# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ConversationProfileAutomatedAgentConfigArgs',
    'ConversationProfileAutomatedAgentConfigArgsDict',
    'ConversationProfileHumanAgentAssistantConfigArgs',
    'ConversationProfileHumanAgentAssistantConfigArgsDict',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigArgs',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigArgsDict',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigArgs',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigArgsDict',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationModelConfigArgs',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationModelConfigArgsDict',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationProcessConfigArgs',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationProcessConfigArgsDict',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigArgs',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigArgsDict',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgs',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgsDict',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgs',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgsDict',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgs',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgsDict',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDocumentQuerySourceArgs',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDocumentQuerySourceArgsDict',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigKnowledgeBaseQuerySourceArgs',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigKnowledgeBaseQuerySourceArgsDict',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigSectionsArgs',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigSectionsArgsDict',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionFeatureArgs',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionFeatureArgsDict',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgs',
    'ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgsDict',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigArgs',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigArgsDict',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigArgs',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigArgsDict',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationModelConfigArgs',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationModelConfigArgsDict',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationProcessConfigArgs',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationProcessConfigArgsDict',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigArgs',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigArgsDict',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgs',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgsDict',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgs',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgsDict',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgs',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgsDict',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigSectionsArgs',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigSectionsArgsDict',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionFeatureArgs',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionFeatureArgsDict',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgs',
    'ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgsDict',
    'ConversationProfileHumanAgentAssistantConfigMessageAnalysisConfigArgs',
    'ConversationProfileHumanAgentAssistantConfigMessageAnalysisConfigArgsDict',
    'ConversationProfileHumanAgentAssistantConfigNotificationConfigArgs',
    'ConversationProfileHumanAgentAssistantConfigNotificationConfigArgsDict',
    'ConversationProfileHumanAgentHandoffConfigArgs',
    'ConversationProfileHumanAgentHandoffConfigArgsDict',
    'ConversationProfileHumanAgentHandoffConfigLivePersonConfigArgs',
    'ConversationProfileHumanAgentHandoffConfigLivePersonConfigArgsDict',
    'ConversationProfileLoggingConfigArgs',
    'ConversationProfileLoggingConfigArgsDict',
    'ConversationProfileNewMessageEventNotificationConfigArgs',
    'ConversationProfileNewMessageEventNotificationConfigArgsDict',
    'ConversationProfileNewRecognitionResultNotificationConfigArgs',
    'ConversationProfileNewRecognitionResultNotificationConfigArgsDict',
    'ConversationProfileNotificationConfigArgs',
    'ConversationProfileNotificationConfigArgsDict',
    'ConversationProfileSttConfigArgs',
    'ConversationProfileSttConfigArgsDict',
    'ConversationProfileTtsConfigArgs',
    'ConversationProfileTtsConfigArgsDict',
    'ConversationProfileTtsConfigVoiceArgs',
    'ConversationProfileTtsConfigVoiceArgsDict',
    'CxAgentAdvancedSettingsArgs',
    'CxAgentAdvancedSettingsArgsDict',
    'CxAgentAdvancedSettingsAudioExportGcsDestinationArgs',
    'CxAgentAdvancedSettingsAudioExportGcsDestinationArgsDict',
    'CxAgentAdvancedSettingsDtmfSettingsArgs',
    'CxAgentAdvancedSettingsDtmfSettingsArgsDict',
    'CxAgentAdvancedSettingsLoggingSettingsArgs',
    'CxAgentAdvancedSettingsLoggingSettingsArgsDict',
    'CxAgentAdvancedSettingsSpeechSettingsArgs',
    'CxAgentAdvancedSettingsSpeechSettingsArgsDict',
    'CxAgentAnswerFeedbackSettingsArgs',
    'CxAgentAnswerFeedbackSettingsArgsDict',
    'CxAgentClientCertificateSettingsArgs',
    'CxAgentClientCertificateSettingsArgsDict',
    'CxAgentGenAppBuilderSettingsArgs',
    'CxAgentGenAppBuilderSettingsArgsDict',
    'CxAgentGitIntegrationSettingsArgs',
    'CxAgentGitIntegrationSettingsArgsDict',
    'CxAgentGitIntegrationSettingsGithubSettingsArgs',
    'CxAgentGitIntegrationSettingsGithubSettingsArgsDict',
    'CxAgentPersonalizationSettingsArgs',
    'CxAgentPersonalizationSettingsArgsDict',
    'CxAgentSpeechToTextSettingsArgs',
    'CxAgentSpeechToTextSettingsArgsDict',
    'CxAgentTextToSpeechSettingsArgs',
    'CxAgentTextToSpeechSettingsArgsDict',
    'CxEntityTypeEntityArgs',
    'CxEntityTypeEntityArgsDict',
    'CxEntityTypeExcludedPhraseArgs',
    'CxEntityTypeExcludedPhraseArgsDict',
    'CxEnvironmentVersionConfigArgs',
    'CxEnvironmentVersionConfigArgsDict',
    'CxFlowAdvancedSettingsArgs',
    'CxFlowAdvancedSettingsArgsDict',
    'CxFlowAdvancedSettingsAudioExportGcsDestinationArgs',
    'CxFlowAdvancedSettingsAudioExportGcsDestinationArgsDict',
    'CxFlowAdvancedSettingsDtmfSettingsArgs',
    'CxFlowAdvancedSettingsDtmfSettingsArgsDict',
    'CxFlowAdvancedSettingsLoggingSettingsArgs',
    'CxFlowAdvancedSettingsLoggingSettingsArgsDict',
    'CxFlowAdvancedSettingsSpeechSettingsArgs',
    'CxFlowAdvancedSettingsSpeechSettingsArgsDict',
    'CxFlowEventHandlerArgs',
    'CxFlowEventHandlerArgsDict',
    'CxFlowEventHandlerTriggerFulfillmentArgs',
    'CxFlowEventHandlerTriggerFulfillmentArgsDict',
    'CxFlowEventHandlerTriggerFulfillmentConditionalCaseArgs',
    'CxFlowEventHandlerTriggerFulfillmentConditionalCaseArgsDict',
    'CxFlowEventHandlerTriggerFulfillmentMessageArgs',
    'CxFlowEventHandlerTriggerFulfillmentMessageArgsDict',
    'CxFlowEventHandlerTriggerFulfillmentMessageConversationSuccessArgs',
    'CxFlowEventHandlerTriggerFulfillmentMessageConversationSuccessArgsDict',
    'CxFlowEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs',
    'CxFlowEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgsDict',
    'CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs',
    'CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioTextArgsDict',
    'CxFlowEventHandlerTriggerFulfillmentMessagePlayAudioArgs',
    'CxFlowEventHandlerTriggerFulfillmentMessagePlayAudioArgsDict',
    'CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs',
    'CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgsDict',
    'CxFlowEventHandlerTriggerFulfillmentMessageTextArgs',
    'CxFlowEventHandlerTriggerFulfillmentMessageTextArgsDict',
    'CxFlowEventHandlerTriggerFulfillmentSetParameterActionArgs',
    'CxFlowEventHandlerTriggerFulfillmentSetParameterActionArgsDict',
    'CxFlowKnowledgeConnectorSettingsArgs',
    'CxFlowKnowledgeConnectorSettingsArgsDict',
    'CxFlowKnowledgeConnectorSettingsDataStoreConnectionArgs',
    'CxFlowKnowledgeConnectorSettingsDataStoreConnectionArgsDict',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentArgs',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentArgsDict',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgs',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgsDict',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgs',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgsDict',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgs',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgsDict',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgs',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgsDict',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgs',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgsDict',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageArgs',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageArgsDict',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgs',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgsDict',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgs',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgsDict',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgs',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgsDict',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgs',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgsDict',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgs',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgsDict',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgs',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgsDict',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgs',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgsDict',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgs',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgsDict',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgs',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgsDict',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgs',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgsDict',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgs',
    'CxFlowKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgsDict',
    'CxFlowNluSettingsArgs',
    'CxFlowNluSettingsArgsDict',
    'CxFlowTransitionRouteArgs',
    'CxFlowTransitionRouteArgsDict',
    'CxFlowTransitionRouteTriggerFulfillmentArgs',
    'CxFlowTransitionRouteTriggerFulfillmentArgsDict',
    'CxFlowTransitionRouteTriggerFulfillmentConditionalCaseArgs',
    'CxFlowTransitionRouteTriggerFulfillmentConditionalCaseArgsDict',
    'CxFlowTransitionRouteTriggerFulfillmentMessageArgs',
    'CxFlowTransitionRouteTriggerFulfillmentMessageArgsDict',
    'CxFlowTransitionRouteTriggerFulfillmentMessageConversationSuccessArgs',
    'CxFlowTransitionRouteTriggerFulfillmentMessageConversationSuccessArgsDict',
    'CxFlowTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgs',
    'CxFlowTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgsDict',
    'CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgs',
    'CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgsDict',
    'CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudioArgs',
    'CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudioArgsDict',
    'CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgs',
    'CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgsDict',
    'CxFlowTransitionRouteTriggerFulfillmentMessageTextArgs',
    'CxFlowTransitionRouteTriggerFulfillmentMessageTextArgsDict',
    'CxFlowTransitionRouteTriggerFulfillmentSetParameterActionArgs',
    'CxFlowTransitionRouteTriggerFulfillmentSetParameterActionArgsDict',
    'CxGenerativeSettingsFallbackSettingsArgs',
    'CxGenerativeSettingsFallbackSettingsArgsDict',
    'CxGenerativeSettingsFallbackSettingsPromptTemplateArgs',
    'CxGenerativeSettingsFallbackSettingsPromptTemplateArgsDict',
    'CxGenerativeSettingsGenerativeSafetySettingsArgs',
    'CxGenerativeSettingsGenerativeSafetySettingsArgsDict',
    'CxGenerativeSettingsGenerativeSafetySettingsBannedPhraseArgs',
    'CxGenerativeSettingsGenerativeSafetySettingsBannedPhraseArgsDict',
    'CxGenerativeSettingsKnowledgeConnectorSettingsArgs',
    'CxGenerativeSettingsKnowledgeConnectorSettingsArgsDict',
    'CxGenerativeSettingsLlmModelSettingsArgs',
    'CxGenerativeSettingsLlmModelSettingsArgsDict',
    'CxGeneratorLlmModelSettingsArgs',
    'CxGeneratorLlmModelSettingsArgsDict',
    'CxGeneratorModelParameterArgs',
    'CxGeneratorModelParameterArgsDict',
    'CxGeneratorPlaceholderArgs',
    'CxGeneratorPlaceholderArgsDict',
    'CxGeneratorPromptTextArgs',
    'CxGeneratorPromptTextArgsDict',
    'CxIntentParameterArgs',
    'CxIntentParameterArgsDict',
    'CxIntentTrainingPhraseArgs',
    'CxIntentTrainingPhraseArgsDict',
    'CxIntentTrainingPhrasePartArgs',
    'CxIntentTrainingPhrasePartArgsDict',
    'CxPageAdvancedSettingsArgs',
    'CxPageAdvancedSettingsArgsDict',
    'CxPageAdvancedSettingsDtmfSettingsArgs',
    'CxPageAdvancedSettingsDtmfSettingsArgsDict',
    'CxPageEntryFulfillmentArgs',
    'CxPageEntryFulfillmentArgsDict',
    'CxPageEntryFulfillmentConditionalCaseArgs',
    'CxPageEntryFulfillmentConditionalCaseArgsDict',
    'CxPageEntryFulfillmentMessageArgs',
    'CxPageEntryFulfillmentMessageArgsDict',
    'CxPageEntryFulfillmentMessageConversationSuccessArgs',
    'CxPageEntryFulfillmentMessageConversationSuccessArgsDict',
    'CxPageEntryFulfillmentMessageLiveAgentHandoffArgs',
    'CxPageEntryFulfillmentMessageLiveAgentHandoffArgsDict',
    'CxPageEntryFulfillmentMessageOutputAudioTextArgs',
    'CxPageEntryFulfillmentMessageOutputAudioTextArgsDict',
    'CxPageEntryFulfillmentMessagePlayAudioArgs',
    'CxPageEntryFulfillmentMessagePlayAudioArgsDict',
    'CxPageEntryFulfillmentMessageTelephonyTransferCallArgs',
    'CxPageEntryFulfillmentMessageTelephonyTransferCallArgsDict',
    'CxPageEntryFulfillmentMessageTextArgs',
    'CxPageEntryFulfillmentMessageTextArgsDict',
    'CxPageEntryFulfillmentSetParameterActionArgs',
    'CxPageEntryFulfillmentSetParameterActionArgsDict',
    'CxPageEventHandlerArgs',
    'CxPageEventHandlerArgsDict',
    'CxPageEventHandlerTriggerFulfillmentArgs',
    'CxPageEventHandlerTriggerFulfillmentArgsDict',
    'CxPageEventHandlerTriggerFulfillmentConditionalCaseArgs',
    'CxPageEventHandlerTriggerFulfillmentConditionalCaseArgsDict',
    'CxPageEventHandlerTriggerFulfillmentMessageArgs',
    'CxPageEventHandlerTriggerFulfillmentMessageArgsDict',
    'CxPageEventHandlerTriggerFulfillmentMessageConversationSuccessArgs',
    'CxPageEventHandlerTriggerFulfillmentMessageConversationSuccessArgsDict',
    'CxPageEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs',
    'CxPageEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgsDict',
    'CxPageEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs',
    'CxPageEventHandlerTriggerFulfillmentMessageOutputAudioTextArgsDict',
    'CxPageEventHandlerTriggerFulfillmentMessagePlayAudioArgs',
    'CxPageEventHandlerTriggerFulfillmentMessagePlayAudioArgsDict',
    'CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs',
    'CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgsDict',
    'CxPageEventHandlerTriggerFulfillmentMessageTextArgs',
    'CxPageEventHandlerTriggerFulfillmentMessageTextArgsDict',
    'CxPageEventHandlerTriggerFulfillmentSetParameterActionArgs',
    'CxPageEventHandlerTriggerFulfillmentSetParameterActionArgsDict',
    'CxPageFormArgs',
    'CxPageFormArgsDict',
    'CxPageFormParameterArgs',
    'CxPageFormParameterArgsDict',
    'CxPageFormParameterAdvancedSettingsArgs',
    'CxPageFormParameterAdvancedSettingsArgsDict',
    'CxPageFormParameterAdvancedSettingsDtmfSettingsArgs',
    'CxPageFormParameterAdvancedSettingsDtmfSettingsArgsDict',
    'CxPageFormParameterFillBehaviorArgs',
    'CxPageFormParameterFillBehaviorArgsDict',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentArgs',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentArgsDict',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentConditionalCaseArgs',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentConditionalCaseArgsDict',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageArgs',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageArgsDict',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageConversationSuccessArgs',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageConversationSuccessArgsDict',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageLiveAgentHandoffArgs',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageLiveAgentHandoffArgsDict',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioTextArgs',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioTextArgsDict',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudioArgs',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudioArgsDict',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCallArgs',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCallArgsDict',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTextArgs',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTextArgsDict',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentSetParameterActionArgs',
    'CxPageFormParameterFillBehaviorInitialPromptFulfillmentSetParameterActionArgsDict',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerArgs',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerArgsDict',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentArgs',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentArgsDict',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentConditionalCaseArgs',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentConditionalCaseArgsDict',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageArgs',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageArgsDict',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageConversationSuccessArgs',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageConversationSuccessArgsDict',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgsDict',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioTextArgsDict',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudioArgs',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudioArgsDict',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgsDict',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTextArgs',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTextArgsDict',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentSetParameterActionArgs',
    'CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentSetParameterActionArgsDict',
    'CxPageKnowledgeConnectorSettingsArgs',
    'CxPageKnowledgeConnectorSettingsArgsDict',
    'CxPageKnowledgeConnectorSettingsDataStoreConnectionArgs',
    'CxPageKnowledgeConnectorSettingsDataStoreConnectionArgsDict',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentArgs',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentArgsDict',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgs',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgsDict',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgs',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgsDict',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgs',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgsDict',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgs',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgsDict',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgs',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgsDict',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageArgs',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageArgsDict',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgs',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgsDict',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgs',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgsDict',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgs',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgsDict',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgs',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgsDict',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgs',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgsDict',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgs',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgsDict',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgs',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgsDict',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgs',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgsDict',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgs',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgsDict',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgs',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgsDict',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgs',
    'CxPageKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgsDict',
    'CxPageTransitionRouteArgs',
    'CxPageTransitionRouteArgsDict',
    'CxPageTransitionRouteTriggerFulfillmentArgs',
    'CxPageTransitionRouteTriggerFulfillmentArgsDict',
    'CxPageTransitionRouteTriggerFulfillmentConditionalCaseArgs',
    'CxPageTransitionRouteTriggerFulfillmentConditionalCaseArgsDict',
    'CxPageTransitionRouteTriggerFulfillmentMessageArgs',
    'CxPageTransitionRouteTriggerFulfillmentMessageArgsDict',
    'CxPageTransitionRouteTriggerFulfillmentMessageConversationSuccessArgs',
    'CxPageTransitionRouteTriggerFulfillmentMessageConversationSuccessArgsDict',
    'CxPageTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgs',
    'CxPageTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgsDict',
    'CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgs',
    'CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgsDict',
    'CxPageTransitionRouteTriggerFulfillmentMessagePlayAudioArgs',
    'CxPageTransitionRouteTriggerFulfillmentMessagePlayAudioArgsDict',
    'CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgs',
    'CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgsDict',
    'CxPageTransitionRouteTriggerFulfillmentMessageTextArgs',
    'CxPageTransitionRouteTriggerFulfillmentMessageTextArgsDict',
    'CxPageTransitionRouteTriggerFulfillmentSetParameterActionArgs',
    'CxPageTransitionRouteTriggerFulfillmentSetParameterActionArgsDict',
    'CxPlaybookInstructionArgs',
    'CxPlaybookInstructionArgsDict',
    'CxPlaybookInstructionStepArgs',
    'CxPlaybookInstructionStepArgsDict',
    'CxPlaybookLlmModelSettingsArgs',
    'CxPlaybookLlmModelSettingsArgsDict',
    'CxSecuritySettingsAudioExportSettingsArgs',
    'CxSecuritySettingsAudioExportSettingsArgsDict',
    'CxSecuritySettingsInsightsExportSettingsArgs',
    'CxSecuritySettingsInsightsExportSettingsArgsDict',
    'CxTestCaseLastTestResultArgs',
    'CxTestCaseLastTestResultArgsDict',
    'CxTestCaseLastTestResultConversationTurnArgs',
    'CxTestCaseLastTestResultConversationTurnArgsDict',
    'CxTestCaseLastTestResultConversationTurnUserInputArgs',
    'CxTestCaseLastTestResultConversationTurnUserInputArgsDict',
    'CxTestCaseLastTestResultConversationTurnUserInputInputArgs',
    'CxTestCaseLastTestResultConversationTurnUserInputInputArgsDict',
    'CxTestCaseLastTestResultConversationTurnUserInputInputDtmfArgs',
    'CxTestCaseLastTestResultConversationTurnUserInputInputDtmfArgsDict',
    'CxTestCaseLastTestResultConversationTurnUserInputInputEventArgs',
    'CxTestCaseLastTestResultConversationTurnUserInputInputEventArgsDict',
    'CxTestCaseLastTestResultConversationTurnUserInputInputTextArgs',
    'CxTestCaseLastTestResultConversationTurnUserInputInputTextArgsDict',
    'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputArgs',
    'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputArgsDict',
    'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPageArgs',
    'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPageArgsDict',
    'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputDifferenceArgs',
    'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputDifferenceArgsDict',
    'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputStatusArgs',
    'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputStatusArgsDict',
    'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTextResponseArgs',
    'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTextResponseArgsDict',
    'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntentArgs',
    'CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntentArgsDict',
    'CxTestCaseTestCaseConversationTurnArgs',
    'CxTestCaseTestCaseConversationTurnArgsDict',
    'CxTestCaseTestCaseConversationTurnUserInputArgs',
    'CxTestCaseTestCaseConversationTurnUserInputArgsDict',
    'CxTestCaseTestCaseConversationTurnUserInputInputArgs',
    'CxTestCaseTestCaseConversationTurnUserInputInputArgsDict',
    'CxTestCaseTestCaseConversationTurnUserInputInputDtmfArgs',
    'CxTestCaseTestCaseConversationTurnUserInputInputDtmfArgsDict',
    'CxTestCaseTestCaseConversationTurnUserInputInputEventArgs',
    'CxTestCaseTestCaseConversationTurnUserInputInputEventArgsDict',
    'CxTestCaseTestCaseConversationTurnUserInputInputTextArgs',
    'CxTestCaseTestCaseConversationTurnUserInputInputTextArgsDict',
    'CxTestCaseTestCaseConversationTurnVirtualAgentOutputArgs',
    'CxTestCaseTestCaseConversationTurnVirtualAgentOutputArgsDict',
    'CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPageArgs',
    'CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPageArgsDict',
    'CxTestCaseTestCaseConversationTurnVirtualAgentOutputTextResponseArgs',
    'CxTestCaseTestCaseConversationTurnVirtualAgentOutputTextResponseArgsDict',
    'CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntentArgs',
    'CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntentArgsDict',
    'CxTestCaseTestConfigArgs',
    'CxTestCaseTestConfigArgsDict',
    'CxToolConnectorSpecArgs',
    'CxToolConnectorSpecArgsDict',
    'CxToolConnectorSpecActionArgs',
    'CxToolConnectorSpecActionArgsDict',
    'CxToolConnectorSpecActionEntityOperationArgs',
    'CxToolConnectorSpecActionEntityOperationArgsDict',
    'CxToolConnectorSpecEndUserAuthConfigArgs',
    'CxToolConnectorSpecEndUserAuthConfigArgsDict',
    'CxToolConnectorSpecEndUserAuthConfigOauth2AuthCodeConfigArgs',
    'CxToolConnectorSpecEndUserAuthConfigOauth2AuthCodeConfigArgsDict',
    'CxToolConnectorSpecEndUserAuthConfigOauth2JwtBearerConfigArgs',
    'CxToolConnectorSpecEndUserAuthConfigOauth2JwtBearerConfigArgsDict',
    'CxToolDataStoreSpecArgs',
    'CxToolDataStoreSpecArgsDict',
    'CxToolDataStoreSpecDataStoreConnectionArgs',
    'CxToolDataStoreSpecDataStoreConnectionArgsDict',
    'CxToolDataStoreSpecFallbackPromptArgs',
    'CxToolDataStoreSpecFallbackPromptArgsDict',
    'CxToolFunctionSpecArgs',
    'CxToolFunctionSpecArgsDict',
    'CxToolOpenApiSpecArgs',
    'CxToolOpenApiSpecArgsDict',
    'CxToolOpenApiSpecAuthenticationArgs',
    'CxToolOpenApiSpecAuthenticationArgsDict',
    'CxToolOpenApiSpecAuthenticationApiKeyConfigArgs',
    'CxToolOpenApiSpecAuthenticationApiKeyConfigArgsDict',
    'CxToolOpenApiSpecAuthenticationBearerTokenConfigArgs',
    'CxToolOpenApiSpecAuthenticationBearerTokenConfigArgsDict',
    'CxToolOpenApiSpecAuthenticationOauthConfigArgs',
    'CxToolOpenApiSpecAuthenticationOauthConfigArgsDict',
    'CxToolOpenApiSpecAuthenticationServiceAgentAuthConfigArgs',
    'CxToolOpenApiSpecAuthenticationServiceAgentAuthConfigArgsDict',
    'CxToolOpenApiSpecServiceDirectoryConfigArgs',
    'CxToolOpenApiSpecServiceDirectoryConfigArgsDict',
    'CxToolOpenApiSpecTlsConfigArgs',
    'CxToolOpenApiSpecTlsConfigArgsDict',
    'CxToolOpenApiSpecTlsConfigCaCertArgs',
    'CxToolOpenApiSpecTlsConfigCaCertArgsDict',
    'CxVersionNluSettingArgs',
    'CxVersionNluSettingArgsDict',
    'CxWebhookGenericWebServiceArgs',
    'CxWebhookGenericWebServiceArgsDict',
    'CxWebhookGenericWebServiceOauthConfigArgs',
    'CxWebhookGenericWebServiceOauthConfigArgsDict',
    'CxWebhookGenericWebServiceSecretVersionsForRequestHeaderArgs',
    'CxWebhookGenericWebServiceSecretVersionsForRequestHeaderArgsDict',
    'CxWebhookServiceDirectoryArgs',
    'CxWebhookServiceDirectoryArgsDict',
    'CxWebhookServiceDirectoryGenericWebServiceArgs',
    'CxWebhookServiceDirectoryGenericWebServiceArgsDict',
    'CxWebhookServiceDirectoryGenericWebServiceOauthConfigArgs',
    'CxWebhookServiceDirectoryGenericWebServiceOauthConfigArgsDict',
    'CxWebhookServiceDirectoryGenericWebServiceSecretVersionsForRequestHeaderArgs',
    'CxWebhookServiceDirectoryGenericWebServiceSecretVersionsForRequestHeaderArgsDict',
    'EncryptionSpecEncryptionSpecArgs',
    'EncryptionSpecEncryptionSpecArgsDict',
    'EntityTypeEntityArgs',
    'EntityTypeEntityArgsDict',
    'FulfillmentFeatureArgs',
    'FulfillmentFeatureArgsDict',
    'FulfillmentGenericWebServiceArgs',
    'FulfillmentGenericWebServiceArgsDict',
    'GeneratorInferenceParameterArgs',
    'GeneratorInferenceParameterArgsDict',
    'GeneratorSummarizationContextArgs',
    'GeneratorSummarizationContextArgsDict',
    'GeneratorSummarizationContextFewShotExampleArgs',
    'GeneratorSummarizationContextFewShotExampleArgsDict',
    'GeneratorSummarizationContextFewShotExampleConversationContextArgs',
    'GeneratorSummarizationContextFewShotExampleConversationContextArgsDict',
    'GeneratorSummarizationContextFewShotExampleConversationContextMessageEntryArgs',
    'GeneratorSummarizationContextFewShotExampleConversationContextMessageEntryArgsDict',
    'GeneratorSummarizationContextFewShotExampleOutputArgs',
    'GeneratorSummarizationContextFewShotExampleOutputArgsDict',
    'GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionArgs',
    'GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionArgsDict',
    'GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionSummarySectionArgs',
    'GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionSummarySectionArgsDict',
    'GeneratorSummarizationContextFewShotExampleSummarizationSectionListArgs',
    'GeneratorSummarizationContextFewShotExampleSummarizationSectionListArgsDict',
    'GeneratorSummarizationContextFewShotExampleSummarizationSectionListSummarizationSectionArgs',
    'GeneratorSummarizationContextFewShotExampleSummarizationSectionListSummarizationSectionArgsDict',
    'GeneratorSummarizationContextSummarizationSectionArgs',
    'GeneratorSummarizationContextSummarizationSectionArgsDict',
    'IntentFollowupIntentInfoArgs',
    'IntentFollowupIntentInfoArgsDict',
]

MYPY = False

if not MYPY:
    class ConversationProfileAutomatedAgentConfigArgsDict(TypedDict):
        agent: pulumi.Input[_builtins.str]
        """
        ID of the Dialogflow agent environment to use.
        Expects the format "projects/<Project ID>/locations/<Location ID>/agent/environments/<EnvironmentID>"
        """
        session_ttl: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configure lifetime of the Dialogflow session.
        """
elif False:
    ConversationProfileAutomatedAgentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileAutomatedAgentConfigArgs:
    def __init__(__self__, *,
                 agent: pulumi.Input[_builtins.str],
                 session_ttl: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] agent: ID of the Dialogflow agent environment to use.
               Expects the format "projects/<Project ID>/locations/<Location ID>/agent/environments/<EnvironmentID>"
        :param pulumi.Input[_builtins.str] session_ttl: Configure lifetime of the Dialogflow session.
        """
        pulumi.set(__self__, "agent", agent)
        if session_ttl is not None:
            pulumi.set(__self__, "session_ttl", session_ttl)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the Dialogflow agent environment to use.
        Expects the format "projects/<Project ID>/locations/<Location ID>/agent/environments/<EnvironmentID>"
        """
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agent", value)

    @_builtins.property
    @pulumi.getter(name="sessionTtl")
    def session_ttl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configure lifetime of the Dialogflow session.
        """
        return pulumi.get(self, "session_ttl")

    @session_ttl.setter
    def session_ttl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "session_ttl", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigArgsDict(TypedDict):
        end_user_suggestion_config: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigArgsDict']]
        """
        Configuration for agent assistance of end user participant.
        Structure is documented below.
        """
        human_agent_suggestion_config: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigArgsDict']]
        """
        Configuration for agent assistance of human agent participant.
        Structure is documented below.
        """
        message_analysis_config: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigMessageAnalysisConfigArgsDict']]
        """
        desc
        Structure is documented below.
        """
        notification_config: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigNotificationConfigArgsDict']]
        """
        Pub/Sub topic on which to publish new agent assistant events.
        Expects the format "projects/<Project ID>/locations/<Location ID>/topics/<Topic ID>"
        Structure is documented below.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigArgs:
    def __init__(__self__, *,
                 end_user_suggestion_config: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigArgs']] = None,
                 human_agent_suggestion_config: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigArgs']] = None,
                 message_analysis_config: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigMessageAnalysisConfigArgs']] = None,
                 notification_config: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigNotificationConfigArgs']] = None):
        """
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigArgs'] end_user_suggestion_config: Configuration for agent assistance of end user participant.
               Structure is documented below.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigArgs'] human_agent_suggestion_config: Configuration for agent assistance of human agent participant.
               Structure is documented below.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigMessageAnalysisConfigArgs'] message_analysis_config: desc
               Structure is documented below.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigNotificationConfigArgs'] notification_config: Pub/Sub topic on which to publish new agent assistant events.
               Expects the format "projects/<Project ID>/locations/<Location ID>/topics/<Topic ID>"
               Structure is documented below.
        """
        if end_user_suggestion_config is not None:
            pulumi.set(__self__, "end_user_suggestion_config", end_user_suggestion_config)
        if human_agent_suggestion_config is not None:
            pulumi.set(__self__, "human_agent_suggestion_config", human_agent_suggestion_config)
        if message_analysis_config is not None:
            pulumi.set(__self__, "message_analysis_config", message_analysis_config)
        if notification_config is not None:
            pulumi.set(__self__, "notification_config", notification_config)

    @_builtins.property
    @pulumi.getter(name="endUserSuggestionConfig")
    def end_user_suggestion_config(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigArgs']]:
        """
        Configuration for agent assistance of end user participant.
        Structure is documented below.
        """
        return pulumi.get(self, "end_user_suggestion_config")

    @end_user_suggestion_config.setter
    def end_user_suggestion_config(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigArgs']]):
        pulumi.set(self, "end_user_suggestion_config", value)

    @_builtins.property
    @pulumi.getter(name="humanAgentSuggestionConfig")
    def human_agent_suggestion_config(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigArgs']]:
        """
        Configuration for agent assistance of human agent participant.
        Structure is documented below.
        """
        return pulumi.get(self, "human_agent_suggestion_config")

    @human_agent_suggestion_config.setter
    def human_agent_suggestion_config(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigArgs']]):
        pulumi.set(self, "human_agent_suggestion_config", value)

    @_builtins.property
    @pulumi.getter(name="messageAnalysisConfig")
    def message_analysis_config(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigMessageAnalysisConfigArgs']]:
        """
        desc
        Structure is documented below.
        """
        return pulumi.get(self, "message_analysis_config")

    @message_analysis_config.setter
    def message_analysis_config(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigMessageAnalysisConfigArgs']]):
        pulumi.set(self, "message_analysis_config", value)

    @_builtins.property
    @pulumi.getter(name="notificationConfig")
    def notification_config(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigNotificationConfigArgs']]:
        """
        Pub/Sub topic on which to publish new agent assistant events.
        Expects the format "projects/<Project ID>/locations/<Location ID>/topics/<Topic ID>"
        Structure is documented below.
        """
        return pulumi.get(self, "notification_config")

    @notification_config.setter
    def notification_config(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigNotificationConfigArgs']]):
        pulumi.set(self, "notification_config", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigArgsDict(TypedDict):
        disable_high_latency_features_sync_delivery: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When disableHighLatencyFeaturesSyncDelivery is true and using the AnalyzeContent API, we will not deliver the responses from high latency features in the API response. The humanAgentAssistantConfig.notification_config must be configured and enableEventBasedSuggestion must be set to true to receive the responses from high latency features in Pub/Sub. High latency feature(s): KNOWLEDGE_ASSIST
        """
        feature_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigArgsDict']]]]
        """
        Configuration of different suggestion features. One feature can have only one config.
        Structure is documented below.
        """
        generators: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of various generator resource names used in the conversation profile.
        """
        group_suggestion_responses: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If groupSuggestionResponses is false, and there are multiple featureConfigs in event based suggestion or StreamingAnalyzeContent, we will try to deliver suggestions to customers as soon as we get new suggestion. Different type of suggestions based on the same context will be in separate Pub/Sub event or StreamingAnalyzeContentResponse.
        If groupSuggestionResponses set to true. All the suggestions to the same participant based on the same context will be grouped into a single Pub/Sub event or StreamingAnalyzeContentResponse.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigArgs:
    def __init__(__self__, *,
                 disable_high_latency_features_sync_delivery: Optional[pulumi.Input[_builtins.bool]] = None,
                 feature_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigArgs']]]] = None,
                 generators: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 group_suggestion_responses: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] disable_high_latency_features_sync_delivery: When disableHighLatencyFeaturesSyncDelivery is true and using the AnalyzeContent API, we will not deliver the responses from high latency features in the API response. The humanAgentAssistantConfig.notification_config must be configured and enableEventBasedSuggestion must be set to true to receive the responses from high latency features in Pub/Sub. High latency feature(s): KNOWLEDGE_ASSIST
        :param pulumi.Input[Sequence[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigArgs']]] feature_configs: Configuration of different suggestion features. One feature can have only one config.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] generators: List of various generator resource names used in the conversation profile.
        :param pulumi.Input[_builtins.bool] group_suggestion_responses: If groupSuggestionResponses is false, and there are multiple featureConfigs in event based suggestion or StreamingAnalyzeContent, we will try to deliver suggestions to customers as soon as we get new suggestion. Different type of suggestions based on the same context will be in separate Pub/Sub event or StreamingAnalyzeContentResponse.
               If groupSuggestionResponses set to true. All the suggestions to the same participant based on the same context will be grouped into a single Pub/Sub event or StreamingAnalyzeContentResponse.
        """
        if disable_high_latency_features_sync_delivery is not None:
            pulumi.set(__self__, "disable_high_latency_features_sync_delivery", disable_high_latency_features_sync_delivery)
        if feature_configs is not None:
            pulumi.set(__self__, "feature_configs", feature_configs)
        if generators is not None:
            pulumi.set(__self__, "generators", generators)
        if group_suggestion_responses is not None:
            pulumi.set(__self__, "group_suggestion_responses", group_suggestion_responses)

    @_builtins.property
    @pulumi.getter(name="disableHighLatencyFeaturesSyncDelivery")
    def disable_high_latency_features_sync_delivery(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When disableHighLatencyFeaturesSyncDelivery is true and using the AnalyzeContent API, we will not deliver the responses from high latency features in the API response. The humanAgentAssistantConfig.notification_config must be configured and enableEventBasedSuggestion must be set to true to receive the responses from high latency features in Pub/Sub. High latency feature(s): KNOWLEDGE_ASSIST
        """
        return pulumi.get(self, "disable_high_latency_features_sync_delivery")

    @disable_high_latency_features_sync_delivery.setter
    def disable_high_latency_features_sync_delivery(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_high_latency_features_sync_delivery", value)

    @_builtins.property
    @pulumi.getter(name="featureConfigs")
    def feature_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigArgs']]]]:
        """
        Configuration of different suggestion features. One feature can have only one config.
        Structure is documented below.
        """
        return pulumi.get(self, "feature_configs")

    @feature_configs.setter
    def feature_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigArgs']]]]):
        pulumi.set(self, "feature_configs", value)

    @_builtins.property
    @pulumi.getter
    def generators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of various generator resource names used in the conversation profile.
        """
        return pulumi.get(self, "generators")

    @generators.setter
    def generators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "generators", value)

    @_builtins.property
    @pulumi.getter(name="groupSuggestionResponses")
    def group_suggestion_responses(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If groupSuggestionResponses is false, and there are multiple featureConfigs in event based suggestion or StreamingAnalyzeContent, we will try to deliver suggestions to customers as soon as we get new suggestion. Different type of suggestions based on the same context will be in separate Pub/Sub event or StreamingAnalyzeContentResponse.
        If groupSuggestionResponses set to true. All the suggestions to the same participant based on the same context will be grouped into a single Pub/Sub event or StreamingAnalyzeContentResponse.
        """
        return pulumi.get(self, "group_suggestion_responses")

    @group_suggestion_responses.setter
    def group_suggestion_responses(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "group_suggestion_responses", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigArgsDict(TypedDict):
        conversation_model_config: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationModelConfigArgsDict']]
        """
        Configs of custom conversation model.
        Structure is documented below.
        """
        conversation_process_config: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationProcessConfigArgsDict']]
        """
        Config to process conversation.
        Structure is documented below.
        """
        disable_agent_query_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable the logging of search queries sent by human agents. It can prevent those queries from being stored at answer records.
        This feature is only supported for types: KNOWLEDGE_SEARCH.
        """
        enable_conversation_augmented_query: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable including conversation context during query answer generation.
        This feature is only supported for types: KNOWLEDGE_SEARCH.
        """
        enable_event_based_suggestion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Automatically iterates all participants and tries to compile suggestions.
        This feature is only supported for types: ARTICLE_SUGGESTION, FAQ, DIALOGFLOW_ASSIST, KNOWLEDGE_ASSIST.
        """
        enable_query_suggestion_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable query suggestion only.
        This feature is only supported for types: KNOWLEDGE_ASSIST
        """
        enable_query_suggestion_when_no_answer: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable query suggestion even if we can't find its answer. By default, queries are suggested only if we find its answer.
        This feature is only supported for types: KNOWLEDGE_ASSIST.
        """
        query_config: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigArgsDict']]
        """
        Configs of query.
        Structure is documented below.
        """
        suggestion_feature: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionFeatureArgsDict']]
        """
        The suggestion feature.
        Structure is documented below.
        """
        suggestion_trigger_settings: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgsDict']]
        """
        Settings of suggestion trigger.
        This feature is only supported for types: ARTICLE_SUGGESTION, FAQ.
        Structure is documented below.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigArgs:
    def __init__(__self__, *,
                 conversation_model_config: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationModelConfigArgs']] = None,
                 conversation_process_config: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationProcessConfigArgs']] = None,
                 disable_agent_query_logging: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_conversation_augmented_query: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_event_based_suggestion: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_query_suggestion_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_query_suggestion_when_no_answer: Optional[pulumi.Input[_builtins.bool]] = None,
                 query_config: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigArgs']] = None,
                 suggestion_feature: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionFeatureArgs']] = None,
                 suggestion_trigger_settings: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgs']] = None):
        """
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationModelConfigArgs'] conversation_model_config: Configs of custom conversation model.
               Structure is documented below.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationProcessConfigArgs'] conversation_process_config: Config to process conversation.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] disable_agent_query_logging: Disable the logging of search queries sent by human agents. It can prevent those queries from being stored at answer records.
               This feature is only supported for types: KNOWLEDGE_SEARCH.
        :param pulumi.Input[_builtins.bool] enable_conversation_augmented_query: Enable including conversation context during query answer generation.
               This feature is only supported for types: KNOWLEDGE_SEARCH.
        :param pulumi.Input[_builtins.bool] enable_event_based_suggestion: Automatically iterates all participants and tries to compile suggestions.
               This feature is only supported for types: ARTICLE_SUGGESTION, FAQ, DIALOGFLOW_ASSIST, KNOWLEDGE_ASSIST.
        :param pulumi.Input[_builtins.bool] enable_query_suggestion_only: Enable query suggestion only.
               This feature is only supported for types: KNOWLEDGE_ASSIST
        :param pulumi.Input[_builtins.bool] enable_query_suggestion_when_no_answer: Enable query suggestion even if we can't find its answer. By default, queries are suggested only if we find its answer.
               This feature is only supported for types: KNOWLEDGE_ASSIST.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigArgs'] query_config: Configs of query.
               Structure is documented below.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionFeatureArgs'] suggestion_feature: The suggestion feature.
               Structure is documented below.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgs'] suggestion_trigger_settings: Settings of suggestion trigger.
               This feature is only supported for types: ARTICLE_SUGGESTION, FAQ.
               Structure is documented below.
        """
        if conversation_model_config is not None:
            pulumi.set(__self__, "conversation_model_config", conversation_model_config)
        if conversation_process_config is not None:
            pulumi.set(__self__, "conversation_process_config", conversation_process_config)
        if disable_agent_query_logging is not None:
            pulumi.set(__self__, "disable_agent_query_logging", disable_agent_query_logging)
        if enable_conversation_augmented_query is not None:
            pulumi.set(__self__, "enable_conversation_augmented_query", enable_conversation_augmented_query)
        if enable_event_based_suggestion is not None:
            pulumi.set(__self__, "enable_event_based_suggestion", enable_event_based_suggestion)
        if enable_query_suggestion_only is not None:
            pulumi.set(__self__, "enable_query_suggestion_only", enable_query_suggestion_only)
        if enable_query_suggestion_when_no_answer is not None:
            pulumi.set(__self__, "enable_query_suggestion_when_no_answer", enable_query_suggestion_when_no_answer)
        if query_config is not None:
            pulumi.set(__self__, "query_config", query_config)
        if suggestion_feature is not None:
            pulumi.set(__self__, "suggestion_feature", suggestion_feature)
        if suggestion_trigger_settings is not None:
            pulumi.set(__self__, "suggestion_trigger_settings", suggestion_trigger_settings)

    @_builtins.property
    @pulumi.getter(name="conversationModelConfig")
    def conversation_model_config(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationModelConfigArgs']]:
        """
        Configs of custom conversation model.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_model_config")

    @conversation_model_config.setter
    def conversation_model_config(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationModelConfigArgs']]):
        pulumi.set(self, "conversation_model_config", value)

    @_builtins.property
    @pulumi.getter(name="conversationProcessConfig")
    def conversation_process_config(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationProcessConfigArgs']]:
        """
        Config to process conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_process_config")

    @conversation_process_config.setter
    def conversation_process_config(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationProcessConfigArgs']]):
        pulumi.set(self, "conversation_process_config", value)

    @_builtins.property
    @pulumi.getter(name="disableAgentQueryLogging")
    def disable_agent_query_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable the logging of search queries sent by human agents. It can prevent those queries from being stored at answer records.
        This feature is only supported for types: KNOWLEDGE_SEARCH.
        """
        return pulumi.get(self, "disable_agent_query_logging")

    @disable_agent_query_logging.setter
    def disable_agent_query_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_agent_query_logging", value)

    @_builtins.property
    @pulumi.getter(name="enableConversationAugmentedQuery")
    def enable_conversation_augmented_query(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable including conversation context during query answer generation.
        This feature is only supported for types: KNOWLEDGE_SEARCH.
        """
        return pulumi.get(self, "enable_conversation_augmented_query")

    @enable_conversation_augmented_query.setter
    def enable_conversation_augmented_query(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_conversation_augmented_query", value)

    @_builtins.property
    @pulumi.getter(name="enableEventBasedSuggestion")
    def enable_event_based_suggestion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Automatically iterates all participants and tries to compile suggestions.
        This feature is only supported for types: ARTICLE_SUGGESTION, FAQ, DIALOGFLOW_ASSIST, KNOWLEDGE_ASSIST.
        """
        return pulumi.get(self, "enable_event_based_suggestion")

    @enable_event_based_suggestion.setter
    def enable_event_based_suggestion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_event_based_suggestion", value)

    @_builtins.property
    @pulumi.getter(name="enableQuerySuggestionOnly")
    def enable_query_suggestion_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable query suggestion only.
        This feature is only supported for types: KNOWLEDGE_ASSIST
        """
        return pulumi.get(self, "enable_query_suggestion_only")

    @enable_query_suggestion_only.setter
    def enable_query_suggestion_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_query_suggestion_only", value)

    @_builtins.property
    @pulumi.getter(name="enableQuerySuggestionWhenNoAnswer")
    def enable_query_suggestion_when_no_answer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable query suggestion even if we can't find its answer. By default, queries are suggested only if we find its answer.
        This feature is only supported for types: KNOWLEDGE_ASSIST.
        """
        return pulumi.get(self, "enable_query_suggestion_when_no_answer")

    @enable_query_suggestion_when_no_answer.setter
    def enable_query_suggestion_when_no_answer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_query_suggestion_when_no_answer", value)

    @_builtins.property
    @pulumi.getter(name="queryConfig")
    def query_config(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigArgs']]:
        """
        Configs of query.
        Structure is documented below.
        """
        return pulumi.get(self, "query_config")

    @query_config.setter
    def query_config(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigArgs']]):
        pulumi.set(self, "query_config", value)

    @_builtins.property
    @pulumi.getter(name="suggestionFeature")
    def suggestion_feature(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionFeatureArgs']]:
        """
        The suggestion feature.
        Structure is documented below.
        """
        return pulumi.get(self, "suggestion_feature")

    @suggestion_feature.setter
    def suggestion_feature(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionFeatureArgs']]):
        pulumi.set(self, "suggestion_feature", value)

    @_builtins.property
    @pulumi.getter(name="suggestionTriggerSettings")
    def suggestion_trigger_settings(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgs']]:
        """
        Settings of suggestion trigger.
        This feature is only supported for types: ARTICLE_SUGGESTION, FAQ.
        Structure is documented below.
        """
        return pulumi.get(self, "suggestion_trigger_settings")

    @suggestion_trigger_settings.setter
    def suggestion_trigger_settings(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgs']]):
        pulumi.set(self, "suggestion_trigger_settings", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationModelConfigArgsDict(TypedDict):
        baseline_model_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version of current baseline model. It will be ignored if model is set. Valid versions are: Article Suggestion baseline model: - 0.9 - 1.0 (default) Summarization baseline model: - 1.0
        """
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        Conversation model resource name. Format: projects/<Project ID>/conversationModels/<Model ID>.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationModelConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationModelConfigArgs:
    def __init__(__self__, *,
                 baseline_model_version: Optional[pulumi.Input[_builtins.str]] = None,
                 model: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] baseline_model_version: Version of current baseline model. It will be ignored if model is set. Valid versions are: Article Suggestion baseline model: - 0.9 - 1.0 (default) Summarization baseline model: - 1.0
        :param pulumi.Input[_builtins.str] model: Conversation model resource name. Format: projects/<Project ID>/conversationModels/<Model ID>.
        """
        if baseline_model_version is not None:
            pulumi.set(__self__, "baseline_model_version", baseline_model_version)
        if model is not None:
            pulumi.set(__self__, "model", model)

    @_builtins.property
    @pulumi.getter(name="baselineModelVersion")
    def baseline_model_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version of current baseline model. It will be ignored if model is set. Valid versions are: Article Suggestion baseline model: - 0.9 - 1.0 (default) Summarization baseline model: - 1.0
        """
        return pulumi.get(self, "baseline_model_version")

    @baseline_model_version.setter
    def baseline_model_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "baseline_model_version", value)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Conversation model resource name. Format: projects/<Project ID>/conversationModels/<Model ID>.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationProcessConfigArgsDict(TypedDict):
        recent_sentences_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of recent non-small-talk sentences to use as context for article and FAQ suggestion
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationProcessConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigConversationProcessConfigArgs:
    def __init__(__self__, *,
                 recent_sentences_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] recent_sentences_count: Number of recent non-small-talk sentences to use as context for article and FAQ suggestion
        """
        if recent_sentences_count is not None:
            pulumi.set(__self__, "recent_sentences_count", recent_sentences_count)

    @_builtins.property
    @pulumi.getter(name="recentSentencesCount")
    def recent_sentences_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of recent non-small-talk sentences to use as context for article and FAQ suggestion
        """
        return pulumi.get(self, "recent_sentences_count")

    @recent_sentences_count.setter
    def recent_sentences_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "recent_sentences_count", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigArgsDict(TypedDict):
        confidence_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        Confidence threshold of query result.
        This feature is only supported for types: ARTICLE_SUGGESTION, FAQ, SMART_REPLY, SMART_COMPOSE, KNOWLEDGE_SEARCH, KNOWLEDGE_ASSIST, ENTITY_EXTRACTION.
        """
        context_filter_settings: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgsDict']]
        """
        Determines how recent conversation context is filtered when generating suggestions. If unspecified, no messages will be dropped.
        Structure is documented below.
        """
        dialogflow_query_source: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgsDict']]
        """
        Query from Dialogflow agent.
        This feature is supported for types: DIALOGFLOW_ASSIST.
        Structure is documented below.
        """
        document_query_source: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDocumentQuerySourceArgsDict']]
        """
        Query from knowledge base document.
        This feature is supported for types: SMART_REPLY, SMART_COMPOSE.
        Structure is documented below.
        """
        knowledge_base_query_source: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigKnowledgeBaseQuerySourceArgsDict']]
        """
        Query from knowledgebase.
        This feature is only supported for types: ARTICLE_SUGGESTION, FAQ.
        Structure is documented below.
        """
        max_results: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of results to return.
        """
        sections: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigSectionsArgsDict']]
        """
        he customized sections chosen to return when requesting a summary of a conversation.
        Structure is documented below.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigArgs:
    def __init__(__self__, *,
                 confidence_threshold: Optional[pulumi.Input[_builtins.float]] = None,
                 context_filter_settings: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgs']] = None,
                 dialogflow_query_source: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgs']] = None,
                 document_query_source: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDocumentQuerySourceArgs']] = None,
                 knowledge_base_query_source: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigKnowledgeBaseQuerySourceArgs']] = None,
                 max_results: Optional[pulumi.Input[_builtins.int]] = None,
                 sections: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigSectionsArgs']] = None):
        """
        :param pulumi.Input[_builtins.float] confidence_threshold: Confidence threshold of query result.
               This feature is only supported for types: ARTICLE_SUGGESTION, FAQ, SMART_REPLY, SMART_COMPOSE, KNOWLEDGE_SEARCH, KNOWLEDGE_ASSIST, ENTITY_EXTRACTION.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgs'] context_filter_settings: Determines how recent conversation context is filtered when generating suggestions. If unspecified, no messages will be dropped.
               Structure is documented below.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgs'] dialogflow_query_source: Query from Dialogflow agent.
               This feature is supported for types: DIALOGFLOW_ASSIST.
               Structure is documented below.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDocumentQuerySourceArgs'] document_query_source: Query from knowledge base document.
               This feature is supported for types: SMART_REPLY, SMART_COMPOSE.
               Structure is documented below.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigKnowledgeBaseQuerySourceArgs'] knowledge_base_query_source: Query from knowledgebase.
               This feature is only supported for types: ARTICLE_SUGGESTION, FAQ.
               Structure is documented below.
        :param pulumi.Input[_builtins.int] max_results: Maximum number of results to return.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigSectionsArgs'] sections: he customized sections chosen to return when requesting a summary of a conversation.
               Structure is documented below.
        """
        if confidence_threshold is not None:
            pulumi.set(__self__, "confidence_threshold", confidence_threshold)
        if context_filter_settings is not None:
            pulumi.set(__self__, "context_filter_settings", context_filter_settings)
        if dialogflow_query_source is not None:
            pulumi.set(__self__, "dialogflow_query_source", dialogflow_query_source)
        if document_query_source is not None:
            pulumi.set(__self__, "document_query_source", document_query_source)
        if knowledge_base_query_source is not None:
            pulumi.set(__self__, "knowledge_base_query_source", knowledge_base_query_source)
        if max_results is not None:
            pulumi.set(__self__, "max_results", max_results)
        if sections is not None:
            pulumi.set(__self__, "sections", sections)

    @_builtins.property
    @pulumi.getter(name="confidenceThreshold")
    def confidence_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Confidence threshold of query result.
        This feature is only supported for types: ARTICLE_SUGGESTION, FAQ, SMART_REPLY, SMART_COMPOSE, KNOWLEDGE_SEARCH, KNOWLEDGE_ASSIST, ENTITY_EXTRACTION.
        """
        return pulumi.get(self, "confidence_threshold")

    @confidence_threshold.setter
    def confidence_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "confidence_threshold", value)

    @_builtins.property
    @pulumi.getter(name="contextFilterSettings")
    def context_filter_settings(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgs']]:
        """
        Determines how recent conversation context is filtered when generating suggestions. If unspecified, no messages will be dropped.
        Structure is documented below.
        """
        return pulumi.get(self, "context_filter_settings")

    @context_filter_settings.setter
    def context_filter_settings(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgs']]):
        pulumi.set(self, "context_filter_settings", value)

    @_builtins.property
    @pulumi.getter(name="dialogflowQuerySource")
    def dialogflow_query_source(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgs']]:
        """
        Query from Dialogflow agent.
        This feature is supported for types: DIALOGFLOW_ASSIST.
        Structure is documented below.
        """
        return pulumi.get(self, "dialogflow_query_source")

    @dialogflow_query_source.setter
    def dialogflow_query_source(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgs']]):
        pulumi.set(self, "dialogflow_query_source", value)

    @_builtins.property
    @pulumi.getter(name="documentQuerySource")
    def document_query_source(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDocumentQuerySourceArgs']]:
        """
        Query from knowledge base document.
        This feature is supported for types: SMART_REPLY, SMART_COMPOSE.
        Structure is documented below.
        """
        return pulumi.get(self, "document_query_source")

    @document_query_source.setter
    def document_query_source(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDocumentQuerySourceArgs']]):
        pulumi.set(self, "document_query_source", value)

    @_builtins.property
    @pulumi.getter(name="knowledgeBaseQuerySource")
    def knowledge_base_query_source(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigKnowledgeBaseQuerySourceArgs']]:
        """
        Query from knowledgebase.
        This feature is only supported for types: ARTICLE_SUGGESTION, FAQ.
        Structure is documented below.
        """
        return pulumi.get(self, "knowledge_base_query_source")

    @knowledge_base_query_source.setter
    def knowledge_base_query_source(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigKnowledgeBaseQuerySourceArgs']]):
        pulumi.set(self, "knowledge_base_query_source", value)

    @_builtins.property
    @pulumi.getter(name="maxResults")
    def max_results(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of results to return.
        """
        return pulumi.get(self, "max_results")

    @max_results.setter
    def max_results(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_results", value)

    @_builtins.property
    @pulumi.getter
    def sections(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigSectionsArgs']]:
        """
        he customized sections chosen to return when requesting a summary of a conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "sections")

    @sections.setter
    def sections(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigSectionsArgs']]):
        pulumi.set(self, "sections", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgsDict(TypedDict):
        drop_handoff_messages: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set to true, the last message from virtual agent (hand off message) and the message before it (trigger message of hand off) are dropped.
        """
        drop_ivr_messages: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set to true, all messages from ivr stage are dropped.
        """
        drop_virtual_agent_messages: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set to true, all messages from virtual agent are dropped.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgs:
    def __init__(__self__, *,
                 drop_handoff_messages: Optional[pulumi.Input[_builtins.bool]] = None,
                 drop_ivr_messages: Optional[pulumi.Input[_builtins.bool]] = None,
                 drop_virtual_agent_messages: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] drop_handoff_messages: If set to true, the last message from virtual agent (hand off message) and the message before it (trigger message of hand off) are dropped.
        :param pulumi.Input[_builtins.bool] drop_ivr_messages: If set to true, all messages from ivr stage are dropped.
        :param pulumi.Input[_builtins.bool] drop_virtual_agent_messages: If set to true, all messages from virtual agent are dropped.
        """
        if drop_handoff_messages is not None:
            pulumi.set(__self__, "drop_handoff_messages", drop_handoff_messages)
        if drop_ivr_messages is not None:
            pulumi.set(__self__, "drop_ivr_messages", drop_ivr_messages)
        if drop_virtual_agent_messages is not None:
            pulumi.set(__self__, "drop_virtual_agent_messages", drop_virtual_agent_messages)

    @_builtins.property
    @pulumi.getter(name="dropHandoffMessages")
    def drop_handoff_messages(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to true, the last message from virtual agent (hand off message) and the message before it (trigger message of hand off) are dropped.
        """
        return pulumi.get(self, "drop_handoff_messages")

    @drop_handoff_messages.setter
    def drop_handoff_messages(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "drop_handoff_messages", value)

    @_builtins.property
    @pulumi.getter(name="dropIvrMessages")
    def drop_ivr_messages(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to true, all messages from ivr stage are dropped.
        """
        return pulumi.get(self, "drop_ivr_messages")

    @drop_ivr_messages.setter
    def drop_ivr_messages(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "drop_ivr_messages", value)

    @_builtins.property
    @pulumi.getter(name="dropVirtualAgentMessages")
    def drop_virtual_agent_messages(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to true, all messages from virtual agent are dropped.
        """
        return pulumi.get(self, "drop_virtual_agent_messages")

    @drop_virtual_agent_messages.setter
    def drop_virtual_agent_messages(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "drop_virtual_agent_messages", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgsDict(TypedDict):
        agent: pulumi.Input[_builtins.str]
        """
        he name of a Dialogflow virtual agent used for end user side intent detection and suggestion. Format: projects/<Project ID>/locations/<Location ID>/agent.
        """
        human_agent_side_config: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgsDict']]
        """
        The Dialogflow assist configuration for human agent.
        Structure is documented below.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgs:
    def __init__(__self__, *,
                 agent: pulumi.Input[_builtins.str],
                 human_agent_side_config: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] agent: he name of a Dialogflow virtual agent used for end user side intent detection and suggestion. Format: projects/<Project ID>/locations/<Location ID>/agent.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgs'] human_agent_side_config: The Dialogflow assist configuration for human agent.
               Structure is documented below.
        """
        pulumi.set(__self__, "agent", agent)
        if human_agent_side_config is not None:
            pulumi.set(__self__, "human_agent_side_config", human_agent_side_config)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> pulumi.Input[_builtins.str]:
        """
        he name of a Dialogflow virtual agent used for end user side intent detection and suggestion. Format: projects/<Project ID>/locations/<Location ID>/agent.
        """
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agent", value)

    @_builtins.property
    @pulumi.getter(name="humanAgentSideConfig")
    def human_agent_side_config(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgs']]:
        """
        The Dialogflow assist configuration for human agent.
        Structure is documented below.
        """
        return pulumi.get(self, "human_agent_side_config")

    @human_agent_side_config.setter
    def human_agent_side_config(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgs']]):
        pulumi.set(self, "human_agent_side_config", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgsDict(TypedDict):
        agent: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of a dialogflow virtual agent used for intent detection and suggestion triggered by human agent. Format: projects/<Project ID>/locations/<Location ID>/agent.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgs:
    def __init__(__self__, *,
                 agent: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] agent: The name of a dialogflow virtual agent used for intent detection and suggestion triggered by human agent. Format: projects/<Project ID>/locations/<Location ID>/agent.
        """
        if agent is not None:
            pulumi.set(__self__, "agent", agent)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of a dialogflow virtual agent used for intent detection and suggestion triggered by human agent. Format: projects/<Project ID>/locations/<Location ID>/agent.
        """
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agent", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDocumentQuerySourceArgsDict(TypedDict):
        documents: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Knowledge documents to query from. Format: projects/<Project ID>/locations/<Location ID>/knowledgeBases/<KnowledgeBase ID>/documents/<Document ID>.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDocumentQuerySourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigDocumentQuerySourceArgs:
    def __init__(__self__, *,
                 documents: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] documents: Knowledge documents to query from. Format: projects/<Project ID>/locations/<Location ID>/knowledgeBases/<KnowledgeBase ID>/documents/<Document ID>.
        """
        pulumi.set(__self__, "documents", documents)

    @_builtins.property
    @pulumi.getter
    def documents(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Knowledge documents to query from. Format: projects/<Project ID>/locations/<Location ID>/knowledgeBases/<KnowledgeBase ID>/documents/<Document ID>.
        """
        return pulumi.get(self, "documents")

    @documents.setter
    def documents(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "documents", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigKnowledgeBaseQuerySourceArgsDict(TypedDict):
        knowledge_bases: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        Knowledge bases to query. Format: projects/<Project ID>/locations/<Location ID>/knowledgeBases/<Knowledge Base ID>.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigKnowledgeBaseQuerySourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigKnowledgeBaseQuerySourceArgs:
    def __init__(__self__, *,
                 knowledge_bases: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] knowledge_bases: Knowledge bases to query. Format: projects/<Project ID>/locations/<Location ID>/knowledgeBases/<Knowledge Base ID>.
        """
        pulumi.set(__self__, "knowledge_bases", knowledge_bases)

    @_builtins.property
    @pulumi.getter(name="knowledgeBases")
    def knowledge_bases(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        Knowledge bases to query. Format: projects/<Project ID>/locations/<Location ID>/knowledgeBases/<Knowledge Base ID>.
        """
        return pulumi.get(self, "knowledge_bases")

    @knowledge_bases.setter
    def knowledge_bases(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "knowledge_bases", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigSectionsArgsDict(TypedDict):
        section_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The selected sections chosen to return when requesting a summary of a conversation
        If not provided the default selection will be "{SITUATION, ACTION, RESULT}".
        Each value may be one of: `SECTION_TYPE_UNSPECIFIED`, `SITUATION`, `ACTION`, `RESOLUTION`, `REASON_FOR_CANCELLATION`, `CUSTOMER_SATISFACTION`, `ENTITIES`.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigSectionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigQueryConfigSectionsArgs:
    def __init__(__self__, *,
                 section_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] section_types: The selected sections chosen to return when requesting a summary of a conversation
               If not provided the default selection will be "{SITUATION, ACTION, RESULT}".
               Each value may be one of: `SECTION_TYPE_UNSPECIFIED`, `SITUATION`, `ACTION`, `RESOLUTION`, `REASON_FOR_CANCELLATION`, `CUSTOMER_SATISFACTION`, `ENTITIES`.
        """
        if section_types is not None:
            pulumi.set(__self__, "section_types", section_types)

    @_builtins.property
    @pulumi.getter(name="sectionTypes")
    def section_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The selected sections chosen to return when requesting a summary of a conversation
        If not provided the default selection will be "{SITUATION, ACTION, RESULT}".
        Each value may be one of: `SECTION_TYPE_UNSPECIFIED`, `SITUATION`, `ACTION`, `RESOLUTION`, `REASON_FOR_CANCELLATION`, `CUSTOMER_SATISFACTION`, `ENTITIES`.
        """
        return pulumi.get(self, "section_types")

    @section_types.setter
    def section_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "section_types", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionFeatureArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of Human Agent Assistant API feature to request.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionFeatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionFeatureArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of Human Agent Assistant API feature to request.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of Human Agent Assistant API feature to request.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgsDict(TypedDict):
        no_small_talk: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Do not trigger if last utterance is small talk.
        """
        only_end_user: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Only trigger suggestion if participant role of last utterance is END_USER.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigEndUserSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgs:
    def __init__(__self__, *,
                 no_small_talk: Optional[pulumi.Input[_builtins.bool]] = None,
                 only_end_user: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] no_small_talk: Do not trigger if last utterance is small talk.
        :param pulumi.Input[_builtins.bool] only_end_user: Only trigger suggestion if participant role of last utterance is END_USER.
        """
        if no_small_talk is not None:
            pulumi.set(__self__, "no_small_talk", no_small_talk)
        if only_end_user is not None:
            pulumi.set(__self__, "only_end_user", only_end_user)

    @_builtins.property
    @pulumi.getter(name="noSmallTalk")
    def no_small_talk(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Do not trigger if last utterance is small talk.
        """
        return pulumi.get(self, "no_small_talk")

    @no_small_talk.setter
    def no_small_talk(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "no_small_talk", value)

    @_builtins.property
    @pulumi.getter(name="onlyEndUser")
    def only_end_user(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Only trigger suggestion if participant role of last utterance is END_USER.
        """
        return pulumi.get(self, "only_end_user")

    @only_end_user.setter
    def only_end_user(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "only_end_user", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigArgsDict(TypedDict):
        disable_high_latency_features_sync_delivery: NotRequired[pulumi.Input[_builtins.bool]]
        """
        When disableHighLatencyFeaturesSyncDelivery is true and using the AnalyzeContent API, we will not deliver the responses from high latency features in the API response. The humanAgentAssistantConfig.notification_config must be configured and enableEventBasedSuggestion must be set to true to receive the responses from high latency features in Pub/Sub. High latency feature(s): KNOWLEDGE_ASSIST
        """
        feature_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigArgsDict']]]]
        """
        Configuration of different suggestion features. One feature can have only one config.
        Structure is documented below.
        """
        generators: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of various generator resource names used in the conversation profile.
        """
        group_suggestion_responses: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If groupSuggestionResponses is false, and there are multiple featureConfigs in event based suggestion or StreamingAnalyzeContent, we will try to deliver suggestions to customers as soon as we get new suggestion. Different type of suggestions based on the same context will be in separate Pub/Sub event or StreamingAnalyzeContentResponse.
        If groupSuggestionResponses set to true. All the suggestions to the same participant based on the same context will be grouped into a single Pub/Sub event or StreamingAnalyzeContentResponse.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigArgs:
    def __init__(__self__, *,
                 disable_high_latency_features_sync_delivery: Optional[pulumi.Input[_builtins.bool]] = None,
                 feature_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigArgs']]]] = None,
                 generators: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 group_suggestion_responses: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] disable_high_latency_features_sync_delivery: When disableHighLatencyFeaturesSyncDelivery is true and using the AnalyzeContent API, we will not deliver the responses from high latency features in the API response. The humanAgentAssistantConfig.notification_config must be configured and enableEventBasedSuggestion must be set to true to receive the responses from high latency features in Pub/Sub. High latency feature(s): KNOWLEDGE_ASSIST
        :param pulumi.Input[Sequence[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigArgs']]] feature_configs: Configuration of different suggestion features. One feature can have only one config.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] generators: List of various generator resource names used in the conversation profile.
        :param pulumi.Input[_builtins.bool] group_suggestion_responses: If groupSuggestionResponses is false, and there are multiple featureConfigs in event based suggestion or StreamingAnalyzeContent, we will try to deliver suggestions to customers as soon as we get new suggestion. Different type of suggestions based on the same context will be in separate Pub/Sub event or StreamingAnalyzeContentResponse.
               If groupSuggestionResponses set to true. All the suggestions to the same participant based on the same context will be grouped into a single Pub/Sub event or StreamingAnalyzeContentResponse.
        """
        if disable_high_latency_features_sync_delivery is not None:
            pulumi.set(__self__, "disable_high_latency_features_sync_delivery", disable_high_latency_features_sync_delivery)
        if feature_configs is not None:
            pulumi.set(__self__, "feature_configs", feature_configs)
        if generators is not None:
            pulumi.set(__self__, "generators", generators)
        if group_suggestion_responses is not None:
            pulumi.set(__self__, "group_suggestion_responses", group_suggestion_responses)

    @_builtins.property
    @pulumi.getter(name="disableHighLatencyFeaturesSyncDelivery")
    def disable_high_latency_features_sync_delivery(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        When disableHighLatencyFeaturesSyncDelivery is true and using the AnalyzeContent API, we will not deliver the responses from high latency features in the API response. The humanAgentAssistantConfig.notification_config must be configured and enableEventBasedSuggestion must be set to true to receive the responses from high latency features in Pub/Sub. High latency feature(s): KNOWLEDGE_ASSIST
        """
        return pulumi.get(self, "disable_high_latency_features_sync_delivery")

    @disable_high_latency_features_sync_delivery.setter
    def disable_high_latency_features_sync_delivery(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_high_latency_features_sync_delivery", value)

    @_builtins.property
    @pulumi.getter(name="featureConfigs")
    def feature_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigArgs']]]]:
        """
        Configuration of different suggestion features. One feature can have only one config.
        Structure is documented below.
        """
        return pulumi.get(self, "feature_configs")

    @feature_configs.setter
    def feature_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigArgs']]]]):
        pulumi.set(self, "feature_configs", value)

    @_builtins.property
    @pulumi.getter
    def generators(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of various generator resource names used in the conversation profile.
        """
        return pulumi.get(self, "generators")

    @generators.setter
    def generators(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "generators", value)

    @_builtins.property
    @pulumi.getter(name="groupSuggestionResponses")
    def group_suggestion_responses(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If groupSuggestionResponses is false, and there are multiple featureConfigs in event based suggestion or StreamingAnalyzeContent, we will try to deliver suggestions to customers as soon as we get new suggestion. Different type of suggestions based on the same context will be in separate Pub/Sub event or StreamingAnalyzeContentResponse.
        If groupSuggestionResponses set to true. All the suggestions to the same participant based on the same context will be grouped into a single Pub/Sub event or StreamingAnalyzeContentResponse.
        """
        return pulumi.get(self, "group_suggestion_responses")

    @group_suggestion_responses.setter
    def group_suggestion_responses(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "group_suggestion_responses", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigArgsDict(TypedDict):
        conversation_model_config: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationModelConfigArgsDict']]
        """
        Configs of custom conversation model.
        Structure is documented below.
        """
        conversation_process_config: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationProcessConfigArgsDict']]
        """
        Config to process conversation.
        Structure is documented below.
        """
        disable_agent_query_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Disable the logging of search queries sent by human agents. It can prevent those queries from being stored at answer records.
        This feature is only supported for types: KNOWLEDGE_SEARCH.
        """
        enable_conversation_augmented_query: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable including conversation context during query answer generation.
        This feature is only supported for types: KNOWLEDGE_SEARCH.
        """
        enable_event_based_suggestion: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Automatically iterates all participants and tries to compile suggestions.
        This feature is only supported for types: ARTICLE_SUGGESTION, FAQ, DIALOGFLOW_ASSIST, KNOWLEDGE_ASSIST.
        """
        enable_query_suggestion_only: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable query suggestion only.
        This feature is only supported for types: KNOWLEDGE_ASSIST
        """
        enable_query_suggestion_when_no_answer: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable query suggestion even if we can't find its answer. By default, queries are suggested only if we find its answer.
        This feature is only supported for types: KNOWLEDGE_ASSIST.
        """
        query_config: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigArgsDict']]
        """
        Configs of query.
        Structure is documented below.
        """
        suggestion_feature: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionFeatureArgsDict']]
        """
        The suggestion feature.
        Structure is documented below.
        """
        suggestion_trigger_settings: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgsDict']]
        """
        Settings of suggestion trigger.
        This feature is only supported for types: ARTICLE_SUGGESTION, FAQ.
        Structure is documented below.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigArgs:
    def __init__(__self__, *,
                 conversation_model_config: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationModelConfigArgs']] = None,
                 conversation_process_config: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationProcessConfigArgs']] = None,
                 disable_agent_query_logging: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_conversation_augmented_query: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_event_based_suggestion: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_query_suggestion_only: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_query_suggestion_when_no_answer: Optional[pulumi.Input[_builtins.bool]] = None,
                 query_config: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigArgs']] = None,
                 suggestion_feature: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionFeatureArgs']] = None,
                 suggestion_trigger_settings: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgs']] = None):
        """
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationModelConfigArgs'] conversation_model_config: Configs of custom conversation model.
               Structure is documented below.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationProcessConfigArgs'] conversation_process_config: Config to process conversation.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] disable_agent_query_logging: Disable the logging of search queries sent by human agents. It can prevent those queries from being stored at answer records.
               This feature is only supported for types: KNOWLEDGE_SEARCH.
        :param pulumi.Input[_builtins.bool] enable_conversation_augmented_query: Enable including conversation context during query answer generation.
               This feature is only supported for types: KNOWLEDGE_SEARCH.
        :param pulumi.Input[_builtins.bool] enable_event_based_suggestion: Automatically iterates all participants and tries to compile suggestions.
               This feature is only supported for types: ARTICLE_SUGGESTION, FAQ, DIALOGFLOW_ASSIST, KNOWLEDGE_ASSIST.
        :param pulumi.Input[_builtins.bool] enable_query_suggestion_only: Enable query suggestion only.
               This feature is only supported for types: KNOWLEDGE_ASSIST
        :param pulumi.Input[_builtins.bool] enable_query_suggestion_when_no_answer: Enable query suggestion even if we can't find its answer. By default, queries are suggested only if we find its answer.
               This feature is only supported for types: KNOWLEDGE_ASSIST.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigArgs'] query_config: Configs of query.
               Structure is documented below.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionFeatureArgs'] suggestion_feature: The suggestion feature.
               Structure is documented below.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgs'] suggestion_trigger_settings: Settings of suggestion trigger.
               This feature is only supported for types: ARTICLE_SUGGESTION, FAQ.
               Structure is documented below.
        """
        if conversation_model_config is not None:
            pulumi.set(__self__, "conversation_model_config", conversation_model_config)
        if conversation_process_config is not None:
            pulumi.set(__self__, "conversation_process_config", conversation_process_config)
        if disable_agent_query_logging is not None:
            pulumi.set(__self__, "disable_agent_query_logging", disable_agent_query_logging)
        if enable_conversation_augmented_query is not None:
            pulumi.set(__self__, "enable_conversation_augmented_query", enable_conversation_augmented_query)
        if enable_event_based_suggestion is not None:
            pulumi.set(__self__, "enable_event_based_suggestion", enable_event_based_suggestion)
        if enable_query_suggestion_only is not None:
            pulumi.set(__self__, "enable_query_suggestion_only", enable_query_suggestion_only)
        if enable_query_suggestion_when_no_answer is not None:
            pulumi.set(__self__, "enable_query_suggestion_when_no_answer", enable_query_suggestion_when_no_answer)
        if query_config is not None:
            pulumi.set(__self__, "query_config", query_config)
        if suggestion_feature is not None:
            pulumi.set(__self__, "suggestion_feature", suggestion_feature)
        if suggestion_trigger_settings is not None:
            pulumi.set(__self__, "suggestion_trigger_settings", suggestion_trigger_settings)

    @_builtins.property
    @pulumi.getter(name="conversationModelConfig")
    def conversation_model_config(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationModelConfigArgs']]:
        """
        Configs of custom conversation model.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_model_config")

    @conversation_model_config.setter
    def conversation_model_config(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationModelConfigArgs']]):
        pulumi.set(self, "conversation_model_config", value)

    @_builtins.property
    @pulumi.getter(name="conversationProcessConfig")
    def conversation_process_config(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationProcessConfigArgs']]:
        """
        Config to process conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_process_config")

    @conversation_process_config.setter
    def conversation_process_config(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationProcessConfigArgs']]):
        pulumi.set(self, "conversation_process_config", value)

    @_builtins.property
    @pulumi.getter(name="disableAgentQueryLogging")
    def disable_agent_query_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Disable the logging of search queries sent by human agents. It can prevent those queries from being stored at answer records.
        This feature is only supported for types: KNOWLEDGE_SEARCH.
        """
        return pulumi.get(self, "disable_agent_query_logging")

    @disable_agent_query_logging.setter
    def disable_agent_query_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_agent_query_logging", value)

    @_builtins.property
    @pulumi.getter(name="enableConversationAugmentedQuery")
    def enable_conversation_augmented_query(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable including conversation context during query answer generation.
        This feature is only supported for types: KNOWLEDGE_SEARCH.
        """
        return pulumi.get(self, "enable_conversation_augmented_query")

    @enable_conversation_augmented_query.setter
    def enable_conversation_augmented_query(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_conversation_augmented_query", value)

    @_builtins.property
    @pulumi.getter(name="enableEventBasedSuggestion")
    def enable_event_based_suggestion(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Automatically iterates all participants and tries to compile suggestions.
        This feature is only supported for types: ARTICLE_SUGGESTION, FAQ, DIALOGFLOW_ASSIST, KNOWLEDGE_ASSIST.
        """
        return pulumi.get(self, "enable_event_based_suggestion")

    @enable_event_based_suggestion.setter
    def enable_event_based_suggestion(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_event_based_suggestion", value)

    @_builtins.property
    @pulumi.getter(name="enableQuerySuggestionOnly")
    def enable_query_suggestion_only(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable query suggestion only.
        This feature is only supported for types: KNOWLEDGE_ASSIST
        """
        return pulumi.get(self, "enable_query_suggestion_only")

    @enable_query_suggestion_only.setter
    def enable_query_suggestion_only(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_query_suggestion_only", value)

    @_builtins.property
    @pulumi.getter(name="enableQuerySuggestionWhenNoAnswer")
    def enable_query_suggestion_when_no_answer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable query suggestion even if we can't find its answer. By default, queries are suggested only if we find its answer.
        This feature is only supported for types: KNOWLEDGE_ASSIST.
        """
        return pulumi.get(self, "enable_query_suggestion_when_no_answer")

    @enable_query_suggestion_when_no_answer.setter
    def enable_query_suggestion_when_no_answer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_query_suggestion_when_no_answer", value)

    @_builtins.property
    @pulumi.getter(name="queryConfig")
    def query_config(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigArgs']]:
        """
        Configs of query.
        Structure is documented below.
        """
        return pulumi.get(self, "query_config")

    @query_config.setter
    def query_config(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigArgs']]):
        pulumi.set(self, "query_config", value)

    @_builtins.property
    @pulumi.getter(name="suggestionFeature")
    def suggestion_feature(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionFeatureArgs']]:
        """
        The suggestion feature.
        Structure is documented below.
        """
        return pulumi.get(self, "suggestion_feature")

    @suggestion_feature.setter
    def suggestion_feature(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionFeatureArgs']]):
        pulumi.set(self, "suggestion_feature", value)

    @_builtins.property
    @pulumi.getter(name="suggestionTriggerSettings")
    def suggestion_trigger_settings(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgs']]:
        """
        Settings of suggestion trigger.
        This feature is only supported for types: ARTICLE_SUGGESTION, FAQ.
        Structure is documented below.
        """
        return pulumi.get(self, "suggestion_trigger_settings")

    @suggestion_trigger_settings.setter
    def suggestion_trigger_settings(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgs']]):
        pulumi.set(self, "suggestion_trigger_settings", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationModelConfigArgsDict(TypedDict):
        baseline_model_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Version of current baseline model. It will be ignored if model is set. Valid versions are: Article Suggestion baseline model: - 0.9 - 1.0 (default) Summarization baseline model: - 1.0
        """
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        Conversation model resource name. Format: projects/<Project ID>/conversationModels/<Model ID>.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationModelConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationModelConfigArgs:
    def __init__(__self__, *,
                 baseline_model_version: Optional[pulumi.Input[_builtins.str]] = None,
                 model: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] baseline_model_version: Version of current baseline model. It will be ignored if model is set. Valid versions are: Article Suggestion baseline model: - 0.9 - 1.0 (default) Summarization baseline model: - 1.0
        :param pulumi.Input[_builtins.str] model: Conversation model resource name. Format: projects/<Project ID>/conversationModels/<Model ID>.
        """
        if baseline_model_version is not None:
            pulumi.set(__self__, "baseline_model_version", baseline_model_version)
        if model is not None:
            pulumi.set(__self__, "model", model)

    @_builtins.property
    @pulumi.getter(name="baselineModelVersion")
    def baseline_model_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Version of current baseline model. It will be ignored if model is set. Valid versions are: Article Suggestion baseline model: - 0.9 - 1.0 (default) Summarization baseline model: - 1.0
        """
        return pulumi.get(self, "baseline_model_version")

    @baseline_model_version.setter
    def baseline_model_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "baseline_model_version", value)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Conversation model resource name. Format: projects/<Project ID>/conversationModels/<Model ID>.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationProcessConfigArgsDict(TypedDict):
        recent_sentences_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of recent non-small-talk sentences to use as context for article and FAQ suggestion
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationProcessConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigConversationProcessConfigArgs:
    def __init__(__self__, *,
                 recent_sentences_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] recent_sentences_count: Number of recent non-small-talk sentences to use as context for article and FAQ suggestion
        """
        if recent_sentences_count is not None:
            pulumi.set(__self__, "recent_sentences_count", recent_sentences_count)

    @_builtins.property
    @pulumi.getter(name="recentSentencesCount")
    def recent_sentences_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of recent non-small-talk sentences to use as context for article and FAQ suggestion
        """
        return pulumi.get(self, "recent_sentences_count")

    @recent_sentences_count.setter
    def recent_sentences_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "recent_sentences_count", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigArgsDict(TypedDict):
        confidence_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        Confidence threshold of query result.
        This feature is only supported for types: ARTICLE_SUGGESTION, FAQ, SMART_REPLY, SMART_COMPOSE, KNOWLEDGE_SEARCH, KNOWLEDGE_ASSIST, ENTITY_EXTRACTION.
        """
        context_filter_settings: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgsDict']]
        """
        Determines how recent conversation context is filtered when generating suggestions. If unspecified, no messages will be dropped.
        Structure is documented below.
        """
        dialogflow_query_source: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgsDict']]
        """
        Query from Dialogflow agent.
        This feature is supported for types: DIALOGFLOW_ASSIST.
        Structure is documented below.
        """
        max_results: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of results to return.
        """
        sections: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigSectionsArgsDict']]
        """
        he customized sections chosen to return when requesting a summary of a conversation.
        Structure is documented below.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigArgs:
    def __init__(__self__, *,
                 confidence_threshold: Optional[pulumi.Input[_builtins.float]] = None,
                 context_filter_settings: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgs']] = None,
                 dialogflow_query_source: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgs']] = None,
                 max_results: Optional[pulumi.Input[_builtins.int]] = None,
                 sections: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigSectionsArgs']] = None):
        """
        :param pulumi.Input[_builtins.float] confidence_threshold: Confidence threshold of query result.
               This feature is only supported for types: ARTICLE_SUGGESTION, FAQ, SMART_REPLY, SMART_COMPOSE, KNOWLEDGE_SEARCH, KNOWLEDGE_ASSIST, ENTITY_EXTRACTION.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgs'] context_filter_settings: Determines how recent conversation context is filtered when generating suggestions. If unspecified, no messages will be dropped.
               Structure is documented below.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgs'] dialogflow_query_source: Query from Dialogflow agent.
               This feature is supported for types: DIALOGFLOW_ASSIST.
               Structure is documented below.
        :param pulumi.Input[_builtins.int] max_results: Maximum number of results to return.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigSectionsArgs'] sections: he customized sections chosen to return when requesting a summary of a conversation.
               Structure is documented below.
        """
        if confidence_threshold is not None:
            pulumi.set(__self__, "confidence_threshold", confidence_threshold)
        if context_filter_settings is not None:
            pulumi.set(__self__, "context_filter_settings", context_filter_settings)
        if dialogflow_query_source is not None:
            pulumi.set(__self__, "dialogflow_query_source", dialogflow_query_source)
        if max_results is not None:
            pulumi.set(__self__, "max_results", max_results)
        if sections is not None:
            pulumi.set(__self__, "sections", sections)

    @_builtins.property
    @pulumi.getter(name="confidenceThreshold")
    def confidence_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Confidence threshold of query result.
        This feature is only supported for types: ARTICLE_SUGGESTION, FAQ, SMART_REPLY, SMART_COMPOSE, KNOWLEDGE_SEARCH, KNOWLEDGE_ASSIST, ENTITY_EXTRACTION.
        """
        return pulumi.get(self, "confidence_threshold")

    @confidence_threshold.setter
    def confidence_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "confidence_threshold", value)

    @_builtins.property
    @pulumi.getter(name="contextFilterSettings")
    def context_filter_settings(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgs']]:
        """
        Determines how recent conversation context is filtered when generating suggestions. If unspecified, no messages will be dropped.
        Structure is documented below.
        """
        return pulumi.get(self, "context_filter_settings")

    @context_filter_settings.setter
    def context_filter_settings(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgs']]):
        pulumi.set(self, "context_filter_settings", value)

    @_builtins.property
    @pulumi.getter(name="dialogflowQuerySource")
    def dialogflow_query_source(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgs']]:
        """
        Query from Dialogflow agent.
        This feature is supported for types: DIALOGFLOW_ASSIST.
        Structure is documented below.
        """
        return pulumi.get(self, "dialogflow_query_source")

    @dialogflow_query_source.setter
    def dialogflow_query_source(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgs']]):
        pulumi.set(self, "dialogflow_query_source", value)

    @_builtins.property
    @pulumi.getter(name="maxResults")
    def max_results(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of results to return.
        """
        return pulumi.get(self, "max_results")

    @max_results.setter
    def max_results(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_results", value)

    @_builtins.property
    @pulumi.getter
    def sections(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigSectionsArgs']]:
        """
        he customized sections chosen to return when requesting a summary of a conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "sections")

    @sections.setter
    def sections(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigSectionsArgs']]):
        pulumi.set(self, "sections", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgsDict(TypedDict):
        drop_handoff_messages: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set to true, the last message from virtual agent (hand off message) and the message before it (trigger message of hand off) are dropped.
        """
        drop_ivr_messages: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set to true, all messages from ivr stage are dropped.
        """
        drop_virtual_agent_messages: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set to true, all messages from virtual agent are dropped.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigContextFilterSettingsArgs:
    def __init__(__self__, *,
                 drop_handoff_messages: Optional[pulumi.Input[_builtins.bool]] = None,
                 drop_ivr_messages: Optional[pulumi.Input[_builtins.bool]] = None,
                 drop_virtual_agent_messages: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] drop_handoff_messages: If set to true, the last message from virtual agent (hand off message) and the message before it (trigger message of hand off) are dropped.
        :param pulumi.Input[_builtins.bool] drop_ivr_messages: If set to true, all messages from ivr stage are dropped.
        :param pulumi.Input[_builtins.bool] drop_virtual_agent_messages: If set to true, all messages from virtual agent are dropped.
        """
        if drop_handoff_messages is not None:
            pulumi.set(__self__, "drop_handoff_messages", drop_handoff_messages)
        if drop_ivr_messages is not None:
            pulumi.set(__self__, "drop_ivr_messages", drop_ivr_messages)
        if drop_virtual_agent_messages is not None:
            pulumi.set(__self__, "drop_virtual_agent_messages", drop_virtual_agent_messages)

    @_builtins.property
    @pulumi.getter(name="dropHandoffMessages")
    def drop_handoff_messages(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to true, the last message from virtual agent (hand off message) and the message before it (trigger message of hand off) are dropped.
        """
        return pulumi.get(self, "drop_handoff_messages")

    @drop_handoff_messages.setter
    def drop_handoff_messages(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "drop_handoff_messages", value)

    @_builtins.property
    @pulumi.getter(name="dropIvrMessages")
    def drop_ivr_messages(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to true, all messages from ivr stage are dropped.
        """
        return pulumi.get(self, "drop_ivr_messages")

    @drop_ivr_messages.setter
    def drop_ivr_messages(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "drop_ivr_messages", value)

    @_builtins.property
    @pulumi.getter(name="dropVirtualAgentMessages")
    def drop_virtual_agent_messages(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to true, all messages from virtual agent are dropped.
        """
        return pulumi.get(self, "drop_virtual_agent_messages")

    @drop_virtual_agent_messages.setter
    def drop_virtual_agent_messages(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "drop_virtual_agent_messages", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgsDict(TypedDict):
        agent: pulumi.Input[_builtins.str]
        """
        he name of a Dialogflow virtual agent used for end user side intent detection and suggestion. Format: projects/<Project ID>/locations/<Location ID>/agent.
        """
        human_agent_side_config: NotRequired[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgsDict']]
        """
        The Dialogflow assist configuration for human agent.
        Structure is documented below.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceArgs:
    def __init__(__self__, *,
                 agent: pulumi.Input[_builtins.str],
                 human_agent_side_config: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] agent: he name of a Dialogflow virtual agent used for end user side intent detection and suggestion. Format: projects/<Project ID>/locations/<Location ID>/agent.
        :param pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgs'] human_agent_side_config: The Dialogflow assist configuration for human agent.
               Structure is documented below.
        """
        pulumi.set(__self__, "agent", agent)
        if human_agent_side_config is not None:
            pulumi.set(__self__, "human_agent_side_config", human_agent_side_config)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> pulumi.Input[_builtins.str]:
        """
        he name of a Dialogflow virtual agent used for end user side intent detection and suggestion. Format: projects/<Project ID>/locations/<Location ID>/agent.
        """
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agent", value)

    @_builtins.property
    @pulumi.getter(name="humanAgentSideConfig")
    def human_agent_side_config(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgs']]:
        """
        The Dialogflow assist configuration for human agent.
        Structure is documented below.
        """
        return pulumi.get(self, "human_agent_side_config")

    @human_agent_side_config.setter
    def human_agent_side_config(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgs']]):
        pulumi.set(self, "human_agent_side_config", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgsDict(TypedDict):
        agent: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of a dialogflow virtual agent used for intent detection and suggestion triggered by human agent. Format: projects/<Project ID>/locations/<Location ID>/agent.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigDialogflowQuerySourceHumanAgentSideConfigArgs:
    def __init__(__self__, *,
                 agent: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] agent: The name of a dialogflow virtual agent used for intent detection and suggestion triggered by human agent. Format: projects/<Project ID>/locations/<Location ID>/agent.
        """
        if agent is not None:
            pulumi.set(__self__, "agent", agent)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of a dialogflow virtual agent used for intent detection and suggestion triggered by human agent. Format: projects/<Project ID>/locations/<Location ID>/agent.
        """
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agent", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigSectionsArgsDict(TypedDict):
        section_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The selected sections chosen to return when requesting a summary of a conversation
        If not provided the default selection will be "{SITUATION, ACTION, RESULT}".
        Each value may be one of: `SECTION_TYPE_UNSPECIFIED`, `SITUATION`, `ACTION`, `RESOLUTION`, `REASON_FOR_CANCELLATION`, `CUSTOMER_SATISFACTION`, `ENTITIES`.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigSectionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigQueryConfigSectionsArgs:
    def __init__(__self__, *,
                 section_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] section_types: The selected sections chosen to return when requesting a summary of a conversation
               If not provided the default selection will be "{SITUATION, ACTION, RESULT}".
               Each value may be one of: `SECTION_TYPE_UNSPECIFIED`, `SITUATION`, `ACTION`, `RESOLUTION`, `REASON_FOR_CANCELLATION`, `CUSTOMER_SATISFACTION`, `ENTITIES`.
        """
        if section_types is not None:
            pulumi.set(__self__, "section_types", section_types)

    @_builtins.property
    @pulumi.getter(name="sectionTypes")
    def section_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The selected sections chosen to return when requesting a summary of a conversation
        If not provided the default selection will be "{SITUATION, ACTION, RESULT}".
        Each value may be one of: `SECTION_TYPE_UNSPECIFIED`, `SITUATION`, `ACTION`, `RESOLUTION`, `REASON_FOR_CANCELLATION`, `CUSTOMER_SATISFACTION`, `ENTITIES`.
        """
        return pulumi.get(self, "section_types")

    @section_types.setter
    def section_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "section_types", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionFeatureArgsDict(TypedDict):
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of Human Agent Assistant API feature to request.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionFeatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionFeatureArgs:
    def __init__(__self__, *,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of Human Agent Assistant API feature to request.
        """
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of Human Agent Assistant API feature to request.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgsDict(TypedDict):
        no_small_talk: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Do not trigger if last utterance is small talk.
        """
        only_end_user: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Only trigger suggestion if participant role of last utterance is END_USER.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigHumanAgentSuggestionConfigFeatureConfigSuggestionTriggerSettingsArgs:
    def __init__(__self__, *,
                 no_small_talk: Optional[pulumi.Input[_builtins.bool]] = None,
                 only_end_user: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] no_small_talk: Do not trigger if last utterance is small talk.
        :param pulumi.Input[_builtins.bool] only_end_user: Only trigger suggestion if participant role of last utterance is END_USER.
        """
        if no_small_talk is not None:
            pulumi.set(__self__, "no_small_talk", no_small_talk)
        if only_end_user is not None:
            pulumi.set(__self__, "only_end_user", only_end_user)

    @_builtins.property
    @pulumi.getter(name="noSmallTalk")
    def no_small_talk(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Do not trigger if last utterance is small talk.
        """
        return pulumi.get(self, "no_small_talk")

    @no_small_talk.setter
    def no_small_talk(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "no_small_talk", value)

    @_builtins.property
    @pulumi.getter(name="onlyEndUser")
    def only_end_user(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Only trigger suggestion if participant role of last utterance is END_USER.
        """
        return pulumi.get(self, "only_end_user")

    @only_end_user.setter
    def only_end_user(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "only_end_user", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigMessageAnalysisConfigArgsDict(TypedDict):
        enable_entity_extraction: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable entity extraction in conversation messages on agent assist stage.
        """
        enable_sentiment_analysis: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable sentiment analysis in conversation messages on agent assist stage. Sentiment analysis inspects user input and identifies the prevailing subjective opinion, especially to determine a user's attitude as positive, negative, or neutral.
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigMessageAnalysisConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigMessageAnalysisConfigArgs:
    def __init__(__self__, *,
                 enable_entity_extraction: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_sentiment_analysis: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_entity_extraction: Enable entity extraction in conversation messages on agent assist stage.
        :param pulumi.Input[_builtins.bool] enable_sentiment_analysis: Enable sentiment analysis in conversation messages on agent assist stage. Sentiment analysis inspects user input and identifies the prevailing subjective opinion, especially to determine a user's attitude as positive, negative, or neutral.
        """
        if enable_entity_extraction is not None:
            pulumi.set(__self__, "enable_entity_extraction", enable_entity_extraction)
        if enable_sentiment_analysis is not None:
            pulumi.set(__self__, "enable_sentiment_analysis", enable_sentiment_analysis)

    @_builtins.property
    @pulumi.getter(name="enableEntityExtraction")
    def enable_entity_extraction(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable entity extraction in conversation messages on agent assist stage.
        """
        return pulumi.get(self, "enable_entity_extraction")

    @enable_entity_extraction.setter
    def enable_entity_extraction(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_entity_extraction", value)

    @_builtins.property
    @pulumi.getter(name="enableSentimentAnalysis")
    def enable_sentiment_analysis(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable sentiment analysis in conversation messages on agent assist stage. Sentiment analysis inspects user input and identifies the prevailing subjective opinion, especially to determine a user's attitude as positive, negative, or neutral.
        """
        return pulumi.get(self, "enable_sentiment_analysis")

    @enable_sentiment_analysis.setter
    def enable_sentiment_analysis(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_sentiment_analysis", value)


if not MYPY:
    class ConversationProfileHumanAgentAssistantConfigNotificationConfigArgsDict(TypedDict):
        message_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Format of the message
        Possible values are: `MESSAGE_FORMAT_UNSPECIFIED`, `PROTO`, `JSON`.
        """
        topic: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Pub/Sub topic to publish conversation events
        """
elif False:
    ConversationProfileHumanAgentAssistantConfigNotificationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentAssistantConfigNotificationConfigArgs:
    def __init__(__self__, *,
                 message_format: Optional[pulumi.Input[_builtins.str]] = None,
                 topic: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] message_format: Format of the message
               Possible values are: `MESSAGE_FORMAT_UNSPECIFIED`, `PROTO`, `JSON`.
        :param pulumi.Input[_builtins.str] topic: Name of the Pub/Sub topic to publish conversation events
        """
        if message_format is not None:
            pulumi.set(__self__, "message_format", message_format)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @_builtins.property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Format of the message
        Possible values are: `MESSAGE_FORMAT_UNSPECIFIED`, `PROTO`, `JSON`.
        """
        return pulumi.get(self, "message_format")

    @message_format.setter
    def message_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_format", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Pub/Sub topic to publish conversation events
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "topic", value)


if not MYPY:
    class ConversationProfileHumanAgentHandoffConfigArgsDict(TypedDict):
        live_person_config: NotRequired[pulumi.Input['ConversationProfileHumanAgentHandoffConfigLivePersonConfigArgsDict']]
        """
        Config for using LivePerson.
        Structure is documented below.
        """
elif False:
    ConversationProfileHumanAgentHandoffConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentHandoffConfigArgs:
    def __init__(__self__, *,
                 live_person_config: Optional[pulumi.Input['ConversationProfileHumanAgentHandoffConfigLivePersonConfigArgs']] = None):
        """
        :param pulumi.Input['ConversationProfileHumanAgentHandoffConfigLivePersonConfigArgs'] live_person_config: Config for using LivePerson.
               Structure is documented below.
        """
        if live_person_config is not None:
            pulumi.set(__self__, "live_person_config", live_person_config)

    @_builtins.property
    @pulumi.getter(name="livePersonConfig")
    def live_person_config(self) -> Optional[pulumi.Input['ConversationProfileHumanAgentHandoffConfigLivePersonConfigArgs']]:
        """
        Config for using LivePerson.
        Structure is documented below.
        """
        return pulumi.get(self, "live_person_config")

    @live_person_config.setter
    def live_person_config(self, value: Optional[pulumi.Input['ConversationProfileHumanAgentHandoffConfigLivePersonConfigArgs']]):
        pulumi.set(self, "live_person_config", value)


if not MYPY:
    class ConversationProfileHumanAgentHandoffConfigLivePersonConfigArgsDict(TypedDict):
        account_number: pulumi.Input[_builtins.str]
        """
        Account number of the LivePerson account to connect.
        """
elif False:
    ConversationProfileHumanAgentHandoffConfigLivePersonConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileHumanAgentHandoffConfigLivePersonConfigArgs:
    def __init__(__self__, *,
                 account_number: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] account_number: Account number of the LivePerson account to connect.
        """
        pulumi.set(__self__, "account_number", account_number)

    @_builtins.property
    @pulumi.getter(name="accountNumber")
    def account_number(self) -> pulumi.Input[_builtins.str]:
        """
        Account number of the LivePerson account to connect.
        """
        return pulumi.get(self, "account_number")

    @account_number.setter
    def account_number(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "account_number", value)


if not MYPY:
    class ConversationProfileLoggingConfigArgsDict(TypedDict):
        enable_stackdriver_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to log conversation events
        """
elif False:
    ConversationProfileLoggingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileLoggingConfigArgs:
    def __init__(__self__, *,
                 enable_stackdriver_logging: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_stackdriver_logging: Whether to log conversation events
        """
        if enable_stackdriver_logging is not None:
            pulumi.set(__self__, "enable_stackdriver_logging", enable_stackdriver_logging)

    @_builtins.property
    @pulumi.getter(name="enableStackdriverLogging")
    def enable_stackdriver_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to log conversation events
        """
        return pulumi.get(self, "enable_stackdriver_logging")

    @enable_stackdriver_logging.setter
    def enable_stackdriver_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_stackdriver_logging", value)


if not MYPY:
    class ConversationProfileNewMessageEventNotificationConfigArgsDict(TypedDict):
        message_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Format of the message
        Possible values are: `MESSAGE_FORMAT_UNSPECIFIED`, `PROTO`, `JSON`.
        """
        topic: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Pub/Sub topic to publish conversation events
        """
elif False:
    ConversationProfileNewMessageEventNotificationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileNewMessageEventNotificationConfigArgs:
    def __init__(__self__, *,
                 message_format: Optional[pulumi.Input[_builtins.str]] = None,
                 topic: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] message_format: Format of the message
               Possible values are: `MESSAGE_FORMAT_UNSPECIFIED`, `PROTO`, `JSON`.
        :param pulumi.Input[_builtins.str] topic: Name of the Pub/Sub topic to publish conversation events
        """
        if message_format is not None:
            pulumi.set(__self__, "message_format", message_format)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @_builtins.property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Format of the message
        Possible values are: `MESSAGE_FORMAT_UNSPECIFIED`, `PROTO`, `JSON`.
        """
        return pulumi.get(self, "message_format")

    @message_format.setter
    def message_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_format", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Pub/Sub topic to publish conversation events
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "topic", value)


if not MYPY:
    class ConversationProfileNewRecognitionResultNotificationConfigArgsDict(TypedDict):
        message_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Format of message.
        Possible values are: `MESSAGE_FORMAT_UNSPECIFIED`, `PROTO`, `JSON`.
        """
        topic: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Pub/Sub topic to publish conversation events like CONVERSATION_STARTED as serialized ConversationEvent protos.
        For telephony integration to receive notification, make sure either this topic is in the same project as the conversation or you grant service-<Conversation Project Number>@gcp-sa-dialogflow.iam.gserviceaccount.com the Dialogflow Service Agent role in the topic project.
        For chat integration to receive notification, make sure API caller has been granted the Dialogflow Service Agent role for the topic.
        Format: projects/<Project ID>/locations/<Location ID>/topics/<Topic ID>.
        """
elif False:
    ConversationProfileNewRecognitionResultNotificationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileNewRecognitionResultNotificationConfigArgs:
    def __init__(__self__, *,
                 message_format: Optional[pulumi.Input[_builtins.str]] = None,
                 topic: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] message_format: Format of message.
               Possible values are: `MESSAGE_FORMAT_UNSPECIFIED`, `PROTO`, `JSON`.
        :param pulumi.Input[_builtins.str] topic: Name of the Pub/Sub topic to publish conversation events like CONVERSATION_STARTED as serialized ConversationEvent protos.
               For telephony integration to receive notification, make sure either this topic is in the same project as the conversation or you grant service-<Conversation Project Number>@gcp-sa-dialogflow.iam.gserviceaccount.com the Dialogflow Service Agent role in the topic project.
               For chat integration to receive notification, make sure API caller has been granted the Dialogflow Service Agent role for the topic.
               Format: projects/<Project ID>/locations/<Location ID>/topics/<Topic ID>.
        """
        if message_format is not None:
            pulumi.set(__self__, "message_format", message_format)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @_builtins.property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Format of message.
        Possible values are: `MESSAGE_FORMAT_UNSPECIFIED`, `PROTO`, `JSON`.
        """
        return pulumi.get(self, "message_format")

    @message_format.setter
    def message_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_format", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Pub/Sub topic to publish conversation events like CONVERSATION_STARTED as serialized ConversationEvent protos.
        For telephony integration to receive notification, make sure either this topic is in the same project as the conversation or you grant service-<Conversation Project Number>@gcp-sa-dialogflow.iam.gserviceaccount.com the Dialogflow Service Agent role in the topic project.
        For chat integration to receive notification, make sure API caller has been granted the Dialogflow Service Agent role for the topic.
        Format: projects/<Project ID>/locations/<Location ID>/topics/<Topic ID>.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "topic", value)


if not MYPY:
    class ConversationProfileNotificationConfigArgsDict(TypedDict):
        message_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        Format of the message
        Possible values are: `MESSAGE_FORMAT_UNSPECIFIED`, `PROTO`, `JSON`.
        """
        topic: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the Pub/Sub topic to publish conversation events
        """
elif False:
    ConversationProfileNotificationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileNotificationConfigArgs:
    def __init__(__self__, *,
                 message_format: Optional[pulumi.Input[_builtins.str]] = None,
                 topic: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] message_format: Format of the message
               Possible values are: `MESSAGE_FORMAT_UNSPECIFIED`, `PROTO`, `JSON`.
        :param pulumi.Input[_builtins.str] topic: Name of the Pub/Sub topic to publish conversation events
        """
        if message_format is not None:
            pulumi.set(__self__, "message_format", message_format)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @_builtins.property
    @pulumi.getter(name="messageFormat")
    def message_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Format of the message
        Possible values are: `MESSAGE_FORMAT_UNSPECIFIED`, `PROTO`, `JSON`.
        """
        return pulumi.get(self, "message_format")

    @message_format.setter
    def message_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message_format", value)

    @_builtins.property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the Pub/Sub topic to publish conversation events
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "topic", value)


if not MYPY:
    class ConversationProfileSttConfigArgsDict(TypedDict):
        audio_encoding: NotRequired[pulumi.Input[_builtins.str]]
        """
        Audio encoding of the audio content to process.
        Possible values are: `AUDIO_ENCODING_UNSPECIFIED`, `AUDIO_ENCODING_LINEAR_16`, `AUDIO_ENCODING_FLAC`, `AUDIO_ENCODING_MULAW`, `AUDIO_ENCODING_AMR`, `AUDIO_ENCODING_AMR_WB`, `AUDIO_ENCODING_OGG_OPUS`, `AUDIOENCODING_SPEEX_WITH_HEADER_BYTE`.
        """
        enable_word_info: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, Dialogflow returns SpeechWordInfo in StreamingRecognitionResult with information about the recognized speech words.
        """
        language_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        The language of the supplied audio.
        """
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        Which Speech model to select.
        Leave this field unspecified to use Agent Speech settings for model selection.
        """
        sample_rate_hertz: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sample rate (in Hertz) of the audio content sent in the query.
        """
        speech_model_variant: NotRequired[pulumi.Input[_builtins.str]]
        """
        The speech model used in speech to text.
        Possible values are: `SPEECH_MODEL_VARIANT_UNSPECIFIED`, `USE_BEST_AVAILABLE`, `USE_STANDARD`, `USE_ENHANCED`.
        """
        use_timeout_based_endpointing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
        """
elif False:
    ConversationProfileSttConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileSttConfigArgs:
    def __init__(__self__, *,
                 audio_encoding: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_word_info: Optional[pulumi.Input[_builtins.bool]] = None,
                 language_code: Optional[pulumi.Input[_builtins.str]] = None,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 sample_rate_hertz: Optional[pulumi.Input[_builtins.int]] = None,
                 speech_model_variant: Optional[pulumi.Input[_builtins.str]] = None,
                 use_timeout_based_endpointing: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] audio_encoding: Audio encoding of the audio content to process.
               Possible values are: `AUDIO_ENCODING_UNSPECIFIED`, `AUDIO_ENCODING_LINEAR_16`, `AUDIO_ENCODING_FLAC`, `AUDIO_ENCODING_MULAW`, `AUDIO_ENCODING_AMR`, `AUDIO_ENCODING_AMR_WB`, `AUDIO_ENCODING_OGG_OPUS`, `AUDIOENCODING_SPEEX_WITH_HEADER_BYTE`.
        :param pulumi.Input[_builtins.bool] enable_word_info: If true, Dialogflow returns SpeechWordInfo in StreamingRecognitionResult with information about the recognized speech words.
        :param pulumi.Input[_builtins.str] language_code: The language of the supplied audio.
        :param pulumi.Input[_builtins.str] model: Which Speech model to select.
               Leave this field unspecified to use Agent Speech settings for model selection.
        :param pulumi.Input[_builtins.int] sample_rate_hertz: Sample rate (in Hertz) of the audio content sent in the query.
        :param pulumi.Input[_builtins.str] speech_model_variant: The speech model used in speech to text.
               Possible values are: `SPEECH_MODEL_VARIANT_UNSPECIFIED`, `USE_BEST_AVAILABLE`, `USE_STANDARD`, `USE_ENHANCED`.
        :param pulumi.Input[_builtins.bool] use_timeout_based_endpointing: Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
        """
        if audio_encoding is not None:
            pulumi.set(__self__, "audio_encoding", audio_encoding)
        if enable_word_info is not None:
            pulumi.set(__self__, "enable_word_info", enable_word_info)
        if language_code is not None:
            pulumi.set(__self__, "language_code", language_code)
        if model is not None:
            pulumi.set(__self__, "model", model)
        if sample_rate_hertz is not None:
            pulumi.set(__self__, "sample_rate_hertz", sample_rate_hertz)
        if speech_model_variant is not None:
            pulumi.set(__self__, "speech_model_variant", speech_model_variant)
        if use_timeout_based_endpointing is not None:
            pulumi.set(__self__, "use_timeout_based_endpointing", use_timeout_based_endpointing)

    @_builtins.property
    @pulumi.getter(name="audioEncoding")
    def audio_encoding(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Audio encoding of the audio content to process.
        Possible values are: `AUDIO_ENCODING_UNSPECIFIED`, `AUDIO_ENCODING_LINEAR_16`, `AUDIO_ENCODING_FLAC`, `AUDIO_ENCODING_MULAW`, `AUDIO_ENCODING_AMR`, `AUDIO_ENCODING_AMR_WB`, `AUDIO_ENCODING_OGG_OPUS`, `AUDIOENCODING_SPEEX_WITH_HEADER_BYTE`.
        """
        return pulumi.get(self, "audio_encoding")

    @audio_encoding.setter
    def audio_encoding(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audio_encoding", value)

    @_builtins.property
    @pulumi.getter(name="enableWordInfo")
    def enable_word_info(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, Dialogflow returns SpeechWordInfo in StreamingRecognitionResult with information about the recognized speech words.
        """
        return pulumi.get(self, "enable_word_info")

    @enable_word_info.setter
    def enable_word_info(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_word_info", value)

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The language of the supplied audio.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "language_code", value)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Which Speech model to select.
        Leave this field unspecified to use Agent Speech settings for model selection.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter(name="sampleRateHertz")
    def sample_rate_hertz(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sample rate (in Hertz) of the audio content sent in the query.
        """
        return pulumi.get(self, "sample_rate_hertz")

    @sample_rate_hertz.setter
    def sample_rate_hertz(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "sample_rate_hertz", value)

    @_builtins.property
    @pulumi.getter(name="speechModelVariant")
    def speech_model_variant(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The speech model used in speech to text.
        Possible values are: `SPEECH_MODEL_VARIANT_UNSPECIFIED`, `USE_BEST_AVAILABLE`, `USE_STANDARD`, `USE_ENHANCED`.
        """
        return pulumi.get(self, "speech_model_variant")

    @speech_model_variant.setter
    def speech_model_variant(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "speech_model_variant", value)

    @_builtins.property
    @pulumi.getter(name="useTimeoutBasedEndpointing")
    def use_timeout_based_endpointing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use timeout based endpointing, interpreting endpointer sensitivy as seconds of timeout value.
        """
        return pulumi.get(self, "use_timeout_based_endpointing")

    @use_timeout_based_endpointing.setter
    def use_timeout_based_endpointing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_timeout_based_endpointing", value)


if not MYPY:
    class ConversationProfileTtsConfigArgsDict(TypedDict):
        effects_profile_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        An identifier which selects 'audio effects' profiles that are applied on (post synthesized) text to speech. Effects are applied on top of each other in the order they are given.
        """
        pitch: NotRequired[pulumi.Input[_builtins.float]]
        """
        Speaking pitch, in the range [-20.0, 20.0]. 20 means increase 20 semitones from the original pitch. -20 means decrease 20 semitones from the original pitch.
        """
        speaking_rate: NotRequired[pulumi.Input[_builtins.float]]
        """
        Speaking rate/speed, in the range [0.25, 4.0].
        """
        voice: NotRequired[pulumi.Input['ConversationProfileTtsConfigVoiceArgsDict']]
        """
        The desired voice of the synthesized audio.
        Structure is documented below.
        """
        volume_gain_db: NotRequired[pulumi.Input[_builtins.float]]
        """
        Volume gain (in dB) of the normal native volume supported by the specific voice.
        """
elif False:
    ConversationProfileTtsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileTtsConfigArgs:
    def __init__(__self__, *,
                 effects_profile_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 pitch: Optional[pulumi.Input[_builtins.float]] = None,
                 speaking_rate: Optional[pulumi.Input[_builtins.float]] = None,
                 voice: Optional[pulumi.Input['ConversationProfileTtsConfigVoiceArgs']] = None,
                 volume_gain_db: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] effects_profile_ids: An identifier which selects 'audio effects' profiles that are applied on (post synthesized) text to speech. Effects are applied on top of each other in the order they are given.
        :param pulumi.Input[_builtins.float] pitch: Speaking pitch, in the range [-20.0, 20.0]. 20 means increase 20 semitones from the original pitch. -20 means decrease 20 semitones from the original pitch.
        :param pulumi.Input[_builtins.float] speaking_rate: Speaking rate/speed, in the range [0.25, 4.0].
        :param pulumi.Input['ConversationProfileTtsConfigVoiceArgs'] voice: The desired voice of the synthesized audio.
               Structure is documented below.
        :param pulumi.Input[_builtins.float] volume_gain_db: Volume gain (in dB) of the normal native volume supported by the specific voice.
        """
        if effects_profile_ids is not None:
            pulumi.set(__self__, "effects_profile_ids", effects_profile_ids)
        if pitch is not None:
            pulumi.set(__self__, "pitch", pitch)
        if speaking_rate is not None:
            pulumi.set(__self__, "speaking_rate", speaking_rate)
        if voice is not None:
            pulumi.set(__self__, "voice", voice)
        if volume_gain_db is not None:
            pulumi.set(__self__, "volume_gain_db", volume_gain_db)

    @_builtins.property
    @pulumi.getter(name="effectsProfileIds")
    def effects_profile_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        An identifier which selects 'audio effects' profiles that are applied on (post synthesized) text to speech. Effects are applied on top of each other in the order they are given.
        """
        return pulumi.get(self, "effects_profile_ids")

    @effects_profile_ids.setter
    def effects_profile_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "effects_profile_ids", value)

    @_builtins.property
    @pulumi.getter
    def pitch(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Speaking pitch, in the range [-20.0, 20.0]. 20 means increase 20 semitones from the original pitch. -20 means decrease 20 semitones from the original pitch.
        """
        return pulumi.get(self, "pitch")

    @pitch.setter
    def pitch(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "pitch", value)

    @_builtins.property
    @pulumi.getter(name="speakingRate")
    def speaking_rate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Speaking rate/speed, in the range [0.25, 4.0].
        """
        return pulumi.get(self, "speaking_rate")

    @speaking_rate.setter
    def speaking_rate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "speaking_rate", value)

    @_builtins.property
    @pulumi.getter
    def voice(self) -> Optional[pulumi.Input['ConversationProfileTtsConfigVoiceArgs']]:
        """
        The desired voice of the synthesized audio.
        Structure is documented below.
        """
        return pulumi.get(self, "voice")

    @voice.setter
    def voice(self, value: Optional[pulumi.Input['ConversationProfileTtsConfigVoiceArgs']]):
        pulumi.set(self, "voice", value)

    @_builtins.property
    @pulumi.getter(name="volumeGainDb")
    def volume_gain_db(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Volume gain (in dB) of the normal native volume supported by the specific voice.
        """
        return pulumi.get(self, "volume_gain_db")

    @volume_gain_db.setter
    def volume_gain_db(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "volume_gain_db", value)


if not MYPY:
    class ConversationProfileTtsConfigVoiceArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the voice.
        """
        ssml_gender: NotRequired[pulumi.Input[_builtins.str]]
        """
        The preferred gender of the voice.
        Possible values are: `SSML_VOICE_GENDER_UNSPECIFIED`, `SSML_VOICE_GENDER_MALE`, `SSML_VOICE_GENDER_FEMALE`, `SSML_VOICE_GENDER_NEUTRAL`.
        """
elif False:
    ConversationProfileTtsConfigVoiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConversationProfileTtsConfigVoiceArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 ssml_gender: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the voice.
        :param pulumi.Input[_builtins.str] ssml_gender: The preferred gender of the voice.
               Possible values are: `SSML_VOICE_GENDER_UNSPECIFIED`, `SSML_VOICE_GENDER_MALE`, `SSML_VOICE_GENDER_FEMALE`, `SSML_VOICE_GENDER_NEUTRAL`.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if ssml_gender is not None:
            pulumi.set(__self__, "ssml_gender", ssml_gender)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the voice.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="ssmlGender")
    def ssml_gender(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The preferred gender of the voice.
        Possible values are: `SSML_VOICE_GENDER_UNSPECIFIED`, `SSML_VOICE_GENDER_MALE`, `SSML_VOICE_GENDER_FEMALE`, `SSML_VOICE_GENDER_NEUTRAL`.
        """
        return pulumi.get(self, "ssml_gender")

    @ssml_gender.setter
    def ssml_gender(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssml_gender", value)


if not MYPY:
    class CxAgentAdvancedSettingsArgsDict(TypedDict):
        audio_export_gcs_destination: NotRequired[pulumi.Input['CxAgentAdvancedSettingsAudioExportGcsDestinationArgsDict']]
        """
        If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels:
        * Agent level
        * Flow level
        Structure is documented below.
        """
        dtmf_settings: NotRequired[pulumi.Input['CxAgentAdvancedSettingsDtmfSettingsArgsDict']]
        """
        Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
        logging_settings: NotRequired[pulumi.Input['CxAgentAdvancedSettingsLoggingSettingsArgsDict']]
        """
        Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels:
        * Agent level
        Structure is documented below.
        """
        speech_settings: NotRequired[pulumi.Input['CxAgentAdvancedSettingsSpeechSettingsArgsDict']]
        """
        Settings for speech to text detection. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
elif False:
    CxAgentAdvancedSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxAgentAdvancedSettingsArgs:
    def __init__(__self__, *,
                 audio_export_gcs_destination: Optional[pulumi.Input['CxAgentAdvancedSettingsAudioExportGcsDestinationArgs']] = None,
                 dtmf_settings: Optional[pulumi.Input['CxAgentAdvancedSettingsDtmfSettingsArgs']] = None,
                 logging_settings: Optional[pulumi.Input['CxAgentAdvancedSettingsLoggingSettingsArgs']] = None,
                 speech_settings: Optional[pulumi.Input['CxAgentAdvancedSettingsSpeechSettingsArgs']] = None):
        """
        :param pulumi.Input['CxAgentAdvancedSettingsAudioExportGcsDestinationArgs'] audio_export_gcs_destination: If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels:
               * Agent level
               * Flow level
               Structure is documented below.
        :param pulumi.Input['CxAgentAdvancedSettingsDtmfSettingsArgs'] dtmf_settings: Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
               * Agent level
               * Flow level
               * Page level
               * Parameter level
               Structure is documented below.
        :param pulumi.Input['CxAgentAdvancedSettingsLoggingSettingsArgs'] logging_settings: Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels:
               * Agent level
               Structure is documented below.
        :param pulumi.Input['CxAgentAdvancedSettingsSpeechSettingsArgs'] speech_settings: Settings for speech to text detection. Exposed at the following levels:
               * Agent level
               * Flow level
               * Page level
               * Parameter level
               Structure is documented below.
        """
        if audio_export_gcs_destination is not None:
            pulumi.set(__self__, "audio_export_gcs_destination", audio_export_gcs_destination)
        if dtmf_settings is not None:
            pulumi.set(__self__, "dtmf_settings", dtmf_settings)
        if logging_settings is not None:
            pulumi.set(__self__, "logging_settings", logging_settings)
        if speech_settings is not None:
            pulumi.set(__self__, "speech_settings", speech_settings)

    @_builtins.property
    @pulumi.getter(name="audioExportGcsDestination")
    def audio_export_gcs_destination(self) -> Optional[pulumi.Input['CxAgentAdvancedSettingsAudioExportGcsDestinationArgs']]:
        """
        If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels:
        * Agent level
        * Flow level
        Structure is documented below.
        """
        return pulumi.get(self, "audio_export_gcs_destination")

    @audio_export_gcs_destination.setter
    def audio_export_gcs_destination(self, value: Optional[pulumi.Input['CxAgentAdvancedSettingsAudioExportGcsDestinationArgs']]):
        pulumi.set(self, "audio_export_gcs_destination", value)

    @_builtins.property
    @pulumi.getter(name="dtmfSettings")
    def dtmf_settings(self) -> Optional[pulumi.Input['CxAgentAdvancedSettingsDtmfSettingsArgs']]:
        """
        Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
        return pulumi.get(self, "dtmf_settings")

    @dtmf_settings.setter
    def dtmf_settings(self, value: Optional[pulumi.Input['CxAgentAdvancedSettingsDtmfSettingsArgs']]):
        pulumi.set(self, "dtmf_settings", value)

    @_builtins.property
    @pulumi.getter(name="loggingSettings")
    def logging_settings(self) -> Optional[pulumi.Input['CxAgentAdvancedSettingsLoggingSettingsArgs']]:
        """
        Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels:
        * Agent level
        Structure is documented below.
        """
        return pulumi.get(self, "logging_settings")

    @logging_settings.setter
    def logging_settings(self, value: Optional[pulumi.Input['CxAgentAdvancedSettingsLoggingSettingsArgs']]):
        pulumi.set(self, "logging_settings", value)

    @_builtins.property
    @pulumi.getter(name="speechSettings")
    def speech_settings(self) -> Optional[pulumi.Input['CxAgentAdvancedSettingsSpeechSettingsArgs']]:
        """
        Settings for speech to text detection. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
        return pulumi.get(self, "speech_settings")

    @speech_settings.setter
    def speech_settings(self, value: Optional[pulumi.Input['CxAgentAdvancedSettingsSpeechSettingsArgs']]):
        pulumi.set(self, "speech_settings", value)


if not MYPY:
    class CxAgentAdvancedSettingsAudioExportGcsDestinationArgsDict(TypedDict):
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Google Cloud Storage URI for the exported objects. Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
        Format: gs://bucket/object-name-or-prefix
        """
elif False:
    CxAgentAdvancedSettingsAudioExportGcsDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxAgentAdvancedSettingsAudioExportGcsDestinationArgs:
    def __init__(__self__, *,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uri: The Google Cloud Storage URI for the exported objects. Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
               Format: gs://bucket/object-name-or-prefix
        """
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Google Cloud Storage URI for the exported objects. Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
        Format: gs://bucket/object-name-or-prefix
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class CxAgentAdvancedSettingsDtmfSettingsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        """
        finish_digit: NotRequired[pulumi.Input[_builtins.str]]
        """
        The digit that terminates a DTMF digit sequence.
        """
        max_digits: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max length of DTMF digits.
        """
elif False:
    CxAgentAdvancedSettingsDtmfSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxAgentAdvancedSettingsDtmfSettingsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 finish_digit: Optional[pulumi.Input[_builtins.str]] = None,
                 max_digits: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        :param pulumi.Input[_builtins.str] finish_digit: The digit that terminates a DTMF digit sequence.
        :param pulumi.Input[_builtins.int] max_digits: Max length of DTMF digits.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if finish_digit is not None:
            pulumi.set(__self__, "finish_digit", finish_digit)
        if max_digits is not None:
            pulumi.set(__self__, "max_digits", max_digits)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, incoming audio is processed for DTMF (dual tone multi frequency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will detect the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="finishDigit")
    def finish_digit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The digit that terminates a DTMF digit sequence.
        """
        return pulumi.get(self, "finish_digit")

    @finish_digit.setter
    def finish_digit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "finish_digit", value)

    @_builtins.property
    @pulumi.getter(name="maxDigits")
    def max_digits(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max length of DTMF digits.
        """
        return pulumi.get(self, "max_digits")

    @max_digits.setter
    def max_digits(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_digits", value)


if not MYPY:
    class CxAgentAdvancedSettingsLoggingSettingsArgsDict(TypedDict):
        enable_consent_based_redaction: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables consent-based end-user input redaction, if true, a pre-defined session parameter **$session.params.conversation-redaction** will be used to determine if the utterance should be redacted.
        """
        enable_interaction_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables DF Interaction logging.
        """
        enable_stackdriver_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables Google Cloud Logging.
        """
elif False:
    CxAgentAdvancedSettingsLoggingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxAgentAdvancedSettingsLoggingSettingsArgs:
    def __init__(__self__, *,
                 enable_consent_based_redaction: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_interaction_logging: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_stackdriver_logging: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_consent_based_redaction: Enables consent-based end-user input redaction, if true, a pre-defined session parameter **$session.params.conversation-redaction** will be used to determine if the utterance should be redacted.
        :param pulumi.Input[_builtins.bool] enable_interaction_logging: Enables DF Interaction logging.
        :param pulumi.Input[_builtins.bool] enable_stackdriver_logging: Enables Google Cloud Logging.
        """
        if enable_consent_based_redaction is not None:
            pulumi.set(__self__, "enable_consent_based_redaction", enable_consent_based_redaction)
        if enable_interaction_logging is not None:
            pulumi.set(__self__, "enable_interaction_logging", enable_interaction_logging)
        if enable_stackdriver_logging is not None:
            pulumi.set(__self__, "enable_stackdriver_logging", enable_stackdriver_logging)

    @_builtins.property
    @pulumi.getter(name="enableConsentBasedRedaction")
    def enable_consent_based_redaction(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables consent-based end-user input redaction, if true, a pre-defined session parameter **$session.params.conversation-redaction** will be used to determine if the utterance should be redacted.
        """
        return pulumi.get(self, "enable_consent_based_redaction")

    @enable_consent_based_redaction.setter
    def enable_consent_based_redaction(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_consent_based_redaction", value)

    @_builtins.property
    @pulumi.getter(name="enableInteractionLogging")
    def enable_interaction_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables DF Interaction logging.
        """
        return pulumi.get(self, "enable_interaction_logging")

    @enable_interaction_logging.setter
    def enable_interaction_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_interaction_logging", value)

    @_builtins.property
    @pulumi.getter(name="enableStackdriverLogging")
    def enable_stackdriver_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables Google Cloud Logging.
        """
        return pulumi.get(self, "enable_stackdriver_logging")

    @enable_stackdriver_logging.setter
    def enable_stackdriver_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_stackdriver_logging", value)


if not MYPY:
    class CxAgentAdvancedSettingsSpeechSettingsArgsDict(TypedDict):
        endpointer_sensitivity: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
        """
        models: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
        An object containing a list of **"key": value** pairs. Example: **{ "name": "wrench", "mass": "1.3kg", "count": "3" }**.
        """
        no_speech_timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timeout before detecting no speech.
        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
        """
        use_timeout_based_endpointing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use timeout based endpointing, interpreting endpointer sensitivity as seconds of timeout value.
        """
elif False:
    CxAgentAdvancedSettingsSpeechSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxAgentAdvancedSettingsSpeechSettingsArgs:
    def __init__(__self__, *,
                 endpointer_sensitivity: Optional[pulumi.Input[_builtins.int]] = None,
                 models: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 no_speech_timeout: Optional[pulumi.Input[_builtins.str]] = None,
                 use_timeout_based_endpointing: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] endpointer_sensitivity: Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] models: Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
               An object containing a list of **"key": value** pairs. Example: **{ "name": "wrench", "mass": "1.3kg", "count": "3" }**.
        :param pulumi.Input[_builtins.str] no_speech_timeout: Timeout before detecting no speech.
               A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
        :param pulumi.Input[_builtins.bool] use_timeout_based_endpointing: Use timeout based endpointing, interpreting endpointer sensitivity as seconds of timeout value.
        """
        if endpointer_sensitivity is not None:
            pulumi.set(__self__, "endpointer_sensitivity", endpointer_sensitivity)
        if models is not None:
            pulumi.set(__self__, "models", models)
        if no_speech_timeout is not None:
            pulumi.set(__self__, "no_speech_timeout", no_speech_timeout)
        if use_timeout_based_endpointing is not None:
            pulumi.set(__self__, "use_timeout_based_endpointing", use_timeout_based_endpointing)

    @_builtins.property
    @pulumi.getter(name="endpointerSensitivity")
    def endpointer_sensitivity(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
        """
        return pulumi.get(self, "endpointer_sensitivity")

    @endpointer_sensitivity.setter
    def endpointer_sensitivity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "endpointer_sensitivity", value)

    @_builtins.property
    @pulumi.getter
    def models(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
        An object containing a list of **"key": value** pairs. Example: **{ "name": "wrench", "mass": "1.3kg", "count": "3" }**.
        """
        return pulumi.get(self, "models")

    @models.setter
    def models(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "models", value)

    @_builtins.property
    @pulumi.getter(name="noSpeechTimeout")
    def no_speech_timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timeout before detecting no speech.
        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
        """
        return pulumi.get(self, "no_speech_timeout")

    @no_speech_timeout.setter
    def no_speech_timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "no_speech_timeout", value)

    @_builtins.property
    @pulumi.getter(name="useTimeoutBasedEndpointing")
    def use_timeout_based_endpointing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use timeout based endpointing, interpreting endpointer sensitivity as seconds of timeout value.
        """
        return pulumi.get(self, "use_timeout_based_endpointing")

    @use_timeout_based_endpointing.setter
    def use_timeout_based_endpointing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_timeout_based_endpointing", value)


if not MYPY:
    class CxAgentAnswerFeedbackSettingsArgsDict(TypedDict):
        enable_answer_feedback: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If enabled, end users will be able to provide [answer feedback](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.sessions/submitAnswerFeedback#body.AnswerFeedback)
        to Dialogflow responses. Feature works only if interaction logging is enabled in the Dialogflow agent.
        """
elif False:
    CxAgentAnswerFeedbackSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxAgentAnswerFeedbackSettingsArgs:
    def __init__(__self__, *,
                 enable_answer_feedback: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_answer_feedback: If enabled, end users will be able to provide [answer feedback](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.sessions/submitAnswerFeedback#body.AnswerFeedback)
               to Dialogflow responses. Feature works only if interaction logging is enabled in the Dialogflow agent.
        """
        if enable_answer_feedback is not None:
            pulumi.set(__self__, "enable_answer_feedback", enable_answer_feedback)

    @_builtins.property
    @pulumi.getter(name="enableAnswerFeedback")
    def enable_answer_feedback(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If enabled, end users will be able to provide [answer feedback](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.sessions/submitAnswerFeedback#body.AnswerFeedback)
        to Dialogflow responses. Feature works only if interaction logging is enabled in the Dialogflow agent.
        """
        return pulumi.get(self, "enable_answer_feedback")

    @enable_answer_feedback.setter
    def enable_answer_feedback(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_answer_feedback", value)


if not MYPY:
    class CxAgentClientCertificateSettingsArgsDict(TypedDict):
        private_key: pulumi.Input[_builtins.str]
        """
        The name of the SecretManager secret version resource storing the private key encoded in PEM format. Format: **projects/{project}/secrets/{secret}/versions/{version}**
        """
        ssl_certificate: pulumi.Input[_builtins.str]
        """
        The ssl certificate encoded in PEM format. This string must include the begin header and end footer lines.
        """
        passphrase: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the SecretManager secret version resource storing the passphrase. 'passphrase' should be left unset if the private key is not encrypted. Format: **projects/{project}/secrets/{secret}/versions/{version}**
        """
elif False:
    CxAgentClientCertificateSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxAgentClientCertificateSettingsArgs:
    def __init__(__self__, *,
                 private_key: pulumi.Input[_builtins.str],
                 ssl_certificate: pulumi.Input[_builtins.str],
                 passphrase: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] private_key: The name of the SecretManager secret version resource storing the private key encoded in PEM format. Format: **projects/{project}/secrets/{secret}/versions/{version}**
        :param pulumi.Input[_builtins.str] ssl_certificate: The ssl certificate encoded in PEM format. This string must include the begin header and end footer lines.
        :param pulumi.Input[_builtins.str] passphrase: The name of the SecretManager secret version resource storing the passphrase. 'passphrase' should be left unset if the private key is not encrypted. Format: **projects/{project}/secrets/{secret}/versions/{version}**
        """
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "ssl_certificate", ssl_certificate)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SecretManager secret version resource storing the private key encoded in PEM format. Format: **projects/{project}/secrets/{secret}/versions/{version}**
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="sslCertificate")
    def ssl_certificate(self) -> pulumi.Input[_builtins.str]:
        """
        The ssl certificate encoded in PEM format. This string must include the begin header and end footer lines.
        """
        return pulumi.get(self, "ssl_certificate")

    @ssl_certificate.setter
    def ssl_certificate(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ssl_certificate", value)

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the SecretManager secret version resource storing the passphrase. 'passphrase' should be left unset if the private key is not encrypted. Format: **projects/{project}/secrets/{secret}/versions/{version}**
        """
        return pulumi.get(self, "passphrase")

    @passphrase.setter
    def passphrase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "passphrase", value)


if not MYPY:
    class CxAgentGenAppBuilderSettingsArgsDict(TypedDict):
        engine: pulumi.Input[_builtins.str]
        """
        The full name of the Gen App Builder engine related to this agent if there is one.
        Format: projects/{Project ID}/locations/{Location ID}/collections/{Collection ID}/engines/{Engine ID}
        """
elif False:
    CxAgentGenAppBuilderSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxAgentGenAppBuilderSettingsArgs:
    def __init__(__self__, *,
                 engine: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] engine: The full name of the Gen App Builder engine related to this agent if there is one.
               Format: projects/{Project ID}/locations/{Location ID}/collections/{Collection ID}/engines/{Engine ID}
        """
        pulumi.set(__self__, "engine", engine)

    @_builtins.property
    @pulumi.getter
    def engine(self) -> pulumi.Input[_builtins.str]:
        """
        The full name of the Gen App Builder engine related to this agent if there is one.
        Format: projects/{Project ID}/locations/{Location ID}/collections/{Collection ID}/engines/{Engine ID}
        """
        return pulumi.get(self, "engine")

    @engine.setter
    def engine(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "engine", value)


if not MYPY:
    class CxAgentGitIntegrationSettingsArgsDict(TypedDict):
        github_settings: NotRequired[pulumi.Input['CxAgentGitIntegrationSettingsGithubSettingsArgsDict']]
        """
        Settings of integration with GitHub.
        Structure is documented below.
        """
elif False:
    CxAgentGitIntegrationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxAgentGitIntegrationSettingsArgs:
    def __init__(__self__, *,
                 github_settings: Optional[pulumi.Input['CxAgentGitIntegrationSettingsGithubSettingsArgs']] = None):
        """
        :param pulumi.Input['CxAgentGitIntegrationSettingsGithubSettingsArgs'] github_settings: Settings of integration with GitHub.
               Structure is documented below.
        """
        if github_settings is not None:
            pulumi.set(__self__, "github_settings", github_settings)

    @_builtins.property
    @pulumi.getter(name="githubSettings")
    def github_settings(self) -> Optional[pulumi.Input['CxAgentGitIntegrationSettingsGithubSettingsArgs']]:
        """
        Settings of integration with GitHub.
        Structure is documented below.
        """
        return pulumi.get(self, "github_settings")

    @github_settings.setter
    def github_settings(self, value: Optional[pulumi.Input['CxAgentGitIntegrationSettingsGithubSettingsArgs']]):
        pulumi.set(self, "github_settings", value)


if not MYPY:
    class CxAgentGitIntegrationSettingsGithubSettingsArgsDict(TypedDict):
        access_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        The access token used to authenticate the access to the GitHub repository.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        branches: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of branches configured to be used from Dialogflow.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique repository display name for the GitHub repository.
        """
        repository_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        The GitHub repository URI related to the agent.
        """
        tracking_branch: NotRequired[pulumi.Input[_builtins.str]]
        """
        The branch of the GitHub repository tracked for this agent.
        """
elif False:
    CxAgentGitIntegrationSettingsGithubSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxAgentGitIntegrationSettingsGithubSettingsArgs:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input[_builtins.str]] = None,
                 branches: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 repository_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 tracking_branch: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] access_token: The access token used to authenticate the access to the GitHub repository.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] branches: A list of branches configured to be used from Dialogflow.
        :param pulumi.Input[_builtins.str] display_name: The unique repository display name for the GitHub repository.
        :param pulumi.Input[_builtins.str] repository_uri: The GitHub repository URI related to the agent.
        :param pulumi.Input[_builtins.str] tracking_branch: The branch of the GitHub repository tracked for this agent.
        """
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if branches is not None:
            pulumi.set(__self__, "branches", branches)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if repository_uri is not None:
            pulumi.set(__self__, "repository_uri", repository_uri)
        if tracking_branch is not None:
            pulumi.set(__self__, "tracking_branch", tracking_branch)

    @_builtins.property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The access token used to authenticate the access to the GitHub repository.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "access_token", value)

    @_builtins.property
    @pulumi.getter
    def branches(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of branches configured to be used from Dialogflow.
        """
        return pulumi.get(self, "branches")

    @branches.setter
    def branches(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "branches", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique repository display name for the GitHub repository.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="repositoryUri")
    def repository_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The GitHub repository URI related to the agent.
        """
        return pulumi.get(self, "repository_uri")

    @repository_uri.setter
    def repository_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repository_uri", value)

    @_builtins.property
    @pulumi.getter(name="trackingBranch")
    def tracking_branch(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The branch of the GitHub repository tracked for this agent.
        """
        return pulumi.get(self, "tracking_branch")

    @tracking_branch.setter
    def tracking_branch(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tracking_branch", value)


if not MYPY:
    class CxAgentPersonalizationSettingsArgsDict(TypedDict):
        default_end_user_metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        Default end user metadata, used when processing DetectIntent requests. Recommended to be filled as a template instead of hard-coded value, for example { "age": "$session.params.age" }.
        The data will be merged with the [QueryParameters.end_user_metadata](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/QueryParameters#FIELDS.end_user_metadata)
        in [DetectIntentRequest.query_params](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.sessions/detectIntent#body.request_body.FIELDS.query_params) during query processing.
        This field uses JSON data as a string. The value provided must be a valid JSON representation documented in [Struct](https://protobuf.dev/reference/protobuf/google.protobuf/#struct).
        """
elif False:
    CxAgentPersonalizationSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxAgentPersonalizationSettingsArgs:
    def __init__(__self__, *,
                 default_end_user_metadata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] default_end_user_metadata: Default end user metadata, used when processing DetectIntent requests. Recommended to be filled as a template instead of hard-coded value, for example { "age": "$session.params.age" }.
               The data will be merged with the [QueryParameters.end_user_metadata](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/QueryParameters#FIELDS.end_user_metadata)
               in [DetectIntentRequest.query_params](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.sessions/detectIntent#body.request_body.FIELDS.query_params) during query processing.
               This field uses JSON data as a string. The value provided must be a valid JSON representation documented in [Struct](https://protobuf.dev/reference/protobuf/google.protobuf/#struct).
        """
        if default_end_user_metadata is not None:
            pulumi.set(__self__, "default_end_user_metadata", default_end_user_metadata)

    @_builtins.property
    @pulumi.getter(name="defaultEndUserMetadata")
    def default_end_user_metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default end user metadata, used when processing DetectIntent requests. Recommended to be filled as a template instead of hard-coded value, for example { "age": "$session.params.age" }.
        The data will be merged with the [QueryParameters.end_user_metadata](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/QueryParameters#FIELDS.end_user_metadata)
        in [DetectIntentRequest.query_params](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.sessions/detectIntent#body.request_body.FIELDS.query_params) during query processing.
        This field uses JSON data as a string. The value provided must be a valid JSON representation documented in [Struct](https://protobuf.dev/reference/protobuf/google.protobuf/#struct).
        """
        return pulumi.get(self, "default_end_user_metadata")

    @default_end_user_metadata.setter
    def default_end_user_metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_end_user_metadata", value)


if not MYPY:
    class CxAgentSpeechToTextSettingsArgsDict(TypedDict):
        enable_speech_adaptation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to use speech adaptation for speech recognition.
        """
elif False:
    CxAgentSpeechToTextSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxAgentSpeechToTextSettingsArgs:
    def __init__(__self__, *,
                 enable_speech_adaptation: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_speech_adaptation: Whether to use speech adaptation for speech recognition.
        """
        if enable_speech_adaptation is not None:
            pulumi.set(__self__, "enable_speech_adaptation", enable_speech_adaptation)

    @_builtins.property
    @pulumi.getter(name="enableSpeechAdaptation")
    def enable_speech_adaptation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to use speech adaptation for speech recognition.
        """
        return pulumi.get(self, "enable_speech_adaptation")

    @enable_speech_adaptation.setter
    def enable_speech_adaptation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_speech_adaptation", value)


if not MYPY:
    class CxAgentTextToSpeechSettingsArgsDict(TypedDict):
        synthesize_speech_configs: NotRequired[pulumi.Input[_builtins.str]]
        """
        Configuration of how speech should be synthesized, mapping from [language](https://cloud.google.com/dialogflow/cx/docs/reference/language) to [SynthesizeSpeechConfig](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents#synthesizespeechconfig).
        These settings affect:
        * The phone gateway synthesize configuration set via Agent.text_to_speech_settings.
        * How speech is synthesized when invoking session APIs. `Agent.text_to_speech_settings` only applies if `OutputAudioConfig.synthesize_speech_config` is not specified.
        """
elif False:
    CxAgentTextToSpeechSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxAgentTextToSpeechSettingsArgs:
    def __init__(__self__, *,
                 synthesize_speech_configs: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] synthesize_speech_configs: Configuration of how speech should be synthesized, mapping from [language](https://cloud.google.com/dialogflow/cx/docs/reference/language) to [SynthesizeSpeechConfig](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents#synthesizespeechconfig).
               These settings affect:
               * The phone gateway synthesize configuration set via Agent.text_to_speech_settings.
               * How speech is synthesized when invoking session APIs. `Agent.text_to_speech_settings` only applies if `OutputAudioConfig.synthesize_speech_config` is not specified.
        """
        if synthesize_speech_configs is not None:
            pulumi.set(__self__, "synthesize_speech_configs", synthesize_speech_configs)

    @_builtins.property
    @pulumi.getter(name="synthesizeSpeechConfigs")
    def synthesize_speech_configs(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Configuration of how speech should be synthesized, mapping from [language](https://cloud.google.com/dialogflow/cx/docs/reference/language) to [SynthesizeSpeechConfig](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents#synthesizespeechconfig).
        These settings affect:
        * The phone gateway synthesize configuration set via Agent.text_to_speech_settings.
        * How speech is synthesized when invoking session APIs. `Agent.text_to_speech_settings` only applies if `OutputAudioConfig.synthesize_speech_config` is not specified.
        """
        return pulumi.get(self, "synthesize_speech_configs")

    @synthesize_speech_configs.setter
    def synthesize_speech_configs(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "synthesize_speech_configs", value)


if not MYPY:
    class CxEntityTypeEntityArgsDict(TypedDict):
        synonyms: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A collection of value synonyms. For example, if the entity type is vegetable, and value is scallions, a synonym could be green onions.
        For KIND_LIST entity types: This collection must contain exactly one synonym equal to value.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The primary value associated with this entity entry. For example, if the entity type is vegetable, the value could be scallions.
        For KIND_MAP entity types: A canonical value to be used in place of synonyms.
        For KIND_LIST entity types: A string that can contain references to other entity types (with or without aliases).
        """
elif False:
    CxEntityTypeEntityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxEntityTypeEntityArgs:
    def __init__(__self__, *,
                 synonyms: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] synonyms: A collection of value synonyms. For example, if the entity type is vegetable, and value is scallions, a synonym could be green onions.
               For KIND_LIST entity types: This collection must contain exactly one synonym equal to value.
        :param pulumi.Input[_builtins.str] value: The primary value associated with this entity entry. For example, if the entity type is vegetable, the value could be scallions.
               For KIND_MAP entity types: A canonical value to be used in place of synonyms.
               For KIND_LIST entity types: A string that can contain references to other entity types (with or without aliases).
        """
        if synonyms is not None:
            pulumi.set(__self__, "synonyms", synonyms)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def synonyms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A collection of value synonyms. For example, if the entity type is vegetable, and value is scallions, a synonym could be green onions.
        For KIND_LIST entity types: This collection must contain exactly one synonym equal to value.
        """
        return pulumi.get(self, "synonyms")

    @synonyms.setter
    def synonyms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "synonyms", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The primary value associated with this entity entry. For example, if the entity type is vegetable, the value could be scallions.
        For KIND_MAP entity types: A canonical value to be used in place of synonyms.
        For KIND_LIST entity types: A string that can contain references to other entity types (with or without aliases).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CxEntityTypeExcludedPhraseArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The word or phrase to be excluded.
        """
elif False:
    CxEntityTypeExcludedPhraseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxEntityTypeExcludedPhraseArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] value: The word or phrase to be excluded.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The word or phrase to be excluded.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CxEnvironmentVersionConfigArgsDict(TypedDict):
        version: pulumi.Input[_builtins.str]
        """
        Format: projects/{{project}}/locations/{{location}}/agents/{{agent}}/flows/{{flow}}/versions/{{version}}.
        """
elif False:
    CxEnvironmentVersionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxEnvironmentVersionConfigArgs:
    def __init__(__self__, *,
                 version: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] version: Format: projects/{{project}}/locations/{{location}}/agents/{{agent}}/flows/{{flow}}/versions/{{version}}.
        """
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.str]:
        """
        Format: projects/{{project}}/locations/{{location}}/agents/{{agent}}/flows/{{flow}}/versions/{{version}}.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version", value)


if not MYPY:
    class CxFlowAdvancedSettingsArgsDict(TypedDict):
        audio_export_gcs_destination: NotRequired[pulumi.Input['CxFlowAdvancedSettingsAudioExportGcsDestinationArgsDict']]
        """
        If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels:
        * Agent level
        * Flow level
        Structure is documented below.
        """
        dtmf_settings: NotRequired[pulumi.Input['CxFlowAdvancedSettingsDtmfSettingsArgsDict']]
        """
        Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
        logging_settings: NotRequired[pulumi.Input['CxFlowAdvancedSettingsLoggingSettingsArgsDict']]
        """
        Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels:
        * Agent level
        Structure is documented below.
        """
        speech_settings: NotRequired[pulumi.Input['CxFlowAdvancedSettingsSpeechSettingsArgsDict']]
        """
        Settings for speech to text detection. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
elif False:
    CxFlowAdvancedSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowAdvancedSettingsArgs:
    def __init__(__self__, *,
                 audio_export_gcs_destination: Optional[pulumi.Input['CxFlowAdvancedSettingsAudioExportGcsDestinationArgs']] = None,
                 dtmf_settings: Optional[pulumi.Input['CxFlowAdvancedSettingsDtmfSettingsArgs']] = None,
                 logging_settings: Optional[pulumi.Input['CxFlowAdvancedSettingsLoggingSettingsArgs']] = None,
                 speech_settings: Optional[pulumi.Input['CxFlowAdvancedSettingsSpeechSettingsArgs']] = None):
        """
        :param pulumi.Input['CxFlowAdvancedSettingsAudioExportGcsDestinationArgs'] audio_export_gcs_destination: If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels:
               * Agent level
               * Flow level
               Structure is documented below.
        :param pulumi.Input['CxFlowAdvancedSettingsDtmfSettingsArgs'] dtmf_settings: Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
               * Agent level
               * Flow level
               * Page level
               * Parameter level
               Structure is documented below.
        :param pulumi.Input['CxFlowAdvancedSettingsLoggingSettingsArgs'] logging_settings: Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels:
               * Agent level
               Structure is documented below.
        :param pulumi.Input['CxFlowAdvancedSettingsSpeechSettingsArgs'] speech_settings: Settings for speech to text detection. Exposed at the following levels:
               * Agent level
               * Flow level
               * Page level
               * Parameter level
               Structure is documented below.
        """
        if audio_export_gcs_destination is not None:
            pulumi.set(__self__, "audio_export_gcs_destination", audio_export_gcs_destination)
        if dtmf_settings is not None:
            pulumi.set(__self__, "dtmf_settings", dtmf_settings)
        if logging_settings is not None:
            pulumi.set(__self__, "logging_settings", logging_settings)
        if speech_settings is not None:
            pulumi.set(__self__, "speech_settings", speech_settings)

    @_builtins.property
    @pulumi.getter(name="audioExportGcsDestination")
    def audio_export_gcs_destination(self) -> Optional[pulumi.Input['CxFlowAdvancedSettingsAudioExportGcsDestinationArgs']]:
        """
        If present, incoming audio is exported by Dialogflow to the configured Google Cloud Storage destination. Exposed at the following levels:
        * Agent level
        * Flow level
        Structure is documented below.
        """
        return pulumi.get(self, "audio_export_gcs_destination")

    @audio_export_gcs_destination.setter
    def audio_export_gcs_destination(self, value: Optional[pulumi.Input['CxFlowAdvancedSettingsAudioExportGcsDestinationArgs']]):
        pulumi.set(self, "audio_export_gcs_destination", value)

    @_builtins.property
    @pulumi.getter(name="dtmfSettings")
    def dtmf_settings(self) -> Optional[pulumi.Input['CxFlowAdvancedSettingsDtmfSettingsArgs']]:
        """
        Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
        return pulumi.get(self, "dtmf_settings")

    @dtmf_settings.setter
    def dtmf_settings(self, value: Optional[pulumi.Input['CxFlowAdvancedSettingsDtmfSettingsArgs']]):
        pulumi.set(self, "dtmf_settings", value)

    @_builtins.property
    @pulumi.getter(name="loggingSettings")
    def logging_settings(self) -> Optional[pulumi.Input['CxFlowAdvancedSettingsLoggingSettingsArgs']]:
        """
        Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels:
        * Agent level
        Structure is documented below.
        """
        return pulumi.get(self, "logging_settings")

    @logging_settings.setter
    def logging_settings(self, value: Optional[pulumi.Input['CxFlowAdvancedSettingsLoggingSettingsArgs']]):
        pulumi.set(self, "logging_settings", value)

    @_builtins.property
    @pulumi.getter(name="speechSettings")
    def speech_settings(self) -> Optional[pulumi.Input['CxFlowAdvancedSettingsSpeechSettingsArgs']]:
        """
        Settings for speech to text detection. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
        return pulumi.get(self, "speech_settings")

    @speech_settings.setter
    def speech_settings(self, value: Optional[pulumi.Input['CxFlowAdvancedSettingsSpeechSettingsArgs']]):
        pulumi.set(self, "speech_settings", value)


if not MYPY:
    class CxFlowAdvancedSettingsAudioExportGcsDestinationArgsDict(TypedDict):
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Google Cloud Storage URI for the exported objects. Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
        Format: gs://bucket/object-name-or-prefix
        """
elif False:
    CxFlowAdvancedSettingsAudioExportGcsDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowAdvancedSettingsAudioExportGcsDestinationArgs:
    def __init__(__self__, *,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uri: The Google Cloud Storage URI for the exported objects. Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
               Format: gs://bucket/object-name-or-prefix
        """
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Google Cloud Storage URI for the exported objects. Whether a full object name, or just a prefix, its usage depends on the Dialogflow operation.
        Format: gs://bucket/object-name-or-prefix
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class CxFlowAdvancedSettingsDtmfSettingsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        """
        finish_digit: NotRequired[pulumi.Input[_builtins.str]]
        """
        The digit that terminates a DTMF digit sequence.
        """
        max_digits: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max length of DTMF digits.
        """
elif False:
    CxFlowAdvancedSettingsDtmfSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowAdvancedSettingsDtmfSettingsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 finish_digit: Optional[pulumi.Input[_builtins.str]] = None,
                 max_digits: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        :param pulumi.Input[_builtins.str] finish_digit: The digit that terminates a DTMF digit sequence.
        :param pulumi.Input[_builtins.int] max_digits: Max length of DTMF digits.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if finish_digit is not None:
            pulumi.set(__self__, "finish_digit", finish_digit)
        if max_digits is not None:
            pulumi.set(__self__, "max_digits", max_digits)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="finishDigit")
    def finish_digit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The digit that terminates a DTMF digit sequence.
        """
        return pulumi.get(self, "finish_digit")

    @finish_digit.setter
    def finish_digit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "finish_digit", value)

    @_builtins.property
    @pulumi.getter(name="maxDigits")
    def max_digits(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max length of DTMF digits.
        """
        return pulumi.get(self, "max_digits")

    @max_digits.setter
    def max_digits(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_digits", value)


if not MYPY:
    class CxFlowAdvancedSettingsLoggingSettingsArgsDict(TypedDict):
        enable_consent_based_redaction: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables consent-based end-user input redaction, if true, a pre-defined session parameter **$session.params.conversation-redaction** will be used to determine if the utterance should be redacted.
        """
        enable_interaction_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables DF Interaction logging.
        """
        enable_stackdriver_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables Google Cloud Logging.
        """
elif False:
    CxFlowAdvancedSettingsLoggingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowAdvancedSettingsLoggingSettingsArgs:
    def __init__(__self__, *,
                 enable_consent_based_redaction: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_interaction_logging: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_stackdriver_logging: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_consent_based_redaction: Enables consent-based end-user input redaction, if true, a pre-defined session parameter **$session.params.conversation-redaction** will be used to determine if the utterance should be redacted.
        :param pulumi.Input[_builtins.bool] enable_interaction_logging: Enables DF Interaction logging.
        :param pulumi.Input[_builtins.bool] enable_stackdriver_logging: Enables Google Cloud Logging.
        """
        if enable_consent_based_redaction is not None:
            pulumi.set(__self__, "enable_consent_based_redaction", enable_consent_based_redaction)
        if enable_interaction_logging is not None:
            pulumi.set(__self__, "enable_interaction_logging", enable_interaction_logging)
        if enable_stackdriver_logging is not None:
            pulumi.set(__self__, "enable_stackdriver_logging", enable_stackdriver_logging)

    @_builtins.property
    @pulumi.getter(name="enableConsentBasedRedaction")
    def enable_consent_based_redaction(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables consent-based end-user input redaction, if true, a pre-defined session parameter **$session.params.conversation-redaction** will be used to determine if the utterance should be redacted.
        """
        return pulumi.get(self, "enable_consent_based_redaction")

    @enable_consent_based_redaction.setter
    def enable_consent_based_redaction(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_consent_based_redaction", value)

    @_builtins.property
    @pulumi.getter(name="enableInteractionLogging")
    def enable_interaction_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables DF Interaction logging.
        """
        return pulumi.get(self, "enable_interaction_logging")

    @enable_interaction_logging.setter
    def enable_interaction_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_interaction_logging", value)

    @_builtins.property
    @pulumi.getter(name="enableStackdriverLogging")
    def enable_stackdriver_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables Google Cloud Logging.
        """
        return pulumi.get(self, "enable_stackdriver_logging")

    @enable_stackdriver_logging.setter
    def enable_stackdriver_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_stackdriver_logging", value)


if not MYPY:
    class CxFlowAdvancedSettingsSpeechSettingsArgsDict(TypedDict):
        endpointer_sensitivity: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
        """
        models: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
        An object containing a list of **"key": value** pairs. Example: **{ "name": "wrench", "mass": "1.3kg", "count": "3" }**.
        """
        no_speech_timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timeout before detecting no speech.
        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        """
        use_timeout_based_endpointing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use timeout based endpointing, interpreting endpointer sensitivity as seconds of timeout value.
        """
elif False:
    CxFlowAdvancedSettingsSpeechSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowAdvancedSettingsSpeechSettingsArgs:
    def __init__(__self__, *,
                 endpointer_sensitivity: Optional[pulumi.Input[_builtins.int]] = None,
                 models: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 no_speech_timeout: Optional[pulumi.Input[_builtins.str]] = None,
                 use_timeout_based_endpointing: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] endpointer_sensitivity: Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] models: Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
               An object containing a list of **"key": value** pairs. Example: **{ "name": "wrench", "mass": "1.3kg", "count": "3" }**.
        :param pulumi.Input[_builtins.str] no_speech_timeout: Timeout before detecting no speech.
               A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        :param pulumi.Input[_builtins.bool] use_timeout_based_endpointing: Use timeout based endpointing, interpreting endpointer sensitivity as seconds of timeout value.
        """
        if endpointer_sensitivity is not None:
            pulumi.set(__self__, "endpointer_sensitivity", endpointer_sensitivity)
        if models is not None:
            pulumi.set(__self__, "models", models)
        if no_speech_timeout is not None:
            pulumi.set(__self__, "no_speech_timeout", no_speech_timeout)
        if use_timeout_based_endpointing is not None:
            pulumi.set(__self__, "use_timeout_based_endpointing", use_timeout_based_endpointing)

    @_builtins.property
    @pulumi.getter(name="endpointerSensitivity")
    def endpointer_sensitivity(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
        """
        return pulumi.get(self, "endpointer_sensitivity")

    @endpointer_sensitivity.setter
    def endpointer_sensitivity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "endpointer_sensitivity", value)

    @_builtins.property
    @pulumi.getter
    def models(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
        An object containing a list of **"key": value** pairs. Example: **{ "name": "wrench", "mass": "1.3kg", "count": "3" }**.
        """
        return pulumi.get(self, "models")

    @models.setter
    def models(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "models", value)

    @_builtins.property
    @pulumi.getter(name="noSpeechTimeout")
    def no_speech_timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timeout before detecting no speech.
        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        """
        return pulumi.get(self, "no_speech_timeout")

    @no_speech_timeout.setter
    def no_speech_timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "no_speech_timeout", value)

    @_builtins.property
    @pulumi.getter(name="useTimeoutBasedEndpointing")
    def use_timeout_based_endpointing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use timeout based endpointing, interpreting endpointer sensitivity as seconds of timeout value.
        """
        return pulumi.get(self, "use_timeout_based_endpointing")

    @use_timeout_based_endpointing.setter
    def use_timeout_based_endpointing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_timeout_based_endpointing", value)


if not MYPY:
    class CxFlowEventHandlerArgsDict(TypedDict):
        event: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the event to handle.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The unique identifier of this event handler.
        """
        target_flow: NotRequired[pulumi.Input[_builtins.str]]
        """
        The target flow to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        """
        target_page: NotRequired[pulumi.Input[_builtins.str]]
        """
        The target page to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        trigger_fulfillment: NotRequired[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentArgsDict']]
        """
        The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
        Structure is documented below.
        """
elif False:
    CxFlowEventHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowEventHandlerArgs:
    def __init__(__self__, *,
                 event: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 target_flow: Optional[pulumi.Input[_builtins.str]] = None,
                 target_page: Optional[pulumi.Input[_builtins.str]] = None,
                 trigger_fulfillment: Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] event: The name of the event to handle.
        :param pulumi.Input[_builtins.str] name: (Output)
               The unique identifier of this event handler.
        :param pulumi.Input[_builtins.str] target_flow: The target flow to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        :param pulumi.Input[_builtins.str] target_page: The target page to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        :param pulumi.Input['CxFlowEventHandlerTriggerFulfillmentArgs'] trigger_fulfillment: The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
               Structure is documented below.
        """
        if event is not None:
            pulumi.set(__self__, "event", event)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target_flow is not None:
            pulumi.set(__self__, "target_flow", target_flow)
        if target_page is not None:
            pulumi.set(__self__, "target_page", target_page)
        if trigger_fulfillment is not None:
            pulumi.set(__self__, "trigger_fulfillment", trigger_fulfillment)

    @_builtins.property
    @pulumi.getter
    def event(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the event to handle.
        """
        return pulumi.get(self, "event")

    @event.setter
    def event(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The unique identifier of this event handler.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="targetFlow")
    def target_flow(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The target flow to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        """
        return pulumi.get(self, "target_flow")

    @target_flow.setter
    def target_flow(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_flow", value)

    @_builtins.property
    @pulumi.getter(name="targetPage")
    def target_page(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The target page to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        return pulumi.get(self, "target_page")

    @target_page.setter
    def target_page(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_page", value)

    @_builtins.property
    @pulumi.getter(name="triggerFulfillment")
    def trigger_fulfillment(self) -> Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentArgs']]:
        """
        The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
        Structure is documented below.
        """
        return pulumi.get(self, "trigger_fulfillment")

    @trigger_fulfillment.setter
    def trigger_fulfillment(self, value: Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentArgs']]):
        pulumi.set(self, "trigger_fulfillment", value)


if not MYPY:
    class CxFlowEventHandlerTriggerFulfillmentArgsDict(TypedDict):
        conditional_cases: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentConditionalCaseArgsDict']]]]
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        enable_generative_fallback: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
        """
        messages: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageArgsDict']]]]
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return_partial_responses: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        set_parameter_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentSetParameterActionArgsDict']]]]
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        webhook: NotRequired[pulumi.Input[_builtins.str]]
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
elif False:
    CxFlowEventHandlerTriggerFulfillmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowEventHandlerTriggerFulfillmentArgs:
    def __init__(__self__, *,
                 conditional_cases: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentConditionalCaseArgs']]]] = None,
                 enable_generative_fallback: Optional[pulumi.Input[_builtins.bool]] = None,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageArgs']]]] = None,
                 return_partial_responses: Optional[pulumi.Input[_builtins.bool]] = None,
                 set_parameter_actions: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentSetParameterActionArgs']]]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None,
                 webhook: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentConditionalCaseArgs']]] conditional_cases: Conditional cases for this fulfillment.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] enable_generative_fallback: If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
        :param pulumi.Input[Sequence[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageArgs']]] messages: The list of rich message responses to present to the user.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] return_partial_responses: Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        :param pulumi.Input[Sequence[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentSetParameterActionArgs']]] set_parameter_actions: Set parameter values before executing the webhook.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] tag: The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        :param pulumi.Input[_builtins.str] webhook: The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        if conditional_cases is not None:
            pulumi.set(__self__, "conditional_cases", conditional_cases)
        if enable_generative_fallback is not None:
            pulumi.set(__self__, "enable_generative_fallback", enable_generative_fallback)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if return_partial_responses is not None:
            pulumi.set(__self__, "return_partial_responses", return_partial_responses)
        if set_parameter_actions is not None:
            pulumi.set(__self__, "set_parameter_actions", set_parameter_actions)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @_builtins.property
    @pulumi.getter(name="conditionalCases")
    def conditional_cases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentConditionalCaseArgs']]]]:
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        return pulumi.get(self, "conditional_cases")

    @conditional_cases.setter
    def conditional_cases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentConditionalCaseArgs']]]]):
        pulumi.set(self, "conditional_cases", value)

    @_builtins.property
    @pulumi.getter(name="enableGenerativeFallback")
    def enable_generative_fallback(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
        """
        return pulumi.get(self, "enable_generative_fallback")

    @enable_generative_fallback.setter
    def enable_generative_fallback(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_generative_fallback", value)

    @_builtins.property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageArgs']]]]:
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageArgs']]]]):
        pulumi.set(self, "messages", value)

    @_builtins.property
    @pulumi.getter(name="returnPartialResponses")
    def return_partial_responses(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        return pulumi.get(self, "return_partial_responses")

    @return_partial_responses.setter
    def return_partial_responses(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "return_partial_responses", value)

    @_builtins.property
    @pulumi.getter(name="setParameterActions")
    def set_parameter_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentSetParameterActionArgs']]]]:
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        return pulumi.get(self, "set_parameter_actions")

    @set_parameter_actions.setter
    def set_parameter_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentSetParameterActionArgs']]]]):
        pulumi.set(self, "set_parameter_actions", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def webhook(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        return pulumi.get(self, "webhook")

    @webhook.setter
    def webhook(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "webhook", value)


if not MYPY:
    class CxFlowEventHandlerTriggerFulfillmentConditionalCaseArgsDict(TypedDict):
        cases: NotRequired[pulumi.Input[_builtins.str]]
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
elif False:
    CxFlowEventHandlerTriggerFulfillmentConditionalCaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowEventHandlerTriggerFulfillmentConditionalCaseArgs:
    def __init__(__self__, *,
                 cases: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cases: A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
               See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        if cases is not None:
            pulumi.set(__self__, "cases", cases)

    @_builtins.property
    @pulumi.getter
    def cases(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        return pulumi.get(self, "cases")

    @cases.setter
    def cases(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cases", value)


if not MYPY:
    class CxFlowEventHandlerTriggerFulfillmentMessageArgsDict(TypedDict):
        channel: NotRequired[pulumi.Input[_builtins.str]]
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        conversation_success: NotRequired[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageConversationSuccessArgsDict']]
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        live_agent_handoff: NotRequired[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgsDict']]
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        output_audio_text: NotRequired[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioTextArgsDict']]
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        Returns a response containing a custom, platform-specific payload.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        play_audio: NotRequired[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessagePlayAudioArgsDict']]
        """
        Specifies an audio clip to be played by the client as part of the response.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        telephony_transfer_call: NotRequired[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgsDict']]
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        text: NotRequired[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageTextArgsDict']]
        """
        The text response message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
elif False:
    CxFlowEventHandlerTriggerFulfillmentMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowEventHandlerTriggerFulfillmentMessageArgs:
    def __init__(__self__, *,
                 channel: Optional[pulumi.Input[_builtins.str]] = None,
                 conversation_success: Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageConversationSuccessArgs']] = None,
                 live_agent_handoff: Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs']] = None,
                 output_audio_text: Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs']] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 play_audio: Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessagePlayAudioArgs']] = None,
                 telephony_transfer_call: Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs']] = None,
                 text: Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageTextArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] channel: The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        :param pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageConversationSuccessArgs'] conversation_success: Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
               Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
               * In a webhook response when you determine that you handled the customer issue.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs'] live_agent_handoff: Indicates that the conversation should be handed off to a live agent.
               Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
               * In a webhook response when you determine that the customer issue can only be handled by a human.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs'] output_audio_text: A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] payload: Returns a response containing a custom, platform-specific payload.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        :param pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessagePlayAudioArgs'] play_audio: Specifies an audio clip to be played by the client as part of the response.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs'] telephony_transfer_call: Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageTextArgs'] text: The text response message.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if conversation_success is not None:
            pulumi.set(__self__, "conversation_success", conversation_success)
        if live_agent_handoff is not None:
            pulumi.set(__self__, "live_agent_handoff", live_agent_handoff)
        if output_audio_text is not None:
            pulumi.set(__self__, "output_audio_text", output_audio_text)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if play_audio is not None:
            pulumi.set(__self__, "play_audio", play_audio)
        if telephony_transfer_call is not None:
            pulumi.set(__self__, "telephony_transfer_call", telephony_transfer_call)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter(name="conversationSuccess")
    def conversation_success(self) -> Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageConversationSuccessArgs']]:
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_success")

    @conversation_success.setter
    def conversation_success(self, value: Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageConversationSuccessArgs']]):
        pulumi.set(self, "conversation_success", value)

    @_builtins.property
    @pulumi.getter(name="liveAgentHandoff")
    def live_agent_handoff(self) -> Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs']]:
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "live_agent_handoff")

    @live_agent_handoff.setter
    def live_agent_handoff(self, value: Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs']]):
        pulumi.set(self, "live_agent_handoff", value)

    @_builtins.property
    @pulumi.getter(name="outputAudioText")
    def output_audio_text(self) -> Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs']]:
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "output_audio_text")

    @output_audio_text.setter
    def output_audio_text(self, value: Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs']]):
        pulumi.set(self, "output_audio_text", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Returns a response containing a custom, platform-specific payload.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="playAudio")
    def play_audio(self) -> Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessagePlayAudioArgs']]:
        """
        Specifies an audio clip to be played by the client as part of the response.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "play_audio")

    @play_audio.setter
    def play_audio(self, value: Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessagePlayAudioArgs']]):
        pulumi.set(self, "play_audio", value)

    @_builtins.property
    @pulumi.getter(name="telephonyTransferCall")
    def telephony_transfer_call(self) -> Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs']]:
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "telephony_transfer_call")

    @telephony_transfer_call.setter
    def telephony_transfer_call(self, value: Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs']]):
        pulumi.set(self, "telephony_transfer_call", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageTextArgs']]:
        """
        The text response message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['CxFlowEventHandlerTriggerFulfillmentMessageTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxFlowEventHandlerTriggerFulfillmentMessageConversationSuccessArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
elif False:
    CxFlowEventHandlerTriggerFulfillmentMessageConversationSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowEventHandlerTriggerFulfillmentMessageConversationSuccessArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class CxFlowEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
elif False:
    CxFlowEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioTextArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        ssml: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SSML text to be synthesized. For more information, see SSML.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The raw text to be synthesized.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
elif False:
    CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 ssml: Optional[pulumi.Input[_builtins.str]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param pulumi.Input[_builtins.str] ssml: The SSML text to be synthesized. For more information, see SSML.
               This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        :param pulumi.Input[_builtins.str] text: The raw text to be synthesized.
               This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if ssml is not None:
            pulumi.set(__self__, "ssml", ssml)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def ssml(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SSML text to be synthesized. For more information, see SSML.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        return pulumi.get(self, "ssml")

    @ssml.setter
    def ssml(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssml", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The raw text to be synthesized.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxFlowEventHandlerTriggerFulfillmentMessagePlayAudioArgsDict(TypedDict):
        audio_uri: pulumi.Input[_builtins.str]
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.

        <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
elif False:
    CxFlowEventHandlerTriggerFulfillmentMessagePlayAudioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowEventHandlerTriggerFulfillmentMessagePlayAudioArgs:
    def __init__(__self__, *,
                 audio_uri: pulumi.Input[_builtins.str],
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] audio_uri: URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
               
               <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
        pulumi.set(__self__, "audio_uri", audio_uri)
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)

    @_builtins.property
    @pulumi.getter(name="audioUri")
    def audio_uri(self) -> pulumi.Input[_builtins.str]:
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        return pulumi.get(self, "audio_uri")

    @audio_uri.setter
    def audio_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "audio_uri", value)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.

        <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)


if not MYPY:
    class CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgsDict(TypedDict):
        phone_number: pulumi.Input[_builtins.str]
        """
        Transfer the call to a phone number in E.164 format.
        """
elif False:
    CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs:
    def __init__(__self__, *,
                 phone_number: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] phone_number: Transfer the call to a phone number in E.164 format.
        """
        pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> pulumi.Input[_builtins.str]:
        """
        Transfer the call to a phone number in E.164 format.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class CxFlowEventHandlerTriggerFulfillmentMessageTextArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        texts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
        required: true
        """
elif False:
    CxFlowEventHandlerTriggerFulfillmentMessageTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowEventHandlerTriggerFulfillmentMessageTextArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 texts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] texts: A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
               required: true
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def texts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
        required: true
        """
        return pulumi.get(self, "texts")

    @texts.setter
    def texts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "texts", value)


if not MYPY:
    class CxFlowEventHandlerTriggerFulfillmentSetParameterActionArgsDict(TypedDict):
        parameter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name of the parameter.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
elif False:
    CxFlowEventHandlerTriggerFulfillmentSetParameterActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowEventHandlerTriggerFulfillmentSetParameterActionArgs:
    def __init__(__self__, *,
                 parameter: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] parameter: Display name of the parameter.
        :param pulumi.Input[_builtins.str] value: The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        if parameter is not None:
            pulumi.set(__self__, "parameter", parameter)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def parameter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name of the parameter.
        """
        return pulumi.get(self, "parameter")

    @parameter.setter
    def parameter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parameter", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsArgsDict(TypedDict):
        data_store_connections: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsDataStoreConnectionArgsDict']]]]
        """
        Optional. List of related data store connections.
        Structure is documented below.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Knowledge Connector is enabled or not.
        """
        target_flow: NotRequired[pulumi.Input[_builtins.str]]
        """
        The target flow to transition to. Format: projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>.
        This field is part of a union field `target`: Only one of `targetPage` or `targetFlow` may be set.
        """
        target_page: NotRequired[pulumi.Input[_builtins.str]]
        """
        The target page to transition to. Format: projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/pages/<PageID>.
        The page must be in the same host flow (the flow that owns this `KnowledgeConnectorSettings`).
        This field is part of a union field `target`: Only one of `targetPage` or `targetFlow` may be set.
        """
        trigger_fulfillment: NotRequired[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentArgsDict']]
        """
        The fulfillment to be triggered.
        When the answers from the Knowledge Connector are selected by Dialogflow, you can utitlize the request scoped parameter $request.knowledge.answers (contains up to the 5 highest confidence answers) and $request.knowledge.questions (contains the corresponding questions) to construct the fulfillment.
        Structure is documented below.
        """
elif False:
    CxFlowKnowledgeConnectorSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsArgs:
    def __init__(__self__, *,
                 data_store_connections: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsDataStoreConnectionArgs']]]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 target_flow: Optional[pulumi.Input[_builtins.str]] = None,
                 target_page: Optional[pulumi.Input[_builtins.str]] = None,
                 trigger_fulfillment: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsDataStoreConnectionArgs']]] data_store_connections: Optional. List of related data store connections.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] enabled: Whether Knowledge Connector is enabled or not.
        :param pulumi.Input[_builtins.str] target_flow: The target flow to transition to. Format: projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>.
               This field is part of a union field `target`: Only one of `targetPage` or `targetFlow` may be set.
        :param pulumi.Input[_builtins.str] target_page: The target page to transition to. Format: projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/pages/<PageID>.
               The page must be in the same host flow (the flow that owns this `KnowledgeConnectorSettings`).
               This field is part of a union field `target`: Only one of `targetPage` or `targetFlow` may be set.
        :param pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentArgs'] trigger_fulfillment: The fulfillment to be triggered.
               When the answers from the Knowledge Connector are selected by Dialogflow, you can utitlize the request scoped parameter $request.knowledge.answers (contains up to the 5 highest confidence answers) and $request.knowledge.questions (contains the corresponding questions) to construct the fulfillment.
               Structure is documented below.
        """
        if data_store_connections is not None:
            pulumi.set(__self__, "data_store_connections", data_store_connections)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if target_flow is not None:
            pulumi.set(__self__, "target_flow", target_flow)
        if target_page is not None:
            pulumi.set(__self__, "target_page", target_page)
        if trigger_fulfillment is not None:
            pulumi.set(__self__, "trigger_fulfillment", trigger_fulfillment)

    @_builtins.property
    @pulumi.getter(name="dataStoreConnections")
    def data_store_connections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsDataStoreConnectionArgs']]]]:
        """
        Optional. List of related data store connections.
        Structure is documented below.
        """
        return pulumi.get(self, "data_store_connections")

    @data_store_connections.setter
    def data_store_connections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsDataStoreConnectionArgs']]]]):
        pulumi.set(self, "data_store_connections", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Knowledge Connector is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="targetFlow")
    def target_flow(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The target flow to transition to. Format: projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>.
        This field is part of a union field `target`: Only one of `targetPage` or `targetFlow` may be set.
        """
        return pulumi.get(self, "target_flow")

    @target_flow.setter
    def target_flow(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_flow", value)

    @_builtins.property
    @pulumi.getter(name="targetPage")
    def target_page(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The target page to transition to. Format: projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/pages/<PageID>.
        The page must be in the same host flow (the flow that owns this `KnowledgeConnectorSettings`).
        This field is part of a union field `target`: Only one of `targetPage` or `targetFlow` may be set.
        """
        return pulumi.get(self, "target_page")

    @target_page.setter
    def target_page(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_page", value)

    @_builtins.property
    @pulumi.getter(name="triggerFulfillment")
    def trigger_fulfillment(self) -> Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentArgs']]:
        """
        The fulfillment to be triggered.
        When the answers from the Knowledge Connector are selected by Dialogflow, you can utitlize the request scoped parameter $request.knowledge.answers (contains up to the 5 highest confidence answers) and $request.knowledge.questions (contains the corresponding questions) to construct the fulfillment.
        Structure is documented below.
        """
        return pulumi.get(self, "trigger_fulfillment")

    @trigger_fulfillment.setter
    def trigger_fulfillment(self, value: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentArgs']]):
        pulumi.set(self, "trigger_fulfillment", value)


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsDataStoreConnectionArgsDict(TypedDict):
        data_store: NotRequired[pulumi.Input[_builtins.str]]
        """
        The full name of the referenced data store. Formats: projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore} projects/{project}/locations/{location}/dataStores/{dataStore}
        """
        data_store_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the connected data store.
        * PUBLIC_WEB: A data store that contains public web content.
        * UNSTRUCTURED: A data store that contains unstructured private data.
        * STRUCTURED: A data store that contains structured data (for example FAQ).
        Possible values are: `PUBLIC_WEB`, `UNSTRUCTURED`, `STRUCTURED`.
        """
        document_processing_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The document processing mode for the data store connection. Should only be set for PUBLIC_WEB and UNSTRUCTURED data stores. If not set it is considered as DOCUMENTS, as this is the legacy mode.
        * DOCUMENTS: Documents are processed as documents.
        * CHUNKS: Documents are converted to chunks.
        Possible values are: `DOCUMENTS`, `CHUNKS`.
        """
elif False:
    CxFlowKnowledgeConnectorSettingsDataStoreConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsDataStoreConnectionArgs:
    def __init__(__self__, *,
                 data_store: Optional[pulumi.Input[_builtins.str]] = None,
                 data_store_type: Optional[pulumi.Input[_builtins.str]] = None,
                 document_processing_mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] data_store: The full name of the referenced data store. Formats: projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore} projects/{project}/locations/{location}/dataStores/{dataStore}
        :param pulumi.Input[_builtins.str] data_store_type: The type of the connected data store.
               * PUBLIC_WEB: A data store that contains public web content.
               * UNSTRUCTURED: A data store that contains unstructured private data.
               * STRUCTURED: A data store that contains structured data (for example FAQ).
               Possible values are: `PUBLIC_WEB`, `UNSTRUCTURED`, `STRUCTURED`.
        :param pulumi.Input[_builtins.str] document_processing_mode: The document processing mode for the data store connection. Should only be set for PUBLIC_WEB and UNSTRUCTURED data stores. If not set it is considered as DOCUMENTS, as this is the legacy mode.
               * DOCUMENTS: Documents are processed as documents.
               * CHUNKS: Documents are converted to chunks.
               Possible values are: `DOCUMENTS`, `CHUNKS`.
        """
        if data_store is not None:
            pulumi.set(__self__, "data_store", data_store)
        if data_store_type is not None:
            pulumi.set(__self__, "data_store_type", data_store_type)
        if document_processing_mode is not None:
            pulumi.set(__self__, "document_processing_mode", document_processing_mode)

    @_builtins.property
    @pulumi.getter(name="dataStore")
    def data_store(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The full name of the referenced data store. Formats: projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore} projects/{project}/locations/{location}/dataStores/{dataStore}
        """
        return pulumi.get(self, "data_store")

    @data_store.setter
    def data_store(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_store", value)

    @_builtins.property
    @pulumi.getter(name="dataStoreType")
    def data_store_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the connected data store.
        * PUBLIC_WEB: A data store that contains public web content.
        * UNSTRUCTURED: A data store that contains unstructured private data.
        * STRUCTURED: A data store that contains structured data (for example FAQ).
        Possible values are: `PUBLIC_WEB`, `UNSTRUCTURED`, `STRUCTURED`.
        """
        return pulumi.get(self, "data_store_type")

    @data_store_type.setter
    def data_store_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_store_type", value)

    @_builtins.property
    @pulumi.getter(name="documentProcessingMode")
    def document_processing_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The document processing mode for the data store connection. Should only be set for PUBLIC_WEB and UNSTRUCTURED data stores. If not set it is considered as DOCUMENTS, as this is the legacy mode.
        * DOCUMENTS: Documents are processed as documents.
        * CHUNKS: Documents are converted to chunks.
        Possible values are: `DOCUMENTS`, `CHUNKS`.
        """
        return pulumi.get(self, "document_processing_mode")

    @document_processing_mode.setter
    def document_processing_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "document_processing_mode", value)


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentArgsDict(TypedDict):
        advanced_settings: NotRequired[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgsDict']]
        """
        Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playbackInterruptionSettings at fulfillment level only overrides the playbackInterruptionSettings at the agent level, leaving other settings at the agent level unchanged.
        DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel.
        Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
        Structure is documented below.
        """
        conditional_cases: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgsDict']]]]
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        enable_generative_fallback: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
        """
        messages: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageArgsDict']]]]
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return_partial_responses: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        set_parameter_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgsDict']]]]
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        webhook: NotRequired[pulumi.Input[_builtins.str]]
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
elif False:
    CxFlowKnowledgeConnectorSettingsTriggerFulfillmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentArgs:
    def __init__(__self__, *,
                 advanced_settings: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgs']] = None,
                 conditional_cases: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgs']]]] = None,
                 enable_generative_fallback: Optional[pulumi.Input[_builtins.bool]] = None,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageArgs']]]] = None,
                 return_partial_responses: Optional[pulumi.Input[_builtins.bool]] = None,
                 set_parameter_actions: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgs']]]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None,
                 webhook: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgs'] advanced_settings: Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playbackInterruptionSettings at fulfillment level only overrides the playbackInterruptionSettings at the agent level, leaving other settings at the agent level unchanged.
               DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel.
               Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgs']]] conditional_cases: Conditional cases for this fulfillment.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] enable_generative_fallback: If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
        :param pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageArgs']]] messages: The list of rich message responses to present to the user.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] return_partial_responses: Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        :param pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgs']]] set_parameter_actions: Set parameter values before executing the webhook.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] tag: The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        :param pulumi.Input[_builtins.str] webhook: The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        if advanced_settings is not None:
            pulumi.set(__self__, "advanced_settings", advanced_settings)
        if conditional_cases is not None:
            pulumi.set(__self__, "conditional_cases", conditional_cases)
        if enable_generative_fallback is not None:
            pulumi.set(__self__, "enable_generative_fallback", enable_generative_fallback)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if return_partial_responses is not None:
            pulumi.set(__self__, "return_partial_responses", return_partial_responses)
        if set_parameter_actions is not None:
            pulumi.set(__self__, "set_parameter_actions", set_parameter_actions)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @_builtins.property
    @pulumi.getter(name="advancedSettings")
    def advanced_settings(self) -> Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgs']]:
        """
        Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playbackInterruptionSettings at fulfillment level only overrides the playbackInterruptionSettings at the agent level, leaving other settings at the agent level unchanged.
        DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel.
        Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
        Structure is documented below.
        """
        return pulumi.get(self, "advanced_settings")

    @advanced_settings.setter
    def advanced_settings(self, value: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgs']]):
        pulumi.set(self, "advanced_settings", value)

    @_builtins.property
    @pulumi.getter(name="conditionalCases")
    def conditional_cases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgs']]]]:
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        return pulumi.get(self, "conditional_cases")

    @conditional_cases.setter
    def conditional_cases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgs']]]]):
        pulumi.set(self, "conditional_cases", value)

    @_builtins.property
    @pulumi.getter(name="enableGenerativeFallback")
    def enable_generative_fallback(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
        """
        return pulumi.get(self, "enable_generative_fallback")

    @enable_generative_fallback.setter
    def enable_generative_fallback(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_generative_fallback", value)

    @_builtins.property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageArgs']]]]:
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageArgs']]]]):
        pulumi.set(self, "messages", value)

    @_builtins.property
    @pulumi.getter(name="returnPartialResponses")
    def return_partial_responses(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        return pulumi.get(self, "return_partial_responses")

    @return_partial_responses.setter
    def return_partial_responses(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "return_partial_responses", value)

    @_builtins.property
    @pulumi.getter(name="setParameterActions")
    def set_parameter_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgs']]]]:
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        return pulumi.get(self, "set_parameter_actions")

    @set_parameter_actions.setter
    def set_parameter_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgs']]]]):
        pulumi.set(self, "set_parameter_actions", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def webhook(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        return pulumi.get(self, "webhook")

    @webhook.setter
    def webhook(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "webhook", value)


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgsDict(TypedDict):
        dtmf_settings: NotRequired[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgsDict']]
        """
        Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
        logging_settings: NotRequired[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgsDict']]
        """
        Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels:
        * Agent level
        Structure is documented below.
        """
        speech_settings: NotRequired[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgsDict']]
        """
        Settings for speech to text detection. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
elif False:
    CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgs:
    def __init__(__self__, *,
                 dtmf_settings: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgs']] = None,
                 logging_settings: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgs']] = None,
                 speech_settings: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgs']] = None):
        """
        :param pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgs'] dtmf_settings: Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
               * Agent level
               * Flow level
               * Page level
               * Parameter level
               Structure is documented below.
        :param pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgs'] logging_settings: Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels:
               * Agent level
               Structure is documented below.
        :param pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgs'] speech_settings: Settings for speech to text detection. Exposed at the following levels:
               * Agent level
               * Flow level
               * Page level
               * Parameter level
               Structure is documented below.
        """
        if dtmf_settings is not None:
            pulumi.set(__self__, "dtmf_settings", dtmf_settings)
        if logging_settings is not None:
            pulumi.set(__self__, "logging_settings", logging_settings)
        if speech_settings is not None:
            pulumi.set(__self__, "speech_settings", speech_settings)

    @_builtins.property
    @pulumi.getter(name="dtmfSettings")
    def dtmf_settings(self) -> Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgs']]:
        """
        Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
        return pulumi.get(self, "dtmf_settings")

    @dtmf_settings.setter
    def dtmf_settings(self, value: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgs']]):
        pulumi.set(self, "dtmf_settings", value)

    @_builtins.property
    @pulumi.getter(name="loggingSettings")
    def logging_settings(self) -> Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgs']]:
        """
        Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels:
        * Agent level
        Structure is documented below.
        """
        return pulumi.get(self, "logging_settings")

    @logging_settings.setter
    def logging_settings(self, value: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgs']]):
        pulumi.set(self, "logging_settings", value)

    @_builtins.property
    @pulumi.getter(name="speechSettings")
    def speech_settings(self) -> Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgs']]:
        """
        Settings for speech to text detection. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
        return pulumi.get(self, "speech_settings")

    @speech_settings.setter
    def speech_settings(self, value: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgs']]):
        pulumi.set(self, "speech_settings", value)


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        """
        endpointing_timeout_duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        Endpoint timeout setting for matching dtmf input to regex.
        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        """
        finish_digit: NotRequired[pulumi.Input[_builtins.str]]
        """
        The digit that terminates a DTMF digit sequence.
        """
        interdigit_timeout_duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interdigit timeout setting for matching dtmf input to regex.
        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        """
        max_digits: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max length of DTMF digits.
        """
elif False:
    CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 endpointing_timeout_duration: Optional[pulumi.Input[_builtins.str]] = None,
                 finish_digit: Optional[pulumi.Input[_builtins.str]] = None,
                 interdigit_timeout_duration: Optional[pulumi.Input[_builtins.str]] = None,
                 max_digits: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        :param pulumi.Input[_builtins.str] endpointing_timeout_duration: Endpoint timeout setting for matching dtmf input to regex.
               A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        :param pulumi.Input[_builtins.str] finish_digit: The digit that terminates a DTMF digit sequence.
        :param pulumi.Input[_builtins.str] interdigit_timeout_duration: Interdigit timeout setting for matching dtmf input to regex.
               A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        :param pulumi.Input[_builtins.int] max_digits: Max length of DTMF digits.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if endpointing_timeout_duration is not None:
            pulumi.set(__self__, "endpointing_timeout_duration", endpointing_timeout_duration)
        if finish_digit is not None:
            pulumi.set(__self__, "finish_digit", finish_digit)
        if interdigit_timeout_duration is not None:
            pulumi.set(__self__, "interdigit_timeout_duration", interdigit_timeout_duration)
        if max_digits is not None:
            pulumi.set(__self__, "max_digits", max_digits)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="endpointingTimeoutDuration")
    def endpointing_timeout_duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Endpoint timeout setting for matching dtmf input to regex.
        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        """
        return pulumi.get(self, "endpointing_timeout_duration")

    @endpointing_timeout_duration.setter
    def endpointing_timeout_duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpointing_timeout_duration", value)

    @_builtins.property
    @pulumi.getter(name="finishDigit")
    def finish_digit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The digit that terminates a DTMF digit sequence.
        """
        return pulumi.get(self, "finish_digit")

    @finish_digit.setter
    def finish_digit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "finish_digit", value)

    @_builtins.property
    @pulumi.getter(name="interdigitTimeoutDuration")
    def interdigit_timeout_duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interdigit timeout setting for matching dtmf input to regex.
        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        """
        return pulumi.get(self, "interdigit_timeout_duration")

    @interdigit_timeout_duration.setter
    def interdigit_timeout_duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interdigit_timeout_duration", value)

    @_builtins.property
    @pulumi.getter(name="maxDigits")
    def max_digits(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max length of DTMF digits.
        """
        return pulumi.get(self, "max_digits")

    @max_digits.setter
    def max_digits(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_digits", value)


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgsDict(TypedDict):
        enable_consent_based_redaction: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables consent-based end-user input redaction, if true, a pre-defined session parameter **$session.params.conversation-redaction** will be used to determine if the utterance should be redacted.
        """
        enable_interaction_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables DF Interaction logging.
        """
        enable_stackdriver_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables Google Cloud Logging.
        """
elif False:
    CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgs:
    def __init__(__self__, *,
                 enable_consent_based_redaction: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_interaction_logging: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_stackdriver_logging: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_consent_based_redaction: Enables consent-based end-user input redaction, if true, a pre-defined session parameter **$session.params.conversation-redaction** will be used to determine if the utterance should be redacted.
        :param pulumi.Input[_builtins.bool] enable_interaction_logging: Enables DF Interaction logging.
        :param pulumi.Input[_builtins.bool] enable_stackdriver_logging: Enables Google Cloud Logging.
        """
        if enable_consent_based_redaction is not None:
            pulumi.set(__self__, "enable_consent_based_redaction", enable_consent_based_redaction)
        if enable_interaction_logging is not None:
            pulumi.set(__self__, "enable_interaction_logging", enable_interaction_logging)
        if enable_stackdriver_logging is not None:
            pulumi.set(__self__, "enable_stackdriver_logging", enable_stackdriver_logging)

    @_builtins.property
    @pulumi.getter(name="enableConsentBasedRedaction")
    def enable_consent_based_redaction(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables consent-based end-user input redaction, if true, a pre-defined session parameter **$session.params.conversation-redaction** will be used to determine if the utterance should be redacted.
        """
        return pulumi.get(self, "enable_consent_based_redaction")

    @enable_consent_based_redaction.setter
    def enable_consent_based_redaction(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_consent_based_redaction", value)

    @_builtins.property
    @pulumi.getter(name="enableInteractionLogging")
    def enable_interaction_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables DF Interaction logging.
        """
        return pulumi.get(self, "enable_interaction_logging")

    @enable_interaction_logging.setter
    def enable_interaction_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_interaction_logging", value)

    @_builtins.property
    @pulumi.getter(name="enableStackdriverLogging")
    def enable_stackdriver_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables Google Cloud Logging.
        """
        return pulumi.get(self, "enable_stackdriver_logging")

    @enable_stackdriver_logging.setter
    def enable_stackdriver_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_stackdriver_logging", value)


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgsDict(TypedDict):
        endpointer_sensitivity: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
        """
        models: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
        An object containing a list of **"key": value** pairs. Example: **{ "name": "wrench", "mass": "1.3kg", "count": "3" }**.
        """
        no_speech_timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timeout before detecting no speech.
        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        """
        use_timeout_based_endpointing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use timeout based endpointing, interpreting endpointer sensitivity as seconds of timeout value.
        """
elif False:
    CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgs:
    def __init__(__self__, *,
                 endpointer_sensitivity: Optional[pulumi.Input[_builtins.int]] = None,
                 models: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 no_speech_timeout: Optional[pulumi.Input[_builtins.str]] = None,
                 use_timeout_based_endpointing: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] endpointer_sensitivity: Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] models: Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
               An object containing a list of **"key": value** pairs. Example: **{ "name": "wrench", "mass": "1.3kg", "count": "3" }**.
        :param pulumi.Input[_builtins.str] no_speech_timeout: Timeout before detecting no speech.
               A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        :param pulumi.Input[_builtins.bool] use_timeout_based_endpointing: Use timeout based endpointing, interpreting endpointer sensitivity as seconds of timeout value.
        """
        if endpointer_sensitivity is not None:
            pulumi.set(__self__, "endpointer_sensitivity", endpointer_sensitivity)
        if models is not None:
            pulumi.set(__self__, "models", models)
        if no_speech_timeout is not None:
            pulumi.set(__self__, "no_speech_timeout", no_speech_timeout)
        if use_timeout_based_endpointing is not None:
            pulumi.set(__self__, "use_timeout_based_endpointing", use_timeout_based_endpointing)

    @_builtins.property
    @pulumi.getter(name="endpointerSensitivity")
    def endpointer_sensitivity(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
        """
        return pulumi.get(self, "endpointer_sensitivity")

    @endpointer_sensitivity.setter
    def endpointer_sensitivity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "endpointer_sensitivity", value)

    @_builtins.property
    @pulumi.getter
    def models(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
        An object containing a list of **"key": value** pairs. Example: **{ "name": "wrench", "mass": "1.3kg", "count": "3" }**.
        """
        return pulumi.get(self, "models")

    @models.setter
    def models(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "models", value)

    @_builtins.property
    @pulumi.getter(name="noSpeechTimeout")
    def no_speech_timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timeout before detecting no speech.
        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        """
        return pulumi.get(self, "no_speech_timeout")

    @no_speech_timeout.setter
    def no_speech_timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "no_speech_timeout", value)

    @_builtins.property
    @pulumi.getter(name="useTimeoutBasedEndpointing")
    def use_timeout_based_endpointing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use timeout based endpointing, interpreting endpointer sensitivity as seconds of timeout value.
        """
        return pulumi.get(self, "use_timeout_based_endpointing")

    @use_timeout_based_endpointing.setter
    def use_timeout_based_endpointing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_timeout_based_endpointing", value)


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgsDict(TypedDict):
        cases: NotRequired[pulumi.Input[_builtins.str]]
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
elif False:
    CxFlowKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgs:
    def __init__(__self__, *,
                 cases: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cases: A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
               See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        if cases is not None:
            pulumi.set(__self__, "cases", cases)

    @_builtins.property
    @pulumi.getter
    def cases(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        return pulumi.get(self, "cases")

    @cases.setter
    def cases(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cases", value)


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageArgsDict(TypedDict):
        channel: NotRequired[pulumi.Input[_builtins.str]]
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        conversation_success: NotRequired[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgsDict']]
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        end_interactions: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgsDict']]]]
        """
        (Output)
        This type has no fields.
        Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        knowledge_info_card: NotRequired[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgsDict']]
        """
        This type has no fields.
        Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card.
        Otherwise, the info card response is skipped.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        live_agent_handoff: NotRequired[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgsDict']]
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        mixed_audios: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgsDict']]]]
        """
        (Output)
        Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via playAudio. This message is generated by Dialogflow only and not supposed to be defined by the user.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        output_audio_text: NotRequired[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgsDict']]
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        Returns a response containing a custom, platform-specific payload.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        play_audio: NotRequired[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgsDict']]
        """
        Specifies an audio clip to be played by the client as part of the response.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        telephony_transfer_call: NotRequired[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgsDict']]
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        text: NotRequired[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgsDict']]
        """
        The text response message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
elif False:
    CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageArgs:
    def __init__(__self__, *,
                 channel: Optional[pulumi.Input[_builtins.str]] = None,
                 conversation_success: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgs']] = None,
                 end_interactions: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgs']]]] = None,
                 knowledge_info_card: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgs']] = None,
                 live_agent_handoff: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgs']] = None,
                 mixed_audios: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgs']]]] = None,
                 output_audio_text: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgs']] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 play_audio: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgs']] = None,
                 telephony_transfer_call: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgs']] = None,
                 text: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] channel: The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        :param pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgs'] conversation_success: Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
               Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
               * In a webhook response when you determine that you handled the customer issue.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgs']]] end_interactions: (Output)
               This type has no fields.
               Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        :param pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgs'] knowledge_info_card: This type has no fields.
               Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card.
               Otherwise, the info card response is skipped.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        :param pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgs'] live_agent_handoff: Indicates that the conversation should be handed off to a live agent.
               Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
               * In a webhook response when you determine that the customer issue can only be handled by a human.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgs']]] mixed_audios: (Output)
               Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via playAudio. This message is generated by Dialogflow only and not supposed to be defined by the user.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgs'] output_audio_text: A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] payload: Returns a response containing a custom, platform-specific payload.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        :param pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgs'] play_audio: Specifies an audio clip to be played by the client as part of the response.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgs'] telephony_transfer_call: Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgs'] text: The text response message.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if conversation_success is not None:
            pulumi.set(__self__, "conversation_success", conversation_success)
        if end_interactions is not None:
            pulumi.set(__self__, "end_interactions", end_interactions)
        if knowledge_info_card is not None:
            pulumi.set(__self__, "knowledge_info_card", knowledge_info_card)
        if live_agent_handoff is not None:
            pulumi.set(__self__, "live_agent_handoff", live_agent_handoff)
        if mixed_audios is not None:
            pulumi.set(__self__, "mixed_audios", mixed_audios)
        if output_audio_text is not None:
            pulumi.set(__self__, "output_audio_text", output_audio_text)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if play_audio is not None:
            pulumi.set(__self__, "play_audio", play_audio)
        if telephony_transfer_call is not None:
            pulumi.set(__self__, "telephony_transfer_call", telephony_transfer_call)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter(name="conversationSuccess")
    def conversation_success(self) -> Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgs']]:
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_success")

    @conversation_success.setter
    def conversation_success(self, value: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgs']]):
        pulumi.set(self, "conversation_success", value)

    @_builtins.property
    @pulumi.getter(name="endInteractions")
    def end_interactions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgs']]]]:
        """
        (Output)
        This type has no fields.
        Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        return pulumi.get(self, "end_interactions")

    @end_interactions.setter
    def end_interactions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgs']]]]):
        pulumi.set(self, "end_interactions", value)

    @_builtins.property
    @pulumi.getter(name="knowledgeInfoCard")
    def knowledge_info_card(self) -> Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgs']]:
        """
        This type has no fields.
        Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card.
        Otherwise, the info card response is skipped.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        return pulumi.get(self, "knowledge_info_card")

    @knowledge_info_card.setter
    def knowledge_info_card(self, value: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgs']]):
        pulumi.set(self, "knowledge_info_card", value)

    @_builtins.property
    @pulumi.getter(name="liveAgentHandoff")
    def live_agent_handoff(self) -> Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgs']]:
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "live_agent_handoff")

    @live_agent_handoff.setter
    def live_agent_handoff(self, value: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgs']]):
        pulumi.set(self, "live_agent_handoff", value)

    @_builtins.property
    @pulumi.getter(name="mixedAudios")
    def mixed_audios(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgs']]]]:
        """
        (Output)
        Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via playAudio. This message is generated by Dialogflow only and not supposed to be defined by the user.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "mixed_audios")

    @mixed_audios.setter
    def mixed_audios(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgs']]]]):
        pulumi.set(self, "mixed_audios", value)

    @_builtins.property
    @pulumi.getter(name="outputAudioText")
    def output_audio_text(self) -> Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgs']]:
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "output_audio_text")

    @output_audio_text.setter
    def output_audio_text(self, value: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgs']]):
        pulumi.set(self, "output_audio_text", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Returns a response containing a custom, platform-specific payload.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="playAudio")
    def play_audio(self) -> Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgs']]:
        """
        Specifies an audio clip to be played by the client as part of the response.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "play_audio")

    @play_audio.setter
    def play_audio(self, value: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgs']]):
        pulumi.set(self, "play_audio", value)

    @_builtins.property
    @pulumi.getter(name="telephonyTransferCall")
    def telephony_transfer_call(self) -> Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgs']]:
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "telephony_transfer_call")

    @telephony_transfer_call.setter
    def telephony_transfer_call(self, value: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgs']]):
        pulumi.set(self, "telephony_transfer_call", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgs']]:
        """
        The text response message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
elif False:
    CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgsDict(TypedDict):
        pass
elif False:
    CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgsDict(TypedDict):
        pass
elif False:
    CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
elif False:
    CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgsDict(TypedDict):
        segments: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgsDict']]]]
        """
        Segments this audio response is composed of.
        """
elif False:
    CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgs:
    def __init__(__self__, *,
                 segments: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgs']]] segments: Segments this audio response is composed of.
        """
        if segments is not None:
            pulumi.set(__self__, "segments", segments)

    @_builtins.property
    @pulumi.getter
    def segments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgs']]]]:
        """
        Segments this audio response is composed of.
        """
        return pulumi.get(self, "segments")

    @segments.setter
    def segments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgs']]]]):
        pulumi.set(self, "segments", value)


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this segment can be interrupted by the end user's speech and the client should then start the next Dialogflow request.
        """
        audio: NotRequired[pulumi.Input[_builtins.str]]
        """
        Raw audio synthesized from the Dialogflow agent's response using the output config specified in the request.
        A base64-encoded string.
        This field is part of a union field `content`: Only one of `audio` or `uri` may be set.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
        This field is part of a union field `content`: Only one of `audio` or `uri` may be set.
        """
elif False:
    CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 audio: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this segment can be interrupted by the end user's speech and the client should then start the next Dialogflow request.
        :param pulumi.Input[_builtins.str] audio: Raw audio synthesized from the Dialogflow agent's response using the output config specified in the request.
               A base64-encoded string.
               This field is part of a union field `content`: Only one of `audio` or `uri` may be set.
        :param pulumi.Input[_builtins.str] uri: Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
               This field is part of a union field `content`: Only one of `audio` or `uri` may be set.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if audio is not None:
            pulumi.set(__self__, "audio", audio)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this segment can be interrupted by the end user's speech and the client should then start the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def audio(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Raw audio synthesized from the Dialogflow agent's response using the output config specified in the request.
        A base64-encoded string.
        This field is part of a union field `content`: Only one of `audio` or `uri` may be set.
        """
        return pulumi.get(self, "audio")

    @audio.setter
    def audio(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audio", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
        This field is part of a union field `content`: Only one of `audio` or `uri` may be set.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        ssml: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SSML text to be synthesized. For more information, see SSML.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The raw text to be synthesized.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
elif False:
    CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 ssml: Optional[pulumi.Input[_builtins.str]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param pulumi.Input[_builtins.str] ssml: The SSML text to be synthesized. For more information, see SSML.
               This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        :param pulumi.Input[_builtins.str] text: The raw text to be synthesized.
               This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if ssml is not None:
            pulumi.set(__self__, "ssml", ssml)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def ssml(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SSML text to be synthesized. For more information, see SSML.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        return pulumi.get(self, "ssml")

    @ssml.setter
    def ssml(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssml", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The raw text to be synthesized.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgsDict(TypedDict):
        audio_uri: pulumi.Input[_builtins.str]
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.

        <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
elif False:
    CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgs:
    def __init__(__self__, *,
                 audio_uri: pulumi.Input[_builtins.str],
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] audio_uri: URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
               
               <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
        pulumi.set(__self__, "audio_uri", audio_uri)
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)

    @_builtins.property
    @pulumi.getter(name="audioUri")
    def audio_uri(self) -> pulumi.Input[_builtins.str]:
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        return pulumi.get(self, "audio_uri")

    @audio_uri.setter
    def audio_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "audio_uri", value)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.

        <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgsDict(TypedDict):
        phone_number: pulumi.Input[_builtins.str]
        """
        Transfer the call to a phone number in E.164 format.
        """
elif False:
    CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgs:
    def __init__(__self__, *,
                 phone_number: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] phone_number: Transfer the call to a phone number in E.164 format.
        """
        pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> pulumi.Input[_builtins.str]:
        """
        Transfer the call to a phone number in E.164 format.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        texts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
        required: true
        """
elif False:
    CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 texts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] texts: A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
               required: true
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def texts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
        required: true
        """
        return pulumi.get(self, "texts")

    @texts.setter
    def texts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "texts", value)


if not MYPY:
    class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgsDict(TypedDict):
        parameter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name of the parameter.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
elif False:
    CxFlowKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgs:
    def __init__(__self__, *,
                 parameter: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] parameter: Display name of the parameter.
        :param pulumi.Input[_builtins.str] value: The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        if parameter is not None:
            pulumi.set(__self__, "parameter", parameter)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def parameter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name of the parameter.
        """
        return pulumi.get(self, "parameter")

    @parameter.setter
    def parameter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parameter", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CxFlowNluSettingsArgsDict(TypedDict):
        classification_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold.
        If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
        """
        model_training_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates NLU model training mode.
        * MODEL_TRAINING_MODE_AUTOMATIC: NLU model training is automatically triggered when a flow gets modified. User can also manually trigger model training in this mode.
        * MODEL_TRAINING_MODE_MANUAL: User needs to manually trigger NLU model training. Best for large flows whose models take long time to train.
        Possible values are: `MODEL_TRAINING_MODE_AUTOMATIC`, `MODEL_TRAINING_MODE_MANUAL`.
        """
        model_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the type of NLU model.
        * MODEL_TYPE_STANDARD: Use standard NLU model.
        * MODEL_TYPE_ADVANCED: Use advanced NLU model.
        Possible values are: `MODEL_TYPE_STANDARD`, `MODEL_TYPE_ADVANCED`.
        """
elif False:
    CxFlowNluSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowNluSettingsArgs:
    def __init__(__self__, *,
                 classification_threshold: Optional[pulumi.Input[_builtins.float]] = None,
                 model_training_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 model_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] classification_threshold: To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold.
               If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
        :param pulumi.Input[_builtins.str] model_training_mode: Indicates NLU model training mode.
               * MODEL_TRAINING_MODE_AUTOMATIC: NLU model training is automatically triggered when a flow gets modified. User can also manually trigger model training in this mode.
               * MODEL_TRAINING_MODE_MANUAL: User needs to manually trigger NLU model training. Best for large flows whose models take long time to train.
               Possible values are: `MODEL_TRAINING_MODE_AUTOMATIC`, `MODEL_TRAINING_MODE_MANUAL`.
        :param pulumi.Input[_builtins.str] model_type: Indicates the type of NLU model.
               * MODEL_TYPE_STANDARD: Use standard NLU model.
               * MODEL_TYPE_ADVANCED: Use advanced NLU model.
               Possible values are: `MODEL_TYPE_STANDARD`, `MODEL_TYPE_ADVANCED`.
        """
        if classification_threshold is not None:
            pulumi.set(__self__, "classification_threshold", classification_threshold)
        if model_training_mode is not None:
            pulumi.set(__self__, "model_training_mode", model_training_mode)
        if model_type is not None:
            pulumi.set(__self__, "model_type", model_type)

    @_builtins.property
    @pulumi.getter(name="classificationThreshold")
    def classification_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold.
        If the returned score value is less than the threshold value, then a no-match event will be triggered. The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
        """
        return pulumi.get(self, "classification_threshold")

    @classification_threshold.setter
    def classification_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "classification_threshold", value)

    @_builtins.property
    @pulumi.getter(name="modelTrainingMode")
    def model_training_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates NLU model training mode.
        * MODEL_TRAINING_MODE_AUTOMATIC: NLU model training is automatically triggered when a flow gets modified. User can also manually trigger model training in this mode.
        * MODEL_TRAINING_MODE_MANUAL: User needs to manually trigger NLU model training. Best for large flows whose models take long time to train.
        Possible values are: `MODEL_TRAINING_MODE_AUTOMATIC`, `MODEL_TRAINING_MODE_MANUAL`.
        """
        return pulumi.get(self, "model_training_mode")

    @model_training_mode.setter
    def model_training_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model_training_mode", value)

    @_builtins.property
    @pulumi.getter(name="modelType")
    def model_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the type of NLU model.
        * MODEL_TYPE_STANDARD: Use standard NLU model.
        * MODEL_TYPE_ADVANCED: Use advanced NLU model.
        Possible values are: `MODEL_TYPE_STANDARD`, `MODEL_TYPE_ADVANCED`.
        """
        return pulumi.get(self, "model_type")

    @model_type.setter
    def model_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model_type", value)


if not MYPY:
    class CxFlowTransitionRouteArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The condition to evaluate against form parameters or session parameters.
        At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        """
        intent: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier of an Intent.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>. Indicates that the transition can only happen when the given intent is matched. At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The unique identifier of this transition route.
        """
        target_flow: NotRequired[pulumi.Input[_builtins.str]]
        """
        The target flow to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        """
        target_page: NotRequired[pulumi.Input[_builtins.str]]
        """
        The target page to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        trigger_fulfillment: NotRequired[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentArgsDict']]
        """
        The fulfillment to call when the condition is satisfied. At least one of triggerFulfillment and target must be specified. When both are defined, triggerFulfillment is executed first.
        Structure is documented below.
        """
elif False:
    CxFlowTransitionRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowTransitionRouteArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[_builtins.str]] = None,
                 intent: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 target_flow: Optional[pulumi.Input[_builtins.str]] = None,
                 target_page: Optional[pulumi.Input[_builtins.str]] = None,
                 trigger_fulfillment: Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] condition: The condition to evaluate against form parameters or session parameters.
               At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        :param pulumi.Input[_builtins.str] intent: The unique identifier of an Intent.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>. Indicates that the transition can only happen when the given intent is matched. At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        :param pulumi.Input[_builtins.str] name: (Output)
               The unique identifier of this transition route.
        :param pulumi.Input[_builtins.str] target_flow: The target flow to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        :param pulumi.Input[_builtins.str] target_page: The target page to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        :param pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentArgs'] trigger_fulfillment: The fulfillment to call when the condition is satisfied. At least one of triggerFulfillment and target must be specified. When both are defined, triggerFulfillment is executed first.
               Structure is documented below.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if intent is not None:
            pulumi.set(__self__, "intent", intent)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target_flow is not None:
            pulumi.set(__self__, "target_flow", target_flow)
        if target_page is not None:
            pulumi.set(__self__, "target_page", target_page)
        if trigger_fulfillment is not None:
            pulumi.set(__self__, "trigger_fulfillment", trigger_fulfillment)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The condition to evaluate against form parameters or session parameters.
        At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter
    def intent(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier of an Intent.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>. Indicates that the transition can only happen when the given intent is matched. At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        """
        return pulumi.get(self, "intent")

    @intent.setter
    def intent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "intent", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The unique identifier of this transition route.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="targetFlow")
    def target_flow(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The target flow to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        """
        return pulumi.get(self, "target_flow")

    @target_flow.setter
    def target_flow(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_flow", value)

    @_builtins.property
    @pulumi.getter(name="targetPage")
    def target_page(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The target page to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        return pulumi.get(self, "target_page")

    @target_page.setter
    def target_page(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_page", value)

    @_builtins.property
    @pulumi.getter(name="triggerFulfillment")
    def trigger_fulfillment(self) -> Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentArgs']]:
        """
        The fulfillment to call when the condition is satisfied. At least one of triggerFulfillment and target must be specified. When both are defined, triggerFulfillment is executed first.
        Structure is documented below.
        """
        return pulumi.get(self, "trigger_fulfillment")

    @trigger_fulfillment.setter
    def trigger_fulfillment(self, value: Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentArgs']]):
        pulumi.set(self, "trigger_fulfillment", value)


if not MYPY:
    class CxFlowTransitionRouteTriggerFulfillmentArgsDict(TypedDict):
        conditional_cases: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentConditionalCaseArgsDict']]]]
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        messages: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageArgsDict']]]]
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return_partial_responses: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        set_parameter_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentSetParameterActionArgsDict']]]]
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        webhook: NotRequired[pulumi.Input[_builtins.str]]
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
elif False:
    CxFlowTransitionRouteTriggerFulfillmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowTransitionRouteTriggerFulfillmentArgs:
    def __init__(__self__, *,
                 conditional_cases: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentConditionalCaseArgs']]]] = None,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageArgs']]]] = None,
                 return_partial_responses: Optional[pulumi.Input[_builtins.bool]] = None,
                 set_parameter_actions: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentSetParameterActionArgs']]]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None,
                 webhook: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentConditionalCaseArgs']]] conditional_cases: Conditional cases for this fulfillment.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageArgs']]] messages: The list of rich message responses to present to the user.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] return_partial_responses: Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        :param pulumi.Input[Sequence[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentSetParameterActionArgs']]] set_parameter_actions: Set parameter values before executing the webhook.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] tag: The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        :param pulumi.Input[_builtins.str] webhook: The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        if conditional_cases is not None:
            pulumi.set(__self__, "conditional_cases", conditional_cases)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if return_partial_responses is not None:
            pulumi.set(__self__, "return_partial_responses", return_partial_responses)
        if set_parameter_actions is not None:
            pulumi.set(__self__, "set_parameter_actions", set_parameter_actions)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @_builtins.property
    @pulumi.getter(name="conditionalCases")
    def conditional_cases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentConditionalCaseArgs']]]]:
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        return pulumi.get(self, "conditional_cases")

    @conditional_cases.setter
    def conditional_cases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentConditionalCaseArgs']]]]):
        pulumi.set(self, "conditional_cases", value)

    @_builtins.property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageArgs']]]]:
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageArgs']]]]):
        pulumi.set(self, "messages", value)

    @_builtins.property
    @pulumi.getter(name="returnPartialResponses")
    def return_partial_responses(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        return pulumi.get(self, "return_partial_responses")

    @return_partial_responses.setter
    def return_partial_responses(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "return_partial_responses", value)

    @_builtins.property
    @pulumi.getter(name="setParameterActions")
    def set_parameter_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentSetParameterActionArgs']]]]:
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        return pulumi.get(self, "set_parameter_actions")

    @set_parameter_actions.setter
    def set_parameter_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentSetParameterActionArgs']]]]):
        pulumi.set(self, "set_parameter_actions", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def webhook(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        return pulumi.get(self, "webhook")

    @webhook.setter
    def webhook(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "webhook", value)


if not MYPY:
    class CxFlowTransitionRouteTriggerFulfillmentConditionalCaseArgsDict(TypedDict):
        cases: NotRequired[pulumi.Input[_builtins.str]]
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
elif False:
    CxFlowTransitionRouteTriggerFulfillmentConditionalCaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowTransitionRouteTriggerFulfillmentConditionalCaseArgs:
    def __init__(__self__, *,
                 cases: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cases: A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
               See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        if cases is not None:
            pulumi.set(__self__, "cases", cases)

    @_builtins.property
    @pulumi.getter
    def cases(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        return pulumi.get(self, "cases")

    @cases.setter
    def cases(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cases", value)


if not MYPY:
    class CxFlowTransitionRouteTriggerFulfillmentMessageArgsDict(TypedDict):
        channel: NotRequired[pulumi.Input[_builtins.str]]
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        conversation_success: NotRequired[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageConversationSuccessArgsDict']]
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        live_agent_handoff: NotRequired[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgsDict']]
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        output_audio_text: NotRequired[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgsDict']]
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        Returns a response containing a custom, platform-specific payload.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        play_audio: NotRequired[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudioArgsDict']]
        """
        Specifies an audio clip to be played by the client as part of the response.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        telephony_transfer_call: NotRequired[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgsDict']]
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        text: NotRequired[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageTextArgsDict']]
        """
        The text response message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
elif False:
    CxFlowTransitionRouteTriggerFulfillmentMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowTransitionRouteTriggerFulfillmentMessageArgs:
    def __init__(__self__, *,
                 channel: Optional[pulumi.Input[_builtins.str]] = None,
                 conversation_success: Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageConversationSuccessArgs']] = None,
                 live_agent_handoff: Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgs']] = None,
                 output_audio_text: Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgs']] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 play_audio: Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudioArgs']] = None,
                 telephony_transfer_call: Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgs']] = None,
                 text: Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageTextArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] channel: The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        :param pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageConversationSuccessArgs'] conversation_success: Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
               Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
               * In a webhook response when you determine that you handled the customer issue.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgs'] live_agent_handoff: Indicates that the conversation should be handed off to a live agent.
               Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
               * In a webhook response when you determine that the customer issue can only be handled by a human.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgs'] output_audio_text: A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] payload: Returns a response containing a custom, platform-specific payload.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        :param pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudioArgs'] play_audio: Specifies an audio clip to be played by the client as part of the response.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgs'] telephony_transfer_call: Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageTextArgs'] text: The text response message.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if conversation_success is not None:
            pulumi.set(__self__, "conversation_success", conversation_success)
        if live_agent_handoff is not None:
            pulumi.set(__self__, "live_agent_handoff", live_agent_handoff)
        if output_audio_text is not None:
            pulumi.set(__self__, "output_audio_text", output_audio_text)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if play_audio is not None:
            pulumi.set(__self__, "play_audio", play_audio)
        if telephony_transfer_call is not None:
            pulumi.set(__self__, "telephony_transfer_call", telephony_transfer_call)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter(name="conversationSuccess")
    def conversation_success(self) -> Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageConversationSuccessArgs']]:
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_success")

    @conversation_success.setter
    def conversation_success(self, value: Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageConversationSuccessArgs']]):
        pulumi.set(self, "conversation_success", value)

    @_builtins.property
    @pulumi.getter(name="liveAgentHandoff")
    def live_agent_handoff(self) -> Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgs']]:
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "live_agent_handoff")

    @live_agent_handoff.setter
    def live_agent_handoff(self, value: Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgs']]):
        pulumi.set(self, "live_agent_handoff", value)

    @_builtins.property
    @pulumi.getter(name="outputAudioText")
    def output_audio_text(self) -> Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgs']]:
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "output_audio_text")

    @output_audio_text.setter
    def output_audio_text(self, value: Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgs']]):
        pulumi.set(self, "output_audio_text", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Returns a response containing a custom, platform-specific payload.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="playAudio")
    def play_audio(self) -> Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudioArgs']]:
        """
        Specifies an audio clip to be played by the client as part of the response.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "play_audio")

    @play_audio.setter
    def play_audio(self, value: Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudioArgs']]):
        pulumi.set(self, "play_audio", value)

    @_builtins.property
    @pulumi.getter(name="telephonyTransferCall")
    def telephony_transfer_call(self) -> Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgs']]:
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "telephony_transfer_call")

    @telephony_transfer_call.setter
    def telephony_transfer_call(self, value: Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgs']]):
        pulumi.set(self, "telephony_transfer_call", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageTextArgs']]:
        """
        The text response message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['CxFlowTransitionRouteTriggerFulfillmentMessageTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxFlowTransitionRouteTriggerFulfillmentMessageConversationSuccessArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
elif False:
    CxFlowTransitionRouteTriggerFulfillmentMessageConversationSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowTransitionRouteTriggerFulfillmentMessageConversationSuccessArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class CxFlowTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
elif False:
    CxFlowTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        ssml: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SSML text to be synthesized. For more information, see SSML.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The raw text to be synthesized.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
elif False:
    CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 ssml: Optional[pulumi.Input[_builtins.str]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param pulumi.Input[_builtins.str] ssml: The SSML text to be synthesized. For more information, see SSML.
               This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        :param pulumi.Input[_builtins.str] text: The raw text to be synthesized.
               This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if ssml is not None:
            pulumi.set(__self__, "ssml", ssml)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def ssml(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SSML text to be synthesized. For more information, see SSML.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        return pulumi.get(self, "ssml")

    @ssml.setter
    def ssml(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssml", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The raw text to be synthesized.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudioArgsDict(TypedDict):
        audio_uri: pulumi.Input[_builtins.str]
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.

        <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
elif False:
    CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowTransitionRouteTriggerFulfillmentMessagePlayAudioArgs:
    def __init__(__self__, *,
                 audio_uri: pulumi.Input[_builtins.str],
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] audio_uri: URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
               
               <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
        pulumi.set(__self__, "audio_uri", audio_uri)
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)

    @_builtins.property
    @pulumi.getter(name="audioUri")
    def audio_uri(self) -> pulumi.Input[_builtins.str]:
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        return pulumi.get(self, "audio_uri")

    @audio_uri.setter
    def audio_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "audio_uri", value)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.

        <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)


if not MYPY:
    class CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgsDict(TypedDict):
        phone_number: pulumi.Input[_builtins.str]
        """
        Transfer the call to a phone number in E.164 format.
        """
elif False:
    CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgs:
    def __init__(__self__, *,
                 phone_number: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] phone_number: Transfer the call to a phone number in E.164 format.
        """
        pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> pulumi.Input[_builtins.str]:
        """
        Transfer the call to a phone number in E.164 format.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class CxFlowTransitionRouteTriggerFulfillmentMessageTextArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        texts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
        required: true
        """
elif False:
    CxFlowTransitionRouteTriggerFulfillmentMessageTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowTransitionRouteTriggerFulfillmentMessageTextArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 texts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] texts: A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
               required: true
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def texts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
        required: true
        """
        return pulumi.get(self, "texts")

    @texts.setter
    def texts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "texts", value)


if not MYPY:
    class CxFlowTransitionRouteTriggerFulfillmentSetParameterActionArgsDict(TypedDict):
        parameter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name of the parameter.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
elif False:
    CxFlowTransitionRouteTriggerFulfillmentSetParameterActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxFlowTransitionRouteTriggerFulfillmentSetParameterActionArgs:
    def __init__(__self__, *,
                 parameter: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] parameter: Display name of the parameter.
        :param pulumi.Input[_builtins.str] value: The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        if parameter is not None:
            pulumi.set(__self__, "parameter", parameter)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def parameter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name of the parameter.
        """
        return pulumi.get(self, "parameter")

    @parameter.setter
    def parameter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parameter", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CxGenerativeSettingsFallbackSettingsArgsDict(TypedDict):
        prompt_templates: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxGenerativeSettingsFallbackSettingsPromptTemplateArgsDict']]]]
        """
        Stored prompts that can be selected, for example default templates like "conservative" or "chatty", or user defined ones.
        Structure is documented below.
        """
        selected_prompt: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name of the selected prompt.
        """
elif False:
    CxGenerativeSettingsFallbackSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxGenerativeSettingsFallbackSettingsArgs:
    def __init__(__self__, *,
                 prompt_templates: Optional[pulumi.Input[Sequence[pulumi.Input['CxGenerativeSettingsFallbackSettingsPromptTemplateArgs']]]] = None,
                 selected_prompt: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CxGenerativeSettingsFallbackSettingsPromptTemplateArgs']]] prompt_templates: Stored prompts that can be selected, for example default templates like "conservative" or "chatty", or user defined ones.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] selected_prompt: Display name of the selected prompt.
        """
        if prompt_templates is not None:
            pulumi.set(__self__, "prompt_templates", prompt_templates)
        if selected_prompt is not None:
            pulumi.set(__self__, "selected_prompt", selected_prompt)

    @_builtins.property
    @pulumi.getter(name="promptTemplates")
    def prompt_templates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxGenerativeSettingsFallbackSettingsPromptTemplateArgs']]]]:
        """
        Stored prompts that can be selected, for example default templates like "conservative" or "chatty", or user defined ones.
        Structure is documented below.
        """
        return pulumi.get(self, "prompt_templates")

    @prompt_templates.setter
    def prompt_templates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxGenerativeSettingsFallbackSettingsPromptTemplateArgs']]]]):
        pulumi.set(self, "prompt_templates", value)

    @_builtins.property
    @pulumi.getter(name="selectedPrompt")
    def selected_prompt(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name of the selected prompt.
        """
        return pulumi.get(self, "selected_prompt")

    @selected_prompt.setter
    def selected_prompt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "selected_prompt", value)


if not MYPY:
    class CxGenerativeSettingsFallbackSettingsPromptTemplateArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prompt name.
        """
        frozen: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If the flag is true, the prompt is frozen and cannot be modified by users.
        """
        prompt_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        Prompt text that is sent to a LLM on no-match default, placeholders are filled downstream. For example: "Here is a conversation $conversation, a response is: "
        """
elif False:
    CxGenerativeSettingsFallbackSettingsPromptTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxGenerativeSettingsFallbackSettingsPromptTemplateArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 frozen: Optional[pulumi.Input[_builtins.bool]] = None,
                 prompt_text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: Prompt name.
        :param pulumi.Input[_builtins.bool] frozen: If the flag is true, the prompt is frozen and cannot be modified by users.
        :param pulumi.Input[_builtins.str] prompt_text: Prompt text that is sent to a LLM on no-match default, placeholders are filled downstream. For example: "Here is a conversation $conversation, a response is: "
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if frozen is not None:
            pulumi.set(__self__, "frozen", frozen)
        if prompt_text is not None:
            pulumi.set(__self__, "prompt_text", prompt_text)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prompt name.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def frozen(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If the flag is true, the prompt is frozen and cannot be modified by users.
        """
        return pulumi.get(self, "frozen")

    @frozen.setter
    def frozen(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "frozen", value)

    @_builtins.property
    @pulumi.getter(name="promptText")
    def prompt_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Prompt text that is sent to a LLM on no-match default, placeholders are filled downstream. For example: "Here is a conversation $conversation, a response is: "
        """
        return pulumi.get(self, "prompt_text")

    @prompt_text.setter
    def prompt_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prompt_text", value)


if not MYPY:
    class CxGenerativeSettingsGenerativeSafetySettingsArgsDict(TypedDict):
        banned_phrases: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxGenerativeSettingsGenerativeSafetySettingsBannedPhraseArgsDict']]]]
        """
        Banned phrases for generated text.
        Structure is documented below.
        """
        default_banned_phrase_match_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Default phrase match strategy for banned phrases.
        See [PhraseMatchStrategy](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/GenerativeSettings#phrasematchstrategy) for valid values.
        """
elif False:
    CxGenerativeSettingsGenerativeSafetySettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxGenerativeSettingsGenerativeSafetySettingsArgs:
    def __init__(__self__, *,
                 banned_phrases: Optional[pulumi.Input[Sequence[pulumi.Input['CxGenerativeSettingsGenerativeSafetySettingsBannedPhraseArgs']]]] = None,
                 default_banned_phrase_match_strategy: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CxGenerativeSettingsGenerativeSafetySettingsBannedPhraseArgs']]] banned_phrases: Banned phrases for generated text.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] default_banned_phrase_match_strategy: Optional. Default phrase match strategy for banned phrases.
               See [PhraseMatchStrategy](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/GenerativeSettings#phrasematchstrategy) for valid values.
        """
        if banned_phrases is not None:
            pulumi.set(__self__, "banned_phrases", banned_phrases)
        if default_banned_phrase_match_strategy is not None:
            pulumi.set(__self__, "default_banned_phrase_match_strategy", default_banned_phrase_match_strategy)

    @_builtins.property
    @pulumi.getter(name="bannedPhrases")
    def banned_phrases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxGenerativeSettingsGenerativeSafetySettingsBannedPhraseArgs']]]]:
        """
        Banned phrases for generated text.
        Structure is documented below.
        """
        return pulumi.get(self, "banned_phrases")

    @banned_phrases.setter
    def banned_phrases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxGenerativeSettingsGenerativeSafetySettingsBannedPhraseArgs']]]]):
        pulumi.set(self, "banned_phrases", value)

    @_builtins.property
    @pulumi.getter(name="defaultBannedPhraseMatchStrategy")
    def default_banned_phrase_match_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Default phrase match strategy for banned phrases.
        See [PhraseMatchStrategy](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/GenerativeSettings#phrasematchstrategy) for valid values.
        """
        return pulumi.get(self, "default_banned_phrase_match_strategy")

    @default_banned_phrase_match_strategy.setter
    def default_banned_phrase_match_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_banned_phrase_match_strategy", value)


if not MYPY:
    class CxGenerativeSettingsGenerativeSafetySettingsBannedPhraseArgsDict(TypedDict):
        language_code: pulumi.Input[_builtins.str]
        """
        Language code of the phrase.
        """
        text: pulumi.Input[_builtins.str]
        """
        Text input which can be used for prompt or banned phrases.
        """
elif False:
    CxGenerativeSettingsGenerativeSafetySettingsBannedPhraseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxGenerativeSettingsGenerativeSafetySettingsBannedPhraseArgs:
    def __init__(__self__, *,
                 language_code: pulumi.Input[_builtins.str],
                 text: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] language_code: Language code of the phrase.
        :param pulumi.Input[_builtins.str] text: Text input which can be used for prompt or banned phrases.
        """
        pulumi.set(__self__, "language_code", language_code)
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> pulumi.Input[_builtins.str]:
        """
        Language code of the phrase.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "language_code", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        """
        Text input which can be used for prompt or banned phrases.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxGenerativeSettingsKnowledgeConnectorSettingsArgsDict(TypedDict):
        agent: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the virtual agent. Used for LLM prompt. Can be left empty.
        """
        agent_identity: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identity of the agent, e.g. "virtual agent", "AI assistant".
        """
        agent_scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        Agent scope, e.g. "Example company website", "internal Example company website for employees", "manual of car owner".
        """
        business: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the company, organization or other entity that the agent represents. Used for knowledge connector LLM prompt and for knowledge search.
        """
        business_description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Company description, used for LLM prompt, e.g. "a family company selling freshly roasted coffee beans".``
        """
        disable_data_store_fallback: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable fallback to Data Store search results (in case the LLM couldn't pick a proper answer). Per default the feature is enabled.
        """
elif False:
    CxGenerativeSettingsKnowledgeConnectorSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxGenerativeSettingsKnowledgeConnectorSettingsArgs:
    def __init__(__self__, *,
                 agent: Optional[pulumi.Input[_builtins.str]] = None,
                 agent_identity: Optional[pulumi.Input[_builtins.str]] = None,
                 agent_scope: Optional[pulumi.Input[_builtins.str]] = None,
                 business: Optional[pulumi.Input[_builtins.str]] = None,
                 business_description: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_data_store_fallback: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] agent: Name of the virtual agent. Used for LLM prompt. Can be left empty.
        :param pulumi.Input[_builtins.str] agent_identity: Identity of the agent, e.g. "virtual agent", "AI assistant".
        :param pulumi.Input[_builtins.str] agent_scope: Agent scope, e.g. "Example company website", "internal Example company website for employees", "manual of car owner".
        :param pulumi.Input[_builtins.str] business: Name of the company, organization or other entity that the agent represents. Used for knowledge connector LLM prompt and for knowledge search.
        :param pulumi.Input[_builtins.str] business_description: Company description, used for LLM prompt, e.g. "a family company selling freshly roasted coffee beans".``
        :param pulumi.Input[_builtins.bool] disable_data_store_fallback: Whether to disable fallback to Data Store search results (in case the LLM couldn't pick a proper answer). Per default the feature is enabled.
        """
        if agent is not None:
            pulumi.set(__self__, "agent", agent)
        if agent_identity is not None:
            pulumi.set(__self__, "agent_identity", agent_identity)
        if agent_scope is not None:
            pulumi.set(__self__, "agent_scope", agent_scope)
        if business is not None:
            pulumi.set(__self__, "business", business)
        if business_description is not None:
            pulumi.set(__self__, "business_description", business_description)
        if disable_data_store_fallback is not None:
            pulumi.set(__self__, "disable_data_store_fallback", disable_data_store_fallback)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the virtual agent. Used for LLM prompt. Can be left empty.
        """
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agent", value)

    @_builtins.property
    @pulumi.getter(name="agentIdentity")
    def agent_identity(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identity of the agent, e.g. "virtual agent", "AI assistant".
        """
        return pulumi.get(self, "agent_identity")

    @agent_identity.setter
    def agent_identity(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agent_identity", value)

    @_builtins.property
    @pulumi.getter(name="agentScope")
    def agent_scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Agent scope, e.g. "Example company website", "internal Example company website for employees", "manual of car owner".
        """
        return pulumi.get(self, "agent_scope")

    @agent_scope.setter
    def agent_scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agent_scope", value)

    @_builtins.property
    @pulumi.getter
    def business(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the company, organization or other entity that the agent represents. Used for knowledge connector LLM prompt and for knowledge search.
        """
        return pulumi.get(self, "business")

    @business.setter
    def business(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "business", value)

    @_builtins.property
    @pulumi.getter(name="businessDescription")
    def business_description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Company description, used for LLM prompt, e.g. "a family company selling freshly roasted coffee beans".``
        """
        return pulumi.get(self, "business_description")

    @business_description.setter
    def business_description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "business_description", value)

    @_builtins.property
    @pulumi.getter(name="disableDataStoreFallback")
    def disable_data_store_fallback(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable fallback to Data Store search results (in case the LLM couldn't pick a proper answer). Per default the feature is enabled.
        """
        return pulumi.get(self, "disable_data_store_fallback")

    @disable_data_store_fallback.setter
    def disable_data_store_fallback(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_data_store_fallback", value)


if not MYPY:
    class CxGenerativeSettingsLlmModelSettingsArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The selected LLM model.
        """
        prompt_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The custom prompt to use.
        """
elif False:
    CxGenerativeSettingsLlmModelSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxGenerativeSettingsLlmModelSettingsArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 prompt_text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] model: The selected LLM model.
        :param pulumi.Input[_builtins.str] prompt_text: The custom prompt to use.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if prompt_text is not None:
            pulumi.set(__self__, "prompt_text", prompt_text)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The selected LLM model.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter(name="promptText")
    def prompt_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The custom prompt to use.
        """
        return pulumi.get(self, "prompt_text")

    @prompt_text.setter
    def prompt_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prompt_text", value)


if not MYPY:
    class CxGeneratorLlmModelSettingsArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The selected LLM model.
        """
        prompt_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The custom prompt to use.
        """
elif False:
    CxGeneratorLlmModelSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxGeneratorLlmModelSettingsArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 prompt_text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] model: The selected LLM model.
        :param pulumi.Input[_builtins.str] prompt_text: The custom prompt to use.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if prompt_text is not None:
            pulumi.set(__self__, "prompt_text", prompt_text)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The selected LLM model.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter(name="promptText")
    def prompt_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The custom prompt to use.
        """
        return pulumi.get(self, "prompt_text")

    @prompt_text.setter
    def prompt_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prompt_text", value)


if not MYPY:
    class CxGeneratorModelParameterArgsDict(TypedDict):
        max_decode_steps: NotRequired[pulumi.Input[_builtins.int]]
        """
        The maximum number of tokens to generate.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        The temperature used for sampling. Temperature sampling occurs after both topP and topK have been applied.
        Valid range: [0.0, 1.0] Low temperature = less random. High temperature = more random.
        """
        top_k: NotRequired[pulumi.Input[_builtins.int]]
        """
        If set, the sampling process in each step is limited to the topK tokens with highest probabilities.
        Valid range: [1, 40] or 1000+. Small topK = less random. Large topK = more random.
        """
        top_p: NotRequired[pulumi.Input[_builtins.float]]
        """
        If set, only the tokens comprising the top topP probability mass are considered.
        If both topP and topK are set, topP will be used for further refining candidates selected with topK.
        Valid range: (0.0, 1.0]. Small topP = less random. Large topP = more random.
        """
elif False:
    CxGeneratorModelParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxGeneratorModelParameterArgs:
    def __init__(__self__, *,
                 max_decode_steps: Optional[pulumi.Input[_builtins.int]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None,
                 top_k: Optional[pulumi.Input[_builtins.int]] = None,
                 top_p: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.int] max_decode_steps: The maximum number of tokens to generate.
        :param pulumi.Input[_builtins.float] temperature: The temperature used for sampling. Temperature sampling occurs after both topP and topK have been applied.
               Valid range: [0.0, 1.0] Low temperature = less random. High temperature = more random.
        :param pulumi.Input[_builtins.int] top_k: If set, the sampling process in each step is limited to the topK tokens with highest probabilities.
               Valid range: [1, 40] or 1000+. Small topK = less random. Large topK = more random.
        :param pulumi.Input[_builtins.float] top_p: If set, only the tokens comprising the top topP probability mass are considered.
               If both topP and topK are set, topP will be used for further refining candidates selected with topK.
               Valid range: (0.0, 1.0]. Small topP = less random. Large topP = more random.
        """
        if max_decode_steps is not None:
            pulumi.set(__self__, "max_decode_steps", max_decode_steps)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_k is not None:
            pulumi.set(__self__, "top_k", top_k)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @_builtins.property
    @pulumi.getter(name="maxDecodeSteps")
    def max_decode_steps(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The maximum number of tokens to generate.
        """
        return pulumi.get(self, "max_decode_steps")

    @max_decode_steps.setter
    def max_decode_steps(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_decode_steps", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The temperature used for sampling. Temperature sampling occurs after both topP and topK have been applied.
        Valid range: [0.0, 1.0] Low temperature = less random. High temperature = more random.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)

    @_builtins.property
    @pulumi.getter(name="topK")
    def top_k(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        If set, the sampling process in each step is limited to the topK tokens with highest probabilities.
        Valid range: [1, 40] or 1000+. Small topK = less random. Large topK = more random.
        """
        return pulumi.get(self, "top_k")

    @top_k.setter
    def top_k(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "top_k", value)

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        If set, only the tokens comprising the top topP probability mass are considered.
        If both topP and topK are set, topP will be used for further refining candidates selected with topK.
        Valid range: (0.0, 1.0]. Small topP = less random. Large topP = more random.
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "top_p", value)


if not MYPY:
    class CxGeneratorPlaceholderArgsDict(TypedDict):
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Unique ID used to map custom placeholder to parameters in fulfillment.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom placeholder value in the prompt text.
        """
elif False:
    CxGeneratorPlaceholderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxGeneratorPlaceholderArgs:
    def __init__(__self__, *,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] id: Unique ID used to map custom placeholder to parameters in fulfillment.
        :param pulumi.Input[_builtins.str] name: Custom placeholder value in the prompt text.
        """
        if id is not None:
            pulumi.set(__self__, "id", id)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Unique ID used to map custom placeholder to parameters in fulfillment.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom placeholder value in the prompt text.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CxGeneratorPromptTextArgsDict(TypedDict):
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        Text input which can be used for prompt or banned phrases.
        """
elif False:
    CxGeneratorPromptTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxGeneratorPromptTextArgs:
    def __init__(__self__, *,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] text: Text input which can be used for prompt or banned phrases.
        """
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Text input which can be used for prompt or banned phrases.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxIntentParameterArgsDict(TypedDict):
        entity_type: pulumi.Input[_builtins.str]
        """
        The entity type of the parameter.
        Format: projects/-/locations/-/agents/-/entityTypes/<System Entity Type ID> for system entity types (for example, projects/-/locations/-/agents/-/entityTypes/sys.date), or projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/entityTypes/<Entity Type ID> for developer entity types.
        """
        id: pulumi.Input[_builtins.str]
        """
        The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
        """
        is_list: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the parameter represents a list of values.
        """
        redact: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging.
        Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
        """
elif False:
    CxIntentParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxIntentParameterArgs:
    def __init__(__self__, *,
                 entity_type: pulumi.Input[_builtins.str],
                 id: pulumi.Input[_builtins.str],
                 is_list: Optional[pulumi.Input[_builtins.bool]] = None,
                 redact: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] entity_type: The entity type of the parameter.
               Format: projects/-/locations/-/agents/-/entityTypes/<System Entity Type ID> for system entity types (for example, projects/-/locations/-/agents/-/entityTypes/sys.date), or projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/entityTypes/<Entity Type ID> for developer entity types.
        :param pulumi.Input[_builtins.str] id: The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
        :param pulumi.Input[_builtins.bool] is_list: Indicates whether the parameter represents a list of values.
        :param pulumi.Input[_builtins.bool] redact: Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging.
               Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
        """
        pulumi.set(__self__, "entity_type", entity_type)
        pulumi.set(__self__, "id", id)
        if is_list is not None:
            pulumi.set(__self__, "is_list", is_list)
        if redact is not None:
            pulumi.set(__self__, "redact", redact)

    @_builtins.property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> pulumi.Input[_builtins.str]:
        """
        The entity type of the parameter.
        Format: projects/-/locations/-/agents/-/entityTypes/<System Entity Type ID> for system entity types (for example, projects/-/locations/-/agents/-/entityTypes/sys.date), or projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/entityTypes/<Entity Type ID> for developer entity types.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "entity_type", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> pulumi.Input[_builtins.str]:
        """
        The unique identifier of the parameter. This field is used by training phrases to annotate their parts.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="isList")
    def is_list(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the parameter represents a list of values.
        """
        return pulumi.get(self, "is_list")

    @is_list.setter
    def is_list(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_list", value)

    @_builtins.property
    @pulumi.getter
    def redact(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the parameter content should be redacted in log. If redaction is enabled, the parameter content will be replaced by parameter name during logging.
        Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
        """
        return pulumi.get(self, "redact")

    @redact.setter
    def redact(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "redact", value)


if not MYPY:
    class CxIntentTrainingPhraseArgsDict(TypedDict):
        parts: pulumi.Input[Sequence[pulumi.Input['CxIntentTrainingPhrasePartArgsDict']]]
        """
        The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase.
        Note: The API does not automatically annotate training phrases like the Dialogflow Console does.
        Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated.
        If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set.
        If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways:
        Part.text is set to a part of the phrase that has no parameters.
        Part.text is set to a part of the phrase that you want to annotate, and the parameterId field is set.
        Structure is documented below.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The unique identifier of the training phrase.
        """
        repeat_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        Indicates how many times this example was added to the intent.
        """
elif False:
    CxIntentTrainingPhraseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxIntentTrainingPhraseArgs:
    def __init__(__self__, *,
                 parts: pulumi.Input[Sequence[pulumi.Input['CxIntentTrainingPhrasePartArgs']]],
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 repeat_count: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CxIntentTrainingPhrasePartArgs']]] parts: The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase.
               Note: The API does not automatically annotate training phrases like the Dialogflow Console does.
               Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated.
               If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set.
               If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways:
               Part.text is set to a part of the phrase that has no parameters.
               Part.text is set to a part of the phrase that you want to annotate, and the parameterId field is set.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] id: (Output)
               The unique identifier of the training phrase.
        :param pulumi.Input[_builtins.int] repeat_count: Indicates how many times this example was added to the intent.
        """
        pulumi.set(__self__, "parts", parts)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if repeat_count is not None:
            pulumi.set(__self__, "repeat_count", repeat_count)

    @_builtins.property
    @pulumi.getter
    def parts(self) -> pulumi.Input[Sequence[pulumi.Input['CxIntentTrainingPhrasePartArgs']]]:
        """
        The ordered list of training phrase parts. The parts are concatenated in order to form the training phrase.
        Note: The API does not automatically annotate training phrases like the Dialogflow Console does.
        Note: Do not forget to include whitespace at part boundaries, so the training phrase is well formatted when the parts are concatenated.
        If the training phrase does not need to be annotated with parameters, you just need a single part with only the Part.text field set.
        If you want to annotate the training phrase, you must create multiple parts, where the fields of each part are populated in one of two ways:
        Part.text is set to a part of the phrase that has no parameters.
        Part.text is set to a part of the phrase that you want to annotate, and the parameterId field is set.
        Structure is documented below.
        """
        return pulumi.get(self, "parts")

    @parts.setter
    def parts(self, value: pulumi.Input[Sequence[pulumi.Input['CxIntentTrainingPhrasePartArgs']]]):
        pulumi.set(self, "parts", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The unique identifier of the training phrase.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter(name="repeatCount")
    def repeat_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Indicates how many times this example was added to the intent.
        """
        return pulumi.get(self, "repeat_count")

    @repeat_count.setter
    def repeat_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "repeat_count", value)


if not MYPY:
    class CxIntentTrainingPhrasePartArgsDict(TypedDict):
        text: pulumi.Input[_builtins.str]
        """
        The text for this part.
        """
        parameter_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
        """
elif False:
    CxIntentTrainingPhrasePartArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxIntentTrainingPhrasePartArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[_builtins.str],
                 parameter_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] text: The text for this part.
        :param pulumi.Input[_builtins.str] parameter_id: The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
        """
        pulumi.set(__self__, "text", text)
        if parameter_id is not None:
            pulumi.set(__self__, "parameter_id", parameter_id)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        """
        The text for this part.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter(name="parameterId")
    def parameter_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The parameter used to annotate this part of the training phrase. This field is required for annotated parts of the training phrase.
        """
        return pulumi.get(self, "parameter_id")

    @parameter_id.setter
    def parameter_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parameter_id", value)


if not MYPY:
    class CxPageAdvancedSettingsArgsDict(TypedDict):
        dtmf_settings: NotRequired[pulumi.Input['CxPageAdvancedSettingsDtmfSettingsArgsDict']]
        """
        Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
elif False:
    CxPageAdvancedSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageAdvancedSettingsArgs:
    def __init__(__self__, *,
                 dtmf_settings: Optional[pulumi.Input['CxPageAdvancedSettingsDtmfSettingsArgs']] = None):
        """
        :param pulumi.Input['CxPageAdvancedSettingsDtmfSettingsArgs'] dtmf_settings: Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
               * Agent level
               * Flow level
               * Page level
               * Parameter level
               Structure is documented below.
        """
        if dtmf_settings is not None:
            pulumi.set(__self__, "dtmf_settings", dtmf_settings)

    @_builtins.property
    @pulumi.getter(name="dtmfSettings")
    def dtmf_settings(self) -> Optional[pulumi.Input['CxPageAdvancedSettingsDtmfSettingsArgs']]:
        """
        Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
        return pulumi.get(self, "dtmf_settings")

    @dtmf_settings.setter
    def dtmf_settings(self, value: Optional[pulumi.Input['CxPageAdvancedSettingsDtmfSettingsArgs']]):
        pulumi.set(self, "dtmf_settings", value)


if not MYPY:
    class CxPageAdvancedSettingsDtmfSettingsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        """
        finish_digit: NotRequired[pulumi.Input[_builtins.str]]
        """
        The digit that terminates a DTMF digit sequence.
        """
        max_digits: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max length of DTMF digits.
        """
elif False:
    CxPageAdvancedSettingsDtmfSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageAdvancedSettingsDtmfSettingsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 finish_digit: Optional[pulumi.Input[_builtins.str]] = None,
                 max_digits: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        :param pulumi.Input[_builtins.str] finish_digit: The digit that terminates a DTMF digit sequence.
        :param pulumi.Input[_builtins.int] max_digits: Max length of DTMF digits.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if finish_digit is not None:
            pulumi.set(__self__, "finish_digit", finish_digit)
        if max_digits is not None:
            pulumi.set(__self__, "max_digits", max_digits)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="finishDigit")
    def finish_digit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The digit that terminates a DTMF digit sequence.
        """
        return pulumi.get(self, "finish_digit")

    @finish_digit.setter
    def finish_digit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "finish_digit", value)

    @_builtins.property
    @pulumi.getter(name="maxDigits")
    def max_digits(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max length of DTMF digits.
        """
        return pulumi.get(self, "max_digits")

    @max_digits.setter
    def max_digits(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_digits", value)


if not MYPY:
    class CxPageEntryFulfillmentArgsDict(TypedDict):
        conditional_cases: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageEntryFulfillmentConditionalCaseArgsDict']]]]
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        messages: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageEntryFulfillmentMessageArgsDict']]]]
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return_partial_responses: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        set_parameter_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageEntryFulfillmentSetParameterActionArgsDict']]]]
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        webhook: NotRequired[pulumi.Input[_builtins.str]]
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
elif False:
    CxPageEntryFulfillmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEntryFulfillmentArgs:
    def __init__(__self__, *,
                 conditional_cases: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageEntryFulfillmentConditionalCaseArgs']]]] = None,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageEntryFulfillmentMessageArgs']]]] = None,
                 return_partial_responses: Optional[pulumi.Input[_builtins.bool]] = None,
                 set_parameter_actions: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageEntryFulfillmentSetParameterActionArgs']]]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None,
                 webhook: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CxPageEntryFulfillmentConditionalCaseArgs']]] conditional_cases: Conditional cases for this fulfillment.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['CxPageEntryFulfillmentMessageArgs']]] messages: The list of rich message responses to present to the user.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] return_partial_responses: Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        :param pulumi.Input[Sequence[pulumi.Input['CxPageEntryFulfillmentSetParameterActionArgs']]] set_parameter_actions: Set parameter values before executing the webhook.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] tag: The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        :param pulumi.Input[_builtins.str] webhook: The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        if conditional_cases is not None:
            pulumi.set(__self__, "conditional_cases", conditional_cases)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if return_partial_responses is not None:
            pulumi.set(__self__, "return_partial_responses", return_partial_responses)
        if set_parameter_actions is not None:
            pulumi.set(__self__, "set_parameter_actions", set_parameter_actions)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @_builtins.property
    @pulumi.getter(name="conditionalCases")
    def conditional_cases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageEntryFulfillmentConditionalCaseArgs']]]]:
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        return pulumi.get(self, "conditional_cases")

    @conditional_cases.setter
    def conditional_cases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageEntryFulfillmentConditionalCaseArgs']]]]):
        pulumi.set(self, "conditional_cases", value)

    @_builtins.property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageEntryFulfillmentMessageArgs']]]]:
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageEntryFulfillmentMessageArgs']]]]):
        pulumi.set(self, "messages", value)

    @_builtins.property
    @pulumi.getter(name="returnPartialResponses")
    def return_partial_responses(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        return pulumi.get(self, "return_partial_responses")

    @return_partial_responses.setter
    def return_partial_responses(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "return_partial_responses", value)

    @_builtins.property
    @pulumi.getter(name="setParameterActions")
    def set_parameter_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageEntryFulfillmentSetParameterActionArgs']]]]:
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        return pulumi.get(self, "set_parameter_actions")

    @set_parameter_actions.setter
    def set_parameter_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageEntryFulfillmentSetParameterActionArgs']]]]):
        pulumi.set(self, "set_parameter_actions", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def webhook(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        return pulumi.get(self, "webhook")

    @webhook.setter
    def webhook(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "webhook", value)


if not MYPY:
    class CxPageEntryFulfillmentConditionalCaseArgsDict(TypedDict):
        cases: NotRequired[pulumi.Input[_builtins.str]]
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
elif False:
    CxPageEntryFulfillmentConditionalCaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEntryFulfillmentConditionalCaseArgs:
    def __init__(__self__, *,
                 cases: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cases: A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
               See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        if cases is not None:
            pulumi.set(__self__, "cases", cases)

    @_builtins.property
    @pulumi.getter
    def cases(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        return pulumi.get(self, "cases")

    @cases.setter
    def cases(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cases", value)


if not MYPY:
    class CxPageEntryFulfillmentMessageArgsDict(TypedDict):
        channel: NotRequired[pulumi.Input[_builtins.str]]
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        conversation_success: NotRequired[pulumi.Input['CxPageEntryFulfillmentMessageConversationSuccessArgsDict']]
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        live_agent_handoff: NotRequired[pulumi.Input['CxPageEntryFulfillmentMessageLiveAgentHandoffArgsDict']]
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        output_audio_text: NotRequired[pulumi.Input['CxPageEntryFulfillmentMessageOutputAudioTextArgsDict']]
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        Returns a response containing a custom, platform-specific payload.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        play_audio: NotRequired[pulumi.Input['CxPageEntryFulfillmentMessagePlayAudioArgsDict']]
        """
        Specifies an audio clip to be played by the client as part of the response.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        telephony_transfer_call: NotRequired[pulumi.Input['CxPageEntryFulfillmentMessageTelephonyTransferCallArgsDict']]
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        text: NotRequired[pulumi.Input['CxPageEntryFulfillmentMessageTextArgsDict']]
        """
        The text response message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
elif False:
    CxPageEntryFulfillmentMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEntryFulfillmentMessageArgs:
    def __init__(__self__, *,
                 channel: Optional[pulumi.Input[_builtins.str]] = None,
                 conversation_success: Optional[pulumi.Input['CxPageEntryFulfillmentMessageConversationSuccessArgs']] = None,
                 live_agent_handoff: Optional[pulumi.Input['CxPageEntryFulfillmentMessageLiveAgentHandoffArgs']] = None,
                 output_audio_text: Optional[pulumi.Input['CxPageEntryFulfillmentMessageOutputAudioTextArgs']] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 play_audio: Optional[pulumi.Input['CxPageEntryFulfillmentMessagePlayAudioArgs']] = None,
                 telephony_transfer_call: Optional[pulumi.Input['CxPageEntryFulfillmentMessageTelephonyTransferCallArgs']] = None,
                 text: Optional[pulumi.Input['CxPageEntryFulfillmentMessageTextArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] channel: The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        :param pulumi.Input['CxPageEntryFulfillmentMessageConversationSuccessArgs'] conversation_success: Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
               Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
               * In a webhook response when you determine that you handled the customer issue.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageEntryFulfillmentMessageLiveAgentHandoffArgs'] live_agent_handoff: Indicates that the conversation should be handed off to a live agent.
               Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
               * In a webhook response when you determine that the customer issue can only be handled by a human.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageEntryFulfillmentMessageOutputAudioTextArgs'] output_audio_text: A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] payload: Returns a response containing a custom, platform-specific payload.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        :param pulumi.Input['CxPageEntryFulfillmentMessagePlayAudioArgs'] play_audio: Specifies an audio clip to be played by the client as part of the response.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageEntryFulfillmentMessageTelephonyTransferCallArgs'] telephony_transfer_call: Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageEntryFulfillmentMessageTextArgs'] text: The text response message.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if conversation_success is not None:
            pulumi.set(__self__, "conversation_success", conversation_success)
        if live_agent_handoff is not None:
            pulumi.set(__self__, "live_agent_handoff", live_agent_handoff)
        if output_audio_text is not None:
            pulumi.set(__self__, "output_audio_text", output_audio_text)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if play_audio is not None:
            pulumi.set(__self__, "play_audio", play_audio)
        if telephony_transfer_call is not None:
            pulumi.set(__self__, "telephony_transfer_call", telephony_transfer_call)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter(name="conversationSuccess")
    def conversation_success(self) -> Optional[pulumi.Input['CxPageEntryFulfillmentMessageConversationSuccessArgs']]:
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_success")

    @conversation_success.setter
    def conversation_success(self, value: Optional[pulumi.Input['CxPageEntryFulfillmentMessageConversationSuccessArgs']]):
        pulumi.set(self, "conversation_success", value)

    @_builtins.property
    @pulumi.getter(name="liveAgentHandoff")
    def live_agent_handoff(self) -> Optional[pulumi.Input['CxPageEntryFulfillmentMessageLiveAgentHandoffArgs']]:
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "live_agent_handoff")

    @live_agent_handoff.setter
    def live_agent_handoff(self, value: Optional[pulumi.Input['CxPageEntryFulfillmentMessageLiveAgentHandoffArgs']]):
        pulumi.set(self, "live_agent_handoff", value)

    @_builtins.property
    @pulumi.getter(name="outputAudioText")
    def output_audio_text(self) -> Optional[pulumi.Input['CxPageEntryFulfillmentMessageOutputAudioTextArgs']]:
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "output_audio_text")

    @output_audio_text.setter
    def output_audio_text(self, value: Optional[pulumi.Input['CxPageEntryFulfillmentMessageOutputAudioTextArgs']]):
        pulumi.set(self, "output_audio_text", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Returns a response containing a custom, platform-specific payload.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="playAudio")
    def play_audio(self) -> Optional[pulumi.Input['CxPageEntryFulfillmentMessagePlayAudioArgs']]:
        """
        Specifies an audio clip to be played by the client as part of the response.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "play_audio")

    @play_audio.setter
    def play_audio(self, value: Optional[pulumi.Input['CxPageEntryFulfillmentMessagePlayAudioArgs']]):
        pulumi.set(self, "play_audio", value)

    @_builtins.property
    @pulumi.getter(name="telephonyTransferCall")
    def telephony_transfer_call(self) -> Optional[pulumi.Input['CxPageEntryFulfillmentMessageTelephonyTransferCallArgs']]:
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "telephony_transfer_call")

    @telephony_transfer_call.setter
    def telephony_transfer_call(self, value: Optional[pulumi.Input['CxPageEntryFulfillmentMessageTelephonyTransferCallArgs']]):
        pulumi.set(self, "telephony_transfer_call", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['CxPageEntryFulfillmentMessageTextArgs']]:
        """
        The text response message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['CxPageEntryFulfillmentMessageTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxPageEntryFulfillmentMessageConversationSuccessArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
elif False:
    CxPageEntryFulfillmentMessageConversationSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEntryFulfillmentMessageConversationSuccessArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class CxPageEntryFulfillmentMessageLiveAgentHandoffArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
elif False:
    CxPageEntryFulfillmentMessageLiveAgentHandoffArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEntryFulfillmentMessageLiveAgentHandoffArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class CxPageEntryFulfillmentMessageOutputAudioTextArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        ssml: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SSML text to be synthesized. For more information, see SSML.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The raw text to be synthesized.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
elif False:
    CxPageEntryFulfillmentMessageOutputAudioTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEntryFulfillmentMessageOutputAudioTextArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 ssml: Optional[pulumi.Input[_builtins.str]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param pulumi.Input[_builtins.str] ssml: The SSML text to be synthesized. For more information, see SSML.
               This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        :param pulumi.Input[_builtins.str] text: The raw text to be synthesized.
               This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if ssml is not None:
            pulumi.set(__self__, "ssml", ssml)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def ssml(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SSML text to be synthesized. For more information, see SSML.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        return pulumi.get(self, "ssml")

    @ssml.setter
    def ssml(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssml", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The raw text to be synthesized.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxPageEntryFulfillmentMessagePlayAudioArgsDict(TypedDict):
        audio_uri: pulumi.Input[_builtins.str]
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.

        <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
elif False:
    CxPageEntryFulfillmentMessagePlayAudioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEntryFulfillmentMessagePlayAudioArgs:
    def __init__(__self__, *,
                 audio_uri: pulumi.Input[_builtins.str],
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] audio_uri: URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
               
               <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
        pulumi.set(__self__, "audio_uri", audio_uri)
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)

    @_builtins.property
    @pulumi.getter(name="audioUri")
    def audio_uri(self) -> pulumi.Input[_builtins.str]:
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        return pulumi.get(self, "audio_uri")

    @audio_uri.setter
    def audio_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "audio_uri", value)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.

        <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)


if not MYPY:
    class CxPageEntryFulfillmentMessageTelephonyTransferCallArgsDict(TypedDict):
        phone_number: pulumi.Input[_builtins.str]
        """
        Transfer the call to a phone number in E.164 format.
        """
elif False:
    CxPageEntryFulfillmentMessageTelephonyTransferCallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEntryFulfillmentMessageTelephonyTransferCallArgs:
    def __init__(__self__, *,
                 phone_number: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] phone_number: Transfer the call to a phone number in E.164 format.
        """
        pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> pulumi.Input[_builtins.str]:
        """
        Transfer the call to a phone number in E.164 format.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class CxPageEntryFulfillmentMessageTextArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        texts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
        required: true
        """
elif False:
    CxPageEntryFulfillmentMessageTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEntryFulfillmentMessageTextArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 texts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] texts: A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
               required: true
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def texts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
        required: true
        """
        return pulumi.get(self, "texts")

    @texts.setter
    def texts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "texts", value)


if not MYPY:
    class CxPageEntryFulfillmentSetParameterActionArgsDict(TypedDict):
        parameter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name of the parameter.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
elif False:
    CxPageEntryFulfillmentSetParameterActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEntryFulfillmentSetParameterActionArgs:
    def __init__(__self__, *,
                 parameter: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] parameter: Display name of the parameter.
        :param pulumi.Input[_builtins.str] value: The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        if parameter is not None:
            pulumi.set(__self__, "parameter", parameter)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def parameter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name of the parameter.
        """
        return pulumi.get(self, "parameter")

    @parameter.setter
    def parameter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parameter", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CxPageEventHandlerArgsDict(TypedDict):
        event: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the event to handle.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The unique identifier of this event handler.
        """
        target_flow: NotRequired[pulumi.Input[_builtins.str]]
        """
        The target flow to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        """
        target_page: NotRequired[pulumi.Input[_builtins.str]]
        """
        The target page to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        trigger_fulfillment: NotRequired[pulumi.Input['CxPageEventHandlerTriggerFulfillmentArgsDict']]
        """
        The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
        Structure is documented below.
        """
elif False:
    CxPageEventHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEventHandlerArgs:
    def __init__(__self__, *,
                 event: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 target_flow: Optional[pulumi.Input[_builtins.str]] = None,
                 target_page: Optional[pulumi.Input[_builtins.str]] = None,
                 trigger_fulfillment: Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] event: The name of the event to handle.
        :param pulumi.Input[_builtins.str] name: (Output)
               The unique identifier of this event handler.
        :param pulumi.Input[_builtins.str] target_flow: The target flow to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        :param pulumi.Input[_builtins.str] target_page: The target page to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        :param pulumi.Input['CxPageEventHandlerTriggerFulfillmentArgs'] trigger_fulfillment: The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
               Structure is documented below.
        """
        if event is not None:
            pulumi.set(__self__, "event", event)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target_flow is not None:
            pulumi.set(__self__, "target_flow", target_flow)
        if target_page is not None:
            pulumi.set(__self__, "target_page", target_page)
        if trigger_fulfillment is not None:
            pulumi.set(__self__, "trigger_fulfillment", trigger_fulfillment)

    @_builtins.property
    @pulumi.getter
    def event(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the event to handle.
        """
        return pulumi.get(self, "event")

    @event.setter
    def event(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The unique identifier of this event handler.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="targetFlow")
    def target_flow(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The target flow to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        """
        return pulumi.get(self, "target_flow")

    @target_flow.setter
    def target_flow(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_flow", value)

    @_builtins.property
    @pulumi.getter(name="targetPage")
    def target_page(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The target page to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        return pulumi.get(self, "target_page")

    @target_page.setter
    def target_page(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_page", value)

    @_builtins.property
    @pulumi.getter(name="triggerFulfillment")
    def trigger_fulfillment(self) -> Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentArgs']]:
        """
        The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
        Structure is documented below.
        """
        return pulumi.get(self, "trigger_fulfillment")

    @trigger_fulfillment.setter
    def trigger_fulfillment(self, value: Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentArgs']]):
        pulumi.set(self, "trigger_fulfillment", value)


if not MYPY:
    class CxPageEventHandlerTriggerFulfillmentArgsDict(TypedDict):
        conditional_cases: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageEventHandlerTriggerFulfillmentConditionalCaseArgsDict']]]]
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        messages: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageArgsDict']]]]
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return_partial_responses: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        set_parameter_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageEventHandlerTriggerFulfillmentSetParameterActionArgsDict']]]]
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        webhook: NotRequired[pulumi.Input[_builtins.str]]
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
elif False:
    CxPageEventHandlerTriggerFulfillmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEventHandlerTriggerFulfillmentArgs:
    def __init__(__self__, *,
                 conditional_cases: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageEventHandlerTriggerFulfillmentConditionalCaseArgs']]]] = None,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageArgs']]]] = None,
                 return_partial_responses: Optional[pulumi.Input[_builtins.bool]] = None,
                 set_parameter_actions: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageEventHandlerTriggerFulfillmentSetParameterActionArgs']]]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None,
                 webhook: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CxPageEventHandlerTriggerFulfillmentConditionalCaseArgs']]] conditional_cases: Conditional cases for this fulfillment.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageArgs']]] messages: The list of rich message responses to present to the user.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] return_partial_responses: Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        :param pulumi.Input[Sequence[pulumi.Input['CxPageEventHandlerTriggerFulfillmentSetParameterActionArgs']]] set_parameter_actions: Set parameter values before executing the webhook.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] tag: The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        :param pulumi.Input[_builtins.str] webhook: The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        if conditional_cases is not None:
            pulumi.set(__self__, "conditional_cases", conditional_cases)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if return_partial_responses is not None:
            pulumi.set(__self__, "return_partial_responses", return_partial_responses)
        if set_parameter_actions is not None:
            pulumi.set(__self__, "set_parameter_actions", set_parameter_actions)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @_builtins.property
    @pulumi.getter(name="conditionalCases")
    def conditional_cases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageEventHandlerTriggerFulfillmentConditionalCaseArgs']]]]:
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        return pulumi.get(self, "conditional_cases")

    @conditional_cases.setter
    def conditional_cases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageEventHandlerTriggerFulfillmentConditionalCaseArgs']]]]):
        pulumi.set(self, "conditional_cases", value)

    @_builtins.property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageArgs']]]]:
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageArgs']]]]):
        pulumi.set(self, "messages", value)

    @_builtins.property
    @pulumi.getter(name="returnPartialResponses")
    def return_partial_responses(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        return pulumi.get(self, "return_partial_responses")

    @return_partial_responses.setter
    def return_partial_responses(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "return_partial_responses", value)

    @_builtins.property
    @pulumi.getter(name="setParameterActions")
    def set_parameter_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageEventHandlerTriggerFulfillmentSetParameterActionArgs']]]]:
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        return pulumi.get(self, "set_parameter_actions")

    @set_parameter_actions.setter
    def set_parameter_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageEventHandlerTriggerFulfillmentSetParameterActionArgs']]]]):
        pulumi.set(self, "set_parameter_actions", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def webhook(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        return pulumi.get(self, "webhook")

    @webhook.setter
    def webhook(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "webhook", value)


if not MYPY:
    class CxPageEventHandlerTriggerFulfillmentConditionalCaseArgsDict(TypedDict):
        cases: NotRequired[pulumi.Input[_builtins.str]]
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
elif False:
    CxPageEventHandlerTriggerFulfillmentConditionalCaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEventHandlerTriggerFulfillmentConditionalCaseArgs:
    def __init__(__self__, *,
                 cases: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cases: A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
               See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        if cases is not None:
            pulumi.set(__self__, "cases", cases)

    @_builtins.property
    @pulumi.getter
    def cases(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        return pulumi.get(self, "cases")

    @cases.setter
    def cases(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cases", value)


if not MYPY:
    class CxPageEventHandlerTriggerFulfillmentMessageArgsDict(TypedDict):
        channel: NotRequired[pulumi.Input[_builtins.str]]
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        conversation_success: NotRequired[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageConversationSuccessArgsDict']]
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        live_agent_handoff: NotRequired[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgsDict']]
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        output_audio_text: NotRequired[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageOutputAudioTextArgsDict']]
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        Returns a response containing a custom, platform-specific payload.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        play_audio: NotRequired[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessagePlayAudioArgsDict']]
        """
        Specifies an audio clip to be played by the client as part of the response.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        telephony_transfer_call: NotRequired[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgsDict']]
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        text: NotRequired[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageTextArgsDict']]
        """
        The text response message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
elif False:
    CxPageEventHandlerTriggerFulfillmentMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEventHandlerTriggerFulfillmentMessageArgs:
    def __init__(__self__, *,
                 channel: Optional[pulumi.Input[_builtins.str]] = None,
                 conversation_success: Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageConversationSuccessArgs']] = None,
                 live_agent_handoff: Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs']] = None,
                 output_audio_text: Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs']] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 play_audio: Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessagePlayAudioArgs']] = None,
                 telephony_transfer_call: Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs']] = None,
                 text: Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageTextArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] channel: The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        :param pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageConversationSuccessArgs'] conversation_success: Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
               Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
               * In a webhook response when you determine that you handled the customer issue.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs'] live_agent_handoff: Indicates that the conversation should be handed off to a live agent.
               Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
               * In a webhook response when you determine that the customer issue can only be handled by a human.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs'] output_audio_text: A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] payload: Returns a response containing a custom, platform-specific payload.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        :param pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessagePlayAudioArgs'] play_audio: Specifies an audio clip to be played by the client as part of the response.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs'] telephony_transfer_call: Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageTextArgs'] text: The text response message.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if conversation_success is not None:
            pulumi.set(__self__, "conversation_success", conversation_success)
        if live_agent_handoff is not None:
            pulumi.set(__self__, "live_agent_handoff", live_agent_handoff)
        if output_audio_text is not None:
            pulumi.set(__self__, "output_audio_text", output_audio_text)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if play_audio is not None:
            pulumi.set(__self__, "play_audio", play_audio)
        if telephony_transfer_call is not None:
            pulumi.set(__self__, "telephony_transfer_call", telephony_transfer_call)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter(name="conversationSuccess")
    def conversation_success(self) -> Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageConversationSuccessArgs']]:
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_success")

    @conversation_success.setter
    def conversation_success(self, value: Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageConversationSuccessArgs']]):
        pulumi.set(self, "conversation_success", value)

    @_builtins.property
    @pulumi.getter(name="liveAgentHandoff")
    def live_agent_handoff(self) -> Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs']]:
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "live_agent_handoff")

    @live_agent_handoff.setter
    def live_agent_handoff(self, value: Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs']]):
        pulumi.set(self, "live_agent_handoff", value)

    @_builtins.property
    @pulumi.getter(name="outputAudioText")
    def output_audio_text(self) -> Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs']]:
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "output_audio_text")

    @output_audio_text.setter
    def output_audio_text(self, value: Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs']]):
        pulumi.set(self, "output_audio_text", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Returns a response containing a custom, platform-specific payload.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="playAudio")
    def play_audio(self) -> Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessagePlayAudioArgs']]:
        """
        Specifies an audio clip to be played by the client as part of the response.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "play_audio")

    @play_audio.setter
    def play_audio(self, value: Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessagePlayAudioArgs']]):
        pulumi.set(self, "play_audio", value)

    @_builtins.property
    @pulumi.getter(name="telephonyTransferCall")
    def telephony_transfer_call(self) -> Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs']]:
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "telephony_transfer_call")

    @telephony_transfer_call.setter
    def telephony_transfer_call(self, value: Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs']]):
        pulumi.set(self, "telephony_transfer_call", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageTextArgs']]:
        """
        The text response message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['CxPageEventHandlerTriggerFulfillmentMessageTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxPageEventHandlerTriggerFulfillmentMessageConversationSuccessArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
elif False:
    CxPageEventHandlerTriggerFulfillmentMessageConversationSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEventHandlerTriggerFulfillmentMessageConversationSuccessArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class CxPageEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
elif False:
    CxPageEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class CxPageEventHandlerTriggerFulfillmentMessageOutputAudioTextArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        ssml: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SSML text to be synthesized. For more information, see SSML.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The raw text to be synthesized.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
elif False:
    CxPageEventHandlerTriggerFulfillmentMessageOutputAudioTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 ssml: Optional[pulumi.Input[_builtins.str]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param pulumi.Input[_builtins.str] ssml: The SSML text to be synthesized. For more information, see SSML.
               This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        :param pulumi.Input[_builtins.str] text: The raw text to be synthesized.
               This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if ssml is not None:
            pulumi.set(__self__, "ssml", ssml)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def ssml(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SSML text to be synthesized. For more information, see SSML.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        return pulumi.get(self, "ssml")

    @ssml.setter
    def ssml(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssml", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The raw text to be synthesized.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxPageEventHandlerTriggerFulfillmentMessagePlayAudioArgsDict(TypedDict):
        audio_uri: pulumi.Input[_builtins.str]
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.

        <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
elif False:
    CxPageEventHandlerTriggerFulfillmentMessagePlayAudioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEventHandlerTriggerFulfillmentMessagePlayAudioArgs:
    def __init__(__self__, *,
                 audio_uri: pulumi.Input[_builtins.str],
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] audio_uri: URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
               
               <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
        pulumi.set(__self__, "audio_uri", audio_uri)
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)

    @_builtins.property
    @pulumi.getter(name="audioUri")
    def audio_uri(self) -> pulumi.Input[_builtins.str]:
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        return pulumi.get(self, "audio_uri")

    @audio_uri.setter
    def audio_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "audio_uri", value)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.

        <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)


if not MYPY:
    class CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgsDict(TypedDict):
        phone_number: pulumi.Input[_builtins.str]
        """
        Transfer the call to a phone number in E.164 format.
        """
elif False:
    CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs:
    def __init__(__self__, *,
                 phone_number: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] phone_number: Transfer the call to a phone number in E.164 format.
        """
        pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> pulumi.Input[_builtins.str]:
        """
        Transfer the call to a phone number in E.164 format.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class CxPageEventHandlerTriggerFulfillmentMessageTextArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        texts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
        required: true
        """
elif False:
    CxPageEventHandlerTriggerFulfillmentMessageTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEventHandlerTriggerFulfillmentMessageTextArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 texts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] texts: A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
               required: true
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def texts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
        required: true
        """
        return pulumi.get(self, "texts")

    @texts.setter
    def texts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "texts", value)


if not MYPY:
    class CxPageEventHandlerTriggerFulfillmentSetParameterActionArgsDict(TypedDict):
        parameter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name of the parameter.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
elif False:
    CxPageEventHandlerTriggerFulfillmentSetParameterActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageEventHandlerTriggerFulfillmentSetParameterActionArgs:
    def __init__(__self__, *,
                 parameter: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] parameter: Display name of the parameter.
        :param pulumi.Input[_builtins.str] value: The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        if parameter is not None:
            pulumi.set(__self__, "parameter", parameter)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def parameter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name of the parameter.
        """
        return pulumi.get(self, "parameter")

    @parameter.setter
    def parameter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parameter", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CxPageFormArgsDict(TypedDict):
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterArgsDict']]]]
        """
        Parameters to collect from the user.
        Structure is documented below.
        """
elif False:
    CxPageFormArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormArgs:
    def __init__(__self__, *,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterArgs']]] parameters: Parameters to collect from the user.
               Structure is documented below.
        """
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterArgs']]]]:
        """
        Parameters to collect from the user.
        Structure is documented below.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterArgs']]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class CxPageFormParameterArgsDict(TypedDict):
        advanced_settings: NotRequired[pulumi.Input['CxPageFormParameterAdvancedSettingsArgsDict']]
        """
        Hierarchical advanced settings for this parameter. The settings exposed at the lower level overrides the settings exposed at the higher level.
        Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
        Structure is documented below.
        """
        default_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default value of an optional parameter. If the parameter is required, the default value will be ignored.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The human-readable name of the parameter, unique within the form.
        """
        entity_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The entity type of the parameter.
        Format: projects/-/locations/-/agents/-/entityTypes/<System Entity Type ID> for system entity types (for example, projects/-/locations/-/agents/-/entityTypes/sys.date), or projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/entityTypes/<Entity Type ID> for developer entity types.
        """
        fill_behavior: NotRequired[pulumi.Input['CxPageFormParameterFillBehaviorArgsDict']]
        """
        Defines fill behavior for the parameter.
        Structure is documented below.
        """
        is_list: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the parameter represents a list of values.
        """
        redact: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the parameter content should be redacted in log.
        If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
        """
        required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them.
        Required parameters must be filled before form filling concludes.
        """
elif False:
    CxPageFormParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterArgs:
    def __init__(__self__, *,
                 advanced_settings: Optional[pulumi.Input['CxPageFormParameterAdvancedSettingsArgs']] = None,
                 default_value: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 entity_type: Optional[pulumi.Input[_builtins.str]] = None,
                 fill_behavior: Optional[pulumi.Input['CxPageFormParameterFillBehaviorArgs']] = None,
                 is_list: Optional[pulumi.Input[_builtins.bool]] = None,
                 redact: Optional[pulumi.Input[_builtins.bool]] = None,
                 required: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input['CxPageFormParameterAdvancedSettingsArgs'] advanced_settings: Hierarchical advanced settings for this parameter. The settings exposed at the lower level overrides the settings exposed at the higher level.
               Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] default_value: The default value of an optional parameter. If the parameter is required, the default value will be ignored.
        :param pulumi.Input[_builtins.str] display_name: The human-readable name of the parameter, unique within the form.
        :param pulumi.Input[_builtins.str] entity_type: The entity type of the parameter.
               Format: projects/-/locations/-/agents/-/entityTypes/<System Entity Type ID> for system entity types (for example, projects/-/locations/-/agents/-/entityTypes/sys.date), or projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/entityTypes/<Entity Type ID> for developer entity types.
        :param pulumi.Input['CxPageFormParameterFillBehaviorArgs'] fill_behavior: Defines fill behavior for the parameter.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] is_list: Indicates whether the parameter represents a list of values.
        :param pulumi.Input[_builtins.bool] redact: Indicates whether the parameter content should be redacted in log.
               If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
        :param pulumi.Input[_builtins.bool] required: Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them.
               Required parameters must be filled before form filling concludes.
        """
        if advanced_settings is not None:
            pulumi.set(__self__, "advanced_settings", advanced_settings)
        if default_value is not None:
            pulumi.set(__self__, "default_value", default_value)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if entity_type is not None:
            pulumi.set(__self__, "entity_type", entity_type)
        if fill_behavior is not None:
            pulumi.set(__self__, "fill_behavior", fill_behavior)
        if is_list is not None:
            pulumi.set(__self__, "is_list", is_list)
        if redact is not None:
            pulumi.set(__self__, "redact", redact)
        if required is not None:
            pulumi.set(__self__, "required", required)

    @_builtins.property
    @pulumi.getter(name="advancedSettings")
    def advanced_settings(self) -> Optional[pulumi.Input['CxPageFormParameterAdvancedSettingsArgs']]:
        """
        Hierarchical advanced settings for this parameter. The settings exposed at the lower level overrides the settings exposed at the higher level.
        Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
        Structure is documented below.
        """
        return pulumi.get(self, "advanced_settings")

    @advanced_settings.setter
    def advanced_settings(self, value: Optional[pulumi.Input['CxPageFormParameterAdvancedSettingsArgs']]):
        pulumi.set(self, "advanced_settings", value)

    @_builtins.property
    @pulumi.getter(name="defaultValue")
    def default_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default value of an optional parameter. If the parameter is required, the default value will be ignored.
        """
        return pulumi.get(self, "default_value")

    @default_value.setter
    def default_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_value", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The human-readable name of the parameter, unique within the form.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="entityType")
    def entity_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The entity type of the parameter.
        Format: projects/-/locations/-/agents/-/entityTypes/<System Entity Type ID> for system entity types (for example, projects/-/locations/-/agents/-/entityTypes/sys.date), or projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/entityTypes/<Entity Type ID> for developer entity types.
        """
        return pulumi.get(self, "entity_type")

    @entity_type.setter
    def entity_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entity_type", value)

    @_builtins.property
    @pulumi.getter(name="fillBehavior")
    def fill_behavior(self) -> Optional[pulumi.Input['CxPageFormParameterFillBehaviorArgs']]:
        """
        Defines fill behavior for the parameter.
        Structure is documented below.
        """
        return pulumi.get(self, "fill_behavior")

    @fill_behavior.setter
    def fill_behavior(self, value: Optional[pulumi.Input['CxPageFormParameterFillBehaviorArgs']]):
        pulumi.set(self, "fill_behavior", value)

    @_builtins.property
    @pulumi.getter(name="isList")
    def is_list(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the parameter represents a list of values.
        """
        return pulumi.get(self, "is_list")

    @is_list.setter
    def is_list(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_list", value)

    @_builtins.property
    @pulumi.getter
    def redact(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the parameter content should be redacted in log.
        If redaction is enabled, the parameter content will be replaced by parameter name during logging. Note: the parameter content is subject to redaction if either parameter level redaction or entity type level redaction is enabled.
        """
        return pulumi.get(self, "redact")

    @redact.setter
    def redact(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "redact", value)

    @_builtins.property
    @pulumi.getter
    def required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the parameter is required. Optional parameters will not trigger prompts; however, they are filled if the user specifies them.
        Required parameters must be filled before form filling concludes.
        """
        return pulumi.get(self, "required")

    @required.setter
    def required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "required", value)


if not MYPY:
    class CxPageFormParameterAdvancedSettingsArgsDict(TypedDict):
        dtmf_settings: NotRequired[pulumi.Input['CxPageFormParameterAdvancedSettingsDtmfSettingsArgsDict']]
        """
        Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
elif False:
    CxPageFormParameterAdvancedSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterAdvancedSettingsArgs:
    def __init__(__self__, *,
                 dtmf_settings: Optional[pulumi.Input['CxPageFormParameterAdvancedSettingsDtmfSettingsArgs']] = None):
        """
        :param pulumi.Input['CxPageFormParameterAdvancedSettingsDtmfSettingsArgs'] dtmf_settings: Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
               * Agent level
               * Flow level
               * Page level
               * Parameter level
               Structure is documented below.
        """
        if dtmf_settings is not None:
            pulumi.set(__self__, "dtmf_settings", dtmf_settings)

    @_builtins.property
    @pulumi.getter(name="dtmfSettings")
    def dtmf_settings(self) -> Optional[pulumi.Input['CxPageFormParameterAdvancedSettingsDtmfSettingsArgs']]:
        """
        Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
        return pulumi.get(self, "dtmf_settings")

    @dtmf_settings.setter
    def dtmf_settings(self, value: Optional[pulumi.Input['CxPageFormParameterAdvancedSettingsDtmfSettingsArgs']]):
        pulumi.set(self, "dtmf_settings", value)


if not MYPY:
    class CxPageFormParameterAdvancedSettingsDtmfSettingsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        """
        finish_digit: NotRequired[pulumi.Input[_builtins.str]]
        """
        The digit that terminates a DTMF digit sequence.
        """
        max_digits: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max length of DTMF digits.
        """
elif False:
    CxPageFormParameterAdvancedSettingsDtmfSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterAdvancedSettingsDtmfSettingsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 finish_digit: Optional[pulumi.Input[_builtins.str]] = None,
                 max_digits: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        :param pulumi.Input[_builtins.str] finish_digit: The digit that terminates a DTMF digit sequence.
        :param pulumi.Input[_builtins.int] max_digits: Max length of DTMF digits.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if finish_digit is not None:
            pulumi.set(__self__, "finish_digit", finish_digit)
        if max_digits is not None:
            pulumi.set(__self__, "max_digits", max_digits)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="finishDigit")
    def finish_digit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The digit that terminates a DTMF digit sequence.
        """
        return pulumi.get(self, "finish_digit")

    @finish_digit.setter
    def finish_digit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "finish_digit", value)

    @_builtins.property
    @pulumi.getter(name="maxDigits")
    def max_digits(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max length of DTMF digits.
        """
        return pulumi.get(self, "max_digits")

    @max_digits.setter
    def max_digits(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_digits", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorArgsDict(TypedDict):
        initial_prompt_fulfillment: NotRequired[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentArgsDict']]
        """
        The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
        Structure is documented below.
        """
        reprompt_event_handlers: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerArgsDict']]]]
        """
        The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are:
        * sys.no-match-<N>, where N can be from 1 to 6
        * sys.no-match-default
        * sys.no-input-<N>, where N can be from 1 to 6
        * sys.no-input-default
        * sys.invalid-parameter
        [initialPromptFulfillment][initialPromptFulfillment] provides the first prompt for the parameter.
        If the user's response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the sys.no-match-1/sys.no-input-1 handler (if defined) will be called to provide a prompt. The sys.no-match-2/sys.no-input-2 handler (if defined) will respond to the next no-match/no-input event, and so on.
        A sys.no-match-default or sys.no-input-default handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed.
        A sys.invalid-parameter handler can be defined to handle the case where the parameter values have been invalidated by webhook. For example, if the user's response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the sys.invalid-parameter handler (if defined) will be called to provide a prompt.
        If the event handler for the corresponding event can't be found on the parameter, initialPromptFulfillment will be re-prompted.
        Structure is documented below.
        """
elif False:
    CxPageFormParameterFillBehaviorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorArgs:
    def __init__(__self__, *,
                 initial_prompt_fulfillment: Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentArgs']] = None,
                 reprompt_event_handlers: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerArgs']]]] = None):
        """
        :param pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentArgs'] initial_prompt_fulfillment: The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerArgs']]] reprompt_event_handlers: The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are:
               * sys.no-match-<N>, where N can be from 1 to 6
               * sys.no-match-default
               * sys.no-input-<N>, where N can be from 1 to 6
               * sys.no-input-default
               * sys.invalid-parameter
               [initialPromptFulfillment][initialPromptFulfillment] provides the first prompt for the parameter.
               If the user's response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the sys.no-match-1/sys.no-input-1 handler (if defined) will be called to provide a prompt. The sys.no-match-2/sys.no-input-2 handler (if defined) will respond to the next no-match/no-input event, and so on.
               A sys.no-match-default or sys.no-input-default handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed.
               A sys.invalid-parameter handler can be defined to handle the case where the parameter values have been invalidated by webhook. For example, if the user's response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the sys.invalid-parameter handler (if defined) will be called to provide a prompt.
               If the event handler for the corresponding event can't be found on the parameter, initialPromptFulfillment will be re-prompted.
               Structure is documented below.
        """
        if initial_prompt_fulfillment is not None:
            pulumi.set(__self__, "initial_prompt_fulfillment", initial_prompt_fulfillment)
        if reprompt_event_handlers is not None:
            pulumi.set(__self__, "reprompt_event_handlers", reprompt_event_handlers)

    @_builtins.property
    @pulumi.getter(name="initialPromptFulfillment")
    def initial_prompt_fulfillment(self) -> Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentArgs']]:
        """
        The fulfillment to provide the initial prompt that the agent can present to the user in order to fill the parameter.
        Structure is documented below.
        """
        return pulumi.get(self, "initial_prompt_fulfillment")

    @initial_prompt_fulfillment.setter
    def initial_prompt_fulfillment(self, value: Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentArgs']]):
        pulumi.set(self, "initial_prompt_fulfillment", value)

    @_builtins.property
    @pulumi.getter(name="repromptEventHandlers")
    def reprompt_event_handlers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerArgs']]]]:
        """
        The handlers for parameter-level events, used to provide reprompt for the parameter or transition to a different page/flow. The supported events are:
        * sys.no-match-<N>, where N can be from 1 to 6
        * sys.no-match-default
        * sys.no-input-<N>, where N can be from 1 to 6
        * sys.no-input-default
        * sys.invalid-parameter
        [initialPromptFulfillment][initialPromptFulfillment] provides the first prompt for the parameter.
        If the user's response does not fill the parameter, a no-match/no-input event will be triggered, and the fulfillment associated with the sys.no-match-1/sys.no-input-1 handler (if defined) will be called to provide a prompt. The sys.no-match-2/sys.no-input-2 handler (if defined) will respond to the next no-match/no-input event, and so on.
        A sys.no-match-default or sys.no-input-default handler will be used to handle all following no-match/no-input events after all numbered no-match/no-input handlers for the parameter are consumed.
        A sys.invalid-parameter handler can be defined to handle the case where the parameter values have been invalidated by webhook. For example, if the user's response fill the parameter, however the parameter was invalidated by webhook, the fulfillment associated with the sys.invalid-parameter handler (if defined) will be called to provide a prompt.
        If the event handler for the corresponding event can't be found on the parameter, initialPromptFulfillment will be re-prompted.
        Structure is documented below.
        """
        return pulumi.get(self, "reprompt_event_handlers")

    @reprompt_event_handlers.setter
    def reprompt_event_handlers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerArgs']]]]):
        pulumi.set(self, "reprompt_event_handlers", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorInitialPromptFulfillmentArgsDict(TypedDict):
        conditional_cases: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentConditionalCaseArgsDict']]]]
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        messages: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageArgsDict']]]]
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return_partial_responses: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        set_parameter_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentSetParameterActionArgsDict']]]]
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        webhook: NotRequired[pulumi.Input[_builtins.str]]
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
elif False:
    CxPageFormParameterFillBehaviorInitialPromptFulfillmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillmentArgs:
    def __init__(__self__, *,
                 conditional_cases: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentConditionalCaseArgs']]]] = None,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageArgs']]]] = None,
                 return_partial_responses: Optional[pulumi.Input[_builtins.bool]] = None,
                 set_parameter_actions: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentSetParameterActionArgs']]]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None,
                 webhook: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentConditionalCaseArgs']]] conditional_cases: Conditional cases for this fulfillment.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageArgs']]] messages: The list of rich message responses to present to the user.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] return_partial_responses: Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        :param pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentSetParameterActionArgs']]] set_parameter_actions: Set parameter values before executing the webhook.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] tag: The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        :param pulumi.Input[_builtins.str] webhook: The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        if conditional_cases is not None:
            pulumi.set(__self__, "conditional_cases", conditional_cases)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if return_partial_responses is not None:
            pulumi.set(__self__, "return_partial_responses", return_partial_responses)
        if set_parameter_actions is not None:
            pulumi.set(__self__, "set_parameter_actions", set_parameter_actions)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @_builtins.property
    @pulumi.getter(name="conditionalCases")
    def conditional_cases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentConditionalCaseArgs']]]]:
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        return pulumi.get(self, "conditional_cases")

    @conditional_cases.setter
    def conditional_cases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentConditionalCaseArgs']]]]):
        pulumi.set(self, "conditional_cases", value)

    @_builtins.property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageArgs']]]]:
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageArgs']]]]):
        pulumi.set(self, "messages", value)

    @_builtins.property
    @pulumi.getter(name="returnPartialResponses")
    def return_partial_responses(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        return pulumi.get(self, "return_partial_responses")

    @return_partial_responses.setter
    def return_partial_responses(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "return_partial_responses", value)

    @_builtins.property
    @pulumi.getter(name="setParameterActions")
    def set_parameter_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentSetParameterActionArgs']]]]:
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        return pulumi.get(self, "set_parameter_actions")

    @set_parameter_actions.setter
    def set_parameter_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentSetParameterActionArgs']]]]):
        pulumi.set(self, "set_parameter_actions", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def webhook(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        return pulumi.get(self, "webhook")

    @webhook.setter
    def webhook(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "webhook", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorInitialPromptFulfillmentConditionalCaseArgsDict(TypedDict):
        cases: NotRequired[pulumi.Input[_builtins.str]]
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
elif False:
    CxPageFormParameterFillBehaviorInitialPromptFulfillmentConditionalCaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillmentConditionalCaseArgs:
    def __init__(__self__, *,
                 cases: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cases: A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
               See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        if cases is not None:
            pulumi.set(__self__, "cases", cases)

    @_builtins.property
    @pulumi.getter
    def cases(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        return pulumi.get(self, "cases")

    @cases.setter
    def cases(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cases", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageArgsDict(TypedDict):
        channel: NotRequired[pulumi.Input[_builtins.str]]
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        conversation_success: NotRequired[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageConversationSuccessArgsDict']]
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        live_agent_handoff: NotRequired[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageLiveAgentHandoffArgsDict']]
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        output_audio_text: NotRequired[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioTextArgsDict']]
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        Returns a response containing a custom, platform-specific payload.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        play_audio: NotRequired[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudioArgsDict']]
        """
        Specifies an audio clip to be played by the client as part of the response.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        telephony_transfer_call: NotRequired[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCallArgsDict']]
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        text: NotRequired[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTextArgsDict']]
        """
        The text response message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
elif False:
    CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageArgs:
    def __init__(__self__, *,
                 channel: Optional[pulumi.Input[_builtins.str]] = None,
                 conversation_success: Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageConversationSuccessArgs']] = None,
                 live_agent_handoff: Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageLiveAgentHandoffArgs']] = None,
                 output_audio_text: Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioTextArgs']] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 play_audio: Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudioArgs']] = None,
                 telephony_transfer_call: Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCallArgs']] = None,
                 text: Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTextArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] channel: The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        :param pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageConversationSuccessArgs'] conversation_success: Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
               Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
               * In a webhook response when you determine that you handled the customer issue.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageLiveAgentHandoffArgs'] live_agent_handoff: Indicates that the conversation should be handed off to a live agent.
               Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
               * In a webhook response when you determine that the customer issue can only be handled by a human.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioTextArgs'] output_audio_text: A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] payload: Returns a response containing a custom, platform-specific payload.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        :param pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudioArgs'] play_audio: Specifies an audio clip to be played by the client as part of the response.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCallArgs'] telephony_transfer_call: Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTextArgs'] text: The text response message.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if conversation_success is not None:
            pulumi.set(__self__, "conversation_success", conversation_success)
        if live_agent_handoff is not None:
            pulumi.set(__self__, "live_agent_handoff", live_agent_handoff)
        if output_audio_text is not None:
            pulumi.set(__self__, "output_audio_text", output_audio_text)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if play_audio is not None:
            pulumi.set(__self__, "play_audio", play_audio)
        if telephony_transfer_call is not None:
            pulumi.set(__self__, "telephony_transfer_call", telephony_transfer_call)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter(name="conversationSuccess")
    def conversation_success(self) -> Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageConversationSuccessArgs']]:
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_success")

    @conversation_success.setter
    def conversation_success(self, value: Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageConversationSuccessArgs']]):
        pulumi.set(self, "conversation_success", value)

    @_builtins.property
    @pulumi.getter(name="liveAgentHandoff")
    def live_agent_handoff(self) -> Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageLiveAgentHandoffArgs']]:
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "live_agent_handoff")

    @live_agent_handoff.setter
    def live_agent_handoff(self, value: Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageLiveAgentHandoffArgs']]):
        pulumi.set(self, "live_agent_handoff", value)

    @_builtins.property
    @pulumi.getter(name="outputAudioText")
    def output_audio_text(self) -> Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioTextArgs']]:
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "output_audio_text")

    @output_audio_text.setter
    def output_audio_text(self, value: Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioTextArgs']]):
        pulumi.set(self, "output_audio_text", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Returns a response containing a custom, platform-specific payload.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="playAudio")
    def play_audio(self) -> Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudioArgs']]:
        """
        Specifies an audio clip to be played by the client as part of the response.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "play_audio")

    @play_audio.setter
    def play_audio(self, value: Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudioArgs']]):
        pulumi.set(self, "play_audio", value)

    @_builtins.property
    @pulumi.getter(name="telephonyTransferCall")
    def telephony_transfer_call(self) -> Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCallArgs']]:
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "telephony_transfer_call")

    @telephony_transfer_call.setter
    def telephony_transfer_call(self, value: Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCallArgs']]):
        pulumi.set(self, "telephony_transfer_call", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTextArgs']]:
        """
        The text response message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageConversationSuccessArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
elif False:
    CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageConversationSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageConversationSuccessArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageLiveAgentHandoffArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
elif False:
    CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageLiveAgentHandoffArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageLiveAgentHandoffArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioTextArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        ssml: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SSML text to be synthesized. For more information, see SSML.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The raw text to be synthesized.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
elif False:
    CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageOutputAudioTextArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 ssml: Optional[pulumi.Input[_builtins.str]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param pulumi.Input[_builtins.str] ssml: The SSML text to be synthesized. For more information, see SSML.
               This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        :param pulumi.Input[_builtins.str] text: The raw text to be synthesized.
               This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if ssml is not None:
            pulumi.set(__self__, "ssml", ssml)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def ssml(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SSML text to be synthesized. For more information, see SSML.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        return pulumi.get(self, "ssml")

    @ssml.setter
    def ssml(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssml", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The raw text to be synthesized.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudioArgsDict(TypedDict):
        audio_uri: pulumi.Input[_builtins.str]
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.

        <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
elif False:
    CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessagePlayAudioArgs:
    def __init__(__self__, *,
                 audio_uri: pulumi.Input[_builtins.str],
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] audio_uri: URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
               
               <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
        pulumi.set(__self__, "audio_uri", audio_uri)
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)

    @_builtins.property
    @pulumi.getter(name="audioUri")
    def audio_uri(self) -> pulumi.Input[_builtins.str]:
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        return pulumi.get(self, "audio_uri")

    @audio_uri.setter
    def audio_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "audio_uri", value)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.

        <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCallArgsDict(TypedDict):
        phone_number: pulumi.Input[_builtins.str]
        """
        Transfer the call to a phone number in E.164 format.
        """
elif False:
    CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTelephonyTransferCallArgs:
    def __init__(__self__, *,
                 phone_number: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] phone_number: Transfer the call to a phone number in E.164 format.
        """
        pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> pulumi.Input[_builtins.str]:
        """
        Transfer the call to a phone number in E.164 format.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTextArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        texts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
        required: true
        """
elif False:
    CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillmentMessageTextArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 texts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] texts: A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
               required: true
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def texts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
        required: true
        """
        return pulumi.get(self, "texts")

    @texts.setter
    def texts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "texts", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorInitialPromptFulfillmentSetParameterActionArgsDict(TypedDict):
        parameter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name of the parameter.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
elif False:
    CxPageFormParameterFillBehaviorInitialPromptFulfillmentSetParameterActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorInitialPromptFulfillmentSetParameterActionArgs:
    def __init__(__self__, *,
                 parameter: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] parameter: Display name of the parameter.
        :param pulumi.Input[_builtins.str] value: The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        if parameter is not None:
            pulumi.set(__self__, "parameter", parameter)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def parameter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name of the parameter.
        """
        return pulumi.get(self, "parameter")

    @parameter.setter
    def parameter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parameter", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorRepromptEventHandlerArgsDict(TypedDict):
        event: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the event to handle.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The unique identifier of this event handler.
        """
        target_flow: NotRequired[pulumi.Input[_builtins.str]]
        """
        The target flow to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        """
        target_page: NotRequired[pulumi.Input[_builtins.str]]
        """
        The target page to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        trigger_fulfillment: NotRequired[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentArgsDict']]
        """
        The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
        Structure is documented below.
        """
elif False:
    CxPageFormParameterFillBehaviorRepromptEventHandlerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerArgs:
    def __init__(__self__, *,
                 event: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 target_flow: Optional[pulumi.Input[_builtins.str]] = None,
                 target_page: Optional[pulumi.Input[_builtins.str]] = None,
                 trigger_fulfillment: Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] event: The name of the event to handle.
        :param pulumi.Input[_builtins.str] name: (Output)
               The unique identifier of this event handler.
        :param pulumi.Input[_builtins.str] target_flow: The target flow to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        :param pulumi.Input[_builtins.str] target_page: The target page to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        :param pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentArgs'] trigger_fulfillment: The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
               Structure is documented below.
        """
        if event is not None:
            pulumi.set(__self__, "event", event)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target_flow is not None:
            pulumi.set(__self__, "target_flow", target_flow)
        if target_page is not None:
            pulumi.set(__self__, "target_page", target_page)
        if trigger_fulfillment is not None:
            pulumi.set(__self__, "trigger_fulfillment", trigger_fulfillment)

    @_builtins.property
    @pulumi.getter
    def event(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the event to handle.
        """
        return pulumi.get(self, "event")

    @event.setter
    def event(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The unique identifier of this event handler.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="targetFlow")
    def target_flow(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The target flow to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        """
        return pulumi.get(self, "target_flow")

    @target_flow.setter
    def target_flow(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_flow", value)

    @_builtins.property
    @pulumi.getter(name="targetPage")
    def target_page(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The target page to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        return pulumi.get(self, "target_page")

    @target_page.setter
    def target_page(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_page", value)

    @_builtins.property
    @pulumi.getter(name="triggerFulfillment")
    def trigger_fulfillment(self) -> Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentArgs']]:
        """
        The fulfillment to call when the event occurs. Handling webhook errors with a fulfillment enabled with webhook could cause infinite loop. It is invalid to specify such fulfillment for a handler handling webhooks.
        Structure is documented below.
        """
        return pulumi.get(self, "trigger_fulfillment")

    @trigger_fulfillment.setter
    def trigger_fulfillment(self, value: Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentArgs']]):
        pulumi.set(self, "trigger_fulfillment", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentArgsDict(TypedDict):
        conditional_cases: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentConditionalCaseArgsDict']]]]
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        messages: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageArgsDict']]]]
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return_partial_responses: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        set_parameter_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentSetParameterActionArgsDict']]]]
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        webhook: NotRequired[pulumi.Input[_builtins.str]]
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
elif False:
    CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentArgs:
    def __init__(__self__, *,
                 conditional_cases: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentConditionalCaseArgs']]]] = None,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageArgs']]]] = None,
                 return_partial_responses: Optional[pulumi.Input[_builtins.bool]] = None,
                 set_parameter_actions: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentSetParameterActionArgs']]]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None,
                 webhook: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentConditionalCaseArgs']]] conditional_cases: Conditional cases for this fulfillment.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageArgs']]] messages: The list of rich message responses to present to the user.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] return_partial_responses: Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        :param pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentSetParameterActionArgs']]] set_parameter_actions: Set parameter values before executing the webhook.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] tag: The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        :param pulumi.Input[_builtins.str] webhook: The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        if conditional_cases is not None:
            pulumi.set(__self__, "conditional_cases", conditional_cases)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if return_partial_responses is not None:
            pulumi.set(__self__, "return_partial_responses", return_partial_responses)
        if set_parameter_actions is not None:
            pulumi.set(__self__, "set_parameter_actions", set_parameter_actions)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @_builtins.property
    @pulumi.getter(name="conditionalCases")
    def conditional_cases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentConditionalCaseArgs']]]]:
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        return pulumi.get(self, "conditional_cases")

    @conditional_cases.setter
    def conditional_cases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentConditionalCaseArgs']]]]):
        pulumi.set(self, "conditional_cases", value)

    @_builtins.property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageArgs']]]]:
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageArgs']]]]):
        pulumi.set(self, "messages", value)

    @_builtins.property
    @pulumi.getter(name="returnPartialResponses")
    def return_partial_responses(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        return pulumi.get(self, "return_partial_responses")

    @return_partial_responses.setter
    def return_partial_responses(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "return_partial_responses", value)

    @_builtins.property
    @pulumi.getter(name="setParameterActions")
    def set_parameter_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentSetParameterActionArgs']]]]:
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        return pulumi.get(self, "set_parameter_actions")

    @set_parameter_actions.setter
    def set_parameter_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentSetParameterActionArgs']]]]):
        pulumi.set(self, "set_parameter_actions", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def webhook(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        return pulumi.get(self, "webhook")

    @webhook.setter
    def webhook(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "webhook", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentConditionalCaseArgsDict(TypedDict):
        cases: NotRequired[pulumi.Input[_builtins.str]]
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
elif False:
    CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentConditionalCaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentConditionalCaseArgs:
    def __init__(__self__, *,
                 cases: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cases: A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
               See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        if cases is not None:
            pulumi.set(__self__, "cases", cases)

    @_builtins.property
    @pulumi.getter
    def cases(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        return pulumi.get(self, "cases")

    @cases.setter
    def cases(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cases", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageArgsDict(TypedDict):
        channel: NotRequired[pulumi.Input[_builtins.str]]
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        conversation_success: NotRequired[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageConversationSuccessArgsDict']]
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        live_agent_handoff: NotRequired[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgsDict']]
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        output_audio_text: NotRequired[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioTextArgsDict']]
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        Returns a response containing a custom, platform-specific payload.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        play_audio: NotRequired[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudioArgsDict']]
        """
        Specifies an audio clip to be played by the client as part of the response.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        telephony_transfer_call: NotRequired[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgsDict']]
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        text: NotRequired[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTextArgsDict']]
        """
        The text response message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
elif False:
    CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageArgs:
    def __init__(__self__, *,
                 channel: Optional[pulumi.Input[_builtins.str]] = None,
                 conversation_success: Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageConversationSuccessArgs']] = None,
                 live_agent_handoff: Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs']] = None,
                 output_audio_text: Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs']] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 play_audio: Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudioArgs']] = None,
                 telephony_transfer_call: Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs']] = None,
                 text: Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTextArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] channel: The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        :param pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageConversationSuccessArgs'] conversation_success: Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
               Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
               * In a webhook response when you determine that you handled the customer issue.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs'] live_agent_handoff: Indicates that the conversation should be handed off to a live agent.
               Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
               * In a webhook response when you determine that the customer issue can only be handled by a human.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs'] output_audio_text: A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] payload: Returns a response containing a custom, platform-specific payload.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        :param pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudioArgs'] play_audio: Specifies an audio clip to be played by the client as part of the response.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs'] telephony_transfer_call: Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTextArgs'] text: The text response message.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if conversation_success is not None:
            pulumi.set(__self__, "conversation_success", conversation_success)
        if live_agent_handoff is not None:
            pulumi.set(__self__, "live_agent_handoff", live_agent_handoff)
        if output_audio_text is not None:
            pulumi.set(__self__, "output_audio_text", output_audio_text)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if play_audio is not None:
            pulumi.set(__self__, "play_audio", play_audio)
        if telephony_transfer_call is not None:
            pulumi.set(__self__, "telephony_transfer_call", telephony_transfer_call)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter(name="conversationSuccess")
    def conversation_success(self) -> Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageConversationSuccessArgs']]:
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_success")

    @conversation_success.setter
    def conversation_success(self, value: Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageConversationSuccessArgs']]):
        pulumi.set(self, "conversation_success", value)

    @_builtins.property
    @pulumi.getter(name="liveAgentHandoff")
    def live_agent_handoff(self) -> Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs']]:
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "live_agent_handoff")

    @live_agent_handoff.setter
    def live_agent_handoff(self, value: Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs']]):
        pulumi.set(self, "live_agent_handoff", value)

    @_builtins.property
    @pulumi.getter(name="outputAudioText")
    def output_audio_text(self) -> Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs']]:
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "output_audio_text")

    @output_audio_text.setter
    def output_audio_text(self, value: Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs']]):
        pulumi.set(self, "output_audio_text", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Returns a response containing a custom, platform-specific payload.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="playAudio")
    def play_audio(self) -> Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudioArgs']]:
        """
        Specifies an audio clip to be played by the client as part of the response.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "play_audio")

    @play_audio.setter
    def play_audio(self, value: Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudioArgs']]):
        pulumi.set(self, "play_audio", value)

    @_builtins.property
    @pulumi.getter(name="telephonyTransferCall")
    def telephony_transfer_call(self) -> Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs']]:
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "telephony_transfer_call")

    @telephony_transfer_call.setter
    def telephony_transfer_call(self, value: Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs']]):
        pulumi.set(self, "telephony_transfer_call", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTextArgs']]:
        """
        The text response message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageConversationSuccessArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
elif False:
    CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageConversationSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageConversationSuccessArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
elif False:
    CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageLiveAgentHandoffArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioTextArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        ssml: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SSML text to be synthesized. For more information, see SSML.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The raw text to be synthesized.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
elif False:
    CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageOutputAudioTextArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 ssml: Optional[pulumi.Input[_builtins.str]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param pulumi.Input[_builtins.str] ssml: The SSML text to be synthesized. For more information, see SSML.
               This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        :param pulumi.Input[_builtins.str] text: The raw text to be synthesized.
               This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if ssml is not None:
            pulumi.set(__self__, "ssml", ssml)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def ssml(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SSML text to be synthesized. For more information, see SSML.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        return pulumi.get(self, "ssml")

    @ssml.setter
    def ssml(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssml", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The raw text to be synthesized.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudioArgsDict(TypedDict):
        audio_uri: pulumi.Input[_builtins.str]
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.

        <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
elif False:
    CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessagePlayAudioArgs:
    def __init__(__self__, *,
                 audio_uri: pulumi.Input[_builtins.str],
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] audio_uri: URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
               
               <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
        pulumi.set(__self__, "audio_uri", audio_uri)
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)

    @_builtins.property
    @pulumi.getter(name="audioUri")
    def audio_uri(self) -> pulumi.Input[_builtins.str]:
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        return pulumi.get(self, "audio_uri")

    @audio_uri.setter
    def audio_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "audio_uri", value)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.

        <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgsDict(TypedDict):
        phone_number: pulumi.Input[_builtins.str]
        """
        Transfer the call to a phone number in E.164 format.
        """
elif False:
    CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTelephonyTransferCallArgs:
    def __init__(__self__, *,
                 phone_number: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] phone_number: Transfer the call to a phone number in E.164 format.
        """
        pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> pulumi.Input[_builtins.str]:
        """
        Transfer the call to a phone number in E.164 format.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTextArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        texts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
        required: true
        """
elif False:
    CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentMessageTextArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 texts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] texts: A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
               required: true
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def texts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
        required: true
        """
        return pulumi.get(self, "texts")

    @texts.setter
    def texts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "texts", value)


if not MYPY:
    class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentSetParameterActionArgsDict(TypedDict):
        parameter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name of the parameter.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
elif False:
    CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentSetParameterActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageFormParameterFillBehaviorRepromptEventHandlerTriggerFulfillmentSetParameterActionArgs:
    def __init__(__self__, *,
                 parameter: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] parameter: Display name of the parameter.
        :param pulumi.Input[_builtins.str] value: The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        if parameter is not None:
            pulumi.set(__self__, "parameter", parameter)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def parameter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name of the parameter.
        """
        return pulumi.get(self, "parameter")

    @parameter.setter
    def parameter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parameter", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CxPageKnowledgeConnectorSettingsArgsDict(TypedDict):
        data_store_connections: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsDataStoreConnectionArgsDict']]]]
        """
        Optional. List of related data store connections.
        Structure is documented below.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Knowledge Connector is enabled or not.
        """
        target_flow: NotRequired[pulumi.Input[_builtins.str]]
        """
        The target flow to transition to. Format: projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>.
        This field is part of a union field `target`: Only one of `targetPage` or `targetFlow` may be set.
        """
        target_page: NotRequired[pulumi.Input[_builtins.str]]
        """
        The target page to transition to. Format: projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/pages/<PageID>.
        The page must be in the same host flow (the flow that owns this `KnowledgeConnectorSettings`).
        This field is part of a union field `target`: Only one of `targetPage` or `targetFlow` may be set.
        """
        trigger_fulfillment: NotRequired[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentArgsDict']]
        """
        The fulfillment to be triggered.
        When the answers from the Knowledge Connector are selected by Dialogflow, you can utitlize the request scoped parameter $request.knowledge.answers (contains up to the 5 highest confidence answers) and $request.knowledge.questions (contains the corresponding questions) to construct the fulfillment.
        Structure is documented below.
        """
elif False:
    CxPageKnowledgeConnectorSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsArgs:
    def __init__(__self__, *,
                 data_store_connections: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsDataStoreConnectionArgs']]]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 target_flow: Optional[pulumi.Input[_builtins.str]] = None,
                 target_page: Optional[pulumi.Input[_builtins.str]] = None,
                 trigger_fulfillment: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsDataStoreConnectionArgs']]] data_store_connections: Optional. List of related data store connections.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] enabled: Whether Knowledge Connector is enabled or not.
        :param pulumi.Input[_builtins.str] target_flow: The target flow to transition to. Format: projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>.
               This field is part of a union field `target`: Only one of `targetPage` or `targetFlow` may be set.
        :param pulumi.Input[_builtins.str] target_page: The target page to transition to. Format: projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/pages/<PageID>.
               The page must be in the same host flow (the flow that owns this `KnowledgeConnectorSettings`).
               This field is part of a union field `target`: Only one of `targetPage` or `targetFlow` may be set.
        :param pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentArgs'] trigger_fulfillment: The fulfillment to be triggered.
               When the answers from the Knowledge Connector are selected by Dialogflow, you can utitlize the request scoped parameter $request.knowledge.answers (contains up to the 5 highest confidence answers) and $request.knowledge.questions (contains the corresponding questions) to construct the fulfillment.
               Structure is documented below.
        """
        if data_store_connections is not None:
            pulumi.set(__self__, "data_store_connections", data_store_connections)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if target_flow is not None:
            pulumi.set(__self__, "target_flow", target_flow)
        if target_page is not None:
            pulumi.set(__self__, "target_page", target_page)
        if trigger_fulfillment is not None:
            pulumi.set(__self__, "trigger_fulfillment", trigger_fulfillment)

    @_builtins.property
    @pulumi.getter(name="dataStoreConnections")
    def data_store_connections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsDataStoreConnectionArgs']]]]:
        """
        Optional. List of related data store connections.
        Structure is documented below.
        """
        return pulumi.get(self, "data_store_connections")

    @data_store_connections.setter
    def data_store_connections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsDataStoreConnectionArgs']]]]):
        pulumi.set(self, "data_store_connections", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Knowledge Connector is enabled or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="targetFlow")
    def target_flow(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The target flow to transition to. Format: projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>.
        This field is part of a union field `target`: Only one of `targetPage` or `targetFlow` may be set.
        """
        return pulumi.get(self, "target_flow")

    @target_flow.setter
    def target_flow(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_flow", value)

    @_builtins.property
    @pulumi.getter(name="targetPage")
    def target_page(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The target page to transition to. Format: projects/<ProjectID>/locations/<LocationID>/agents/<AgentID>/flows/<FlowID>/pages/<PageID>.
        The page must be in the same host flow (the flow that owns this `KnowledgeConnectorSettings`).
        This field is part of a union field `target`: Only one of `targetPage` or `targetFlow` may be set.
        """
        return pulumi.get(self, "target_page")

    @target_page.setter
    def target_page(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_page", value)

    @_builtins.property
    @pulumi.getter(name="triggerFulfillment")
    def trigger_fulfillment(self) -> Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentArgs']]:
        """
        The fulfillment to be triggered.
        When the answers from the Knowledge Connector are selected by Dialogflow, you can utitlize the request scoped parameter $request.knowledge.answers (contains up to the 5 highest confidence answers) and $request.knowledge.questions (contains the corresponding questions) to construct the fulfillment.
        Structure is documented below.
        """
        return pulumi.get(self, "trigger_fulfillment")

    @trigger_fulfillment.setter
    def trigger_fulfillment(self, value: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentArgs']]):
        pulumi.set(self, "trigger_fulfillment", value)


if not MYPY:
    class CxPageKnowledgeConnectorSettingsDataStoreConnectionArgsDict(TypedDict):
        data_store: NotRequired[pulumi.Input[_builtins.str]]
        """
        The full name of the referenced data store. Formats: projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore} projects/{project}/locations/{location}/dataStores/{dataStore}
        """
        data_store_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the connected data store.
        * PUBLIC_WEB: A data store that contains public web content.
        * UNSTRUCTURED: A data store that contains unstructured private data.
        * STRUCTURED: A data store that contains structured data (for example FAQ).
        Possible values are: `PUBLIC_WEB`, `UNSTRUCTURED`, `STRUCTURED`.
        """
        document_processing_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The document processing mode for the data store connection. Should only be set for PUBLIC_WEB and UNSTRUCTURED data stores. If not set it is considered as DOCUMENTS, as this is the legacy mode.
        * DOCUMENTS: Documents are processed as documents.
        * CHUNKS: Documents are converted to chunks.
        Possible values are: `DOCUMENTS`, `CHUNKS`.
        """
elif False:
    CxPageKnowledgeConnectorSettingsDataStoreConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsDataStoreConnectionArgs:
    def __init__(__self__, *,
                 data_store: Optional[pulumi.Input[_builtins.str]] = None,
                 data_store_type: Optional[pulumi.Input[_builtins.str]] = None,
                 document_processing_mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] data_store: The full name of the referenced data store. Formats: projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore} projects/{project}/locations/{location}/dataStores/{dataStore}
        :param pulumi.Input[_builtins.str] data_store_type: The type of the connected data store.
               * PUBLIC_WEB: A data store that contains public web content.
               * UNSTRUCTURED: A data store that contains unstructured private data.
               * STRUCTURED: A data store that contains structured data (for example FAQ).
               Possible values are: `PUBLIC_WEB`, `UNSTRUCTURED`, `STRUCTURED`.
        :param pulumi.Input[_builtins.str] document_processing_mode: The document processing mode for the data store connection. Should only be set for PUBLIC_WEB and UNSTRUCTURED data stores. If not set it is considered as DOCUMENTS, as this is the legacy mode.
               * DOCUMENTS: Documents are processed as documents.
               * CHUNKS: Documents are converted to chunks.
               Possible values are: `DOCUMENTS`, `CHUNKS`.
        """
        if data_store is not None:
            pulumi.set(__self__, "data_store", data_store)
        if data_store_type is not None:
            pulumi.set(__self__, "data_store_type", data_store_type)
        if document_processing_mode is not None:
            pulumi.set(__self__, "document_processing_mode", document_processing_mode)

    @_builtins.property
    @pulumi.getter(name="dataStore")
    def data_store(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The full name of the referenced data store. Formats: projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore} projects/{project}/locations/{location}/dataStores/{dataStore}
        """
        return pulumi.get(self, "data_store")

    @data_store.setter
    def data_store(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_store", value)

    @_builtins.property
    @pulumi.getter(name="dataStoreType")
    def data_store_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the connected data store.
        * PUBLIC_WEB: A data store that contains public web content.
        * UNSTRUCTURED: A data store that contains unstructured private data.
        * STRUCTURED: A data store that contains structured data (for example FAQ).
        Possible values are: `PUBLIC_WEB`, `UNSTRUCTURED`, `STRUCTURED`.
        """
        return pulumi.get(self, "data_store_type")

    @data_store_type.setter
    def data_store_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_store_type", value)

    @_builtins.property
    @pulumi.getter(name="documentProcessingMode")
    def document_processing_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The document processing mode for the data store connection. Should only be set for PUBLIC_WEB and UNSTRUCTURED data stores. If not set it is considered as DOCUMENTS, as this is the legacy mode.
        * DOCUMENTS: Documents are processed as documents.
        * CHUNKS: Documents are converted to chunks.
        Possible values are: `DOCUMENTS`, `CHUNKS`.
        """
        return pulumi.get(self, "document_processing_mode")

    @document_processing_mode.setter
    def document_processing_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "document_processing_mode", value)


if not MYPY:
    class CxPageKnowledgeConnectorSettingsTriggerFulfillmentArgsDict(TypedDict):
        advanced_settings: NotRequired[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgsDict']]
        """
        Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playbackInterruptionSettings at fulfillment level only overrides the playbackInterruptionSettings at the agent level, leaving other settings at the agent level unchanged.
        DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel.
        Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
        Structure is documented below.
        """
        conditional_cases: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgsDict']]]]
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        enable_generative_fallback: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
        """
        messages: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageArgsDict']]]]
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return_partial_responses: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        set_parameter_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgsDict']]]]
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        webhook: NotRequired[pulumi.Input[_builtins.str]]
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
elif False:
    CxPageKnowledgeConnectorSettingsTriggerFulfillmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsTriggerFulfillmentArgs:
    def __init__(__self__, *,
                 advanced_settings: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgs']] = None,
                 conditional_cases: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgs']]]] = None,
                 enable_generative_fallback: Optional[pulumi.Input[_builtins.bool]] = None,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageArgs']]]] = None,
                 return_partial_responses: Optional[pulumi.Input[_builtins.bool]] = None,
                 set_parameter_actions: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgs']]]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None,
                 webhook: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgs'] advanced_settings: Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playbackInterruptionSettings at fulfillment level only overrides the playbackInterruptionSettings at the agent level, leaving other settings at the agent level unchanged.
               DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel.
               Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgs']]] conditional_cases: Conditional cases for this fulfillment.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] enable_generative_fallback: If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
        :param pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageArgs']]] messages: The list of rich message responses to present to the user.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] return_partial_responses: Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        :param pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgs']]] set_parameter_actions: Set parameter values before executing the webhook.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] tag: The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        :param pulumi.Input[_builtins.str] webhook: The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        if advanced_settings is not None:
            pulumi.set(__self__, "advanced_settings", advanced_settings)
        if conditional_cases is not None:
            pulumi.set(__self__, "conditional_cases", conditional_cases)
        if enable_generative_fallback is not None:
            pulumi.set(__self__, "enable_generative_fallback", enable_generative_fallback)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if return_partial_responses is not None:
            pulumi.set(__self__, "return_partial_responses", return_partial_responses)
        if set_parameter_actions is not None:
            pulumi.set(__self__, "set_parameter_actions", set_parameter_actions)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @_builtins.property
    @pulumi.getter(name="advancedSettings")
    def advanced_settings(self) -> Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgs']]:
        """
        Hierarchical advanced settings for agent/flow/page/fulfillment/parameter. Settings exposed at lower level overrides the settings exposed at higher level. Overriding occurs at the sub-setting level. For example, the playbackInterruptionSettings at fulfillment level only overrides the playbackInterruptionSettings at the agent level, leaving other settings at the agent level unchanged.
        DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel.
        Hierarchy: Agent->Flow->Page->Fulfillment/Parameter.
        Structure is documented below.
        """
        return pulumi.get(self, "advanced_settings")

    @advanced_settings.setter
    def advanced_settings(self, value: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgs']]):
        pulumi.set(self, "advanced_settings", value)

    @_builtins.property
    @pulumi.getter(name="conditionalCases")
    def conditional_cases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgs']]]]:
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        return pulumi.get(self, "conditional_cases")

    @conditional_cases.setter
    def conditional_cases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgs']]]]):
        pulumi.set(self, "conditional_cases", value)

    @_builtins.property
    @pulumi.getter(name="enableGenerativeFallback")
    def enable_generative_fallback(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If the flag is true, the agent will utilize LLM to generate a text response. If LLM generation fails, the defined responses in the fulfillment will be respected. This flag is only useful for fulfillments associated with no-match event handlers.
        """
        return pulumi.get(self, "enable_generative_fallback")

    @enable_generative_fallback.setter
    def enable_generative_fallback(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_generative_fallback", value)

    @_builtins.property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageArgs']]]]:
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageArgs']]]]):
        pulumi.set(self, "messages", value)

    @_builtins.property
    @pulumi.getter(name="returnPartialResponses")
    def return_partial_responses(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        return pulumi.get(self, "return_partial_responses")

    @return_partial_responses.setter
    def return_partial_responses(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "return_partial_responses", value)

    @_builtins.property
    @pulumi.getter(name="setParameterActions")
    def set_parameter_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgs']]]]:
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        return pulumi.get(self, "set_parameter_actions")

    @set_parameter_actions.setter
    def set_parameter_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgs']]]]):
        pulumi.set(self, "set_parameter_actions", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def webhook(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        return pulumi.get(self, "webhook")

    @webhook.setter
    def webhook(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "webhook", value)


if not MYPY:
    class CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgsDict(TypedDict):
        dtmf_settings: NotRequired[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgsDict']]
        """
        Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
        logging_settings: NotRequired[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgsDict']]
        """
        Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels:
        * Agent level
        Structure is documented below.
        """
        speech_settings: NotRequired[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgsDict']]
        """
        Settings for speech to text detection. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
elif False:
    CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsArgs:
    def __init__(__self__, *,
                 dtmf_settings: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgs']] = None,
                 logging_settings: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgs']] = None,
                 speech_settings: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgs']] = None):
        """
        :param pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgs'] dtmf_settings: Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
               * Agent level
               * Flow level
               * Page level
               * Parameter level
               Structure is documented below.
        :param pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgs'] logging_settings: Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels:
               * Agent level
               Structure is documented below.
        :param pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgs'] speech_settings: Settings for speech to text detection. Exposed at the following levels:
               * Agent level
               * Flow level
               * Page level
               * Parameter level
               Structure is documented below.
        """
        if dtmf_settings is not None:
            pulumi.set(__self__, "dtmf_settings", dtmf_settings)
        if logging_settings is not None:
            pulumi.set(__self__, "logging_settings", logging_settings)
        if speech_settings is not None:
            pulumi.set(__self__, "speech_settings", speech_settings)

    @_builtins.property
    @pulumi.getter(name="dtmfSettings")
    def dtmf_settings(self) -> Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgs']]:
        """
        Define behaviors for DTMF (dual tone multi frequency). DTMF settings does not override each other. DTMF settings set at different levels define DTMF detections running in parallel. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
        return pulumi.get(self, "dtmf_settings")

    @dtmf_settings.setter
    def dtmf_settings(self, value: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgs']]):
        pulumi.set(self, "dtmf_settings", value)

    @_builtins.property
    @pulumi.getter(name="loggingSettings")
    def logging_settings(self) -> Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgs']]:
        """
        Settings for logging. Settings for Dialogflow History, Contact Center messages, StackDriver logs, and speech logging. Exposed at the following levels:
        * Agent level
        Structure is documented below.
        """
        return pulumi.get(self, "logging_settings")

    @logging_settings.setter
    def logging_settings(self, value: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgs']]):
        pulumi.set(self, "logging_settings", value)

    @_builtins.property
    @pulumi.getter(name="speechSettings")
    def speech_settings(self) -> Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgs']]:
        """
        Settings for speech to text detection. Exposed at the following levels:
        * Agent level
        * Flow level
        * Page level
        * Parameter level
        Structure is documented below.
        """
        return pulumi.get(self, "speech_settings")

    @speech_settings.setter
    def speech_settings(self, value: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgs']]):
        pulumi.set(self, "speech_settings", value)


if not MYPY:
    class CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        """
        endpointing_timeout_duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        Endpoint timeout setting for matching dtmf input to regex.
        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        """
        finish_digit: NotRequired[pulumi.Input[_builtins.str]]
        """
        The digit that terminates a DTMF digit sequence.
        """
        interdigit_timeout_duration: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interdigit timeout setting for matching dtmf input to regex.
        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        """
        max_digits: NotRequired[pulumi.Input[_builtins.int]]
        """
        Max length of DTMF digits.
        """
elif False:
    CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsDtmfSettingsArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 endpointing_timeout_duration: Optional[pulumi.Input[_builtins.str]] = None,
                 finish_digit: Optional[pulumi.Input[_builtins.str]] = None,
                 interdigit_timeout_duration: Optional[pulumi.Input[_builtins.str]] = None,
                 max_digits: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        :param pulumi.Input[_builtins.str] endpointing_timeout_duration: Endpoint timeout setting for matching dtmf input to regex.
               A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        :param pulumi.Input[_builtins.str] finish_digit: The digit that terminates a DTMF digit sequence.
        :param pulumi.Input[_builtins.str] interdigit_timeout_duration: Interdigit timeout setting for matching dtmf input to regex.
               A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        :param pulumi.Input[_builtins.int] max_digits: Max length of DTMF digits.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if endpointing_timeout_duration is not None:
            pulumi.set(__self__, "endpointing_timeout_duration", endpointing_timeout_duration)
        if finish_digit is not None:
            pulumi.set(__self__, "finish_digit", finish_digit)
        if interdigit_timeout_duration is not None:
            pulumi.set(__self__, "interdigit_timeout_duration", interdigit_timeout_duration)
        if max_digits is not None:
            pulumi.set(__self__, "max_digits", max_digits)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, incoming audio is processed for DTMF (dual tone multi frequtectency) events. For example, if the caller presses a button on their telephone keypad and DTMF processing is enabled, Dialogflow will de the event (e.g. a "3" was pressed) in the incoming audio and pass the event to the bot to drive business logic (e.g. when 3 is pressed, return the account balance).
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="endpointingTimeoutDuration")
    def endpointing_timeout_duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Endpoint timeout setting for matching dtmf input to regex.
        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        """
        return pulumi.get(self, "endpointing_timeout_duration")

    @endpointing_timeout_duration.setter
    def endpointing_timeout_duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "endpointing_timeout_duration", value)

    @_builtins.property
    @pulumi.getter(name="finishDigit")
    def finish_digit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The digit that terminates a DTMF digit sequence.
        """
        return pulumi.get(self, "finish_digit")

    @finish_digit.setter
    def finish_digit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "finish_digit", value)

    @_builtins.property
    @pulumi.getter(name="interdigitTimeoutDuration")
    def interdigit_timeout_duration(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interdigit timeout setting for matching dtmf input to regex.
        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        """
        return pulumi.get(self, "interdigit_timeout_duration")

    @interdigit_timeout_duration.setter
    def interdigit_timeout_duration(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interdigit_timeout_duration", value)

    @_builtins.property
    @pulumi.getter(name="maxDigits")
    def max_digits(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Max length of DTMF digits.
        """
        return pulumi.get(self, "max_digits")

    @max_digits.setter
    def max_digits(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_digits", value)


if not MYPY:
    class CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgsDict(TypedDict):
        enable_consent_based_redaction: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables consent-based end-user input redaction, if true, a pre-defined session parameter **$session.params.conversation-redaction** will be used to determine if the utterance should be redacted.
        """
        enable_interaction_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables DF Interaction logging.
        """
        enable_stackdriver_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables Google Cloud Logging.
        """
elif False:
    CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsLoggingSettingsArgs:
    def __init__(__self__, *,
                 enable_consent_based_redaction: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_interaction_logging: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_stackdriver_logging: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_consent_based_redaction: Enables consent-based end-user input redaction, if true, a pre-defined session parameter **$session.params.conversation-redaction** will be used to determine if the utterance should be redacted.
        :param pulumi.Input[_builtins.bool] enable_interaction_logging: Enables DF Interaction logging.
        :param pulumi.Input[_builtins.bool] enable_stackdriver_logging: Enables Google Cloud Logging.
        """
        if enable_consent_based_redaction is not None:
            pulumi.set(__self__, "enable_consent_based_redaction", enable_consent_based_redaction)
        if enable_interaction_logging is not None:
            pulumi.set(__self__, "enable_interaction_logging", enable_interaction_logging)
        if enable_stackdriver_logging is not None:
            pulumi.set(__self__, "enable_stackdriver_logging", enable_stackdriver_logging)

    @_builtins.property
    @pulumi.getter(name="enableConsentBasedRedaction")
    def enable_consent_based_redaction(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables consent-based end-user input redaction, if true, a pre-defined session parameter **$session.params.conversation-redaction** will be used to determine if the utterance should be redacted.
        """
        return pulumi.get(self, "enable_consent_based_redaction")

    @enable_consent_based_redaction.setter
    def enable_consent_based_redaction(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_consent_based_redaction", value)

    @_builtins.property
    @pulumi.getter(name="enableInteractionLogging")
    def enable_interaction_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables DF Interaction logging.
        """
        return pulumi.get(self, "enable_interaction_logging")

    @enable_interaction_logging.setter
    def enable_interaction_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_interaction_logging", value)

    @_builtins.property
    @pulumi.getter(name="enableStackdriverLogging")
    def enable_stackdriver_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables Google Cloud Logging.
        """
        return pulumi.get(self, "enable_stackdriver_logging")

    @enable_stackdriver_logging.setter
    def enable_stackdriver_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_stackdriver_logging", value)


if not MYPY:
    class CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgsDict(TypedDict):
        endpointer_sensitivity: NotRequired[pulumi.Input[_builtins.int]]
        """
        Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
        """
        models: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
        An object containing a list of **"key": value** pairs. Example: **{ "name": "wrench", "mass": "1.3kg", "count": "3" }**.
        """
        no_speech_timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        Timeout before detecting no speech.
        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        """
        use_timeout_based_endpointing: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Use timeout based endpointing, interpreting endpointer sensitivity as seconds of timeout value.
        """
elif False:
    CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsTriggerFulfillmentAdvancedSettingsSpeechSettingsArgs:
    def __init__(__self__, *,
                 endpointer_sensitivity: Optional[pulumi.Input[_builtins.int]] = None,
                 models: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 no_speech_timeout: Optional[pulumi.Input[_builtins.str]] = None,
                 use_timeout_based_endpointing: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] endpointer_sensitivity: Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] models: Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
               An object containing a list of **"key": value** pairs. Example: **{ "name": "wrench", "mass": "1.3kg", "count": "3" }**.
        :param pulumi.Input[_builtins.str] no_speech_timeout: Timeout before detecting no speech.
               A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        :param pulumi.Input[_builtins.bool] use_timeout_based_endpointing: Use timeout based endpointing, interpreting endpointer sensitivity as seconds of timeout value.
        """
        if endpointer_sensitivity is not None:
            pulumi.set(__self__, "endpointer_sensitivity", endpointer_sensitivity)
        if models is not None:
            pulumi.set(__self__, "models", models)
        if no_speech_timeout is not None:
            pulumi.set(__self__, "no_speech_timeout", no_speech_timeout)
        if use_timeout_based_endpointing is not None:
            pulumi.set(__self__, "use_timeout_based_endpointing", use_timeout_based_endpointing)

    @_builtins.property
    @pulumi.getter(name="endpointerSensitivity")
    def endpointer_sensitivity(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Sensitivity of the speech model that detects the end of speech. Scale from 0 to 100.
        """
        return pulumi.get(self, "endpointer_sensitivity")

    @endpointer_sensitivity.setter
    def endpointer_sensitivity(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "endpointer_sensitivity", value)

    @_builtins.property
    @pulumi.getter
    def models(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Mapping from language to Speech-to-Text model. The mapped Speech-to-Text model will be selected for requests from its corresponding language. For more information, see [Speech models](https://cloud.google.com/dialogflow/cx/docs/concept/speech-models).
        An object containing a list of **"key": value** pairs. Example: **{ "name": "wrench", "mass": "1.3kg", "count": "3" }**.
        """
        return pulumi.get(self, "models")

    @models.setter
    def models(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "models", value)

    @_builtins.property
    @pulumi.getter(name="noSpeechTimeout")
    def no_speech_timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Timeout before detecting no speech.
        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.500s".
        """
        return pulumi.get(self, "no_speech_timeout")

    @no_speech_timeout.setter
    def no_speech_timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "no_speech_timeout", value)

    @_builtins.property
    @pulumi.getter(name="useTimeoutBasedEndpointing")
    def use_timeout_based_endpointing(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Use timeout based endpointing, interpreting endpointer sensitivity as seconds of timeout value.
        """
        return pulumi.get(self, "use_timeout_based_endpointing")

    @use_timeout_based_endpointing.setter
    def use_timeout_based_endpointing(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_timeout_based_endpointing", value)


if not MYPY:
    class CxPageKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgsDict(TypedDict):
        cases: NotRequired[pulumi.Input[_builtins.str]]
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
elif False:
    CxPageKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsTriggerFulfillmentConditionalCaseArgs:
    def __init__(__self__, *,
                 cases: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cases: A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
               See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        if cases is not None:
            pulumi.set(__self__, "cases", cases)

    @_builtins.property
    @pulumi.getter
    def cases(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        return pulumi.get(self, "cases")

    @cases.setter
    def cases(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cases", value)


if not MYPY:
    class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageArgsDict(TypedDict):
        channel: NotRequired[pulumi.Input[_builtins.str]]
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        conversation_success: NotRequired[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgsDict']]
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        end_interactions: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgsDict']]]]
        """
        (Output)
        This type has no fields.
        Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        knowledge_info_card: NotRequired[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgsDict']]
        """
        This type has no fields.
        Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card.
        Otherwise, the info card response is skipped.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        live_agent_handoff: NotRequired[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgsDict']]
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        mixed_audios: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgsDict']]]]
        """
        (Output)
        Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via playAudio. This message is generated by Dialogflow only and not supposed to be defined by the user.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        output_audio_text: NotRequired[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgsDict']]
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        Returns a response containing a custom, platform-specific payload.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        play_audio: NotRequired[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgsDict']]
        """
        Specifies an audio clip to be played by the client as part of the response.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        telephony_transfer_call: NotRequired[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgsDict']]
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        text: NotRequired[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgsDict']]
        """
        The text response message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
elif False:
    CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageArgs:
    def __init__(__self__, *,
                 channel: Optional[pulumi.Input[_builtins.str]] = None,
                 conversation_success: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgs']] = None,
                 end_interactions: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgs']]]] = None,
                 knowledge_info_card: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgs']] = None,
                 live_agent_handoff: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgs']] = None,
                 mixed_audios: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgs']]]] = None,
                 output_audio_text: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgs']] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 play_audio: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgs']] = None,
                 telephony_transfer_call: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgs']] = None,
                 text: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] channel: The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        :param pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgs'] conversation_success: Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
               Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
               * In a webhook response when you determine that you handled the customer issue.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgs']]] end_interactions: (Output)
               This type has no fields.
               Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        :param pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgs'] knowledge_info_card: This type has no fields.
               Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card.
               Otherwise, the info card response is skipped.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        :param pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgs'] live_agent_handoff: Indicates that the conversation should be handed off to a live agent.
               Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
               * In a webhook response when you determine that the customer issue can only be handled by a human.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgs']]] mixed_audios: (Output)
               Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via playAudio. This message is generated by Dialogflow only and not supposed to be defined by the user.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgs'] output_audio_text: A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] payload: Returns a response containing a custom, platform-specific payload.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        :param pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgs'] play_audio: Specifies an audio clip to be played by the client as part of the response.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgs'] telephony_transfer_call: Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgs'] text: The text response message.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if conversation_success is not None:
            pulumi.set(__self__, "conversation_success", conversation_success)
        if end_interactions is not None:
            pulumi.set(__self__, "end_interactions", end_interactions)
        if knowledge_info_card is not None:
            pulumi.set(__self__, "knowledge_info_card", knowledge_info_card)
        if live_agent_handoff is not None:
            pulumi.set(__self__, "live_agent_handoff", live_agent_handoff)
        if mixed_audios is not None:
            pulumi.set(__self__, "mixed_audios", mixed_audios)
        if output_audio_text is not None:
            pulumi.set(__self__, "output_audio_text", output_audio_text)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if play_audio is not None:
            pulumi.set(__self__, "play_audio", play_audio)
        if telephony_transfer_call is not None:
            pulumi.set(__self__, "telephony_transfer_call", telephony_transfer_call)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter(name="conversationSuccess")
    def conversation_success(self) -> Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgs']]:
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_success")

    @conversation_success.setter
    def conversation_success(self, value: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgs']]):
        pulumi.set(self, "conversation_success", value)

    @_builtins.property
    @pulumi.getter(name="endInteractions")
    def end_interactions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgs']]]]:
        """
        (Output)
        This type has no fields.
        Indicates that interaction with the Dialogflow agent has ended. This message is generated by Dialogflow only and not supposed to be defined by the user.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        return pulumi.get(self, "end_interactions")

    @end_interactions.setter
    def end_interactions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgs']]]]):
        pulumi.set(self, "end_interactions", value)

    @_builtins.property
    @pulumi.getter(name="knowledgeInfoCard")
    def knowledge_info_card(self) -> Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgs']]:
        """
        This type has no fields.
        Represents info card response. If the response contains generative knowledge prediction, Dialogflow will return a payload with Infobot Messenger compatible info card.
        Otherwise, the info card response is skipped.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        return pulumi.get(self, "knowledge_info_card")

    @knowledge_info_card.setter
    def knowledge_info_card(self, value: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgs']]):
        pulumi.set(self, "knowledge_info_card", value)

    @_builtins.property
    @pulumi.getter(name="liveAgentHandoff")
    def live_agent_handoff(self) -> Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgs']]:
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "live_agent_handoff")

    @live_agent_handoff.setter
    def live_agent_handoff(self, value: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgs']]):
        pulumi.set(self, "live_agent_handoff", value)

    @_builtins.property
    @pulumi.getter(name="mixedAudios")
    def mixed_audios(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgs']]]]:
        """
        (Output)
        Represents an audio message that is composed of both segments synthesized from the Dialogflow agent prompts and ones hosted externally at the specified URIs. The external URIs are specified via playAudio. This message is generated by Dialogflow only and not supposed to be defined by the user.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "mixed_audios")

    @mixed_audios.setter
    def mixed_audios(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgs']]]]):
        pulumi.set(self, "mixed_audios", value)

    @_builtins.property
    @pulumi.getter(name="outputAudioText")
    def output_audio_text(self) -> Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgs']]:
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "output_audio_text")

    @output_audio_text.setter
    def output_audio_text(self, value: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgs']]):
        pulumi.set(self, "output_audio_text", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Returns a response containing a custom, platform-specific payload.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="playAudio")
    def play_audio(self) -> Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgs']]:
        """
        Specifies an audio clip to be played by the client as part of the response.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "play_audio")

    @play_audio.setter
    def play_audio(self, value: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgs']]):
        pulumi.set(self, "play_audio", value)

    @_builtins.property
    @pulumi.getter(name="telephonyTransferCall")
    def telephony_transfer_call(self) -> Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgs']]:
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "telephony_transfer_call")

    @telephony_transfer_call.setter
    def telephony_transfer_call(self, value: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgs']]):
        pulumi.set(self, "telephony_transfer_call", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgs']]:
        """
        The text response message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
elif False:
    CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageConversationSuccessArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgsDict(TypedDict):
        pass
elif False:
    CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageEndInteractionArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgsDict(TypedDict):
        pass
elif False:
    CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageKnowledgeInfoCardArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
elif False:
    CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageLiveAgentHandoffArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgsDict(TypedDict):
        segments: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgsDict']]]]
        """
        Segments this audio response is composed of.
        """
elif False:
    CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioArgs:
    def __init__(__self__, *,
                 segments: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgs']]] segments: Segments this audio response is composed of.
        """
        if segments is not None:
            pulumi.set(__self__, "segments", segments)

    @_builtins.property
    @pulumi.getter
    def segments(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgs']]]]:
        """
        Segments this audio response is composed of.
        """
        return pulumi.get(self, "segments")

    @segments.setter
    def segments(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgs']]]]):
        pulumi.set(self, "segments", value)


if not MYPY:
    class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this segment can be interrupted by the end user's speech and the client should then start the next Dialogflow request.
        """
        audio: NotRequired[pulumi.Input[_builtins.str]]
        """
        Raw audio synthesized from the Dialogflow agent's response using the output config specified in the request.
        A base64-encoded string.
        This field is part of a union field `content`: Only one of `audio` or `uri` may be set.
        """
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
        This field is part of a union field `content`: Only one of `audio` or `uri` may be set.
        """
elif False:
    CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageMixedAudioSegmentArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 audio: Optional[pulumi.Input[_builtins.str]] = None,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this segment can be interrupted by the end user's speech and the client should then start the next Dialogflow request.
        :param pulumi.Input[_builtins.str] audio: Raw audio synthesized from the Dialogflow agent's response using the output config specified in the request.
               A base64-encoded string.
               This field is part of a union field `content`: Only one of `audio` or `uri` may be set.
        :param pulumi.Input[_builtins.str] uri: Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
               This field is part of a union field `content`: Only one of `audio` or `uri` may be set.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if audio is not None:
            pulumi.set(__self__, "audio", audio)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this segment can be interrupted by the end user's speech and the client should then start the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def audio(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Raw audio synthesized from the Dialogflow agent's response using the output config specified in the request.
        A base64-encoded string.
        This field is part of a union field `content`: Only one of `audio` or `uri` may be set.
        """
        return pulumi.get(self, "audio")

    @audio.setter
    def audio(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audio", value)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Client-specific URI that points to an audio clip accessible to the client. Dialogflow does not impose any validation on it.
        This field is part of a union field `content`: Only one of `audio` or `uri` may be set.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        ssml: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SSML text to be synthesized. For more information, see SSML.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The raw text to be synthesized.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
elif False:
    CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageOutputAudioTextArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 ssml: Optional[pulumi.Input[_builtins.str]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param pulumi.Input[_builtins.str] ssml: The SSML text to be synthesized. For more information, see SSML.
               This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        :param pulumi.Input[_builtins.str] text: The raw text to be synthesized.
               This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if ssml is not None:
            pulumi.set(__self__, "ssml", ssml)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def ssml(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SSML text to be synthesized. For more information, see SSML.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        return pulumi.get(self, "ssml")

    @ssml.setter
    def ssml(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssml", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The raw text to be synthesized.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgsDict(TypedDict):
        audio_uri: pulumi.Input[_builtins.str]
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.

        <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
elif False:
    CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessagePlayAudioArgs:
    def __init__(__self__, *,
                 audio_uri: pulumi.Input[_builtins.str],
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] audio_uri: URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
               
               <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
        pulumi.set(__self__, "audio_uri", audio_uri)
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)

    @_builtins.property
    @pulumi.getter(name="audioUri")
    def audio_uri(self) -> pulumi.Input[_builtins.str]:
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        return pulumi.get(self, "audio_uri")

    @audio_uri.setter
    def audio_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "audio_uri", value)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.

        <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)


if not MYPY:
    class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgsDict(TypedDict):
        phone_number: pulumi.Input[_builtins.str]
        """
        Transfer the call to a phone number in E.164 format.
        """
elif False:
    CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTelephonyTransferCallArgs:
    def __init__(__self__, *,
                 phone_number: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] phone_number: Transfer the call to a phone number in E.164 format.
        """
        pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> pulumi.Input[_builtins.str]:
        """
        Transfer the call to a phone number in E.164 format.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        texts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
        required: true
        """
elif False:
    CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsTriggerFulfillmentMessageTextArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 texts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] texts: A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
               required: true
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def texts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
        required: true
        """
        return pulumi.get(self, "texts")

    @texts.setter
    def texts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "texts", value)


if not MYPY:
    class CxPageKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgsDict(TypedDict):
        parameter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name of the parameter.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
elif False:
    CxPageKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageKnowledgeConnectorSettingsTriggerFulfillmentSetParameterActionArgs:
    def __init__(__self__, *,
                 parameter: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] parameter: Display name of the parameter.
        :param pulumi.Input[_builtins.str] value: The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        if parameter is not None:
            pulumi.set(__self__, "parameter", parameter)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def parameter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name of the parameter.
        """
        return pulumi.get(self, "parameter")

    @parameter.setter
    def parameter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parameter", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CxPageTransitionRouteArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        The condition to evaluate against form parameters or session parameters.
        At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        """
        intent: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier of an Intent.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>. Indicates that the transition can only happen when the given intent is matched. At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The unique identifier of this transition route.
        """
        target_flow: NotRequired[pulumi.Input[_builtins.str]]
        """
        The target flow to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        """
        target_page: NotRequired[pulumi.Input[_builtins.str]]
        """
        The target page to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        trigger_fulfillment: NotRequired[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentArgsDict']]
        """
        The fulfillment to call when the condition is satisfied. At least one of triggerFulfillment and target must be specified. When both are defined, triggerFulfillment is executed first.
        Structure is documented below.
        """
elif False:
    CxPageTransitionRouteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageTransitionRouteArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input[_builtins.str]] = None,
                 intent: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 target_flow: Optional[pulumi.Input[_builtins.str]] = None,
                 target_page: Optional[pulumi.Input[_builtins.str]] = None,
                 trigger_fulfillment: Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] condition: The condition to evaluate against form parameters or session parameters.
               At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        :param pulumi.Input[_builtins.str] intent: The unique identifier of an Intent.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>. Indicates that the transition can only happen when the given intent is matched. At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        :param pulumi.Input[_builtins.str] name: (Output)
               The unique identifier of this transition route.
        :param pulumi.Input[_builtins.str] target_flow: The target flow to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        :param pulumi.Input[_builtins.str] target_page: The target page to transition to.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        :param pulumi.Input['CxPageTransitionRouteTriggerFulfillmentArgs'] trigger_fulfillment: The fulfillment to call when the condition is satisfied. At least one of triggerFulfillment and target must be specified. When both are defined, triggerFulfillment is executed first.
               Structure is documented below.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if intent is not None:
            pulumi.set(__self__, "intent", intent)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if target_flow is not None:
            pulumi.set(__self__, "target_flow", target_flow)
        if target_page is not None:
            pulumi.set(__self__, "target_page", target_page)
        if trigger_fulfillment is not None:
            pulumi.set(__self__, "trigger_fulfillment", trigger_fulfillment)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The condition to evaluate against form parameters or session parameters.
        At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter
    def intent(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier of an Intent.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>. Indicates that the transition can only happen when the given intent is matched. At least one of intent or condition must be specified. When both intent and condition are specified, the transition can only happen when both are fulfilled.
        """
        return pulumi.get(self, "intent")

    @intent.setter
    def intent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "intent", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The unique identifier of this transition route.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="targetFlow")
    def target_flow(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The target flow to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        """
        return pulumi.get(self, "target_flow")

    @target_flow.setter
    def target_flow(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_flow", value)

    @_builtins.property
    @pulumi.getter(name="targetPage")
    def target_page(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The target page to transition to.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        return pulumi.get(self, "target_page")

    @target_page.setter
    def target_page(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_page", value)

    @_builtins.property
    @pulumi.getter(name="triggerFulfillment")
    def trigger_fulfillment(self) -> Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentArgs']]:
        """
        The fulfillment to call when the condition is satisfied. At least one of triggerFulfillment and target must be specified. When both are defined, triggerFulfillment is executed first.
        Structure is documented below.
        """
        return pulumi.get(self, "trigger_fulfillment")

    @trigger_fulfillment.setter
    def trigger_fulfillment(self, value: Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentArgs']]):
        pulumi.set(self, "trigger_fulfillment", value)


if not MYPY:
    class CxPageTransitionRouteTriggerFulfillmentArgsDict(TypedDict):
        conditional_cases: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentConditionalCaseArgsDict']]]]
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        messages: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageArgsDict']]]]
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return_partial_responses: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        set_parameter_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentSetParameterActionArgsDict']]]]
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        tag: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        webhook: NotRequired[pulumi.Input[_builtins.str]]
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
elif False:
    CxPageTransitionRouteTriggerFulfillmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageTransitionRouteTriggerFulfillmentArgs:
    def __init__(__self__, *,
                 conditional_cases: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentConditionalCaseArgs']]]] = None,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageArgs']]]] = None,
                 return_partial_responses: Optional[pulumi.Input[_builtins.bool]] = None,
                 set_parameter_actions: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentSetParameterActionArgs']]]] = None,
                 tag: Optional[pulumi.Input[_builtins.str]] = None,
                 webhook: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentConditionalCaseArgs']]] conditional_cases: Conditional cases for this fulfillment.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageArgs']]] messages: The list of rich message responses to present to the user.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] return_partial_responses: Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        :param pulumi.Input[Sequence[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentSetParameterActionArgs']]] set_parameter_actions: Set parameter values before executing the webhook.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] tag: The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        :param pulumi.Input[_builtins.str] webhook: The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        if conditional_cases is not None:
            pulumi.set(__self__, "conditional_cases", conditional_cases)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if return_partial_responses is not None:
            pulumi.set(__self__, "return_partial_responses", return_partial_responses)
        if set_parameter_actions is not None:
            pulumi.set(__self__, "set_parameter_actions", set_parameter_actions)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)
        if webhook is not None:
            pulumi.set(__self__, "webhook", webhook)

    @_builtins.property
    @pulumi.getter(name="conditionalCases")
    def conditional_cases(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentConditionalCaseArgs']]]]:
        """
        Conditional cases for this fulfillment.
        Structure is documented below.
        """
        return pulumi.get(self, "conditional_cases")

    @conditional_cases.setter
    def conditional_cases(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentConditionalCaseArgs']]]]):
        pulumi.set(self, "conditional_cases", value)

    @_builtins.property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageArgs']]]]:
        """
        The list of rich message responses to present to the user.
        Structure is documented below.
        """
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageArgs']]]]):
        pulumi.set(self, "messages", value)

    @_builtins.property
    @pulumi.getter(name="returnPartialResponses")
    def return_partial_responses(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether Dialogflow should return currently queued fulfillment response messages in streaming APIs. If a webhook is specified, it happens before Dialogflow invokes webhook. Warning: 1) This flag only affects streaming API. Responses are still queued and returned once in non-streaming API. 2) The flag can be enabled in any fulfillment but only the first 3 partial responses will be returned. You may only want to apply it to fulfillments that have slow webhooks.
        """
        return pulumi.get(self, "return_partial_responses")

    @return_partial_responses.setter
    def return_partial_responses(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "return_partial_responses", value)

    @_builtins.property
    @pulumi.getter(name="setParameterActions")
    def set_parameter_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentSetParameterActionArgs']]]]:
        """
        Set parameter values before executing the webhook.
        Structure is documented below.
        """
        return pulumi.get(self, "set_parameter_actions")

    @set_parameter_actions.setter
    def set_parameter_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentSetParameterActionArgs']]]]):
        pulumi.set(self, "set_parameter_actions", value)

    @_builtins.property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tag used by the webhook to identify which fulfillment is being called. This field is required if webhook is specified.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tag", value)

    @_builtins.property
    @pulumi.getter
    def webhook(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The webhook to call. Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/webhooks/<Webhook ID>.
        """
        return pulumi.get(self, "webhook")

    @webhook.setter
    def webhook(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "webhook", value)


if not MYPY:
    class CxPageTransitionRouteTriggerFulfillmentConditionalCaseArgsDict(TypedDict):
        cases: NotRequired[pulumi.Input[_builtins.str]]
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
elif False:
    CxPageTransitionRouteTriggerFulfillmentConditionalCaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageTransitionRouteTriggerFulfillmentConditionalCaseArgs:
    def __init__(__self__, *,
                 cases: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cases: A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
               See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        if cases is not None:
            pulumi.set(__self__, "cases", cases)

    @_builtins.property
    @pulumi.getter
    def cases(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A JSON encoded list of cascading if-else conditions. Cases are mutually exclusive. The first one with a matching condition is selected, all the rest ignored.
        See [Case](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/Fulfillment#case) for the schema.
        """
        return pulumi.get(self, "cases")

    @cases.setter
    def cases(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cases", value)


if not MYPY:
    class CxPageTransitionRouteTriggerFulfillmentMessageArgsDict(TypedDict):
        channel: NotRequired[pulumi.Input[_builtins.str]]
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        conversation_success: NotRequired[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageConversationSuccessArgsDict']]
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        live_agent_handoff: NotRequired[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgsDict']]
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        output_audio_text: NotRequired[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgsDict']]
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        payload: NotRequired[pulumi.Input[_builtins.str]]
        """
        Returns a response containing a custom, platform-specific payload.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        play_audio: NotRequired[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessagePlayAudioArgsDict']]
        """
        Specifies an audio clip to be played by the client as part of the response.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        telephony_transfer_call: NotRequired[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgsDict']]
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        text: NotRequired[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageTextArgsDict']]
        """
        The text response message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
elif False:
    CxPageTransitionRouteTriggerFulfillmentMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageTransitionRouteTriggerFulfillmentMessageArgs:
    def __init__(__self__, *,
                 channel: Optional[pulumi.Input[_builtins.str]] = None,
                 conversation_success: Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageConversationSuccessArgs']] = None,
                 live_agent_handoff: Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgs']] = None,
                 output_audio_text: Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgs']] = None,
                 payload: Optional[pulumi.Input[_builtins.str]] = None,
                 play_audio: Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessagePlayAudioArgs']] = None,
                 telephony_transfer_call: Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgs']] = None,
                 text: Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageTextArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] channel: The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        :param pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageConversationSuccessArgs'] conversation_success: Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
               Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
               * In a webhook response when you determine that you handled the customer issue.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgs'] live_agent_handoff: Indicates that the conversation should be handed off to a live agent.
               Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
               You may set this, for example:
               * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
               * In a webhook response when you determine that the customer issue can only be handled by a human.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgs'] output_audio_text: A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] payload: Returns a response containing a custom, platform-specific payload.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        :param pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessagePlayAudioArgs'] play_audio: Specifies an audio clip to be played by the client as part of the response.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgs'] telephony_transfer_call: Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        :param pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageTextArgs'] text: The text response message.
               This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
               Structure is documented below.
        """
        if channel is not None:
            pulumi.set(__self__, "channel", channel)
        if conversation_success is not None:
            pulumi.set(__self__, "conversation_success", conversation_success)
        if live_agent_handoff is not None:
            pulumi.set(__self__, "live_agent_handoff", live_agent_handoff)
        if output_audio_text is not None:
            pulumi.set(__self__, "output_audio_text", output_audio_text)
        if payload is not None:
            pulumi.set(__self__, "payload", payload)
        if play_audio is not None:
            pulumi.set(__self__, "play_audio", play_audio)
        if telephony_transfer_call is not None:
            pulumi.set(__self__, "telephony_transfer_call", telephony_transfer_call)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def channel(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The channel which the response is associated with. Clients can specify the channel via QueryParameters.channel, and only associated channel response will be returned.
        """
        return pulumi.get(self, "channel")

    @channel.setter
    def channel(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel", value)

    @_builtins.property
    @pulumi.getter(name="conversationSuccess")
    def conversation_success(self) -> Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageConversationSuccessArgs']]:
        """
        Indicates that the conversation succeeded, i.e., the bot handled the issue that the customer talked to it about.
        Dialogflow only uses this to determine which conversations should be counted as successful and doesn't process the metadata in this message in any way. Note that Dialogflow also considers conversations that get to the conversation end page as successful even if they don't return ConversationSuccess.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates that the conversation succeeded.
        * In a webhook response when you determine that you handled the customer issue.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_success")

    @conversation_success.setter
    def conversation_success(self, value: Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageConversationSuccessArgs']]):
        pulumi.set(self, "conversation_success", value)

    @_builtins.property
    @pulumi.getter(name="liveAgentHandoff")
    def live_agent_handoff(self) -> Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgs']]:
        """
        Indicates that the conversation should be handed off to a live agent.
        Dialogflow only uses this to determine which conversations were handed off to a human agent for measurement purposes. What else to do with this signal is up to you and your handoff procedures.
        You may set this, for example:
        * In the entryFulfillment of a Page if entering the page indicates something went extremely wrong in the conversation.
        * In a webhook response when you determine that the customer issue can only be handled by a human.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "live_agent_handoff")

    @live_agent_handoff.setter
    def live_agent_handoff(self, value: Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgs']]):
        pulumi.set(self, "live_agent_handoff", value)

    @_builtins.property
    @pulumi.getter(name="outputAudioText")
    def output_audio_text(self) -> Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgs']]:
        """
        A text or ssml response that is preferentially used for TTS output audio synthesis, as described in the comment on the ResponseMessage message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "output_audio_text")

    @output_audio_text.setter
    def output_audio_text(self, value: Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgs']]):
        pulumi.set(self, "output_audio_text", value)

    @_builtins.property
    @pulumi.getter
    def payload(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Returns a response containing a custom, platform-specific payload.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        """
        return pulumi.get(self, "payload")

    @payload.setter
    def payload(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "payload", value)

    @_builtins.property
    @pulumi.getter(name="playAudio")
    def play_audio(self) -> Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessagePlayAudioArgs']]:
        """
        Specifies an audio clip to be played by the client as part of the response.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "play_audio")

    @play_audio.setter
    def play_audio(self, value: Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessagePlayAudioArgs']]):
        pulumi.set(self, "play_audio", value)

    @_builtins.property
    @pulumi.getter(name="telephonyTransferCall")
    def telephony_transfer_call(self) -> Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgs']]:
        """
        Represents the signal that telles the client to transfer the phone call connected to the agent to a third-party endpoint.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "telephony_transfer_call")

    @telephony_transfer_call.setter
    def telephony_transfer_call(self, value: Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgs']]):
        pulumi.set(self, "telephony_transfer_call", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageTextArgs']]:
        """
        The text response message.
        This field is part of a union field `message`: Only one of `text`, `payload`, `conversationSuccess`, `outputAudioText`, `liveAgentHandoff`, `endInteraction`, `playAudio`, `mixedAudio`, `telephonyTransferCall`, or `knowledgeInfoCard` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['CxPageTransitionRouteTriggerFulfillmentMessageTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxPageTransitionRouteTriggerFulfillmentMessageConversationSuccessArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
elif False:
    CxPageTransitionRouteTriggerFulfillmentMessageConversationSuccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageTransitionRouteTriggerFulfillmentMessageConversationSuccessArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class CxPageTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgsDict(TypedDict):
        metadata: NotRequired[pulumi.Input[_builtins.str]]
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
elif False:
    CxPageTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageTransitionRouteTriggerFulfillmentMessageLiveAgentHandoffArgs:
    def __init__(__self__, *,
                 metadata: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] metadata: Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Custom metadata. Dialogflow doesn't impose any structure on this.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "metadata", value)


if not MYPY:
    class CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        ssml: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SSML text to be synthesized. For more information, see SSML.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The raw text to be synthesized.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
elif False:
    CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageTransitionRouteTriggerFulfillmentMessageOutputAudioTextArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 ssml: Optional[pulumi.Input[_builtins.str]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param pulumi.Input[_builtins.str] ssml: The SSML text to be synthesized. For more information, see SSML.
               This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        :param pulumi.Input[_builtins.str] text: The raw text to be synthesized.
               This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if ssml is not None:
            pulumi.set(__self__, "ssml", ssml)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def ssml(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SSML text to be synthesized. For more information, see SSML.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        return pulumi.get(self, "ssml")

    @ssml.setter
    def ssml(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ssml", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The raw text to be synthesized.
        This field is part of a union field `source`: Only one of `text` or `ssml` may be set.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxPageTransitionRouteTriggerFulfillmentMessagePlayAudioArgsDict(TypedDict):
        audio_uri: pulumi.Input[_builtins.str]
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.

        <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
elif False:
    CxPageTransitionRouteTriggerFulfillmentMessagePlayAudioArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageTransitionRouteTriggerFulfillmentMessagePlayAudioArgs:
    def __init__(__self__, *,
                 audio_uri: pulumi.Input[_builtins.str],
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] audio_uri: URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
               
               <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
        pulumi.set(__self__, "audio_uri", audio_uri)
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)

    @_builtins.property
    @pulumi.getter(name="audioUri")
    def audio_uri(self) -> pulumi.Input[_builtins.str]:
        """
        URI of the audio clip. Dialogflow does not impose any validation on this value. It is specific to the client that reads it.
        """
        return pulumi.get(self, "audio_uri")

    @audio_uri.setter
    def audio_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "audio_uri", value)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.

        <a name="nested_knowledge_connector_settings_trigger_fulfillment_messages_messages_mixed_audio"></a>The `mixed_audio` block contains:
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)


if not MYPY:
    class CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgsDict(TypedDict):
        phone_number: pulumi.Input[_builtins.str]
        """
        Transfer the call to a phone number in E.164 format.
        """
elif False:
    CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageTransitionRouteTriggerFulfillmentMessageTelephonyTransferCallArgs:
    def __init__(__self__, *,
                 phone_number: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] phone_number: Transfer the call to a phone number in E.164 format.
        """
        pulumi.set(__self__, "phone_number", phone_number)

    @_builtins.property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> pulumi.Input[_builtins.str]:
        """
        Transfer the call to a phone number in E.164 format.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "phone_number", value)


if not MYPY:
    class CxPageTransitionRouteTriggerFulfillmentMessageTextArgsDict(TypedDict):
        allow_playback_interruption: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        texts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
        required: true
        """
elif False:
    CxPageTransitionRouteTriggerFulfillmentMessageTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageTransitionRouteTriggerFulfillmentMessageTextArgs:
    def __init__(__self__, *,
                 allow_playback_interruption: Optional[pulumi.Input[_builtins.bool]] = None,
                 texts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] allow_playback_interruption: (Output)
               Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] texts: A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
               required: true
        """
        if allow_playback_interruption is not None:
            pulumi.set(__self__, "allow_playback_interruption", allow_playback_interruption)
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @_builtins.property
    @pulumi.getter(name="allowPlaybackInterruption")
    def allow_playback_interruption(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the playback of this message can be interrupted by the end user's speech and the client can then starts the next Dialogflow request.
        """
        return pulumi.get(self, "allow_playback_interruption")

    @allow_playback_interruption.setter
    def allow_playback_interruption(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_playback_interruption", value)

    @_builtins.property
    @pulumi.getter
    def texts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A collection of text response variants. If multiple variants are defined, only one text response variant is returned at runtime.
        required: true
        """
        return pulumi.get(self, "texts")

    @texts.setter
    def texts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "texts", value)


if not MYPY:
    class CxPageTransitionRouteTriggerFulfillmentSetParameterActionArgsDict(TypedDict):
        parameter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name of the parameter.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
elif False:
    CxPageTransitionRouteTriggerFulfillmentSetParameterActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPageTransitionRouteTriggerFulfillmentSetParameterActionArgs:
    def __init__(__self__, *,
                 parameter: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] parameter: Display name of the parameter.
        :param pulumi.Input[_builtins.str] value: The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        if parameter is not None:
            pulumi.set(__self__, "parameter", parameter)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def parameter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name of the parameter.
        """
        return pulumi.get(self, "parameter")

    @parameter.setter
    def parameter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parameter", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The new JSON-encoded value of the parameter. A null value clears the parameter.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class CxPlaybookInstructionArgsDict(TypedDict):
        guidelines: NotRequired[pulumi.Input[_builtins.str]]
        """
        General guidelines for the playbook. These are unstructured instructions that are not directly part of the goal, e.g. "Always be polite". It's valid for this text to be long and used instead of steps altogether.
        """
        steps: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxPlaybookInstructionStepArgsDict']]]]
        """
        Ordered list of step by step execution instructions to accomplish target goal.
        Structure is documented below.
        """
elif False:
    CxPlaybookInstructionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPlaybookInstructionArgs:
    def __init__(__self__, *,
                 guidelines: Optional[pulumi.Input[_builtins.str]] = None,
                 steps: Optional[pulumi.Input[Sequence[pulumi.Input['CxPlaybookInstructionStepArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] guidelines: General guidelines for the playbook. These are unstructured instructions that are not directly part of the goal, e.g. "Always be polite". It's valid for this text to be long and used instead of steps altogether.
        :param pulumi.Input[Sequence[pulumi.Input['CxPlaybookInstructionStepArgs']]] steps: Ordered list of step by step execution instructions to accomplish target goal.
               Structure is documented below.
        """
        if guidelines is not None:
            pulumi.set(__self__, "guidelines", guidelines)
        if steps is not None:
            pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter
    def guidelines(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        General guidelines for the playbook. These are unstructured instructions that are not directly part of the goal, e.g. "Always be polite". It's valid for this text to be long and used instead of steps altogether.
        """
        return pulumi.get(self, "guidelines")

    @guidelines.setter
    def guidelines(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "guidelines", value)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxPlaybookInstructionStepArgs']]]]:
        """
        Ordered list of step by step execution instructions to accomplish target goal.
        Structure is documented below.
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxPlaybookInstructionStepArgs']]]]):
        pulumi.set(self, "steps", value)


if not MYPY:
    class CxPlaybookInstructionStepArgsDict(TypedDict):
        steps: NotRequired[pulumi.Input[_builtins.str]]
        """
        Sub-processing needed to execute the current step.
        This field uses JSON data as a string. The value provided must be a valid JSON representation documented in [Step](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.playbooks#step).
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        Step instruction in text format.
        """
elif False:
    CxPlaybookInstructionStepArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPlaybookInstructionStepArgs:
    def __init__(__self__, *,
                 steps: Optional[pulumi.Input[_builtins.str]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] steps: Sub-processing needed to execute the current step.
               This field uses JSON data as a string. The value provided must be a valid JSON representation documented in [Step](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.playbooks#step).
        :param pulumi.Input[_builtins.str] text: Step instruction in text format.
        """
        if steps is not None:
            pulumi.set(__self__, "steps", steps)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Sub-processing needed to execute the current step.
        This field uses JSON data as a string. The value provided must be a valid JSON representation documented in [Step](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.playbooks#step).
        """
        return pulumi.get(self, "steps")

    @steps.setter
    def steps(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "steps", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Step instruction in text format.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxPlaybookLlmModelSettingsArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The selected LLM model.
        """
        prompt_text: NotRequired[pulumi.Input[_builtins.str]]
        """
        The custom prompt to use.
        """
elif False:
    CxPlaybookLlmModelSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxPlaybookLlmModelSettingsArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 prompt_text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] model: The selected LLM model.
        :param pulumi.Input[_builtins.str] prompt_text: The custom prompt to use.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if prompt_text is not None:
            pulumi.set(__self__, "prompt_text", prompt_text)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The selected LLM model.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter(name="promptText")
    def prompt_text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The custom prompt to use.
        """
        return pulumi.get(self, "prompt_text")

    @prompt_text.setter
    def prompt_text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prompt_text", value)


if not MYPY:
    class CxSecuritySettingsAudioExportSettingsArgsDict(TypedDict):
        audio_export_pattern: NotRequired[pulumi.Input[_builtins.str]]
        """
        Filename pattern for exported audio.
        """
        audio_format: NotRequired[pulumi.Input[_builtins.str]]
        """
        File format for exported audio file. Currently only in telephony recordings.
        * MULAW: G.711 mu-law PCM with 8kHz sample rate.
        * MP3: MP3 file format.
        * OGG: OGG Vorbis.
        Possible values are: `MULAW`, `MP3`, `OGG`.
        """
        enable_audio_redaction: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enable audio redaction if it is true.
        """
        gcs_bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cloud Storage bucket to export audio record to. Setting this field would grant the Storage Object Creator role to the Dialogflow Service Agent. API caller that tries to modify this field should have the permission of storage.buckets.setIamPolicy.
        """
elif False:
    CxSecuritySettingsAudioExportSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxSecuritySettingsAudioExportSettingsArgs:
    def __init__(__self__, *,
                 audio_export_pattern: Optional[pulumi.Input[_builtins.str]] = None,
                 audio_format: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_audio_redaction: Optional[pulumi.Input[_builtins.bool]] = None,
                 gcs_bucket: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] audio_export_pattern: Filename pattern for exported audio.
        :param pulumi.Input[_builtins.str] audio_format: File format for exported audio file. Currently only in telephony recordings.
               * MULAW: G.711 mu-law PCM with 8kHz sample rate.
               * MP3: MP3 file format.
               * OGG: OGG Vorbis.
               Possible values are: `MULAW`, `MP3`, `OGG`.
        :param pulumi.Input[_builtins.bool] enable_audio_redaction: Enable audio redaction if it is true.
        :param pulumi.Input[_builtins.str] gcs_bucket: Cloud Storage bucket to export audio record to. Setting this field would grant the Storage Object Creator role to the Dialogflow Service Agent. API caller that tries to modify this field should have the permission of storage.buckets.setIamPolicy.
        """
        if audio_export_pattern is not None:
            pulumi.set(__self__, "audio_export_pattern", audio_export_pattern)
        if audio_format is not None:
            pulumi.set(__self__, "audio_format", audio_format)
        if enable_audio_redaction is not None:
            pulumi.set(__self__, "enable_audio_redaction", enable_audio_redaction)
        if gcs_bucket is not None:
            pulumi.set(__self__, "gcs_bucket", gcs_bucket)

    @_builtins.property
    @pulumi.getter(name="audioExportPattern")
    def audio_export_pattern(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Filename pattern for exported audio.
        """
        return pulumi.get(self, "audio_export_pattern")

    @audio_export_pattern.setter
    def audio_export_pattern(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audio_export_pattern", value)

    @_builtins.property
    @pulumi.getter(name="audioFormat")
    def audio_format(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        File format for exported audio file. Currently only in telephony recordings.
        * MULAW: G.711 mu-law PCM with 8kHz sample rate.
        * MP3: MP3 file format.
        * OGG: OGG Vorbis.
        Possible values are: `MULAW`, `MP3`, `OGG`.
        """
        return pulumi.get(self, "audio_format")

    @audio_format.setter
    def audio_format(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "audio_format", value)

    @_builtins.property
    @pulumi.getter(name="enableAudioRedaction")
    def enable_audio_redaction(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enable audio redaction if it is true.
        """
        return pulumi.get(self, "enable_audio_redaction")

    @enable_audio_redaction.setter
    def enable_audio_redaction(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_audio_redaction", value)

    @_builtins.property
    @pulumi.getter(name="gcsBucket")
    def gcs_bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cloud Storage bucket to export audio record to. Setting this field would grant the Storage Object Creator role to the Dialogflow Service Agent. API caller that tries to modify this field should have the permission of storage.buckets.setIamPolicy.
        """
        return pulumi.get(self, "gcs_bucket")

    @gcs_bucket.setter
    def gcs_bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gcs_bucket", value)


if not MYPY:
    class CxSecuritySettingsInsightsExportSettingsArgsDict(TypedDict):
        enable_insights_export: pulumi.Input[_builtins.bool]
        """
        If enabled, we will automatically exports conversations to Insights and Insights runs its analyzers.
        """
elif False:
    CxSecuritySettingsInsightsExportSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxSecuritySettingsInsightsExportSettingsArgs:
    def __init__(__self__, *,
                 enable_insights_export: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] enable_insights_export: If enabled, we will automatically exports conversations to Insights and Insights runs its analyzers.
        """
        pulumi.set(__self__, "enable_insights_export", enable_insights_export)

    @_builtins.property
    @pulumi.getter(name="enableInsightsExport")
    def enable_insights_export(self) -> pulumi.Input[_builtins.bool]:
        """
        If enabled, we will automatically exports conversations to Insights and Insights runs its analyzers.
        """
        return pulumi.get(self, "enable_insights_export")

    @enable_insights_export.setter
    def enable_insights_export(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enable_insights_export", value)


if not MYPY:
    class CxTestCaseLastTestResultArgsDict(TypedDict):
        conversation_turns: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxTestCaseLastTestResultConversationTurnArgsDict']]]]
        """
        The conversation turns uttered during the test case replay in chronological order.
        Structure is documented below.
        """
        environment: NotRequired[pulumi.Input[_builtins.str]]
        """
        Environment where the test was run. If not set, it indicates the draft environment.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier of the page.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        test_result: NotRequired[pulumi.Input[_builtins.str]]
        """
        Whether the test case passed in the agent environment.
        * PASSED: The test passed.
        * FAILED: The test did not pass.
        Possible values are: `PASSED`, `FAILED`.
        """
        test_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time that the test was run. A timestamp in RFC3339 text format.
        """
elif False:
    CxTestCaseLastTestResultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseLastTestResultArgs:
    def __init__(__self__, *,
                 conversation_turns: Optional[pulumi.Input[Sequence[pulumi.Input['CxTestCaseLastTestResultConversationTurnArgs']]]] = None,
                 environment: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 test_result: Optional[pulumi.Input[_builtins.str]] = None,
                 test_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CxTestCaseLastTestResultConversationTurnArgs']]] conversation_turns: The conversation turns uttered during the test case replay in chronological order.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] environment: Environment where the test was run. If not set, it indicates the draft environment.
        :param pulumi.Input[_builtins.str] name: The unique identifier of the page.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        :param pulumi.Input[_builtins.str] test_result: Whether the test case passed in the agent environment.
               * PASSED: The test passed.
               * FAILED: The test did not pass.
               Possible values are: `PASSED`, `FAILED`.
        :param pulumi.Input[_builtins.str] test_time: The time that the test was run. A timestamp in RFC3339 text format.
        """
        if conversation_turns is not None:
            pulumi.set(__self__, "conversation_turns", conversation_turns)
        if environment is not None:
            pulumi.set(__self__, "environment", environment)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if test_result is not None:
            pulumi.set(__self__, "test_result", test_result)
        if test_time is not None:
            pulumi.set(__self__, "test_time", test_time)

    @_builtins.property
    @pulumi.getter(name="conversationTurns")
    def conversation_turns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxTestCaseLastTestResultConversationTurnArgs']]]]:
        """
        The conversation turns uttered during the test case replay in chronological order.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_turns")

    @conversation_turns.setter
    def conversation_turns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxTestCaseLastTestResultConversationTurnArgs']]]]):
        pulumi.set(self, "conversation_turns", value)

    @_builtins.property
    @pulumi.getter
    def environment(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Environment where the test was run. If not set, it indicates the draft environment.
        """
        return pulumi.get(self, "environment")

    @environment.setter
    def environment(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier of the page.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="testResult")
    def test_result(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Whether the test case passed in the agent environment.
        * PASSED: The test passed.
        * FAILED: The test did not pass.
        Possible values are: `PASSED`, `FAILED`.
        """
        return pulumi.get(self, "test_result")

    @test_result.setter
    def test_result(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "test_result", value)

    @_builtins.property
    @pulumi.getter(name="testTime")
    def test_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time that the test was run. A timestamp in RFC3339 text format.
        """
        return pulumi.get(self, "test_time")

    @test_time.setter
    def test_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "test_time", value)


if not MYPY:
    class CxTestCaseLastTestResultConversationTurnArgsDict(TypedDict):
        user_input: NotRequired[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputArgsDict']]
        """
        The user input.
        Structure is documented below.
        """
        virtual_agent_output: NotRequired[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputArgsDict']]
        """
        The virtual agent output.
        Structure is documented below.
        """
elif False:
    CxTestCaseLastTestResultConversationTurnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseLastTestResultConversationTurnArgs:
    def __init__(__self__, *,
                 user_input: Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputArgs']] = None,
                 virtual_agent_output: Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputArgs']] = None):
        """
        :param pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputArgs'] user_input: The user input.
               Structure is documented below.
        :param pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputArgs'] virtual_agent_output: The virtual agent output.
               Structure is documented below.
        """
        if user_input is not None:
            pulumi.set(__self__, "user_input", user_input)
        if virtual_agent_output is not None:
            pulumi.set(__self__, "virtual_agent_output", virtual_agent_output)

    @_builtins.property
    @pulumi.getter(name="userInput")
    def user_input(self) -> Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputArgs']]:
        """
        The user input.
        Structure is documented below.
        """
        return pulumi.get(self, "user_input")

    @user_input.setter
    def user_input(self, value: Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputArgs']]):
        pulumi.set(self, "user_input", value)

    @_builtins.property
    @pulumi.getter(name="virtualAgentOutput")
    def virtual_agent_output(self) -> Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputArgs']]:
        """
        The virtual agent output.
        Structure is documented below.
        """
        return pulumi.get(self, "virtual_agent_output")

    @virtual_agent_output.setter
    def virtual_agent_output(self, value: Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputArgs']]):
        pulumi.set(self, "virtual_agent_output", value)


if not MYPY:
    class CxTestCaseLastTestResultConversationTurnUserInputArgsDict(TypedDict):
        enable_sentiment_analysis: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether sentiment analysis is enabled.
        """
        injected_parameters: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameters that need to be injected into the conversation during intent detection.
        """
        input: NotRequired[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputArgsDict']]
        """
        User input. Supports text input, event input, dtmf input in the test case.
        Structure is documented below.
        """
        is_webhook_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
        """
elif False:
    CxTestCaseLastTestResultConversationTurnUserInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseLastTestResultConversationTurnUserInputArgs:
    def __init__(__self__, *,
                 enable_sentiment_analysis: Optional[pulumi.Input[_builtins.bool]] = None,
                 injected_parameters: Optional[pulumi.Input[_builtins.str]] = None,
                 input: Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputArgs']] = None,
                 is_webhook_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_sentiment_analysis: Whether sentiment analysis is enabled.
        :param pulumi.Input[_builtins.str] injected_parameters: Parameters that need to be injected into the conversation during intent detection.
        :param pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputArgs'] input: User input. Supports text input, event input, dtmf input in the test case.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] is_webhook_enabled: If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
        """
        if enable_sentiment_analysis is not None:
            pulumi.set(__self__, "enable_sentiment_analysis", enable_sentiment_analysis)
        if injected_parameters is not None:
            pulumi.set(__self__, "injected_parameters", injected_parameters)
        if input is not None:
            pulumi.set(__self__, "input", input)
        if is_webhook_enabled is not None:
            pulumi.set(__self__, "is_webhook_enabled", is_webhook_enabled)

    @_builtins.property
    @pulumi.getter(name="enableSentimentAnalysis")
    def enable_sentiment_analysis(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether sentiment analysis is enabled.
        """
        return pulumi.get(self, "enable_sentiment_analysis")

    @enable_sentiment_analysis.setter
    def enable_sentiment_analysis(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_sentiment_analysis", value)

    @_builtins.property
    @pulumi.getter(name="injectedParameters")
    def injected_parameters(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameters that need to be injected into the conversation during intent detection.
        """
        return pulumi.get(self, "injected_parameters")

    @injected_parameters.setter
    def injected_parameters(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "injected_parameters", value)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputArgs']]:
        """
        User input. Supports text input, event input, dtmf input in the test case.
        Structure is documented below.
        """
        return pulumi.get(self, "input")

    @input.setter
    def input(self, value: Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputArgs']]):
        pulumi.set(self, "input", value)

    @_builtins.property
    @pulumi.getter(name="isWebhookEnabled")
    def is_webhook_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
        """
        return pulumi.get(self, "is_webhook_enabled")

    @is_webhook_enabled.setter
    def is_webhook_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_webhook_enabled", value)


if not MYPY:
    class CxTestCaseLastTestResultConversationTurnUserInputInputArgsDict(TypedDict):
        dtmf: NotRequired[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputDtmfArgsDict']]
        """
        The DTMF event to be handled.
        Structure is documented below.
        """
        event: NotRequired[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputEventArgsDict']]
        """
        The event to be triggered.
        Structure is documented below.
        """
        language_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes.
        Note that queries in the same session do not necessarily need to specify the same language.
        """
        text: NotRequired[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputTextArgsDict']]
        """
        The natural language text to be processed.
        Structure is documented below.
        """
elif False:
    CxTestCaseLastTestResultConversationTurnUserInputInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseLastTestResultConversationTurnUserInputInputArgs:
    def __init__(__self__, *,
                 dtmf: Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputDtmfArgs']] = None,
                 event: Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputEventArgs']] = None,
                 language_code: Optional[pulumi.Input[_builtins.str]] = None,
                 text: Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputTextArgs']] = None):
        """
        :param pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputDtmfArgs'] dtmf: The DTMF event to be handled.
               Structure is documented below.
        :param pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputEventArgs'] event: The event to be triggered.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] language_code: The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes.
               Note that queries in the same session do not necessarily need to specify the same language.
        :param pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputTextArgs'] text: The natural language text to be processed.
               Structure is documented below.
        """
        if dtmf is not None:
            pulumi.set(__self__, "dtmf", dtmf)
        if event is not None:
            pulumi.set(__self__, "event", event)
        if language_code is not None:
            pulumi.set(__self__, "language_code", language_code)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def dtmf(self) -> Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputDtmfArgs']]:
        """
        The DTMF event to be handled.
        Structure is documented below.
        """
        return pulumi.get(self, "dtmf")

    @dtmf.setter
    def dtmf(self, value: Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputDtmfArgs']]):
        pulumi.set(self, "dtmf", value)

    @_builtins.property
    @pulumi.getter
    def event(self) -> Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputEventArgs']]:
        """
        The event to be triggered.
        Structure is documented below.
        """
        return pulumi.get(self, "event")

    @event.setter
    def event(self, value: Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputEventArgs']]):
        pulumi.set(self, "event", value)

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes.
        Note that queries in the same session do not necessarily need to specify the same language.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "language_code", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputTextArgs']]:
        """
        The natural language text to be processed.
        Structure is documented below.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnUserInputInputTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxTestCaseLastTestResultConversationTurnUserInputInputDtmfArgsDict(TypedDict):
        digits: NotRequired[pulumi.Input[_builtins.str]]
        """
        The dtmf digits.
        """
        finish_digit: NotRequired[pulumi.Input[_builtins.str]]
        """
        The finish digit (if any).
        """
elif False:
    CxTestCaseLastTestResultConversationTurnUserInputInputDtmfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseLastTestResultConversationTurnUserInputInputDtmfArgs:
    def __init__(__self__, *,
                 digits: Optional[pulumi.Input[_builtins.str]] = None,
                 finish_digit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] digits: The dtmf digits.
        :param pulumi.Input[_builtins.str] finish_digit: The finish digit (if any).
        """
        if digits is not None:
            pulumi.set(__self__, "digits", digits)
        if finish_digit is not None:
            pulumi.set(__self__, "finish_digit", finish_digit)

    @_builtins.property
    @pulumi.getter
    def digits(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The dtmf digits.
        """
        return pulumi.get(self, "digits")

    @digits.setter
    def digits(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "digits", value)

    @_builtins.property
    @pulumi.getter(name="finishDigit")
    def finish_digit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The finish digit (if any).
        """
        return pulumi.get(self, "finish_digit")

    @finish_digit.setter
    def finish_digit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "finish_digit", value)


if not MYPY:
    class CxTestCaseLastTestResultConversationTurnUserInputInputEventArgsDict(TypedDict):
        event: pulumi.Input[_builtins.str]
        """
        Name of the event.
        """
elif False:
    CxTestCaseLastTestResultConversationTurnUserInputInputEventArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseLastTestResultConversationTurnUserInputInputEventArgs:
    def __init__(__self__, *,
                 event: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] event: Name of the event.
        """
        pulumi.set(__self__, "event", event)

    @_builtins.property
    @pulumi.getter
    def event(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the event.
        """
        return pulumi.get(self, "event")

    @event.setter
    def event(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event", value)


if not MYPY:
    class CxTestCaseLastTestResultConversationTurnUserInputInputTextArgsDict(TypedDict):
        text: pulumi.Input[_builtins.str]
        """
        The natural language text to be processed. Text length must not exceed 256 characters.
        """
elif False:
    CxTestCaseLastTestResultConversationTurnUserInputInputTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseLastTestResultConversationTurnUserInputInputTextArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] text: The natural language text to be processed. Text length must not exceed 256 characters.
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        """
        The natural language text to be processed. Text length must not exceed 256 characters.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxTestCaseLastTestResultConversationTurnVirtualAgentOutputArgsDict(TypedDict):
        current_page: NotRequired[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPageArgsDict']]
        """
        The [Page](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.flows.pages#Page) on which the utterance was spoken.
        Structure is documented below.
        """
        differences: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputDifferenceArgsDict']]]]
        """
        The list of differences between the original run and the replay for this output, if any.
        Structure is documented below.
        """
        session_parameters: NotRequired[pulumi.Input[_builtins.str]]
        """
        The session parameters available to the bot at this point.
        """
        status: NotRequired[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputStatusArgsDict']]
        """
        Response error from the agent in the test result. If set, other output is empty.
        Structure is documented below.
        """
        text_responses: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTextResponseArgsDict']]]]
        """
        The text responses from the agent for the turn.
        Structure is documented below.
        """
        triggered_intent: NotRequired[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntentArgsDict']]
        """
        The [Intent](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.intents#Intent) that triggered the response.
        Structure is documented below.
        """
elif False:
    CxTestCaseLastTestResultConversationTurnVirtualAgentOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseLastTestResultConversationTurnVirtualAgentOutputArgs:
    def __init__(__self__, *,
                 current_page: Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPageArgs']] = None,
                 differences: Optional[pulumi.Input[Sequence[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputDifferenceArgs']]]] = None,
                 session_parameters: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputStatusArgs']] = None,
                 text_responses: Optional[pulumi.Input[Sequence[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTextResponseArgs']]]] = None,
                 triggered_intent: Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntentArgs']] = None):
        """
        :param pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPageArgs'] current_page: The [Page](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.flows.pages#Page) on which the utterance was spoken.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputDifferenceArgs']]] differences: The list of differences between the original run and the replay for this output, if any.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] session_parameters: The session parameters available to the bot at this point.
        :param pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputStatusArgs'] status: Response error from the agent in the test result. If set, other output is empty.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTextResponseArgs']]] text_responses: The text responses from the agent for the turn.
               Structure is documented below.
        :param pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntentArgs'] triggered_intent: The [Intent](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.intents#Intent) that triggered the response.
               Structure is documented below.
        """
        if current_page is not None:
            pulumi.set(__self__, "current_page", current_page)
        if differences is not None:
            pulumi.set(__self__, "differences", differences)
        if session_parameters is not None:
            pulumi.set(__self__, "session_parameters", session_parameters)
        if status is not None:
            pulumi.set(__self__, "status", status)
        if text_responses is not None:
            pulumi.set(__self__, "text_responses", text_responses)
        if triggered_intent is not None:
            pulumi.set(__self__, "triggered_intent", triggered_intent)

    @_builtins.property
    @pulumi.getter(name="currentPage")
    def current_page(self) -> Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPageArgs']]:
        """
        The [Page](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.flows.pages#Page) on which the utterance was spoken.
        Structure is documented below.
        """
        return pulumi.get(self, "current_page")

    @current_page.setter
    def current_page(self, value: Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPageArgs']]):
        pulumi.set(self, "current_page", value)

    @_builtins.property
    @pulumi.getter
    def differences(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputDifferenceArgs']]]]:
        """
        The list of differences between the original run and the replay for this output, if any.
        Structure is documented below.
        """
        return pulumi.get(self, "differences")

    @differences.setter
    def differences(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputDifferenceArgs']]]]):
        pulumi.set(self, "differences", value)

    @_builtins.property
    @pulumi.getter(name="sessionParameters")
    def session_parameters(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The session parameters available to the bot at this point.
        """
        return pulumi.get(self, "session_parameters")

    @session_parameters.setter
    def session_parameters(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "session_parameters", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputStatusArgs']]:
        """
        Response error from the agent in the test result. If set, other output is empty.
        Structure is documented below.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputStatusArgs']]):
        pulumi.set(self, "status", value)

    @_builtins.property
    @pulumi.getter(name="textResponses")
    def text_responses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTextResponseArgs']]]]:
        """
        The text responses from the agent for the turn.
        Structure is documented below.
        """
        return pulumi.get(self, "text_responses")

    @text_responses.setter
    def text_responses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTextResponseArgs']]]]):
        pulumi.set(self, "text_responses", value)

    @_builtins.property
    @pulumi.getter(name="triggeredIntent")
    def triggered_intent(self) -> Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntentArgs']]:
        """
        The [Intent](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.intents#Intent) that triggered the response.
        Structure is documented below.
        """
        return pulumi.get(self, "triggered_intent")

    @triggered_intent.setter
    def triggered_intent(self, value: Optional[pulumi.Input['CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntentArgs']]):
        pulumi.set(self, "triggered_intent", value)


if not MYPY:
    class CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPageArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The human-readable name of the page, unique within the flow.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier of the page.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
elif False:
    CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseLastTestResultConversationTurnVirtualAgentOutputCurrentPageArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Output)
               The human-readable name of the page, unique within the flow.
        :param pulumi.Input[_builtins.str] name: The unique identifier of the page.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The human-readable name of the page, unique within the flow.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier of the page.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CxTestCaseLastTestResultConversationTurnVirtualAgentOutputDifferenceArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        A human readable description of the diff, showing the actual output vs expected output.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of diff.
        * INTENT: The intent.
        * PAGE: The page.
        * PARAMETERS: The parameters.
        * UTTERANCE: The message utterance.
        * FLOW: The flow.
        Possible values are: `INTENT`, `PAGE`, `PARAMETERS`, `UTTERANCE`, `FLOW`.
        """
elif False:
    CxTestCaseLastTestResultConversationTurnVirtualAgentOutputDifferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseLastTestResultConversationTurnVirtualAgentOutputDifferenceArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: A human readable description of the diff, showing the actual output vs expected output.
        :param pulumi.Input[_builtins.str] type: The type of diff.
               * INTENT: The intent.
               * PAGE: The page.
               * PARAMETERS: The parameters.
               * UTTERANCE: The message utterance.
               * FLOW: The flow.
               Possible values are: `INTENT`, `PAGE`, `PARAMETERS`, `UTTERANCE`, `FLOW`.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A human readable description of the diff, showing the actual output vs expected output.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of diff.
        * INTENT: The intent.
        * PAGE: The page.
        * PARAMETERS: The parameters.
        * UTTERANCE: The message utterance.
        * FLOW: The flow.
        Possible values are: `INTENT`, `PAGE`, `PARAMETERS`, `UTTERANCE`, `FLOW`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class CxTestCaseLastTestResultConversationTurnVirtualAgentOutputStatusArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.int]]
        """
        The status code, which should be an enum value of google.rpc.Code.
        """
        details: NotRequired[pulumi.Input[_builtins.str]]
        """
        A JSON encoded list of messages that carry the error details.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        A developer-facing error message.
        """
elif False:
    CxTestCaseLastTestResultConversationTurnVirtualAgentOutputStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseLastTestResultConversationTurnVirtualAgentOutputStatusArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.int]] = None,
                 details: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] code: The status code, which should be an enum value of google.rpc.Code.
        :param pulumi.Input[_builtins.str] details: A JSON encoded list of messages that carry the error details.
        :param pulumi.Input[_builtins.str] message: A developer-facing error message.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The status code, which should be an enum value of google.rpc.Code.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A JSON encoded list of messages that carry the error details.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "details", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A developer-facing error message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTextResponseArgsDict(TypedDict):
        texts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A collection of text responses.
        """
elif False:
    CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTextResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTextResponseArgs:
    def __init__(__self__, *,
                 texts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] texts: A collection of text responses.
        """
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @_builtins.property
    @pulumi.getter
    def texts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A collection of text responses.
        """
        return pulumi.get(self, "texts")

    @texts.setter
    def texts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "texts", value)


if not MYPY:
    class CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntentArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The human-readable name of the intent, unique within the agent.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier of the intent.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>.
        """
elif False:
    CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseLastTestResultConversationTurnVirtualAgentOutputTriggeredIntentArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Output)
               The human-readable name of the intent, unique within the agent.
        :param pulumi.Input[_builtins.str] name: The unique identifier of the intent.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The human-readable name of the intent, unique within the agent.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier of the intent.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CxTestCaseTestCaseConversationTurnArgsDict(TypedDict):
        user_input: NotRequired[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputArgsDict']]
        """
        The user input.
        Structure is documented below.
        """
        virtual_agent_output: NotRequired[pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputArgsDict']]
        """
        The virtual agent output.
        Structure is documented below.
        """
elif False:
    CxTestCaseTestCaseConversationTurnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseTestCaseConversationTurnArgs:
    def __init__(__self__, *,
                 user_input: Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputArgs']] = None,
                 virtual_agent_output: Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputArgs']] = None):
        """
        :param pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputArgs'] user_input: The user input.
               Structure is documented below.
        :param pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputArgs'] virtual_agent_output: The virtual agent output.
               Structure is documented below.
        """
        if user_input is not None:
            pulumi.set(__self__, "user_input", user_input)
        if virtual_agent_output is not None:
            pulumi.set(__self__, "virtual_agent_output", virtual_agent_output)

    @_builtins.property
    @pulumi.getter(name="userInput")
    def user_input(self) -> Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputArgs']]:
        """
        The user input.
        Structure is documented below.
        """
        return pulumi.get(self, "user_input")

    @user_input.setter
    def user_input(self, value: Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputArgs']]):
        pulumi.set(self, "user_input", value)

    @_builtins.property
    @pulumi.getter(name="virtualAgentOutput")
    def virtual_agent_output(self) -> Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputArgs']]:
        """
        The virtual agent output.
        Structure is documented below.
        """
        return pulumi.get(self, "virtual_agent_output")

    @virtual_agent_output.setter
    def virtual_agent_output(self, value: Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputArgs']]):
        pulumi.set(self, "virtual_agent_output", value)


if not MYPY:
    class CxTestCaseTestCaseConversationTurnUserInputArgsDict(TypedDict):
        enable_sentiment_analysis: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether sentiment analysis is enabled.
        """
        injected_parameters: NotRequired[pulumi.Input[_builtins.str]]
        """
        Parameters that need to be injected into the conversation during intent detection.
        """
        input: NotRequired[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputArgsDict']]
        """
        User input. Supports text input, event input, dtmf input in the test case.
        Structure is documented below.
        """
        is_webhook_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
        """
elif False:
    CxTestCaseTestCaseConversationTurnUserInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseTestCaseConversationTurnUserInputArgs:
    def __init__(__self__, *,
                 enable_sentiment_analysis: Optional[pulumi.Input[_builtins.bool]] = None,
                 injected_parameters: Optional[pulumi.Input[_builtins.str]] = None,
                 input: Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputArgs']] = None,
                 is_webhook_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_sentiment_analysis: Whether sentiment analysis is enabled.
        :param pulumi.Input[_builtins.str] injected_parameters: Parameters that need to be injected into the conversation during intent detection.
        :param pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputArgs'] input: User input. Supports text input, event input, dtmf input in the test case.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] is_webhook_enabled: If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
        """
        if enable_sentiment_analysis is not None:
            pulumi.set(__self__, "enable_sentiment_analysis", enable_sentiment_analysis)
        if injected_parameters is not None:
            pulumi.set(__self__, "injected_parameters", injected_parameters)
        if input is not None:
            pulumi.set(__self__, "input", input)
        if is_webhook_enabled is not None:
            pulumi.set(__self__, "is_webhook_enabled", is_webhook_enabled)

    @_builtins.property
    @pulumi.getter(name="enableSentimentAnalysis")
    def enable_sentiment_analysis(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether sentiment analysis is enabled.
        """
        return pulumi.get(self, "enable_sentiment_analysis")

    @enable_sentiment_analysis.setter
    def enable_sentiment_analysis(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_sentiment_analysis", value)

    @_builtins.property
    @pulumi.getter(name="injectedParameters")
    def injected_parameters(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Parameters that need to be injected into the conversation during intent detection.
        """
        return pulumi.get(self, "injected_parameters")

    @injected_parameters.setter
    def injected_parameters(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "injected_parameters", value)

    @_builtins.property
    @pulumi.getter
    def input(self) -> Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputArgs']]:
        """
        User input. Supports text input, event input, dtmf input in the test case.
        Structure is documented below.
        """
        return pulumi.get(self, "input")

    @input.setter
    def input(self, value: Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputArgs']]):
        pulumi.set(self, "input", value)

    @_builtins.property
    @pulumi.getter(name="isWebhookEnabled")
    def is_webhook_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If webhooks should be allowed to trigger in response to the user utterance. Often if parameters are injected, webhooks should not be enabled.
        """
        return pulumi.get(self, "is_webhook_enabled")

    @is_webhook_enabled.setter
    def is_webhook_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_webhook_enabled", value)


if not MYPY:
    class CxTestCaseTestCaseConversationTurnUserInputInputArgsDict(TypedDict):
        dtmf: NotRequired[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputDtmfArgsDict']]
        """
        The DTMF event to be handled.
        Structure is documented below.
        """
        event: NotRequired[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputEventArgsDict']]
        """
        The event to be triggered.
        Structure is documented below.
        """
        language_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes.
        Note that queries in the same session do not necessarily need to specify the same language.
        """
        text: NotRequired[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputTextArgsDict']]
        """
        The natural language text to be processed.
        Structure is documented below.
        """
elif False:
    CxTestCaseTestCaseConversationTurnUserInputInputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseTestCaseConversationTurnUserInputInputArgs:
    def __init__(__self__, *,
                 dtmf: Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputDtmfArgs']] = None,
                 event: Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputEventArgs']] = None,
                 language_code: Optional[pulumi.Input[_builtins.str]] = None,
                 text: Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputTextArgs']] = None):
        """
        :param pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputDtmfArgs'] dtmf: The DTMF event to be handled.
               Structure is documented below.
        :param pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputEventArgs'] event: The event to be triggered.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] language_code: The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes.
               Note that queries in the same session do not necessarily need to specify the same language.
        :param pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputTextArgs'] text: The natural language text to be processed.
               Structure is documented below.
        """
        if dtmf is not None:
            pulumi.set(__self__, "dtmf", dtmf)
        if event is not None:
            pulumi.set(__self__, "event", event)
        if language_code is not None:
            pulumi.set(__self__, "language_code", language_code)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def dtmf(self) -> Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputDtmfArgs']]:
        """
        The DTMF event to be handled.
        Structure is documented below.
        """
        return pulumi.get(self, "dtmf")

    @dtmf.setter
    def dtmf(self, value: Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputDtmfArgs']]):
        pulumi.set(self, "dtmf", value)

    @_builtins.property
    @pulumi.getter
    def event(self) -> Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputEventArgs']]:
        """
        The event to be triggered.
        Structure is documented below.
        """
        return pulumi.get(self, "event")

    @event.setter
    def event(self, value: Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputEventArgs']]):
        pulumi.set(self, "event", value)

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The language of the input. See [Language Support](https://cloud.google.com/dialogflow/cx/docs/reference/language) for a list of the currently supported language codes.
        Note that queries in the same session do not necessarily need to specify the same language.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "language_code", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputTextArgs']]:
        """
        The natural language text to be processed.
        Structure is documented below.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnUserInputInputTextArgs']]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxTestCaseTestCaseConversationTurnUserInputInputDtmfArgsDict(TypedDict):
        digits: NotRequired[pulumi.Input[_builtins.str]]
        """
        The dtmf digits.
        """
        finish_digit: NotRequired[pulumi.Input[_builtins.str]]
        """
        The finish digit (if any).
        """
elif False:
    CxTestCaseTestCaseConversationTurnUserInputInputDtmfArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseTestCaseConversationTurnUserInputInputDtmfArgs:
    def __init__(__self__, *,
                 digits: Optional[pulumi.Input[_builtins.str]] = None,
                 finish_digit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] digits: The dtmf digits.
        :param pulumi.Input[_builtins.str] finish_digit: The finish digit (if any).
        """
        if digits is not None:
            pulumi.set(__self__, "digits", digits)
        if finish_digit is not None:
            pulumi.set(__self__, "finish_digit", finish_digit)

    @_builtins.property
    @pulumi.getter
    def digits(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The dtmf digits.
        """
        return pulumi.get(self, "digits")

    @digits.setter
    def digits(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "digits", value)

    @_builtins.property
    @pulumi.getter(name="finishDigit")
    def finish_digit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The finish digit (if any).
        """
        return pulumi.get(self, "finish_digit")

    @finish_digit.setter
    def finish_digit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "finish_digit", value)


if not MYPY:
    class CxTestCaseTestCaseConversationTurnUserInputInputEventArgsDict(TypedDict):
        event: pulumi.Input[_builtins.str]
        """
        Name of the event.
        """
elif False:
    CxTestCaseTestCaseConversationTurnUserInputInputEventArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseTestCaseConversationTurnUserInputInputEventArgs:
    def __init__(__self__, *,
                 event: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] event: Name of the event.
        """
        pulumi.set(__self__, "event", event)

    @_builtins.property
    @pulumi.getter
    def event(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the event.
        """
        return pulumi.get(self, "event")

    @event.setter
    def event(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event", value)


if not MYPY:
    class CxTestCaseTestCaseConversationTurnUserInputInputTextArgsDict(TypedDict):
        text: pulumi.Input[_builtins.str]
        """
        The natural language text to be processed. Text length must not exceed 256 characters.
        """
elif False:
    CxTestCaseTestCaseConversationTurnUserInputInputTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseTestCaseConversationTurnUserInputInputTextArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] text: The natural language text to be processed. Text length must not exceed 256 characters.
        """
        pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        """
        The natural language text to be processed. Text length must not exceed 256 characters.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)


if not MYPY:
    class CxTestCaseTestCaseConversationTurnVirtualAgentOutputArgsDict(TypedDict):
        current_page: NotRequired[pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPageArgsDict']]
        """
        The [Page](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.flows.pages#Page) on which the utterance was spoken.
        Structure is documented below.
        """
        session_parameters: NotRequired[pulumi.Input[_builtins.str]]
        """
        The session parameters available to the bot at this point.
        """
        text_responses: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputTextResponseArgsDict']]]]
        """
        The text responses from the agent for the turn.
        Structure is documented below.
        """
        triggered_intent: NotRequired[pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntentArgsDict']]
        """
        The [Intent](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.intents#Intent) that triggered the response.
        Structure is documented below.
        """
elif False:
    CxTestCaseTestCaseConversationTurnVirtualAgentOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseTestCaseConversationTurnVirtualAgentOutputArgs:
    def __init__(__self__, *,
                 current_page: Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPageArgs']] = None,
                 session_parameters: Optional[pulumi.Input[_builtins.str]] = None,
                 text_responses: Optional[pulumi.Input[Sequence[pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputTextResponseArgs']]]] = None,
                 triggered_intent: Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntentArgs']] = None):
        """
        :param pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPageArgs'] current_page: The [Page](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.flows.pages#Page) on which the utterance was spoken.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] session_parameters: The session parameters available to the bot at this point.
        :param pulumi.Input[Sequence[pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputTextResponseArgs']]] text_responses: The text responses from the agent for the turn.
               Structure is documented below.
        :param pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntentArgs'] triggered_intent: The [Intent](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.intents#Intent) that triggered the response.
               Structure is documented below.
        """
        if current_page is not None:
            pulumi.set(__self__, "current_page", current_page)
        if session_parameters is not None:
            pulumi.set(__self__, "session_parameters", session_parameters)
        if text_responses is not None:
            pulumi.set(__self__, "text_responses", text_responses)
        if triggered_intent is not None:
            pulumi.set(__self__, "triggered_intent", triggered_intent)

    @_builtins.property
    @pulumi.getter(name="currentPage")
    def current_page(self) -> Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPageArgs']]:
        """
        The [Page](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.flows.pages#Page) on which the utterance was spoken.
        Structure is documented below.
        """
        return pulumi.get(self, "current_page")

    @current_page.setter
    def current_page(self, value: Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPageArgs']]):
        pulumi.set(self, "current_page", value)

    @_builtins.property
    @pulumi.getter(name="sessionParameters")
    def session_parameters(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The session parameters available to the bot at this point.
        """
        return pulumi.get(self, "session_parameters")

    @session_parameters.setter
    def session_parameters(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "session_parameters", value)

    @_builtins.property
    @pulumi.getter(name="textResponses")
    def text_responses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputTextResponseArgs']]]]:
        """
        The text responses from the agent for the turn.
        Structure is documented below.
        """
        return pulumi.get(self, "text_responses")

    @text_responses.setter
    def text_responses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputTextResponseArgs']]]]):
        pulumi.set(self, "text_responses", value)

    @_builtins.property
    @pulumi.getter(name="triggeredIntent")
    def triggered_intent(self) -> Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntentArgs']]:
        """
        The [Intent](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.intents#Intent) that triggered the response.
        Structure is documented below.
        """
        return pulumi.get(self, "triggered_intent")

    @triggered_intent.setter
    def triggered_intent(self, value: Optional[pulumi.Input['CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntentArgs']]):
        pulumi.set(self, "triggered_intent", value)


if not MYPY:
    class CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPageArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The human-readable name of the page, unique within the flow.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier of the page.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
elif False:
    CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseTestCaseConversationTurnVirtualAgentOutputCurrentPageArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Output)
               The human-readable name of the page, unique within the flow.
        :param pulumi.Input[_builtins.str] name: The unique identifier of the page.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The human-readable name of the page, unique within the flow.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier of the page.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CxTestCaseTestCaseConversationTurnVirtualAgentOutputTextResponseArgsDict(TypedDict):
        texts: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A collection of text responses.
        """
elif False:
    CxTestCaseTestCaseConversationTurnVirtualAgentOutputTextResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseTestCaseConversationTurnVirtualAgentOutputTextResponseArgs:
    def __init__(__self__, *,
                 texts: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] texts: A collection of text responses.
        """
        if texts is not None:
            pulumi.set(__self__, "texts", texts)

    @_builtins.property
    @pulumi.getter
    def texts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A collection of text responses.
        """
        return pulumi.get(self, "texts")

    @texts.setter
    def texts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "texts", value)


if not MYPY:
    class CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntentArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The human-readable name of the intent, unique within the agent.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier of the intent.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>.
        """
elif False:
    CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseTestCaseConversationTurnVirtualAgentOutputTriggeredIntentArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: (Output)
               The human-readable name of the intent, unique within the agent.
        :param pulumi.Input[_builtins.str] name: The unique identifier of the intent.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The human-readable name of the intent, unique within the agent.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier of the intent.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/intents/<Intent ID>.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class CxTestCaseTestConfigArgsDict(TypedDict):
        flow: NotRequired[pulumi.Input[_builtins.str]]
        """
        Flow name to start the test case with.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        Only one of flow and page should be set to indicate the starting point of the test case. If neither is set, the test case will start with start page on the default start flow.
        """
        page: NotRequired[pulumi.Input[_builtins.str]]
        """
        The page to start the test case with.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        Only one of flow and page should be set to indicate the starting point of the test case. If neither is set, the test case will start with start page on the default start flow.
        """
        tracking_parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Session parameters to be compared when calculating differences.
        """
elif False:
    CxTestCaseTestConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxTestCaseTestConfigArgs:
    def __init__(__self__, *,
                 flow: Optional[pulumi.Input[_builtins.str]] = None,
                 page: Optional[pulumi.Input[_builtins.str]] = None,
                 tracking_parameters: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] flow: Flow name to start the test case with.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
               Only one of flow and page should be set to indicate the starting point of the test case. If neither is set, the test case will start with start page on the default start flow.
        :param pulumi.Input[_builtins.str] page: The page to start the test case with.
               Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
               Only one of flow and page should be set to indicate the starting point of the test case. If neither is set, the test case will start with start page on the default start flow.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tracking_parameters: Session parameters to be compared when calculating differences.
        """
        if flow is not None:
            pulumi.set(__self__, "flow", flow)
        if page is not None:
            pulumi.set(__self__, "page", page)
        if tracking_parameters is not None:
            pulumi.set(__self__, "tracking_parameters", tracking_parameters)

    @_builtins.property
    @pulumi.getter
    def flow(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Flow name to start the test case with.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>.
        Only one of flow and page should be set to indicate the starting point of the test case. If neither is set, the test case will start with start page on the default start flow.
        """
        return pulumi.get(self, "flow")

    @flow.setter
    def flow(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flow", value)

    @_builtins.property
    @pulumi.getter
    def page(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The page to start the test case with.
        Format: projects/<Project ID>/locations/<Location ID>/agents/<Agent ID>/flows/<Flow ID>/pages/<Page ID>.
        Only one of flow and page should be set to indicate the starting point of the test case. If neither is set, the test case will start with start page on the default start flow.
        """
        return pulumi.get(self, "page")

    @page.setter
    def page(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "page", value)

    @_builtins.property
    @pulumi.getter(name="trackingParameters")
    def tracking_parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Session parameters to be compared when calculating differences.
        """
        return pulumi.get(self, "tracking_parameters")

    @tracking_parameters.setter
    def tracking_parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tracking_parameters", value)


if not MYPY:
    class CxToolConnectorSpecArgsDict(TypedDict):
        actions: pulumi.Input[Sequence[pulumi.Input['CxToolConnectorSpecActionArgsDict']]]
        """
        Actions for the tool to use.
        Structure is documented below.
        """
        name: pulumi.Input[_builtins.str]
        """
        The full resource name of the referenced Integration Connectors Connection.
        Format: projects/*/locations/*/connections/*
        """
        end_user_auth_config: NotRequired[pulumi.Input['CxToolConnectorSpecEndUserAuthConfigArgsDict']]
        """
        Integration Connectors end-user authentication configuration.
        If configured, the end-user authentication fields will be passed in the Integration Connectors API request
        and override the admin, default authentication configured for the Connection.
        Note: The Connection must have authentication override enabled in order to specify an EUC configuration here - otherwise,
        the ConnectorTool creation will fail.
        See: https://cloud.google.com/application-integration/docs/configure-connectors-task#configure-authentication-override        properties:
        Structure is documented below.
        """
elif False:
    CxToolConnectorSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxToolConnectorSpecArgs:
    def __init__(__self__, *,
                 actions: pulumi.Input[Sequence[pulumi.Input['CxToolConnectorSpecActionArgs']]],
                 name: pulumi.Input[_builtins.str],
                 end_user_auth_config: Optional[pulumi.Input['CxToolConnectorSpecEndUserAuthConfigArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CxToolConnectorSpecActionArgs']]] actions: Actions for the tool to use.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] name: The full resource name of the referenced Integration Connectors Connection.
               Format: projects/*/locations/*/connections/*
        :param pulumi.Input['CxToolConnectorSpecEndUserAuthConfigArgs'] end_user_auth_config: Integration Connectors end-user authentication configuration.
               If configured, the end-user authentication fields will be passed in the Integration Connectors API request
               and override the admin, default authentication configured for the Connection.
               Note: The Connection must have authentication override enabled in order to specify an EUC configuration here - otherwise,
               the ConnectorTool creation will fail.
               See: https://cloud.google.com/application-integration/docs/configure-connectors-task#configure-authentication-override        properties:
               Structure is documented below.
        """
        pulumi.set(__self__, "actions", actions)
        pulumi.set(__self__, "name", name)
        if end_user_auth_config is not None:
            pulumi.set(__self__, "end_user_auth_config", end_user_auth_config)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> pulumi.Input[Sequence[pulumi.Input['CxToolConnectorSpecActionArgs']]]:
        """
        Actions for the tool to use.
        Structure is documented below.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: pulumi.Input[Sequence[pulumi.Input['CxToolConnectorSpecActionArgs']]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The full resource name of the referenced Integration Connectors Connection.
        Format: projects/*/locations/*/connections/*
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="endUserAuthConfig")
    def end_user_auth_config(self) -> Optional[pulumi.Input['CxToolConnectorSpecEndUserAuthConfigArgs']]:
        """
        Integration Connectors end-user authentication configuration.
        If configured, the end-user authentication fields will be passed in the Integration Connectors API request
        and override the admin, default authentication configured for the Connection.
        Note: The Connection must have authentication override enabled in order to specify an EUC configuration here - otherwise,
        the ConnectorTool creation will fail.
        See: https://cloud.google.com/application-integration/docs/configure-connectors-task#configure-authentication-override        properties:
        Structure is documented below.
        """
        return pulumi.get(self, "end_user_auth_config")

    @end_user_auth_config.setter
    def end_user_auth_config(self, value: Optional[pulumi.Input['CxToolConnectorSpecEndUserAuthConfigArgs']]):
        pulumi.set(self, "end_user_auth_config", value)


if not MYPY:
    class CxToolConnectorSpecActionArgsDict(TypedDict):
        connection_action_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        ID of a Connection action for the tool to use. This field is part of a required union field `action_spec`.
        """
        entity_operation: NotRequired[pulumi.Input['CxToolConnectorSpecActionEntityOperationArgsDict']]
        """
        Entity operation configuration for the tool to use. This field is part of a required union field `action_spec`.
        Structure is documented below.
        """
        input_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Entity fields to use as inputs for the operation.
        If no fields are specified, all fields of the Entity will be used.
        """
        output_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Entity fields to return from the operation.
        If no fields are specified, all fields of the Entity will be returned.
        """
elif False:
    CxToolConnectorSpecActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxToolConnectorSpecActionArgs:
    def __init__(__self__, *,
                 connection_action_id: Optional[pulumi.Input[_builtins.str]] = None,
                 entity_operation: Optional[pulumi.Input['CxToolConnectorSpecActionEntityOperationArgs']] = None,
                 input_fields: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 output_fields: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] connection_action_id: ID of a Connection action for the tool to use. This field is part of a required union field `action_spec`.
        :param pulumi.Input['CxToolConnectorSpecActionEntityOperationArgs'] entity_operation: Entity operation configuration for the tool to use. This field is part of a required union field `action_spec`.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] input_fields: Entity fields to use as inputs for the operation.
               If no fields are specified, all fields of the Entity will be used.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] output_fields: Entity fields to return from the operation.
               If no fields are specified, all fields of the Entity will be returned.
        """
        if connection_action_id is not None:
            pulumi.set(__self__, "connection_action_id", connection_action_id)
        if entity_operation is not None:
            pulumi.set(__self__, "entity_operation", entity_operation)
        if input_fields is not None:
            pulumi.set(__self__, "input_fields", input_fields)
        if output_fields is not None:
            pulumi.set(__self__, "output_fields", output_fields)

    @_builtins.property
    @pulumi.getter(name="connectionActionId")
    def connection_action_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ID of a Connection action for the tool to use. This field is part of a required union field `action_spec`.
        """
        return pulumi.get(self, "connection_action_id")

    @connection_action_id.setter
    def connection_action_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "connection_action_id", value)

    @_builtins.property
    @pulumi.getter(name="entityOperation")
    def entity_operation(self) -> Optional[pulumi.Input['CxToolConnectorSpecActionEntityOperationArgs']]:
        """
        Entity operation configuration for the tool to use. This field is part of a required union field `action_spec`.
        Structure is documented below.
        """
        return pulumi.get(self, "entity_operation")

    @entity_operation.setter
    def entity_operation(self, value: Optional[pulumi.Input['CxToolConnectorSpecActionEntityOperationArgs']]):
        pulumi.set(self, "entity_operation", value)

    @_builtins.property
    @pulumi.getter(name="inputFields")
    def input_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Entity fields to use as inputs for the operation.
        If no fields are specified, all fields of the Entity will be used.
        """
        return pulumi.get(self, "input_fields")

    @input_fields.setter
    def input_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "input_fields", value)

    @_builtins.property
    @pulumi.getter(name="outputFields")
    def output_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Entity fields to return from the operation.
        If no fields are specified, all fields of the Entity will be returned.
        """
        return pulumi.get(self, "output_fields")

    @output_fields.setter
    def output_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "output_fields", value)


if not MYPY:
    class CxToolConnectorSpecActionEntityOperationArgsDict(TypedDict):
        entity_id: pulumi.Input[_builtins.str]
        """
        ID of the entity.
        """
        operation: pulumi.Input[_builtins.str]
        """
        The operation to perform on the entity.
        Possible values are: `LIST`, `CREATE`, `UPDATE`, `DELETE`, `GET`.
        """
elif False:
    CxToolConnectorSpecActionEntityOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxToolConnectorSpecActionEntityOperationArgs:
    def __init__(__self__, *,
                 entity_id: pulumi.Input[_builtins.str],
                 operation: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] entity_id: ID of the entity.
        :param pulumi.Input[_builtins.str] operation: The operation to perform on the entity.
               Possible values are: `LIST`, `CREATE`, `UPDATE`, `DELETE`, `GET`.
        """
        pulumi.set(__self__, "entity_id", entity_id)
        pulumi.set(__self__, "operation", operation)

    @_builtins.property
    @pulumi.getter(name="entityId")
    def entity_id(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the entity.
        """
        return pulumi.get(self, "entity_id")

    @entity_id.setter
    def entity_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "entity_id", value)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> pulumi.Input[_builtins.str]:
        """
        The operation to perform on the entity.
        Possible values are: `LIST`, `CREATE`, `UPDATE`, `DELETE`, `GET`.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "operation", value)


if not MYPY:
    class CxToolConnectorSpecEndUserAuthConfigArgsDict(TypedDict):
        oauth2_auth_code_config: NotRequired[pulumi.Input['CxToolConnectorSpecEndUserAuthConfigOauth2AuthCodeConfigArgsDict']]
        """
        Oauth 2.0 Authorization Code authentication. This field is part of a union field `end_user_auth_config`. Only one of `oauth2AuthCodeConfig` or `oauth2JwtBearerConfig` may be set.
        Structure is documented below.
        """
        oauth2_jwt_bearer_config: NotRequired[pulumi.Input['CxToolConnectorSpecEndUserAuthConfigOauth2JwtBearerConfigArgsDict']]
        """
        JWT Profile Oauth 2.0 Authorization Grant authentication.. This field is part of a union field `end_user_auth_config`. Only one of `oauth2AuthCodeConfig` or `oauth2JwtBearerConfig` may be set.
        Structure is documented below.


        <a name="nested_connector_spec_end_user_auth_config_oauth2_auth_code_config"></a>The `oauth2_auth_code_config` block supports:
        """
elif False:
    CxToolConnectorSpecEndUserAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxToolConnectorSpecEndUserAuthConfigArgs:
    def __init__(__self__, *,
                 oauth2_auth_code_config: Optional[pulumi.Input['CxToolConnectorSpecEndUserAuthConfigOauth2AuthCodeConfigArgs']] = None,
                 oauth2_jwt_bearer_config: Optional[pulumi.Input['CxToolConnectorSpecEndUserAuthConfigOauth2JwtBearerConfigArgs']] = None):
        """
        :param pulumi.Input['CxToolConnectorSpecEndUserAuthConfigOauth2AuthCodeConfigArgs'] oauth2_auth_code_config: Oauth 2.0 Authorization Code authentication. This field is part of a union field `end_user_auth_config`. Only one of `oauth2AuthCodeConfig` or `oauth2JwtBearerConfig` may be set.
               Structure is documented below.
        :param pulumi.Input['CxToolConnectorSpecEndUserAuthConfigOauth2JwtBearerConfigArgs'] oauth2_jwt_bearer_config: JWT Profile Oauth 2.0 Authorization Grant authentication.. This field is part of a union field `end_user_auth_config`. Only one of `oauth2AuthCodeConfig` or `oauth2JwtBearerConfig` may be set.
               Structure is documented below.
               
               
               <a name="nested_connector_spec_end_user_auth_config_oauth2_auth_code_config"></a>The `oauth2_auth_code_config` block supports:
        """
        if oauth2_auth_code_config is not None:
            pulumi.set(__self__, "oauth2_auth_code_config", oauth2_auth_code_config)
        if oauth2_jwt_bearer_config is not None:
            pulumi.set(__self__, "oauth2_jwt_bearer_config", oauth2_jwt_bearer_config)

    @_builtins.property
    @pulumi.getter(name="oauth2AuthCodeConfig")
    def oauth2_auth_code_config(self) -> Optional[pulumi.Input['CxToolConnectorSpecEndUserAuthConfigOauth2AuthCodeConfigArgs']]:
        """
        Oauth 2.0 Authorization Code authentication. This field is part of a union field `end_user_auth_config`. Only one of `oauth2AuthCodeConfig` or `oauth2JwtBearerConfig` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "oauth2_auth_code_config")

    @oauth2_auth_code_config.setter
    def oauth2_auth_code_config(self, value: Optional[pulumi.Input['CxToolConnectorSpecEndUserAuthConfigOauth2AuthCodeConfigArgs']]):
        pulumi.set(self, "oauth2_auth_code_config", value)

    @_builtins.property
    @pulumi.getter(name="oauth2JwtBearerConfig")
    def oauth2_jwt_bearer_config(self) -> Optional[pulumi.Input['CxToolConnectorSpecEndUserAuthConfigOauth2JwtBearerConfigArgs']]:
        """
        JWT Profile Oauth 2.0 Authorization Grant authentication.. This field is part of a union field `end_user_auth_config`. Only one of `oauth2AuthCodeConfig` or `oauth2JwtBearerConfig` may be set.
        Structure is documented below.


        <a name="nested_connector_spec_end_user_auth_config_oauth2_auth_code_config"></a>The `oauth2_auth_code_config` block supports:
        """
        return pulumi.get(self, "oauth2_jwt_bearer_config")

    @oauth2_jwt_bearer_config.setter
    def oauth2_jwt_bearer_config(self, value: Optional[pulumi.Input['CxToolConnectorSpecEndUserAuthConfigOauth2JwtBearerConfigArgs']]):
        pulumi.set(self, "oauth2_jwt_bearer_config", value)


if not MYPY:
    class CxToolConnectorSpecEndUserAuthConfigOauth2AuthCodeConfigArgsDict(TypedDict):
        oauth_token: pulumi.Input[_builtins.str]
        """
        Oauth token value or parameter name to pass it through.
        """
elif False:
    CxToolConnectorSpecEndUserAuthConfigOauth2AuthCodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxToolConnectorSpecEndUserAuthConfigOauth2AuthCodeConfigArgs:
    def __init__(__self__, *,
                 oauth_token: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] oauth_token: Oauth token value or parameter name to pass it through.
        """
        pulumi.set(__self__, "oauth_token", oauth_token)

    @_builtins.property
    @pulumi.getter(name="oauthToken")
    def oauth_token(self) -> pulumi.Input[_builtins.str]:
        """
        Oauth token value or parameter name to pass it through.
        """
        return pulumi.get(self, "oauth_token")

    @oauth_token.setter
    def oauth_token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oauth_token", value)


if not MYPY:
    class CxToolConnectorSpecEndUserAuthConfigOauth2JwtBearerConfigArgsDict(TypedDict):
        client_key: pulumi.Input[_builtins.str]
        """
        Client key value or parameter name to pass it through.
        """
        issuer: pulumi.Input[_builtins.str]
        """
        Issuer value or parameter name to pass it through.
        """
        subject: pulumi.Input[_builtins.str]
        """
        Subject value or parameter name to pass it through.
        """
elif False:
    CxToolConnectorSpecEndUserAuthConfigOauth2JwtBearerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxToolConnectorSpecEndUserAuthConfigOauth2JwtBearerConfigArgs:
    def __init__(__self__, *,
                 client_key: pulumi.Input[_builtins.str],
                 issuer: pulumi.Input[_builtins.str],
                 subject: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] client_key: Client key value or parameter name to pass it through.
        :param pulumi.Input[_builtins.str] issuer: Issuer value or parameter name to pass it through.
        :param pulumi.Input[_builtins.str] subject: Subject value or parameter name to pass it through.
        """
        pulumi.set(__self__, "client_key", client_key)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "subject", subject)

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> pulumi.Input[_builtins.str]:
        """
        Client key value or parameter name to pass it through.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_key", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> pulumi.Input[_builtins.str]:
        """
        Issuer value or parameter name to pass it through.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> pulumi.Input[_builtins.str]:
        """
        Subject value or parameter name to pass it through.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subject", value)


if not MYPY:
    class CxToolDataStoreSpecArgsDict(TypedDict):
        data_store_connections: pulumi.Input[Sequence[pulumi.Input['CxToolDataStoreSpecDataStoreConnectionArgsDict']]]
        """
        List of data stores to search.
        Structure is documented below.
        """
        fallback_prompt: pulumi.Input['CxToolDataStoreSpecFallbackPromptArgsDict']
        """
        Fallback prompt configurations to use.
        """
elif False:
    CxToolDataStoreSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxToolDataStoreSpecArgs:
    def __init__(__self__, *,
                 data_store_connections: pulumi.Input[Sequence[pulumi.Input['CxToolDataStoreSpecDataStoreConnectionArgs']]],
                 fallback_prompt: pulumi.Input['CxToolDataStoreSpecFallbackPromptArgs']):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CxToolDataStoreSpecDataStoreConnectionArgs']]] data_store_connections: List of data stores to search.
               Structure is documented below.
        :param pulumi.Input['CxToolDataStoreSpecFallbackPromptArgs'] fallback_prompt: Fallback prompt configurations to use.
        """
        pulumi.set(__self__, "data_store_connections", data_store_connections)
        pulumi.set(__self__, "fallback_prompt", fallback_prompt)

    @_builtins.property
    @pulumi.getter(name="dataStoreConnections")
    def data_store_connections(self) -> pulumi.Input[Sequence[pulumi.Input['CxToolDataStoreSpecDataStoreConnectionArgs']]]:
        """
        List of data stores to search.
        Structure is documented below.
        """
        return pulumi.get(self, "data_store_connections")

    @data_store_connections.setter
    def data_store_connections(self, value: pulumi.Input[Sequence[pulumi.Input['CxToolDataStoreSpecDataStoreConnectionArgs']]]):
        pulumi.set(self, "data_store_connections", value)

    @_builtins.property
    @pulumi.getter(name="fallbackPrompt")
    def fallback_prompt(self) -> pulumi.Input['CxToolDataStoreSpecFallbackPromptArgs']:
        """
        Fallback prompt configurations to use.
        """
        return pulumi.get(self, "fallback_prompt")

    @fallback_prompt.setter
    def fallback_prompt(self, value: pulumi.Input['CxToolDataStoreSpecFallbackPromptArgs']):
        pulumi.set(self, "fallback_prompt", value)


if not MYPY:
    class CxToolDataStoreSpecDataStoreConnectionArgsDict(TypedDict):
        data_store: NotRequired[pulumi.Input[_builtins.str]]
        """
        The full name of the referenced data store. Formats: projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore} projects/{project}/locations/{location}/dataStores/{dataStore}
        """
        data_store_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the connected data store.
        See [DataStoreType](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/DataStoreConnection#datastoretype) for valid values.
        """
        document_processing_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        The document processing mode for the data store connection. Should only be set for PUBLIC_WEB and UNSTRUCTURED data stores. If not set it is considered as DOCUMENTS, as this is the legacy mode.
        See [DocumentProcessingMode](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/DataStoreConnection#documentprocessingmode) for valid values.
        """
elif False:
    CxToolDataStoreSpecDataStoreConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxToolDataStoreSpecDataStoreConnectionArgs:
    def __init__(__self__, *,
                 data_store: Optional[pulumi.Input[_builtins.str]] = None,
                 data_store_type: Optional[pulumi.Input[_builtins.str]] = None,
                 document_processing_mode: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] data_store: The full name of the referenced data store. Formats: projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore} projects/{project}/locations/{location}/dataStores/{dataStore}
        :param pulumi.Input[_builtins.str] data_store_type: The type of the connected data store.
               See [DataStoreType](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/DataStoreConnection#datastoretype) for valid values.
        :param pulumi.Input[_builtins.str] document_processing_mode: The document processing mode for the data store connection. Should only be set for PUBLIC_WEB and UNSTRUCTURED data stores. If not set it is considered as DOCUMENTS, as this is the legacy mode.
               See [DocumentProcessingMode](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/DataStoreConnection#documentprocessingmode) for valid values.
        """
        if data_store is not None:
            pulumi.set(__self__, "data_store", data_store)
        if data_store_type is not None:
            pulumi.set(__self__, "data_store_type", data_store_type)
        if document_processing_mode is not None:
            pulumi.set(__self__, "document_processing_mode", document_processing_mode)

    @_builtins.property
    @pulumi.getter(name="dataStore")
    def data_store(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The full name of the referenced data store. Formats: projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore} projects/{project}/locations/{location}/dataStores/{dataStore}
        """
        return pulumi.get(self, "data_store")

    @data_store.setter
    def data_store(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_store", value)

    @_builtins.property
    @pulumi.getter(name="dataStoreType")
    def data_store_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the connected data store.
        See [DataStoreType](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/DataStoreConnection#datastoretype) for valid values.
        """
        return pulumi.get(self, "data_store_type")

    @data_store_type.setter
    def data_store_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_store_type", value)

    @_builtins.property
    @pulumi.getter(name="documentProcessingMode")
    def document_processing_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The document processing mode for the data store connection. Should only be set for PUBLIC_WEB and UNSTRUCTURED data stores. If not set it is considered as DOCUMENTS, as this is the legacy mode.
        See [DocumentProcessingMode](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/DataStoreConnection#documentprocessingmode) for valid values.
        """
        return pulumi.get(self, "document_processing_mode")

    @document_processing_mode.setter
    def document_processing_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "document_processing_mode", value)


if not MYPY:
    class CxToolDataStoreSpecFallbackPromptArgsDict(TypedDict):
        pass
elif False:
    CxToolDataStoreSpecFallbackPromptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxToolDataStoreSpecFallbackPromptArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class CxToolFunctionSpecArgsDict(TypedDict):
        input_schema: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. The JSON schema is encapsulated in a [google.protobuf.Struct](https://protobuf.dev/reference/protobuf/google.protobuf/#struct) to describe the input of the function.
        This input is a JSON object that contains the function's parameters as properties of the object
        """
        output_schema: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. The JSON schema is encapsulated in a [google.protobuf.Struct](https://protobuf.dev/reference/protobuf/google.protobuf/#struct) to describe the output of the function.
        This output is a JSON object that contains the function's parameters as properties of the object
        """
elif False:
    CxToolFunctionSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxToolFunctionSpecArgs:
    def __init__(__self__, *,
                 input_schema: Optional[pulumi.Input[_builtins.str]] = None,
                 output_schema: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] input_schema: Optional. The JSON schema is encapsulated in a [google.protobuf.Struct](https://protobuf.dev/reference/protobuf/google.protobuf/#struct) to describe the input of the function.
               This input is a JSON object that contains the function's parameters as properties of the object
        :param pulumi.Input[_builtins.str] output_schema: Optional. The JSON schema is encapsulated in a [google.protobuf.Struct](https://protobuf.dev/reference/protobuf/google.protobuf/#struct) to describe the output of the function.
               This output is a JSON object that contains the function's parameters as properties of the object
        """
        if input_schema is not None:
            pulumi.set(__self__, "input_schema", input_schema)
        if output_schema is not None:
            pulumi.set(__self__, "output_schema", output_schema)

    @_builtins.property
    @pulumi.getter(name="inputSchema")
    def input_schema(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. The JSON schema is encapsulated in a [google.protobuf.Struct](https://protobuf.dev/reference/protobuf/google.protobuf/#struct) to describe the input of the function.
        This input is a JSON object that contains the function's parameters as properties of the object
        """
        return pulumi.get(self, "input_schema")

    @input_schema.setter
    def input_schema(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "input_schema", value)

    @_builtins.property
    @pulumi.getter(name="outputSchema")
    def output_schema(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. The JSON schema is encapsulated in a [google.protobuf.Struct](https://protobuf.dev/reference/protobuf/google.protobuf/#struct) to describe the output of the function.
        This output is a JSON object that contains the function's parameters as properties of the object
        """
        return pulumi.get(self, "output_schema")

    @output_schema.setter
    def output_schema(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_schema", value)


if not MYPY:
    class CxToolOpenApiSpecArgsDict(TypedDict):
        text_schema: pulumi.Input[_builtins.str]
        """
        The OpenAPI schema specified as a text.
        This field is part of a union field `schema`: only one of `textSchema` may be set.
        """
        authentication: NotRequired[pulumi.Input['CxToolOpenApiSpecAuthenticationArgsDict']]
        """
        Optional. Authentication information required by the API.
        Structure is documented below.
        """
        service_directory_config: NotRequired[pulumi.Input['CxToolOpenApiSpecServiceDirectoryConfigArgsDict']]
        """
        Optional. Service Directory configuration.
        Structure is documented below.
        """
        tls_config: NotRequired[pulumi.Input['CxToolOpenApiSpecTlsConfigArgsDict']]
        """
        Optional. TLS configuration for the HTTPS verification.
        Structure is documented below.
        """
elif False:
    CxToolOpenApiSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxToolOpenApiSpecArgs:
    def __init__(__self__, *,
                 text_schema: pulumi.Input[_builtins.str],
                 authentication: Optional[pulumi.Input['CxToolOpenApiSpecAuthenticationArgs']] = None,
                 service_directory_config: Optional[pulumi.Input['CxToolOpenApiSpecServiceDirectoryConfigArgs']] = None,
                 tls_config: Optional[pulumi.Input['CxToolOpenApiSpecTlsConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] text_schema: The OpenAPI schema specified as a text.
               This field is part of a union field `schema`: only one of `textSchema` may be set.
        :param pulumi.Input['CxToolOpenApiSpecAuthenticationArgs'] authentication: Optional. Authentication information required by the API.
               Structure is documented below.
        :param pulumi.Input['CxToolOpenApiSpecServiceDirectoryConfigArgs'] service_directory_config: Optional. Service Directory configuration.
               Structure is documented below.
        :param pulumi.Input['CxToolOpenApiSpecTlsConfigArgs'] tls_config: Optional. TLS configuration for the HTTPS verification.
               Structure is documented below.
        """
        pulumi.set(__self__, "text_schema", text_schema)
        if authentication is not None:
            pulumi.set(__self__, "authentication", authentication)
        if service_directory_config is not None:
            pulumi.set(__self__, "service_directory_config", service_directory_config)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)

    @_builtins.property
    @pulumi.getter(name="textSchema")
    def text_schema(self) -> pulumi.Input[_builtins.str]:
        """
        The OpenAPI schema specified as a text.
        This field is part of a union field `schema`: only one of `textSchema` may be set.
        """
        return pulumi.get(self, "text_schema")

    @text_schema.setter
    def text_schema(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text_schema", value)

    @_builtins.property
    @pulumi.getter
    def authentication(self) -> Optional[pulumi.Input['CxToolOpenApiSpecAuthenticationArgs']]:
        """
        Optional. Authentication information required by the API.
        Structure is documented below.
        """
        return pulumi.get(self, "authentication")

    @authentication.setter
    def authentication(self, value: Optional[pulumi.Input['CxToolOpenApiSpecAuthenticationArgs']]):
        pulumi.set(self, "authentication", value)

    @_builtins.property
    @pulumi.getter(name="serviceDirectoryConfig")
    def service_directory_config(self) -> Optional[pulumi.Input['CxToolOpenApiSpecServiceDirectoryConfigArgs']]:
        """
        Optional. Service Directory configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "service_directory_config")

    @service_directory_config.setter
    def service_directory_config(self, value: Optional[pulumi.Input['CxToolOpenApiSpecServiceDirectoryConfigArgs']]):
        pulumi.set(self, "service_directory_config", value)

    @_builtins.property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional[pulumi.Input['CxToolOpenApiSpecTlsConfigArgs']]:
        """
        Optional. TLS configuration for the HTTPS verification.
        Structure is documented below.
        """
        return pulumi.get(self, "tls_config")

    @tls_config.setter
    def tls_config(self, value: Optional[pulumi.Input['CxToolOpenApiSpecTlsConfigArgs']]):
        pulumi.set(self, "tls_config", value)


if not MYPY:
    class CxToolOpenApiSpecAuthenticationArgsDict(TypedDict):
        api_key_config: NotRequired[pulumi.Input['CxToolOpenApiSpecAuthenticationApiKeyConfigArgsDict']]
        """
        Config for API key auth.
        This field is part of a union field `auth_config`: Only one of `apiKeyConfig`, `oauthConfig`, `serviceAgentAuthConfig`, or `bearerTokenConfig` may be set.
        Structure is documented below.
        """
        bearer_token_config: NotRequired[pulumi.Input['CxToolOpenApiSpecAuthenticationBearerTokenConfigArgsDict']]
        """
        Config for bearer token auth.
        This field is part of a union field `auth_config`: Only one of `apiKeyConfig`, `oauthConfig`, `serviceAgentAuthConfig`, or `bearerTokenConfig` may be set.
        Structure is documented below.
        """
        oauth_config: NotRequired[pulumi.Input['CxToolOpenApiSpecAuthenticationOauthConfigArgsDict']]
        """
        Config for OAuth.
        This field is part of a union field `auth_config`: Only one of `apiKeyConfig`, `oauthConfig`, `serviceAgentAuthConfig`, or `bearerTokenConfig` may be set.
        Structure is documented below.
        """
        service_agent_auth_config: NotRequired[pulumi.Input['CxToolOpenApiSpecAuthenticationServiceAgentAuthConfigArgsDict']]
        """
        Config for [Diglogflow service agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent) auth.
        This field is part of a union field `auth_config`: Only one of `apiKeyConfig`, `oauthConfig`, `serviceAgentAuthConfig`, or `bearerTokenConfig` may be set.
        Structure is documented below.
        """
elif False:
    CxToolOpenApiSpecAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxToolOpenApiSpecAuthenticationArgs:
    def __init__(__self__, *,
                 api_key_config: Optional[pulumi.Input['CxToolOpenApiSpecAuthenticationApiKeyConfigArgs']] = None,
                 bearer_token_config: Optional[pulumi.Input['CxToolOpenApiSpecAuthenticationBearerTokenConfigArgs']] = None,
                 oauth_config: Optional[pulumi.Input['CxToolOpenApiSpecAuthenticationOauthConfigArgs']] = None,
                 service_agent_auth_config: Optional[pulumi.Input['CxToolOpenApiSpecAuthenticationServiceAgentAuthConfigArgs']] = None):
        """
        :param pulumi.Input['CxToolOpenApiSpecAuthenticationApiKeyConfigArgs'] api_key_config: Config for API key auth.
               This field is part of a union field `auth_config`: Only one of `apiKeyConfig`, `oauthConfig`, `serviceAgentAuthConfig`, or `bearerTokenConfig` may be set.
               Structure is documented below.
        :param pulumi.Input['CxToolOpenApiSpecAuthenticationBearerTokenConfigArgs'] bearer_token_config: Config for bearer token auth.
               This field is part of a union field `auth_config`: Only one of `apiKeyConfig`, `oauthConfig`, `serviceAgentAuthConfig`, or `bearerTokenConfig` may be set.
               Structure is documented below.
        :param pulumi.Input['CxToolOpenApiSpecAuthenticationOauthConfigArgs'] oauth_config: Config for OAuth.
               This field is part of a union field `auth_config`: Only one of `apiKeyConfig`, `oauthConfig`, `serviceAgentAuthConfig`, or `bearerTokenConfig` may be set.
               Structure is documented below.
        :param pulumi.Input['CxToolOpenApiSpecAuthenticationServiceAgentAuthConfigArgs'] service_agent_auth_config: Config for [Diglogflow service agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent) auth.
               This field is part of a union field `auth_config`: Only one of `apiKeyConfig`, `oauthConfig`, `serviceAgentAuthConfig`, or `bearerTokenConfig` may be set.
               Structure is documented below.
        """
        if api_key_config is not None:
            pulumi.set(__self__, "api_key_config", api_key_config)
        if bearer_token_config is not None:
            pulumi.set(__self__, "bearer_token_config", bearer_token_config)
        if oauth_config is not None:
            pulumi.set(__self__, "oauth_config", oauth_config)
        if service_agent_auth_config is not None:
            pulumi.set(__self__, "service_agent_auth_config", service_agent_auth_config)

    @_builtins.property
    @pulumi.getter(name="apiKeyConfig")
    def api_key_config(self) -> Optional[pulumi.Input['CxToolOpenApiSpecAuthenticationApiKeyConfigArgs']]:
        """
        Config for API key auth.
        This field is part of a union field `auth_config`: Only one of `apiKeyConfig`, `oauthConfig`, `serviceAgentAuthConfig`, or `bearerTokenConfig` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "api_key_config")

    @api_key_config.setter
    def api_key_config(self, value: Optional[pulumi.Input['CxToolOpenApiSpecAuthenticationApiKeyConfigArgs']]):
        pulumi.set(self, "api_key_config", value)

    @_builtins.property
    @pulumi.getter(name="bearerTokenConfig")
    def bearer_token_config(self) -> Optional[pulumi.Input['CxToolOpenApiSpecAuthenticationBearerTokenConfigArgs']]:
        """
        Config for bearer token auth.
        This field is part of a union field `auth_config`: Only one of `apiKeyConfig`, `oauthConfig`, `serviceAgentAuthConfig`, or `bearerTokenConfig` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "bearer_token_config")

    @bearer_token_config.setter
    def bearer_token_config(self, value: Optional[pulumi.Input['CxToolOpenApiSpecAuthenticationBearerTokenConfigArgs']]):
        pulumi.set(self, "bearer_token_config", value)

    @_builtins.property
    @pulumi.getter(name="oauthConfig")
    def oauth_config(self) -> Optional[pulumi.Input['CxToolOpenApiSpecAuthenticationOauthConfigArgs']]:
        """
        Config for OAuth.
        This field is part of a union field `auth_config`: Only one of `apiKeyConfig`, `oauthConfig`, `serviceAgentAuthConfig`, or `bearerTokenConfig` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "oauth_config")

    @oauth_config.setter
    def oauth_config(self, value: Optional[pulumi.Input['CxToolOpenApiSpecAuthenticationOauthConfigArgs']]):
        pulumi.set(self, "oauth_config", value)

    @_builtins.property
    @pulumi.getter(name="serviceAgentAuthConfig")
    def service_agent_auth_config(self) -> Optional[pulumi.Input['CxToolOpenApiSpecAuthenticationServiceAgentAuthConfigArgs']]:
        """
        Config for [Diglogflow service agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent) auth.
        This field is part of a union field `auth_config`: Only one of `apiKeyConfig`, `oauthConfig`, `serviceAgentAuthConfig`, or `bearerTokenConfig` may be set.
        Structure is documented below.
        """
        return pulumi.get(self, "service_agent_auth_config")

    @service_agent_auth_config.setter
    def service_agent_auth_config(self, value: Optional[pulumi.Input['CxToolOpenApiSpecAuthenticationServiceAgentAuthConfigArgs']]):
        pulumi.set(self, "service_agent_auth_config", value)


if not MYPY:
    class CxToolOpenApiSpecAuthenticationApiKeyConfigArgsDict(TypedDict):
        key_name: pulumi.Input[_builtins.str]
        """
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        request_location: pulumi.Input[_builtins.str]
        """
        Key location in the request.
        See [RequestLocation](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.tools#requestlocation) for valid values.
        """
        api_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. The API key. If the `secretVersionForApiKey`` field is set, this field will be ignored.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        secret_version_for_api_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. The name of the SecretManager secret version resource storing the API key.
        If this field is set, the apiKey field will be ignored.
        Format: projects/{project}/secrets/{secret}/versions/{version}
        """
elif False:
    CxToolOpenApiSpecAuthenticationApiKeyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxToolOpenApiSpecAuthenticationApiKeyConfigArgs:
    def __init__(__self__, *,
                 key_name: pulumi.Input[_builtins.str],
                 request_location: pulumi.Input[_builtins.str],
                 api_key: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_version_for_api_key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key_name: The parameter name or the header name of the API key.
               E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        :param pulumi.Input[_builtins.str] request_location: Key location in the request.
               See [RequestLocation](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.tools#requestlocation) for valid values.
        :param pulumi.Input[_builtins.str] api_key: Optional. The API key. If the `secretVersionForApiKey`` field is set, this field will be ignored.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[_builtins.str] secret_version_for_api_key: Optional. The name of the SecretManager secret version resource storing the API key.
               If this field is set, the apiKey field will be ignored.
               Format: projects/{project}/secrets/{secret}/versions/{version}
        """
        pulumi.set(__self__, "key_name", key_name)
        pulumi.set(__self__, "request_location", request_location)
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if secret_version_for_api_key is not None:
            pulumi.set(__self__, "secret_version_for_api_key", secret_version_for_api_key)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> pulumi.Input[_builtins.str]:
        """
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter(name="requestLocation")
    def request_location(self) -> pulumi.Input[_builtins.str]:
        """
        Key location in the request.
        See [RequestLocation](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.tools#requestlocation) for valid values.
        """
        return pulumi.get(self, "request_location")

    @request_location.setter
    def request_location(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "request_location", value)

    @_builtins.property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. The API key. If the `secretVersionForApiKey`` field is set, this field will be ignored.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_key", value)

    @_builtins.property
    @pulumi.getter(name="secretVersionForApiKey")
    def secret_version_for_api_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. The name of the SecretManager secret version resource storing the API key.
        If this field is set, the apiKey field will be ignored.
        Format: projects/{project}/secrets/{secret}/versions/{version}
        """
        return pulumi.get(self, "secret_version_for_api_key")

    @secret_version_for_api_key.setter
    def secret_version_for_api_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_version_for_api_key", value)


if not MYPY:
    class CxToolOpenApiSpecAuthenticationBearerTokenConfigArgsDict(TypedDict):
        secret_version_for_token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. The name of the SecretManager secret version resource storing the Bearer token. If this field is set, the `token` field will be ignored.
        Format: projects/{project}/secrets/{secret}/versions/{version}
        """
        token: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. The text token appended to the text Bearer to the request Authorization header.
        [Session parameters reference](https://cloud.google.com/dialogflow/cx/docs/concept/parameter#session-ref) can be used to pass the token dynamically, e.g. `$session.params.parameter-id`.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
elif False:
    CxToolOpenApiSpecAuthenticationBearerTokenConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxToolOpenApiSpecAuthenticationBearerTokenConfigArgs:
    def __init__(__self__, *,
                 secret_version_for_token: Optional[pulumi.Input[_builtins.str]] = None,
                 token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] secret_version_for_token: Optional. The name of the SecretManager secret version resource storing the Bearer token. If this field is set, the `token` field will be ignored.
               Format: projects/{project}/secrets/{secret}/versions/{version}
        :param pulumi.Input[_builtins.str] token: Optional. The text token appended to the text Bearer to the request Authorization header.
               [Session parameters reference](https://cloud.google.com/dialogflow/cx/docs/concept/parameter#session-ref) can be used to pass the token dynamically, e.g. `$session.params.parameter-id`.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        if secret_version_for_token is not None:
            pulumi.set(__self__, "secret_version_for_token", secret_version_for_token)
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter(name="secretVersionForToken")
    def secret_version_for_token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. The name of the SecretManager secret version resource storing the Bearer token. If this field is set, the `token` field will be ignored.
        Format: projects/{project}/secrets/{secret}/versions/{version}
        """
        return pulumi.get(self, "secret_version_for_token")

    @secret_version_for_token.setter
    def secret_version_for_token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_version_for_token", value)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. The text token appended to the text Bearer to the request Authorization header.
        [Session parameters reference](https://cloud.google.com/dialogflow/cx/docs/concept/parameter#session-ref) can be used to pass the token dynamically, e.g. `$session.params.parameter-id`.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)


if not MYPY:
    class CxToolOpenApiSpecAuthenticationOauthConfigArgsDict(TypedDict):
        client_id: pulumi.Input[_builtins.str]
        """
        The client ID from the OAuth provider.
        """
        oauth_grant_type: pulumi.Input[_builtins.str]
        """
        OAuth grant types.
        See [OauthGrantType](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.tools#oauthgranttype) for valid values
        """
        token_endpoint: pulumi.Input[_builtins.str]
        """
        The token endpoint in the OAuth provider to exchange for an access token.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. The client secret from the OAuth provider. If the `secretVersionForClientSecret` field is set, this field will be ignored.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Optional. The OAuth scopes to grant.
        """
        secret_version_for_client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. The name of the SecretManager secret version resource storing the client secret.
        If this field is set, the clientSecret field will be ignored.
        Format: projects/{project}/secrets/{secret}/versions/{version}
        """
elif False:
    CxToolOpenApiSpecAuthenticationOauthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxToolOpenApiSpecAuthenticationOauthConfigArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[_builtins.str],
                 oauth_grant_type: pulumi.Input[_builtins.str],
                 token_endpoint: pulumi.Input[_builtins.str],
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 secret_version_for_client_secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id: The client ID from the OAuth provider.
        :param pulumi.Input[_builtins.str] oauth_grant_type: OAuth grant types.
               See [OauthGrantType](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.tools#oauthgranttype) for valid values
        :param pulumi.Input[_builtins.str] token_endpoint: The token endpoint in the OAuth provider to exchange for an access token.
        :param pulumi.Input[_builtins.str] client_secret: Optional. The client secret from the OAuth provider. If the `secretVersionForClientSecret` field is set, this field will be ignored.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: Optional. The OAuth scopes to grant.
        :param pulumi.Input[_builtins.str] secret_version_for_client_secret: Optional. The name of the SecretManager secret version resource storing the client secret.
               If this field is set, the clientSecret field will be ignored.
               Format: projects/{project}/secrets/{secret}/versions/{version}
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "oauth_grant_type", oauth_grant_type)
        pulumi.set(__self__, "token_endpoint", token_endpoint)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if secret_version_for_client_secret is not None:
            pulumi.set(__self__, "secret_version_for_client_secret", secret_version_for_client_secret)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        """
        The client ID from the OAuth provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="oauthGrantType")
    def oauth_grant_type(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth grant types.
        See [OauthGrantType](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.tools#oauthgranttype) for valid values
        """
        return pulumi.get(self, "oauth_grant_type")

    @oauth_grant_type.setter
    def oauth_grant_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oauth_grant_type", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The token endpoint in the OAuth provider to exchange for an access token.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. The client secret from the OAuth provider. If the `secretVersionForClientSecret` field is set, this field will be ignored.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Optional. The OAuth scopes to grant.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="secretVersionForClientSecret")
    def secret_version_for_client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. The name of the SecretManager secret version resource storing the client secret.
        If this field is set, the clientSecret field will be ignored.
        Format: projects/{project}/secrets/{secret}/versions/{version}
        """
        return pulumi.get(self, "secret_version_for_client_secret")

    @secret_version_for_client_secret.setter
    def secret_version_for_client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_version_for_client_secret", value)


if not MYPY:
    class CxToolOpenApiSpecAuthenticationServiceAgentAuthConfigArgsDict(TypedDict):
        service_agent_auth: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Indicate the auth token type generated from the Diglogflow service agent.
        The generated token is sent in the Authorization header.
        See [ServiceAgentAuth](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.tools#serviceagentauth) for valid values.
        """
elif False:
    CxToolOpenApiSpecAuthenticationServiceAgentAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxToolOpenApiSpecAuthenticationServiceAgentAuthConfigArgs:
    def __init__(__self__, *,
                 service_agent_auth: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] service_agent_auth: Optional. Indicate the auth token type generated from the Diglogflow service agent.
               The generated token is sent in the Authorization header.
               See [ServiceAgentAuth](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.tools#serviceagentauth) for valid values.
        """
        if service_agent_auth is not None:
            pulumi.set(__self__, "service_agent_auth", service_agent_auth)

    @_builtins.property
    @pulumi.getter(name="serviceAgentAuth")
    def service_agent_auth(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Indicate the auth token type generated from the Diglogflow service agent.
        The generated token is sent in the Authorization header.
        See [ServiceAgentAuth](https://cloud.google.com/dialogflow/cx/docs/reference/rest/v3/projects.locations.agents.tools#serviceagentauth) for valid values.
        """
        return pulumi.get(self, "service_agent_auth")

    @service_agent_auth.setter
    def service_agent_auth(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_agent_auth", value)


if not MYPY:
    class CxToolOpenApiSpecServiceDirectoryConfigArgsDict(TypedDict):
        service: pulumi.Input[_builtins.str]
        """
        The name of [Service Directory](https://cloud.google.com/service-directory/docs) service.
        Format: projects/<ProjectID>/locations/<LocationID>/namespaces/<NamespaceID>/services/<ServiceID>. LocationID of the service directory must be the same as the location of the agent.
        """
elif False:
    CxToolOpenApiSpecServiceDirectoryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxToolOpenApiSpecServiceDirectoryConfigArgs:
    def __init__(__self__, *,
                 service: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] service: The name of [Service Directory](https://cloud.google.com/service-directory/docs) service.
               Format: projects/<ProjectID>/locations/<LocationID>/namespaces/<NamespaceID>/services/<ServiceID>. LocationID of the service directory must be the same as the location of the agent.
        """
        pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def service(self) -> pulumi.Input[_builtins.str]:
        """
        The name of [Service Directory](https://cloud.google.com/service-directory/docs) service.
        Format: projects/<ProjectID>/locations/<LocationID>/namespaces/<NamespaceID>/services/<ServiceID>. LocationID of the service directory must be the same as the location of the agent.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service", value)


if not MYPY:
    class CxToolOpenApiSpecTlsConfigArgsDict(TypedDict):
        ca_certs: pulumi.Input[Sequence[pulumi.Input['CxToolOpenApiSpecTlsConfigCaCertArgsDict']]]
        """
        Specifies a list of allowed custom CA certificates for HTTPS verification.
        Structure is documented below.
        """
elif False:
    CxToolOpenApiSpecTlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxToolOpenApiSpecTlsConfigArgs:
    def __init__(__self__, *,
                 ca_certs: pulumi.Input[Sequence[pulumi.Input['CxToolOpenApiSpecTlsConfigCaCertArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['CxToolOpenApiSpecTlsConfigCaCertArgs']]] ca_certs: Specifies a list of allowed custom CA certificates for HTTPS verification.
               Structure is documented below.
        """
        pulumi.set(__self__, "ca_certs", ca_certs)

    @_builtins.property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> pulumi.Input[Sequence[pulumi.Input['CxToolOpenApiSpecTlsConfigCaCertArgs']]]:
        """
        Specifies a list of allowed custom CA certificates for HTTPS verification.
        Structure is documented below.
        """
        return pulumi.get(self, "ca_certs")

    @ca_certs.setter
    def ca_certs(self, value: pulumi.Input[Sequence[pulumi.Input['CxToolOpenApiSpecTlsConfigCaCertArgs']]]):
        pulumi.set(self, "ca_certs", value)


if not MYPY:
    class CxToolOpenApiSpecTlsConfigCaCertArgsDict(TypedDict):
        cert: pulumi.Input[_builtins.str]
        """
        The allowed custom CA certificates (in DER format) for HTTPS verification. This overrides the default SSL trust store.
        If this is empty or unspecified, Dialogflow will use Google's default trust store to verify certificates.
        N.B. Make sure the HTTPS server certificates are signed with "subject alt name".
        For instance a certificate can be self-signed using the following command:
        ```
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        ```
        A base64-encoded string.
        """
        display_name: pulumi.Input[_builtins.str]
        """
        The name of the allowed custom CA certificates. This can be used to disambiguate the custom CA certificates.
        """
elif False:
    CxToolOpenApiSpecTlsConfigCaCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxToolOpenApiSpecTlsConfigCaCertArgs:
    def __init__(__self__, *,
                 cert: pulumi.Input[_builtins.str],
                 display_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] cert: The allowed custom CA certificates (in DER format) for HTTPS verification. This overrides the default SSL trust store.
               If this is empty or unspecified, Dialogflow will use Google's default trust store to verify certificates.
               N.B. Make sure the HTTPS server certificates are signed with "subject alt name".
               For instance a certificate can be self-signed using the following command:
               ```
               openssl x509 -req -days 200 -in example.com.csr \\
               -signkey example.com.key \\
               -out example.com.crt \\
               -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
               ```
               A base64-encoded string.
        :param pulumi.Input[_builtins.str] display_name: The name of the allowed custom CA certificates. This can be used to disambiguate the custom CA certificates.
        """
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> pulumi.Input[_builtins.str]:
        """
        The allowed custom CA certificates (in DER format) for HTTPS verification. This overrides the default SSL trust store.
        If this is empty or unspecified, Dialogflow will use Google's default trust store to verify certificates.
        N.B. Make sure the HTTPS server certificates are signed with "subject alt name".
        For instance a certificate can be self-signed using the following command:
        ```
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        ```
        A base64-encoded string.
        """
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cert", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the allowed custom CA certificates. This can be used to disambiguate the custom CA certificates.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class CxVersionNluSettingArgsDict(TypedDict):
        classification_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold. If the returned score value is less than the threshold value, then a no-match event will be triggered.
        The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
        """
        model_training_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates NLU model training mode.
        * MODEL_TRAINING_MODE_AUTOMATIC: NLU model training is automatically triggered when a flow gets modified. User can also manually trigger model training in this mode.
        * MODEL_TRAINING_MODE_MANUAL: User needs to manually trigger NLU model training. Best for large flows whose models take long time to train.
        Possible values are: `MODEL_TRAINING_MODE_AUTOMATIC`, `MODEL_TRAINING_MODE_MANUAL`.
        """
        model_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicates the type of NLU model.
        * MODEL_TYPE_STANDARD: Use standard NLU model.
        * MODEL_TYPE_ADVANCED: Use advanced NLU model.
        Possible values are: `MODEL_TYPE_STANDARD`, `MODEL_TYPE_ADVANCED`.
        """
elif False:
    CxVersionNluSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxVersionNluSettingArgs:
    def __init__(__self__, *,
                 classification_threshold: Optional[pulumi.Input[_builtins.float]] = None,
                 model_training_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 model_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] classification_threshold: To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold. If the returned score value is less than the threshold value, then a no-match event will be triggered.
               The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
        :param pulumi.Input[_builtins.str] model_training_mode: Indicates NLU model training mode.
               * MODEL_TRAINING_MODE_AUTOMATIC: NLU model training is automatically triggered when a flow gets modified. User can also manually trigger model training in this mode.
               * MODEL_TRAINING_MODE_MANUAL: User needs to manually trigger NLU model training. Best for large flows whose models take long time to train.
               Possible values are: `MODEL_TRAINING_MODE_AUTOMATIC`, `MODEL_TRAINING_MODE_MANUAL`.
        :param pulumi.Input[_builtins.str] model_type: Indicates the type of NLU model.
               * MODEL_TYPE_STANDARD: Use standard NLU model.
               * MODEL_TYPE_ADVANCED: Use advanced NLU model.
               Possible values are: `MODEL_TYPE_STANDARD`, `MODEL_TYPE_ADVANCED`.
        """
        if classification_threshold is not None:
            pulumi.set(__self__, "classification_threshold", classification_threshold)
        if model_training_mode is not None:
            pulumi.set(__self__, "model_training_mode", model_training_mode)
        if model_type is not None:
            pulumi.set(__self__, "model_type", model_type)

    @_builtins.property
    @pulumi.getter(name="classificationThreshold")
    def classification_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        To filter out false positive results and still get variety in matched natural language inputs for your agent, you can tune the machine learning classification threshold. If the returned score value is less than the threshold value, then a no-match event will be triggered.
        The score values range from 0.0 (completely uncertain) to 1.0 (completely certain). If set to 0.0, the default of 0.3 is used.
        """
        return pulumi.get(self, "classification_threshold")

    @classification_threshold.setter
    def classification_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "classification_threshold", value)

    @_builtins.property
    @pulumi.getter(name="modelTrainingMode")
    def model_training_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates NLU model training mode.
        * MODEL_TRAINING_MODE_AUTOMATIC: NLU model training is automatically triggered when a flow gets modified. User can also manually trigger model training in this mode.
        * MODEL_TRAINING_MODE_MANUAL: User needs to manually trigger NLU model training. Best for large flows whose models take long time to train.
        Possible values are: `MODEL_TRAINING_MODE_AUTOMATIC`, `MODEL_TRAINING_MODE_MANUAL`.
        """
        return pulumi.get(self, "model_training_mode")

    @model_training_mode.setter
    def model_training_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model_training_mode", value)

    @_builtins.property
    @pulumi.getter(name="modelType")
    def model_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicates the type of NLU model.
        * MODEL_TYPE_STANDARD: Use standard NLU model.
        * MODEL_TYPE_ADVANCED: Use advanced NLU model.
        Possible values are: `MODEL_TYPE_STANDARD`, `MODEL_TYPE_ADVANCED`.
        """
        return pulumi.get(self, "model_type")

    @model_type.setter
    def model_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model_type", value)


if not MYPY:
    class CxWebhookGenericWebServiceArgsDict(TypedDict):
        uri: pulumi.Input[_builtins.str]
        """
        The webhook URI for receiving POST requests. It must use https protocol.
        """
        allowed_ca_certs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies a list of allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, Dialogflow will use Google's default trust store
        to verify certificates.
        N.B. Make sure the HTTPS server certificates are signed with "subject alt
        name". For instance a certificate can be self-signed using the following
        command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        """
        http_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP method for the flexible webhook calls. Standard webhook always uses
        POST.
        Possible values are: `POST`, `GET`, `HEAD`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`.
        """
        oauth_config: NotRequired[pulumi.Input['CxWebhookGenericWebServiceOauthConfigArgsDict']]
        """
        Represents configuration of OAuth client credential flow for 3rd party
        API authentication.
        Structure is documented below.
        """
        parameter_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Maps the values extracted from specific fields of the flexible webhook
        response into session parameters.
        - Key: session parameter name
        - Value: field path in the webhook response
        """
        request_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines a custom JSON object as request body to send to flexible webhook.
        """
        request_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The HTTP request headers to send together with webhook requests.
        """
        secret_version_for_username_password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SecretManager secret version resource storing the username:password
        pair for HTTP Basic authentication.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        """
        secret_versions_for_request_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxWebhookGenericWebServiceSecretVersionsForRequestHeaderArgsDict']]]]
        """
        The HTTP request headers to send together with webhook requests. Header
        values are stored in SecretManager secret versions.
        When the same header name is specified in both `request_headers` and
        `secret_versions_for_request_headers`, the value in
        `secret_versions_for_request_headers` will be used.
        Structure is documented below.
        """
        service_agent_auth: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicate the auth token type generated from the [Diglogflow service
        agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent).
        The generated token is sent in the Authorization header.
        Possible values are: `NONE`, `ID_TOKEN`, `ACCESS_TOKEN`.
        """
        webhook_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the webhook.
        Possible values are: `STANDARD`, `FLEXIBLE`.
        """
elif False:
    CxWebhookGenericWebServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxWebhookGenericWebServiceArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[_builtins.str],
                 allowed_ca_certs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 http_method: Optional[pulumi.Input[_builtins.str]] = None,
                 oauth_config: Optional[pulumi.Input['CxWebhookGenericWebServiceOauthConfigArgs']] = None,
                 parameter_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 request_body: Optional[pulumi.Input[_builtins.str]] = None,
                 request_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 secret_version_for_username_password: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_versions_for_request_headers: Optional[pulumi.Input[Sequence[pulumi.Input['CxWebhookGenericWebServiceSecretVersionsForRequestHeaderArgs']]]] = None,
                 service_agent_auth: Optional[pulumi.Input[_builtins.str]] = None,
                 webhook_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uri: The webhook URI for receiving POST requests. It must use https protocol.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_ca_certs: Specifies a list of allowed custom CA certificates (in DER format) for
               HTTPS verification. This overrides the default SSL trust store. If this
               is empty or unspecified, Dialogflow will use Google's default trust store
               to verify certificates.
               N.B. Make sure the HTTPS server certificates are signed with "subject alt
               name". For instance a certificate can be self-signed using the following
               command,
               openssl x509 -req -days 200 -in example.com.csr \\
               -signkey example.com.key \\
               -out example.com.crt \\
               -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        :param pulumi.Input[_builtins.str] http_method: HTTP method for the flexible webhook calls. Standard webhook always uses
               POST.
               Possible values are: `POST`, `GET`, `HEAD`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`.
        :param pulumi.Input['CxWebhookGenericWebServiceOauthConfigArgs'] oauth_config: Represents configuration of OAuth client credential flow for 3rd party
               API authentication.
               Structure is documented below.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] parameter_mapping: Maps the values extracted from specific fields of the flexible webhook
               response into session parameters.
               - Key: session parameter name
               - Value: field path in the webhook response
        :param pulumi.Input[_builtins.str] request_body: Defines a custom JSON object as request body to send to flexible webhook.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] request_headers: The HTTP request headers to send together with webhook requests.
        :param pulumi.Input[_builtins.str] secret_version_for_username_password: The SecretManager secret version resource storing the username:password
               pair for HTTP Basic authentication.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
        :param pulumi.Input[Sequence[pulumi.Input['CxWebhookGenericWebServiceSecretVersionsForRequestHeaderArgs']]] secret_versions_for_request_headers: The HTTP request headers to send together with webhook requests. Header
               values are stored in SecretManager secret versions.
               When the same header name is specified in both `request_headers` and
               `secret_versions_for_request_headers`, the value in
               `secret_versions_for_request_headers` will be used.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] service_agent_auth: Indicate the auth token type generated from the [Diglogflow service
               agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent).
               The generated token is sent in the Authorization header.
               Possible values are: `NONE`, `ID_TOKEN`, `ACCESS_TOKEN`.
        :param pulumi.Input[_builtins.str] webhook_type: Type of the webhook.
               Possible values are: `STANDARD`, `FLEXIBLE`.
        """
        pulumi.set(__self__, "uri", uri)
        if allowed_ca_certs is not None:
            pulumi.set(__self__, "allowed_ca_certs", allowed_ca_certs)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if oauth_config is not None:
            pulumi.set(__self__, "oauth_config", oauth_config)
        if parameter_mapping is not None:
            pulumi.set(__self__, "parameter_mapping", parameter_mapping)
        if request_body is not None:
            pulumi.set(__self__, "request_body", request_body)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if secret_version_for_username_password is not None:
            pulumi.set(__self__, "secret_version_for_username_password", secret_version_for_username_password)
        if secret_versions_for_request_headers is not None:
            pulumi.set(__self__, "secret_versions_for_request_headers", secret_versions_for_request_headers)
        if service_agent_auth is not None:
            pulumi.set(__self__, "service_agent_auth", service_agent_auth)
        if webhook_type is not None:
            pulumi.set(__self__, "webhook_type", webhook_type)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> pulumi.Input[_builtins.str]:
        """
        The webhook URI for receiving POST requests. It must use https protocol.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uri", value)

    @_builtins.property
    @pulumi.getter(name="allowedCaCerts")
    def allowed_ca_certs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies a list of allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, Dialogflow will use Google's default trust store
        to verify certificates.
        N.B. Make sure the HTTPS server certificates are signed with "subject alt
        name". For instance a certificate can be self-signed using the following
        command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        """
        return pulumi.get(self, "allowed_ca_certs")

    @allowed_ca_certs.setter
    def allowed_ca_certs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_ca_certs", value)

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP method for the flexible webhook calls. Standard webhook always uses
        POST.
        Possible values are: `POST`, `GET`, `HEAD`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`.
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_method", value)

    @_builtins.property
    @pulumi.getter(name="oauthConfig")
    def oauth_config(self) -> Optional[pulumi.Input['CxWebhookGenericWebServiceOauthConfigArgs']]:
        """
        Represents configuration of OAuth client credential flow for 3rd party
        API authentication.
        Structure is documented below.
        """
        return pulumi.get(self, "oauth_config")

    @oauth_config.setter
    def oauth_config(self, value: Optional[pulumi.Input['CxWebhookGenericWebServiceOauthConfigArgs']]):
        pulumi.set(self, "oauth_config", value)

    @_builtins.property
    @pulumi.getter(name="parameterMapping")
    def parameter_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Maps the values extracted from specific fields of the flexible webhook
        response into session parameters.
        - Key: session parameter name
        - Value: field path in the webhook response
        """
        return pulumi.get(self, "parameter_mapping")

    @parameter_mapping.setter
    def parameter_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "parameter_mapping", value)

    @_builtins.property
    @pulumi.getter(name="requestBody")
    def request_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines a custom JSON object as request body to send to flexible webhook.
        """
        return pulumi.get(self, "request_body")

    @request_body.setter
    def request_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request_body", value)

    @_builtins.property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The HTTP request headers to send together with webhook requests.
        """
        return pulumi.get(self, "request_headers")

    @request_headers.setter
    def request_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "request_headers", value)

    @_builtins.property
    @pulumi.getter(name="secretVersionForUsernamePassword")
    def secret_version_for_username_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SecretManager secret version resource storing the username:password
        pair for HTTP Basic authentication.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        """
        return pulumi.get(self, "secret_version_for_username_password")

    @secret_version_for_username_password.setter
    def secret_version_for_username_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_version_for_username_password", value)

    @_builtins.property
    @pulumi.getter(name="secretVersionsForRequestHeaders")
    def secret_versions_for_request_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxWebhookGenericWebServiceSecretVersionsForRequestHeaderArgs']]]]:
        """
        The HTTP request headers to send together with webhook requests. Header
        values are stored in SecretManager secret versions.
        When the same header name is specified in both `request_headers` and
        `secret_versions_for_request_headers`, the value in
        `secret_versions_for_request_headers` will be used.
        Structure is documented below.
        """
        return pulumi.get(self, "secret_versions_for_request_headers")

    @secret_versions_for_request_headers.setter
    def secret_versions_for_request_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxWebhookGenericWebServiceSecretVersionsForRequestHeaderArgs']]]]):
        pulumi.set(self, "secret_versions_for_request_headers", value)

    @_builtins.property
    @pulumi.getter(name="serviceAgentAuth")
    def service_agent_auth(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicate the auth token type generated from the [Diglogflow service
        agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent).
        The generated token is sent in the Authorization header.
        Possible values are: `NONE`, `ID_TOKEN`, `ACCESS_TOKEN`.
        """
        return pulumi.get(self, "service_agent_auth")

    @service_agent_auth.setter
    def service_agent_auth(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_agent_auth", value)

    @_builtins.property
    @pulumi.getter(name="webhookType")
    def webhook_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the webhook.
        Possible values are: `STANDARD`, `FLEXIBLE`.
        """
        return pulumi.get(self, "webhook_type")

    @webhook_type.setter
    def webhook_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "webhook_type", value)


if not MYPY:
    class CxWebhookGenericWebServiceOauthConfigArgsDict(TypedDict):
        client_id: pulumi.Input[_builtins.str]
        """
        The client ID provided by the 3rd party platform.
        """
        token_endpoint: pulumi.Input[_builtins.str]
        """
        The token endpoint provided by the 3rd party platform to exchange an
        access token.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret provided by the 3rd party platform.  If the
        `secret_version_for_client_secret` field is set, this field will be
        ignored.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The OAuth scopes to grant.
        """
        secret_version_for_client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the SecretManager secret version resource storing the
        client secret. If this field is set, the `client_secret` field will be
        ignored.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        """
elif False:
    CxWebhookGenericWebServiceOauthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxWebhookGenericWebServiceOauthConfigArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[_builtins.str],
                 token_endpoint: pulumi.Input[_builtins.str],
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 secret_version_for_client_secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id: The client ID provided by the 3rd party platform.
        :param pulumi.Input[_builtins.str] token_endpoint: The token endpoint provided by the 3rd party platform to exchange an
               access token.
        :param pulumi.Input[_builtins.str] client_secret: The client secret provided by the 3rd party platform.  If the
               `secret_version_for_client_secret` field is set, this field will be
               ignored.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: The OAuth scopes to grant.
        :param pulumi.Input[_builtins.str] secret_version_for_client_secret: The name of the SecretManager secret version resource storing the
               client secret. If this field is set, the `client_secret` field will be
               ignored.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "token_endpoint", token_endpoint)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if secret_version_for_client_secret is not None:
            pulumi.set(__self__, "secret_version_for_client_secret", secret_version_for_client_secret)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        """
        The client ID provided by the 3rd party platform.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The token endpoint provided by the 3rd party platform to exchange an
        access token.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret provided by the 3rd party platform.  If the
        `secret_version_for_client_secret` field is set, this field will be
        ignored.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The OAuth scopes to grant.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="secretVersionForClientSecret")
    def secret_version_for_client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the SecretManager secret version resource storing the
        client secret. If this field is set, the `client_secret` field will be
        ignored.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        """
        return pulumi.get(self, "secret_version_for_client_secret")

    @secret_version_for_client_secret.setter
    def secret_version_for_client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_version_for_client_secret", value)


if not MYPY:
    class CxWebhookGenericWebServiceSecretVersionsForRequestHeaderArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The identifier for this object. Format specified above.
        """
        secret_version: pulumi.Input[_builtins.str]
        """
        The SecretManager secret version resource storing the header value.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        """
elif False:
    CxWebhookGenericWebServiceSecretVersionsForRequestHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxWebhookGenericWebServiceSecretVersionsForRequestHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret_version: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The identifier for this object. Format specified above.
        :param pulumi.Input[_builtins.str] secret_version: The SecretManager secret version resource storing the header value.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_version", secret_version)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> pulumi.Input[_builtins.str]:
        """
        The SecretManager secret version resource storing the header value.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        """
        return pulumi.get(self, "secret_version")

    @secret_version.setter
    def secret_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_version", value)


if not MYPY:
    class CxWebhookServiceDirectoryArgsDict(TypedDict):
        service: pulumi.Input[_builtins.str]
        """
        The name of Service Directory service.
        """
        generic_web_service: NotRequired[pulumi.Input['CxWebhookServiceDirectoryGenericWebServiceArgsDict']]
        """
        Represents configuration for a generic web service.
        Structure is documented below.
        """
elif False:
    CxWebhookServiceDirectoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxWebhookServiceDirectoryArgs:
    def __init__(__self__, *,
                 service: pulumi.Input[_builtins.str],
                 generic_web_service: Optional[pulumi.Input['CxWebhookServiceDirectoryGenericWebServiceArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] service: The name of Service Directory service.
        :param pulumi.Input['CxWebhookServiceDirectoryGenericWebServiceArgs'] generic_web_service: Represents configuration for a generic web service.
               Structure is documented below.
        """
        pulumi.set(__self__, "service", service)
        if generic_web_service is not None:
            pulumi.set(__self__, "generic_web_service", generic_web_service)

    @_builtins.property
    @pulumi.getter
    def service(self) -> pulumi.Input[_builtins.str]:
        """
        The name of Service Directory service.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service", value)

    @_builtins.property
    @pulumi.getter(name="genericWebService")
    def generic_web_service(self) -> Optional[pulumi.Input['CxWebhookServiceDirectoryGenericWebServiceArgs']]:
        """
        Represents configuration for a generic web service.
        Structure is documented below.
        """
        return pulumi.get(self, "generic_web_service")

    @generic_web_service.setter
    def generic_web_service(self, value: Optional[pulumi.Input['CxWebhookServiceDirectoryGenericWebServiceArgs']]):
        pulumi.set(self, "generic_web_service", value)


if not MYPY:
    class CxWebhookServiceDirectoryGenericWebServiceArgsDict(TypedDict):
        uri: pulumi.Input[_builtins.str]
        """
        The webhook URI for receiving POST requests. It must use https protocol.
        """
        allowed_ca_certs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies a list of allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, Dialogflow will use Google's default trust store
        to verify certificates.
        N.B. Make sure the HTTPS server certificates are signed with "subject alt
        name". For instance a certificate can be self-signed using the following
        command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        """
        http_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        HTTP method for the flexible webhook calls. Standard webhook always uses
        POST.
        Possible values are: `POST`, `GET`, `HEAD`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`.
        """
        oauth_config: NotRequired[pulumi.Input['CxWebhookServiceDirectoryGenericWebServiceOauthConfigArgsDict']]
        """
        Represents configuration of OAuth client credential flow for 3rd party
        API authentication.
        Structure is documented below.
        """
        parameter_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Maps the values extracted from specific fields of the flexible webhook
        response into session parameters.
        - Key: session parameter name
        - Value: field path in the webhook response
        """
        request_body: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines a custom JSON object as request body to send to flexible webhook.
        """
        request_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The HTTP request headers to send together with webhook requests.
        """
        secret_version_for_username_password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The SecretManager secret version resource storing the username:password
        pair for HTTP Basic authentication.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        """
        secret_versions_for_request_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['CxWebhookServiceDirectoryGenericWebServiceSecretVersionsForRequestHeaderArgsDict']]]]
        """
        The HTTP request headers to send together with webhook requests. Header
        values are stored in SecretManager secret versions.
        When the same header name is specified in both `request_headers` and
        `secret_versions_for_request_headers`, the value in
        `secret_versions_for_request_headers` will be used.
        Structure is documented below.
        """
        service_agent_auth: NotRequired[pulumi.Input[_builtins.str]]
        """
        Indicate the auth token type generated from the [Diglogflow service
        agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent).
        The generated token is sent in the Authorization header.
        Possible values are: `NONE`, `ID_TOKEN`, `ACCESS_TOKEN`.
        """
        webhook_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Type of the webhook.
        Possible values are: `STANDARD`, `FLEXIBLE`.
        """
elif False:
    CxWebhookServiceDirectoryGenericWebServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxWebhookServiceDirectoryGenericWebServiceArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[_builtins.str],
                 allowed_ca_certs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 http_method: Optional[pulumi.Input[_builtins.str]] = None,
                 oauth_config: Optional[pulumi.Input['CxWebhookServiceDirectoryGenericWebServiceOauthConfigArgs']] = None,
                 parameter_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 request_body: Optional[pulumi.Input[_builtins.str]] = None,
                 request_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 secret_version_for_username_password: Optional[pulumi.Input[_builtins.str]] = None,
                 secret_versions_for_request_headers: Optional[pulumi.Input[Sequence[pulumi.Input['CxWebhookServiceDirectoryGenericWebServiceSecretVersionsForRequestHeaderArgs']]]] = None,
                 service_agent_auth: Optional[pulumi.Input[_builtins.str]] = None,
                 webhook_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uri: The webhook URI for receiving POST requests. It must use https protocol.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_ca_certs: Specifies a list of allowed custom CA certificates (in DER format) for
               HTTPS verification. This overrides the default SSL trust store. If this
               is empty or unspecified, Dialogflow will use Google's default trust store
               to verify certificates.
               N.B. Make sure the HTTPS server certificates are signed with "subject alt
               name". For instance a certificate can be self-signed using the following
               command,
               openssl x509 -req -days 200 -in example.com.csr \\
               -signkey example.com.key \\
               -out example.com.crt \\
               -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        :param pulumi.Input[_builtins.str] http_method: HTTP method for the flexible webhook calls. Standard webhook always uses
               POST.
               Possible values are: `POST`, `GET`, `HEAD`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`.
        :param pulumi.Input['CxWebhookServiceDirectoryGenericWebServiceOauthConfigArgs'] oauth_config: Represents configuration of OAuth client credential flow for 3rd party
               API authentication.
               Structure is documented below.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] parameter_mapping: Maps the values extracted from specific fields of the flexible webhook
               response into session parameters.
               - Key: session parameter name
               - Value: field path in the webhook response
        :param pulumi.Input[_builtins.str] request_body: Defines a custom JSON object as request body to send to flexible webhook.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] request_headers: The HTTP request headers to send together with webhook requests.
        :param pulumi.Input[_builtins.str] secret_version_for_username_password: The SecretManager secret version resource storing the username:password
               pair for HTTP Basic authentication.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
        :param pulumi.Input[Sequence[pulumi.Input['CxWebhookServiceDirectoryGenericWebServiceSecretVersionsForRequestHeaderArgs']]] secret_versions_for_request_headers: The HTTP request headers to send together with webhook requests. Header
               values are stored in SecretManager secret versions.
               When the same header name is specified in both `request_headers` and
               `secret_versions_for_request_headers`, the value in
               `secret_versions_for_request_headers` will be used.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] service_agent_auth: Indicate the auth token type generated from the [Diglogflow service
               agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent).
               The generated token is sent in the Authorization header.
               Possible values are: `NONE`, `ID_TOKEN`, `ACCESS_TOKEN`.
        :param pulumi.Input[_builtins.str] webhook_type: Type of the webhook.
               Possible values are: `STANDARD`, `FLEXIBLE`.
        """
        pulumi.set(__self__, "uri", uri)
        if allowed_ca_certs is not None:
            pulumi.set(__self__, "allowed_ca_certs", allowed_ca_certs)
        if http_method is not None:
            pulumi.set(__self__, "http_method", http_method)
        if oauth_config is not None:
            pulumi.set(__self__, "oauth_config", oauth_config)
        if parameter_mapping is not None:
            pulumi.set(__self__, "parameter_mapping", parameter_mapping)
        if request_body is not None:
            pulumi.set(__self__, "request_body", request_body)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if secret_version_for_username_password is not None:
            pulumi.set(__self__, "secret_version_for_username_password", secret_version_for_username_password)
        if secret_versions_for_request_headers is not None:
            pulumi.set(__self__, "secret_versions_for_request_headers", secret_versions_for_request_headers)
        if service_agent_auth is not None:
            pulumi.set(__self__, "service_agent_auth", service_agent_auth)
        if webhook_type is not None:
            pulumi.set(__self__, "webhook_type", webhook_type)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> pulumi.Input[_builtins.str]:
        """
        The webhook URI for receiving POST requests. It must use https protocol.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uri", value)

    @_builtins.property
    @pulumi.getter(name="allowedCaCerts")
    def allowed_ca_certs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies a list of allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, Dialogflow will use Google's default trust store
        to verify certificates.
        N.B. Make sure the HTTPS server certificates are signed with "subject alt
        name". For instance a certificate can be self-signed using the following
        command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        """
        return pulumi.get(self, "allowed_ca_certs")

    @allowed_ca_certs.setter
    def allowed_ca_certs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_ca_certs", value)

    @_builtins.property
    @pulumi.getter(name="httpMethod")
    def http_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        HTTP method for the flexible webhook calls. Standard webhook always uses
        POST.
        Possible values are: `POST`, `GET`, `HEAD`, `PUT`, `DELETE`, `PATCH`, `OPTIONS`.
        """
        return pulumi.get(self, "http_method")

    @http_method.setter
    def http_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "http_method", value)

    @_builtins.property
    @pulumi.getter(name="oauthConfig")
    def oauth_config(self) -> Optional[pulumi.Input['CxWebhookServiceDirectoryGenericWebServiceOauthConfigArgs']]:
        """
        Represents configuration of OAuth client credential flow for 3rd party
        API authentication.
        Structure is documented below.
        """
        return pulumi.get(self, "oauth_config")

    @oauth_config.setter
    def oauth_config(self, value: Optional[pulumi.Input['CxWebhookServiceDirectoryGenericWebServiceOauthConfigArgs']]):
        pulumi.set(self, "oauth_config", value)

    @_builtins.property
    @pulumi.getter(name="parameterMapping")
    def parameter_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Maps the values extracted from specific fields of the flexible webhook
        response into session parameters.
        - Key: session parameter name
        - Value: field path in the webhook response
        """
        return pulumi.get(self, "parameter_mapping")

    @parameter_mapping.setter
    def parameter_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "parameter_mapping", value)

    @_builtins.property
    @pulumi.getter(name="requestBody")
    def request_body(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines a custom JSON object as request body to send to flexible webhook.
        """
        return pulumi.get(self, "request_body")

    @request_body.setter
    def request_body(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request_body", value)

    @_builtins.property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The HTTP request headers to send together with webhook requests.
        """
        return pulumi.get(self, "request_headers")

    @request_headers.setter
    def request_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "request_headers", value)

    @_builtins.property
    @pulumi.getter(name="secretVersionForUsernamePassword")
    def secret_version_for_username_password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The SecretManager secret version resource storing the username:password
        pair for HTTP Basic authentication.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        """
        return pulumi.get(self, "secret_version_for_username_password")

    @secret_version_for_username_password.setter
    def secret_version_for_username_password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_version_for_username_password", value)

    @_builtins.property
    @pulumi.getter(name="secretVersionsForRequestHeaders")
    def secret_versions_for_request_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['CxWebhookServiceDirectoryGenericWebServiceSecretVersionsForRequestHeaderArgs']]]]:
        """
        The HTTP request headers to send together with webhook requests. Header
        values are stored in SecretManager secret versions.
        When the same header name is specified in both `request_headers` and
        `secret_versions_for_request_headers`, the value in
        `secret_versions_for_request_headers` will be used.
        Structure is documented below.
        """
        return pulumi.get(self, "secret_versions_for_request_headers")

    @secret_versions_for_request_headers.setter
    def secret_versions_for_request_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['CxWebhookServiceDirectoryGenericWebServiceSecretVersionsForRequestHeaderArgs']]]]):
        pulumi.set(self, "secret_versions_for_request_headers", value)

    @_builtins.property
    @pulumi.getter(name="serviceAgentAuth")
    def service_agent_auth(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Indicate the auth token type generated from the [Diglogflow service
        agent](https://cloud.google.com/iam/docs/service-agents#dialogflow-service-agent).
        The generated token is sent in the Authorization header.
        Possible values are: `NONE`, `ID_TOKEN`, `ACCESS_TOKEN`.
        """
        return pulumi.get(self, "service_agent_auth")

    @service_agent_auth.setter
    def service_agent_auth(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_agent_auth", value)

    @_builtins.property
    @pulumi.getter(name="webhookType")
    def webhook_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Type of the webhook.
        Possible values are: `STANDARD`, `FLEXIBLE`.
        """
        return pulumi.get(self, "webhook_type")

    @webhook_type.setter
    def webhook_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "webhook_type", value)


if not MYPY:
    class CxWebhookServiceDirectoryGenericWebServiceOauthConfigArgsDict(TypedDict):
        client_id: pulumi.Input[_builtins.str]
        """
        The client ID provided by the 3rd party platform.
        """
        token_endpoint: pulumi.Input[_builtins.str]
        """
        The token endpoint provided by the 3rd party platform to exchange an
        access token.
        """
        client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The client secret provided by the 3rd party platform.  If the
        `secret_version_for_client_secret` field is set, this field will be
        ignored.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The OAuth scopes to grant.
        """
        secret_version_for_client_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the SecretManager secret version resource storing the
        client secret. If this field is set, the `client_secret` field will be
        ignored.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        """
elif False:
    CxWebhookServiceDirectoryGenericWebServiceOauthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxWebhookServiceDirectoryGenericWebServiceOauthConfigArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[_builtins.str],
                 token_endpoint: pulumi.Input[_builtins.str],
                 client_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 secret_version_for_client_secret: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id: The client ID provided by the 3rd party platform.
        :param pulumi.Input[_builtins.str] token_endpoint: The token endpoint provided by the 3rd party platform to exchange an
               access token.
        :param pulumi.Input[_builtins.str] client_secret: The client secret provided by the 3rd party platform.  If the
               `secret_version_for_client_secret` field is set, this field will be
               ignored.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: The OAuth scopes to grant.
        :param pulumi.Input[_builtins.str] secret_version_for_client_secret: The name of the SecretManager secret version resource storing the
               client secret. If this field is set, the `client_secret` field will be
               ignored.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "token_endpoint", token_endpoint)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if secret_version_for_client_secret is not None:
            pulumi.set(__self__, "secret_version_for_client_secret", secret_version_for_client_secret)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        """
        The client ID provided by the 3rd party platform.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The token endpoint provided by the 3rd party platform to exchange an
        access token.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_endpoint", value)

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The client secret provided by the 3rd party platform.  If the
        `secret_version_for_client_secret` field is set, this field will be
        ignored.
        """
        return pulumi.get(self, "client_secret")

    @client_secret.setter
    def client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The OAuth scopes to grant.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="secretVersionForClientSecret")
    def secret_version_for_client_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the SecretManager secret version resource storing the
        client secret. If this field is set, the `client_secret` field will be
        ignored.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        """
        return pulumi.get(self, "secret_version_for_client_secret")

    @secret_version_for_client_secret.setter
    def secret_version_for_client_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_version_for_client_secret", value)


if not MYPY:
    class CxWebhookServiceDirectoryGenericWebServiceSecretVersionsForRequestHeaderArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        The identifier for this object. Format specified above.
        """
        secret_version: pulumi.Input[_builtins.str]
        """
        The SecretManager secret version resource storing the header value.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        """
elif False:
    CxWebhookServiceDirectoryGenericWebServiceSecretVersionsForRequestHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CxWebhookServiceDirectoryGenericWebServiceSecretVersionsForRequestHeaderArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret_version: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] key: The identifier for this object. Format specified above.
        :param pulumi.Input[_builtins.str] secret_version: The SecretManager secret version resource storing the header value.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret_version", secret_version)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter(name="secretVersion")
    def secret_version(self) -> pulumi.Input[_builtins.str]:
        """
        The SecretManager secret version resource storing the header value.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        """
        return pulumi.get(self, "secret_version")

    @secret_version.setter
    def secret_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_version", value)


if not MYPY:
    class EncryptionSpecEncryptionSpecArgsDict(TypedDict):
        kms_key: pulumi.Input[_builtins.str]
        """
        The name of customer-managed encryption key that is used to secure a resource and its sub-resources.
        If empty, the resource is secured by the default Google encryption key.
        Only the key in the same location as this resource is allowed to be used for encryption.
        Format: projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key}
        """
elif False:
    EncryptionSpecEncryptionSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EncryptionSpecEncryptionSpecArgs:
    def __init__(__self__, *,
                 kms_key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] kms_key: The name of customer-managed encryption key that is used to secure a resource and its sub-resources.
               If empty, the resource is secured by the default Google encryption key.
               Only the key in the same location as this resource is allowed to be used for encryption.
               Format: projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key}
        """
        pulumi.set(__self__, "kms_key", kms_key)

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> pulumi.Input[_builtins.str]:
        """
        The name of customer-managed encryption key that is used to secure a resource and its sub-resources.
        If empty, the resource is secured by the default Google encryption key.
        Only the key in the same location as this resource is allowed to be used for encryption.
        Format: projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{key}
        """
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kms_key", value)


if not MYPY:
    class EntityTypeEntityArgsDict(TypedDict):
        synonyms: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A collection of value synonyms. For example, if the entity type is vegetable, and value is scallions, a synonym
        could be green onions.
        For KIND_LIST entity types:
        * This collection must contain exactly one synonym equal to value.
        """
        value: pulumi.Input[_builtins.str]
        """
        The primary value associated with this entity entry. For example, if the entity type is vegetable, the value
        could be scallions.
        For KIND_MAP entity types:
        * A reference value to be used in place of synonyms.
        For KIND_LIST entity types:
        * A string that can contain references to other entity types (with or without aliases).
        """
elif False:
    EntityTypeEntityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EntityTypeEntityArgs:
    def __init__(__self__, *,
                 synonyms: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 value: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] synonyms: A collection of value synonyms. For example, if the entity type is vegetable, and value is scallions, a synonym
               could be green onions.
               For KIND_LIST entity types:
               * This collection must contain exactly one synonym equal to value.
        :param pulumi.Input[_builtins.str] value: The primary value associated with this entity entry. For example, if the entity type is vegetable, the value
               could be scallions.
               For KIND_MAP entity types:
               * A reference value to be used in place of synonyms.
               For KIND_LIST entity types:
               * A string that can contain references to other entity types (with or without aliases).
        """
        pulumi.set(__self__, "synonyms", synonyms)
        pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def synonyms(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A collection of value synonyms. For example, if the entity type is vegetable, and value is scallions, a synonym
        could be green onions.
        For KIND_LIST entity types:
        * This collection must contain exactly one synonym equal to value.
        """
        return pulumi.get(self, "synonyms")

    @synonyms.setter
    def synonyms(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "synonyms", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The primary value associated with this entity entry. For example, if the entity type is vegetable, the value
        could be scallions.
        For KIND_MAP entity types:
        * A reference value to be used in place of synonyms.
        For KIND_LIST entity types:
        * A string that can contain references to other entity types (with or without aliases).
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class FulfillmentFeatureArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of the feature that enabled for fulfillment.
        * SMALLTALK: Fulfillment is enabled for SmallTalk.
        Possible values are: `SMALLTALK`.
        """
elif False:
    FulfillmentFeatureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FulfillmentFeatureArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] type: The type of the feature that enabled for fulfillment.
               * SMALLTALK: Fulfillment is enabled for SmallTalk.
               Possible values are: `SMALLTALK`.
        """
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the feature that enabled for fulfillment.
        * SMALLTALK: Fulfillment is enabled for SmallTalk.
        Possible values are: `SMALLTALK`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)


if not MYPY:
    class FulfillmentGenericWebServiceArgsDict(TypedDict):
        uri: pulumi.Input[_builtins.str]
        """
        The fulfillment URI for receiving POST requests. It must use https protocol.
        """
        password: NotRequired[pulumi.Input[_builtins.str]]
        """
        The password for HTTP Basic authentication.
        """
        request_headers: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The HTTP request headers to send together with fulfillment requests.
        """
        username: NotRequired[pulumi.Input[_builtins.str]]
        """
        The user name for HTTP Basic authentication.
        """
elif False:
    FulfillmentGenericWebServiceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FulfillmentGenericWebServiceArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[_builtins.str],
                 password: Optional[pulumi.Input[_builtins.str]] = None,
                 request_headers: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 username: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uri: The fulfillment URI for receiving POST requests. It must use https protocol.
        :param pulumi.Input[_builtins.str] password: The password for HTTP Basic authentication.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] request_headers: The HTTP request headers to send together with fulfillment requests.
        :param pulumi.Input[_builtins.str] username: The user name for HTTP Basic authentication.
        """
        pulumi.set(__self__, "uri", uri)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if request_headers is not None:
            pulumi.set(__self__, "request_headers", request_headers)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> pulumi.Input[_builtins.str]:
        """
        The fulfillment URI for receiving POST requests. It must use https protocol.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uri", value)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The password for HTTP Basic authentication.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "password", value)

    @_builtins.property
    @pulumi.getter(name="requestHeaders")
    def request_headers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The HTTP request headers to send together with fulfillment requests.
        """
        return pulumi.get(self, "request_headers")

    @request_headers.setter
    def request_headers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "request_headers", value)

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The user name for HTTP Basic authentication.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "username", value)


if not MYPY:
    class GeneratorInferenceParameterArgsDict(TypedDict):
        max_output_tokens: NotRequired[pulumi.Input[_builtins.int]]
        """
        Optional. Maximum number of the output tokens for the generator.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        Optional. Controls the randomness of LLM predictions. Low temperature = less random. High temperature = more random. If unset (or 0), uses a default value of 0.
        """
        top_k: NotRequired[pulumi.Input[_builtins.int]]
        """
        Optional. Top-k changes how the model selects tokens for output. A top-k of 1 means the selected token is the most probable among all tokens in the model's vocabulary (also called greedy decoding), while a top-k of 3 means that the next token is selected from among the 3 most probable tokens (using temperature). For each token selection step, the top K tokens with the highest probabilities are sampled. Then tokens are further filtered based on topP with the final token selected using temperature sampling. Specify a lower value for less random responses and a higher value for more random responses. Acceptable value is [1, 40], default to 40.
        """
        top_p: NotRequired[pulumi.Input[_builtins.float]]
        """
        Optional. Top-p changes how the model selects tokens for output. Tokens are selected from most K (see topK parameter) probable to least until the sum of their probabilities equals the top-p value. For example, if tokens A, B, and C have a probability of 0.3, 0.2, and 0.1 and the top-p value is 0.5, then the model will select either A or B as the next token (using temperature) and doesn't consider C. The default top-p value is 0.95. Specify a lower value for less random responses and a higher value for more random responses. Acceptable value is [0.0, 1.0], default to 0.95.
        """
elif False:
    GeneratorInferenceParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GeneratorInferenceParameterArgs:
    def __init__(__self__, *,
                 max_output_tokens: Optional[pulumi.Input[_builtins.int]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None,
                 top_k: Optional[pulumi.Input[_builtins.int]] = None,
                 top_p: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.int] max_output_tokens: Optional. Maximum number of the output tokens for the generator.
        :param pulumi.Input[_builtins.float] temperature: Optional. Controls the randomness of LLM predictions. Low temperature = less random. High temperature = more random. If unset (or 0), uses a default value of 0.
        :param pulumi.Input[_builtins.int] top_k: Optional. Top-k changes how the model selects tokens for output. A top-k of 1 means the selected token is the most probable among all tokens in the model's vocabulary (also called greedy decoding), while a top-k of 3 means that the next token is selected from among the 3 most probable tokens (using temperature). For each token selection step, the top K tokens with the highest probabilities are sampled. Then tokens are further filtered based on topP with the final token selected using temperature sampling. Specify a lower value for less random responses and a higher value for more random responses. Acceptable value is [1, 40], default to 40.
        :param pulumi.Input[_builtins.float] top_p: Optional. Top-p changes how the model selects tokens for output. Tokens are selected from most K (see topK parameter) probable to least until the sum of their probabilities equals the top-p value. For example, if tokens A, B, and C have a probability of 0.3, 0.2, and 0.1 and the top-p value is 0.5, then the model will select either A or B as the next token (using temperature) and doesn't consider C. The default top-p value is 0.95. Specify a lower value for less random responses and a higher value for more random responses. Acceptable value is [0.0, 1.0], default to 0.95.
        """
        if max_output_tokens is not None:
            pulumi.set(__self__, "max_output_tokens", max_output_tokens)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)
        if top_k is not None:
            pulumi.set(__self__, "top_k", top_k)
        if top_p is not None:
            pulumi.set(__self__, "top_p", top_p)

    @_builtins.property
    @pulumi.getter(name="maxOutputTokens")
    def max_output_tokens(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Optional. Maximum number of the output tokens for the generator.
        """
        return pulumi.get(self, "max_output_tokens")

    @max_output_tokens.setter
    def max_output_tokens(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_output_tokens", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Optional. Controls the randomness of LLM predictions. Low temperature = less random. High temperature = more random. If unset (or 0), uses a default value of 0.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)

    @_builtins.property
    @pulumi.getter(name="topK")
    def top_k(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Optional. Top-k changes how the model selects tokens for output. A top-k of 1 means the selected token is the most probable among all tokens in the model's vocabulary (also called greedy decoding), while a top-k of 3 means that the next token is selected from among the 3 most probable tokens (using temperature). For each token selection step, the top K tokens with the highest probabilities are sampled. Then tokens are further filtered based on topP with the final token selected using temperature sampling. Specify a lower value for less random responses and a higher value for more random responses. Acceptable value is [1, 40], default to 40.
        """
        return pulumi.get(self, "top_k")

    @top_k.setter
    def top_k(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "top_k", value)

    @_builtins.property
    @pulumi.getter(name="topP")
    def top_p(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Optional. Top-p changes how the model selects tokens for output. Tokens are selected from most K (see topK parameter) probable to least until the sum of their probabilities equals the top-p value. For example, if tokens A, B, and C have a probability of 0.3, 0.2, and 0.1 and the top-p value is 0.5, then the model will select either A or B as the next token (using temperature) and doesn't consider C. The default top-p value is 0.95. Specify a lower value for less random responses and a higher value for more random responses. Acceptable value is [0.0, 1.0], default to 0.95.
        """
        return pulumi.get(self, "top_p")

    @top_p.setter
    def top_p(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "top_p", value)


if not MYPY:
    class GeneratorSummarizationContextArgsDict(TypedDict):
        few_shot_examples: NotRequired[pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleArgsDict']]]]
        """
        Optional. List of few shot examples.
        Structure is documented below.
        """
        output_language_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. The target language of the generated summary. The language code for conversation will be used if this field is empty. Supported 2.0 and later versions.
        """
        summarization_sections: NotRequired[pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextSummarizationSectionArgsDict']]]]
        """
        Optional. List of sections. Note it contains both predefined section sand customer defined sections.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Version of the feature. If not set, default to latest version. Current candidates are ["1.0"].
        """
elif False:
    GeneratorSummarizationContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GeneratorSummarizationContextArgs:
    def __init__(__self__, *,
                 few_shot_examples: Optional[pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleArgs']]]] = None,
                 output_language_code: Optional[pulumi.Input[_builtins.str]] = None,
                 summarization_sections: Optional[pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextSummarizationSectionArgs']]]] = None,
                 version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleArgs']]] few_shot_examples: Optional. List of few shot examples.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] output_language_code: Optional. The target language of the generated summary. The language code for conversation will be used if this field is empty. Supported 2.0 and later versions.
        :param pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextSummarizationSectionArgs']]] summarization_sections: Optional. List of sections. Note it contains both predefined section sand customer defined sections.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] version: Optional. Version of the feature. If not set, default to latest version. Current candidates are ["1.0"].
        """
        if few_shot_examples is not None:
            pulumi.set(__self__, "few_shot_examples", few_shot_examples)
        if output_language_code is not None:
            pulumi.set(__self__, "output_language_code", output_language_code)
        if summarization_sections is not None:
            pulumi.set(__self__, "summarization_sections", summarization_sections)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="fewShotExamples")
    def few_shot_examples(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleArgs']]]]:
        """
        Optional. List of few shot examples.
        Structure is documented below.
        """
        return pulumi.get(self, "few_shot_examples")

    @few_shot_examples.setter
    def few_shot_examples(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleArgs']]]]):
        pulumi.set(self, "few_shot_examples", value)

    @_builtins.property
    @pulumi.getter(name="outputLanguageCode")
    def output_language_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. The target language of the generated summary. The language code for conversation will be used if this field is empty. Supported 2.0 and later versions.
        """
        return pulumi.get(self, "output_language_code")

    @output_language_code.setter
    def output_language_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "output_language_code", value)

    @_builtins.property
    @pulumi.getter(name="summarizationSections")
    def summarization_sections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextSummarizationSectionArgs']]]]:
        """
        Optional. List of sections. Note it contains both predefined section sand customer defined sections.
        Structure is documented below.
        """
        return pulumi.get(self, "summarization_sections")

    @summarization_sections.setter
    def summarization_sections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextSummarizationSectionArgs']]]]):
        pulumi.set(self, "summarization_sections", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Version of the feature. If not set, default to latest version. Current candidates are ["1.0"].
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class GeneratorSummarizationContextFewShotExampleArgsDict(TypedDict):
        output: pulumi.Input['GeneratorSummarizationContextFewShotExampleOutputArgsDict']
        """
        Required. Example output of the model.
        Structure is documented below.
        """
        conversation_context: NotRequired[pulumi.Input['GeneratorSummarizationContextFewShotExampleConversationContextArgsDict']]
        """
        Optional. Conversation transcripts.
        Structure is documented below.
        """
        extra_info: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Optional. Key is the placeholder field name in input, value is the value of the placeholder. E.g. instruction contains "@price", and ingested data has <"price", "10">
        """
        summarization_section_list: NotRequired[pulumi.Input['GeneratorSummarizationContextFewShotExampleSummarizationSectionListArgsDict']]
        """
        Summarization sections.
        Structure is documented below.
        """
elif False:
    GeneratorSummarizationContextFewShotExampleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GeneratorSummarizationContextFewShotExampleArgs:
    def __init__(__self__, *,
                 output: pulumi.Input['GeneratorSummarizationContextFewShotExampleOutputArgs'],
                 conversation_context: Optional[pulumi.Input['GeneratorSummarizationContextFewShotExampleConversationContextArgs']] = None,
                 extra_info: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 summarization_section_list: Optional[pulumi.Input['GeneratorSummarizationContextFewShotExampleSummarizationSectionListArgs']] = None):
        """
        :param pulumi.Input['GeneratorSummarizationContextFewShotExampleOutputArgs'] output: Required. Example output of the model.
               Structure is documented below.
        :param pulumi.Input['GeneratorSummarizationContextFewShotExampleConversationContextArgs'] conversation_context: Optional. Conversation transcripts.
               Structure is documented below.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] extra_info: Optional. Key is the placeholder field name in input, value is the value of the placeholder. E.g. instruction contains "@price", and ingested data has <"price", "10">
        :param pulumi.Input['GeneratorSummarizationContextFewShotExampleSummarizationSectionListArgs'] summarization_section_list: Summarization sections.
               Structure is documented below.
        """
        pulumi.set(__self__, "output", output)
        if conversation_context is not None:
            pulumi.set(__self__, "conversation_context", conversation_context)
        if extra_info is not None:
            pulumi.set(__self__, "extra_info", extra_info)
        if summarization_section_list is not None:
            pulumi.set(__self__, "summarization_section_list", summarization_section_list)

    @_builtins.property
    @pulumi.getter
    def output(self) -> pulumi.Input['GeneratorSummarizationContextFewShotExampleOutputArgs']:
        """
        Required. Example output of the model.
        Structure is documented below.
        """
        return pulumi.get(self, "output")

    @output.setter
    def output(self, value: pulumi.Input['GeneratorSummarizationContextFewShotExampleOutputArgs']):
        pulumi.set(self, "output", value)

    @_builtins.property
    @pulumi.getter(name="conversationContext")
    def conversation_context(self) -> Optional[pulumi.Input['GeneratorSummarizationContextFewShotExampleConversationContextArgs']]:
        """
        Optional. Conversation transcripts.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_context")

    @conversation_context.setter
    def conversation_context(self, value: Optional[pulumi.Input['GeneratorSummarizationContextFewShotExampleConversationContextArgs']]):
        pulumi.set(self, "conversation_context", value)

    @_builtins.property
    @pulumi.getter(name="extraInfo")
    def extra_info(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Optional. Key is the placeholder field name in input, value is the value of the placeholder. E.g. instruction contains "@price", and ingested data has <"price", "10">
        """
        return pulumi.get(self, "extra_info")

    @extra_info.setter
    def extra_info(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "extra_info", value)

    @_builtins.property
    @pulumi.getter(name="summarizationSectionList")
    def summarization_section_list(self) -> Optional[pulumi.Input['GeneratorSummarizationContextFewShotExampleSummarizationSectionListArgs']]:
        """
        Summarization sections.
        Structure is documented below.
        """
        return pulumi.get(self, "summarization_section_list")

    @summarization_section_list.setter
    def summarization_section_list(self, value: Optional[pulumi.Input['GeneratorSummarizationContextFewShotExampleSummarizationSectionListArgs']]):
        pulumi.set(self, "summarization_section_list", value)


if not MYPY:
    class GeneratorSummarizationContextFewShotExampleConversationContextArgsDict(TypedDict):
        message_entries: NotRequired[pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleConversationContextMessageEntryArgsDict']]]]
        """
        Optional. List of message transcripts in the conversation.
        Structure is documented below.
        """
elif False:
    GeneratorSummarizationContextFewShotExampleConversationContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GeneratorSummarizationContextFewShotExampleConversationContextArgs:
    def __init__(__self__, *,
                 message_entries: Optional[pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleConversationContextMessageEntryArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleConversationContextMessageEntryArgs']]] message_entries: Optional. List of message transcripts in the conversation.
               Structure is documented below.
        """
        if message_entries is not None:
            pulumi.set(__self__, "message_entries", message_entries)

    @_builtins.property
    @pulumi.getter(name="messageEntries")
    def message_entries(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleConversationContextMessageEntryArgs']]]]:
        """
        Optional. List of message transcripts in the conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "message_entries")

    @message_entries.setter
    def message_entries(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleConversationContextMessageEntryArgs']]]]):
        pulumi.set(self, "message_entries", value)


if not MYPY:
    class GeneratorSummarizationContextFewShotExampleConversationContextMessageEntryArgsDict(TypedDict):
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Create time of the message entry.
        """
        language_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. The language of the text.
        """
        role: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Participant role of the message.
        Possible values are: `HUMAN_AGENT`, `AUTOMATED_AGENT`, `END_USER`.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Transcript content of the message.
        """
elif False:
    GeneratorSummarizationContextFewShotExampleConversationContextMessageEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GeneratorSummarizationContextFewShotExampleConversationContextMessageEntryArgs:
    def __init__(__self__, *,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 language_code: Optional[pulumi.Input[_builtins.str]] = None,
                 role: Optional[pulumi.Input[_builtins.str]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create_time: Optional. Create time of the message entry.
        :param pulumi.Input[_builtins.str] language_code: Optional. The language of the text.
        :param pulumi.Input[_builtins.str] role: Optional. Participant role of the message.
               Possible values are: `HUMAN_AGENT`, `AUTOMATED_AGENT`, `END_USER`.
        :param pulumi.Input[_builtins.str] text: Optional. Transcript content of the message.
        """
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if language_code is not None:
            pulumi.set(__self__, "language_code", language_code)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Create time of the message entry.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. The language of the text.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "language_code", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Participant role of the message.
        Possible values are: `HUMAN_AGENT`, `AUTOMATED_AGENT`, `END_USER`.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Transcript content of the message.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class GeneratorSummarizationContextFewShotExampleOutputArgsDict(TypedDict):
        summary_suggestion: NotRequired[pulumi.Input['GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionArgsDict']]
        """
        Optional. Suggested summary.
        Structure is documented below.
        """
elif False:
    GeneratorSummarizationContextFewShotExampleOutputArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GeneratorSummarizationContextFewShotExampleOutputArgs:
    def __init__(__self__, *,
                 summary_suggestion: Optional[pulumi.Input['GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionArgs']] = None):
        """
        :param pulumi.Input['GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionArgs'] summary_suggestion: Optional. Suggested summary.
               Structure is documented below.
        """
        if summary_suggestion is not None:
            pulumi.set(__self__, "summary_suggestion", summary_suggestion)

    @_builtins.property
    @pulumi.getter(name="summarySuggestion")
    def summary_suggestion(self) -> Optional[pulumi.Input['GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionArgs']]:
        """
        Optional. Suggested summary.
        Structure is documented below.
        """
        return pulumi.get(self, "summary_suggestion")

    @summary_suggestion.setter
    def summary_suggestion(self, value: Optional[pulumi.Input['GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionArgs']]):
        pulumi.set(self, "summary_suggestion", value)


if not MYPY:
    class GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionArgsDict(TypedDict):
        summary_sections: pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionSummarySectionArgsDict']]]
        """
        Required. All the parts of generated summary.
        Structure is documented below.
        """
elif False:
    GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionArgs:
    def __init__(__self__, *,
                 summary_sections: pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionSummarySectionArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionSummarySectionArgs']]] summary_sections: Required. All the parts of generated summary.
               Structure is documented below.
        """
        pulumi.set(__self__, "summary_sections", summary_sections)

    @_builtins.property
    @pulumi.getter(name="summarySections")
    def summary_sections(self) -> pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionSummarySectionArgs']]]:
        """
        Required. All the parts of generated summary.
        Structure is documented below.
        """
        return pulumi.get(self, "summary_sections")

    @summary_sections.setter
    def summary_sections(self, value: pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionSummarySectionArgs']]]):
        pulumi.set(self, "summary_sections", value)


if not MYPY:
    class GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionSummarySectionArgsDict(TypedDict):
        section: pulumi.Input[_builtins.str]
        """
        Required. Name of the section.
        """
        summary: pulumi.Input[_builtins.str]
        """
        Required. Summary text for the section.
        """
elif False:
    GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionSummarySectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GeneratorSummarizationContextFewShotExampleOutputSummarySuggestionSummarySectionArgs:
    def __init__(__self__, *,
                 section: pulumi.Input[_builtins.str],
                 summary: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] section: Required. Name of the section.
        :param pulumi.Input[_builtins.str] summary: Required. Summary text for the section.
        """
        pulumi.set(__self__, "section", section)
        pulumi.set(__self__, "summary", summary)

    @_builtins.property
    @pulumi.getter
    def section(self) -> pulumi.Input[_builtins.str]:
        """
        Required. Name of the section.
        """
        return pulumi.get(self, "section")

    @section.setter
    def section(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "section", value)

    @_builtins.property
    @pulumi.getter
    def summary(self) -> pulumi.Input[_builtins.str]:
        """
        Required. Summary text for the section.
        """
        return pulumi.get(self, "summary")

    @summary.setter
    def summary(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "summary", value)


if not MYPY:
    class GeneratorSummarizationContextFewShotExampleSummarizationSectionListArgsDict(TypedDict):
        summarization_sections: NotRequired[pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleSummarizationSectionListSummarizationSectionArgsDict']]]]
        """
        Optional. Summarization sections.
        Structure is documented below.
        """
elif False:
    GeneratorSummarizationContextFewShotExampleSummarizationSectionListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GeneratorSummarizationContextFewShotExampleSummarizationSectionListArgs:
    def __init__(__self__, *,
                 summarization_sections: Optional[pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleSummarizationSectionListSummarizationSectionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleSummarizationSectionListSummarizationSectionArgs']]] summarization_sections: Optional. Summarization sections.
               Structure is documented below.
        """
        if summarization_sections is not None:
            pulumi.set(__self__, "summarization_sections", summarization_sections)

    @_builtins.property
    @pulumi.getter(name="summarizationSections")
    def summarization_sections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleSummarizationSectionListSummarizationSectionArgs']]]]:
        """
        Optional. Summarization sections.
        Structure is documented below.
        """
        return pulumi.get(self, "summarization_sections")

    @summarization_sections.setter
    def summarization_sections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['GeneratorSummarizationContextFewShotExampleSummarizationSectionListSummarizationSectionArgs']]]]):
        pulumi.set(self, "summarization_sections", value)


if not MYPY:
    class GeneratorSummarizationContextFewShotExampleSummarizationSectionListSummarizationSectionArgsDict(TypedDict):
        definition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Definition of the section, for example, "what the customer needs help with or has question about."
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Name of the section, for example, "situation".
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Type of the summarization section.
        Possible values are: `SITUATION`, `ACTION`, `RESOLUTION`, `REASON_FOR_CANCELLATION`, `CUSTOMER_SATISFACTION`, `ENTITIES`, `CUSTOMER_DEFINED`, `SITUATION_CONCISE`, `ACTION_CONCISE`.
        """
elif False:
    GeneratorSummarizationContextFewShotExampleSummarizationSectionListSummarizationSectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GeneratorSummarizationContextFewShotExampleSummarizationSectionListSummarizationSectionArgs:
    def __init__(__self__, *,
                 definition: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] definition: Optional. Definition of the section, for example, "what the customer needs help with or has question about."
        :param pulumi.Input[_builtins.str] key: Optional. Name of the section, for example, "situation".
        :param pulumi.Input[_builtins.str] type: Optional. Type of the summarization section.
               Possible values are: `SITUATION`, `ACTION`, `RESOLUTION`, `REASON_FOR_CANCELLATION`, `CUSTOMER_SATISFACTION`, `ENTITIES`, `CUSTOMER_DEFINED`, `SITUATION_CONCISE`, `ACTION_CONCISE`.
        """
        if definition is not None:
            pulumi.set(__self__, "definition", definition)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def definition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Definition of the section, for example, "what the customer needs help with or has question about."
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "definition", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Name of the section, for example, "situation".
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Type of the summarization section.
        Possible values are: `SITUATION`, `ACTION`, `RESOLUTION`, `REASON_FOR_CANCELLATION`, `CUSTOMER_SATISFACTION`, `ENTITIES`, `CUSTOMER_DEFINED`, `SITUATION_CONCISE`, `ACTION_CONCISE`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class GeneratorSummarizationContextSummarizationSectionArgsDict(TypedDict):
        definition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Definition of the section, for example, "what the customer needs help with or has question about."
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Name of the section, for example, "situation".
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Type of the summarization section.
        Possible values are: `SITUATION`, `ACTION`, `RESOLUTION`, `REASON_FOR_CANCELLATION`, `CUSTOMER_SATISFACTION`, `ENTITIES`, `CUSTOMER_DEFINED`, `SITUATION_CONCISE`, `ACTION_CONCISE`.
        """
elif False:
    GeneratorSummarizationContextSummarizationSectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GeneratorSummarizationContextSummarizationSectionArgs:
    def __init__(__self__, *,
                 definition: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] definition: Optional. Definition of the section, for example, "what the customer needs help with or has question about."
        :param pulumi.Input[_builtins.str] key: Optional. Name of the section, for example, "situation".
        :param pulumi.Input[_builtins.str] type: Optional. Type of the summarization section.
               Possible values are: `SITUATION`, `ACTION`, `RESOLUTION`, `REASON_FOR_CANCELLATION`, `CUSTOMER_SATISFACTION`, `ENTITIES`, `CUSTOMER_DEFINED`, `SITUATION_CONCISE`, `ACTION_CONCISE`.
        """
        if definition is not None:
            pulumi.set(__self__, "definition", definition)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def definition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Definition of the section, for example, "what the customer needs help with or has question about."
        """
        return pulumi.get(self, "definition")

    @definition.setter
    def definition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "definition", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Name of the section, for example, "situation".
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Type of the summarization section.
        Possible values are: `SITUATION`, `ACTION`, `RESOLUTION`, `REASON_FOR_CANCELLATION`, `CUSTOMER_SATISFACTION`, `ENTITIES`, `CUSTOMER_DEFINED`, `SITUATION_CONCISE`, `ACTION_CONCISE`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class IntentFollowupIntentInfoArgsDict(TypedDict):
        followup_intent_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier of the followup intent.
        Format: projects/<Project ID>/agent/intents/<Intent ID>.
        """
        parent_followup_intent_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier of the parent intent in the chain of followup intents.
        Format: projects/<Project ID>/agent/intents/<Intent ID>.
        """
elif False:
    IntentFollowupIntentInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IntentFollowupIntentInfoArgs:
    def __init__(__self__, *,
                 followup_intent_name: Optional[pulumi.Input[_builtins.str]] = None,
                 parent_followup_intent_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] followup_intent_name: The unique identifier of the followup intent.
               Format: projects/<Project ID>/agent/intents/<Intent ID>.
        :param pulumi.Input[_builtins.str] parent_followup_intent_name: The unique identifier of the parent intent in the chain of followup intents.
               Format: projects/<Project ID>/agent/intents/<Intent ID>.
        """
        if followup_intent_name is not None:
            pulumi.set(__self__, "followup_intent_name", followup_intent_name)
        if parent_followup_intent_name is not None:
            pulumi.set(__self__, "parent_followup_intent_name", parent_followup_intent_name)

    @_builtins.property
    @pulumi.getter(name="followupIntentName")
    def followup_intent_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier of the followup intent.
        Format: projects/<Project ID>/agent/intents/<Intent ID>.
        """
        return pulumi.get(self, "followup_intent_name")

    @followup_intent_name.setter
    def followup_intent_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "followup_intent_name", value)

    @_builtins.property
    @pulumi.getter(name="parentFollowupIntentName")
    def parent_followup_intent_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier of the parent intent in the chain of followup intents.
        Format: projects/<Project ID>/agent/intents/<Intent ID>.
        """
        return pulumi.get(self, "parent_followup_intent_name")

    @parent_followup_intent_name.setter
    def parent_followup_intent_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "parent_followup_intent_name", value)


