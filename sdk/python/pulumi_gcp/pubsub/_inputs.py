# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'LiteSubscriptionDeliveryConfigArgs',
    'LiteSubscriptionDeliveryConfigArgsDict',
    'LiteTopicPartitionConfigArgs',
    'LiteTopicPartitionConfigArgsDict',
    'LiteTopicPartitionConfigCapacityArgs',
    'LiteTopicPartitionConfigCapacityArgsDict',
    'LiteTopicReservationConfigArgs',
    'LiteTopicReservationConfigArgsDict',
    'LiteTopicRetentionConfigArgs',
    'LiteTopicRetentionConfigArgsDict',
    'SchemaIamBindingConditionArgs',
    'SchemaIamBindingConditionArgsDict',
    'SchemaIamMemberConditionArgs',
    'SchemaIamMemberConditionArgsDict',
    'SubscriptionBigqueryConfigArgs',
    'SubscriptionBigqueryConfigArgsDict',
    'SubscriptionCloudStorageConfigArgs',
    'SubscriptionCloudStorageConfigArgsDict',
    'SubscriptionCloudStorageConfigAvroConfigArgs',
    'SubscriptionCloudStorageConfigAvroConfigArgsDict',
    'SubscriptionDeadLetterPolicyArgs',
    'SubscriptionDeadLetterPolicyArgsDict',
    'SubscriptionExpirationPolicyArgs',
    'SubscriptionExpirationPolicyArgsDict',
    'SubscriptionIAMBindingConditionArgs',
    'SubscriptionIAMBindingConditionArgsDict',
    'SubscriptionIAMMemberConditionArgs',
    'SubscriptionIAMMemberConditionArgsDict',
    'SubscriptionPushConfigArgs',
    'SubscriptionPushConfigArgsDict',
    'SubscriptionPushConfigNoWrapperArgs',
    'SubscriptionPushConfigNoWrapperArgsDict',
    'SubscriptionPushConfigOidcTokenArgs',
    'SubscriptionPushConfigOidcTokenArgsDict',
    'SubscriptionRetryPolicyArgs',
    'SubscriptionRetryPolicyArgsDict',
    'TopicIAMBindingConditionArgs',
    'TopicIAMBindingConditionArgsDict',
    'TopicIAMMemberConditionArgs',
    'TopicIAMMemberConditionArgsDict',
    'TopicIngestionDataSourceSettingsArgs',
    'TopicIngestionDataSourceSettingsArgsDict',
    'TopicIngestionDataSourceSettingsAwsKinesisArgs',
    'TopicIngestionDataSourceSettingsAwsKinesisArgsDict',
    'TopicIngestionDataSourceSettingsAwsMskArgs',
    'TopicIngestionDataSourceSettingsAwsMskArgsDict',
    'TopicIngestionDataSourceSettingsAzureEventHubsArgs',
    'TopicIngestionDataSourceSettingsAzureEventHubsArgsDict',
    'TopicIngestionDataSourceSettingsCloudStorageArgs',
    'TopicIngestionDataSourceSettingsCloudStorageArgsDict',
    'TopicIngestionDataSourceSettingsCloudStorageAvroFormatArgs',
    'TopicIngestionDataSourceSettingsCloudStorageAvroFormatArgsDict',
    'TopicIngestionDataSourceSettingsCloudStoragePubsubAvroFormatArgs',
    'TopicIngestionDataSourceSettingsCloudStoragePubsubAvroFormatArgsDict',
    'TopicIngestionDataSourceSettingsCloudStorageTextFormatArgs',
    'TopicIngestionDataSourceSettingsCloudStorageTextFormatArgsDict',
    'TopicIngestionDataSourceSettingsConfluentCloudArgs',
    'TopicIngestionDataSourceSettingsConfluentCloudArgsDict',
    'TopicIngestionDataSourceSettingsPlatformLogsSettingsArgs',
    'TopicIngestionDataSourceSettingsPlatformLogsSettingsArgsDict',
    'TopicMessageStoragePolicyArgs',
    'TopicMessageStoragePolicyArgsDict',
    'TopicSchemaSettingsArgs',
    'TopicSchemaSettingsArgsDict',
]

MYPY = False

if not MYPY:
    class LiteSubscriptionDeliveryConfigArgsDict(TypedDict):
        delivery_requirement: pulumi.Input[builtins.str]
        """
        When this subscription should send messages to subscribers relative to messages persistence in storage.
        Possible values are: `DELIVER_IMMEDIATELY`, `DELIVER_AFTER_STORED`, `DELIVERY_REQUIREMENT_UNSPECIFIED`.
        """
elif False:
    LiteSubscriptionDeliveryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiteSubscriptionDeliveryConfigArgs:
    def __init__(__self__, *,
                 delivery_requirement: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] delivery_requirement: When this subscription should send messages to subscribers relative to messages persistence in storage.
               Possible values are: `DELIVER_IMMEDIATELY`, `DELIVER_AFTER_STORED`, `DELIVERY_REQUIREMENT_UNSPECIFIED`.
        """
        pulumi.set(__self__, "delivery_requirement", delivery_requirement)

    @property
    @pulumi.getter(name="deliveryRequirement")
    def delivery_requirement(self) -> pulumi.Input[builtins.str]:
        """
        When this subscription should send messages to subscribers relative to messages persistence in storage.
        Possible values are: `DELIVER_IMMEDIATELY`, `DELIVER_AFTER_STORED`, `DELIVERY_REQUIREMENT_UNSPECIFIED`.
        """
        return pulumi.get(self, "delivery_requirement")

    @delivery_requirement.setter
    def delivery_requirement(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "delivery_requirement", value)


if not MYPY:
    class LiteTopicPartitionConfigArgsDict(TypedDict):
        count: pulumi.Input[builtins.int]
        """
        The number of partitions in the topic. Must be at least 1.
        """
        capacity: NotRequired[pulumi.Input['LiteTopicPartitionConfigCapacityArgsDict']]
        """
        The capacity configuration.
        Structure is documented below.
        """
elif False:
    LiteTopicPartitionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiteTopicPartitionConfigArgs:
    def __init__(__self__, *,
                 count: pulumi.Input[builtins.int],
                 capacity: Optional[pulumi.Input['LiteTopicPartitionConfigCapacityArgs']] = None):
        """
        :param pulumi.Input[builtins.int] count: The number of partitions in the topic. Must be at least 1.
        :param pulumi.Input['LiteTopicPartitionConfigCapacityArgs'] capacity: The capacity configuration.
               Structure is documented below.
        """
        pulumi.set(__self__, "count", count)
        if capacity is not None:
            pulumi.set(__self__, "capacity", capacity)

    @property
    @pulumi.getter
    def count(self) -> pulumi.Input[builtins.int]:
        """
        The number of partitions in the topic. Must be at least 1.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "count", value)

    @property
    @pulumi.getter
    def capacity(self) -> Optional[pulumi.Input['LiteTopicPartitionConfigCapacityArgs']]:
        """
        The capacity configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: Optional[pulumi.Input['LiteTopicPartitionConfigCapacityArgs']]):
        pulumi.set(self, "capacity", value)


if not MYPY:
    class LiteTopicPartitionConfigCapacityArgsDict(TypedDict):
        publish_mib_per_sec: pulumi.Input[builtins.int]
        """
        Subscribe throughput capacity per partition in MiB/s. Must be >= 4 and <= 16.
        """
        subscribe_mib_per_sec: pulumi.Input[builtins.int]
        """
        Publish throughput capacity per partition in MiB/s. Must be >= 4 and <= 16.
        """
elif False:
    LiteTopicPartitionConfigCapacityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiteTopicPartitionConfigCapacityArgs:
    def __init__(__self__, *,
                 publish_mib_per_sec: pulumi.Input[builtins.int],
                 subscribe_mib_per_sec: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.int] publish_mib_per_sec: Subscribe throughput capacity per partition in MiB/s. Must be >= 4 and <= 16.
        :param pulumi.Input[builtins.int] subscribe_mib_per_sec: Publish throughput capacity per partition in MiB/s. Must be >= 4 and <= 16.
        """
        pulumi.set(__self__, "publish_mib_per_sec", publish_mib_per_sec)
        pulumi.set(__self__, "subscribe_mib_per_sec", subscribe_mib_per_sec)

    @property
    @pulumi.getter(name="publishMibPerSec")
    def publish_mib_per_sec(self) -> pulumi.Input[builtins.int]:
        """
        Subscribe throughput capacity per partition in MiB/s. Must be >= 4 and <= 16.
        """
        return pulumi.get(self, "publish_mib_per_sec")

    @publish_mib_per_sec.setter
    def publish_mib_per_sec(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "publish_mib_per_sec", value)

    @property
    @pulumi.getter(name="subscribeMibPerSec")
    def subscribe_mib_per_sec(self) -> pulumi.Input[builtins.int]:
        """
        Publish throughput capacity per partition in MiB/s. Must be >= 4 and <= 16.
        """
        return pulumi.get(self, "subscribe_mib_per_sec")

    @subscribe_mib_per_sec.setter
    def subscribe_mib_per_sec(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "subscribe_mib_per_sec", value)


if not MYPY:
    class LiteTopicReservationConfigArgsDict(TypedDict):
        throughput_reservation: NotRequired[pulumi.Input[builtins.str]]
        """
        The Reservation to use for this topic's throughput capacity.
        """
elif False:
    LiteTopicReservationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiteTopicReservationConfigArgs:
    def __init__(__self__, *,
                 throughput_reservation: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] throughput_reservation: The Reservation to use for this topic's throughput capacity.
        """
        if throughput_reservation is not None:
            pulumi.set(__self__, "throughput_reservation", throughput_reservation)

    @property
    @pulumi.getter(name="throughputReservation")
    def throughput_reservation(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Reservation to use for this topic's throughput capacity.
        """
        return pulumi.get(self, "throughput_reservation")

    @throughput_reservation.setter
    def throughput_reservation(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "throughput_reservation", value)


if not MYPY:
    class LiteTopicRetentionConfigArgsDict(TypedDict):
        per_partition_bytes: pulumi.Input[builtins.str]
        """
        The provisioned storage, in bytes, per partition. If the number of bytes stored
        in any of the topic's partitions grows beyond this value, older messages will be
        dropped to make room for newer ones, regardless of the value of period.
        """
        period: NotRequired[pulumi.Input[builtins.str]]
        """
        How long a published message is retained. If unset, messages will be retained as
        long as the bytes retained for each partition is below perPartitionBytes. A
        duration in seconds with up to nine fractional digits, terminated by 's'.
        Example: "3.5s".
        """
elif False:
    LiteTopicRetentionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class LiteTopicRetentionConfigArgs:
    def __init__(__self__, *,
                 per_partition_bytes: pulumi.Input[builtins.str],
                 period: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] per_partition_bytes: The provisioned storage, in bytes, per partition. If the number of bytes stored
               in any of the topic's partitions grows beyond this value, older messages will be
               dropped to make room for newer ones, regardless of the value of period.
        :param pulumi.Input[builtins.str] period: How long a published message is retained. If unset, messages will be retained as
               long as the bytes retained for each partition is below perPartitionBytes. A
               duration in seconds with up to nine fractional digits, terminated by 's'.
               Example: "3.5s".
        """
        pulumi.set(__self__, "per_partition_bytes", per_partition_bytes)
        if period is not None:
            pulumi.set(__self__, "period", period)

    @property
    @pulumi.getter(name="perPartitionBytes")
    def per_partition_bytes(self) -> pulumi.Input[builtins.str]:
        """
        The provisioned storage, in bytes, per partition. If the number of bytes stored
        in any of the topic's partitions grows beyond this value, older messages will be
        dropped to make room for newer ones, regardless of the value of period.
        """
        return pulumi.get(self, "per_partition_bytes")

    @per_partition_bytes.setter
    def per_partition_bytes(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "per_partition_bytes", value)

    @property
    @pulumi.getter
    def period(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        How long a published message is retained. If unset, messages will be retained as
        long as the bytes retained for each partition is below perPartitionBytes. A
        duration in seconds with up to nine fractional digits, terminated by 's'.
        Example: "3.5s".
        """
        return pulumi.get(self, "period")

    @period.setter
    def period(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "period", value)


if not MYPY:
    class SchemaIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    SchemaIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchemaIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class SchemaIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    SchemaIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SchemaIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class SubscriptionBigqueryConfigArgsDict(TypedDict):
        table: pulumi.Input[builtins.str]
        """
        The name of the table to which to write data, of the form {projectId}.{datasetId}.{tableId}
        """
        drop_unknown_fields: NotRequired[pulumi.Input[builtins.bool]]
        """
        When true and use_topic_schema or use_table_schema is true, any fields that are a part of the topic schema or message schema that
        are not part of the BigQuery table schema are dropped when writing to BigQuery. Otherwise, the schemas must be kept in sync
        and any messages with extra fields are not written and remain in the subscription's backlog.
        """
        service_account_email: NotRequired[pulumi.Input[builtins.str]]
        """
        The service account to use to write to BigQuery. If not specified, the Pub/Sub
        [service agent](https://cloud.google.com/iam/docs/service-agents),
        service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
        """
        use_table_schema: NotRequired[pulumi.Input[builtins.bool]]
        """
        When true, use the BigQuery table's schema as the columns to write to in BigQuery. Messages
        must be published in JSON format. Only one of use_topic_schema and use_table_schema can be set.
        """
        use_topic_schema: NotRequired[pulumi.Input[builtins.bool]]
        """
        When true, use the topic's schema as the columns to write to in BigQuery, if it exists.
        Only one of use_topic_schema and use_table_schema can be set.
        """
        write_metadata: NotRequired[pulumi.Input[builtins.bool]]
        """
        When true, write the subscription name, messageId, publishTime, attributes, and orderingKey to additional columns in the table.
        The subscription name, messageId, and publishTime fields are put in their own columns while all other message properties (other than data) are written to a JSON object in the attributes column.
        """
elif False:
    SubscriptionBigqueryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionBigqueryConfigArgs:
    def __init__(__self__, *,
                 table: pulumi.Input[builtins.str],
                 drop_unknown_fields: Optional[pulumi.Input[builtins.bool]] = None,
                 service_account_email: Optional[pulumi.Input[builtins.str]] = None,
                 use_table_schema: Optional[pulumi.Input[builtins.bool]] = None,
                 use_topic_schema: Optional[pulumi.Input[builtins.bool]] = None,
                 write_metadata: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.str] table: The name of the table to which to write data, of the form {projectId}.{datasetId}.{tableId}
        :param pulumi.Input[builtins.bool] drop_unknown_fields: When true and use_topic_schema or use_table_schema is true, any fields that are a part of the topic schema or message schema that
               are not part of the BigQuery table schema are dropped when writing to BigQuery. Otherwise, the schemas must be kept in sync
               and any messages with extra fields are not written and remain in the subscription's backlog.
        :param pulumi.Input[builtins.str] service_account_email: The service account to use to write to BigQuery. If not specified, the Pub/Sub
               [service agent](https://cloud.google.com/iam/docs/service-agents),
               service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
        :param pulumi.Input[builtins.bool] use_table_schema: When true, use the BigQuery table's schema as the columns to write to in BigQuery. Messages
               must be published in JSON format. Only one of use_topic_schema and use_table_schema can be set.
        :param pulumi.Input[builtins.bool] use_topic_schema: When true, use the topic's schema as the columns to write to in BigQuery, if it exists.
               Only one of use_topic_schema and use_table_schema can be set.
        :param pulumi.Input[builtins.bool] write_metadata: When true, write the subscription name, messageId, publishTime, attributes, and orderingKey to additional columns in the table.
               The subscription name, messageId, and publishTime fields are put in their own columns while all other message properties (other than data) are written to a JSON object in the attributes column.
        """
        pulumi.set(__self__, "table", table)
        if drop_unknown_fields is not None:
            pulumi.set(__self__, "drop_unknown_fields", drop_unknown_fields)
        if service_account_email is not None:
            pulumi.set(__self__, "service_account_email", service_account_email)
        if use_table_schema is not None:
            pulumi.set(__self__, "use_table_schema", use_table_schema)
        if use_topic_schema is not None:
            pulumi.set(__self__, "use_topic_schema", use_topic_schema)
        if write_metadata is not None:
            pulumi.set(__self__, "write_metadata", write_metadata)

    @property
    @pulumi.getter
    def table(self) -> pulumi.Input[builtins.str]:
        """
        The name of the table to which to write data, of the form {projectId}.{datasetId}.{tableId}
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="dropUnknownFields")
    def drop_unknown_fields(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When true and use_topic_schema or use_table_schema is true, any fields that are a part of the topic schema or message schema that
        are not part of the BigQuery table schema are dropped when writing to BigQuery. Otherwise, the schemas must be kept in sync
        and any messages with extra fields are not written and remain in the subscription's backlog.
        """
        return pulumi.get(self, "drop_unknown_fields")

    @drop_unknown_fields.setter
    def drop_unknown_fields(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "drop_unknown_fields", value)

    @property
    @pulumi.getter(name="serviceAccountEmail")
    def service_account_email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The service account to use to write to BigQuery. If not specified, the Pub/Sub
        [service agent](https://cloud.google.com/iam/docs/service-agents),
        service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
        """
        return pulumi.get(self, "service_account_email")

    @service_account_email.setter
    def service_account_email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "service_account_email", value)

    @property
    @pulumi.getter(name="useTableSchema")
    def use_table_schema(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When true, use the BigQuery table's schema as the columns to write to in BigQuery. Messages
        must be published in JSON format. Only one of use_topic_schema and use_table_schema can be set.
        """
        return pulumi.get(self, "use_table_schema")

    @use_table_schema.setter
    def use_table_schema(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_table_schema", value)

    @property
    @pulumi.getter(name="useTopicSchema")
    def use_topic_schema(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When true, use the topic's schema as the columns to write to in BigQuery, if it exists.
        Only one of use_topic_schema and use_table_schema can be set.
        """
        return pulumi.get(self, "use_topic_schema")

    @use_topic_schema.setter
    def use_topic_schema(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_topic_schema", value)

    @property
    @pulumi.getter(name="writeMetadata")
    def write_metadata(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When true, write the subscription name, messageId, publishTime, attributes, and orderingKey to additional columns in the table.
        The subscription name, messageId, and publishTime fields are put in their own columns while all other message properties (other than data) are written to a JSON object in the attributes column.
        """
        return pulumi.get(self, "write_metadata")

    @write_metadata.setter
    def write_metadata(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "write_metadata", value)


if not MYPY:
    class SubscriptionCloudStorageConfigArgsDict(TypedDict):
        bucket: pulumi.Input[builtins.str]
        """
        User-provided name for the Cloud Storage bucket. The bucket must be created by the user. The bucket name must be without any prefix like "gs://".
        """
        avro_config: NotRequired[pulumi.Input['SubscriptionCloudStorageConfigAvroConfigArgsDict']]
        """
        If set, message data will be written to Cloud Storage in Avro format.
        Structure is documented below.
        """
        filename_datetime_format: NotRequired[pulumi.Input[builtins.str]]
        """
        User-provided format string specifying how to represent datetimes in Cloud Storage filenames.
        """
        filename_prefix: NotRequired[pulumi.Input[builtins.str]]
        """
        User-provided prefix for Cloud Storage filename.
        """
        filename_suffix: NotRequired[pulumi.Input[builtins.str]]
        """
        User-provided suffix for Cloud Storage filename. Must not end in "/".
        """
        max_bytes: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum bytes that can be written to a Cloud Storage file before a new file is created. Min 1 KB, max 10 GiB.
        The maxBytes limit may be exceeded in cases where messages are larger than the limit.
        """
        max_duration: NotRequired[pulumi.Input[builtins.str]]
        """
        The maximum duration that can elapse before a new Cloud Storage file is created. Min 1 minute, max 10 minutes, default 5 minutes.
        May not exceed the subscription's acknowledgement deadline.
        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
        """
        max_messages: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum messages that can be written to a Cloud Storage file before a new file is created. Min 1000 messages.
        """
        service_account_email: NotRequired[pulumi.Input[builtins.str]]
        """
        The service account to use to write to Cloud Storage. If not specified, the Pub/Sub
        [service agent](https://cloud.google.com/iam/docs/service-agents),
        service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
        """
        state: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        An output-only field that indicates whether or not the subscription can receive messages.
        """
elif False:
    SubscriptionCloudStorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionCloudStorageConfigArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[builtins.str],
                 avro_config: Optional[pulumi.Input['SubscriptionCloudStorageConfigAvroConfigArgs']] = None,
                 filename_datetime_format: Optional[pulumi.Input[builtins.str]] = None,
                 filename_prefix: Optional[pulumi.Input[builtins.str]] = None,
                 filename_suffix: Optional[pulumi.Input[builtins.str]] = None,
                 max_bytes: Optional[pulumi.Input[builtins.int]] = None,
                 max_duration: Optional[pulumi.Input[builtins.str]] = None,
                 max_messages: Optional[pulumi.Input[builtins.int]] = None,
                 service_account_email: Optional[pulumi.Input[builtins.str]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] bucket: User-provided name for the Cloud Storage bucket. The bucket must be created by the user. The bucket name must be without any prefix like "gs://".
        :param pulumi.Input['SubscriptionCloudStorageConfigAvroConfigArgs'] avro_config: If set, message data will be written to Cloud Storage in Avro format.
               Structure is documented below.
        :param pulumi.Input[builtins.str] filename_datetime_format: User-provided format string specifying how to represent datetimes in Cloud Storage filenames.
        :param pulumi.Input[builtins.str] filename_prefix: User-provided prefix for Cloud Storage filename.
        :param pulumi.Input[builtins.str] filename_suffix: User-provided suffix for Cloud Storage filename. Must not end in "/".
        :param pulumi.Input[builtins.int] max_bytes: The maximum bytes that can be written to a Cloud Storage file before a new file is created. Min 1 KB, max 10 GiB.
               The maxBytes limit may be exceeded in cases where messages are larger than the limit.
        :param pulumi.Input[builtins.str] max_duration: The maximum duration that can elapse before a new Cloud Storage file is created. Min 1 minute, max 10 minutes, default 5 minutes.
               May not exceed the subscription's acknowledgement deadline.
               A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
        :param pulumi.Input[builtins.int] max_messages: The maximum messages that can be written to a Cloud Storage file before a new file is created. Min 1000 messages.
        :param pulumi.Input[builtins.str] service_account_email: The service account to use to write to Cloud Storage. If not specified, the Pub/Sub
               [service agent](https://cloud.google.com/iam/docs/service-agents),
               service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
        :param pulumi.Input[builtins.str] state: (Output)
               An output-only field that indicates whether or not the subscription can receive messages.
        """
        pulumi.set(__self__, "bucket", bucket)
        if avro_config is not None:
            pulumi.set(__self__, "avro_config", avro_config)
        if filename_datetime_format is not None:
            pulumi.set(__self__, "filename_datetime_format", filename_datetime_format)
        if filename_prefix is not None:
            pulumi.set(__self__, "filename_prefix", filename_prefix)
        if filename_suffix is not None:
            pulumi.set(__self__, "filename_suffix", filename_suffix)
        if max_bytes is not None:
            pulumi.set(__self__, "max_bytes", max_bytes)
        if max_duration is not None:
            pulumi.set(__self__, "max_duration", max_duration)
        if max_messages is not None:
            pulumi.set(__self__, "max_messages", max_messages)
        if service_account_email is not None:
            pulumi.set(__self__, "service_account_email", service_account_email)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[builtins.str]:
        """
        User-provided name for the Cloud Storage bucket. The bucket must be created by the user. The bucket name must be without any prefix like "gs://".
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="avroConfig")
    def avro_config(self) -> Optional[pulumi.Input['SubscriptionCloudStorageConfigAvroConfigArgs']]:
        """
        If set, message data will be written to Cloud Storage in Avro format.
        Structure is documented below.
        """
        return pulumi.get(self, "avro_config")

    @avro_config.setter
    def avro_config(self, value: Optional[pulumi.Input['SubscriptionCloudStorageConfigAvroConfigArgs']]):
        pulumi.set(self, "avro_config", value)

    @property
    @pulumi.getter(name="filenameDatetimeFormat")
    def filename_datetime_format(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User-provided format string specifying how to represent datetimes in Cloud Storage filenames.
        """
        return pulumi.get(self, "filename_datetime_format")

    @filename_datetime_format.setter
    def filename_datetime_format(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "filename_datetime_format", value)

    @property
    @pulumi.getter(name="filenamePrefix")
    def filename_prefix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User-provided prefix for Cloud Storage filename.
        """
        return pulumi.get(self, "filename_prefix")

    @filename_prefix.setter
    def filename_prefix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "filename_prefix", value)

    @property
    @pulumi.getter(name="filenameSuffix")
    def filename_suffix(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        User-provided suffix for Cloud Storage filename. Must not end in "/".
        """
        return pulumi.get(self, "filename_suffix")

    @filename_suffix.setter
    def filename_suffix(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "filename_suffix", value)

    @property
    @pulumi.getter(name="maxBytes")
    def max_bytes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum bytes that can be written to a Cloud Storage file before a new file is created. Min 1 KB, max 10 GiB.
        The maxBytes limit may be exceeded in cases where messages are larger than the limit.
        """
        return pulumi.get(self, "max_bytes")

    @max_bytes.setter
    def max_bytes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_bytes", value)

    @property
    @pulumi.getter(name="maxDuration")
    def max_duration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The maximum duration that can elapse before a new Cloud Storage file is created. Min 1 minute, max 10 minutes, default 5 minutes.
        May not exceed the subscription's acknowledgement deadline.
        A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
        """
        return pulumi.get(self, "max_duration")

    @max_duration.setter
    def max_duration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "max_duration", value)

    @property
    @pulumi.getter(name="maxMessages")
    def max_messages(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum messages that can be written to a Cloud Storage file before a new file is created. Min 1000 messages.
        """
        return pulumi.get(self, "max_messages")

    @max_messages.setter
    def max_messages(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_messages", value)

    @property
    @pulumi.getter(name="serviceAccountEmail")
    def service_account_email(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The service account to use to write to Cloud Storage. If not specified, the Pub/Sub
        [service agent](https://cloud.google.com/iam/docs/service-agents),
        service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com, is used.
        """
        return pulumi.get(self, "service_account_email")

    @service_account_email.setter
    def service_account_email(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "service_account_email", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        An output-only field that indicates whether or not the subscription can receive messages.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class SubscriptionCloudStorageConfigAvroConfigArgsDict(TypedDict):
        use_topic_schema: NotRequired[pulumi.Input[builtins.bool]]
        """
        When true, the output Cloud Storage file will be serialized using the topic schema, if it exists.
        """
        write_metadata: NotRequired[pulumi.Input[builtins.bool]]
        """
        When true, write the subscription name, messageId, publishTime, attributes, and orderingKey as additional fields in the output.
        """
elif False:
    SubscriptionCloudStorageConfigAvroConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionCloudStorageConfigAvroConfigArgs:
    def __init__(__self__, *,
                 use_topic_schema: Optional[pulumi.Input[builtins.bool]] = None,
                 write_metadata: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] use_topic_schema: When true, the output Cloud Storage file will be serialized using the topic schema, if it exists.
        :param pulumi.Input[builtins.bool] write_metadata: When true, write the subscription name, messageId, publishTime, attributes, and orderingKey as additional fields in the output.
        """
        if use_topic_schema is not None:
            pulumi.set(__self__, "use_topic_schema", use_topic_schema)
        if write_metadata is not None:
            pulumi.set(__self__, "write_metadata", write_metadata)

    @property
    @pulumi.getter(name="useTopicSchema")
    def use_topic_schema(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When true, the output Cloud Storage file will be serialized using the topic schema, if it exists.
        """
        return pulumi.get(self, "use_topic_schema")

    @use_topic_schema.setter
    def use_topic_schema(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "use_topic_schema", value)

    @property
    @pulumi.getter(name="writeMetadata")
    def write_metadata(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When true, write the subscription name, messageId, publishTime, attributes, and orderingKey as additional fields in the output.
        """
        return pulumi.get(self, "write_metadata")

    @write_metadata.setter
    def write_metadata(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "write_metadata", value)


if not MYPY:
    class SubscriptionDeadLetterPolicyArgsDict(TypedDict):
        dead_letter_topic: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the topic to which dead letter messages should be published.
        Format is `projects/{project}/topics/{topic}`.
        The Cloud Pub/Sub service account associated with the enclosing subscription's
        parent project (i.e.,
        service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
        permission to Publish() to this topic.
        The operation will fail if the topic does not exist.
        Users should ensure that there is a subscription attached to this topic
        since messages published to a topic with no subscriptions are lost.
        """
        max_delivery_attempts: NotRequired[pulumi.Input[builtins.int]]
        """
        The maximum number of delivery attempts for any message. The value must be
        between 5 and 100.
        The number of delivery attempts is defined as 1 + (the sum of number of
        NACKs and number of times the acknowledgement deadline has been exceeded for the message).
        A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
        client libraries may automatically extend ack_deadlines.
        This field will be honored on a best effort basis.
        If this parameter is 0, a default value of 5 is used.
        """
elif False:
    SubscriptionDeadLetterPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionDeadLetterPolicyArgs:
    def __init__(__self__, *,
                 dead_letter_topic: Optional[pulumi.Input[builtins.str]] = None,
                 max_delivery_attempts: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] dead_letter_topic: The name of the topic to which dead letter messages should be published.
               Format is `projects/{project}/topics/{topic}`.
               The Cloud Pub/Sub service account associated with the enclosing subscription's
               parent project (i.e.,
               service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
               permission to Publish() to this topic.
               The operation will fail if the topic does not exist.
               Users should ensure that there is a subscription attached to this topic
               since messages published to a topic with no subscriptions are lost.
        :param pulumi.Input[builtins.int] max_delivery_attempts: The maximum number of delivery attempts for any message. The value must be
               between 5 and 100.
               The number of delivery attempts is defined as 1 + (the sum of number of
               NACKs and number of times the acknowledgement deadline has been exceeded for the message).
               A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
               client libraries may automatically extend ack_deadlines.
               This field will be honored on a best effort basis.
               If this parameter is 0, a default value of 5 is used.
        """
        if dead_letter_topic is not None:
            pulumi.set(__self__, "dead_letter_topic", dead_letter_topic)
        if max_delivery_attempts is not None:
            pulumi.set(__self__, "max_delivery_attempts", max_delivery_attempts)

    @property
    @pulumi.getter(name="deadLetterTopic")
    def dead_letter_topic(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the topic to which dead letter messages should be published.
        Format is `projects/{project}/topics/{topic}`.
        The Cloud Pub/Sub service account associated with the enclosing subscription's
        parent project (i.e.,
        service-{project_number}@gcp-sa-pubsub.iam.gserviceaccount.com) must have
        permission to Publish() to this topic.
        The operation will fail if the topic does not exist.
        Users should ensure that there is a subscription attached to this topic
        since messages published to a topic with no subscriptions are lost.
        """
        return pulumi.get(self, "dead_letter_topic")

    @dead_letter_topic.setter
    def dead_letter_topic(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dead_letter_topic", value)

    @property
    @pulumi.getter(name="maxDeliveryAttempts")
    def max_delivery_attempts(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The maximum number of delivery attempts for any message. The value must be
        between 5 and 100.
        The number of delivery attempts is defined as 1 + (the sum of number of
        NACKs and number of times the acknowledgement deadline has been exceeded for the message).
        A NACK is any call to ModifyAckDeadline with a 0 deadline. Note that
        client libraries may automatically extend ack_deadlines.
        This field will be honored on a best effort basis.
        If this parameter is 0, a default value of 5 is used.
        """
        return pulumi.get(self, "max_delivery_attempts")

    @max_delivery_attempts.setter
    def max_delivery_attempts(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_delivery_attempts", value)


if not MYPY:
    class SubscriptionExpirationPolicyArgsDict(TypedDict):
        ttl: pulumi.Input[builtins.str]
        """
        Specifies the "time-to-live" duration for an associated resource. The
        resource expires if it is not active for a period of ttl.
        If ttl is set to "", the associated resource never expires.
        A duration in seconds with up to nine fractional digits, terminated by 's'.
        Example - "3.5s".
        """
elif False:
    SubscriptionExpirationPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionExpirationPolicyArgs:
    def __init__(__self__, *,
                 ttl: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] ttl: Specifies the "time-to-live" duration for an associated resource. The
               resource expires if it is not active for a period of ttl.
               If ttl is set to "", the associated resource never expires.
               A duration in seconds with up to nine fractional digits, terminated by 's'.
               Example - "3.5s".
        """
        pulumi.set(__self__, "ttl", ttl)

    @property
    @pulumi.getter
    def ttl(self) -> pulumi.Input[builtins.str]:
        """
        Specifies the "time-to-live" duration for an associated resource. The
        resource expires if it is not active for a period of ttl.
        If ttl is set to "", the associated resource never expires.
        A duration in seconds with up to nine fractional digits, terminated by 's'.
        Example - "3.5s".
        """
        return pulumi.get(self, "ttl")

    @ttl.setter
    def ttl(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ttl", value)


if not MYPY:
    class SubscriptionIAMBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    SubscriptionIAMBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionIAMBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class SubscriptionIAMMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    SubscriptionIAMMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionIAMMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class SubscriptionPushConfigArgsDict(TypedDict):
        push_endpoint: pulumi.Input[builtins.str]
        """
        A URL locating the endpoint to which messages should be pushed.
        For example, a Webhook endpoint might use
        "https://example.com/push".
        """
        attributes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        Endpoint configuration attributes.
        Every endpoint has a set of API supported attributes that can
        be used to control different aspects of the message delivery.
        The currently supported attribute is x-goog-version, which you
        can use to change the format of the pushed message. This
        attribute indicates the version of the data expected by
        the endpoint. This controls the shape of the pushed message
        (i.e., its fields and metadata). The endpoint version is
        based on the version of the Pub/Sub API.
        If not present during the subscriptions.create call,
        it will default to the version of the API used to make
        such call. If not present during a subscriptions.modifyPushConfig
        call, its value will not be changed. subscriptions.get
        calls will always return a valid version, even if the
        subscription was created without this attribute.
        The possible values for this attribute are:
        - v1beta1: uses the push format defined in the v1beta1 Pub/Sub API.
        - v1 or v1beta2: uses the push format defined in the v1 Pub/Sub API.
        """
        no_wrapper: NotRequired[pulumi.Input['SubscriptionPushConfigNoWrapperArgsDict']]
        """
        When set, the payload to the push endpoint is not wrapped.Sets the
        `data` field as the HTTP body for delivery.
        Structure is documented below.
        """
        oidc_token: NotRequired[pulumi.Input['SubscriptionPushConfigOidcTokenArgsDict']]
        """
        If specified, Pub/Sub will generate and attach an OIDC JWT token as
        an Authorization header in the HTTP request for every pushed message.
        Structure is documented below.
        """
elif False:
    SubscriptionPushConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionPushConfigArgs:
    def __init__(__self__, *,
                 push_endpoint: pulumi.Input[builtins.str],
                 attributes: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 no_wrapper: Optional[pulumi.Input['SubscriptionPushConfigNoWrapperArgs']] = None,
                 oidc_token: Optional[pulumi.Input['SubscriptionPushConfigOidcTokenArgs']] = None):
        """
        :param pulumi.Input[builtins.str] push_endpoint: A URL locating the endpoint to which messages should be pushed.
               For example, a Webhook endpoint might use
               "https://example.com/push".
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] attributes: Endpoint configuration attributes.
               Every endpoint has a set of API supported attributes that can
               be used to control different aspects of the message delivery.
               The currently supported attribute is x-goog-version, which you
               can use to change the format of the pushed message. This
               attribute indicates the version of the data expected by
               the endpoint. This controls the shape of the pushed message
               (i.e., its fields and metadata). The endpoint version is
               based on the version of the Pub/Sub API.
               If not present during the subscriptions.create call,
               it will default to the version of the API used to make
               such call. If not present during a subscriptions.modifyPushConfig
               call, its value will not be changed. subscriptions.get
               calls will always return a valid version, even if the
               subscription was created without this attribute.
               The possible values for this attribute are:
               - v1beta1: uses the push format defined in the v1beta1 Pub/Sub API.
               - v1 or v1beta2: uses the push format defined in the v1 Pub/Sub API.
        :param pulumi.Input['SubscriptionPushConfigNoWrapperArgs'] no_wrapper: When set, the payload to the push endpoint is not wrapped.Sets the
               `data` field as the HTTP body for delivery.
               Structure is documented below.
        :param pulumi.Input['SubscriptionPushConfigOidcTokenArgs'] oidc_token: If specified, Pub/Sub will generate and attach an OIDC JWT token as
               an Authorization header in the HTTP request for every pushed message.
               Structure is documented below.
        """
        pulumi.set(__self__, "push_endpoint", push_endpoint)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if no_wrapper is not None:
            pulumi.set(__self__, "no_wrapper", no_wrapper)
        if oidc_token is not None:
            pulumi.set(__self__, "oidc_token", oidc_token)

    @property
    @pulumi.getter(name="pushEndpoint")
    def push_endpoint(self) -> pulumi.Input[builtins.str]:
        """
        A URL locating the endpoint to which messages should be pushed.
        For example, a Webhook endpoint might use
        "https://example.com/push".
        """
        return pulumi.get(self, "push_endpoint")

    @push_endpoint.setter
    def push_endpoint(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "push_endpoint", value)

    @property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        Endpoint configuration attributes.
        Every endpoint has a set of API supported attributes that can
        be used to control different aspects of the message delivery.
        The currently supported attribute is x-goog-version, which you
        can use to change the format of the pushed message. This
        attribute indicates the version of the data expected by
        the endpoint. This controls the shape of the pushed message
        (i.e., its fields and metadata). The endpoint version is
        based on the version of the Pub/Sub API.
        If not present during the subscriptions.create call,
        it will default to the version of the API used to make
        such call. If not present during a subscriptions.modifyPushConfig
        call, its value will not be changed. subscriptions.get
        calls will always return a valid version, even if the
        subscription was created without this attribute.
        The possible values for this attribute are:
        - v1beta1: uses the push format defined in the v1beta1 Pub/Sub API.
        - v1 or v1beta2: uses the push format defined in the v1 Pub/Sub API.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "attributes", value)

    @property
    @pulumi.getter(name="noWrapper")
    def no_wrapper(self) -> Optional[pulumi.Input['SubscriptionPushConfigNoWrapperArgs']]:
        """
        When set, the payload to the push endpoint is not wrapped.Sets the
        `data` field as the HTTP body for delivery.
        Structure is documented below.
        """
        return pulumi.get(self, "no_wrapper")

    @no_wrapper.setter
    def no_wrapper(self, value: Optional[pulumi.Input['SubscriptionPushConfigNoWrapperArgs']]):
        pulumi.set(self, "no_wrapper", value)

    @property
    @pulumi.getter(name="oidcToken")
    def oidc_token(self) -> Optional[pulumi.Input['SubscriptionPushConfigOidcTokenArgs']]:
        """
        If specified, Pub/Sub will generate and attach an OIDC JWT token as
        an Authorization header in the HTTP request for every pushed message.
        Structure is documented below.
        """
        return pulumi.get(self, "oidc_token")

    @oidc_token.setter
    def oidc_token(self, value: Optional[pulumi.Input['SubscriptionPushConfigOidcTokenArgs']]):
        pulumi.set(self, "oidc_token", value)


if not MYPY:
    class SubscriptionPushConfigNoWrapperArgsDict(TypedDict):
        write_metadata: pulumi.Input[builtins.bool]
        """
        When true, writes the Pub/Sub message metadata to
        `x-goog-pubsub-<KEY>:<VAL>` headers of the HTTP request. Writes the
        Pub/Sub message attributes to `<KEY>:<VAL>` headers of the HTTP request.
        """
elif False:
    SubscriptionPushConfigNoWrapperArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionPushConfigNoWrapperArgs:
    def __init__(__self__, *,
                 write_metadata: pulumi.Input[builtins.bool]):
        """
        :param pulumi.Input[builtins.bool] write_metadata: When true, writes the Pub/Sub message metadata to
               `x-goog-pubsub-<KEY>:<VAL>` headers of the HTTP request. Writes the
               Pub/Sub message attributes to `<KEY>:<VAL>` headers of the HTTP request.
        """
        pulumi.set(__self__, "write_metadata", write_metadata)

    @property
    @pulumi.getter(name="writeMetadata")
    def write_metadata(self) -> pulumi.Input[builtins.bool]:
        """
        When true, writes the Pub/Sub message metadata to
        `x-goog-pubsub-<KEY>:<VAL>` headers of the HTTP request. Writes the
        Pub/Sub message attributes to `<KEY>:<VAL>` headers of the HTTP request.
        """
        return pulumi.get(self, "write_metadata")

    @write_metadata.setter
    def write_metadata(self, value: pulumi.Input[builtins.bool]):
        pulumi.set(self, "write_metadata", value)


if not MYPY:
    class SubscriptionPushConfigOidcTokenArgsDict(TypedDict):
        service_account_email: pulumi.Input[builtins.str]
        """
        Service account email to be used for generating the OIDC token.
        The caller (for subscriptions.create, subscriptions.patch, and
        subscriptions.modifyPushConfig RPCs) must have the
        iam.serviceAccounts.actAs permission for the service account.
        """
        audience: NotRequired[pulumi.Input[builtins.str]]
        """
        Audience to be used when generating OIDC token. The audience claim
        identifies the recipients that the JWT is intended for. The audience
        value is a single case-sensitive string. Having multiple values (array)
        for the audience field is not supported. More info about the OIDC JWT
        token audience here: https://tools.ietf.org/html/rfc7519#section-4.1.3
        Note: if not specified, the Push endpoint URL will be used.
        """
elif False:
    SubscriptionPushConfigOidcTokenArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionPushConfigOidcTokenArgs:
    def __init__(__self__, *,
                 service_account_email: pulumi.Input[builtins.str],
                 audience: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] service_account_email: Service account email to be used for generating the OIDC token.
               The caller (for subscriptions.create, subscriptions.patch, and
               subscriptions.modifyPushConfig RPCs) must have the
               iam.serviceAccounts.actAs permission for the service account.
        :param pulumi.Input[builtins.str] audience: Audience to be used when generating OIDC token. The audience claim
               identifies the recipients that the JWT is intended for. The audience
               value is a single case-sensitive string. Having multiple values (array)
               for the audience field is not supported. More info about the OIDC JWT
               token audience here: https://tools.ietf.org/html/rfc7519#section-4.1.3
               Note: if not specified, the Push endpoint URL will be used.
        """
        pulumi.set(__self__, "service_account_email", service_account_email)
        if audience is not None:
            pulumi.set(__self__, "audience", audience)

    @property
    @pulumi.getter(name="serviceAccountEmail")
    def service_account_email(self) -> pulumi.Input[builtins.str]:
        """
        Service account email to be used for generating the OIDC token.
        The caller (for subscriptions.create, subscriptions.patch, and
        subscriptions.modifyPushConfig RPCs) must have the
        iam.serviceAccounts.actAs permission for the service account.
        """
        return pulumi.get(self, "service_account_email")

    @service_account_email.setter
    def service_account_email(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service_account_email", value)

    @property
    @pulumi.getter
    def audience(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Audience to be used when generating OIDC token. The audience claim
        identifies the recipients that the JWT is intended for. The audience
        value is a single case-sensitive string. Having multiple values (array)
        for the audience field is not supported. More info about the OIDC JWT
        token audience here: https://tools.ietf.org/html/rfc7519#section-4.1.3
        Note: if not specified, the Push endpoint URL will be used.
        """
        return pulumi.get(self, "audience")

    @audience.setter
    def audience(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "audience", value)


if not MYPY:
    class SubscriptionRetryPolicyArgsDict(TypedDict):
        maximum_backoff: NotRequired[pulumi.Input[builtins.str]]
        """
        The maximum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 600 seconds.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        minimum_backoff: NotRequired[pulumi.Input[builtins.str]]
        """
        The minimum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 10 seconds.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
elif False:
    SubscriptionRetryPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubscriptionRetryPolicyArgs:
    def __init__(__self__, *,
                 maximum_backoff: Optional[pulumi.Input[builtins.str]] = None,
                 minimum_backoff: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] maximum_backoff: The maximum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 600 seconds.
               A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        :param pulumi.Input[builtins.str] minimum_backoff: The minimum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 10 seconds.
               A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        if maximum_backoff is not None:
            pulumi.set(__self__, "maximum_backoff", maximum_backoff)
        if minimum_backoff is not None:
            pulumi.set(__self__, "minimum_backoff", minimum_backoff)

    @property
    @pulumi.getter(name="maximumBackoff")
    def maximum_backoff(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The maximum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 600 seconds.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        return pulumi.get(self, "maximum_backoff")

    @maximum_backoff.setter
    def maximum_backoff(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "maximum_backoff", value)

    @property
    @pulumi.getter(name="minimumBackoff")
    def minimum_backoff(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The minimum delay between consecutive deliveries of a given message. Value should be between 0 and 600 seconds. Defaults to 10 seconds.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        return pulumi.get(self, "minimum_backoff")

    @minimum_backoff.setter
    def minimum_backoff(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "minimum_backoff", value)


if not MYPY:
    class TopicIAMBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    TopicIAMBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicIAMBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class TopicIAMMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    TopicIAMMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicIAMMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class TopicIngestionDataSourceSettingsArgsDict(TypedDict):
        aws_kinesis: NotRequired[pulumi.Input['TopicIngestionDataSourceSettingsAwsKinesisArgsDict']]
        """
        Settings for ingestion from Amazon Kinesis Data Streams.
        Structure is documented below.
        """
        aws_msk: NotRequired[pulumi.Input['TopicIngestionDataSourceSettingsAwsMskArgsDict']]
        """
        Settings for ingestion from Amazon Managed Streaming for Apache Kafka.
        Structure is documented below.
        """
        azure_event_hubs: NotRequired[pulumi.Input['TopicIngestionDataSourceSettingsAzureEventHubsArgsDict']]
        """
        Settings for ingestion from Azure Event Hubs.
        Structure is documented below.
        """
        cloud_storage: NotRequired[pulumi.Input['TopicIngestionDataSourceSettingsCloudStorageArgsDict']]
        """
        Settings for ingestion from Cloud Storage.
        Structure is documented below.
        """
        confluent_cloud: NotRequired[pulumi.Input['TopicIngestionDataSourceSettingsConfluentCloudArgsDict']]
        """
        Settings for ingestion from Confluent Cloud.
        Structure is documented below.
        """
        platform_logs_settings: NotRequired[pulumi.Input['TopicIngestionDataSourceSettingsPlatformLogsSettingsArgsDict']]
        """
        Settings for Platform Logs regarding ingestion to Pub/Sub. If unset,
        no Platform Logs will be generated.'
        Structure is documented below.
        """
elif False:
    TopicIngestionDataSourceSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicIngestionDataSourceSettingsArgs:
    def __init__(__self__, *,
                 aws_kinesis: Optional[pulumi.Input['TopicIngestionDataSourceSettingsAwsKinesisArgs']] = None,
                 aws_msk: Optional[pulumi.Input['TopicIngestionDataSourceSettingsAwsMskArgs']] = None,
                 azure_event_hubs: Optional[pulumi.Input['TopicIngestionDataSourceSettingsAzureEventHubsArgs']] = None,
                 cloud_storage: Optional[pulumi.Input['TopicIngestionDataSourceSettingsCloudStorageArgs']] = None,
                 confluent_cloud: Optional[pulumi.Input['TopicIngestionDataSourceSettingsConfluentCloudArgs']] = None,
                 platform_logs_settings: Optional[pulumi.Input['TopicIngestionDataSourceSettingsPlatformLogsSettingsArgs']] = None):
        """
        :param pulumi.Input['TopicIngestionDataSourceSettingsAwsKinesisArgs'] aws_kinesis: Settings for ingestion from Amazon Kinesis Data Streams.
               Structure is documented below.
        :param pulumi.Input['TopicIngestionDataSourceSettingsAwsMskArgs'] aws_msk: Settings for ingestion from Amazon Managed Streaming for Apache Kafka.
               Structure is documented below.
        :param pulumi.Input['TopicIngestionDataSourceSettingsAzureEventHubsArgs'] azure_event_hubs: Settings for ingestion from Azure Event Hubs.
               Structure is documented below.
        :param pulumi.Input['TopicIngestionDataSourceSettingsCloudStorageArgs'] cloud_storage: Settings for ingestion from Cloud Storage.
               Structure is documented below.
        :param pulumi.Input['TopicIngestionDataSourceSettingsConfluentCloudArgs'] confluent_cloud: Settings for ingestion from Confluent Cloud.
               Structure is documented below.
        :param pulumi.Input['TopicIngestionDataSourceSettingsPlatformLogsSettingsArgs'] platform_logs_settings: Settings for Platform Logs regarding ingestion to Pub/Sub. If unset,
               no Platform Logs will be generated.'
               Structure is documented below.
        """
        if aws_kinesis is not None:
            pulumi.set(__self__, "aws_kinesis", aws_kinesis)
        if aws_msk is not None:
            pulumi.set(__self__, "aws_msk", aws_msk)
        if azure_event_hubs is not None:
            pulumi.set(__self__, "azure_event_hubs", azure_event_hubs)
        if cloud_storage is not None:
            pulumi.set(__self__, "cloud_storage", cloud_storage)
        if confluent_cloud is not None:
            pulumi.set(__self__, "confluent_cloud", confluent_cloud)
        if platform_logs_settings is not None:
            pulumi.set(__self__, "platform_logs_settings", platform_logs_settings)

    @property
    @pulumi.getter(name="awsKinesis")
    def aws_kinesis(self) -> Optional[pulumi.Input['TopicIngestionDataSourceSettingsAwsKinesisArgs']]:
        """
        Settings for ingestion from Amazon Kinesis Data Streams.
        Structure is documented below.
        """
        return pulumi.get(self, "aws_kinesis")

    @aws_kinesis.setter
    def aws_kinesis(self, value: Optional[pulumi.Input['TopicIngestionDataSourceSettingsAwsKinesisArgs']]):
        pulumi.set(self, "aws_kinesis", value)

    @property
    @pulumi.getter(name="awsMsk")
    def aws_msk(self) -> Optional[pulumi.Input['TopicIngestionDataSourceSettingsAwsMskArgs']]:
        """
        Settings for ingestion from Amazon Managed Streaming for Apache Kafka.
        Structure is documented below.
        """
        return pulumi.get(self, "aws_msk")

    @aws_msk.setter
    def aws_msk(self, value: Optional[pulumi.Input['TopicIngestionDataSourceSettingsAwsMskArgs']]):
        pulumi.set(self, "aws_msk", value)

    @property
    @pulumi.getter(name="azureEventHubs")
    def azure_event_hubs(self) -> Optional[pulumi.Input['TopicIngestionDataSourceSettingsAzureEventHubsArgs']]:
        """
        Settings for ingestion from Azure Event Hubs.
        Structure is documented below.
        """
        return pulumi.get(self, "azure_event_hubs")

    @azure_event_hubs.setter
    def azure_event_hubs(self, value: Optional[pulumi.Input['TopicIngestionDataSourceSettingsAzureEventHubsArgs']]):
        pulumi.set(self, "azure_event_hubs", value)

    @property
    @pulumi.getter(name="cloudStorage")
    def cloud_storage(self) -> Optional[pulumi.Input['TopicIngestionDataSourceSettingsCloudStorageArgs']]:
        """
        Settings for ingestion from Cloud Storage.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_storage")

    @cloud_storage.setter
    def cloud_storage(self, value: Optional[pulumi.Input['TopicIngestionDataSourceSettingsCloudStorageArgs']]):
        pulumi.set(self, "cloud_storage", value)

    @property
    @pulumi.getter(name="confluentCloud")
    def confluent_cloud(self) -> Optional[pulumi.Input['TopicIngestionDataSourceSettingsConfluentCloudArgs']]:
        """
        Settings for ingestion from Confluent Cloud.
        Structure is documented below.
        """
        return pulumi.get(self, "confluent_cloud")

    @confluent_cloud.setter
    def confluent_cloud(self, value: Optional[pulumi.Input['TopicIngestionDataSourceSettingsConfluentCloudArgs']]):
        pulumi.set(self, "confluent_cloud", value)

    @property
    @pulumi.getter(name="platformLogsSettings")
    def platform_logs_settings(self) -> Optional[pulumi.Input['TopicIngestionDataSourceSettingsPlatformLogsSettingsArgs']]:
        """
        Settings for Platform Logs regarding ingestion to Pub/Sub. If unset,
        no Platform Logs will be generated.'
        Structure is documented below.
        """
        return pulumi.get(self, "platform_logs_settings")

    @platform_logs_settings.setter
    def platform_logs_settings(self, value: Optional[pulumi.Input['TopicIngestionDataSourceSettingsPlatformLogsSettingsArgs']]):
        pulumi.set(self, "platform_logs_settings", value)


if not MYPY:
    class TopicIngestionDataSourceSettingsAwsKinesisArgsDict(TypedDict):
        aws_role_arn: pulumi.Input[builtins.str]
        """
        AWS role ARN to be used for Federated Identity authentication with
        Kinesis. Check the Pub/Sub docs for how to set up this role and the
        required permissions that need to be attached to it.
        """
        consumer_arn: pulumi.Input[builtins.str]
        """
        The Kinesis consumer ARN to used for ingestion in
        Enhanced Fan-Out mode. The consumer must be already
        created and ready to be used.
        """
        gcp_service_account: pulumi.Input[builtins.str]
        """
        The GCP service account to be used for Federated Identity authentication
        with Kinesis (via a `AssumeRoleWithWebIdentity` call for the provided
        role). The `awsRoleArn` must be set up with `accounts.google.com:sub`
        equals to this service account number.
        """
        stream_arn: pulumi.Input[builtins.str]
        """
        The Kinesis stream ARN to ingest data from.
        """
elif False:
    TopicIngestionDataSourceSettingsAwsKinesisArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicIngestionDataSourceSettingsAwsKinesisArgs:
    def __init__(__self__, *,
                 aws_role_arn: pulumi.Input[builtins.str],
                 consumer_arn: pulumi.Input[builtins.str],
                 gcp_service_account: pulumi.Input[builtins.str],
                 stream_arn: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] aws_role_arn: AWS role ARN to be used for Federated Identity authentication with
               Kinesis. Check the Pub/Sub docs for how to set up this role and the
               required permissions that need to be attached to it.
        :param pulumi.Input[builtins.str] consumer_arn: The Kinesis consumer ARN to used for ingestion in
               Enhanced Fan-Out mode. The consumer must be already
               created and ready to be used.
        :param pulumi.Input[builtins.str] gcp_service_account: The GCP service account to be used for Federated Identity authentication
               with Kinesis (via a `AssumeRoleWithWebIdentity` call for the provided
               role). The `awsRoleArn` must be set up with `accounts.google.com:sub`
               equals to this service account number.
        :param pulumi.Input[builtins.str] stream_arn: The Kinesis stream ARN to ingest data from.
        """
        pulumi.set(__self__, "aws_role_arn", aws_role_arn)
        pulumi.set(__self__, "consumer_arn", consumer_arn)
        pulumi.set(__self__, "gcp_service_account", gcp_service_account)
        pulumi.set(__self__, "stream_arn", stream_arn)

    @property
    @pulumi.getter(name="awsRoleArn")
    def aws_role_arn(self) -> pulumi.Input[builtins.str]:
        """
        AWS role ARN to be used for Federated Identity authentication with
        Kinesis. Check the Pub/Sub docs for how to set up this role and the
        required permissions that need to be attached to it.
        """
        return pulumi.get(self, "aws_role_arn")

    @aws_role_arn.setter
    def aws_role_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "aws_role_arn", value)

    @property
    @pulumi.getter(name="consumerArn")
    def consumer_arn(self) -> pulumi.Input[builtins.str]:
        """
        The Kinesis consumer ARN to used for ingestion in
        Enhanced Fan-Out mode. The consumer must be already
        created and ready to be used.
        """
        return pulumi.get(self, "consumer_arn")

    @consumer_arn.setter
    def consumer_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "consumer_arn", value)

    @property
    @pulumi.getter(name="gcpServiceAccount")
    def gcp_service_account(self) -> pulumi.Input[builtins.str]:
        """
        The GCP service account to be used for Federated Identity authentication
        with Kinesis (via a `AssumeRoleWithWebIdentity` call for the provided
        role). The `awsRoleArn` must be set up with `accounts.google.com:sub`
        equals to this service account number.
        """
        return pulumi.get(self, "gcp_service_account")

    @gcp_service_account.setter
    def gcp_service_account(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "gcp_service_account", value)

    @property
    @pulumi.getter(name="streamArn")
    def stream_arn(self) -> pulumi.Input[builtins.str]:
        """
        The Kinesis stream ARN to ingest data from.
        """
        return pulumi.get(self, "stream_arn")

    @stream_arn.setter
    def stream_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "stream_arn", value)


if not MYPY:
    class TopicIngestionDataSourceSettingsAwsMskArgsDict(TypedDict):
        aws_role_arn: pulumi.Input[builtins.str]
        """
        AWS role ARN to be used for Federated Identity authentication with
        MSK. Check the Pub/Sub docs for how to set up this role and the
        required permissions that need to be attached to it.
        """
        cluster_arn: pulumi.Input[builtins.str]
        """
        ARN that uniquely identifies the MSK cluster.
        """
        gcp_service_account: pulumi.Input[builtins.str]
        """
        The GCP service account to be used for Federated Identity authentication
        with MSK (via a `AssumeRoleWithWebIdentity` call for the provided
        role). The `awsRoleArn` must be set up with `accounts.google.com:sub`
        equals to this service account number.
        """
        topic: pulumi.Input[builtins.str]
        """
        The name of the MSK topic that Pub/Sub will import from.
        """
elif False:
    TopicIngestionDataSourceSettingsAwsMskArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicIngestionDataSourceSettingsAwsMskArgs:
    def __init__(__self__, *,
                 aws_role_arn: pulumi.Input[builtins.str],
                 cluster_arn: pulumi.Input[builtins.str],
                 gcp_service_account: pulumi.Input[builtins.str],
                 topic: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] aws_role_arn: AWS role ARN to be used for Federated Identity authentication with
               MSK. Check the Pub/Sub docs for how to set up this role and the
               required permissions that need to be attached to it.
        :param pulumi.Input[builtins.str] cluster_arn: ARN that uniquely identifies the MSK cluster.
        :param pulumi.Input[builtins.str] gcp_service_account: The GCP service account to be used for Federated Identity authentication
               with MSK (via a `AssumeRoleWithWebIdentity` call for the provided
               role). The `awsRoleArn` must be set up with `accounts.google.com:sub`
               equals to this service account number.
        :param pulumi.Input[builtins.str] topic: The name of the MSK topic that Pub/Sub will import from.
        """
        pulumi.set(__self__, "aws_role_arn", aws_role_arn)
        pulumi.set(__self__, "cluster_arn", cluster_arn)
        pulumi.set(__self__, "gcp_service_account", gcp_service_account)
        pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter(name="awsRoleArn")
    def aws_role_arn(self) -> pulumi.Input[builtins.str]:
        """
        AWS role ARN to be used for Federated Identity authentication with
        MSK. Check the Pub/Sub docs for how to set up this role and the
        required permissions that need to be attached to it.
        """
        return pulumi.get(self, "aws_role_arn")

    @aws_role_arn.setter
    def aws_role_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "aws_role_arn", value)

    @property
    @pulumi.getter(name="clusterArn")
    def cluster_arn(self) -> pulumi.Input[builtins.str]:
        """
        ARN that uniquely identifies the MSK cluster.
        """
        return pulumi.get(self, "cluster_arn")

    @cluster_arn.setter
    def cluster_arn(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cluster_arn", value)

    @property
    @pulumi.getter(name="gcpServiceAccount")
    def gcp_service_account(self) -> pulumi.Input[builtins.str]:
        """
        The GCP service account to be used for Federated Identity authentication
        with MSK (via a `AssumeRoleWithWebIdentity` call for the provided
        role). The `awsRoleArn` must be set up with `accounts.google.com:sub`
        equals to this service account number.
        """
        return pulumi.get(self, "gcp_service_account")

    @gcp_service_account.setter
    def gcp_service_account(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "gcp_service_account", value)

    @property
    @pulumi.getter
    def topic(self) -> pulumi.Input[builtins.str]:
        """
        The name of the MSK topic that Pub/Sub will import from.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "topic", value)


if not MYPY:
    class TopicIngestionDataSourceSettingsAzureEventHubsArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The Azure event hub client ID to use for ingestion.
        """
        event_hub: NotRequired[pulumi.Input[builtins.str]]
        """
        The Azure event hub to ingest data from.
        """
        gcp_service_account: NotRequired[pulumi.Input[builtins.str]]
        """
        The GCP service account to be used for Federated Identity authentication
        with Azure (via a `AssumeRoleWithWebIdentity` call for the provided
        role).
        """
        namespace: NotRequired[pulumi.Input[builtins.str]]
        """
        The Azure event hub namespace to ingest data from.
        """
        resource_group: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the resource group within an Azure subscription.
        """
        subscription_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The Azure event hub subscription ID to use for ingestion.
        """
        tenant_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The Azure event hub tenant ID to use for ingestion.
        """
elif False:
    TopicIngestionDataSourceSettingsAzureEventHubsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicIngestionDataSourceSettingsAzureEventHubsArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[builtins.str]] = None,
                 event_hub: Optional[pulumi.Input[builtins.str]] = None,
                 gcp_service_account: Optional[pulumi.Input[builtins.str]] = None,
                 namespace: Optional[pulumi.Input[builtins.str]] = None,
                 resource_group: Optional[pulumi.Input[builtins.str]] = None,
                 subscription_id: Optional[pulumi.Input[builtins.str]] = None,
                 tenant_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] client_id: The Azure event hub client ID to use for ingestion.
        :param pulumi.Input[builtins.str] event_hub: The Azure event hub to ingest data from.
        :param pulumi.Input[builtins.str] gcp_service_account: The GCP service account to be used for Federated Identity authentication
               with Azure (via a `AssumeRoleWithWebIdentity` call for the provided
               role).
        :param pulumi.Input[builtins.str] namespace: The Azure event hub namespace to ingest data from.
        :param pulumi.Input[builtins.str] resource_group: The name of the resource group within an Azure subscription.
        :param pulumi.Input[builtins.str] subscription_id: The Azure event hub subscription ID to use for ingestion.
        :param pulumi.Input[builtins.str] tenant_id: The Azure event hub tenant ID to use for ingestion.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if event_hub is not None:
            pulumi.set(__self__, "event_hub", event_hub)
        if gcp_service_account is not None:
            pulumi.set(__self__, "gcp_service_account", gcp_service_account)
        if namespace is not None:
            pulumi.set(__self__, "namespace", namespace)
        if resource_group is not None:
            pulumi.set(__self__, "resource_group", resource_group)
        if subscription_id is not None:
            pulumi.set(__self__, "subscription_id", subscription_id)
        if tenant_id is not None:
            pulumi.set(__self__, "tenant_id", tenant_id)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Azure event hub client ID to use for ingestion.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="eventHub")
    def event_hub(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Azure event hub to ingest data from.
        """
        return pulumi.get(self, "event_hub")

    @event_hub.setter
    def event_hub(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "event_hub", value)

    @property
    @pulumi.getter(name="gcpServiceAccount")
    def gcp_service_account(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The GCP service account to be used for Federated Identity authentication
        with Azure (via a `AssumeRoleWithWebIdentity` call for the provided
        role).
        """
        return pulumi.get(self, "gcp_service_account")

    @gcp_service_account.setter
    def gcp_service_account(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "gcp_service_account", value)

    @property
    @pulumi.getter
    def namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Azure event hub namespace to ingest data from.
        """
        return pulumi.get(self, "namespace")

    @namespace.setter
    def namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "namespace", value)

    @property
    @pulumi.getter(name="resourceGroup")
    def resource_group(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the resource group within an Azure subscription.
        """
        return pulumi.get(self, "resource_group")

    @resource_group.setter
    def resource_group(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "resource_group", value)

    @property
    @pulumi.getter(name="subscriptionId")
    def subscription_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Azure event hub subscription ID to use for ingestion.
        """
        return pulumi.get(self, "subscription_id")

    @subscription_id.setter
    def subscription_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "subscription_id", value)

    @property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Azure event hub tenant ID to use for ingestion.
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class TopicIngestionDataSourceSettingsCloudStorageArgsDict(TypedDict):
        bucket: pulumi.Input[builtins.str]
        """
        Cloud Storage bucket. The bucket name must be without any
        prefix like "gs://". See the bucket naming requirements:
        https://cloud.google.com/storage/docs/buckets#naming.
        """
        avro_format: NotRequired[pulumi.Input['TopicIngestionDataSourceSettingsCloudStorageAvroFormatArgsDict']]
        """
        Configuration for reading Cloud Storage data in Avro binary format. The
        bytes of each object will be set to the `data` field of a Pub/Sub message.
        """
        match_glob: NotRequired[pulumi.Input[builtins.str]]
        """
        Glob pattern used to match objects that will be ingested. If unset, all
        objects will be ingested. See the supported patterns:
        https://cloud.google.com/storage/docs/json_api/v1/objects/list#list-objects-and-prefixes-using-glob
        """
        minimum_object_create_time: NotRequired[pulumi.Input[builtins.str]]
        """
        The timestamp set in RFC3339 text format. If set, only objects with a
        larger or equal timestamp will be ingested. Unset by default, meaning
        all objects will be ingested.
        """
        pubsub_avro_format: NotRequired[pulumi.Input['TopicIngestionDataSourceSettingsCloudStoragePubsubAvroFormatArgsDict']]
        """
        Configuration for reading Cloud Storage data written via Cloud Storage
        subscriptions(See https://cloud.google.com/pubsub/docs/cloudstorage). The
        data and attributes fields of the originally exported Pub/Sub message
        will be restored when publishing.
        """
        text_format: NotRequired[pulumi.Input['TopicIngestionDataSourceSettingsCloudStorageTextFormatArgsDict']]
        """
        Configuration for reading Cloud Storage data in text format. Each line of
        text as specified by the delimiter will be set to the `data` field of a
        Pub/Sub message.
        Structure is documented below.
        """
elif False:
    TopicIngestionDataSourceSettingsCloudStorageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicIngestionDataSourceSettingsCloudStorageArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[builtins.str],
                 avro_format: Optional[pulumi.Input['TopicIngestionDataSourceSettingsCloudStorageAvroFormatArgs']] = None,
                 match_glob: Optional[pulumi.Input[builtins.str]] = None,
                 minimum_object_create_time: Optional[pulumi.Input[builtins.str]] = None,
                 pubsub_avro_format: Optional[pulumi.Input['TopicIngestionDataSourceSettingsCloudStoragePubsubAvroFormatArgs']] = None,
                 text_format: Optional[pulumi.Input['TopicIngestionDataSourceSettingsCloudStorageTextFormatArgs']] = None):
        """
        :param pulumi.Input[builtins.str] bucket: Cloud Storage bucket. The bucket name must be without any
               prefix like "gs://". See the bucket naming requirements:
               https://cloud.google.com/storage/docs/buckets#naming.
        :param pulumi.Input['TopicIngestionDataSourceSettingsCloudStorageAvroFormatArgs'] avro_format: Configuration for reading Cloud Storage data in Avro binary format. The
               bytes of each object will be set to the `data` field of a Pub/Sub message.
        :param pulumi.Input[builtins.str] match_glob: Glob pattern used to match objects that will be ingested. If unset, all
               objects will be ingested. See the supported patterns:
               https://cloud.google.com/storage/docs/json_api/v1/objects/list#list-objects-and-prefixes-using-glob
        :param pulumi.Input[builtins.str] minimum_object_create_time: The timestamp set in RFC3339 text format. If set, only objects with a
               larger or equal timestamp will be ingested. Unset by default, meaning
               all objects will be ingested.
        :param pulumi.Input['TopicIngestionDataSourceSettingsCloudStoragePubsubAvroFormatArgs'] pubsub_avro_format: Configuration for reading Cloud Storage data written via Cloud Storage
               subscriptions(See https://cloud.google.com/pubsub/docs/cloudstorage). The
               data and attributes fields of the originally exported Pub/Sub message
               will be restored when publishing.
        :param pulumi.Input['TopicIngestionDataSourceSettingsCloudStorageTextFormatArgs'] text_format: Configuration for reading Cloud Storage data in text format. Each line of
               text as specified by the delimiter will be set to the `data` field of a
               Pub/Sub message.
               Structure is documented below.
        """
        pulumi.set(__self__, "bucket", bucket)
        if avro_format is not None:
            pulumi.set(__self__, "avro_format", avro_format)
        if match_glob is not None:
            pulumi.set(__self__, "match_glob", match_glob)
        if minimum_object_create_time is not None:
            pulumi.set(__self__, "minimum_object_create_time", minimum_object_create_time)
        if pubsub_avro_format is not None:
            pulumi.set(__self__, "pubsub_avro_format", pubsub_avro_format)
        if text_format is not None:
            pulumi.set(__self__, "text_format", text_format)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[builtins.str]:
        """
        Cloud Storage bucket. The bucket name must be without any
        prefix like "gs://". See the bucket naming requirements:
        https://cloud.google.com/storage/docs/buckets#naming.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="avroFormat")
    def avro_format(self) -> Optional[pulumi.Input['TopicIngestionDataSourceSettingsCloudStorageAvroFormatArgs']]:
        """
        Configuration for reading Cloud Storage data in Avro binary format. The
        bytes of each object will be set to the `data` field of a Pub/Sub message.
        """
        return pulumi.get(self, "avro_format")

    @avro_format.setter
    def avro_format(self, value: Optional[pulumi.Input['TopicIngestionDataSourceSettingsCloudStorageAvroFormatArgs']]):
        pulumi.set(self, "avro_format", value)

    @property
    @pulumi.getter(name="matchGlob")
    def match_glob(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Glob pattern used to match objects that will be ingested. If unset, all
        objects will be ingested. See the supported patterns:
        https://cloud.google.com/storage/docs/json_api/v1/objects/list#list-objects-and-prefixes-using-glob
        """
        return pulumi.get(self, "match_glob")

    @match_glob.setter
    def match_glob(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "match_glob", value)

    @property
    @pulumi.getter(name="minimumObjectCreateTime")
    def minimum_object_create_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The timestamp set in RFC3339 text format. If set, only objects with a
        larger or equal timestamp will be ingested. Unset by default, meaning
        all objects will be ingested.
        """
        return pulumi.get(self, "minimum_object_create_time")

    @minimum_object_create_time.setter
    def minimum_object_create_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "minimum_object_create_time", value)

    @property
    @pulumi.getter(name="pubsubAvroFormat")
    def pubsub_avro_format(self) -> Optional[pulumi.Input['TopicIngestionDataSourceSettingsCloudStoragePubsubAvroFormatArgs']]:
        """
        Configuration for reading Cloud Storage data written via Cloud Storage
        subscriptions(See https://cloud.google.com/pubsub/docs/cloudstorage). The
        data and attributes fields of the originally exported Pub/Sub message
        will be restored when publishing.
        """
        return pulumi.get(self, "pubsub_avro_format")

    @pubsub_avro_format.setter
    def pubsub_avro_format(self, value: Optional[pulumi.Input['TopicIngestionDataSourceSettingsCloudStoragePubsubAvroFormatArgs']]):
        pulumi.set(self, "pubsub_avro_format", value)

    @property
    @pulumi.getter(name="textFormat")
    def text_format(self) -> Optional[pulumi.Input['TopicIngestionDataSourceSettingsCloudStorageTextFormatArgs']]:
        """
        Configuration for reading Cloud Storage data in text format. Each line of
        text as specified by the delimiter will be set to the `data` field of a
        Pub/Sub message.
        Structure is documented below.
        """
        return pulumi.get(self, "text_format")

    @text_format.setter
    def text_format(self, value: Optional[pulumi.Input['TopicIngestionDataSourceSettingsCloudStorageTextFormatArgs']]):
        pulumi.set(self, "text_format", value)


if not MYPY:
    class TopicIngestionDataSourceSettingsCloudStorageAvroFormatArgsDict(TypedDict):
        pass
elif False:
    TopicIngestionDataSourceSettingsCloudStorageAvroFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicIngestionDataSourceSettingsCloudStorageAvroFormatArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class TopicIngestionDataSourceSettingsCloudStoragePubsubAvroFormatArgsDict(TypedDict):
        pass
elif False:
    TopicIngestionDataSourceSettingsCloudStoragePubsubAvroFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicIngestionDataSourceSettingsCloudStoragePubsubAvroFormatArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class TopicIngestionDataSourceSettingsCloudStorageTextFormatArgsDict(TypedDict):
        delimiter: NotRequired[pulumi.Input[builtins.str]]
        """
        The delimiter to use when using the 'text' format. Each line of text as
        specified by the delimiter will be set to the 'data' field of a Pub/Sub
        message. When unset, '\\n' is used.
        """
elif False:
    TopicIngestionDataSourceSettingsCloudStorageTextFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicIngestionDataSourceSettingsCloudStorageTextFormatArgs:
    def __init__(__self__, *,
                 delimiter: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] delimiter: The delimiter to use when using the 'text' format. Each line of text as
               specified by the delimiter will be set to the 'data' field of a Pub/Sub
               message. When unset, '\\n' is used.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)

    @property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The delimiter to use when using the 'text' format. Each line of text as
        specified by the delimiter will be set to the 'data' field of a Pub/Sub
        message. When unset, '\\n' is used.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "delimiter", value)


if not MYPY:
    class TopicIngestionDataSourceSettingsConfluentCloudArgsDict(TypedDict):
        bootstrap_server: pulumi.Input[builtins.str]
        """
        The Confluent Cloud bootstrap server. The format is url:port.
        """
        gcp_service_account: pulumi.Input[builtins.str]
        """
        The GCP service account to be used for Federated Identity authentication
        with Confluent Cloud.
        """
        identity_pool_id: pulumi.Input[builtins.str]
        """
        Identity pool ID to be used for Federated Identity authentication with Confluent Cloud.
        """
        topic: pulumi.Input[builtins.str]
        """
        Name of the Confluent Cloud topic that Pub/Sub will import from.
        """
        cluster_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The Confluent Cloud cluster ID.
        """
elif False:
    TopicIngestionDataSourceSettingsConfluentCloudArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicIngestionDataSourceSettingsConfluentCloudArgs:
    def __init__(__self__, *,
                 bootstrap_server: pulumi.Input[builtins.str],
                 gcp_service_account: pulumi.Input[builtins.str],
                 identity_pool_id: pulumi.Input[builtins.str],
                 topic: pulumi.Input[builtins.str],
                 cluster_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] bootstrap_server: The Confluent Cloud bootstrap server. The format is url:port.
        :param pulumi.Input[builtins.str] gcp_service_account: The GCP service account to be used for Federated Identity authentication
               with Confluent Cloud.
        :param pulumi.Input[builtins.str] identity_pool_id: Identity pool ID to be used for Federated Identity authentication with Confluent Cloud.
        :param pulumi.Input[builtins.str] topic: Name of the Confluent Cloud topic that Pub/Sub will import from.
        :param pulumi.Input[builtins.str] cluster_id: The Confluent Cloud cluster ID.
        """
        pulumi.set(__self__, "bootstrap_server", bootstrap_server)
        pulumi.set(__self__, "gcp_service_account", gcp_service_account)
        pulumi.set(__self__, "identity_pool_id", identity_pool_id)
        pulumi.set(__self__, "topic", topic)
        if cluster_id is not None:
            pulumi.set(__self__, "cluster_id", cluster_id)

    @property
    @pulumi.getter(name="bootstrapServer")
    def bootstrap_server(self) -> pulumi.Input[builtins.str]:
        """
        The Confluent Cloud bootstrap server. The format is url:port.
        """
        return pulumi.get(self, "bootstrap_server")

    @bootstrap_server.setter
    def bootstrap_server(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "bootstrap_server", value)

    @property
    @pulumi.getter(name="gcpServiceAccount")
    def gcp_service_account(self) -> pulumi.Input[builtins.str]:
        """
        The GCP service account to be used for Federated Identity authentication
        with Confluent Cloud.
        """
        return pulumi.get(self, "gcp_service_account")

    @gcp_service_account.setter
    def gcp_service_account(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "gcp_service_account", value)

    @property
    @pulumi.getter(name="identityPoolId")
    def identity_pool_id(self) -> pulumi.Input[builtins.str]:
        """
        Identity pool ID to be used for Federated Identity authentication with Confluent Cloud.
        """
        return pulumi.get(self, "identity_pool_id")

    @identity_pool_id.setter
    def identity_pool_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "identity_pool_id", value)

    @property
    @pulumi.getter
    def topic(self) -> pulumi.Input[builtins.str]:
        """
        Name of the Confluent Cloud topic that Pub/Sub will import from.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "topic", value)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The Confluent Cloud cluster ID.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cluster_id", value)


if not MYPY:
    class TopicIngestionDataSourceSettingsPlatformLogsSettingsArgsDict(TypedDict):
        severity: NotRequired[pulumi.Input[builtins.str]]
        """
        The minimum severity level of Platform Logs that will be written. If unspecified,
        no Platform Logs will be written.
        Default value is `SEVERITY_UNSPECIFIED`.
        Possible values are: `SEVERITY_UNSPECIFIED`, `DISABLED`, `DEBUG`, `INFO`, `WARNING`, `ERROR`.
        """
elif False:
    TopicIngestionDataSourceSettingsPlatformLogsSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicIngestionDataSourceSettingsPlatformLogsSettingsArgs:
    def __init__(__self__, *,
                 severity: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] severity: The minimum severity level of Platform Logs that will be written. If unspecified,
               no Platform Logs will be written.
               Default value is `SEVERITY_UNSPECIFIED`.
               Possible values are: `SEVERITY_UNSPECIFIED`, `DISABLED`, `DEBUG`, `INFO`, `WARNING`, `ERROR`.
        """
        if severity is not None:
            pulumi.set(__self__, "severity", severity)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The minimum severity level of Platform Logs that will be written. If unspecified,
        no Platform Logs will be written.
        Default value is `SEVERITY_UNSPECIFIED`.
        Possible values are: `SEVERITY_UNSPECIFIED`, `DISABLED`, `DEBUG`, `INFO`, `WARNING`, `ERROR`.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class TopicMessageStoragePolicyArgsDict(TypedDict):
        allowed_persistence_regions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]
        """
        A list of IDs of GCP regions where messages that are published to
        the topic may be persisted in storage. Messages published by
        publishers running in non-allowed GCP regions (or running outside
        of GCP altogether) will be routed for storage in one of the
        allowed regions. An empty list means that no regions are allowed,
        and is not a valid configuration.
        """
        enforce_in_transit: NotRequired[pulumi.Input[builtins.bool]]
        """
        If true, `allowedPersistenceRegions` is also used to enforce in-transit
        guarantees for messages. That is, Pub/Sub will fail topics.publish
        operations on this topic and subscribe operations on any subscription
        attached to this topic in any region that is not in `allowedPersistenceRegions`.
        """
elif False:
    TopicMessageStoragePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicMessageStoragePolicyArgs:
    def __init__(__self__, *,
                 allowed_persistence_regions: pulumi.Input[Sequence[pulumi.Input[builtins.str]]],
                 enforce_in_transit: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] allowed_persistence_regions: A list of IDs of GCP regions where messages that are published to
               the topic may be persisted in storage. Messages published by
               publishers running in non-allowed GCP regions (or running outside
               of GCP altogether) will be routed for storage in one of the
               allowed regions. An empty list means that no regions are allowed,
               and is not a valid configuration.
        :param pulumi.Input[builtins.bool] enforce_in_transit: If true, `allowedPersistenceRegions` is also used to enforce in-transit
               guarantees for messages. That is, Pub/Sub will fail topics.publish
               operations on this topic and subscribe operations on any subscription
               attached to this topic in any region that is not in `allowedPersistenceRegions`.
        """
        pulumi.set(__self__, "allowed_persistence_regions", allowed_persistence_regions)
        if enforce_in_transit is not None:
            pulumi.set(__self__, "enforce_in_transit", enforce_in_transit)

    @property
    @pulumi.getter(name="allowedPersistenceRegions")
    def allowed_persistence_regions(self) -> pulumi.Input[Sequence[pulumi.Input[builtins.str]]]:
        """
        A list of IDs of GCP regions where messages that are published to
        the topic may be persisted in storage. Messages published by
        publishers running in non-allowed GCP regions (or running outside
        of GCP altogether) will be routed for storage in one of the
        allowed regions. An empty list means that no regions are allowed,
        and is not a valid configuration.
        """
        return pulumi.get(self, "allowed_persistence_regions")

    @allowed_persistence_regions.setter
    def allowed_persistence_regions(self, value: pulumi.Input[Sequence[pulumi.Input[builtins.str]]]):
        pulumi.set(self, "allowed_persistence_regions", value)

    @property
    @pulumi.getter(name="enforceInTransit")
    def enforce_in_transit(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        If true, `allowedPersistenceRegions` is also used to enforce in-transit
        guarantees for messages. That is, Pub/Sub will fail topics.publish
        operations on this topic and subscribe operations on any subscription
        attached to this topic in any region that is not in `allowedPersistenceRegions`.
        """
        return pulumi.get(self, "enforce_in_transit")

    @enforce_in_transit.setter
    def enforce_in_transit(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enforce_in_transit", value)


if not MYPY:
    class TopicSchemaSettingsArgsDict(TypedDict):
        schema: pulumi.Input[builtins.str]
        """
        The name of the schema that messages published should be
        validated against. Format is projects/{project}/schemas/{schema}.
        The value of this field will be _deleted-schema_
        if the schema has been deleted.
        """
        encoding: NotRequired[pulumi.Input[builtins.str]]
        """
        The encoding of messages validated against schema.
        Default value is `ENCODING_UNSPECIFIED`.
        Possible values are: `ENCODING_UNSPECIFIED`, `JSON`, `BINARY`.
        """
elif False:
    TopicSchemaSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TopicSchemaSettingsArgs:
    def __init__(__self__, *,
                 schema: pulumi.Input[builtins.str],
                 encoding: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] schema: The name of the schema that messages published should be
               validated against. Format is projects/{project}/schemas/{schema}.
               The value of this field will be _deleted-schema_
               if the schema has been deleted.
        :param pulumi.Input[builtins.str] encoding: The encoding of messages validated against schema.
               Default value is `ENCODING_UNSPECIFIED`.
               Possible values are: `ENCODING_UNSPECIFIED`, `JSON`, `BINARY`.
        """
        pulumi.set(__self__, "schema", schema)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)

    @property
    @pulumi.getter
    def schema(self) -> pulumi.Input[builtins.str]:
        """
        The name of the schema that messages published should be
        validated against. Format is projects/{project}/schemas/{schema}.
        The value of this field will be _deleted-schema_
        if the schema has been deleted.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The encoding of messages validated against schema.
        Default value is `ENCODING_UNSPECIFIED`.
        Possible values are: `ENCODING_UNSPECIFIED`, `JSON`, `BINARY`.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "encoding", value)


