# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'SettingsEmailNotificationSettings',
    'SettingsEmailNotificationSettingsCustomNotificationBehavior',
    'SettingsEmailNotificationSettingsCustomNotificationBehaviorAdminNotifications',
    'SettingsEmailNotificationSettingsCustomNotificationBehaviorApproverNotifications',
    'SettingsEmailNotificationSettingsCustomNotificationBehaviorRequesterNotifications',
    'SettingsEmailNotificationSettingsDisableAllNotifications',
    'SettingsServiceAccountApproverSettings',
    'EntitlementAdditionalNotificationTargets',
    'EntitlementApprovalWorkflow',
    'EntitlementApprovalWorkflowManualApprovals',
    'EntitlementApprovalWorkflowManualApprovalsStep',
    'EntitlementApprovalWorkflowManualApprovalsStepApprovers',
    'EntitlementEligibleUser',
    'EntitlementPrivilegedAccess',
    'EntitlementPrivilegedAccessGcpIamAccess',
    'EntitlementPrivilegedAccessGcpIamAccessRoleBinding',
    'EntitlementRequesterJustificationConfig',
    'EntitlementRequesterJustificationConfigNotMandatory',
    'EntitlementRequesterJustificationConfigUnstructured',
    'GetEntitlementAdditionalNotificationTargetResult',
    'GetEntitlementApprovalWorkflowResult',
    'GetEntitlementApprovalWorkflowManualApprovalResult',
    'GetEntitlementApprovalWorkflowManualApprovalStepResult',
    'GetEntitlementApprovalWorkflowManualApprovalStepApproverResult',
    'GetEntitlementEligibleUserResult',
    'GetEntitlementPrivilegedAccessResult',
    'GetEntitlementPrivilegedAccessGcpIamAccessResult',
    'GetEntitlementPrivilegedAccessGcpIamAccessRoleBindingResult',
    'GetEntitlementRequesterJustificationConfigResult',
    'GetEntitlementRequesterJustificationConfigNotMandatoryResult',
    'GetEntitlementRequesterJustificationConfigUnstructuredResult',
]

@pulumi.output_type
class SettingsEmailNotificationSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customNotificationBehavior":
            suggest = "custom_notification_behavior"
        elif key == "disableAllNotifications":
            suggest = "disable_all_notifications"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingsEmailNotificationSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingsEmailNotificationSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingsEmailNotificationSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_notification_behavior: Optional['outputs.SettingsEmailNotificationSettingsCustomNotificationBehavior'] = None,
                 disable_all_notifications: Optional['outputs.SettingsEmailNotificationSettingsDisableAllNotifications'] = None):
        """
        :param 'SettingsEmailNotificationSettingsCustomNotificationBehaviorArgs' custom_notification_behavior: CustomNotificationBehavior provides granular control over email notification delivery. Allows admins to selectively enable/disable notifications for specific events and specific personas.
               Structure is documented below.
        :param 'SettingsEmailNotificationSettingsDisableAllNotificationsArgs' disable_all_notifications: This option indicates that all email notifications are disabled.
        """
        if custom_notification_behavior is not None:
            pulumi.set(__self__, "custom_notification_behavior", custom_notification_behavior)
        if disable_all_notifications is not None:
            pulumi.set(__self__, "disable_all_notifications", disable_all_notifications)

    @_builtins.property
    @pulumi.getter(name="customNotificationBehavior")
    def custom_notification_behavior(self) -> Optional['outputs.SettingsEmailNotificationSettingsCustomNotificationBehavior']:
        """
        CustomNotificationBehavior provides granular control over email notification delivery. Allows admins to selectively enable/disable notifications for specific events and specific personas.
        Structure is documented below.
        """
        return pulumi.get(self, "custom_notification_behavior")

    @_builtins.property
    @pulumi.getter(name="disableAllNotifications")
    def disable_all_notifications(self) -> Optional['outputs.SettingsEmailNotificationSettingsDisableAllNotifications']:
        """
        This option indicates that all email notifications are disabled.
        """
        return pulumi.get(self, "disable_all_notifications")


@pulumi.output_type
class SettingsEmailNotificationSettingsCustomNotificationBehavior(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminNotifications":
            suggest = "admin_notifications"
        elif key == "approverNotifications":
            suggest = "approver_notifications"
        elif key == "requesterNotifications":
            suggest = "requester_notifications"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingsEmailNotificationSettingsCustomNotificationBehavior. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingsEmailNotificationSettingsCustomNotificationBehavior.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingsEmailNotificationSettingsCustomNotificationBehavior.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_notifications: Optional['outputs.SettingsEmailNotificationSettingsCustomNotificationBehaviorAdminNotifications'] = None,
                 approver_notifications: Optional['outputs.SettingsEmailNotificationSettingsCustomNotificationBehaviorApproverNotifications'] = None,
                 requester_notifications: Optional['outputs.SettingsEmailNotificationSettingsCustomNotificationBehaviorRequesterNotifications'] = None):
        """
        :param 'SettingsEmailNotificationSettingsCustomNotificationBehaviorAdminNotificationsArgs' admin_notifications: Email notifications specific to Requesters.
               Structure is documented below.
        :param 'SettingsEmailNotificationSettingsCustomNotificationBehaviorApproverNotificationsArgs' approver_notifications: Email notifications specific to Approvers.
               Structure is documented below.
        :param 'SettingsEmailNotificationSettingsCustomNotificationBehaviorRequesterNotificationsArgs' requester_notifications: Email notifications specific to Requesters.
               Structure is documented below.
        """
        if admin_notifications is not None:
            pulumi.set(__self__, "admin_notifications", admin_notifications)
        if approver_notifications is not None:
            pulumi.set(__self__, "approver_notifications", approver_notifications)
        if requester_notifications is not None:
            pulumi.set(__self__, "requester_notifications", requester_notifications)

    @_builtins.property
    @pulumi.getter(name="adminNotifications")
    def admin_notifications(self) -> Optional['outputs.SettingsEmailNotificationSettingsCustomNotificationBehaviorAdminNotifications']:
        """
        Email notifications specific to Requesters.
        Structure is documented below.
        """
        return pulumi.get(self, "admin_notifications")

    @_builtins.property
    @pulumi.getter(name="approverNotifications")
    def approver_notifications(self) -> Optional['outputs.SettingsEmailNotificationSettingsCustomNotificationBehaviorApproverNotifications']:
        """
        Email notifications specific to Approvers.
        Structure is documented below.
        """
        return pulumi.get(self, "approver_notifications")

    @_builtins.property
    @pulumi.getter(name="requesterNotifications")
    def requester_notifications(self) -> Optional['outputs.SettingsEmailNotificationSettingsCustomNotificationBehaviorRequesterNotifications']:
        """
        Email notifications specific to Requesters.
        Structure is documented below.
        """
        return pulumi.get(self, "requester_notifications")


@pulumi.output_type
class SettingsEmailNotificationSettingsCustomNotificationBehaviorAdminNotifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "grantActivated":
            suggest = "grant_activated"
        elif key == "grantActivationFailed":
            suggest = "grant_activation_failed"
        elif key == "grantEnded":
            suggest = "grant_ended"
        elif key == "grantExternallyModified":
            suggest = "grant_externally_modified"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingsEmailNotificationSettingsCustomNotificationBehaviorAdminNotifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingsEmailNotificationSettingsCustomNotificationBehaviorAdminNotifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingsEmailNotificationSettingsCustomNotificationBehaviorAdminNotifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grant_activated: Optional[_builtins.str] = None,
                 grant_activation_failed: Optional[_builtins.str] = None,
                 grant_ended: Optional[_builtins.str] = None,
                 grant_externally_modified: Optional[_builtins.str] = None):
        """
        :param _builtins.str grant_activated: Notification mode for grant activated.
               Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        :param _builtins.str grant_activation_failed: Notification mode for grant activation failed.
               Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        :param _builtins.str grant_ended: Notification mode for grant ended.
               Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        :param _builtins.str grant_externally_modified: Notification mode for grant externally modified.
               Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        """
        if grant_activated is not None:
            pulumi.set(__self__, "grant_activated", grant_activated)
        if grant_activation_failed is not None:
            pulumi.set(__self__, "grant_activation_failed", grant_activation_failed)
        if grant_ended is not None:
            pulumi.set(__self__, "grant_ended", grant_ended)
        if grant_externally_modified is not None:
            pulumi.set(__self__, "grant_externally_modified", grant_externally_modified)

    @_builtins.property
    @pulumi.getter(name="grantActivated")
    def grant_activated(self) -> Optional[_builtins.str]:
        """
        Notification mode for grant activated.
        Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "grant_activated")

    @_builtins.property
    @pulumi.getter(name="grantActivationFailed")
    def grant_activation_failed(self) -> Optional[_builtins.str]:
        """
        Notification mode for grant activation failed.
        Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "grant_activation_failed")

    @_builtins.property
    @pulumi.getter(name="grantEnded")
    def grant_ended(self) -> Optional[_builtins.str]:
        """
        Notification mode for grant ended.
        Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "grant_ended")

    @_builtins.property
    @pulumi.getter(name="grantExternallyModified")
    def grant_externally_modified(self) -> Optional[_builtins.str]:
        """
        Notification mode for grant externally modified.
        Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "grant_externally_modified")


@pulumi.output_type
class SettingsEmailNotificationSettingsCustomNotificationBehaviorApproverNotifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pendingApproval":
            suggest = "pending_approval"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingsEmailNotificationSettingsCustomNotificationBehaviorApproverNotifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingsEmailNotificationSettingsCustomNotificationBehaviorApproverNotifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingsEmailNotificationSettingsCustomNotificationBehaviorApproverNotifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pending_approval: Optional[_builtins.str] = None):
        """
        :param _builtins.str pending_approval: Notification mode for pending approval.
               Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        """
        if pending_approval is not None:
            pulumi.set(__self__, "pending_approval", pending_approval)

    @_builtins.property
    @pulumi.getter(name="pendingApproval")
    def pending_approval(self) -> Optional[_builtins.str]:
        """
        Notification mode for pending approval.
        Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "pending_approval")


@pulumi.output_type
class SettingsEmailNotificationSettingsCustomNotificationBehaviorRequesterNotifications(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "entitlementAssigned":
            suggest = "entitlement_assigned"
        elif key == "grantActivated":
            suggest = "grant_activated"
        elif key == "grantActivationFailed":
            suggest = "grant_activation_failed"
        elif key == "grantDenied":
            suggest = "grant_denied"
        elif key == "grantEnded":
            suggest = "grant_ended"
        elif key == "grantExpired":
            suggest = "grant_expired"
        elif key == "grantExternallyModified":
            suggest = "grant_externally_modified"
        elif key == "grantRevoked":
            suggest = "grant_revoked"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SettingsEmailNotificationSettingsCustomNotificationBehaviorRequesterNotifications. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SettingsEmailNotificationSettingsCustomNotificationBehaviorRequesterNotifications.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SettingsEmailNotificationSettingsCustomNotificationBehaviorRequesterNotifications.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 entitlement_assigned: Optional[_builtins.str] = None,
                 grant_activated: Optional[_builtins.str] = None,
                 grant_activation_failed: Optional[_builtins.str] = None,
                 grant_denied: Optional[_builtins.str] = None,
                 grant_ended: Optional[_builtins.str] = None,
                 grant_expired: Optional[_builtins.str] = None,
                 grant_externally_modified: Optional[_builtins.str] = None,
                 grant_revoked: Optional[_builtins.str] = None):
        """
        :param _builtins.str entitlement_assigned: Notification mode for entitlement assigned.
               Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        :param _builtins.str grant_activated: Notification mode for grant activated.
               Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        :param _builtins.str grant_activation_failed: Notification mode for grant activation failed.
               Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        :param _builtins.str grant_denied: Notification mode for grant denied.
               Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        :param _builtins.str grant_ended: Notification mode for grant ended.
               Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        :param _builtins.str grant_expired: Notification mode for grant expired.
               Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        :param _builtins.str grant_externally_modified: Notification mode for grant externally modified.
               Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        :param _builtins.str grant_revoked: Notification mode for grant revoked.
               Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        """
        if entitlement_assigned is not None:
            pulumi.set(__self__, "entitlement_assigned", entitlement_assigned)
        if grant_activated is not None:
            pulumi.set(__self__, "grant_activated", grant_activated)
        if grant_activation_failed is not None:
            pulumi.set(__self__, "grant_activation_failed", grant_activation_failed)
        if grant_denied is not None:
            pulumi.set(__self__, "grant_denied", grant_denied)
        if grant_ended is not None:
            pulumi.set(__self__, "grant_ended", grant_ended)
        if grant_expired is not None:
            pulumi.set(__self__, "grant_expired", grant_expired)
        if grant_externally_modified is not None:
            pulumi.set(__self__, "grant_externally_modified", grant_externally_modified)
        if grant_revoked is not None:
            pulumi.set(__self__, "grant_revoked", grant_revoked)

    @_builtins.property
    @pulumi.getter(name="entitlementAssigned")
    def entitlement_assigned(self) -> Optional[_builtins.str]:
        """
        Notification mode for entitlement assigned.
        Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "entitlement_assigned")

    @_builtins.property
    @pulumi.getter(name="grantActivated")
    def grant_activated(self) -> Optional[_builtins.str]:
        """
        Notification mode for grant activated.
        Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "grant_activated")

    @_builtins.property
    @pulumi.getter(name="grantActivationFailed")
    def grant_activation_failed(self) -> Optional[_builtins.str]:
        """
        Notification mode for grant activation failed.
        Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "grant_activation_failed")

    @_builtins.property
    @pulumi.getter(name="grantDenied")
    def grant_denied(self) -> Optional[_builtins.str]:
        """
        Notification mode for grant denied.
        Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "grant_denied")

    @_builtins.property
    @pulumi.getter(name="grantEnded")
    def grant_ended(self) -> Optional[_builtins.str]:
        """
        Notification mode for grant ended.
        Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "grant_ended")

    @_builtins.property
    @pulumi.getter(name="grantExpired")
    def grant_expired(self) -> Optional[_builtins.str]:
        """
        Notification mode for grant expired.
        Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "grant_expired")

    @_builtins.property
    @pulumi.getter(name="grantExternallyModified")
    def grant_externally_modified(self) -> Optional[_builtins.str]:
        """
        Notification mode for grant externally modified.
        Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "grant_externally_modified")

    @_builtins.property
    @pulumi.getter(name="grantRevoked")
    def grant_revoked(self) -> Optional[_builtins.str]:
        """
        Notification mode for grant revoked.
        Possible values are: `NOTIFICATION_MODE_UNSPECIFIED`, `ENABLED`, `DISABLED`.
        """
        return pulumi.get(self, "grant_revoked")


@pulumi.output_type
class SettingsEmailNotificationSettingsDisableAllNotifications(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class SettingsServiceAccountApproverSettings(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enabled: Indicates whether service account is allowed to grant approvals.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether service account is allowed to grant approvals.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class EntitlementAdditionalNotificationTargets(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminEmailRecipients":
            suggest = "admin_email_recipients"
        elif key == "requesterEmailRecipients":
            suggest = "requester_email_recipients"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EntitlementAdditionalNotificationTargets. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EntitlementAdditionalNotificationTargets.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EntitlementAdditionalNotificationTargets.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_email_recipients: Optional[Sequence[_builtins.str]] = None,
                 requester_email_recipients: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] admin_email_recipients: Optional. Additional email addresses to be notified when a principal(requester) is granted access.
        :param Sequence[_builtins.str] requester_email_recipients: Optional. Additional email address to be notified about an eligible entitlement.
        """
        if admin_email_recipients is not None:
            pulumi.set(__self__, "admin_email_recipients", admin_email_recipients)
        if requester_email_recipients is not None:
            pulumi.set(__self__, "requester_email_recipients", requester_email_recipients)

    @_builtins.property
    @pulumi.getter(name="adminEmailRecipients")
    def admin_email_recipients(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional. Additional email addresses to be notified when a principal(requester) is granted access.
        """
        return pulumi.get(self, "admin_email_recipients")

    @_builtins.property
    @pulumi.getter(name="requesterEmailRecipients")
    def requester_email_recipients(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional. Additional email address to be notified about an eligible entitlement.
        """
        return pulumi.get(self, "requester_email_recipients")


@pulumi.output_type
class EntitlementApprovalWorkflow(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "manualApprovals":
            suggest = "manual_approvals"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EntitlementApprovalWorkflow. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EntitlementApprovalWorkflow.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EntitlementApprovalWorkflow.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 manual_approvals: 'outputs.EntitlementApprovalWorkflowManualApprovals'):
        """
        :param 'EntitlementApprovalWorkflowManualApprovalsArgs' manual_approvals: A manual approval workflow where users who are designated as approvers need to call the ApproveGrant/DenyGrant APIs for an Grant.
               The workflow can consist of multiple serial steps where each step defines who can act as Approver in that step and how many of those users should approve before the workflow moves to the next step.
               This can be used to create approval workflows such as
               * Require an approval from any user in a group G.
               * Require an approval from any k number of users from a Group G.
               * Require an approval from any user in a group G and then from a user U. etc.
               A single user might be part of `approvers` ACL for multiple steps in this workflow but they can only approve once and that approval will only be considered to satisfy the approval step at which it was granted.
               Structure is documented below.
        """
        pulumi.set(__self__, "manual_approvals", manual_approvals)

    @_builtins.property
    @pulumi.getter(name="manualApprovals")
    def manual_approvals(self) -> 'outputs.EntitlementApprovalWorkflowManualApprovals':
        """
        A manual approval workflow where users who are designated as approvers need to call the ApproveGrant/DenyGrant APIs for an Grant.
        The workflow can consist of multiple serial steps where each step defines who can act as Approver in that step and how many of those users should approve before the workflow moves to the next step.
        This can be used to create approval workflows such as
        * Require an approval from any user in a group G.
        * Require an approval from any k number of users from a Group G.
        * Require an approval from any user in a group G and then from a user U. etc.
        A single user might be part of `approvers` ACL for multiple steps in this workflow but they can only approve once and that approval will only be considered to satisfy the approval step at which it was granted.
        Structure is documented below.
        """
        return pulumi.get(self, "manual_approvals")


@pulumi.output_type
class EntitlementApprovalWorkflowManualApprovals(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "requireApproverJustification":
            suggest = "require_approver_justification"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EntitlementApprovalWorkflowManualApprovals. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EntitlementApprovalWorkflowManualApprovals.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EntitlementApprovalWorkflowManualApprovals.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 steps: Sequence['outputs.EntitlementApprovalWorkflowManualApprovalsStep'],
                 require_approver_justification: Optional[_builtins.bool] = None):
        """
        :param Sequence['EntitlementApprovalWorkflowManualApprovalsStepArgs'] steps: List of approval steps in this workflow. These steps would be followed in the specified order sequentially.
               Structure is documented below.
        :param _builtins.bool require_approver_justification: Optional. Do the approvers need to provide a justification for their actions?
        """
        pulumi.set(__self__, "steps", steps)
        if require_approver_justification is not None:
            pulumi.set(__self__, "require_approver_justification", require_approver_justification)

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Sequence['outputs.EntitlementApprovalWorkflowManualApprovalsStep']:
        """
        List of approval steps in this workflow. These steps would be followed in the specified order sequentially.
        Structure is documented below.
        """
        return pulumi.get(self, "steps")

    @_builtins.property
    @pulumi.getter(name="requireApproverJustification")
    def require_approver_justification(self) -> Optional[_builtins.bool]:
        """
        Optional. Do the approvers need to provide a justification for their actions?
        """
        return pulumi.get(self, "require_approver_justification")


@pulumi.output_type
class EntitlementApprovalWorkflowManualApprovalsStep(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "approvalsNeeded":
            suggest = "approvals_needed"
        elif key == "approverEmailRecipients":
            suggest = "approver_email_recipients"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EntitlementApprovalWorkflowManualApprovalsStep. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EntitlementApprovalWorkflowManualApprovalsStep.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EntitlementApprovalWorkflowManualApprovalsStep.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 approvers: 'outputs.EntitlementApprovalWorkflowManualApprovalsStepApprovers',
                 approvals_needed: Optional[_builtins.int] = None,
                 approver_email_recipients: Optional[Sequence[_builtins.str]] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param 'EntitlementApprovalWorkflowManualApprovalsStepApproversArgs' approvers: The potential set of approvers in this step. This list should contain at only one entry.
               Structure is documented below.
        :param _builtins.int approvals_needed: How many users from the above list need to approve.
               If there are not enough distinct users in the list above then the workflow
               will indefinitely block. Should always be greater than 0. Currently 1 is the only
               supported value.
        :param Sequence[_builtins.str] approver_email_recipients: Optional. Additional email addresses to be notified when a grant is pending approval.
        :param _builtins.str id: (Output, Beta)
               Output Only. The ID of the approval step.
        """
        pulumi.set(__self__, "approvers", approvers)
        if approvals_needed is not None:
            pulumi.set(__self__, "approvals_needed", approvals_needed)
        if approver_email_recipients is not None:
            pulumi.set(__self__, "approver_email_recipients", approver_email_recipients)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def approvers(self) -> 'outputs.EntitlementApprovalWorkflowManualApprovalsStepApprovers':
        """
        The potential set of approvers in this step. This list should contain at only one entry.
        Structure is documented below.
        """
        return pulumi.get(self, "approvers")

    @_builtins.property
    @pulumi.getter(name="approvalsNeeded")
    def approvals_needed(self) -> Optional[_builtins.int]:
        """
        How many users from the above list need to approve.
        If there are not enough distinct users in the list above then the workflow
        will indefinitely block. Should always be greater than 0. Currently 1 is the only
        supported value.
        """
        return pulumi.get(self, "approvals_needed")

    @_builtins.property
    @pulumi.getter(name="approverEmailRecipients")
    def approver_email_recipients(self) -> Optional[Sequence[_builtins.str]]:
        """
        Optional. Additional email addresses to be notified when a grant is pending approval.
        """
        return pulumi.get(self, "approver_email_recipients")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        (Output, Beta)
        Output Only. The ID of the approval step.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class EntitlementApprovalWorkflowManualApprovalsStepApprovers(dict):
    def __init__(__self__, *,
                 principals: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] principals: Users who are being allowed for the operation. Each entry should be a valid v1 IAM Principal Identifier. Format for these is documented at: https://cloud.google.com/iam/docs/principal-identifiers#v1
        """
        pulumi.set(__self__, "principals", principals)

    @_builtins.property
    @pulumi.getter
    def principals(self) -> Sequence[_builtins.str]:
        """
        Users who are being allowed for the operation. Each entry should be a valid v1 IAM Principal Identifier. Format for these is documented at: https://cloud.google.com/iam/docs/principal-identifiers#v1
        """
        return pulumi.get(self, "principals")


@pulumi.output_type
class EntitlementEligibleUser(dict):
    def __init__(__self__, *,
                 principals: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] principals: Users who are being allowed for the operation. Each entry should be a valid v1 IAM Principal Identifier. Format for these is documented at "https://cloud.google.com/iam/docs/principal-identifiers#v1"
        """
        pulumi.set(__self__, "principals", principals)

    @_builtins.property
    @pulumi.getter
    def principals(self) -> Sequence[_builtins.str]:
        """
        Users who are being allowed for the operation. Each entry should be a valid v1 IAM Principal Identifier. Format for these is documented at "https://cloud.google.com/iam/docs/principal-identifiers#v1"
        """
        return pulumi.get(self, "principals")


@pulumi.output_type
class EntitlementPrivilegedAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gcpIamAccess":
            suggest = "gcp_iam_access"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EntitlementPrivilegedAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EntitlementPrivilegedAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EntitlementPrivilegedAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gcp_iam_access: 'outputs.EntitlementPrivilegedAccessGcpIamAccess'):
        """
        :param 'EntitlementPrivilegedAccessGcpIamAccessArgs' gcp_iam_access: GcpIamAccess represents IAM based access control on a GCP resource. Refer to https://cloud.google.com/iam/docs to understand more about IAM.
               Structure is documented below.
        """
        pulumi.set(__self__, "gcp_iam_access", gcp_iam_access)

    @_builtins.property
    @pulumi.getter(name="gcpIamAccess")
    def gcp_iam_access(self) -> 'outputs.EntitlementPrivilegedAccessGcpIamAccess':
        """
        GcpIamAccess represents IAM based access control on a GCP resource. Refer to https://cloud.google.com/iam/docs to understand more about IAM.
        Structure is documented below.
        """
        return pulumi.get(self, "gcp_iam_access")


@pulumi.output_type
class EntitlementPrivilegedAccessGcpIamAccess(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "resourceType":
            suggest = "resource_type"
        elif key == "roleBindings":
            suggest = "role_bindings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EntitlementPrivilegedAccessGcpIamAccess. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EntitlementPrivilegedAccessGcpIamAccess.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EntitlementPrivilegedAccessGcpIamAccess.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 resource: _builtins.str,
                 resource_type: _builtins.str,
                 role_bindings: Sequence['outputs.EntitlementPrivilegedAccessGcpIamAccessRoleBinding']):
        """
        :param _builtins.str resource: Name of the resource.
        :param _builtins.str resource_type: The type of this resource.
        :param Sequence['EntitlementPrivilegedAccessGcpIamAccessRoleBindingArgs'] role_bindings: Role bindings to be created on successful grant.
               Structure is documented below.
        """
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "role_bindings", role_bindings)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> _builtins.str:
        """
        Name of the resource.
        """
        return pulumi.get(self, "resource")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        The type of this resource.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="roleBindings")
    def role_bindings(self) -> Sequence['outputs.EntitlementPrivilegedAccessGcpIamAccessRoleBinding']:
        """
        Role bindings to be created on successful grant.
        Structure is documented below.
        """
        return pulumi.get(self, "role_bindings")


@pulumi.output_type
class EntitlementPrivilegedAccessGcpIamAccessRoleBinding(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionExpression":
            suggest = "condition_expression"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EntitlementPrivilegedAccessGcpIamAccessRoleBinding. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EntitlementPrivilegedAccessGcpIamAccessRoleBinding.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EntitlementPrivilegedAccessGcpIamAccessRoleBinding.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 role: _builtins.str,
                 condition_expression: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None):
        """
        :param _builtins.str role: IAM role to be granted. https://cloud.google.com/iam/docs/roles-overview.
        :param _builtins.str condition_expression: The expression field of the IAM condition to be associated with the role. If specified, a user with an active grant for this entitlement would be able to access the resource only if this condition evaluates to true for their request.
               https://cloud.google.com/iam/docs/conditions-overview#attributes.
        :param _builtins.str id: (Output, Beta)
               Output Only. The ID corresponding to this role binding in the policy binding. This will be unique within an entitlement across time. Gets re-generated each time the entitlement is updated.
        """
        pulumi.set(__self__, "role", role)
        if condition_expression is not None:
            pulumi.set(__self__, "condition_expression", condition_expression)
        if id is not None:
            pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        IAM role to be granted. https://cloud.google.com/iam/docs/roles-overview.
        """
        return pulumi.get(self, "role")

    @_builtins.property
    @pulumi.getter(name="conditionExpression")
    def condition_expression(self) -> Optional[_builtins.str]:
        """
        The expression field of the IAM condition to be associated with the role. If specified, a user with an active grant for this entitlement would be able to access the resource only if this condition evaluates to true for their request.
        https://cloud.google.com/iam/docs/conditions-overview#attributes.
        """
        return pulumi.get(self, "condition_expression")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        (Output, Beta)
        Output Only. The ID corresponding to this role binding in the policy binding. This will be unique within an entitlement across time. Gets re-generated each time the entitlement is updated.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class EntitlementRequesterJustificationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "notMandatory":
            suggest = "not_mandatory"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EntitlementRequesterJustificationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EntitlementRequesterJustificationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EntitlementRequesterJustificationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 not_mandatory: Optional['outputs.EntitlementRequesterJustificationConfigNotMandatory'] = None,
                 unstructured: Optional['outputs.EntitlementRequesterJustificationConfigUnstructured'] = None):
        """
        :param 'EntitlementRequesterJustificationConfigNotMandatoryArgs' not_mandatory: The justification is not mandatory but can be provided in any of the supported formats.
        :param 'EntitlementRequesterJustificationConfigUnstructuredArgs' unstructured: The requester has to provide a justification in the form of free flowing text.
        """
        if not_mandatory is not None:
            pulumi.set(__self__, "not_mandatory", not_mandatory)
        if unstructured is not None:
            pulumi.set(__self__, "unstructured", unstructured)

    @_builtins.property
    @pulumi.getter(name="notMandatory")
    def not_mandatory(self) -> Optional['outputs.EntitlementRequesterJustificationConfigNotMandatory']:
        """
        The justification is not mandatory but can be provided in any of the supported formats.
        """
        return pulumi.get(self, "not_mandatory")

    @_builtins.property
    @pulumi.getter
    def unstructured(self) -> Optional['outputs.EntitlementRequesterJustificationConfigUnstructured']:
        """
        The requester has to provide a justification in the form of free flowing text.
        """
        return pulumi.get(self, "unstructured")


@pulumi.output_type
class EntitlementRequesterJustificationConfigNotMandatory(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class EntitlementRequesterJustificationConfigUnstructured(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetEntitlementAdditionalNotificationTargetResult(dict):
    def __init__(__self__, *,
                 admin_email_recipients: Sequence[_builtins.str],
                 requester_email_recipients: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] admin_email_recipients: Optional. Additional email addresses to be notified when a principal(requester) is granted access.
        :param Sequence[_builtins.str] requester_email_recipients: Optional. Additional email address to be notified about an eligible entitlement.
        """
        pulumi.set(__self__, "admin_email_recipients", admin_email_recipients)
        pulumi.set(__self__, "requester_email_recipients", requester_email_recipients)

    @_builtins.property
    @pulumi.getter(name="adminEmailRecipients")
    def admin_email_recipients(self) -> Sequence[_builtins.str]:
        """
        Optional. Additional email addresses to be notified when a principal(requester) is granted access.
        """
        return pulumi.get(self, "admin_email_recipients")

    @_builtins.property
    @pulumi.getter(name="requesterEmailRecipients")
    def requester_email_recipients(self) -> Sequence[_builtins.str]:
        """
        Optional. Additional email address to be notified about an eligible entitlement.
        """
        return pulumi.get(self, "requester_email_recipients")


@pulumi.output_type
class GetEntitlementApprovalWorkflowResult(dict):
    def __init__(__self__, *,
                 manual_approvals: Sequence['outputs.GetEntitlementApprovalWorkflowManualApprovalResult']):
        """
        :param Sequence['GetEntitlementApprovalWorkflowManualApprovalArgs'] manual_approvals: A manual approval workflow where users who are designated as approvers need to call the ApproveGrant/DenyGrant APIs for an Grant.
               The workflow can consist of multiple serial steps where each step defines who can act as Approver in that step and how many of those users should approve before the workflow moves to the next step.
               This can be used to create approval workflows such as
               * Require an approval from any user in a group G.
               * Require an approval from any k number of users from a Group G.
               * Require an approval from any user in a group G and then from a user U. etc.
               A single user might be part of 'approvers' ACL for multiple steps in this workflow but they can only approve once and that approval will only be considered to satisfy the approval step at which it was granted.
        """
        pulumi.set(__self__, "manual_approvals", manual_approvals)

    @_builtins.property
    @pulumi.getter(name="manualApprovals")
    def manual_approvals(self) -> Sequence['outputs.GetEntitlementApprovalWorkflowManualApprovalResult']:
        """
        A manual approval workflow where users who are designated as approvers need to call the ApproveGrant/DenyGrant APIs for an Grant.
        The workflow can consist of multiple serial steps where each step defines who can act as Approver in that step and how many of those users should approve before the workflow moves to the next step.
        This can be used to create approval workflows such as
        * Require an approval from any user in a group G.
        * Require an approval from any k number of users from a Group G.
        * Require an approval from any user in a group G and then from a user U. etc.
        A single user might be part of 'approvers' ACL for multiple steps in this workflow but they can only approve once and that approval will only be considered to satisfy the approval step at which it was granted.
        """
        return pulumi.get(self, "manual_approvals")


@pulumi.output_type
class GetEntitlementApprovalWorkflowManualApprovalResult(dict):
    def __init__(__self__, *,
                 require_approver_justification: _builtins.bool,
                 steps: Sequence['outputs.GetEntitlementApprovalWorkflowManualApprovalStepResult']):
        """
        :param _builtins.bool require_approver_justification: Optional. Do the approvers need to provide a justification for their actions?
        :param Sequence['GetEntitlementApprovalWorkflowManualApprovalStepArgs'] steps: List of approval steps in this workflow. These steps would be followed in the specified order sequentially.
        """
        pulumi.set(__self__, "require_approver_justification", require_approver_justification)
        pulumi.set(__self__, "steps", steps)

    @_builtins.property
    @pulumi.getter(name="requireApproverJustification")
    def require_approver_justification(self) -> _builtins.bool:
        """
        Optional. Do the approvers need to provide a justification for their actions?
        """
        return pulumi.get(self, "require_approver_justification")

    @_builtins.property
    @pulumi.getter
    def steps(self) -> Sequence['outputs.GetEntitlementApprovalWorkflowManualApprovalStepResult']:
        """
        List of approval steps in this workflow. These steps would be followed in the specified order sequentially.
        """
        return pulumi.get(self, "steps")


@pulumi.output_type
class GetEntitlementApprovalWorkflowManualApprovalStepResult(dict):
    def __init__(__self__, *,
                 approvals_needed: _builtins.int,
                 approver_email_recipients: Sequence[_builtins.str],
                 approvers: Sequence['outputs.GetEntitlementApprovalWorkflowManualApprovalStepApproverResult'],
                 id: _builtins.str):
        """
        :param _builtins.int approvals_needed: How many users from the above list need to approve.
               If there are not enough distinct users in the list above then the workflow
               will indefinitely block. Should always be greater than 0. Currently 1 is the only
               supported value.
        :param Sequence[_builtins.str] approver_email_recipients: Optional. Additional email addresses to be notified when a grant is pending approval.
        :param Sequence['GetEntitlementApprovalWorkflowManualApprovalStepApproverArgs'] approvers: The potential set of approvers in this step. This list should contain at only one entry.
        :param _builtins.str id: Output Only. The ID of the approval step.
        """
        pulumi.set(__self__, "approvals_needed", approvals_needed)
        pulumi.set(__self__, "approver_email_recipients", approver_email_recipients)
        pulumi.set(__self__, "approvers", approvers)
        pulumi.set(__self__, "id", id)

    @_builtins.property
    @pulumi.getter(name="approvalsNeeded")
    def approvals_needed(self) -> _builtins.int:
        """
        How many users from the above list need to approve.
        If there are not enough distinct users in the list above then the workflow
        will indefinitely block. Should always be greater than 0. Currently 1 is the only
        supported value.
        """
        return pulumi.get(self, "approvals_needed")

    @_builtins.property
    @pulumi.getter(name="approverEmailRecipients")
    def approver_email_recipients(self) -> Sequence[_builtins.str]:
        """
        Optional. Additional email addresses to be notified when a grant is pending approval.
        """
        return pulumi.get(self, "approver_email_recipients")

    @_builtins.property
    @pulumi.getter
    def approvers(self) -> Sequence['outputs.GetEntitlementApprovalWorkflowManualApprovalStepApproverResult']:
        """
        The potential set of approvers in this step. This list should contain at only one entry.
        """
        return pulumi.get(self, "approvers")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Output Only. The ID of the approval step.
        """
        return pulumi.get(self, "id")


@pulumi.output_type
class GetEntitlementApprovalWorkflowManualApprovalStepApproverResult(dict):
    def __init__(__self__, *,
                 principals: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] principals: Users who are being allowed for the operation. Each entry should be a valid v1 IAM Principal Identifier. Format for these is documented at: https://cloud.google.com/iam/docs/principal-identifiers#v1
        """
        pulumi.set(__self__, "principals", principals)

    @_builtins.property
    @pulumi.getter
    def principals(self) -> Sequence[_builtins.str]:
        """
        Users who are being allowed for the operation. Each entry should be a valid v1 IAM Principal Identifier. Format for these is documented at: https://cloud.google.com/iam/docs/principal-identifiers#v1
        """
        return pulumi.get(self, "principals")


@pulumi.output_type
class GetEntitlementEligibleUserResult(dict):
    def __init__(__self__, *,
                 principals: Sequence[_builtins.str]):
        """
        :param Sequence[_builtins.str] principals: Users who are being allowed for the operation. Each entry should be a valid v1 IAM Principal Identifier. Format for these is documented at "https://cloud.google.com/iam/docs/principal-identifiers#v1"
        """
        pulumi.set(__self__, "principals", principals)

    @_builtins.property
    @pulumi.getter
    def principals(self) -> Sequence[_builtins.str]:
        """
        Users who are being allowed for the operation. Each entry should be a valid v1 IAM Principal Identifier. Format for these is documented at "https://cloud.google.com/iam/docs/principal-identifiers#v1"
        """
        return pulumi.get(self, "principals")


@pulumi.output_type
class GetEntitlementPrivilegedAccessResult(dict):
    def __init__(__self__, *,
                 gcp_iam_accesses: Sequence['outputs.GetEntitlementPrivilegedAccessGcpIamAccessResult']):
        """
        :param Sequence['GetEntitlementPrivilegedAccessGcpIamAccessArgs'] gcp_iam_accesses: GcpIamAccess represents IAM based access control on a GCP resource. Refer to https://cloud.google.com/iam/docs to understand more about IAM.
        """
        pulumi.set(__self__, "gcp_iam_accesses", gcp_iam_accesses)

    @_builtins.property
    @pulumi.getter(name="gcpIamAccesses")
    def gcp_iam_accesses(self) -> Sequence['outputs.GetEntitlementPrivilegedAccessGcpIamAccessResult']:
        """
        GcpIamAccess represents IAM based access control on a GCP resource. Refer to https://cloud.google.com/iam/docs to understand more about IAM.
        """
        return pulumi.get(self, "gcp_iam_accesses")


@pulumi.output_type
class GetEntitlementPrivilegedAccessGcpIamAccessResult(dict):
    def __init__(__self__, *,
                 resource: _builtins.str,
                 resource_type: _builtins.str,
                 role_bindings: Sequence['outputs.GetEntitlementPrivilegedAccessGcpIamAccessRoleBindingResult']):
        """
        :param _builtins.str resource: Name of the resource.
        :param _builtins.str resource_type: The type of this resource.
        :param Sequence['GetEntitlementPrivilegedAccessGcpIamAccessRoleBindingArgs'] role_bindings: Role bindings to be created on successful grant.
        """
        pulumi.set(__self__, "resource", resource)
        pulumi.set(__self__, "resource_type", resource_type)
        pulumi.set(__self__, "role_bindings", role_bindings)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> _builtins.str:
        """
        Name of the resource.
        """
        return pulumi.get(self, "resource")

    @_builtins.property
    @pulumi.getter(name="resourceType")
    def resource_type(self) -> _builtins.str:
        """
        The type of this resource.
        """
        return pulumi.get(self, "resource_type")

    @_builtins.property
    @pulumi.getter(name="roleBindings")
    def role_bindings(self) -> Sequence['outputs.GetEntitlementPrivilegedAccessGcpIamAccessRoleBindingResult']:
        """
        Role bindings to be created on successful grant.
        """
        return pulumi.get(self, "role_bindings")


@pulumi.output_type
class GetEntitlementPrivilegedAccessGcpIamAccessRoleBindingResult(dict):
    def __init__(__self__, *,
                 condition_expression: _builtins.str,
                 id: _builtins.str,
                 role: _builtins.str):
        """
        :param _builtins.str condition_expression: The expression field of the IAM condition to be associated with the role. If specified, a user with an active grant for this entitlement would be able to access the resource only if this condition evaluates to true for their request.
               https://cloud.google.com/iam/docs/conditions-overview#attributes.
        :param _builtins.str id: Output Only. The ID corresponding to this role binding in the policy binding. This will be unique within an entitlement across time. Gets re-generated each time the entitlement is updated.
        :param _builtins.str role: IAM role to be granted. https://cloud.google.com/iam/docs/roles-overview.
        """
        pulumi.set(__self__, "condition_expression", condition_expression)
        pulumi.set(__self__, "id", id)
        pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter(name="conditionExpression")
    def condition_expression(self) -> _builtins.str:
        """
        The expression field of the IAM condition to be associated with the role. If specified, a user with an active grant for this entitlement would be able to access the resource only if this condition evaluates to true for their request.
        https://cloud.google.com/iam/docs/conditions-overview#attributes.
        """
        return pulumi.get(self, "condition_expression")

    @_builtins.property
    @pulumi.getter
    def id(self) -> _builtins.str:
        """
        Output Only. The ID corresponding to this role binding in the policy binding. This will be unique within an entitlement across time. Gets re-generated each time the entitlement is updated.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def role(self) -> _builtins.str:
        """
        IAM role to be granted. https://cloud.google.com/iam/docs/roles-overview.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class GetEntitlementRequesterJustificationConfigResult(dict):
    def __init__(__self__, *,
                 not_mandatories: Sequence['outputs.GetEntitlementRequesterJustificationConfigNotMandatoryResult'],
                 unstructureds: Sequence['outputs.GetEntitlementRequesterJustificationConfigUnstructuredResult']):
        """
        :param Sequence['GetEntitlementRequesterJustificationConfigNotMandatoryArgs'] not_mandatories: The justification is not mandatory but can be provided in any of the supported formats.
        :param Sequence['GetEntitlementRequesterJustificationConfigUnstructuredArgs'] unstructureds: The requester has to provide a justification in the form of free flowing text.
        """
        pulumi.set(__self__, "not_mandatories", not_mandatories)
        pulumi.set(__self__, "unstructureds", unstructureds)

    @_builtins.property
    @pulumi.getter(name="notMandatories")
    def not_mandatories(self) -> Sequence['outputs.GetEntitlementRequesterJustificationConfigNotMandatoryResult']:
        """
        The justification is not mandatory but can be provided in any of the supported formats.
        """
        return pulumi.get(self, "not_mandatories")

    @_builtins.property
    @pulumi.getter
    def unstructureds(self) -> Sequence['outputs.GetEntitlementRequesterJustificationConfigUnstructuredResult']:
        """
        The requester has to provide a justification in the form of free flowing text.
        """
        return pulumi.get(self, "unstructureds")


@pulumi.output_type
class GetEntitlementRequesterJustificationConfigNotMandatoryResult(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class GetEntitlementRequesterJustificationConfigUnstructuredResult(dict):
    def __init__(__self__):
        pass


