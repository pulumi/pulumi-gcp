# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AddressGroupIamBindingConditionArgs',
    'AddressGroupIamBindingConditionArgsDict',
    'AddressGroupIamMemberConditionArgs',
    'AddressGroupIamMemberConditionArgsDict',
    'AuthorizationPolicyRuleArgs',
    'AuthorizationPolicyRuleArgsDict',
    'AuthorizationPolicyRuleDestinationArgs',
    'AuthorizationPolicyRuleDestinationArgsDict',
    'AuthorizationPolicyRuleDestinationHttpHeaderMatchArgs',
    'AuthorizationPolicyRuleDestinationHttpHeaderMatchArgsDict',
    'AuthorizationPolicyRuleSourceArgs',
    'AuthorizationPolicyRuleSourceArgsDict',
    'AuthzPolicyCustomProviderArgs',
    'AuthzPolicyCustomProviderArgsDict',
    'AuthzPolicyCustomProviderAuthzExtensionArgs',
    'AuthzPolicyCustomProviderAuthzExtensionArgsDict',
    'AuthzPolicyCustomProviderCloudIapArgs',
    'AuthzPolicyCustomProviderCloudIapArgsDict',
    'AuthzPolicyHttpRuleArgs',
    'AuthzPolicyHttpRuleArgsDict',
    'AuthzPolicyHttpRuleFromArgs',
    'AuthzPolicyHttpRuleFromArgsDict',
    'AuthzPolicyHttpRuleFromNotSourceArgs',
    'AuthzPolicyHttpRuleFromNotSourceArgsDict',
    'AuthzPolicyHttpRuleFromNotSourceIpBlockArgs',
    'AuthzPolicyHttpRuleFromNotSourceIpBlockArgsDict',
    'AuthzPolicyHttpRuleFromNotSourcePrincipalArgs',
    'AuthzPolicyHttpRuleFromNotSourcePrincipalArgsDict',
    'AuthzPolicyHttpRuleFromNotSourcePrincipalPrincipalArgs',
    'AuthzPolicyHttpRuleFromNotSourcePrincipalPrincipalArgsDict',
    'AuthzPolicyHttpRuleFromNotSourceResourceArgs',
    'AuthzPolicyHttpRuleFromNotSourceResourceArgsDict',
    'AuthzPolicyHttpRuleFromNotSourceResourceIamServiceAccountArgs',
    'AuthzPolicyHttpRuleFromNotSourceResourceIamServiceAccountArgsDict',
    'AuthzPolicyHttpRuleFromNotSourceResourceTagValueIdSetArgs',
    'AuthzPolicyHttpRuleFromNotSourceResourceTagValueIdSetArgsDict',
    'AuthzPolicyHttpRuleFromSourceArgs',
    'AuthzPolicyHttpRuleFromSourceArgsDict',
    'AuthzPolicyHttpRuleFromSourceIpBlockArgs',
    'AuthzPolicyHttpRuleFromSourceIpBlockArgsDict',
    'AuthzPolicyHttpRuleFromSourcePrincipalArgs',
    'AuthzPolicyHttpRuleFromSourcePrincipalArgsDict',
    'AuthzPolicyHttpRuleFromSourcePrincipalPrincipalArgs',
    'AuthzPolicyHttpRuleFromSourcePrincipalPrincipalArgsDict',
    'AuthzPolicyHttpRuleFromSourceResourceArgs',
    'AuthzPolicyHttpRuleFromSourceResourceArgsDict',
    'AuthzPolicyHttpRuleFromSourceResourceIamServiceAccountArgs',
    'AuthzPolicyHttpRuleFromSourceResourceIamServiceAccountArgsDict',
    'AuthzPolicyHttpRuleFromSourceResourceTagValueIdSetArgs',
    'AuthzPolicyHttpRuleFromSourceResourceTagValueIdSetArgsDict',
    'AuthzPolicyHttpRuleToArgs',
    'AuthzPolicyHttpRuleToArgsDict',
    'AuthzPolicyHttpRuleToNotOperationArgs',
    'AuthzPolicyHttpRuleToNotOperationArgsDict',
    'AuthzPolicyHttpRuleToNotOperationHeaderSetArgs',
    'AuthzPolicyHttpRuleToNotOperationHeaderSetArgsDict',
    'AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderArgs',
    'AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderArgsDict',
    'AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderValueArgs',
    'AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderValueArgsDict',
    'AuthzPolicyHttpRuleToNotOperationHostArgs',
    'AuthzPolicyHttpRuleToNotOperationHostArgsDict',
    'AuthzPolicyHttpRuleToNotOperationPathArgs',
    'AuthzPolicyHttpRuleToNotOperationPathArgsDict',
    'AuthzPolicyHttpRuleToOperationArgs',
    'AuthzPolicyHttpRuleToOperationArgsDict',
    'AuthzPolicyHttpRuleToOperationHeaderSetArgs',
    'AuthzPolicyHttpRuleToOperationHeaderSetArgsDict',
    'AuthzPolicyHttpRuleToOperationHeaderSetHeaderArgs',
    'AuthzPolicyHttpRuleToOperationHeaderSetHeaderArgsDict',
    'AuthzPolicyHttpRuleToOperationHeaderSetHeaderValueArgs',
    'AuthzPolicyHttpRuleToOperationHeaderSetHeaderValueArgsDict',
    'AuthzPolicyHttpRuleToOperationHostArgs',
    'AuthzPolicyHttpRuleToOperationHostArgsDict',
    'AuthzPolicyHttpRuleToOperationPathArgs',
    'AuthzPolicyHttpRuleToOperationPathArgsDict',
    'AuthzPolicyTargetArgs',
    'AuthzPolicyTargetArgsDict',
    'ClientTlsPolicyClientCertificateArgs',
    'ClientTlsPolicyClientCertificateArgsDict',
    'ClientTlsPolicyClientCertificateCertificateProviderInstanceArgs',
    'ClientTlsPolicyClientCertificateCertificateProviderInstanceArgsDict',
    'ClientTlsPolicyClientCertificateGrpcEndpointArgs',
    'ClientTlsPolicyClientCertificateGrpcEndpointArgsDict',
    'ClientTlsPolicyServerValidationCaArgs',
    'ClientTlsPolicyServerValidationCaArgsDict',
    'ClientTlsPolicyServerValidationCaCertificateProviderInstanceArgs',
    'ClientTlsPolicyServerValidationCaCertificateProviderInstanceArgsDict',
    'ClientTlsPolicyServerValidationCaGrpcEndpointArgs',
    'ClientTlsPolicyServerValidationCaGrpcEndpointArgsDict',
    'FirewallEndpointEndpointSettingsArgs',
    'FirewallEndpointEndpointSettingsArgsDict',
    'InterceptDeploymentGroupConnectedEndpointGroupArgs',
    'InterceptDeploymentGroupConnectedEndpointGroupArgsDict',
    'InterceptDeploymentGroupLocationArgs',
    'InterceptDeploymentGroupLocationArgsDict',
    'InterceptEndpointGroupAssociationArgs',
    'InterceptEndpointGroupAssociationArgsDict',
    'InterceptEndpointGroupAssociationLocationArgs',
    'InterceptEndpointGroupAssociationLocationArgsDict',
    'InterceptEndpointGroupAssociationLocationsDetailArgs',
    'InterceptEndpointGroupAssociationLocationsDetailArgsDict',
    'InterceptEndpointGroupConnectedDeploymentGroupArgs',
    'InterceptEndpointGroupConnectedDeploymentGroupArgsDict',
    'InterceptEndpointGroupConnectedDeploymentGroupLocationArgs',
    'InterceptEndpointGroupConnectedDeploymentGroupLocationArgsDict',
    'MirroringDeploymentGroupConnectedEndpointGroupArgs',
    'MirroringDeploymentGroupConnectedEndpointGroupArgsDict',
    'MirroringDeploymentGroupLocationArgs',
    'MirroringDeploymentGroupLocationArgsDict',
    'MirroringEndpointGroupAssociationArgs',
    'MirroringEndpointGroupAssociationArgsDict',
    'MirroringEndpointGroupAssociationLocationArgs',
    'MirroringEndpointGroupAssociationLocationArgsDict',
    'MirroringEndpointGroupAssociationLocationsDetailArgs',
    'MirroringEndpointGroupAssociationLocationsDetailArgsDict',
    'MirroringEndpointGroupConnectedDeploymentGroupArgs',
    'MirroringEndpointGroupConnectedDeploymentGroupArgsDict',
    'MirroringEndpointGroupConnectedDeploymentGroupLocationArgs',
    'MirroringEndpointGroupConnectedDeploymentGroupLocationArgsDict',
    'SacAttachmentSymantecOptionsArgs',
    'SacAttachmentSymantecOptionsArgsDict',
    'SacRealmPairingKeyArgs',
    'SacRealmPairingKeyArgsDict',
    'SacRealmSymantecOptionsArgs',
    'SacRealmSymantecOptionsArgsDict',
    'SecurityProfileCustomInterceptProfileArgs',
    'SecurityProfileCustomInterceptProfileArgsDict',
    'SecurityProfileCustomMirroringProfileArgs',
    'SecurityProfileCustomMirroringProfileArgsDict',
    'SecurityProfileThreatPreventionProfileArgs',
    'SecurityProfileThreatPreventionProfileArgsDict',
    'SecurityProfileThreatPreventionProfileAntivirusOverrideArgs',
    'SecurityProfileThreatPreventionProfileAntivirusOverrideArgsDict',
    'SecurityProfileThreatPreventionProfileSeverityOverrideArgs',
    'SecurityProfileThreatPreventionProfileSeverityOverrideArgsDict',
    'SecurityProfileThreatPreventionProfileThreatOverrideArgs',
    'SecurityProfileThreatPreventionProfileThreatOverrideArgsDict',
    'SecurityProfileUrlFilteringProfileArgs',
    'SecurityProfileUrlFilteringProfileArgsDict',
    'SecurityProfileUrlFilteringProfileUrlFilterArgs',
    'SecurityProfileUrlFilteringProfileUrlFilterArgsDict',
    'ServerTlsPolicyMtlsPolicyArgs',
    'ServerTlsPolicyMtlsPolicyArgsDict',
    'ServerTlsPolicyMtlsPolicyClientValidationCaArgs',
    'ServerTlsPolicyMtlsPolicyClientValidationCaArgsDict',
    'ServerTlsPolicyMtlsPolicyClientValidationCaCertificateProviderInstanceArgs',
    'ServerTlsPolicyMtlsPolicyClientValidationCaCertificateProviderInstanceArgsDict',
    'ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpointArgs',
    'ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpointArgsDict',
    'ServerTlsPolicyServerCertificateArgs',
    'ServerTlsPolicyServerCertificateArgsDict',
    'ServerTlsPolicyServerCertificateCertificateProviderInstanceArgs',
    'ServerTlsPolicyServerCertificateCertificateProviderInstanceArgsDict',
    'ServerTlsPolicyServerCertificateGrpcEndpointArgs',
    'ServerTlsPolicyServerCertificateGrpcEndpointArgsDict',
]

MYPY = False

if not MYPY:
    class AddressGroupIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[_builtins.str]
        title: pulumi.Input[_builtins.str]
        description: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AddressGroupIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddressGroupIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 title: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class AddressGroupIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[_builtins.str]
        title: pulumi.Input[_builtins.str]
        description: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    AddressGroupIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddressGroupIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 title: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class AuthorizationPolicyRuleArgsDict(TypedDict):
        destinations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthorizationPolicyRuleDestinationArgsDict']]]]
        """
        List of attributes for the traffic destination. All of the destinations must match. A destination is a match if a request matches all the specified hosts, ports, methods and headers.
        If not set, the action specified in the 'action' field will be applied without any rule checks for the destination.
        Structure is documented below.
        """
        sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthorizationPolicyRuleSourceArgsDict']]]]
        """
        List of attributes for the traffic source. All of the sources must match. A source is a match if both principals and ipBlocks match.
        If not set, the action specified in the 'action' field will be applied without any rule checks for the source.
        Structure is documented below.
        """
elif False:
    AuthorizationPolicyRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationPolicyRuleArgs:
    def __init__(__self__, *,
                 destinations: Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationPolicyRuleDestinationArgs']]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationPolicyRuleSourceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AuthorizationPolicyRuleDestinationArgs']]] destinations: List of attributes for the traffic destination. All of the destinations must match. A destination is a match if a request matches all the specified hosts, ports, methods and headers.
               If not set, the action specified in the 'action' field will be applied without any rule checks for the destination.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AuthorizationPolicyRuleSourceArgs']]] sources: List of attributes for the traffic source. All of the sources must match. A source is a match if both principals and ipBlocks match.
               If not set, the action specified in the 'action' field will be applied without any rule checks for the source.
               Structure is documented below.
        """
        if destinations is not None:
            pulumi.set(__self__, "destinations", destinations)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)

    @_builtins.property
    @pulumi.getter
    def destinations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationPolicyRuleDestinationArgs']]]]:
        """
        List of attributes for the traffic destination. All of the destinations must match. A destination is a match if a request matches all the specified hosts, ports, methods and headers.
        If not set, the action specified in the 'action' field will be applied without any rule checks for the destination.
        Structure is documented below.
        """
        return pulumi.get(self, "destinations")

    @destinations.setter
    def destinations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationPolicyRuleDestinationArgs']]]]):
        pulumi.set(self, "destinations", value)

    @_builtins.property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationPolicyRuleSourceArgs']]]]:
        """
        List of attributes for the traffic source. All of the sources must match. A source is a match if both principals and ipBlocks match.
        If not set, the action specified in the 'action' field will be applied without any rule checks for the source.
        Structure is documented below.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizationPolicyRuleSourceArgs']]]]):
        pulumi.set(self, "sources", value)


if not MYPY:
    class AuthorizationPolicyRuleDestinationArgsDict(TypedDict):
        hosts: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of host names to match. Matched against the ":authority" header in http requests. At least one host should match. Each host can be an exact match, or a prefix match (example "mydomain.*") or a suffix match (example "*.myorg.com") or a presence (any) match "*".
        """
        methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of HTTP methods to match. At least one method should match. Should not be set for gRPC services.
        """
        ports: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]
        """
        List of destination ports to match. At least one port should match.
        """
        http_header_match: NotRequired[pulumi.Input['AuthorizationPolicyRuleDestinationHttpHeaderMatchArgsDict']]
        """
        Match against key:value pair in http header. Provides a flexible match based on HTTP headers, for potentially advanced use cases. At least one header should match.
        Avoid using header matches to make authorization decisions unless there is a strong guarantee that requests arrive through a trusted client or proxy.
        Structure is documented below.
        """
elif False:
    AuthorizationPolicyRuleDestinationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationPolicyRuleDestinationArgs:
    def __init__(__self__, *,
                 hosts: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 methods: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 ports: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]],
                 http_header_match: Optional[pulumi.Input['AuthorizationPolicyRuleDestinationHttpHeaderMatchArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] hosts: List of host names to match. Matched against the ":authority" header in http requests. At least one host should match. Each host can be an exact match, or a prefix match (example "mydomain.*") or a suffix match (example "*.myorg.com") or a presence (any) match "*".
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] methods: A list of HTTP methods to match. At least one method should match. Should not be set for gRPC services.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.int]]] ports: List of destination ports to match. At least one port should match.
        :param pulumi.Input['AuthorizationPolicyRuleDestinationHttpHeaderMatchArgs'] http_header_match: Match against key:value pair in http header. Provides a flexible match based on HTTP headers, for potentially advanced use cases. At least one header should match.
               Avoid using header matches to make authorization decisions unless there is a strong guarantee that requests arrive through a trusted client or proxy.
               Structure is documented below.
        """
        pulumi.set(__self__, "hosts", hosts)
        pulumi.set(__self__, "methods", methods)
        pulumi.set(__self__, "ports", ports)
        if http_header_match is not None:
            pulumi.set(__self__, "http_header_match", http_header_match)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of host names to match. Matched against the ":authority" header in http requests. At least one host should match. Each host can be an exact match, or a prefix match (example "mydomain.*") or a suffix match (example "*.myorg.com") or a presence (any) match "*".
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "hosts", value)

    @_builtins.property
    @pulumi.getter
    def methods(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of HTTP methods to match. At least one method should match. Should not be set for gRPC services.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "methods", value)

    @_builtins.property
    @pulumi.getter
    def ports(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]:
        """
        List of destination ports to match. At least one port should match.
        """
        return pulumi.get(self, "ports")

    @ports.setter
    def ports(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.int]]]):
        pulumi.set(self, "ports", value)

    @_builtins.property
    @pulumi.getter(name="httpHeaderMatch")
    def http_header_match(self) -> Optional[pulumi.Input['AuthorizationPolicyRuleDestinationHttpHeaderMatchArgs']]:
        """
        Match against key:value pair in http header. Provides a flexible match based on HTTP headers, for potentially advanced use cases. At least one header should match.
        Avoid using header matches to make authorization decisions unless there is a strong guarantee that requests arrive through a trusted client or proxy.
        Structure is documented below.
        """
        return pulumi.get(self, "http_header_match")

    @http_header_match.setter
    def http_header_match(self, value: Optional[pulumi.Input['AuthorizationPolicyRuleDestinationHttpHeaderMatchArgs']]):
        pulumi.set(self, "http_header_match", value)


if not MYPY:
    class AuthorizationPolicyRuleDestinationHttpHeaderMatchArgsDict(TypedDict):
        header_name: pulumi.Input[_builtins.str]
        """
        The name of the HTTP header to match. For matching against the HTTP request's authority, use a headerMatch with the header name ":authority". For matching a request's method, use the headerName ":method".
        """
        regex_match: pulumi.Input[_builtins.str]
        """
        The value of the header must match the regular expression specified in regexMatch. For regular expression grammar, please see: en.cppreference.com/w/cpp/regex/ecmascript For matching against a port specified in the HTTP request, use a headerMatch with headerName set to Host and a regular expression that satisfies the RFC2616 Host header's port specifier.
        """
elif False:
    AuthorizationPolicyRuleDestinationHttpHeaderMatchArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationPolicyRuleDestinationHttpHeaderMatchArgs:
    def __init__(__self__, *,
                 header_name: pulumi.Input[_builtins.str],
                 regex_match: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] header_name: The name of the HTTP header to match. For matching against the HTTP request's authority, use a headerMatch with the header name ":authority". For matching a request's method, use the headerName ":method".
        :param pulumi.Input[_builtins.str] regex_match: The value of the header must match the regular expression specified in regexMatch. For regular expression grammar, please see: en.cppreference.com/w/cpp/regex/ecmascript For matching against a port specified in the HTTP request, use a headerMatch with headerName set to Host and a regular expression that satisfies the RFC2616 Host header's port specifier.
        """
        pulumi.set(__self__, "header_name", header_name)
        pulumi.set(__self__, "regex_match", regex_match)

    @_builtins.property
    @pulumi.getter(name="headerName")
    def header_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the HTTP header to match. For matching against the HTTP request's authority, use a headerMatch with the header name ":authority". For matching a request's method, use the headerName ":method".
        """
        return pulumi.get(self, "header_name")

    @header_name.setter
    def header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "header_name", value)

    @_builtins.property
    @pulumi.getter(name="regexMatch")
    def regex_match(self) -> pulumi.Input[_builtins.str]:
        """
        The value of the header must match the regular expression specified in regexMatch. For regular expression grammar, please see: en.cppreference.com/w/cpp/regex/ecmascript For matching against a port specified in the HTTP request, use a headerMatch with headerName set to Host and a regular expression that satisfies the RFC2616 Host header's port specifier.
        """
        return pulumi.get(self, "regex_match")

    @regex_match.setter
    def regex_match(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "regex_match", value)


if not MYPY:
    class AuthorizationPolicyRuleSourceArgsDict(TypedDict):
        ip_blocks: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of CIDR ranges to match based on source IP address. At least one IP block should match. Single IP (e.g., "1.2.3.4") and CIDR (e.g., "1.2.3.0/24") are supported. Authorization based on source IP alone should be avoided.
        The IP addresses of any load balancers or proxies should be considered untrusted.
        """
        principals: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of peer identities to match for authorization. At least one principal should match. Each peer can be an exact match, or a prefix match (example, "namespace/*") or a suffix match (example, "*/service-account") or a presence match "*".
        Authorization based on the principal name without certificate validation (configured by ServerTlsPolicy resource) is considered insecure.
        """
elif False:
    AuthorizationPolicyRuleSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizationPolicyRuleSourceArgs:
    def __init__(__self__, *,
                 ip_blocks: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 principals: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ip_blocks: List of CIDR ranges to match based on source IP address. At least one IP block should match. Single IP (e.g., "1.2.3.4") and CIDR (e.g., "1.2.3.0/24") are supported. Authorization based on source IP alone should be avoided.
               The IP addresses of any load balancers or proxies should be considered untrusted.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] principals: List of peer identities to match for authorization. At least one principal should match. Each peer can be an exact match, or a prefix match (example, "namespace/*") or a suffix match (example, "*/service-account") or a presence match "*".
               Authorization based on the principal name without certificate validation (configured by ServerTlsPolicy resource) is considered insecure.
        """
        if ip_blocks is not None:
            pulumi.set(__self__, "ip_blocks", ip_blocks)
        if principals is not None:
            pulumi.set(__self__, "principals", principals)

    @_builtins.property
    @pulumi.getter(name="ipBlocks")
    def ip_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of CIDR ranges to match based on source IP address. At least one IP block should match. Single IP (e.g., "1.2.3.4") and CIDR (e.g., "1.2.3.0/24") are supported. Authorization based on source IP alone should be avoided.
        The IP addresses of any load balancers or proxies should be considered untrusted.
        """
        return pulumi.get(self, "ip_blocks")

    @ip_blocks.setter
    def ip_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_blocks", value)

    @_builtins.property
    @pulumi.getter
    def principals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of peer identities to match for authorization. At least one principal should match. Each peer can be an exact match, or a prefix match (example, "namespace/*") or a suffix match (example, "*/service-account") or a presence match "*".
        Authorization based on the principal name without certificate validation (configured by ServerTlsPolicy resource) is considered insecure.
        """
        return pulumi.get(self, "principals")

    @principals.setter
    def principals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "principals", value)


if not MYPY:
    class AuthzPolicyCustomProviderArgsDict(TypedDict):
        authz_extension: NotRequired[pulumi.Input['AuthzPolicyCustomProviderAuthzExtensionArgsDict']]
        """
        Delegate authorization decision to user authored Service Extension. Only one of cloudIap or authzExtension can be specified.
        Structure is documented below.
        """
        cloud_iap: NotRequired[pulumi.Input['AuthzPolicyCustomProviderCloudIapArgsDict']]
        """
        Delegates authorization decisions to Cloud IAP. Applicable only for managed load balancers. Enabling Cloud IAP at the AuthzPolicy level is not compatible with Cloud IAP settings in the BackendService. Enabling IAP in both places will result in request failure. Ensure that IAP is enabled in either the AuthzPolicy or the BackendService but not in both places.
        Structure is documented below.
        """
elif False:
    AuthzPolicyCustomProviderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyCustomProviderArgs:
    def __init__(__self__, *,
                 authz_extension: Optional[pulumi.Input['AuthzPolicyCustomProviderAuthzExtensionArgs']] = None,
                 cloud_iap: Optional[pulumi.Input['AuthzPolicyCustomProviderCloudIapArgs']] = None):
        """
        :param pulumi.Input['AuthzPolicyCustomProviderAuthzExtensionArgs'] authz_extension: Delegate authorization decision to user authored Service Extension. Only one of cloudIap or authzExtension can be specified.
               Structure is documented below.
        :param pulumi.Input['AuthzPolicyCustomProviderCloudIapArgs'] cloud_iap: Delegates authorization decisions to Cloud IAP. Applicable only for managed load balancers. Enabling Cloud IAP at the AuthzPolicy level is not compatible with Cloud IAP settings in the BackendService. Enabling IAP in both places will result in request failure. Ensure that IAP is enabled in either the AuthzPolicy or the BackendService but not in both places.
               Structure is documented below.
        """
        if authz_extension is not None:
            pulumi.set(__self__, "authz_extension", authz_extension)
        if cloud_iap is not None:
            pulumi.set(__self__, "cloud_iap", cloud_iap)

    @_builtins.property
    @pulumi.getter(name="authzExtension")
    def authz_extension(self) -> Optional[pulumi.Input['AuthzPolicyCustomProviderAuthzExtensionArgs']]:
        """
        Delegate authorization decision to user authored Service Extension. Only one of cloudIap or authzExtension can be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "authz_extension")

    @authz_extension.setter
    def authz_extension(self, value: Optional[pulumi.Input['AuthzPolicyCustomProviderAuthzExtensionArgs']]):
        pulumi.set(self, "authz_extension", value)

    @_builtins.property
    @pulumi.getter(name="cloudIap")
    def cloud_iap(self) -> Optional[pulumi.Input['AuthzPolicyCustomProviderCloudIapArgs']]:
        """
        Delegates authorization decisions to Cloud IAP. Applicable only for managed load balancers. Enabling Cloud IAP at the AuthzPolicy level is not compatible with Cloud IAP settings in the BackendService. Enabling IAP in both places will result in request failure. Ensure that IAP is enabled in either the AuthzPolicy or the BackendService but not in both places.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_iap")

    @cloud_iap.setter
    def cloud_iap(self, value: Optional[pulumi.Input['AuthzPolicyCustomProviderCloudIapArgs']]):
        pulumi.set(self, "cloud_iap", value)


if not MYPY:
    class AuthzPolicyCustomProviderAuthzExtensionArgsDict(TypedDict):
        resources: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of references to authorization extensions that will be invoked for requests matching this policy. Limited to 1 custom provider.
        """
elif False:
    AuthzPolicyCustomProviderAuthzExtensionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyCustomProviderAuthzExtensionArgs:
    def __init__(__self__, *,
                 resources: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] resources: A list of references to authorization extensions that will be invoked for requests matching this policy. Limited to 1 custom provider.
        """
        pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of references to authorization extensions that will be invoked for requests matching this policy. Limited to 1 custom provider.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class AuthzPolicyCustomProviderCloudIapArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Enable Cloud IAP at the AuthzPolicy level.
        """
elif False:
    AuthzPolicyCustomProviderCloudIapArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyCustomProviderCloudIapArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enable Cloud IAP at the AuthzPolicy level.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Enable Cloud IAP at the AuthzPolicy level.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class AuthzPolicyHttpRuleArgsDict(TypedDict):
        from_: NotRequired[pulumi.Input['AuthzPolicyHttpRuleFromArgsDict']]
        """
        Describes properties of one or more sources of a request.
        Structure is documented below.
        """
        to: NotRequired[pulumi.Input['AuthzPolicyHttpRuleToArgsDict']]
        """
        Describes properties of one or more targets of a request
        Structure is documented below.
        """
        when: NotRequired[pulumi.Input[_builtins.str]]
        """
        CEL expression that describes the conditions to be satisfied for the action. The result of the CEL expression is ANDed with the from and to. Refer to the CEL language reference for a list of available attributes.
        """
elif False:
    AuthzPolicyHttpRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleArgs:
    def __init__(__self__, *,
                 from_: Optional[pulumi.Input['AuthzPolicyHttpRuleFromArgs']] = None,
                 to: Optional[pulumi.Input['AuthzPolicyHttpRuleToArgs']] = None,
                 when: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['AuthzPolicyHttpRuleFromArgs'] from_: Describes properties of one or more sources of a request.
               Structure is documented below.
        :param pulumi.Input['AuthzPolicyHttpRuleToArgs'] to: Describes properties of one or more targets of a request
               Structure is documented below.
        :param pulumi.Input[_builtins.str] when: CEL expression that describes the conditions to be satisfied for the action. The result of the CEL expression is ANDed with the from and to. Refer to the CEL language reference for a list of available attributes.
        """
        if from_ is not None:
            pulumi.set(__self__, "from_", from_)
        if to is not None:
            pulumi.set(__self__, "to", to)
        if when is not None:
            pulumi.set(__self__, "when", when)

    @_builtins.property
    @pulumi.getter(name="from")
    def from_(self) -> Optional[pulumi.Input['AuthzPolicyHttpRuleFromArgs']]:
        """
        Describes properties of one or more sources of a request.
        Structure is documented below.
        """
        return pulumi.get(self, "from_")

    @from_.setter
    def from_(self, value: Optional[pulumi.Input['AuthzPolicyHttpRuleFromArgs']]):
        pulumi.set(self, "from_", value)

    @_builtins.property
    @pulumi.getter
    def to(self) -> Optional[pulumi.Input['AuthzPolicyHttpRuleToArgs']]:
        """
        Describes properties of one or more targets of a request
        Structure is documented below.
        """
        return pulumi.get(self, "to")

    @to.setter
    def to(self, value: Optional[pulumi.Input['AuthzPolicyHttpRuleToArgs']]):
        pulumi.set(self, "to", value)

    @_builtins.property
    @pulumi.getter
    def when(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        CEL expression that describes the conditions to be satisfied for the action. The result of the CEL expression is ANDed with the from and to. Refer to the CEL language reference for a list of available attributes.
        """
        return pulumi.get(self, "when")

    @when.setter
    def when(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "when", value)


if not MYPY:
    class AuthzPolicyHttpRuleFromArgsDict(TypedDict):
        not_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceArgsDict']]]]
        """
        Describes the negated properties of request sources. Matches requests from sources that do not match the criteria specified in this field. At least one of sources or notSources must be specified. Limited to 1 not_source.
        Structure is documented below.
        """
        sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourceArgsDict']]]]
        """
        Describes the properties of a request's sources. At least one of sources or notSources must be specified. Limited to 1 source. A match occurs when ANY source (in sources or notSources) matches the request. Within a single source, the match follows AND semantics across fields and OR semantics within a single field, i.e. a match occurs when ANY principal matches AND ANY ipBlocks match.
        Structure is documented below.
        """
elif False:
    AuthzPolicyHttpRuleFromArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleFromArgs:
    def __init__(__self__, *,
                 not_sources: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceArgs']]]] = None,
                 sources: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceArgs']]] not_sources: Describes the negated properties of request sources. Matches requests from sources that do not match the criteria specified in this field. At least one of sources or notSources must be specified. Limited to 1 not_source.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourceArgs']]] sources: Describes the properties of a request's sources. At least one of sources or notSources must be specified. Limited to 1 source. A match occurs when ANY source (in sources or notSources) matches the request. Within a single source, the match follows AND semantics across fields and OR semantics within a single field, i.e. a match occurs when ANY principal matches AND ANY ipBlocks match.
               Structure is documented below.
        """
        if not_sources is not None:
            pulumi.set(__self__, "not_sources", not_sources)
        if sources is not None:
            pulumi.set(__self__, "sources", sources)

    @_builtins.property
    @pulumi.getter(name="notSources")
    def not_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceArgs']]]]:
        """
        Describes the negated properties of request sources. Matches requests from sources that do not match the criteria specified in this field. At least one of sources or notSources must be specified. Limited to 1 not_source.
        Structure is documented below.
        """
        return pulumi.get(self, "not_sources")

    @not_sources.setter
    def not_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceArgs']]]]):
        pulumi.set(self, "not_sources", value)

    @_builtins.property
    @pulumi.getter
    def sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourceArgs']]]]:
        """
        Describes the properties of a request's sources. At least one of sources or notSources must be specified. Limited to 1 source. A match occurs when ANY source (in sources or notSources) matches the request. Within a single source, the match follows AND semantics across fields and OR semantics within a single field, i.e. a match occurs when ANY principal matches AND ANY ipBlocks match.
        Structure is documented below.
        """
        return pulumi.get(self, "sources")

    @sources.setter
    def sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourceArgs']]]]):
        pulumi.set(self, "sources", value)


if not MYPY:
    class AuthzPolicyHttpRuleFromNotSourceArgsDict(TypedDict):
        ip_blocks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceIpBlockArgsDict']]]]
        """
        A list of IP addresses or IP address ranges to match against the source IP address of the request. Limited to 10 ipBlocks per Authorization Policy
        Structure is documented below.
        """
        principals: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourcePrincipalArgsDict']]]]
        """
        A list of identities derived from the client's certificate. This field will not match on a request unless mutual TLS is enabled for the Forwarding rule or Gateway. Each identity is a string whose value is matched against the URI SAN, or DNS SAN or the subject field in the client's certificate. The match can be exact, prefix, suffix or a substring match. One of exact, prefix, suffix or contains must be specified.
        Limited to 5 principals.
        Structure is documented below.
        """
        resources: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceResourceArgsDict']]]]
        """
        A list of resources to match against the resource of the source VM of a request.
        Limited to 5 resources.
        Structure is documented below.
        """
elif False:
    AuthzPolicyHttpRuleFromNotSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleFromNotSourceArgs:
    def __init__(__self__, *,
                 ip_blocks: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceIpBlockArgs']]]] = None,
                 principals: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourcePrincipalArgs']]]] = None,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceResourceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceIpBlockArgs']]] ip_blocks: A list of IP addresses or IP address ranges to match against the source IP address of the request. Limited to 10 ipBlocks per Authorization Policy
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourcePrincipalArgs']]] principals: A list of identities derived from the client's certificate. This field will not match on a request unless mutual TLS is enabled for the Forwarding rule or Gateway. Each identity is a string whose value is matched against the URI SAN, or DNS SAN or the subject field in the client's certificate. The match can be exact, prefix, suffix or a substring match. One of exact, prefix, suffix or contains must be specified.
               Limited to 5 principals.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceResourceArgs']]] resources: A list of resources to match against the resource of the source VM of a request.
               Limited to 5 resources.
               Structure is documented below.
        """
        if ip_blocks is not None:
            pulumi.set(__self__, "ip_blocks", ip_blocks)
        if principals is not None:
            pulumi.set(__self__, "principals", principals)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter(name="ipBlocks")
    def ip_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceIpBlockArgs']]]]:
        """
        A list of IP addresses or IP address ranges to match against the source IP address of the request. Limited to 10 ipBlocks per Authorization Policy
        Structure is documented below.
        """
        return pulumi.get(self, "ip_blocks")

    @ip_blocks.setter
    def ip_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceIpBlockArgs']]]]):
        pulumi.set(self, "ip_blocks", value)

    @_builtins.property
    @pulumi.getter
    def principals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourcePrincipalArgs']]]]:
        """
        A list of identities derived from the client's certificate. This field will not match on a request unless mutual TLS is enabled for the Forwarding rule or Gateway. Each identity is a string whose value is matched against the URI SAN, or DNS SAN or the subject field in the client's certificate. The match can be exact, prefix, suffix or a substring match. One of exact, prefix, suffix or contains must be specified.
        Limited to 5 principals.
        Structure is documented below.
        """
        return pulumi.get(self, "principals")

    @principals.setter
    def principals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourcePrincipalArgs']]]]):
        pulumi.set(self, "principals", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceResourceArgs']]]]:
        """
        A list of resources to match against the resource of the source VM of a request.
        Limited to 5 resources.
        Structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceResourceArgs']]]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class AuthzPolicyHttpRuleFromNotSourceIpBlockArgsDict(TypedDict):
        length: pulumi.Input[_builtins.int]
        """
        The length of the address range.
        """
        prefix: pulumi.Input[_builtins.str]
        """
        The address prefix.
        """
elif False:
    AuthzPolicyHttpRuleFromNotSourceIpBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleFromNotSourceIpBlockArgs:
    def __init__(__self__, *,
                 length: pulumi.Input[_builtins.int],
                 prefix: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] length: The length of the address range.
        :param pulumi.Input[_builtins.str] prefix: The address prefix.
        """
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def length(self) -> pulumi.Input[_builtins.int]:
        """
        The length of the address range.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "length", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> pulumi.Input[_builtins.str]:
        """
        The address prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class AuthzPolicyHttpRuleFromNotSourcePrincipalArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional, Deprecated)
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def

        > **Warning:** `principals.contains` is deprecated and will be removed in a future major release. Use `principals.principal.contains` instead.
        """
        exact: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional, Deprecated)
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.

        > **Warning:** `principals.exact` is deprecated and will be removed in a future major release. Use `principals.principal.exact` instead.
        """
        ignore_case: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Optional, Deprecated)
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.

        > **Warning:** `principals.ignore_case` is deprecated and will be removed in a future major release. Use `principals.principal.ignore_case` instead.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional, Deprecated)
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz

        > **Warning:** `principals.prefix` is deprecated and will be removed in a future major release. Use `principals.principal.prefix` instead.
        """
        principal: NotRequired[pulumi.Input['AuthzPolicyHttpRuleFromNotSourcePrincipalPrincipalArgsDict']]
        """
        Required. A non-empty string whose value is matched against the principal value based on the principalSelector.
        Only exact match can be applied for CLIENT_CERT_URI_SAN, CLIENT_CERT_DNS_NAME_SAN, CLIENT_CERT_COMMON_NAME selectors.
        Structure is documented below.
        """
        principal_selector: NotRequired[pulumi.Input[_builtins.str]]
        """
        An enum to decide what principal value the principal rule will match against. If not specified, the PrincipalSelector is CLIENT_CERT_URI_SAN.
        Default value is `CLIENT_CERT_URI_SAN`.
        Possible values are: `PRINCIPAL_SELECTOR_UNSPECIFIED`, `CLIENT_CERT_URI_SAN`, `CLIENT_CERT_DNS_NAME_SAN`, `CLIENT_CERT_COMMON_NAME`.
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional, Deprecated)
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc

        > **Warning:** `principals.suffix` is deprecated and will be removed in a future major release. Use `principals.principal.suffix` instead.
        """
elif False:
    AuthzPolicyHttpRuleFromNotSourcePrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleFromNotSourcePrincipalArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 ignore_case: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 principal: Optional[pulumi.Input['AuthzPolicyHttpRuleFromNotSourcePrincipalPrincipalArgs']] = None,
                 principal_selector: Optional[pulumi.Input[_builtins.str]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: (Optional, Deprecated)
               The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc.def
               
               > **Warning:** `principals.contains` is deprecated and will be removed in a future major release. Use `principals.principal.contains` instead.
        :param pulumi.Input[_builtins.str] exact: (Optional, Deprecated)
               The input string must match exactly the string specified here.
               Examples:
               * abc only matches the value abc.
               
               > **Warning:** `principals.exact` is deprecated and will be removed in a future major release. Use `principals.principal.exact` instead.
        :param pulumi.Input[_builtins.bool] ignore_case: (Optional, Deprecated)
               If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
               
               > **Warning:** `principals.ignore_case` is deprecated and will be removed in a future major release. Use `principals.principal.ignore_case` instead.
        :param pulumi.Input[_builtins.str] prefix: (Optional, Deprecated)
               The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value abc.xyz
               
               > **Warning:** `principals.prefix` is deprecated and will be removed in a future major release. Use `principals.principal.prefix` instead.
        :param pulumi.Input['AuthzPolicyHttpRuleFromNotSourcePrincipalPrincipalArgs'] principal: Required. A non-empty string whose value is matched against the principal value based on the principalSelector.
               Only exact match can be applied for CLIENT_CERT_URI_SAN, CLIENT_CERT_DNS_NAME_SAN, CLIENT_CERT_COMMON_NAME selectors.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] principal_selector: An enum to decide what principal value the principal rule will match against. If not specified, the PrincipalSelector is CLIENT_CERT_URI_SAN.
               Default value is `CLIENT_CERT_URI_SAN`.
               Possible values are: `PRINCIPAL_SELECTOR_UNSPECIFIED`, `CLIENT_CERT_URI_SAN`, `CLIENT_CERT_DNS_NAME_SAN`, `CLIENT_CERT_COMMON_NAME`.
        :param pulumi.Input[_builtins.str] suffix: (Optional, Deprecated)
               The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc
               
               > **Warning:** `principals.suffix` is deprecated and will be removed in a future major release. Use `principals.principal.suffix` instead.
        """
        if contains is not None:
            warnings.warn("""`principals.contains` is deprecated and will be removed in a future major release. Use `principals.principal.contains` instead.""", DeprecationWarning)
            pulumi.log.warn("""contains is deprecated: `principals.contains` is deprecated and will be removed in a future major release. Use `principals.principal.contains` instead.""")
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exact is not None:
            warnings.warn("""`principals.exact` is deprecated and will be removed in a future major release. Use `principals.principal.exact` instead.""", DeprecationWarning)
            pulumi.log.warn("""exact is deprecated: `principals.exact` is deprecated and will be removed in a future major release. Use `principals.principal.exact` instead.""")
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if ignore_case is not None:
            warnings.warn("""`principals.ignore_case` is deprecated and will be removed in a future major release. Use `principals.principal.ignore_case` instead.""", DeprecationWarning)
            pulumi.log.warn("""ignore_case is deprecated: `principals.ignore_case` is deprecated and will be removed in a future major release. Use `principals.principal.ignore_case` instead.""")
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if prefix is not None:
            warnings.warn("""`principals.prefix` is deprecated and will be removed in a future major release. Use `principals.principal.prefix` instead.""", DeprecationWarning)
            pulumi.log.warn("""prefix is deprecated: `principals.prefix` is deprecated and will be removed in a future major release. Use `principals.principal.prefix` instead.""")
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)
        if principal_selector is not None:
            pulumi.set(__self__, "principal_selector", principal_selector)
        if suffix is not None:
            warnings.warn("""`principals.suffix` is deprecated and will be removed in a future major release. Use `principals.principal.suffix` instead.""", DeprecationWarning)
            pulumi.log.warn("""suffix is deprecated: `principals.suffix` is deprecated and will be removed in a future major release. Use `principals.principal.suffix` instead.""")
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""`principals.contains` is deprecated and will be removed in a future major release. Use `principals.principal.contains` instead.""")
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional, Deprecated)
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def

        > **Warning:** `principals.contains` is deprecated and will be removed in a future major release. Use `principals.principal.contains` instead.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""`principals.exact` is deprecated and will be removed in a future major release. Use `principals.principal.exact` instead.""")
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional, Deprecated)
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.

        > **Warning:** `principals.exact` is deprecated and will be removed in a future major release. Use `principals.principal.exact` instead.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter(name="ignoreCase")
    @_utilities.deprecated("""`principals.ignore_case` is deprecated and will be removed in a future major release. Use `principals.principal.ignore_case` instead.""")
    def ignore_case(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Optional, Deprecated)
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.

        > **Warning:** `principals.ignore_case` is deprecated and will be removed in a future major release. Use `principals.principal.ignore_case` instead.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""`principals.prefix` is deprecated and will be removed in a future major release. Use `principals.principal.prefix` instead.""")
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional, Deprecated)
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz

        > **Warning:** `principals.prefix` is deprecated and will be removed in a future major release. Use `principals.principal.prefix` instead.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def principal(self) -> Optional[pulumi.Input['AuthzPolicyHttpRuleFromNotSourcePrincipalPrincipalArgs']]:
        """
        Required. A non-empty string whose value is matched against the principal value based on the principalSelector.
        Only exact match can be applied for CLIENT_CERT_URI_SAN, CLIENT_CERT_DNS_NAME_SAN, CLIENT_CERT_COMMON_NAME selectors.
        Structure is documented below.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: Optional[pulumi.Input['AuthzPolicyHttpRuleFromNotSourcePrincipalPrincipalArgs']]):
        pulumi.set(self, "principal", value)

    @_builtins.property
    @pulumi.getter(name="principalSelector")
    def principal_selector(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An enum to decide what principal value the principal rule will match against. If not specified, the PrincipalSelector is CLIENT_CERT_URI_SAN.
        Default value is `CLIENT_CERT_URI_SAN`.
        Possible values are: `PRINCIPAL_SELECTOR_UNSPECIFIED`, `CLIENT_CERT_URI_SAN`, `CLIENT_CERT_DNS_NAME_SAN`, `CLIENT_CERT_COMMON_NAME`.
        """
        return pulumi.get(self, "principal_selector")

    @principal_selector.setter
    def principal_selector(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "principal_selector", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""`principals.suffix` is deprecated and will be removed in a future major release. Use `principals.principal.suffix` instead.""")
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional, Deprecated)
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc

        > **Warning:** `principals.suffix` is deprecated and will be removed in a future major release. Use `principals.principal.suffix` instead.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class AuthzPolicyHttpRuleFromNotSourcePrincipalPrincipalArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        exact: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        ignore_case: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
elif False:
    AuthzPolicyHttpRuleFromNotSourcePrincipalPrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleFromNotSourcePrincipalPrincipalArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 ignore_case: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc.def
        :param pulumi.Input[_builtins.str] exact: The input string must match exactly the string specified here.
               Examples:
               * abc only matches the value abc.
        :param pulumi.Input[_builtins.bool] ignore_case: If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        :param pulumi.Input[_builtins.str] prefix: The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value abc.xyz
        :param pulumi.Input[_builtins.str] suffix: The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class AuthzPolicyHttpRuleFromNotSourceResourceArgsDict(TypedDict):
        iam_service_account: NotRequired[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceResourceIamServiceAccountArgsDict']]
        """
        An IAM service account to match against the source service account of the VM sending the request.
        Structure is documented below.
        """
        tag_value_id_set: NotRequired[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceResourceTagValueIdSetArgsDict']]
        """
        A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request.
        Structure is documented below.
        """
elif False:
    AuthzPolicyHttpRuleFromNotSourceResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleFromNotSourceResourceArgs:
    def __init__(__self__, *,
                 iam_service_account: Optional[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceResourceIamServiceAccountArgs']] = None,
                 tag_value_id_set: Optional[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceResourceTagValueIdSetArgs']] = None):
        """
        :param pulumi.Input['AuthzPolicyHttpRuleFromNotSourceResourceIamServiceAccountArgs'] iam_service_account: An IAM service account to match against the source service account of the VM sending the request.
               Structure is documented below.
        :param pulumi.Input['AuthzPolicyHttpRuleFromNotSourceResourceTagValueIdSetArgs'] tag_value_id_set: A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request.
               Structure is documented below.
        """
        if iam_service_account is not None:
            pulumi.set(__self__, "iam_service_account", iam_service_account)
        if tag_value_id_set is not None:
            pulumi.set(__self__, "tag_value_id_set", tag_value_id_set)

    @_builtins.property
    @pulumi.getter(name="iamServiceAccount")
    def iam_service_account(self) -> Optional[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceResourceIamServiceAccountArgs']]:
        """
        An IAM service account to match against the source service account of the VM sending the request.
        Structure is documented below.
        """
        return pulumi.get(self, "iam_service_account")

    @iam_service_account.setter
    def iam_service_account(self, value: Optional[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceResourceIamServiceAccountArgs']]):
        pulumi.set(self, "iam_service_account", value)

    @_builtins.property
    @pulumi.getter(name="tagValueIdSet")
    def tag_value_id_set(self) -> Optional[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceResourceTagValueIdSetArgs']]:
        """
        A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request.
        Structure is documented below.
        """
        return pulumi.get(self, "tag_value_id_set")

    @tag_value_id_set.setter
    def tag_value_id_set(self, value: Optional[pulumi.Input['AuthzPolicyHttpRuleFromNotSourceResourceTagValueIdSetArgs']]):
        pulumi.set(self, "tag_value_id_set", value)


if not MYPY:
    class AuthzPolicyHttpRuleFromNotSourceResourceIamServiceAccountArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        exact: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        ignore_case: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
elif False:
    AuthzPolicyHttpRuleFromNotSourceResourceIamServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleFromNotSourceResourceIamServiceAccountArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 ignore_case: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc.def
        :param pulumi.Input[_builtins.str] exact: The input string must match exactly the string specified here.
               Examples:
               * abc only matches the value abc.
        :param pulumi.Input[_builtins.bool] ignore_case: If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        :param pulumi.Input[_builtins.str] prefix: The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value abc.xyz
        :param pulumi.Input[_builtins.str] suffix: The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class AuthzPolicyHttpRuleFromNotSourceResourceTagValueIdSetArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request. The match follows AND semantics which means all the ids must match.
        Limited to 5 matches.
        """
elif False:
    AuthzPolicyHttpRuleFromNotSourceResourceTagValueIdSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleFromNotSourceResourceTagValueIdSetArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ids: A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request. The match follows AND semantics which means all the ids must match.
               Limited to 5 matches.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request. The match follows AND semantics which means all the ids must match.
        Limited to 5 matches.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class AuthzPolicyHttpRuleFromSourceArgsDict(TypedDict):
        ip_blocks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourceIpBlockArgsDict']]]]
        """
        A list of IP addresses or IP address ranges to match against the source IP address of the request. Limited to 10 ipBlocks per Authorization Policy
        Structure is documented below.
        """
        principals: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourcePrincipalArgsDict']]]]
        """
        A list of identities derived from the client's certificate. This field will not match on a request unless mutual TLS is enabled for the Forwarding rule or Gateway. Each identity is a string whose value is matched against the URI SAN, or DNS SAN or the subject field in the client's certificate. The match can be exact, prefix, suffix or a substring match. One of exact, prefix, suffix or contains must be specified.
        Limited to 5 principals.
        Structure is documented below.
        """
        resources: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourceResourceArgsDict']]]]
        """
        A list of resources to match against the resource of the source VM of a request.
        Limited to 5 resources.
        Structure is documented below.
        """
elif False:
    AuthzPolicyHttpRuleFromSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleFromSourceArgs:
    def __init__(__self__, *,
                 ip_blocks: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourceIpBlockArgs']]]] = None,
                 principals: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourcePrincipalArgs']]]] = None,
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourceResourceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourceIpBlockArgs']]] ip_blocks: A list of IP addresses or IP address ranges to match against the source IP address of the request. Limited to 10 ipBlocks per Authorization Policy
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourcePrincipalArgs']]] principals: A list of identities derived from the client's certificate. This field will not match on a request unless mutual TLS is enabled for the Forwarding rule or Gateway. Each identity is a string whose value is matched against the URI SAN, or DNS SAN or the subject field in the client's certificate. The match can be exact, prefix, suffix or a substring match. One of exact, prefix, suffix or contains must be specified.
               Limited to 5 principals.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourceResourceArgs']]] resources: A list of resources to match against the resource of the source VM of a request.
               Limited to 5 resources.
               Structure is documented below.
        """
        if ip_blocks is not None:
            pulumi.set(__self__, "ip_blocks", ip_blocks)
        if principals is not None:
            pulumi.set(__self__, "principals", principals)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter(name="ipBlocks")
    def ip_blocks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourceIpBlockArgs']]]]:
        """
        A list of IP addresses or IP address ranges to match against the source IP address of the request. Limited to 10 ipBlocks per Authorization Policy
        Structure is documented below.
        """
        return pulumi.get(self, "ip_blocks")

    @ip_blocks.setter
    def ip_blocks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourceIpBlockArgs']]]]):
        pulumi.set(self, "ip_blocks", value)

    @_builtins.property
    @pulumi.getter
    def principals(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourcePrincipalArgs']]]]:
        """
        A list of identities derived from the client's certificate. This field will not match on a request unless mutual TLS is enabled for the Forwarding rule or Gateway. Each identity is a string whose value is matched against the URI SAN, or DNS SAN or the subject field in the client's certificate. The match can be exact, prefix, suffix or a substring match. One of exact, prefix, suffix or contains must be specified.
        Limited to 5 principals.
        Structure is documented below.
        """
        return pulumi.get(self, "principals")

    @principals.setter
    def principals(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourcePrincipalArgs']]]]):
        pulumi.set(self, "principals", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourceResourceArgs']]]]:
        """
        A list of resources to match against the resource of the source VM of a request.
        Limited to 5 resources.
        Structure is documented below.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleFromSourceResourceArgs']]]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class AuthzPolicyHttpRuleFromSourceIpBlockArgsDict(TypedDict):
        length: pulumi.Input[_builtins.int]
        """
        The length of the address range.
        """
        prefix: pulumi.Input[_builtins.str]
        """
        The address prefix.
        """
elif False:
    AuthzPolicyHttpRuleFromSourceIpBlockArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleFromSourceIpBlockArgs:
    def __init__(__self__, *,
                 length: pulumi.Input[_builtins.int],
                 prefix: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] length: The length of the address range.
        :param pulumi.Input[_builtins.str] prefix: The address prefix.
        """
        pulumi.set(__self__, "length", length)
        pulumi.set(__self__, "prefix", prefix)

    @_builtins.property
    @pulumi.getter
    def length(self) -> pulumi.Input[_builtins.int]:
        """
        The length of the address range.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "length", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> pulumi.Input[_builtins.str]:
        """
        The address prefix.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prefix", value)


if not MYPY:
    class AuthzPolicyHttpRuleFromSourcePrincipalArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional, Deprecated)
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def

        > **Warning:** `principals.contains` is deprecated and will be removed in a future major release. Use `principals.principal.contains` instead.
        """
        exact: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional, Deprecated)
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.

        > **Warning:** `principals.exact` is deprecated and will be removed in a future major release. Use `principals.principal.exact` instead.
        """
        ignore_case: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Optional, Deprecated)
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.

        > **Warning:** `principals.ignore_case` is deprecated and will be removed in a future major release. Use `principals.principal.ignore_case` instead.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional, Deprecated)
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz

        > **Warning:** `principals.prefix` is deprecated and will be removed in a future major release. Use `principals.principal.prefix` instead.
        """
        principal: NotRequired[pulumi.Input['AuthzPolicyHttpRuleFromSourcePrincipalPrincipalArgsDict']]
        """
        Required. A non-empty string whose value is matched against the principal value based on the principalSelector.
        Only exact match can be applied for CLIENT_CERT_URI_SAN, CLIENT_CERT_DNS_NAME_SAN, CLIENT_CERT_COMMON_NAME selectors.
        Structure is documented below.
        """
        principal_selector: NotRequired[pulumi.Input[_builtins.str]]
        """
        An enum to decide what principal value the principal rule will match against. If not specified, the PrincipalSelector is CLIENT_CERT_URI_SAN.
        Default value is `CLIENT_CERT_URI_SAN`.
        Possible values are: `PRINCIPAL_SELECTOR_UNSPECIFIED`, `CLIENT_CERT_URI_SAN`, `CLIENT_CERT_DNS_NAME_SAN`, `CLIENT_CERT_COMMON_NAME`.
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional, Deprecated)
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc

        > **Warning:** `principals.suffix` is deprecated and will be removed in a future major release. Use `principals.principal.suffix` instead.
        """
elif False:
    AuthzPolicyHttpRuleFromSourcePrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleFromSourcePrincipalArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 ignore_case: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 principal: Optional[pulumi.Input['AuthzPolicyHttpRuleFromSourcePrincipalPrincipalArgs']] = None,
                 principal_selector: Optional[pulumi.Input[_builtins.str]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: (Optional, Deprecated)
               The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc.def
               
               > **Warning:** `principals.contains` is deprecated and will be removed in a future major release. Use `principals.principal.contains` instead.
        :param pulumi.Input[_builtins.str] exact: (Optional, Deprecated)
               The input string must match exactly the string specified here.
               Examples:
               * abc only matches the value abc.
               
               > **Warning:** `principals.exact` is deprecated and will be removed in a future major release. Use `principals.principal.exact` instead.
        :param pulumi.Input[_builtins.bool] ignore_case: (Optional, Deprecated)
               If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
               
               > **Warning:** `principals.ignore_case` is deprecated and will be removed in a future major release. Use `principals.principal.ignore_case` instead.
        :param pulumi.Input[_builtins.str] prefix: (Optional, Deprecated)
               The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value abc.xyz
               
               > **Warning:** `principals.prefix` is deprecated and will be removed in a future major release. Use `principals.principal.prefix` instead.
        :param pulumi.Input['AuthzPolicyHttpRuleFromSourcePrincipalPrincipalArgs'] principal: Required. A non-empty string whose value is matched against the principal value based on the principalSelector.
               Only exact match can be applied for CLIENT_CERT_URI_SAN, CLIENT_CERT_DNS_NAME_SAN, CLIENT_CERT_COMMON_NAME selectors.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] principal_selector: An enum to decide what principal value the principal rule will match against. If not specified, the PrincipalSelector is CLIENT_CERT_URI_SAN.
               Default value is `CLIENT_CERT_URI_SAN`.
               Possible values are: `PRINCIPAL_SELECTOR_UNSPECIFIED`, `CLIENT_CERT_URI_SAN`, `CLIENT_CERT_DNS_NAME_SAN`, `CLIENT_CERT_COMMON_NAME`.
        :param pulumi.Input[_builtins.str] suffix: (Optional, Deprecated)
               The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc
               
               > **Warning:** `principals.suffix` is deprecated and will be removed in a future major release. Use `principals.principal.suffix` instead.
        """
        if contains is not None:
            warnings.warn("""`principals.contains` is deprecated and will be removed in a future major release. Use `principals.principal.contains` instead.""", DeprecationWarning)
            pulumi.log.warn("""contains is deprecated: `principals.contains` is deprecated and will be removed in a future major release. Use `principals.principal.contains` instead.""")
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exact is not None:
            warnings.warn("""`principals.exact` is deprecated and will be removed in a future major release. Use `principals.principal.exact` instead.""", DeprecationWarning)
            pulumi.log.warn("""exact is deprecated: `principals.exact` is deprecated and will be removed in a future major release. Use `principals.principal.exact` instead.""")
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if ignore_case is not None:
            warnings.warn("""`principals.ignore_case` is deprecated and will be removed in a future major release. Use `principals.principal.ignore_case` instead.""", DeprecationWarning)
            pulumi.log.warn("""ignore_case is deprecated: `principals.ignore_case` is deprecated and will be removed in a future major release. Use `principals.principal.ignore_case` instead.""")
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if prefix is not None:
            warnings.warn("""`principals.prefix` is deprecated and will be removed in a future major release. Use `principals.principal.prefix` instead.""", DeprecationWarning)
            pulumi.log.warn("""prefix is deprecated: `principals.prefix` is deprecated and will be removed in a future major release. Use `principals.principal.prefix` instead.""")
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if principal is not None:
            pulumi.set(__self__, "principal", principal)
        if principal_selector is not None:
            pulumi.set(__self__, "principal_selector", principal_selector)
        if suffix is not None:
            warnings.warn("""`principals.suffix` is deprecated and will be removed in a future major release. Use `principals.principal.suffix` instead.""", DeprecationWarning)
            pulumi.log.warn("""suffix is deprecated: `principals.suffix` is deprecated and will be removed in a future major release. Use `principals.principal.suffix` instead.""")
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""`principals.contains` is deprecated and will be removed in a future major release. Use `principals.principal.contains` instead.""")
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional, Deprecated)
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def

        > **Warning:** `principals.contains` is deprecated and will be removed in a future major release. Use `principals.principal.contains` instead.
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""`principals.exact` is deprecated and will be removed in a future major release. Use `principals.principal.exact` instead.""")
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional, Deprecated)
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.

        > **Warning:** `principals.exact` is deprecated and will be removed in a future major release. Use `principals.principal.exact` instead.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter(name="ignoreCase")
    @_utilities.deprecated("""`principals.ignore_case` is deprecated and will be removed in a future major release. Use `principals.principal.ignore_case` instead.""")
    def ignore_case(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Optional, Deprecated)
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.

        > **Warning:** `principals.ignore_case` is deprecated and will be removed in a future major release. Use `principals.principal.ignore_case` instead.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""`principals.prefix` is deprecated and will be removed in a future major release. Use `principals.principal.prefix` instead.""")
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional, Deprecated)
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz

        > **Warning:** `principals.prefix` is deprecated and will be removed in a future major release. Use `principals.principal.prefix` instead.
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def principal(self) -> Optional[pulumi.Input['AuthzPolicyHttpRuleFromSourcePrincipalPrincipalArgs']]:
        """
        Required. A non-empty string whose value is matched against the principal value based on the principalSelector.
        Only exact match can be applied for CLIENT_CERT_URI_SAN, CLIENT_CERT_DNS_NAME_SAN, CLIENT_CERT_COMMON_NAME selectors.
        Structure is documented below.
        """
        return pulumi.get(self, "principal")

    @principal.setter
    def principal(self, value: Optional[pulumi.Input['AuthzPolicyHttpRuleFromSourcePrincipalPrincipalArgs']]):
        pulumi.set(self, "principal", value)

    @_builtins.property
    @pulumi.getter(name="principalSelector")
    def principal_selector(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An enum to decide what principal value the principal rule will match against. If not specified, the PrincipalSelector is CLIENT_CERT_URI_SAN.
        Default value is `CLIENT_CERT_URI_SAN`.
        Possible values are: `PRINCIPAL_SELECTOR_UNSPECIFIED`, `CLIENT_CERT_URI_SAN`, `CLIENT_CERT_DNS_NAME_SAN`, `CLIENT_CERT_COMMON_NAME`.
        """
        return pulumi.get(self, "principal_selector")

    @principal_selector.setter
    def principal_selector(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "principal_selector", value)

    @_builtins.property
    @pulumi.getter
    @_utilities.deprecated("""`principals.suffix` is deprecated and will be removed in a future major release. Use `principals.principal.suffix` instead.""")
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional, Deprecated)
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc

        > **Warning:** `principals.suffix` is deprecated and will be removed in a future major release. Use `principals.principal.suffix` instead.
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class AuthzPolicyHttpRuleFromSourcePrincipalPrincipalArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        exact: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        ignore_case: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
elif False:
    AuthzPolicyHttpRuleFromSourcePrincipalPrincipalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleFromSourcePrincipalPrincipalArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 ignore_case: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc.def
        :param pulumi.Input[_builtins.str] exact: The input string must match exactly the string specified here.
               Examples:
               * abc only matches the value abc.
        :param pulumi.Input[_builtins.bool] ignore_case: If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        :param pulumi.Input[_builtins.str] prefix: The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value abc.xyz
        :param pulumi.Input[_builtins.str] suffix: The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class AuthzPolicyHttpRuleFromSourceResourceArgsDict(TypedDict):
        iam_service_account: NotRequired[pulumi.Input['AuthzPolicyHttpRuleFromSourceResourceIamServiceAccountArgsDict']]
        """
        An IAM service account to match against the source service account of the VM sending the request.
        Structure is documented below.
        """
        tag_value_id_set: NotRequired[pulumi.Input['AuthzPolicyHttpRuleFromSourceResourceTagValueIdSetArgsDict']]
        """
        A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request.
        Structure is documented below.
        """
elif False:
    AuthzPolicyHttpRuleFromSourceResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleFromSourceResourceArgs:
    def __init__(__self__, *,
                 iam_service_account: Optional[pulumi.Input['AuthzPolicyHttpRuleFromSourceResourceIamServiceAccountArgs']] = None,
                 tag_value_id_set: Optional[pulumi.Input['AuthzPolicyHttpRuleFromSourceResourceTagValueIdSetArgs']] = None):
        """
        :param pulumi.Input['AuthzPolicyHttpRuleFromSourceResourceIamServiceAccountArgs'] iam_service_account: An IAM service account to match against the source service account of the VM sending the request.
               Structure is documented below.
        :param pulumi.Input['AuthzPolicyHttpRuleFromSourceResourceTagValueIdSetArgs'] tag_value_id_set: A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request.
               Structure is documented below.
        """
        if iam_service_account is not None:
            pulumi.set(__self__, "iam_service_account", iam_service_account)
        if tag_value_id_set is not None:
            pulumi.set(__self__, "tag_value_id_set", tag_value_id_set)

    @_builtins.property
    @pulumi.getter(name="iamServiceAccount")
    def iam_service_account(self) -> Optional[pulumi.Input['AuthzPolicyHttpRuleFromSourceResourceIamServiceAccountArgs']]:
        """
        An IAM service account to match against the source service account of the VM sending the request.
        Structure is documented below.
        """
        return pulumi.get(self, "iam_service_account")

    @iam_service_account.setter
    def iam_service_account(self, value: Optional[pulumi.Input['AuthzPolicyHttpRuleFromSourceResourceIamServiceAccountArgs']]):
        pulumi.set(self, "iam_service_account", value)

    @_builtins.property
    @pulumi.getter(name="tagValueIdSet")
    def tag_value_id_set(self) -> Optional[pulumi.Input['AuthzPolicyHttpRuleFromSourceResourceTagValueIdSetArgs']]:
        """
        A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request.
        Structure is documented below.
        """
        return pulumi.get(self, "tag_value_id_set")

    @tag_value_id_set.setter
    def tag_value_id_set(self, value: Optional[pulumi.Input['AuthzPolicyHttpRuleFromSourceResourceTagValueIdSetArgs']]):
        pulumi.set(self, "tag_value_id_set", value)


if not MYPY:
    class AuthzPolicyHttpRuleFromSourceResourceIamServiceAccountArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        exact: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        ignore_case: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
elif False:
    AuthzPolicyHttpRuleFromSourceResourceIamServiceAccountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleFromSourceResourceIamServiceAccountArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 ignore_case: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc.def
        :param pulumi.Input[_builtins.str] exact: The input string must match exactly the string specified here.
               Examples:
               * abc only matches the value abc.
        :param pulumi.Input[_builtins.bool] ignore_case: If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        :param pulumi.Input[_builtins.str] prefix: The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value abc.xyz
        :param pulumi.Input[_builtins.str] suffix: The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class AuthzPolicyHttpRuleFromSourceResourceTagValueIdSetArgsDict(TypedDict):
        ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request. The match follows AND semantics which means all the ids must match.
        Limited to 5 matches.
        """
elif False:
    AuthzPolicyHttpRuleFromSourceResourceTagValueIdSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleFromSourceResourceTagValueIdSetArgs:
    def __init__(__self__, *,
                 ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ids: A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request. The match follows AND semantics which means all the ids must match.
               Limited to 5 matches.
        """
        if ids is not None:
            pulumi.set(__self__, "ids", ids)

    @_builtins.property
    @pulumi.getter
    def ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of resource tag value permanent IDs to match against the resource manager tags value associated with the source VM of a request. The match follows AND semantics which means all the ids must match.
        Limited to 5 matches.
        """
        return pulumi.get(self, "ids")

    @ids.setter
    def ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ids", value)


if not MYPY:
    class AuthzPolicyHttpRuleToArgsDict(TypedDict):
        not_operations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationArgsDict']]]]
        """
        Describes the negated properties of the targets of a request. Matches requests for operations that do not match the criteria specified in this field. At least one of operations or notOperations must be specified. Limited to 1 not_operation.
        Structure is documented below.
        """
        operations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationArgsDict']]]]
        """
        Describes properties of one or more targets of a request. At least one of operations or notOperations must be specified. Limited to 1 operation. A match occurs when ANY operation (in operations or notOperations) matches. Within an operation, the match follows AND semantics across fields and OR semantics within a field, i.e. a match occurs when ANY path matches AND ANY header matches and ANY method matches.
        Structure is documented below.
        """
elif False:
    AuthzPolicyHttpRuleToArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleToArgs:
    def __init__(__self__, *,
                 not_operations: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationArgs']]]] = None,
                 operations: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationArgs']]] not_operations: Describes the negated properties of the targets of a request. Matches requests for operations that do not match the criteria specified in this field. At least one of operations or notOperations must be specified. Limited to 1 not_operation.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationArgs']]] operations: Describes properties of one or more targets of a request. At least one of operations or notOperations must be specified. Limited to 1 operation. A match occurs when ANY operation (in operations or notOperations) matches. Within an operation, the match follows AND semantics across fields and OR semantics within a field, i.e. a match occurs when ANY path matches AND ANY header matches and ANY method matches.
               Structure is documented below.
        """
        if not_operations is not None:
            pulumi.set(__self__, "not_operations", not_operations)
        if operations is not None:
            pulumi.set(__self__, "operations", operations)

    @_builtins.property
    @pulumi.getter(name="notOperations")
    def not_operations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationArgs']]]]:
        """
        Describes the negated properties of the targets of a request. Matches requests for operations that do not match the criteria specified in this field. At least one of operations or notOperations must be specified. Limited to 1 not_operation.
        Structure is documented below.
        """
        return pulumi.get(self, "not_operations")

    @not_operations.setter
    def not_operations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationArgs']]]]):
        pulumi.set(self, "not_operations", value)

    @_builtins.property
    @pulumi.getter
    def operations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationArgs']]]]:
        """
        Describes properties of one or more targets of a request. At least one of operations or notOperations must be specified. Limited to 1 operation. A match occurs when ANY operation (in operations or notOperations) matches. Within an operation, the match follows AND semantics across fields and OR semantics within a field, i.e. a match occurs when ANY path matches AND ANY header matches and ANY method matches.
        Structure is documented below.
        """
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationArgs']]]]):
        pulumi.set(self, "operations", value)


if not MYPY:
    class AuthzPolicyHttpRuleToNotOperationArgsDict(TypedDict):
        header_set: NotRequired[pulumi.Input['AuthzPolicyHttpRuleToNotOperationHeaderSetArgsDict']]
        """
        A list of headers to match against in http header.
        Structure is documented below.
        """
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationHostArgsDict']]]]
        """
        A list of HTTP Hosts to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
        Limited to 10 matches.
        Structure is documented below.
        """
        methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of HTTP methods to match against. Each entry must be a valid HTTP method name (GET, PUT, POST, HEAD, PATCH, DELETE, OPTIONS). It only allows exact match and is always case sensitive.
        """
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationPathArgsDict']]]]
        """
        A list of paths to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
        Limited to 10 matches.
        Note that this path match includes the query parameters. For gRPC services, this should be a fully-qualified name of the form /package.service/method.
        Structure is documented below.
        """
elif False:
    AuthzPolicyHttpRuleToNotOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleToNotOperationArgs:
    def __init__(__self__, *,
                 header_set: Optional[pulumi.Input['AuthzPolicyHttpRuleToNotOperationHeaderSetArgs']] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationHostArgs']]]] = None,
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationPathArgs']]]] = None):
        """
        :param pulumi.Input['AuthzPolicyHttpRuleToNotOperationHeaderSetArgs'] header_set: A list of headers to match against in http header.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationHostArgs']]] hosts: A list of HTTP Hosts to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
               Limited to 10 matches.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] methods: A list of HTTP methods to match against. Each entry must be a valid HTTP method name (GET, PUT, POST, HEAD, PATCH, DELETE, OPTIONS). It only allows exact match and is always case sensitive.
        :param pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationPathArgs']]] paths: A list of paths to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
               Limited to 10 matches.
               Note that this path match includes the query parameters. For gRPC services, this should be a fully-qualified name of the form /package.service/method.
               Structure is documented below.
        """
        if header_set is not None:
            pulumi.set(__self__, "header_set", header_set)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)

    @_builtins.property
    @pulumi.getter(name="headerSet")
    def header_set(self) -> Optional[pulumi.Input['AuthzPolicyHttpRuleToNotOperationHeaderSetArgs']]:
        """
        A list of headers to match against in http header.
        Structure is documented below.
        """
        return pulumi.get(self, "header_set")

    @header_set.setter
    def header_set(self, value: Optional[pulumi.Input['AuthzPolicyHttpRuleToNotOperationHeaderSetArgs']]):
        pulumi.set(self, "header_set", value)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationHostArgs']]]]:
        """
        A list of HTTP Hosts to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
        Limited to 10 matches.
        Structure is documented below.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationHostArgs']]]]):
        pulumi.set(self, "hosts", value)

    @_builtins.property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of HTTP methods to match against. Each entry must be a valid HTTP method name (GET, PUT, POST, HEAD, PATCH, DELETE, OPTIONS). It only allows exact match and is always case sensitive.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "methods", value)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationPathArgs']]]]:
        """
        A list of paths to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
        Limited to 10 matches.
        Note that this path match includes the query parameters. For gRPC services, this should be a fully-qualified name of the form /package.service/method.
        Structure is documented below.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationPathArgs']]]]):
        pulumi.set(self, "paths", value)


if not MYPY:
    class AuthzPolicyHttpRuleToNotOperationHeaderSetArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderArgsDict']]]]
        """
        A list of headers to match against in http header. The match can be one of exact, prefix, suffix, or contains (substring match). The match follows AND semantics which means all the headers must match. Matches are always case sensitive unless the ignoreCase is set. Limited to 10 matches.
        Structure is documented below.
        """
elif False:
    AuthzPolicyHttpRuleToNotOperationHeaderSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleToNotOperationHeaderSetArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderArgs']]] headers: A list of headers to match against in http header. The match can be one of exact, prefix, suffix, or contains (substring match). The match follows AND semantics which means all the headers must match. Matches are always case sensitive unless the ignoreCase is set. Limited to 10 matches.
               Structure is documented below.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderArgs']]]]:
        """
        A list of headers to match against in http header. The match can be one of exact, prefix, suffix, or contains (substring match). The match follows AND semantics which means all the headers must match. Matches are always case sensitive unless the ignoreCase is set. Limited to 10 matches.
        Structure is documented below.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderArgs']]]]):
        pulumi.set(self, "headers", value)


if not MYPY:
    class AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of the header in the request.
        """
        value: NotRequired[pulumi.Input['AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderValueArgsDict']]
        """
        Specifies how the header match will be performed.
        Structure is documented below.
        """
elif False:
    AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input['AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderValueArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of the header in the request.
        :param pulumi.Input['AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderValueArgs'] value: Specifies how the header match will be performed.
               Structure is documented below.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the header in the request.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderValueArgs']]:
        """
        Specifies how the header match will be performed.
        Structure is documented below.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderValueArgs']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderValueArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        exact: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        ignore_case: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
elif False:
    AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleToNotOperationHeaderSetHeaderValueArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 ignore_case: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc.def
        :param pulumi.Input[_builtins.str] exact: The input string must match exactly the string specified here.
               Examples:
               * abc only matches the value abc.
        :param pulumi.Input[_builtins.bool] ignore_case: If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        :param pulumi.Input[_builtins.str] prefix: The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value abc.xyz
        :param pulumi.Input[_builtins.str] suffix: The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class AuthzPolicyHttpRuleToNotOperationHostArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        exact: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        ignore_case: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
elif False:
    AuthzPolicyHttpRuleToNotOperationHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleToNotOperationHostArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 ignore_case: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc.def
        :param pulumi.Input[_builtins.str] exact: The input string must match exactly the string specified here.
               Examples:
               * abc only matches the value abc.
        :param pulumi.Input[_builtins.bool] ignore_case: If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        :param pulumi.Input[_builtins.str] prefix: The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value abc.xyz
        :param pulumi.Input[_builtins.str] suffix: The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class AuthzPolicyHttpRuleToNotOperationPathArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        exact: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        ignore_case: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
elif False:
    AuthzPolicyHttpRuleToNotOperationPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleToNotOperationPathArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 ignore_case: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc.def
        :param pulumi.Input[_builtins.str] exact: The input string must match exactly the string specified here.
               Examples:
               * abc only matches the value abc.
        :param pulumi.Input[_builtins.bool] ignore_case: If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        :param pulumi.Input[_builtins.str] prefix: The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value abc.xyz
        :param pulumi.Input[_builtins.str] suffix: The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class AuthzPolicyHttpRuleToOperationArgsDict(TypedDict):
        header_set: NotRequired[pulumi.Input['AuthzPolicyHttpRuleToOperationHeaderSetArgsDict']]
        """
        A list of headers to match against in http header.
        Structure is documented below.
        """
        hosts: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationHostArgsDict']]]]
        """
        A list of HTTP Hosts to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
        Limited to 10 matches.
        Structure is documented below.
        """
        methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of HTTP methods to match against. Each entry must be a valid HTTP method name (GET, PUT, POST, HEAD, PATCH, DELETE, OPTIONS). It only allows exact match and is always case sensitive.
        """
        paths: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationPathArgsDict']]]]
        """
        A list of paths to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
        Limited to 10 matches.
        Note that this path match includes the query parameters. For gRPC services, this should be a fully-qualified name of the form /package.service/method.
        Structure is documented below.
        """
elif False:
    AuthzPolicyHttpRuleToOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleToOperationArgs:
    def __init__(__self__, *,
                 header_set: Optional[pulumi.Input['AuthzPolicyHttpRuleToOperationHeaderSetArgs']] = None,
                 hosts: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationHostArgs']]]] = None,
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 paths: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationPathArgs']]]] = None):
        """
        :param pulumi.Input['AuthzPolicyHttpRuleToOperationHeaderSetArgs'] header_set: A list of headers to match against in http header.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationHostArgs']]] hosts: A list of HTTP Hosts to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
               Limited to 10 matches.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] methods: A list of HTTP methods to match against. Each entry must be a valid HTTP method name (GET, PUT, POST, HEAD, PATCH, DELETE, OPTIONS). It only allows exact match and is always case sensitive.
        :param pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationPathArgs']]] paths: A list of paths to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
               Limited to 10 matches.
               Note that this path match includes the query parameters. For gRPC services, this should be a fully-qualified name of the form /package.service/method.
               Structure is documented below.
        """
        if header_set is not None:
            pulumi.set(__self__, "header_set", header_set)
        if hosts is not None:
            pulumi.set(__self__, "hosts", hosts)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if paths is not None:
            pulumi.set(__self__, "paths", paths)

    @_builtins.property
    @pulumi.getter(name="headerSet")
    def header_set(self) -> Optional[pulumi.Input['AuthzPolicyHttpRuleToOperationHeaderSetArgs']]:
        """
        A list of headers to match against in http header.
        Structure is documented below.
        """
        return pulumi.get(self, "header_set")

    @header_set.setter
    def header_set(self, value: Optional[pulumi.Input['AuthzPolicyHttpRuleToOperationHeaderSetArgs']]):
        pulumi.set(self, "header_set", value)

    @_builtins.property
    @pulumi.getter
    def hosts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationHostArgs']]]]:
        """
        A list of HTTP Hosts to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
        Limited to 10 matches.
        Structure is documented below.
        """
        return pulumi.get(self, "hosts")

    @hosts.setter
    def hosts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationHostArgs']]]]):
        pulumi.set(self, "hosts", value)

    @_builtins.property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of HTTP methods to match against. Each entry must be a valid HTTP method name (GET, PUT, POST, HEAD, PATCH, DELETE, OPTIONS). It only allows exact match and is always case sensitive.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "methods", value)

    @_builtins.property
    @pulumi.getter
    def paths(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationPathArgs']]]]:
        """
        A list of paths to match against. The match can be one of exact, prefix, suffix, or contains (substring match). Matches are always case sensitive unless the ignoreCase is set.
        Limited to 10 matches.
        Note that this path match includes the query parameters. For gRPC services, this should be a fully-qualified name of the form /package.service/method.
        Structure is documented below.
        """
        return pulumi.get(self, "paths")

    @paths.setter
    def paths(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationPathArgs']]]]):
        pulumi.set(self, "paths", value)


if not MYPY:
    class AuthzPolicyHttpRuleToOperationHeaderSetArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationHeaderSetHeaderArgsDict']]]]
        """
        A list of headers to match against in http header. The match can be one of exact, prefix, suffix, or contains (substring match). The match follows AND semantics which means all the headers must match. Matches are always case sensitive unless the ignoreCase is set. Limited to 10 matches.
        Structure is documented below.
        """
elif False:
    AuthzPolicyHttpRuleToOperationHeaderSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleToOperationHeaderSetArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationHeaderSetHeaderArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationHeaderSetHeaderArgs']]] headers: A list of headers to match against in http header. The match can be one of exact, prefix, suffix, or contains (substring match). The match follows AND semantics which means all the headers must match. Matches are always case sensitive unless the ignoreCase is set. Limited to 10 matches.
               Structure is documented below.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationHeaderSetHeaderArgs']]]]:
        """
        A list of headers to match against in http header. The match can be one of exact, prefix, suffix, or contains (substring match). The match follows AND semantics which means all the headers must match. Matches are always case sensitive unless the ignoreCase is set. Limited to 10 matches.
        Structure is documented below.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthzPolicyHttpRuleToOperationHeaderSetHeaderArgs']]]]):
        pulumi.set(self, "headers", value)


if not MYPY:
    class AuthzPolicyHttpRuleToOperationHeaderSetHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the name of the header in the request.
        """
        value: NotRequired[pulumi.Input['AuthzPolicyHttpRuleToOperationHeaderSetHeaderValueArgsDict']]
        """
        Specifies how the header match will be performed.
        Structure is documented below.
        """
elif False:
    AuthzPolicyHttpRuleToOperationHeaderSetHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleToOperationHeaderSetHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input['AuthzPolicyHttpRuleToOperationHeaderSetHeaderValueArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies the name of the header in the request.
        :param pulumi.Input['AuthzPolicyHttpRuleToOperationHeaderSetHeaderValueArgs'] value: Specifies how the header match will be performed.
               Structure is documented below.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the name of the header in the request.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['AuthzPolicyHttpRuleToOperationHeaderSetHeaderValueArgs']]:
        """
        Specifies how the header match will be performed.
        Structure is documented below.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['AuthzPolicyHttpRuleToOperationHeaderSetHeaderValueArgs']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class AuthzPolicyHttpRuleToOperationHeaderSetHeaderValueArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        exact: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        ignore_case: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
elif False:
    AuthzPolicyHttpRuleToOperationHeaderSetHeaderValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleToOperationHeaderSetHeaderValueArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 ignore_case: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc.def
        :param pulumi.Input[_builtins.str] exact: The input string must match exactly the string specified here.
               Examples:
               * abc only matches the value abc.
        :param pulumi.Input[_builtins.bool] ignore_case: If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        :param pulumi.Input[_builtins.str] prefix: The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value abc.xyz
        :param pulumi.Input[_builtins.str] suffix: The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class AuthzPolicyHttpRuleToOperationHostArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        exact: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        ignore_case: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
elif False:
    AuthzPolicyHttpRuleToOperationHostArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleToOperationHostArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 ignore_case: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc.def
        :param pulumi.Input[_builtins.str] exact: The input string must match exactly the string specified here.
               Examples:
               * abc only matches the value abc.
        :param pulumi.Input[_builtins.bool] ignore_case: If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        :param pulumi.Input[_builtins.str] prefix: The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value abc.xyz
        :param pulumi.Input[_builtins.str] suffix: The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class AuthzPolicyHttpRuleToOperationPathArgsDict(TypedDict):
        contains: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        exact: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        ignore_case: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
elif False:
    AuthzPolicyHttpRuleToOperationPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyHttpRuleToOperationPathArgs:
    def __init__(__self__, *,
                 contains: Optional[pulumi.Input[_builtins.str]] = None,
                 exact: Optional[pulumi.Input[_builtins.str]] = None,
                 ignore_case: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix: Optional[pulumi.Input[_builtins.str]] = None,
                 suffix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] contains: The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc.def
        :param pulumi.Input[_builtins.str] exact: The input string must match exactly the string specified here.
               Examples:
               * abc only matches the value abc.
        :param pulumi.Input[_builtins.bool] ignore_case: If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        :param pulumi.Input[_builtins.str] prefix: The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value abc.xyz
        :param pulumi.Input[_builtins.str] suffix: The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
               Examples:
               * abc matches the value xyz.abc
        """
        if contains is not None:
            pulumi.set(__self__, "contains", contains)
        if exact is not None:
            pulumi.set(__self__, "exact", exact)
        if ignore_case is not None:
            pulumi.set(__self__, "ignore_case", ignore_case)
        if prefix is not None:
            pulumi.set(__self__, "prefix", prefix)
        if suffix is not None:
            pulumi.set(__self__, "suffix", suffix)

    @_builtins.property
    @pulumi.getter
    def contains(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the substring specified here. Note: empty contains match is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc.def
        """
        return pulumi.get(self, "contains")

    @contains.setter
    def contains(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "contains", value)

    @_builtins.property
    @pulumi.getter
    def exact(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must match exactly the string specified here.
        Examples:
        * abc only matches the value abc.
        """
        return pulumi.get(self, "exact")

    @exact.setter
    def exact(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "exact", value)

    @_builtins.property
    @pulumi.getter(name="ignoreCase")
    def ignore_case(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, indicates the exact/prefix/suffix/contains matching should be case insensitive. For example, the matcher data will match both input string Data and data if set to true.
        """
        return pulumi.get(self, "ignore_case")

    @ignore_case.setter
    def ignore_case(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_case", value)

    @_builtins.property
    @pulumi.getter
    def prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the prefix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value abc.xyz
        """
        return pulumi.get(self, "prefix")

    @prefix.setter
    def prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix", value)

    @_builtins.property
    @pulumi.getter
    def suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input string must have the suffix specified here. Note: empty prefix is not allowed, please use regex instead.
        Examples:
        * abc matches the value xyz.abc
        """
        return pulumi.get(self, "suffix")

    @suffix.setter
    def suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "suffix", value)


if not MYPY:
    class AuthzPolicyTargetArgsDict(TypedDict):
        load_balancing_scheme: pulumi.Input[_builtins.str]
        """
        All gateways and forwarding rules referenced by this policy and extensions must share the same load balancing scheme.
        For more information, refer to [Backend services overview](https://cloud.google.com/load-balancing/docs/backend-service).
        Possible values are: `INTERNAL_MANAGED`, `EXTERNAL_MANAGED`, `INTERNAL_SELF_MANAGED`.
        """
        resources: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of references to the Forwarding Rules on which this policy will be applied.
        """
elif False:
    AuthzPolicyTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthzPolicyTargetArgs:
    def __init__(__self__, *,
                 load_balancing_scheme: pulumi.Input[_builtins.str],
                 resources: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] load_balancing_scheme: All gateways and forwarding rules referenced by this policy and extensions must share the same load balancing scheme.
               For more information, refer to [Backend services overview](https://cloud.google.com/load-balancing/docs/backend-service).
               Possible values are: `INTERNAL_MANAGED`, `EXTERNAL_MANAGED`, `INTERNAL_SELF_MANAGED`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] resources: A list of references to the Forwarding Rules on which this policy will be applied.
        """
        pulumi.set(__self__, "load_balancing_scheme", load_balancing_scheme)
        if resources is not None:
            pulumi.set(__self__, "resources", resources)

    @_builtins.property
    @pulumi.getter(name="loadBalancingScheme")
    def load_balancing_scheme(self) -> pulumi.Input[_builtins.str]:
        """
        All gateways and forwarding rules referenced by this policy and extensions must share the same load balancing scheme.
        For more information, refer to [Backend services overview](https://cloud.google.com/load-balancing/docs/backend-service).
        Possible values are: `INTERNAL_MANAGED`, `EXTERNAL_MANAGED`, `INTERNAL_SELF_MANAGED`.
        """
        return pulumi.get(self, "load_balancing_scheme")

    @load_balancing_scheme.setter
    def load_balancing_scheme(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "load_balancing_scheme", value)

    @_builtins.property
    @pulumi.getter
    def resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of references to the Forwarding Rules on which this policy will be applied.
        """
        return pulumi.get(self, "resources")

    @resources.setter
    def resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "resources", value)


if not MYPY:
    class ClientTlsPolicyClientCertificateArgsDict(TypedDict):
        certificate_provider_instance: NotRequired[pulumi.Input['ClientTlsPolicyClientCertificateCertificateProviderInstanceArgsDict']]
        """
        The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.
        Structure is documented below.
        """
        grpc_endpoint: NotRequired[pulumi.Input['ClientTlsPolicyClientCertificateGrpcEndpointArgsDict']]
        """
        gRPC specific configuration to access the gRPC server to obtain the cert and private key.
        Structure is documented below.
        """
elif False:
    ClientTlsPolicyClientCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientTlsPolicyClientCertificateArgs:
    def __init__(__self__, *,
                 certificate_provider_instance: Optional[pulumi.Input['ClientTlsPolicyClientCertificateCertificateProviderInstanceArgs']] = None,
                 grpc_endpoint: Optional[pulumi.Input['ClientTlsPolicyClientCertificateGrpcEndpointArgs']] = None):
        """
        :param pulumi.Input['ClientTlsPolicyClientCertificateCertificateProviderInstanceArgs'] certificate_provider_instance: The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.
               Structure is documented below.
        :param pulumi.Input['ClientTlsPolicyClientCertificateGrpcEndpointArgs'] grpc_endpoint: gRPC specific configuration to access the gRPC server to obtain the cert and private key.
               Structure is documented below.
        """
        if certificate_provider_instance is not None:
            pulumi.set(__self__, "certificate_provider_instance", certificate_provider_instance)
        if grpc_endpoint is not None:
            pulumi.set(__self__, "grpc_endpoint", grpc_endpoint)

    @_builtins.property
    @pulumi.getter(name="certificateProviderInstance")
    def certificate_provider_instance(self) -> Optional[pulumi.Input['ClientTlsPolicyClientCertificateCertificateProviderInstanceArgs']]:
        """
        The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.
        Structure is documented below.
        """
        return pulumi.get(self, "certificate_provider_instance")

    @certificate_provider_instance.setter
    def certificate_provider_instance(self, value: Optional[pulumi.Input['ClientTlsPolicyClientCertificateCertificateProviderInstanceArgs']]):
        pulumi.set(self, "certificate_provider_instance", value)

    @_builtins.property
    @pulumi.getter(name="grpcEndpoint")
    def grpc_endpoint(self) -> Optional[pulumi.Input['ClientTlsPolicyClientCertificateGrpcEndpointArgs']]:
        """
        gRPC specific configuration to access the gRPC server to obtain the cert and private key.
        Structure is documented below.
        """
        return pulumi.get(self, "grpc_endpoint")

    @grpc_endpoint.setter
    def grpc_endpoint(self, value: Optional[pulumi.Input['ClientTlsPolicyClientCertificateGrpcEndpointArgs']]):
        pulumi.set(self, "grpc_endpoint", value)


if not MYPY:
    class ClientTlsPolicyClientCertificateCertificateProviderInstanceArgsDict(TypedDict):
        plugin_instance: pulumi.Input[_builtins.str]
        """
        Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
        """
elif False:
    ClientTlsPolicyClientCertificateCertificateProviderInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientTlsPolicyClientCertificateCertificateProviderInstanceArgs:
    def __init__(__self__, *,
                 plugin_instance: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] plugin_instance: Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
        """
        pulumi.set(__self__, "plugin_instance", plugin_instance)

    @_builtins.property
    @pulumi.getter(name="pluginInstance")
    def plugin_instance(self) -> pulumi.Input[_builtins.str]:
        """
        Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
        """
        return pulumi.get(self, "plugin_instance")

    @plugin_instance.setter
    def plugin_instance(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "plugin_instance", value)


if not MYPY:
    class ClientTlsPolicyClientCertificateGrpcEndpointArgsDict(TypedDict):
        target_uri: pulumi.Input[_builtins.str]
        """
        The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
        """
elif False:
    ClientTlsPolicyClientCertificateGrpcEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientTlsPolicyClientCertificateGrpcEndpointArgs:
    def __init__(__self__, *,
                 target_uri: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] target_uri: The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
        """
        pulumi.set(__self__, "target_uri", target_uri)

    @_builtins.property
    @pulumi.getter(name="targetUri")
    def target_uri(self) -> pulumi.Input[_builtins.str]:
        """
        The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
        """
        return pulumi.get(self, "target_uri")

    @target_uri.setter
    def target_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_uri", value)


if not MYPY:
    class ClientTlsPolicyServerValidationCaArgsDict(TypedDict):
        certificate_provider_instance: NotRequired[pulumi.Input['ClientTlsPolicyServerValidationCaCertificateProviderInstanceArgsDict']]
        """
        The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.
        Structure is documented below.
        """
        grpc_endpoint: NotRequired[pulumi.Input['ClientTlsPolicyServerValidationCaGrpcEndpointArgsDict']]
        """
        gRPC specific configuration to access the gRPC server to obtain the cert and private key.
        Structure is documented below.
        """
elif False:
    ClientTlsPolicyServerValidationCaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientTlsPolicyServerValidationCaArgs:
    def __init__(__self__, *,
                 certificate_provider_instance: Optional[pulumi.Input['ClientTlsPolicyServerValidationCaCertificateProviderInstanceArgs']] = None,
                 grpc_endpoint: Optional[pulumi.Input['ClientTlsPolicyServerValidationCaGrpcEndpointArgs']] = None):
        """
        :param pulumi.Input['ClientTlsPolicyServerValidationCaCertificateProviderInstanceArgs'] certificate_provider_instance: The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.
               Structure is documented below.
        :param pulumi.Input['ClientTlsPolicyServerValidationCaGrpcEndpointArgs'] grpc_endpoint: gRPC specific configuration to access the gRPC server to obtain the cert and private key.
               Structure is documented below.
        """
        if certificate_provider_instance is not None:
            pulumi.set(__self__, "certificate_provider_instance", certificate_provider_instance)
        if grpc_endpoint is not None:
            pulumi.set(__self__, "grpc_endpoint", grpc_endpoint)

    @_builtins.property
    @pulumi.getter(name="certificateProviderInstance")
    def certificate_provider_instance(self) -> Optional[pulumi.Input['ClientTlsPolicyServerValidationCaCertificateProviderInstanceArgs']]:
        """
        The certificate provider instance specification that will be passed to the data plane, which will be used to load necessary credential information.
        Structure is documented below.
        """
        return pulumi.get(self, "certificate_provider_instance")

    @certificate_provider_instance.setter
    def certificate_provider_instance(self, value: Optional[pulumi.Input['ClientTlsPolicyServerValidationCaCertificateProviderInstanceArgs']]):
        pulumi.set(self, "certificate_provider_instance", value)

    @_builtins.property
    @pulumi.getter(name="grpcEndpoint")
    def grpc_endpoint(self) -> Optional[pulumi.Input['ClientTlsPolicyServerValidationCaGrpcEndpointArgs']]:
        """
        gRPC specific configuration to access the gRPC server to obtain the cert and private key.
        Structure is documented below.
        """
        return pulumi.get(self, "grpc_endpoint")

    @grpc_endpoint.setter
    def grpc_endpoint(self, value: Optional[pulumi.Input['ClientTlsPolicyServerValidationCaGrpcEndpointArgs']]):
        pulumi.set(self, "grpc_endpoint", value)


if not MYPY:
    class ClientTlsPolicyServerValidationCaCertificateProviderInstanceArgsDict(TypedDict):
        plugin_instance: pulumi.Input[_builtins.str]
        """
        Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
        """
elif False:
    ClientTlsPolicyServerValidationCaCertificateProviderInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientTlsPolicyServerValidationCaCertificateProviderInstanceArgs:
    def __init__(__self__, *,
                 plugin_instance: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] plugin_instance: Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
        """
        pulumi.set(__self__, "plugin_instance", plugin_instance)

    @_builtins.property
    @pulumi.getter(name="pluginInstance")
    def plugin_instance(self) -> pulumi.Input[_builtins.str]:
        """
        Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
        """
        return pulumi.get(self, "plugin_instance")

    @plugin_instance.setter
    def plugin_instance(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "plugin_instance", value)


if not MYPY:
    class ClientTlsPolicyServerValidationCaGrpcEndpointArgsDict(TypedDict):
        target_uri: pulumi.Input[_builtins.str]
        """
        The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
        """
elif False:
    ClientTlsPolicyServerValidationCaGrpcEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClientTlsPolicyServerValidationCaGrpcEndpointArgs:
    def __init__(__self__, *,
                 target_uri: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] target_uri: The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
        """
        pulumi.set(__self__, "target_uri", target_uri)

    @_builtins.property
    @pulumi.getter(name="targetUri")
    def target_uri(self) -> pulumi.Input[_builtins.str]:
        """
        The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
        """
        return pulumi.get(self, "target_uri")

    @target_uri.setter
    def target_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_uri", value)


if not MYPY:
    class FirewallEndpointEndpointSettingsArgsDict(TypedDict):
        jumbo_frames_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether Jumbo Frames are enabled for the firewall endpoint.
        """
elif False:
    FirewallEndpointEndpointSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FirewallEndpointEndpointSettingsArgs:
    def __init__(__self__, *,
                 jumbo_frames_enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] jumbo_frames_enabled: Indicates whether Jumbo Frames are enabled for the firewall endpoint.
        """
        if jumbo_frames_enabled is not None:
            pulumi.set(__self__, "jumbo_frames_enabled", jumbo_frames_enabled)

    @_builtins.property
    @pulumi.getter(name="jumboFramesEnabled")
    def jumbo_frames_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether Jumbo Frames are enabled for the firewall endpoint.
        """
        return pulumi.get(self, "jumbo_frames_enabled")

    @jumbo_frames_enabled.setter
    def jumbo_frames_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "jumbo_frames_enabled", value)


if not MYPY:
    class InterceptDeploymentGroupConnectedEndpointGroupArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The connected endpoint group's resource name, for example:
        `projects/123456789/locations/global/interceptEndpointGroups/my-eg`.
        See https://google.aip.dev/124.
        """
elif False:
    InterceptDeploymentGroupConnectedEndpointGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InterceptDeploymentGroupConnectedEndpointGroupArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Output)
               The connected endpoint group's resource name, for example:
               `projects/123456789/locations/global/interceptEndpointGroups/my-eg`.
               See https://google.aip.dev/124.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The connected endpoint group's resource name, for example:
        `projects/123456789/locations/global/interceptEndpointGroups/my-eg`.
        See https://google.aip.dev/124.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class InterceptDeploymentGroupLocationArgsDict(TypedDict):
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        The cloud location of the deployment group, currently restricted to `global`.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
elif False:
    InterceptDeploymentGroupLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InterceptDeploymentGroupLocationArgs:
    def __init__(__self__, *,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] location: The cloud location of the deployment group, currently restricted to `global`.
        :param pulumi.Input[_builtins.str] state: (Output)
               The current state of the association in this location.
               Possible values:
               STATE_UNSPECIFIED
               ACTIVE
               OUT_OF_SYNC
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cloud location of the deployment group, currently restricted to `global`.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class InterceptEndpointGroupAssociationArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The connected deployment group's resource name, for example:
        `projects/123456789/locations/global/interceptDeploymentGroups/my-dg`.
        See https://google.aip.dev/124.
        """
        network: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The associated network, for example:
        projects/123456789/global/networks/my-network.
        See https://google.aip.dev/124.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
elif False:
    InterceptEndpointGroupAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InterceptEndpointGroupAssociationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 network: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Output)
               The connected deployment group's resource name, for example:
               `projects/123456789/locations/global/interceptDeploymentGroups/my-dg`.
               See https://google.aip.dev/124.
        :param pulumi.Input[_builtins.str] network: (Output)
               The associated network, for example:
               projects/123456789/global/networks/my-network.
               See https://google.aip.dev/124.
        :param pulumi.Input[_builtins.str] state: (Output)
               The current state of the association in this location.
               Possible values:
               STATE_UNSPECIFIED
               ACTIVE
               OUT_OF_SYNC
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The connected deployment group's resource name, for example:
        `projects/123456789/locations/global/interceptDeploymentGroups/my-dg`.
        See https://google.aip.dev/124.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The associated network, for example:
        projects/123456789/global/networks/my-network.
        See https://google.aip.dev/124.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class InterceptEndpointGroupAssociationLocationArgsDict(TypedDict):
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        The cloud location of the association, currently restricted to `global`.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
elif False:
    InterceptEndpointGroupAssociationLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InterceptEndpointGroupAssociationLocationArgs:
    def __init__(__self__, *,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] location: The cloud location of the association, currently restricted to `global`.
        :param pulumi.Input[_builtins.str] state: (Output)
               The current state of the association in this location.
               Possible values:
               STATE_UNSPECIFIED
               ACTIVE
               OUT_OF_SYNC
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cloud location of the association, currently restricted to `global`.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class InterceptEndpointGroupAssociationLocationsDetailArgsDict(TypedDict):
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        The cloud location of the association, currently restricted to `global`.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
elif False:
    InterceptEndpointGroupAssociationLocationsDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InterceptEndpointGroupAssociationLocationsDetailArgs:
    def __init__(__self__, *,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] location: The cloud location of the association, currently restricted to `global`.
        :param pulumi.Input[_builtins.str] state: (Output)
               The current state of the association in this location.
               Possible values:
               STATE_UNSPECIFIED
               ACTIVE
               OUT_OF_SYNC
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cloud location of the association, currently restricted to `global`.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class InterceptEndpointGroupConnectedDeploymentGroupArgsDict(TypedDict):
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['InterceptEndpointGroupConnectedDeploymentGroupLocationArgsDict']]]]
        """
        (Output)
        The list of locations where the deployment group is present.
        Structure is documented below.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The connected deployment group's resource name, for example:
        `projects/123456789/locations/global/interceptDeploymentGroups/my-dg`.
        See https://google.aip.dev/124.
        """
elif False:
    InterceptEndpointGroupConnectedDeploymentGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InterceptEndpointGroupConnectedDeploymentGroupArgs:
    def __init__(__self__, *,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input['InterceptEndpointGroupConnectedDeploymentGroupLocationArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['InterceptEndpointGroupConnectedDeploymentGroupLocationArgs']]] locations: (Output)
               The list of locations where the deployment group is present.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] name: (Output)
               The connected deployment group's resource name, for example:
               `projects/123456789/locations/global/interceptDeploymentGroups/my-dg`.
               See https://google.aip.dev/124.
        """
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InterceptEndpointGroupConnectedDeploymentGroupLocationArgs']]]]:
        """
        (Output)
        The list of locations where the deployment group is present.
        Structure is documented below.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InterceptEndpointGroupConnectedDeploymentGroupLocationArgs']]]]):
        pulumi.set(self, "locations", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The connected deployment group's resource name, for example:
        `projects/123456789/locations/global/interceptDeploymentGroups/my-dg`.
        See https://google.aip.dev/124.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class InterceptEndpointGroupConnectedDeploymentGroupLocationArgsDict(TypedDict):
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        The cloud location of the endpoint group, currently restricted to `global`.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
elif False:
    InterceptEndpointGroupConnectedDeploymentGroupLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InterceptEndpointGroupConnectedDeploymentGroupLocationArgs:
    def __init__(__self__, *,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] location: The cloud location of the endpoint group, currently restricted to `global`.
        :param pulumi.Input[_builtins.str] state: (Output)
               The current state of the association in this location.
               Possible values:
               STATE_UNSPECIFIED
               ACTIVE
               OUT_OF_SYNC
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cloud location of the endpoint group, currently restricted to `global`.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class MirroringDeploymentGroupConnectedEndpointGroupArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The connected endpoint group's resource name, for example:
        `projects/123456789/locations/global/mirroringEndpointGroups/my-eg`.
        See https://google.aip.dev/124.
        """
elif False:
    MirroringDeploymentGroupConnectedEndpointGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MirroringDeploymentGroupConnectedEndpointGroupArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Output)
               The connected endpoint group's resource name, for example:
               `projects/123456789/locations/global/mirroringEndpointGroups/my-eg`.
               See https://google.aip.dev/124.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The connected endpoint group's resource name, for example:
        `projects/123456789/locations/global/mirroringEndpointGroups/my-eg`.
        See https://google.aip.dev/124.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class MirroringDeploymentGroupLocationArgsDict(TypedDict):
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        The cloud location of the deployment group, currently restricted to `global`.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
elif False:
    MirroringDeploymentGroupLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MirroringDeploymentGroupLocationArgs:
    def __init__(__self__, *,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] location: The cloud location of the deployment group, currently restricted to `global`.
        :param pulumi.Input[_builtins.str] state: (Output)
               The current state of the association in this location.
               Possible values:
               STATE_UNSPECIFIED
               ACTIVE
               OUT_OF_SYNC
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cloud location of the deployment group, currently restricted to `global`.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class MirroringEndpointGroupAssociationArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The connected deployment group's resource name, for example:
        `projects/123456789/locations/global/mirroringDeploymentGroups/my-dg`.
        See https://google.aip.dev/124.
        """
        network: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The associated network, for example:
        projects/123456789/global/networks/my-network.
        See https://google.aip.dev/124.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
elif False:
    MirroringEndpointGroupAssociationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MirroringEndpointGroupAssociationArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 network: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Output)
               The connected deployment group's resource name, for example:
               `projects/123456789/locations/global/mirroringDeploymentGroups/my-dg`.
               See https://google.aip.dev/124.
        :param pulumi.Input[_builtins.str] network: (Output)
               The associated network, for example:
               projects/123456789/global/networks/my-network.
               See https://google.aip.dev/124.
        :param pulumi.Input[_builtins.str] state: (Output)
               The current state of the association in this location.
               Possible values:
               STATE_UNSPECIFIED
               ACTIVE
               OUT_OF_SYNC
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The connected deployment group's resource name, for example:
        `projects/123456789/locations/global/mirroringDeploymentGroups/my-dg`.
        See https://google.aip.dev/124.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The associated network, for example:
        projects/123456789/global/networks/my-network.
        See https://google.aip.dev/124.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "network", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class MirroringEndpointGroupAssociationLocationArgsDict(TypedDict):
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        The cloud location of the association, currently restricted to `global`.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
elif False:
    MirroringEndpointGroupAssociationLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MirroringEndpointGroupAssociationLocationArgs:
    def __init__(__self__, *,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] location: The cloud location of the association, currently restricted to `global`.
        :param pulumi.Input[_builtins.str] state: (Output)
               The current state of the association in this location.
               Possible values:
               STATE_UNSPECIFIED
               ACTIVE
               OUT_OF_SYNC
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cloud location of the association, currently restricted to `global`.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class MirroringEndpointGroupAssociationLocationsDetailArgsDict(TypedDict):
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        The cloud location of the association, currently restricted to `global`.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
elif False:
    MirroringEndpointGroupAssociationLocationsDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MirroringEndpointGroupAssociationLocationsDetailArgs:
    def __init__(__self__, *,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] location: The cloud location of the association, currently restricted to `global`.
        :param pulumi.Input[_builtins.str] state: (Output)
               The current state of the association in this location.
               Possible values:
               STATE_UNSPECIFIED
               ACTIVE
               OUT_OF_SYNC
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cloud location of the association, currently restricted to `global`.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class MirroringEndpointGroupConnectedDeploymentGroupArgsDict(TypedDict):
        locations: NotRequired[pulumi.Input[Sequence[pulumi.Input['MirroringEndpointGroupConnectedDeploymentGroupLocationArgsDict']]]]
        """
        (Output)
        The list of locations where the deployment group is present.
        Structure is documented below.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The connected deployment group's resource name, for example:
        `projects/123456789/locations/global/mirroringDeploymentGroups/my-dg`.
        See https://google.aip.dev/124.
        """
elif False:
    MirroringEndpointGroupConnectedDeploymentGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MirroringEndpointGroupConnectedDeploymentGroupArgs:
    def __init__(__self__, *,
                 locations: Optional[pulumi.Input[Sequence[pulumi.Input['MirroringEndpointGroupConnectedDeploymentGroupLocationArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['MirroringEndpointGroupConnectedDeploymentGroupLocationArgs']]] locations: (Output)
               The list of locations where the deployment group is present.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] name: (Output)
               The connected deployment group's resource name, for example:
               `projects/123456789/locations/global/mirroringDeploymentGroups/my-dg`.
               See https://google.aip.dev/124.
        """
        if locations is not None:
            pulumi.set(__self__, "locations", locations)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['MirroringEndpointGroupConnectedDeploymentGroupLocationArgs']]]]:
        """
        (Output)
        The list of locations where the deployment group is present.
        Structure is documented below.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['MirroringEndpointGroupConnectedDeploymentGroupLocationArgs']]]]):
        pulumi.set(self, "locations", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The connected deployment group's resource name, for example:
        `projects/123456789/locations/global/mirroringDeploymentGroups/my-dg`.
        See https://google.aip.dev/124.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class MirroringEndpointGroupConnectedDeploymentGroupLocationArgsDict(TypedDict):
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        The cloud location of the endpoint group, currently restricted to `global`.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
elif False:
    MirroringEndpointGroupConnectedDeploymentGroupLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class MirroringEndpointGroupConnectedDeploymentGroupLocationArgs:
    def __init__(__self__, *,
                 location: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] location: The cloud location of the endpoint group, currently restricted to `global`.
        :param pulumi.Input[_builtins.str] state: (Output)
               The current state of the association in this location.
               Possible values:
               STATE_UNSPECIFIED
               ACTIVE
               OUT_OF_SYNC
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The cloud location of the endpoint group, currently restricted to `global`.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The current state of the association in this location.
        Possible values:
        STATE_UNSPECIFIED
        ACTIVE
        OUT_OF_SYNC
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class SacAttachmentSymantecOptionsArgsDict(TypedDict):
        symantec_location_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name to be used when creating a location on the customer's behalf in Symantec's Location API. Not to be confused with Google Cloud locations.
        """
        symantec_site: NotRequired[pulumi.Input[_builtins.str]]
        """
        Symantec data center identifier that this attachment will connect to.
        """
elif False:
    SacAttachmentSymantecOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SacAttachmentSymantecOptionsArgs:
    def __init__(__self__, *,
                 symantec_location_name: Optional[pulumi.Input[_builtins.str]] = None,
                 symantec_site: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] symantec_location_name: Name to be used when creating a location on the customer's behalf in Symantec's Location API. Not to be confused with Google Cloud locations.
        :param pulumi.Input[_builtins.str] symantec_site: Symantec data center identifier that this attachment will connect to.
        """
        if symantec_location_name is not None:
            pulumi.set(__self__, "symantec_location_name", symantec_location_name)
        if symantec_site is not None:
            pulumi.set(__self__, "symantec_site", symantec_site)

    @_builtins.property
    @pulumi.getter(name="symantecLocationName")
    def symantec_location_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name to be used when creating a location on the customer's behalf in Symantec's Location API. Not to be confused with Google Cloud locations.
        """
        return pulumi.get(self, "symantec_location_name")

    @symantec_location_name.setter
    def symantec_location_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "symantec_location_name", value)

    @_builtins.property
    @pulumi.getter(name="symantecSite")
    def symantec_site(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Symantec data center identifier that this attachment will connect to.
        """
        return pulumi.get(self, "symantec_site")

    @symantec_site.setter
    def symantec_site(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "symantec_site", value)


if not MYPY:
    class SacRealmPairingKeyArgsDict(TypedDict):
        expire_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Timestamp in UTC of when this resource is considered expired. It expires 7 days after creation.
        """
        key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Key value.
        """
elif False:
    SacRealmPairingKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SacRealmPairingKeyArgs:
    def __init__(__self__, *,
                 expire_time: Optional[pulumi.Input[_builtins.str]] = None,
                 key: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expire_time: (Output)
               Timestamp in UTC of when this resource is considered expired. It expires 7 days after creation.
        :param pulumi.Input[_builtins.str] key: (Output)
               Key value.
        """
        if expire_time is not None:
            pulumi.set(__self__, "expire_time", expire_time)
        if key is not None:
            pulumi.set(__self__, "key", key)

    @_builtins.property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Timestamp in UTC of when this resource is considered expired. It expires 7 days after creation.
        """
        return pulumi.get(self, "expire_time")

    @expire_time.setter
    def expire_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expire_time", value)

    @_builtins.property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Key value.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key", value)


if not MYPY:
    class SacRealmSymantecOptionsArgsDict(TypedDict):
        available_symantec_sites: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        Symantec site IDs which the user can choose to connect to.
        """
        secret_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        API Key used to call Symantec APIs on the user's behalf. Required if using Symantec Cloud SWG. P4SA account needs permissions granted to read this secret.
        A secret ID, secret name, or secret URI can be specified, but it will be parsed and stored as a secret URI in the form projects/{projectNumber}/secrets/my-secret.
        """
        symantec_connection_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Connection status to Symantec API
        """
elif False:
    SacRealmSymantecOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SacRealmSymantecOptionsArgs:
    def __init__(__self__, *,
                 available_symantec_sites: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 secret_path: Optional[pulumi.Input[_builtins.str]] = None,
                 symantec_connection_state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] available_symantec_sites: (Output)
               Symantec site IDs which the user can choose to connect to.
        :param pulumi.Input[_builtins.str] secret_path: API Key used to call Symantec APIs on the user's behalf. Required if using Symantec Cloud SWG. P4SA account needs permissions granted to read this secret.
               A secret ID, secret name, or secret URI can be specified, but it will be parsed and stored as a secret URI in the form projects/{projectNumber}/secrets/my-secret.
        :param pulumi.Input[_builtins.str] symantec_connection_state: (Output)
               Connection status to Symantec API
        """
        if available_symantec_sites is not None:
            pulumi.set(__self__, "available_symantec_sites", available_symantec_sites)
        if secret_path is not None:
            pulumi.set(__self__, "secret_path", secret_path)
        if symantec_connection_state is not None:
            pulumi.set(__self__, "symantec_connection_state", symantec_connection_state)

    @_builtins.property
    @pulumi.getter(name="availableSymantecSites")
    def available_symantec_sites(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        Symantec site IDs which the user can choose to connect to.
        """
        return pulumi.get(self, "available_symantec_sites")

    @available_symantec_sites.setter
    def available_symantec_sites(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "available_symantec_sites", value)

    @_builtins.property
    @pulumi.getter(name="secretPath")
    def secret_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API Key used to call Symantec APIs on the user's behalf. Required if using Symantec Cloud SWG. P4SA account needs permissions granted to read this secret.
        A secret ID, secret name, or secret URI can be specified, but it will be parsed and stored as a secret URI in the form projects/{projectNumber}/secrets/my-secret.
        """
        return pulumi.get(self, "secret_path")

    @secret_path.setter
    def secret_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "secret_path", value)

    @_builtins.property
    @pulumi.getter(name="symantecConnectionState")
    def symantec_connection_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Connection status to Symantec API
        """
        return pulumi.get(self, "symantec_connection_state")

    @symantec_connection_state.setter
    def symantec_connection_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "symantec_connection_state", value)


if not MYPY:
    class SecurityProfileCustomInterceptProfileArgsDict(TypedDict):
        intercept_endpoint_group: pulumi.Input[_builtins.str]
        """
        The Intercept Endpoint Group to which matching traffic should be intercepted.
        Format: projects/{project_id}/locations/global/interceptEndpointGroups/{endpoint_group_id}
        """
elif False:
    SecurityProfileCustomInterceptProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileCustomInterceptProfileArgs:
    def __init__(__self__, *,
                 intercept_endpoint_group: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] intercept_endpoint_group: The Intercept Endpoint Group to which matching traffic should be intercepted.
               Format: projects/{project_id}/locations/global/interceptEndpointGroups/{endpoint_group_id}
        """
        pulumi.set(__self__, "intercept_endpoint_group", intercept_endpoint_group)

    @_builtins.property
    @pulumi.getter(name="interceptEndpointGroup")
    def intercept_endpoint_group(self) -> pulumi.Input[_builtins.str]:
        """
        The Intercept Endpoint Group to which matching traffic should be intercepted.
        Format: projects/{project_id}/locations/global/interceptEndpointGroups/{endpoint_group_id}
        """
        return pulumi.get(self, "intercept_endpoint_group")

    @intercept_endpoint_group.setter
    def intercept_endpoint_group(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "intercept_endpoint_group", value)


if not MYPY:
    class SecurityProfileCustomMirroringProfileArgsDict(TypedDict):
        mirroring_endpoint_group: pulumi.Input[_builtins.str]
        """
        The target Mirroring Endpoint Group.
        When a mirroring rule with this security profile attached matches a packet,
        a replica will be mirrored to the location-local target in this group.
        Format: projects/{project_id}/locations/global/mirroringEndpointGroups/{endpoint_group_id}
        """
        mirroring_deployment_groups: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The target downstream Mirroring Deployment Groups.
        This field is used for Packet Broker mirroring endpoint groups to specify
        the deployment groups that the packet should be mirrored to by the broker.
        Format: projects/{project_id}/locations/global/mirroringDeploymentGroups/{deployment_group_id}
        """
        mirroring_endpoint_group_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output, Beta)
        The type of the mirroring endpoint group this profile is attached to.
        Possible values:
        DIRECT
        BROKER
        """
elif False:
    SecurityProfileCustomMirroringProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileCustomMirroringProfileArgs:
    def __init__(__self__, *,
                 mirroring_endpoint_group: pulumi.Input[_builtins.str],
                 mirroring_deployment_groups: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 mirroring_endpoint_group_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] mirroring_endpoint_group: The target Mirroring Endpoint Group.
               When a mirroring rule with this security profile attached matches a packet,
               a replica will be mirrored to the location-local target in this group.
               Format: projects/{project_id}/locations/global/mirroringEndpointGroups/{endpoint_group_id}
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] mirroring_deployment_groups: The target downstream Mirroring Deployment Groups.
               This field is used for Packet Broker mirroring endpoint groups to specify
               the deployment groups that the packet should be mirrored to by the broker.
               Format: projects/{project_id}/locations/global/mirroringDeploymentGroups/{deployment_group_id}
        :param pulumi.Input[_builtins.str] mirroring_endpoint_group_type: (Output, Beta)
               The type of the mirroring endpoint group this profile is attached to.
               Possible values:
               DIRECT
               BROKER
        """
        pulumi.set(__self__, "mirroring_endpoint_group", mirroring_endpoint_group)
        if mirroring_deployment_groups is not None:
            pulumi.set(__self__, "mirroring_deployment_groups", mirroring_deployment_groups)
        if mirroring_endpoint_group_type is not None:
            pulumi.set(__self__, "mirroring_endpoint_group_type", mirroring_endpoint_group_type)

    @_builtins.property
    @pulumi.getter(name="mirroringEndpointGroup")
    def mirroring_endpoint_group(self) -> pulumi.Input[_builtins.str]:
        """
        The target Mirroring Endpoint Group.
        When a mirroring rule with this security profile attached matches a packet,
        a replica will be mirrored to the location-local target in this group.
        Format: projects/{project_id}/locations/global/mirroringEndpointGroups/{endpoint_group_id}
        """
        return pulumi.get(self, "mirroring_endpoint_group")

    @mirroring_endpoint_group.setter
    def mirroring_endpoint_group(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mirroring_endpoint_group", value)

    @_builtins.property
    @pulumi.getter(name="mirroringDeploymentGroups")
    def mirroring_deployment_groups(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The target downstream Mirroring Deployment Groups.
        This field is used for Packet Broker mirroring endpoint groups to specify
        the deployment groups that the packet should be mirrored to by the broker.
        Format: projects/{project_id}/locations/global/mirroringDeploymentGroups/{deployment_group_id}
        """
        return pulumi.get(self, "mirroring_deployment_groups")

    @mirroring_deployment_groups.setter
    def mirroring_deployment_groups(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "mirroring_deployment_groups", value)

    @_builtins.property
    @pulumi.getter(name="mirroringEndpointGroupType")
    def mirroring_endpoint_group_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output, Beta)
        The type of the mirroring endpoint group this profile is attached to.
        Possible values:
        DIRECT
        BROKER
        """
        return pulumi.get(self, "mirroring_endpoint_group_type")

    @mirroring_endpoint_group_type.setter
    def mirroring_endpoint_group_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mirroring_endpoint_group_type", value)


if not MYPY:
    class SecurityProfileThreatPreventionProfileArgsDict(TypedDict):
        antivirus_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecurityProfileThreatPreventionProfileAntivirusOverrideArgsDict']]]]
        """
        Defines what action to take for antivirus threats per protocol.
        Structure is documented below.
        """
        severity_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecurityProfileThreatPreventionProfileSeverityOverrideArgsDict']]]]
        """
        The configuration for overriding threats actions by severity match.
        Structure is documented below.
        """
        threat_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecurityProfileThreatPreventionProfileThreatOverrideArgsDict']]]]
        """
        The configuration for overriding threats actions by threat id match.
        If a threat is matched both by configuration provided in severity overrides
        and threat overrides, the threat overrides action is applied.
        Structure is documented below.
        """
elif False:
    SecurityProfileThreatPreventionProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileThreatPreventionProfileArgs:
    def __init__(__self__, *,
                 antivirus_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityProfileThreatPreventionProfileAntivirusOverrideArgs']]]] = None,
                 severity_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityProfileThreatPreventionProfileSeverityOverrideArgs']]]] = None,
                 threat_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityProfileThreatPreventionProfileThreatOverrideArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SecurityProfileThreatPreventionProfileAntivirusOverrideArgs']]] antivirus_overrides: Defines what action to take for antivirus threats per protocol.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['SecurityProfileThreatPreventionProfileSeverityOverrideArgs']]] severity_overrides: The configuration for overriding threats actions by severity match.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['SecurityProfileThreatPreventionProfileThreatOverrideArgs']]] threat_overrides: The configuration for overriding threats actions by threat id match.
               If a threat is matched both by configuration provided in severity overrides
               and threat overrides, the threat overrides action is applied.
               Structure is documented below.
        """
        if antivirus_overrides is not None:
            pulumi.set(__self__, "antivirus_overrides", antivirus_overrides)
        if severity_overrides is not None:
            pulumi.set(__self__, "severity_overrides", severity_overrides)
        if threat_overrides is not None:
            pulumi.set(__self__, "threat_overrides", threat_overrides)

    @_builtins.property
    @pulumi.getter(name="antivirusOverrides")
    def antivirus_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecurityProfileThreatPreventionProfileAntivirusOverrideArgs']]]]:
        """
        Defines what action to take for antivirus threats per protocol.
        Structure is documented below.
        """
        return pulumi.get(self, "antivirus_overrides")

    @antivirus_overrides.setter
    def antivirus_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityProfileThreatPreventionProfileAntivirusOverrideArgs']]]]):
        pulumi.set(self, "antivirus_overrides", value)

    @_builtins.property
    @pulumi.getter(name="severityOverrides")
    def severity_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecurityProfileThreatPreventionProfileSeverityOverrideArgs']]]]:
        """
        The configuration for overriding threats actions by severity match.
        Structure is documented below.
        """
        return pulumi.get(self, "severity_overrides")

    @severity_overrides.setter
    def severity_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityProfileThreatPreventionProfileSeverityOverrideArgs']]]]):
        pulumi.set(self, "severity_overrides", value)

    @_builtins.property
    @pulumi.getter(name="threatOverrides")
    def threat_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecurityProfileThreatPreventionProfileThreatOverrideArgs']]]]:
        """
        The configuration for overriding threats actions by threat id match.
        If a threat is matched both by configuration provided in severity overrides
        and threat overrides, the threat overrides action is applied.
        Structure is documented below.
        """
        return pulumi.get(self, "threat_overrides")

    @threat_overrides.setter
    def threat_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityProfileThreatPreventionProfileThreatOverrideArgs']]]]):
        pulumi.set(self, "threat_overrides", value)


if not MYPY:
    class SecurityProfileThreatPreventionProfileAntivirusOverrideArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Threat action override. For some threat types, only a subset of actions applies.
        Possible values are: `ALERT`, `ALLOW`, `DEFAULT_ACTION`, `DENY`.
        """
        protocol: pulumi.Input[_builtins.str]
        """
        Required protocol to match.
        Possible values are: `SMTP`, `SMB`, `POP3`, `IMAP`, `HTTP2`, `HTTP`, `FTP`.
        """
elif False:
    SecurityProfileThreatPreventionProfileAntivirusOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileThreatPreventionProfileAntivirusOverrideArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 protocol: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] action: Threat action override. For some threat types, only a subset of actions applies.
               Possible values are: `ALERT`, `ALLOW`, `DEFAULT_ACTION`, `DENY`.
        :param pulumi.Input[_builtins.str] protocol: Required protocol to match.
               Possible values are: `SMTP`, `SMB`, `POP3`, `IMAP`, `HTTP2`, `HTTP`, `FTP`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "protocol", protocol)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Threat action override. For some threat types, only a subset of actions applies.
        Possible values are: `ALERT`, `ALLOW`, `DEFAULT_ACTION`, `DENY`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> pulumi.Input[_builtins.str]:
        """
        Required protocol to match.
        Possible values are: `SMTP`, `SMB`, `POP3`, `IMAP`, `HTTP2`, `HTTP`, `FTP`.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol", value)


if not MYPY:
    class SecurityProfileThreatPreventionProfileSeverityOverrideArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Threat action override.
        Possible values are: `ALERT`, `ALLOW`, `DEFAULT_ACTION`, `DENY`.
        """
        severity: pulumi.Input[_builtins.str]
        """
        Severity level to match.
        Possible values are: `CRITICAL`, `HIGH`, `INFORMATIONAL`, `LOW`, `MEDIUM`.
        """
elif False:
    SecurityProfileThreatPreventionProfileSeverityOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileThreatPreventionProfileSeverityOverrideArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 severity: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] action: Threat action override.
               Possible values are: `ALERT`, `ALLOW`, `DEFAULT_ACTION`, `DENY`.
        :param pulumi.Input[_builtins.str] severity: Severity level to match.
               Possible values are: `CRITICAL`, `HIGH`, `INFORMATIONAL`, `LOW`, `MEDIUM`.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "severity", severity)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Threat action override.
        Possible values are: `ALERT`, `ALLOW`, `DEFAULT_ACTION`, `DENY`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def severity(self) -> pulumi.Input[_builtins.str]:
        """
        Severity level to match.
        Possible values are: `CRITICAL`, `HIGH`, `INFORMATIONAL`, `LOW`, `MEDIUM`.
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "severity", value)


if not MYPY:
    class SecurityProfileThreatPreventionProfileThreatOverrideArgsDict(TypedDict):
        action: pulumi.Input[_builtins.str]
        """
        Threat action.
        Possible values are: `ALERT`, `ALLOW`, `DEFAULT_ACTION`, `DENY`.
        """
        threat_id: pulumi.Input[_builtins.str]
        """
        Vendor-specific ID of a threat to override.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Type of threat.
        """
elif False:
    SecurityProfileThreatPreventionProfileThreatOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileThreatPreventionProfileThreatOverrideArgs:
    def __init__(__self__, *,
                 action: pulumi.Input[_builtins.str],
                 threat_id: pulumi.Input[_builtins.str],
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] action: Threat action.
               Possible values are: `ALERT`, `ALLOW`, `DEFAULT_ACTION`, `DENY`.
        :param pulumi.Input[_builtins.str] threat_id: Vendor-specific ID of a threat to override.
        :param pulumi.Input[_builtins.str] type: (Output)
               Type of threat.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "threat_id", threat_id)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input[_builtins.str]:
        """
        Threat action.
        Possible values are: `ALERT`, `ALLOW`, `DEFAULT_ACTION`, `DENY`.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter(name="threatId")
    def threat_id(self) -> pulumi.Input[_builtins.str]:
        """
        Vendor-specific ID of a threat to override.
        """
        return pulumi.get(self, "threat_id")

    @threat_id.setter
    def threat_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "threat_id", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Type of threat.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class SecurityProfileUrlFilteringProfileArgsDict(TypedDict):
        url_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecurityProfileUrlFilteringProfileUrlFilterArgsDict']]]]
        """
        The configuration for action to take based on domain name match.
        A domain name would be checked for matching filters through the list in order of highest to lowest priority,
        and the first filter that a domain name matches with is the one whose actions gets applied.
        Structure is documented below.
        """
elif False:
    SecurityProfileUrlFilteringProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileUrlFilteringProfileArgs:
    def __init__(__self__, *,
                 url_filters: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityProfileUrlFilteringProfileUrlFilterArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SecurityProfileUrlFilteringProfileUrlFilterArgs']]] url_filters: The configuration for action to take based on domain name match.
               A domain name would be checked for matching filters through the list in order of highest to lowest priority,
               and the first filter that a domain name matches with is the one whose actions gets applied.
               Structure is documented below.
        """
        if url_filters is not None:
            pulumi.set(__self__, "url_filters", url_filters)

    @_builtins.property
    @pulumi.getter(name="urlFilters")
    def url_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecurityProfileUrlFilteringProfileUrlFilterArgs']]]]:
        """
        The configuration for action to take based on domain name match.
        A domain name would be checked for matching filters through the list in order of highest to lowest priority,
        and the first filter that a domain name matches with is the one whose actions gets applied.
        Structure is documented below.
        """
        return pulumi.get(self, "url_filters")

    @url_filters.setter
    def url_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityProfileUrlFilteringProfileUrlFilterArgs']]]]):
        pulumi.set(self, "url_filters", value)


if not MYPY:
    class SecurityProfileUrlFilteringProfileUrlFilterArgsDict(TypedDict):
        filtering_action: pulumi.Input[_builtins.str]
        """
        The action to take when the filter is applied.
        Possible values are: `ALLOW`, `DENY`.
        """
        priority: pulumi.Input[_builtins.int]
        """
        The priority of the filter within the URL filtering profile.
        Must be an integer from 0 and 2147483647, inclusive. Lower integers indicate higher priorities.
        The priority of a filter must be unique within a URL filtering profile.
        """
        urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of domain matcher strings that a domain name gets compared with to determine if the filter is applicable.
        A domain name must match with at least one of the strings in the list for a filter to be applicable.
        """
elif False:
    SecurityProfileUrlFilteringProfileUrlFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileUrlFilteringProfileUrlFilterArgs:
    def __init__(__self__, *,
                 filtering_action: pulumi.Input[_builtins.str],
                 priority: pulumi.Input[_builtins.int],
                 urls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] filtering_action: The action to take when the filter is applied.
               Possible values are: `ALLOW`, `DENY`.
        :param pulumi.Input[_builtins.int] priority: The priority of the filter within the URL filtering profile.
               Must be an integer from 0 and 2147483647, inclusive. Lower integers indicate higher priorities.
               The priority of a filter must be unique within a URL filtering profile.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] urls: A list of domain matcher strings that a domain name gets compared with to determine if the filter is applicable.
               A domain name must match with at least one of the strings in the list for a filter to be applicable.
        """
        pulumi.set(__self__, "filtering_action", filtering_action)
        pulumi.set(__self__, "priority", priority)
        if urls is not None:
            pulumi.set(__self__, "urls", urls)

    @_builtins.property
    @pulumi.getter(name="filteringAction")
    def filtering_action(self) -> pulumi.Input[_builtins.str]:
        """
        The action to take when the filter is applied.
        Possible values are: `ALLOW`, `DENY`.
        """
        return pulumi.get(self, "filtering_action")

    @filtering_action.setter
    def filtering_action(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "filtering_action", value)

    @_builtins.property
    @pulumi.getter
    def priority(self) -> pulumi.Input[_builtins.int]:
        """
        The priority of the filter within the URL filtering profile.
        Must be an integer from 0 and 2147483647, inclusive. Lower integers indicate higher priorities.
        The priority of a filter must be unique within a URL filtering profile.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "priority", value)

    @_builtins.property
    @pulumi.getter
    def urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of domain matcher strings that a domain name gets compared with to determine if the filter is applicable.
        A domain name must match with at least one of the strings in the list for a filter to be applicable.
        """
        return pulumi.get(self, "urls")

    @urls.setter
    def urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "urls", value)


if not MYPY:
    class ServerTlsPolicyMtlsPolicyArgsDict(TypedDict):
        client_validation_cas: NotRequired[pulumi.Input[Sequence[pulumi.Input['ServerTlsPolicyMtlsPolicyClientValidationCaArgsDict']]]]
        """
        Required if the policy is to be used with Traffic Director. For external HTTPS load balancers it must be empty.
        Defines the mechanism to obtain the Certificate Authority certificate to validate the client certificate.
        Structure is documented below.
        """
        client_validation_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        When the client presents an invalid certificate or no certificate to the load balancer, the clientValidationMode specifies how the client connection is handled.
        Required if the policy is to be used with the external HTTPS load balancing. For Traffic Director it must be empty.
        Possible values are: `CLIENT_VALIDATION_MODE_UNSPECIFIED`, `ALLOW_INVALID_OR_MISSING_CLIENT_CERT`, `REJECT_INVALID`.
        """
        client_validation_trust_config: NotRequired[pulumi.Input[_builtins.str]]
        """
        Reference to the TrustConfig from certificatemanager.googleapis.com namespace.
        If specified, the chain validation will be performed against certificates configured in the given TrustConfig.
        Allowed only if the policy is to be used with external HTTPS load balancers.
        """
elif False:
    ServerTlsPolicyMtlsPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerTlsPolicyMtlsPolicyArgs:
    def __init__(__self__, *,
                 client_validation_cas: Optional[pulumi.Input[Sequence[pulumi.Input['ServerTlsPolicyMtlsPolicyClientValidationCaArgs']]]] = None,
                 client_validation_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 client_validation_trust_config: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ServerTlsPolicyMtlsPolicyClientValidationCaArgs']]] client_validation_cas: Required if the policy is to be used with Traffic Director. For external HTTPS load balancers it must be empty.
               Defines the mechanism to obtain the Certificate Authority certificate to validate the client certificate.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] client_validation_mode: When the client presents an invalid certificate or no certificate to the load balancer, the clientValidationMode specifies how the client connection is handled.
               Required if the policy is to be used with the external HTTPS load balancing. For Traffic Director it must be empty.
               Possible values are: `CLIENT_VALIDATION_MODE_UNSPECIFIED`, `ALLOW_INVALID_OR_MISSING_CLIENT_CERT`, `REJECT_INVALID`.
        :param pulumi.Input[_builtins.str] client_validation_trust_config: Reference to the TrustConfig from certificatemanager.googleapis.com namespace.
               If specified, the chain validation will be performed against certificates configured in the given TrustConfig.
               Allowed only if the policy is to be used with external HTTPS load balancers.
        """
        if client_validation_cas is not None:
            pulumi.set(__self__, "client_validation_cas", client_validation_cas)
        if client_validation_mode is not None:
            pulumi.set(__self__, "client_validation_mode", client_validation_mode)
        if client_validation_trust_config is not None:
            pulumi.set(__self__, "client_validation_trust_config", client_validation_trust_config)

    @_builtins.property
    @pulumi.getter(name="clientValidationCas")
    def client_validation_cas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ServerTlsPolicyMtlsPolicyClientValidationCaArgs']]]]:
        """
        Required if the policy is to be used with Traffic Director. For external HTTPS load balancers it must be empty.
        Defines the mechanism to obtain the Certificate Authority certificate to validate the client certificate.
        Structure is documented below.
        """
        return pulumi.get(self, "client_validation_cas")

    @client_validation_cas.setter
    def client_validation_cas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ServerTlsPolicyMtlsPolicyClientValidationCaArgs']]]]):
        pulumi.set(self, "client_validation_cas", value)

    @_builtins.property
    @pulumi.getter(name="clientValidationMode")
    def client_validation_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When the client presents an invalid certificate or no certificate to the load balancer, the clientValidationMode specifies how the client connection is handled.
        Required if the policy is to be used with the external HTTPS load balancing. For Traffic Director it must be empty.
        Possible values are: `CLIENT_VALIDATION_MODE_UNSPECIFIED`, `ALLOW_INVALID_OR_MISSING_CLIENT_CERT`, `REJECT_INVALID`.
        """
        return pulumi.get(self, "client_validation_mode")

    @client_validation_mode.setter
    def client_validation_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_validation_mode", value)

    @_builtins.property
    @pulumi.getter(name="clientValidationTrustConfig")
    def client_validation_trust_config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Reference to the TrustConfig from certificatemanager.googleapis.com namespace.
        If specified, the chain validation will be performed against certificates configured in the given TrustConfig.
        Allowed only if the policy is to be used with external HTTPS load balancers.
        """
        return pulumi.get(self, "client_validation_trust_config")

    @client_validation_trust_config.setter
    def client_validation_trust_config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_validation_trust_config", value)


if not MYPY:
    class ServerTlsPolicyMtlsPolicyClientValidationCaArgsDict(TypedDict):
        certificate_provider_instance: NotRequired[pulumi.Input['ServerTlsPolicyMtlsPolicyClientValidationCaCertificateProviderInstanceArgsDict']]
        """
        Optional if policy is to be used with Traffic Director. For external HTTPS load balancer must be empty.
        Defines a mechanism to provision server identity (public and private keys). Cannot be combined with allowOpen as a permissive mode that allows both plain text and TLS is not supported.
        Structure is documented below.
        """
        grpc_endpoint: NotRequired[pulumi.Input['ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpointArgsDict']]
        """
        gRPC specific configuration to access the gRPC server to obtain the cert and private key.
        Structure is documented below.
        """
elif False:
    ServerTlsPolicyMtlsPolicyClientValidationCaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerTlsPolicyMtlsPolicyClientValidationCaArgs:
    def __init__(__self__, *,
                 certificate_provider_instance: Optional[pulumi.Input['ServerTlsPolicyMtlsPolicyClientValidationCaCertificateProviderInstanceArgs']] = None,
                 grpc_endpoint: Optional[pulumi.Input['ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpointArgs']] = None):
        """
        :param pulumi.Input['ServerTlsPolicyMtlsPolicyClientValidationCaCertificateProviderInstanceArgs'] certificate_provider_instance: Optional if policy is to be used with Traffic Director. For external HTTPS load balancer must be empty.
               Defines a mechanism to provision server identity (public and private keys). Cannot be combined with allowOpen as a permissive mode that allows both plain text and TLS is not supported.
               Structure is documented below.
        :param pulumi.Input['ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpointArgs'] grpc_endpoint: gRPC specific configuration to access the gRPC server to obtain the cert and private key.
               Structure is documented below.
        """
        if certificate_provider_instance is not None:
            pulumi.set(__self__, "certificate_provider_instance", certificate_provider_instance)
        if grpc_endpoint is not None:
            pulumi.set(__self__, "grpc_endpoint", grpc_endpoint)

    @_builtins.property
    @pulumi.getter(name="certificateProviderInstance")
    def certificate_provider_instance(self) -> Optional[pulumi.Input['ServerTlsPolicyMtlsPolicyClientValidationCaCertificateProviderInstanceArgs']]:
        """
        Optional if policy is to be used with Traffic Director. For external HTTPS load balancer must be empty.
        Defines a mechanism to provision server identity (public and private keys). Cannot be combined with allowOpen as a permissive mode that allows both plain text and TLS is not supported.
        Structure is documented below.
        """
        return pulumi.get(self, "certificate_provider_instance")

    @certificate_provider_instance.setter
    def certificate_provider_instance(self, value: Optional[pulumi.Input['ServerTlsPolicyMtlsPolicyClientValidationCaCertificateProviderInstanceArgs']]):
        pulumi.set(self, "certificate_provider_instance", value)

    @_builtins.property
    @pulumi.getter(name="grpcEndpoint")
    def grpc_endpoint(self) -> Optional[pulumi.Input['ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpointArgs']]:
        """
        gRPC specific configuration to access the gRPC server to obtain the cert and private key.
        Structure is documented below.
        """
        return pulumi.get(self, "grpc_endpoint")

    @grpc_endpoint.setter
    def grpc_endpoint(self, value: Optional[pulumi.Input['ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpointArgs']]):
        pulumi.set(self, "grpc_endpoint", value)


if not MYPY:
    class ServerTlsPolicyMtlsPolicyClientValidationCaCertificateProviderInstanceArgsDict(TypedDict):
        plugin_instance: pulumi.Input[_builtins.str]
        """
        Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
        """
elif False:
    ServerTlsPolicyMtlsPolicyClientValidationCaCertificateProviderInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerTlsPolicyMtlsPolicyClientValidationCaCertificateProviderInstanceArgs:
    def __init__(__self__, *,
                 plugin_instance: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] plugin_instance: Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
        """
        pulumi.set(__self__, "plugin_instance", plugin_instance)

    @_builtins.property
    @pulumi.getter(name="pluginInstance")
    def plugin_instance(self) -> pulumi.Input[_builtins.str]:
        """
        Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
        """
        return pulumi.get(self, "plugin_instance")

    @plugin_instance.setter
    def plugin_instance(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "plugin_instance", value)


if not MYPY:
    class ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpointArgsDict(TypedDict):
        target_uri: pulumi.Input[_builtins.str]
        """
        The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
        """
elif False:
    ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerTlsPolicyMtlsPolicyClientValidationCaGrpcEndpointArgs:
    def __init__(__self__, *,
                 target_uri: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] target_uri: The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
        """
        pulumi.set(__self__, "target_uri", target_uri)

    @_builtins.property
    @pulumi.getter(name="targetUri")
    def target_uri(self) -> pulumi.Input[_builtins.str]:
        """
        The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
        """
        return pulumi.get(self, "target_uri")

    @target_uri.setter
    def target_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_uri", value)


if not MYPY:
    class ServerTlsPolicyServerCertificateArgsDict(TypedDict):
        certificate_provider_instance: NotRequired[pulumi.Input['ServerTlsPolicyServerCertificateCertificateProviderInstanceArgsDict']]
        """
        Optional if policy is to be used with Traffic Director. For external HTTPS load balancer must be empty.
        Defines a mechanism to provision server identity (public and private keys). Cannot be combined with allowOpen as a permissive mode that allows both plain text and TLS is not supported.
        Structure is documented below.
        """
        grpc_endpoint: NotRequired[pulumi.Input['ServerTlsPolicyServerCertificateGrpcEndpointArgsDict']]
        """
        gRPC specific configuration to access the gRPC server to obtain the cert and private key.
        Structure is documented below.
        """
elif False:
    ServerTlsPolicyServerCertificateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerTlsPolicyServerCertificateArgs:
    def __init__(__self__, *,
                 certificate_provider_instance: Optional[pulumi.Input['ServerTlsPolicyServerCertificateCertificateProviderInstanceArgs']] = None,
                 grpc_endpoint: Optional[pulumi.Input['ServerTlsPolicyServerCertificateGrpcEndpointArgs']] = None):
        """
        :param pulumi.Input['ServerTlsPolicyServerCertificateCertificateProviderInstanceArgs'] certificate_provider_instance: Optional if policy is to be used with Traffic Director. For external HTTPS load balancer must be empty.
               Defines a mechanism to provision server identity (public and private keys). Cannot be combined with allowOpen as a permissive mode that allows both plain text and TLS is not supported.
               Structure is documented below.
        :param pulumi.Input['ServerTlsPolicyServerCertificateGrpcEndpointArgs'] grpc_endpoint: gRPC specific configuration to access the gRPC server to obtain the cert and private key.
               Structure is documented below.
        """
        if certificate_provider_instance is not None:
            pulumi.set(__self__, "certificate_provider_instance", certificate_provider_instance)
        if grpc_endpoint is not None:
            pulumi.set(__self__, "grpc_endpoint", grpc_endpoint)

    @_builtins.property
    @pulumi.getter(name="certificateProviderInstance")
    def certificate_provider_instance(self) -> Optional[pulumi.Input['ServerTlsPolicyServerCertificateCertificateProviderInstanceArgs']]:
        """
        Optional if policy is to be used with Traffic Director. For external HTTPS load balancer must be empty.
        Defines a mechanism to provision server identity (public and private keys). Cannot be combined with allowOpen as a permissive mode that allows both plain text and TLS is not supported.
        Structure is documented below.
        """
        return pulumi.get(self, "certificate_provider_instance")

    @certificate_provider_instance.setter
    def certificate_provider_instance(self, value: Optional[pulumi.Input['ServerTlsPolicyServerCertificateCertificateProviderInstanceArgs']]):
        pulumi.set(self, "certificate_provider_instance", value)

    @_builtins.property
    @pulumi.getter(name="grpcEndpoint")
    def grpc_endpoint(self) -> Optional[pulumi.Input['ServerTlsPolicyServerCertificateGrpcEndpointArgs']]:
        """
        gRPC specific configuration to access the gRPC server to obtain the cert and private key.
        Structure is documented below.
        """
        return pulumi.get(self, "grpc_endpoint")

    @grpc_endpoint.setter
    def grpc_endpoint(self, value: Optional[pulumi.Input['ServerTlsPolicyServerCertificateGrpcEndpointArgs']]):
        pulumi.set(self, "grpc_endpoint", value)


if not MYPY:
    class ServerTlsPolicyServerCertificateCertificateProviderInstanceArgsDict(TypedDict):
        plugin_instance: pulumi.Input[_builtins.str]
        """
        Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
        """
elif False:
    ServerTlsPolicyServerCertificateCertificateProviderInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerTlsPolicyServerCertificateCertificateProviderInstanceArgs:
    def __init__(__self__, *,
                 plugin_instance: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] plugin_instance: Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
        """
        pulumi.set(__self__, "plugin_instance", plugin_instance)

    @_builtins.property
    @pulumi.getter(name="pluginInstance")
    def plugin_instance(self) -> pulumi.Input[_builtins.str]:
        """
        Plugin instance name, used to locate and load CertificateProvider instance configuration. Set to "google_cloud_private_spiffe" to use Certificate Authority Service certificate provider instance.
        """
        return pulumi.get(self, "plugin_instance")

    @plugin_instance.setter
    def plugin_instance(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "plugin_instance", value)


if not MYPY:
    class ServerTlsPolicyServerCertificateGrpcEndpointArgsDict(TypedDict):
        target_uri: pulumi.Input[_builtins.str]
        """
        The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
        """
elif False:
    ServerTlsPolicyServerCertificateGrpcEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServerTlsPolicyServerCertificateGrpcEndpointArgs:
    def __init__(__self__, *,
                 target_uri: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] target_uri: The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
        """
        pulumi.set(__self__, "target_uri", target_uri)

    @_builtins.property
    @pulumi.getter(name="targetUri")
    def target_uri(self) -> pulumi.Input[_builtins.str]:
        """
        The target URI of the gRPC endpoint. Only UDS path is supported, and should start with "unix:".
        """
        return pulumi.get(self, "target_uri")

    @target_uri.setter
    def target_uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_uri", value)


