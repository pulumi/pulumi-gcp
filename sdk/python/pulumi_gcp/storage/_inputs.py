# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'BatchOperationsJobBucketListArgs',
    'BatchOperationsJobBucketListArgsDict',
    'BatchOperationsJobBucketListBucketsArgs',
    'BatchOperationsJobBucketListBucketsArgsDict',
    'BatchOperationsJobBucketListBucketsManifestArgs',
    'BatchOperationsJobBucketListBucketsManifestArgsDict',
    'BatchOperationsJobBucketListBucketsPrefixListArgs',
    'BatchOperationsJobBucketListBucketsPrefixListArgsDict',
    'BatchOperationsJobDeleteObjectArgs',
    'BatchOperationsJobDeleteObjectArgsDict',
    'BatchOperationsJobPutMetadataArgs',
    'BatchOperationsJobPutMetadataArgsDict',
    'BatchOperationsJobPutObjectHoldArgs',
    'BatchOperationsJobPutObjectHoldArgsDict',
    'BatchOperationsJobRewriteObjectArgs',
    'BatchOperationsJobRewriteObjectArgsDict',
    'BucketAutoclassArgs',
    'BucketAutoclassArgsDict',
    'BucketCorArgs',
    'BucketCorArgsDict',
    'BucketCustomPlacementConfigArgs',
    'BucketCustomPlacementConfigArgsDict',
    'BucketEncryptionArgs',
    'BucketEncryptionArgsDict',
    'BucketHierarchicalNamespaceArgs',
    'BucketHierarchicalNamespaceArgsDict',
    'BucketIAMBindingConditionArgs',
    'BucketIAMBindingConditionArgsDict',
    'BucketIAMMemberConditionArgs',
    'BucketIAMMemberConditionArgsDict',
    'BucketIpFilterArgs',
    'BucketIpFilterArgsDict',
    'BucketIpFilterPublicNetworkSourceArgs',
    'BucketIpFilterPublicNetworkSourceArgsDict',
    'BucketIpFilterVpcNetworkSourceArgs',
    'BucketIpFilterVpcNetworkSourceArgsDict',
    'BucketLifecycleRuleArgs',
    'BucketLifecycleRuleArgsDict',
    'BucketLifecycleRuleActionArgs',
    'BucketLifecycleRuleActionArgsDict',
    'BucketLifecycleRuleConditionArgs',
    'BucketLifecycleRuleConditionArgsDict',
    'BucketLoggingArgs',
    'BucketLoggingArgsDict',
    'BucketObjectContextsArgs',
    'BucketObjectContextsArgsDict',
    'BucketObjectContextsCustomArgs',
    'BucketObjectContextsCustomArgsDict',
    'BucketObjectCustomerEncryptionArgs',
    'BucketObjectCustomerEncryptionArgsDict',
    'BucketObjectRetentionArgs',
    'BucketObjectRetentionArgsDict',
    'BucketRetentionPolicyArgs',
    'BucketRetentionPolicyArgsDict',
    'BucketSoftDeletePolicyArgs',
    'BucketSoftDeletePolicyArgsDict',
    'BucketVersioningArgs',
    'BucketVersioningArgsDict',
    'BucketWebsiteArgs',
    'BucketWebsiteArgsDict',
    'ControlFolderIntelligenceConfigEffectiveIntelligenceConfigArgs',
    'ControlFolderIntelligenceConfigEffectiveIntelligenceConfigArgsDict',
    'ControlFolderIntelligenceConfigFilterArgs',
    'ControlFolderIntelligenceConfigFilterArgsDict',
    'ControlFolderIntelligenceConfigFilterExcludedCloudStorageBucketsArgs',
    'ControlFolderIntelligenceConfigFilterExcludedCloudStorageBucketsArgsDict',
    'ControlFolderIntelligenceConfigFilterExcludedCloudStorageLocationsArgs',
    'ControlFolderIntelligenceConfigFilterExcludedCloudStorageLocationsArgsDict',
    'ControlFolderIntelligenceConfigFilterIncludedCloudStorageBucketsArgs',
    'ControlFolderIntelligenceConfigFilterIncludedCloudStorageBucketsArgsDict',
    'ControlFolderIntelligenceConfigFilterIncludedCloudStorageLocationsArgs',
    'ControlFolderIntelligenceConfigFilterIncludedCloudStorageLocationsArgsDict',
    'ControlFolderIntelligenceConfigTrialConfigArgs',
    'ControlFolderIntelligenceConfigTrialConfigArgsDict',
    'ControlOrganizationIntelligenceConfigEffectiveIntelligenceConfigArgs',
    'ControlOrganizationIntelligenceConfigEffectiveIntelligenceConfigArgsDict',
    'ControlOrganizationIntelligenceConfigFilterArgs',
    'ControlOrganizationIntelligenceConfigFilterArgsDict',
    'ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageBucketsArgs',
    'ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageBucketsArgsDict',
    'ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageLocationsArgs',
    'ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageLocationsArgsDict',
    'ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageBucketsArgs',
    'ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageBucketsArgsDict',
    'ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageLocationsArgs',
    'ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageLocationsArgsDict',
    'ControlOrganizationIntelligenceConfigTrialConfigArgs',
    'ControlOrganizationIntelligenceConfigTrialConfigArgsDict',
    'ControlProjectIntelligenceConfigEffectiveIntelligenceConfigArgs',
    'ControlProjectIntelligenceConfigEffectiveIntelligenceConfigArgsDict',
    'ControlProjectIntelligenceConfigFilterArgs',
    'ControlProjectIntelligenceConfigFilterArgsDict',
    'ControlProjectIntelligenceConfigFilterExcludedCloudStorageBucketsArgs',
    'ControlProjectIntelligenceConfigFilterExcludedCloudStorageBucketsArgsDict',
    'ControlProjectIntelligenceConfigFilterExcludedCloudStorageLocationsArgs',
    'ControlProjectIntelligenceConfigFilterExcludedCloudStorageLocationsArgsDict',
    'ControlProjectIntelligenceConfigFilterIncludedCloudStorageBucketsArgs',
    'ControlProjectIntelligenceConfigFilterIncludedCloudStorageBucketsArgsDict',
    'ControlProjectIntelligenceConfigFilterIncludedCloudStorageLocationsArgs',
    'ControlProjectIntelligenceConfigFilterIncludedCloudStorageLocationsArgsDict',
    'ControlProjectIntelligenceConfigTrialConfigArgs',
    'ControlProjectIntelligenceConfigTrialConfigArgsDict',
    'DefaultObjectAccessControlProjectTeamArgs',
    'DefaultObjectAccessControlProjectTeamArgsDict',
    'InsightsDatasetConfigExcludeCloudStorageBucketsArgs',
    'InsightsDatasetConfigExcludeCloudStorageBucketsArgsDict',
    'InsightsDatasetConfigExcludeCloudStorageBucketsCloudStorageBucketArgs',
    'InsightsDatasetConfigExcludeCloudStorageBucketsCloudStorageBucketArgsDict',
    'InsightsDatasetConfigExcludeCloudStorageLocationsArgs',
    'InsightsDatasetConfigExcludeCloudStorageLocationsArgsDict',
    'InsightsDatasetConfigIdentityArgs',
    'InsightsDatasetConfigIdentityArgsDict',
    'InsightsDatasetConfigIncludeCloudStorageBucketsArgs',
    'InsightsDatasetConfigIncludeCloudStorageBucketsArgsDict',
    'InsightsDatasetConfigIncludeCloudStorageBucketsCloudStorageBucketArgs',
    'InsightsDatasetConfigIncludeCloudStorageBucketsCloudStorageBucketArgsDict',
    'InsightsDatasetConfigIncludeCloudStorageLocationsArgs',
    'InsightsDatasetConfigIncludeCloudStorageLocationsArgsDict',
    'InsightsDatasetConfigLinkArgs',
    'InsightsDatasetConfigLinkArgsDict',
    'InsightsDatasetConfigSourceFoldersArgs',
    'InsightsDatasetConfigSourceFoldersArgsDict',
    'InsightsDatasetConfigSourceProjectsArgs',
    'InsightsDatasetConfigSourceProjectsArgsDict',
    'InsightsReportConfigCsvOptionsArgs',
    'InsightsReportConfigCsvOptionsArgsDict',
    'InsightsReportConfigFrequencyOptionsArgs',
    'InsightsReportConfigFrequencyOptionsArgsDict',
    'InsightsReportConfigFrequencyOptionsEndDateArgs',
    'InsightsReportConfigFrequencyOptionsEndDateArgsDict',
    'InsightsReportConfigFrequencyOptionsStartDateArgs',
    'InsightsReportConfigFrequencyOptionsStartDateArgsDict',
    'InsightsReportConfigObjectMetadataReportOptionsArgs',
    'InsightsReportConfigObjectMetadataReportOptionsArgsDict',
    'InsightsReportConfigObjectMetadataReportOptionsStorageDestinationOptionsArgs',
    'InsightsReportConfigObjectMetadataReportOptionsStorageDestinationOptionsArgsDict',
    'InsightsReportConfigObjectMetadataReportOptionsStorageFiltersArgs',
    'InsightsReportConfigObjectMetadataReportOptionsStorageFiltersArgsDict',
    'InsightsReportConfigParquetOptionsArgs',
    'InsightsReportConfigParquetOptionsArgsDict',
    'ManagedFolderIamBindingConditionArgs',
    'ManagedFolderIamBindingConditionArgsDict',
    'ManagedFolderIamMemberConditionArgs',
    'ManagedFolderIamMemberConditionArgsDict',
    'ObjectAccessControlProjectTeamArgs',
    'ObjectAccessControlProjectTeamArgsDict',
    'TransferAgentPoolBandwidthLimitArgs',
    'TransferAgentPoolBandwidthLimitArgsDict',
    'TransferJobEventStreamArgs',
    'TransferJobEventStreamArgsDict',
    'TransferJobLoggingConfigArgs',
    'TransferJobLoggingConfigArgsDict',
    'TransferJobNotificationConfigArgs',
    'TransferJobNotificationConfigArgsDict',
    'TransferJobReplicationSpecArgs',
    'TransferJobReplicationSpecArgsDict',
    'TransferJobReplicationSpecGcsDataSinkArgs',
    'TransferJobReplicationSpecGcsDataSinkArgsDict',
    'TransferJobReplicationSpecGcsDataSourceArgs',
    'TransferJobReplicationSpecGcsDataSourceArgsDict',
    'TransferJobReplicationSpecObjectConditionsArgs',
    'TransferJobReplicationSpecObjectConditionsArgsDict',
    'TransferJobReplicationSpecTransferOptionsArgs',
    'TransferJobReplicationSpecTransferOptionsArgsDict',
    'TransferJobReplicationSpecTransferOptionsMetadataOptionsArgs',
    'TransferJobReplicationSpecTransferOptionsMetadataOptionsArgsDict',
    'TransferJobScheduleArgs',
    'TransferJobScheduleArgsDict',
    'TransferJobScheduleScheduleEndDateArgs',
    'TransferJobScheduleScheduleEndDateArgsDict',
    'TransferJobScheduleScheduleStartDateArgs',
    'TransferJobScheduleScheduleStartDateArgsDict',
    'TransferJobScheduleStartTimeOfDayArgs',
    'TransferJobScheduleStartTimeOfDayArgsDict',
    'TransferJobTransferSpecArgs',
    'TransferJobTransferSpecArgsDict',
    'TransferJobTransferSpecAwsS3CompatibleDataSourceArgs',
    'TransferJobTransferSpecAwsS3CompatibleDataSourceArgsDict',
    'TransferJobTransferSpecAwsS3CompatibleDataSourceS3MetadataArgs',
    'TransferJobTransferSpecAwsS3CompatibleDataSourceS3MetadataArgsDict',
    'TransferJobTransferSpecAwsS3DataSourceArgs',
    'TransferJobTransferSpecAwsS3DataSourceArgsDict',
    'TransferJobTransferSpecAwsS3DataSourceAwsAccessKeyArgs',
    'TransferJobTransferSpecAwsS3DataSourceAwsAccessKeyArgsDict',
    'TransferJobTransferSpecAzureBlobStorageDataSourceArgs',
    'TransferJobTransferSpecAzureBlobStorageDataSourceArgsDict',
    'TransferJobTransferSpecAzureBlobStorageDataSourceAzureCredentialsArgs',
    'TransferJobTransferSpecAzureBlobStorageDataSourceAzureCredentialsArgsDict',
    'TransferJobTransferSpecAzureBlobStorageDataSourceFederatedIdentityConfigArgs',
    'TransferJobTransferSpecAzureBlobStorageDataSourceFederatedIdentityConfigArgsDict',
    'TransferJobTransferSpecGcsDataSinkArgs',
    'TransferJobTransferSpecGcsDataSinkArgsDict',
    'TransferJobTransferSpecGcsDataSourceArgs',
    'TransferJobTransferSpecGcsDataSourceArgsDict',
    'TransferJobTransferSpecHdfsDataSourceArgs',
    'TransferJobTransferSpecHdfsDataSourceArgsDict',
    'TransferJobTransferSpecHttpDataSourceArgs',
    'TransferJobTransferSpecHttpDataSourceArgsDict',
    'TransferJobTransferSpecObjectConditionsArgs',
    'TransferJobTransferSpecObjectConditionsArgsDict',
    'TransferJobTransferSpecPosixDataSinkArgs',
    'TransferJobTransferSpecPosixDataSinkArgsDict',
    'TransferJobTransferSpecPosixDataSourceArgs',
    'TransferJobTransferSpecPosixDataSourceArgsDict',
    'TransferJobTransferSpecTransferManifestArgs',
    'TransferJobTransferSpecTransferManifestArgsDict',
    'TransferJobTransferSpecTransferOptionsArgs',
    'TransferJobTransferSpecTransferOptionsArgsDict',
    'TransferJobTransferSpecTransferOptionsMetadataOptionsArgs',
    'TransferJobTransferSpecTransferOptionsMetadataOptionsArgsDict',
]

MYPY = False

if not MYPY:
    class BatchOperationsJobBucketListArgsDict(TypedDict):
        buckets: pulumi.Input['BatchOperationsJobBucketListBucketsArgsDict']
        """
        List of buckets and their objects to be transformed.
        Structure is documented below.
        """
elif False:
    BatchOperationsJobBucketListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchOperationsJobBucketListArgs:
    def __init__(__self__, *,
                 buckets: pulumi.Input['BatchOperationsJobBucketListBucketsArgs']):
        """
        :param pulumi.Input['BatchOperationsJobBucketListBucketsArgs'] buckets: List of buckets and their objects to be transformed.
               Structure is documented below.
        """
        pulumi.set(__self__, "buckets", buckets)

    @_builtins.property
    @pulumi.getter
    def buckets(self) -> pulumi.Input['BatchOperationsJobBucketListBucketsArgs']:
        """
        List of buckets and their objects to be transformed.
        Structure is documented below.
        """
        return pulumi.get(self, "buckets")

    @buckets.setter
    def buckets(self, value: pulumi.Input['BatchOperationsJobBucketListBucketsArgs']):
        pulumi.set(self, "buckets", value)


if not MYPY:
    class BatchOperationsJobBucketListBucketsArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        Bucket name for the objects to be transformed.
        """
        manifest: NotRequired[pulumi.Input['BatchOperationsJobBucketListBucketsManifestArgsDict']]
        """
        contain the manifest source file that is a CSV file in a Google Cloud Storage bucket.
        Structure is documented below.
        """
        prefix_list: NotRequired[pulumi.Input['BatchOperationsJobBucketListBucketsPrefixListArgsDict']]
        """
        Specifies objects matching a prefix set.
        Structure is documented below.
        """
elif False:
    BatchOperationsJobBucketListBucketsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchOperationsJobBucketListBucketsArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 manifest: Optional[pulumi.Input['BatchOperationsJobBucketListBucketsManifestArgs']] = None,
                 prefix_list: Optional[pulumi.Input['BatchOperationsJobBucketListBucketsPrefixListArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: Bucket name for the objects to be transformed.
        :param pulumi.Input['BatchOperationsJobBucketListBucketsManifestArgs'] manifest: contain the manifest source file that is a CSV file in a Google Cloud Storage bucket.
               Structure is documented below.
        :param pulumi.Input['BatchOperationsJobBucketListBucketsPrefixListArgs'] prefix_list: Specifies objects matching a prefix set.
               Structure is documented below.
        """
        pulumi.set(__self__, "bucket", bucket)
        if manifest is not None:
            pulumi.set(__self__, "manifest", manifest)
        if prefix_list is not None:
            pulumi.set(__self__, "prefix_list", prefix_list)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        Bucket name for the objects to be transformed.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter
    def manifest(self) -> Optional[pulumi.Input['BatchOperationsJobBucketListBucketsManifestArgs']]:
        """
        contain the manifest source file that is a CSV file in a Google Cloud Storage bucket.
        Structure is documented below.
        """
        return pulumi.get(self, "manifest")

    @manifest.setter
    def manifest(self, value: Optional[pulumi.Input['BatchOperationsJobBucketListBucketsManifestArgs']]):
        pulumi.set(self, "manifest", value)

    @_builtins.property
    @pulumi.getter(name="prefixList")
    def prefix_list(self) -> Optional[pulumi.Input['BatchOperationsJobBucketListBucketsPrefixListArgs']]:
        """
        Specifies objects matching a prefix set.
        Structure is documented below.
        """
        return pulumi.get(self, "prefix_list")

    @prefix_list.setter
    def prefix_list(self, value: Optional[pulumi.Input['BatchOperationsJobBucketListBucketsPrefixListArgs']]):
        pulumi.set(self, "prefix_list", value)


if not MYPY:
    class BatchOperationsJobBucketListBucketsManifestArgsDict(TypedDict):
        manifest_location: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies objects in a manifest file.
        """
elif False:
    BatchOperationsJobBucketListBucketsManifestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchOperationsJobBucketListBucketsManifestArgs:
    def __init__(__self__, *,
                 manifest_location: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] manifest_location: Specifies objects in a manifest file.
        """
        if manifest_location is not None:
            pulumi.set(__self__, "manifest_location", manifest_location)

    @_builtins.property
    @pulumi.getter(name="manifestLocation")
    def manifest_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies objects in a manifest file.
        """
        return pulumi.get(self, "manifest_location")

    @manifest_location.setter
    def manifest_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "manifest_location", value)


if not MYPY:
    class BatchOperationsJobBucketListBucketsPrefixListArgsDict(TypedDict):
        included_object_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Optional)
        """
elif False:
    BatchOperationsJobBucketListBucketsPrefixListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchOperationsJobBucketListBucketsPrefixListArgs:
    def __init__(__self__, *,
                 included_object_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] included_object_prefixes: (Optional)
        """
        if included_object_prefixes is not None:
            pulumi.set(__self__, "included_object_prefixes", included_object_prefixes)

    @_builtins.property
    @pulumi.getter(name="includedObjectPrefixes")
    def included_object_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Optional)
        """
        return pulumi.get(self, "included_object_prefixes")

    @included_object_prefixes.setter
    def included_object_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "included_object_prefixes", value)


if not MYPY:
    class BatchOperationsJobDeleteObjectArgsDict(TypedDict):
        permanent_object_deletion_enabled: pulumi.Input[_builtins.bool]
        """
        enable flag to permanently delete object and all object versions if versioning is enabled on bucket.
        """
elif False:
    BatchOperationsJobDeleteObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchOperationsJobDeleteObjectArgs:
    def __init__(__self__, *,
                 permanent_object_deletion_enabled: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] permanent_object_deletion_enabled: enable flag to permanently delete object and all object versions if versioning is enabled on bucket.
        """
        pulumi.set(__self__, "permanent_object_deletion_enabled", permanent_object_deletion_enabled)

    @_builtins.property
    @pulumi.getter(name="permanentObjectDeletionEnabled")
    def permanent_object_deletion_enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        enable flag to permanently delete object and all object versions if versioning is enabled on bucket.
        """
        return pulumi.get(self, "permanent_object_deletion_enabled")

    @permanent_object_deletion_enabled.setter
    def permanent_object_deletion_enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "permanent_object_deletion_enabled", value)


if not MYPY:
    class BatchOperationsJobPutMetadataArgsDict(TypedDict):
        cache_control: NotRequired[pulumi.Input[_builtins.str]]
        """
        Cache-Control directive to specify caching behavior of object data. If omitted and object is accessible to all anonymous users, the default will be public, max-age=3600
        """
        content_disposition: NotRequired[pulumi.Input[_builtins.str]]
        """
        Content-Disposition of the object data.
        """
        content_encoding: NotRequired[pulumi.Input[_builtins.str]]
        """
        Content Encoding of the object data.
        """
        content_language: NotRequired[pulumi.Input[_builtins.str]]
        """
        Content-Language of the object data.
        """
        content_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Content-Type of the object data.
        """
        custom_metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        User-provided metadata, in key/value pairs.
        """
        custom_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Updates the objects fixed custom time metadata.
        """
elif False:
    BatchOperationsJobPutMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchOperationsJobPutMetadataArgs:
    def __init__(__self__, *,
                 cache_control: Optional[pulumi.Input[_builtins.str]] = None,
                 content_disposition: Optional[pulumi.Input[_builtins.str]] = None,
                 content_encoding: Optional[pulumi.Input[_builtins.str]] = None,
                 content_language: Optional[pulumi.Input[_builtins.str]] = None,
                 content_type: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 custom_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cache_control: Cache-Control directive to specify caching behavior of object data. If omitted and object is accessible to all anonymous users, the default will be public, max-age=3600
        :param pulumi.Input[_builtins.str] content_disposition: Content-Disposition of the object data.
        :param pulumi.Input[_builtins.str] content_encoding: Content Encoding of the object data.
        :param pulumi.Input[_builtins.str] content_language: Content-Language of the object data.
        :param pulumi.Input[_builtins.str] content_type: Content-Type of the object data.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] custom_metadata: User-provided metadata, in key/value pairs.
        :param pulumi.Input[_builtins.str] custom_time: Updates the objects fixed custom time metadata.
        """
        if cache_control is not None:
            pulumi.set(__self__, "cache_control", cache_control)
        if content_disposition is not None:
            pulumi.set(__self__, "content_disposition", content_disposition)
        if content_encoding is not None:
            pulumi.set(__self__, "content_encoding", content_encoding)
        if content_language is not None:
            pulumi.set(__self__, "content_language", content_language)
        if content_type is not None:
            pulumi.set(__self__, "content_type", content_type)
        if custom_metadata is not None:
            pulumi.set(__self__, "custom_metadata", custom_metadata)
        if custom_time is not None:
            pulumi.set(__self__, "custom_time", custom_time)

    @_builtins.property
    @pulumi.getter(name="cacheControl")
    def cache_control(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Cache-Control directive to specify caching behavior of object data. If omitted and object is accessible to all anonymous users, the default will be public, max-age=3600
        """
        return pulumi.get(self, "cache_control")

    @cache_control.setter
    def cache_control(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cache_control", value)

    @_builtins.property
    @pulumi.getter(name="contentDisposition")
    def content_disposition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Content-Disposition of the object data.
        """
        return pulumi.get(self, "content_disposition")

    @content_disposition.setter
    def content_disposition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_disposition", value)

    @_builtins.property
    @pulumi.getter(name="contentEncoding")
    def content_encoding(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Content Encoding of the object data.
        """
        return pulumi.get(self, "content_encoding")

    @content_encoding.setter
    def content_encoding(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_encoding", value)

    @_builtins.property
    @pulumi.getter(name="contentLanguage")
    def content_language(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Content-Language of the object data.
        """
        return pulumi.get(self, "content_language")

    @content_language.setter
    def content_language(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_language", value)

    @_builtins.property
    @pulumi.getter(name="contentType")
    def content_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Content-Type of the object data.
        """
        return pulumi.get(self, "content_type")

    @content_type.setter
    def content_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "content_type", value)

    @_builtins.property
    @pulumi.getter(name="customMetadata")
    def custom_metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        User-provided metadata, in key/value pairs.
        """
        return pulumi.get(self, "custom_metadata")

    @custom_metadata.setter
    def custom_metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "custom_metadata", value)

    @_builtins.property
    @pulumi.getter(name="customTime")
    def custom_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Updates the objects fixed custom time metadata.
        """
        return pulumi.get(self, "custom_time")

    @custom_time.setter
    def custom_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_time", value)


if not MYPY:
    class BatchOperationsJobPutObjectHoldArgsDict(TypedDict):
        event_based_hold: NotRequired[pulumi.Input[_builtins.str]]
        """
        set/unset to update event based hold for objects.
        """
        temporary_hold: NotRequired[pulumi.Input[_builtins.str]]
        """
        set/unset to update temporary based hold for objects.
        """
elif False:
    BatchOperationsJobPutObjectHoldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchOperationsJobPutObjectHoldArgs:
    def __init__(__self__, *,
                 event_based_hold: Optional[pulumi.Input[_builtins.str]] = None,
                 temporary_hold: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] event_based_hold: set/unset to update event based hold for objects.
        :param pulumi.Input[_builtins.str] temporary_hold: set/unset to update temporary based hold for objects.
        """
        if event_based_hold is not None:
            pulumi.set(__self__, "event_based_hold", event_based_hold)
        if temporary_hold is not None:
            pulumi.set(__self__, "temporary_hold", temporary_hold)

    @_builtins.property
    @pulumi.getter(name="eventBasedHold")
    def event_based_hold(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        set/unset to update event based hold for objects.
        """
        return pulumi.get(self, "event_based_hold")

    @event_based_hold.setter
    def event_based_hold(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_based_hold", value)

    @_builtins.property
    @pulumi.getter(name="temporaryHold")
    def temporary_hold(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        set/unset to update temporary based hold for objects.
        """
        return pulumi.get(self, "temporary_hold")

    @temporary_hold.setter
    def temporary_hold(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "temporary_hold", value)


if not MYPY:
    class BatchOperationsJobRewriteObjectArgsDict(TypedDict):
        kms_key: pulumi.Input[_builtins.str]
        """
        valid kms key
        """
elif False:
    BatchOperationsJobRewriteObjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BatchOperationsJobRewriteObjectArgs:
    def __init__(__self__, *,
                 kms_key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] kms_key: valid kms key
        """
        pulumi.set(__self__, "kms_key", kms_key)

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> pulumi.Input[_builtins.str]:
        """
        valid kms key
        """
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kms_key", value)


if not MYPY:
    class BucketAutoclassArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        While set to `true`, autoclass automatically transitions objects in your bucket to appropriate storage classes based on each object's access pattern.
        """
        terminal_storage_class: NotRequired[pulumi.Input[_builtins.str]]
        """
        The storage class that objects in the bucket eventually transition to if they are not read for a certain length of time. Supported values include: `NEARLINE`, `ARCHIVE`.
        """
elif False:
    BucketAutoclassArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketAutoclassArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 terminal_storage_class: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: While set to `true`, autoclass automatically transitions objects in your bucket to appropriate storage classes based on each object's access pattern.
        :param pulumi.Input[_builtins.str] terminal_storage_class: The storage class that objects in the bucket eventually transition to if they are not read for a certain length of time. Supported values include: `NEARLINE`, `ARCHIVE`.
        """
        pulumi.set(__self__, "enabled", enabled)
        if terminal_storage_class is not None:
            pulumi.set(__self__, "terminal_storage_class", terminal_storage_class)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        While set to `true`, autoclass automatically transitions objects in your bucket to appropriate storage classes based on each object's access pattern.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="terminalStorageClass")
    def terminal_storage_class(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The storage class that objects in the bucket eventually transition to if they are not read for a certain length of time. Supported values include: `NEARLINE`, `ARCHIVE`.
        """
        return pulumi.get(self, "terminal_storage_class")

    @terminal_storage_class.setter
    def terminal_storage_class(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "terminal_storage_class", value)


if not MYPY:
    class BucketCorArgsDict(TypedDict):
        max_age_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The value, in seconds, to return in the [Access-Control-Max-Age header](https://www.w3.org/TR/cors/#access-control-max-age-response-header) used in preflight responses.
        """
        methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of HTTP methods on which to include CORS response headers, (GET, OPTIONS, POST, etc) Note: "*" is permitted in the list of methods, and means "any method".
        """
        origins: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of [Origins](https://tools.ietf.org/html/rfc6454) eligible to receive CORS response headers. Note: "*" is permitted in the list of origins, and means "any Origin".
        """
        response_headers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of HTTP headers other than the [simple response headers](https://www.w3.org/TR/cors/#simple-response-header) to give permission for the user-agent to share across domains.
        """
elif False:
    BucketCorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketCorArgs:
    def __init__(__self__, *,
                 max_age_seconds: Optional[pulumi.Input[_builtins.int]] = None,
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 origins: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 response_headers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.int] max_age_seconds: The value, in seconds, to return in the [Access-Control-Max-Age header](https://www.w3.org/TR/cors/#access-control-max-age-response-header) used in preflight responses.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] methods: The list of HTTP methods on which to include CORS response headers, (GET, OPTIONS, POST, etc) Note: "*" is permitted in the list of methods, and means "any method".
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] origins: The list of [Origins](https://tools.ietf.org/html/rfc6454) eligible to receive CORS response headers. Note: "*" is permitted in the list of origins, and means "any Origin".
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] response_headers: The list of HTTP headers other than the [simple response headers](https://www.w3.org/TR/cors/#simple-response-header) to give permission for the user-agent to share across domains.
        """
        if max_age_seconds is not None:
            pulumi.set(__self__, "max_age_seconds", max_age_seconds)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if origins is not None:
            pulumi.set(__self__, "origins", origins)
        if response_headers is not None:
            pulumi.set(__self__, "response_headers", response_headers)

    @_builtins.property
    @pulumi.getter(name="maxAgeSeconds")
    def max_age_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The value, in seconds, to return in the [Access-Control-Max-Age header](https://www.w3.org/TR/cors/#access-control-max-age-response-header) used in preflight responses.
        """
        return pulumi.get(self, "max_age_seconds")

    @max_age_seconds.setter
    def max_age_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_age_seconds", value)

    @_builtins.property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of HTTP methods on which to include CORS response headers, (GET, OPTIONS, POST, etc) Note: "*" is permitted in the list of methods, and means "any method".
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "methods", value)

    @_builtins.property
    @pulumi.getter
    def origins(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of [Origins](https://tools.ietf.org/html/rfc6454) eligible to receive CORS response headers. Note: "*" is permitted in the list of origins, and means "any Origin".
        """
        return pulumi.get(self, "origins")

    @origins.setter
    def origins(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "origins", value)

    @_builtins.property
    @pulumi.getter(name="responseHeaders")
    def response_headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of HTTP headers other than the [simple response headers](https://www.w3.org/TR/cors/#simple-response-header) to give permission for the user-agent to share across domains.
        """
        return pulumi.get(self, "response_headers")

    @response_headers.setter
    def response_headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "response_headers", value)


if not MYPY:
    class BucketCustomPlacementConfigArgsDict(TypedDict):
        data_locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The list of individual regions that comprise a dual-region bucket. See [Cloud Storage bucket locations](https://cloud.google.com/storage/docs/dual-regions#availability) for a list of acceptable regions. **Note**: If any of the data_locations changes, it will [recreate the bucket](https://cloud.google.com/storage/docs/locations#key-concepts).
        """
elif False:
    BucketCustomPlacementConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketCustomPlacementConfigArgs:
    def __init__(__self__, *,
                 data_locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] data_locations: The list of individual regions that comprise a dual-region bucket. See [Cloud Storage bucket locations](https://cloud.google.com/storage/docs/dual-regions#availability) for a list of acceptable regions. **Note**: If any of the data_locations changes, it will [recreate the bucket](https://cloud.google.com/storage/docs/locations#key-concepts).
        """
        pulumi.set(__self__, "data_locations", data_locations)

    @_builtins.property
    @pulumi.getter(name="dataLocations")
    def data_locations(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The list of individual regions that comprise a dual-region bucket. See [Cloud Storage bucket locations](https://cloud.google.com/storage/docs/dual-regions#availability) for a list of acceptable regions. **Note**: If any of the data_locations changes, it will [recreate the bucket](https://cloud.google.com/storage/docs/locations#key-concepts).
        """
        return pulumi.get(self, "data_locations")

    @data_locations.setter
    def data_locations(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "data_locations", value)


if not MYPY:
    class BucketEncryptionArgsDict(TypedDict):
        default_kms_key_name: pulumi.Input[_builtins.str]
        """
        The `id` of a Cloud KMS key that will be used to encrypt objects inserted into this bucket, if no encryption method is specified.
        You must pay attention to whether the crypto key is available in the location that this bucket is created in.
        See [the docs](https://cloud.google.com/storage/docs/encryption/using-customer-managed-keys) for more details.

        > As per [the docs](https://cloud.google.com/storage/docs/encryption/using-customer-managed-keys) for customer-managed encryption keys, the IAM policy for the
        specified key must permit the [automatic Google Cloud Storage service account](https://cloud.google.com/storage/docs/projects#service-accounts) for the bucket's
        project to use the specified key for encryption and decryption operations.
        Although the service account email address follows a well-known format, the service account is created on-demand and may not necessarily exist for your project
        until a relevant action has occurred which triggers its creation.
        You should use the [`storage_get_project_service_account`](https://www.terraform.io/docs/providers/google/d/storage_project_service_account.html) data source to obtain the email
        address for the service account when configuring IAM policy on the Cloud KMS key.
        This data source calls an API which creates the account if required, ensuring your provider applies cleanly and repeatedly irrespective of the
        state of the project.
        You should take care for race conditions when the same provider manages IAM policy on the Cloud KMS crypto key. See the data source page for more details.
        """
elif False:
    BucketEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketEncryptionArgs:
    def __init__(__self__, *,
                 default_kms_key_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] default_kms_key_name: The `id` of a Cloud KMS key that will be used to encrypt objects inserted into this bucket, if no encryption method is specified.
               You must pay attention to whether the crypto key is available in the location that this bucket is created in.
               See [the docs](https://cloud.google.com/storage/docs/encryption/using-customer-managed-keys) for more details.
               
               > As per [the docs](https://cloud.google.com/storage/docs/encryption/using-customer-managed-keys) for customer-managed encryption keys, the IAM policy for the
               specified key must permit the [automatic Google Cloud Storage service account](https://cloud.google.com/storage/docs/projects#service-accounts) for the bucket's
               project to use the specified key for encryption and decryption operations.
               Although the service account email address follows a well-known format, the service account is created on-demand and may not necessarily exist for your project
               until a relevant action has occurred which triggers its creation.
               You should use the [`storage_get_project_service_account`](https://www.terraform.io/docs/providers/google/d/storage_project_service_account.html) data source to obtain the email
               address for the service account when configuring IAM policy on the Cloud KMS key.
               This data source calls an API which creates the account if required, ensuring your provider applies cleanly and repeatedly irrespective of the
               state of the project.
               You should take care for race conditions when the same provider manages IAM policy on the Cloud KMS crypto key. See the data source page for more details.
        """
        pulumi.set(__self__, "default_kms_key_name", default_kms_key_name)

    @_builtins.property
    @pulumi.getter(name="defaultKmsKeyName")
    def default_kms_key_name(self) -> pulumi.Input[_builtins.str]:
        """
        The `id` of a Cloud KMS key that will be used to encrypt objects inserted into this bucket, if no encryption method is specified.
        You must pay attention to whether the crypto key is available in the location that this bucket is created in.
        See [the docs](https://cloud.google.com/storage/docs/encryption/using-customer-managed-keys) for more details.

        > As per [the docs](https://cloud.google.com/storage/docs/encryption/using-customer-managed-keys) for customer-managed encryption keys, the IAM policy for the
        specified key must permit the [automatic Google Cloud Storage service account](https://cloud.google.com/storage/docs/projects#service-accounts) for the bucket's
        project to use the specified key for encryption and decryption operations.
        Although the service account email address follows a well-known format, the service account is created on-demand and may not necessarily exist for your project
        until a relevant action has occurred which triggers its creation.
        You should use the [`storage_get_project_service_account`](https://www.terraform.io/docs/providers/google/d/storage_project_service_account.html) data source to obtain the email
        address for the service account when configuring IAM policy on the Cloud KMS key.
        This data source calls an API which creates the account if required, ensuring your provider applies cleanly and repeatedly irrespective of the
        state of the project.
        You should take care for race conditions when the same provider manages IAM policy on the Cloud KMS crypto key. See the data source page for more details.
        """
        return pulumi.get(self, "default_kms_key_name")

    @default_kms_key_name.setter
    def default_kms_key_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_kms_key_name", value)


if not MYPY:
    class BucketHierarchicalNamespaceArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Enables hierarchical namespace for the bucket.
        """
elif False:
    BucketHierarchicalNamespaceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketHierarchicalNamespaceArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enables hierarchical namespace for the bucket.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Enables hierarchical namespace for the bucket.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class BucketIAMBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[_builtins.str]
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        title: pulumi.Input[_builtins.str]
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.

        > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
        identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
        consider it to be an entirely different resource and will treat it as such.
        """
elif False:
    BucketIAMBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketIAMBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 title: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expression: Textual representation of an expression in Common Expression Language syntax.
        :param pulumi.Input[_builtins.str] title: A title for the expression, i.e. a short string describing its purpose.
        :param pulumi.Input[_builtins.str] description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
               
               > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
               identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
               consider it to be an entirely different resource and will treat it as such.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> pulumi.Input[_builtins.str]:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.

        > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
        identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
        consider it to be an entirely different resource and will treat it as such.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class BucketIAMMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[_builtins.str]
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        title: pulumi.Input[_builtins.str]
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.

        > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
        identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
        consider it to be an entirely different resource and will treat it as such.
        """
elif False:
    BucketIAMMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketIAMMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 title: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expression: Textual representation of an expression in Common Expression Language syntax.
        :param pulumi.Input[_builtins.str] title: A title for the expression, i.e. a short string describing its purpose.
        :param pulumi.Input[_builtins.str] description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
               
               > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
               identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
               consider it to be an entirely different resource and will treat it as such.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> pulumi.Input[_builtins.str]:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.

        > **Warning:** This provider considers the `role` and condition contents (`title`+`description`+`expression`) as the
        identifier for the binding. This means that if any part of the condition is changed out-of-band, the provider will
        consider it to be an entirely different resource and will treat it as such.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class BucketIpFilterArgsDict(TypedDict):
        mode: pulumi.Input[_builtins.str]
        """
        The state of the IP filter configuration. Valid values are `Enabled` and `Disabled`. When set to `Enabled`, IP filtering rules are applied to a bucket and all incoming requests to the bucket are evaluated against these rules. When set to `Disabled`, IP filtering rules are not applied to a bucket.

        **Note**: Once ip_filter is setup, it can either be `Enabled` or `Disabled` and cannot be removed from config.

        **Note**: `allow_all_service_agent_access` must be supplied when `mode` is set to `Enabled`, it can be ommited for other values.
        """
        allow_all_service_agent_access: NotRequired[pulumi.Input[_builtins.bool]]
        """
        While set `true`, allows all service agents to access the bucket regardless of the IP filter configuration.
        """
        allow_cross_org_vpcs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        While set `true`, allows cross-org VPCs in the bucket's IP filter configuration.
        """
        public_network_source: NotRequired[pulumi.Input['BucketIpFilterPublicNetworkSourceArgsDict']]
        """
        The public network IP address ranges that can access the bucket and its data. Structure is documented below.
        """
        vpc_network_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['BucketIpFilterVpcNetworkSourceArgsDict']]]]
        """
        The list of VPC networks that can access the bucket. Structure is documented below.
        """
elif False:
    BucketIpFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketIpFilterArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[_builtins.str],
                 allow_all_service_agent_access: Optional[pulumi.Input[_builtins.bool]] = None,
                 allow_cross_org_vpcs: Optional[pulumi.Input[_builtins.bool]] = None,
                 public_network_source: Optional[pulumi.Input['BucketIpFilterPublicNetworkSourceArgs']] = None,
                 vpc_network_sources: Optional[pulumi.Input[Sequence[pulumi.Input['BucketIpFilterVpcNetworkSourceArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] mode: The state of the IP filter configuration. Valid values are `Enabled` and `Disabled`. When set to `Enabled`, IP filtering rules are applied to a bucket and all incoming requests to the bucket are evaluated against these rules. When set to `Disabled`, IP filtering rules are not applied to a bucket.
               
               **Note**: Once ip_filter is setup, it can either be `Enabled` or `Disabled` and cannot be removed from config.
               
               **Note**: `allow_all_service_agent_access` must be supplied when `mode` is set to `Enabled`, it can be ommited for other values.
        :param pulumi.Input[_builtins.bool] allow_all_service_agent_access: While set `true`, allows all service agents to access the bucket regardless of the IP filter configuration.
        :param pulumi.Input[_builtins.bool] allow_cross_org_vpcs: While set `true`, allows cross-org VPCs in the bucket's IP filter configuration.
        :param pulumi.Input['BucketIpFilterPublicNetworkSourceArgs'] public_network_source: The public network IP address ranges that can access the bucket and its data. Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['BucketIpFilterVpcNetworkSourceArgs']]] vpc_network_sources: The list of VPC networks that can access the bucket. Structure is documented below.
        """
        pulumi.set(__self__, "mode", mode)
        if allow_all_service_agent_access is not None:
            pulumi.set(__self__, "allow_all_service_agent_access", allow_all_service_agent_access)
        if allow_cross_org_vpcs is not None:
            pulumi.set(__self__, "allow_cross_org_vpcs", allow_cross_org_vpcs)
        if public_network_source is not None:
            pulumi.set(__self__, "public_network_source", public_network_source)
        if vpc_network_sources is not None:
            pulumi.set(__self__, "vpc_network_sources", vpc_network_sources)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        """
        The state of the IP filter configuration. Valid values are `Enabled` and `Disabled`. When set to `Enabled`, IP filtering rules are applied to a bucket and all incoming requests to the bucket are evaluated against these rules. When set to `Disabled`, IP filtering rules are not applied to a bucket.

        **Note**: Once ip_filter is setup, it can either be `Enabled` or `Disabled` and cannot be removed from config.

        **Note**: `allow_all_service_agent_access` must be supplied when `mode` is set to `Enabled`, it can be ommited for other values.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="allowAllServiceAgentAccess")
    def allow_all_service_agent_access(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        While set `true`, allows all service agents to access the bucket regardless of the IP filter configuration.
        """
        return pulumi.get(self, "allow_all_service_agent_access")

    @allow_all_service_agent_access.setter
    def allow_all_service_agent_access(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_all_service_agent_access", value)

    @_builtins.property
    @pulumi.getter(name="allowCrossOrgVpcs")
    def allow_cross_org_vpcs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        While set `true`, allows cross-org VPCs in the bucket's IP filter configuration.
        """
        return pulumi.get(self, "allow_cross_org_vpcs")

    @allow_cross_org_vpcs.setter
    def allow_cross_org_vpcs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_cross_org_vpcs", value)

    @_builtins.property
    @pulumi.getter(name="publicNetworkSource")
    def public_network_source(self) -> Optional[pulumi.Input['BucketIpFilterPublicNetworkSourceArgs']]:
        """
        The public network IP address ranges that can access the bucket and its data. Structure is documented below.
        """
        return pulumi.get(self, "public_network_source")

    @public_network_source.setter
    def public_network_source(self, value: Optional[pulumi.Input['BucketIpFilterPublicNetworkSourceArgs']]):
        pulumi.set(self, "public_network_source", value)

    @_builtins.property
    @pulumi.getter(name="vpcNetworkSources")
    def vpc_network_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BucketIpFilterVpcNetworkSourceArgs']]]]:
        """
        The list of VPC networks that can access the bucket. Structure is documented below.
        """
        return pulumi.get(self, "vpc_network_sources")

    @vpc_network_sources.setter
    def vpc_network_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BucketIpFilterVpcNetworkSourceArgs']]]]):
        pulumi.set(self, "vpc_network_sources", value)


if not MYPY:
    class BucketIpFilterPublicNetworkSourceArgsDict(TypedDict):
        allowed_ip_cidr_ranges: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The list of public IPv4 and IPv6 CIDR ranges that can access the bucket and its data.
        """
elif False:
    BucketIpFilterPublicNetworkSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketIpFilterPublicNetworkSourceArgs:
    def __init__(__self__, *,
                 allowed_ip_cidr_ranges: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_ip_cidr_ranges: The list of public IPv4 and IPv6 CIDR ranges that can access the bucket and its data.
        """
        pulumi.set(__self__, "allowed_ip_cidr_ranges", allowed_ip_cidr_ranges)

    @_builtins.property
    @pulumi.getter(name="allowedIpCidrRanges")
    def allowed_ip_cidr_ranges(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The list of public IPv4 and IPv6 CIDR ranges that can access the bucket and its data.
        """
        return pulumi.get(self, "allowed_ip_cidr_ranges")

    @allowed_ip_cidr_ranges.setter
    def allowed_ip_cidr_ranges(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_ip_cidr_ranges", value)


if not MYPY:
    class BucketIpFilterVpcNetworkSourceArgsDict(TypedDict):
        allowed_ip_cidr_ranges: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The list of public or private IPv4 and IPv6 CIDR ranges that can access the bucket.
        """
        network: pulumi.Input[_builtins.str]
        """
        Name of the network. Format: `projects/PROJECT_ID/global/networks/NETWORK_NAME`
        """
elif False:
    BucketIpFilterVpcNetworkSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketIpFilterVpcNetworkSourceArgs:
    def __init__(__self__, *,
                 allowed_ip_cidr_ranges: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 network: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_ip_cidr_ranges: The list of public or private IPv4 and IPv6 CIDR ranges that can access the bucket.
        :param pulumi.Input[_builtins.str] network: Name of the network. Format: `projects/PROJECT_ID/global/networks/NETWORK_NAME`
        """
        pulumi.set(__self__, "allowed_ip_cidr_ranges", allowed_ip_cidr_ranges)
        pulumi.set(__self__, "network", network)

    @_builtins.property
    @pulumi.getter(name="allowedIpCidrRanges")
    def allowed_ip_cidr_ranges(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The list of public or private IPv4 and IPv6 CIDR ranges that can access the bucket.
        """
        return pulumi.get(self, "allowed_ip_cidr_ranges")

    @allowed_ip_cidr_ranges.setter
    def allowed_ip_cidr_ranges(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "allowed_ip_cidr_ranges", value)

    @_builtins.property
    @pulumi.getter
    def network(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the network. Format: `projects/PROJECT_ID/global/networks/NETWORK_NAME`
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network", value)


if not MYPY:
    class BucketLifecycleRuleArgsDict(TypedDict):
        action: pulumi.Input['BucketLifecycleRuleActionArgsDict']
        """
        The Lifecycle Rule's action configuration. A single block of this type is supported. Structure is documented below.
        """
        condition: pulumi.Input['BucketLifecycleRuleConditionArgsDict']
        """
        The Lifecycle Rule's condition configuration. A single block of this type is supported. Structure is documented below.
        """
elif False:
    BucketLifecycleRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleRuleArgs:
    def __init__(__self__, *,
                 action: pulumi.Input['BucketLifecycleRuleActionArgs'],
                 condition: pulumi.Input['BucketLifecycleRuleConditionArgs']):
        """
        :param pulumi.Input['BucketLifecycleRuleActionArgs'] action: The Lifecycle Rule's action configuration. A single block of this type is supported. Structure is documented below.
        :param pulumi.Input['BucketLifecycleRuleConditionArgs'] condition: The Lifecycle Rule's condition configuration. A single block of this type is supported. Structure is documented below.
        """
        pulumi.set(__self__, "action", action)
        pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def action(self) -> pulumi.Input['BucketLifecycleRuleActionArgs']:
        """
        The Lifecycle Rule's action configuration. A single block of this type is supported. Structure is documented below.
        """
        return pulumi.get(self, "action")

    @action.setter
    def action(self, value: pulumi.Input['BucketLifecycleRuleActionArgs']):
        pulumi.set(self, "action", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input['BucketLifecycleRuleConditionArgs']:
        """
        The Lifecycle Rule's condition configuration. A single block of this type is supported. Structure is documented below.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input['BucketLifecycleRuleConditionArgs']):
        pulumi.set(self, "condition", value)


if not MYPY:
    class BucketLifecycleRuleActionArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of the action of this Lifecycle Rule. Supported values include: `Delete`, `SetStorageClass` and `AbortIncompleteMultipartUpload`.
        """
        storage_class: NotRequired[pulumi.Input[_builtins.str]]
        """
        The target [Storage Class](https://cloud.google.com/storage/docs/storage-classes) of objects affected by this Lifecycle Rule. Supported values include: `STANDARD`, `MULTI_REGIONAL`, `REGIONAL`, `NEARLINE`, `COLDLINE`, `ARCHIVE`.
        """
elif False:
    BucketLifecycleRuleActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleRuleActionArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 storage_class: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of the action of this Lifecycle Rule. Supported values include: `Delete`, `SetStorageClass` and `AbortIncompleteMultipartUpload`.
        :param pulumi.Input[_builtins.str] storage_class: The target [Storage Class](https://cloud.google.com/storage/docs/storage-classes) of objects affected by this Lifecycle Rule. Supported values include: `STANDARD`, `MULTI_REGIONAL`, `REGIONAL`, `NEARLINE`, `COLDLINE`, `ARCHIVE`.
        """
        pulumi.set(__self__, "type", type)
        if storage_class is not None:
            pulumi.set(__self__, "storage_class", storage_class)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the action of this Lifecycle Rule. Supported values include: `Delete`, `SetStorageClass` and `AbortIncompleteMultipartUpload`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The target [Storage Class](https://cloud.google.com/storage/docs/storage-classes) of objects affected by this Lifecycle Rule. Supported values include: `STANDARD`, `MULTI_REGIONAL`, `REGIONAL`, `NEARLINE`, `COLDLINE`, `ARCHIVE`.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_class", value)


if not MYPY:
    class BucketLifecycleRuleConditionArgsDict(TypedDict):
        age: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum age of an object in days to satisfy this condition. **Note** To set `0` value of `age`, `send_age_if_zero` should be set `true` otherwise `0` value of `age` field will be ignored.
        """
        created_before: NotRequired[pulumi.Input[_builtins.str]]
        """
        A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when an object is created before midnight of the specified date in UTC.
        """
        custom_time_before: NotRequired[pulumi.Input[_builtins.str]]
        """
        A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when the customTime metadata for the object is set to an earlier date than the date used in this lifecycle condition.
        """
        days_since_custom_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of days elapsed since the user-specified timestamp set on an object.
        """
        days_since_noncurrent_time: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of days elapsed since the noncurrent timestamp of an object. This
        										condition is relevant only for versioned objects.
        """
        matches_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        One or more matching name prefixes to satisfy this condition.
        """
        matches_storage_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        [Storage Class](https://cloud.google.com/storage/docs/storage-classes) of objects to satisfy this condition. Supported values include: `STANDARD`, `MULTI_REGIONAL`, `REGIONAL`, `NEARLINE`, `COLDLINE`, `ARCHIVE`, `DURABLE_REDUCED_AVAILABILITY`.
        """
        matches_suffixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        One or more matching name suffixes to satisfy this condition.
        """
        noncurrent_time_before: NotRequired[pulumi.Input[_builtins.str]]
        """
        Creation date of an object in RFC 3339 (e.g. 2017-06-13) to satisfy this condition.
        """
        num_newer_versions: NotRequired[pulumi.Input[_builtins.int]]
        """
        Relevant only for versioned objects. The number of newer versions of an object to satisfy this condition.
        """
        send_age_if_zero: NotRequired[pulumi.Input[_builtins.bool]]
        """
        While set true, `age` value will be sent in the request even for zero value of the field. This field is only useful and required for setting 0 value to the `age` field. It can be used alone or together with `age` attribute. **NOTE** `age` attibute with `0` value will be ommitted from the API request if `send_age_if_zero` field is having `false` value.
        """
        send_days_since_custom_time_if_zero: NotRequired[pulumi.Input[_builtins.bool]]
        """
        While set true, `days_since_custom_time` value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the `days_since_custom_time` field. It can be used alone or together with `days_since_custom_time`.
        """
        send_days_since_noncurrent_time_if_zero: NotRequired[pulumi.Input[_builtins.bool]]
        """
        While set true, `days_since_noncurrent_time` value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the `days_since_noncurrent_time` field. It can be used alone or together with `days_since_noncurrent_time`.
        """
        send_num_newer_versions_if_zero: NotRequired[pulumi.Input[_builtins.bool]]
        """
        While set true, `num_newer_versions` value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the `num_newer_versions` field. It can be used alone or together with `num_newer_versions`.
        """
        with_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        Match to live and/or archived objects. Unversioned buckets have only live objects. Supported values include: `"LIVE"`, `"ARCHIVED"`, `"ANY"`.
        """
elif False:
    BucketLifecycleRuleConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLifecycleRuleConditionArgs:
    def __init__(__self__, *,
                 age: Optional[pulumi.Input[_builtins.int]] = None,
                 created_before: Optional[pulumi.Input[_builtins.str]] = None,
                 custom_time_before: Optional[pulumi.Input[_builtins.str]] = None,
                 days_since_custom_time: Optional[pulumi.Input[_builtins.int]] = None,
                 days_since_noncurrent_time: Optional[pulumi.Input[_builtins.int]] = None,
                 matches_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 matches_storage_classes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 matches_suffixes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 noncurrent_time_before: Optional[pulumi.Input[_builtins.str]] = None,
                 num_newer_versions: Optional[pulumi.Input[_builtins.int]] = None,
                 send_age_if_zero: Optional[pulumi.Input[_builtins.bool]] = None,
                 send_days_since_custom_time_if_zero: Optional[pulumi.Input[_builtins.bool]] = None,
                 send_days_since_noncurrent_time_if_zero: Optional[pulumi.Input[_builtins.bool]] = None,
                 send_num_newer_versions_if_zero: Optional[pulumi.Input[_builtins.bool]] = None,
                 with_state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] age: Minimum age of an object in days to satisfy this condition. **Note** To set `0` value of `age`, `send_age_if_zero` should be set `true` otherwise `0` value of `age` field will be ignored.
        :param pulumi.Input[_builtins.str] created_before: A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when an object is created before midnight of the specified date in UTC.
        :param pulumi.Input[_builtins.str] custom_time_before: A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when the customTime metadata for the object is set to an earlier date than the date used in this lifecycle condition.
        :param pulumi.Input[_builtins.int] days_since_custom_time: Number of days elapsed since the user-specified timestamp set on an object.
        :param pulumi.Input[_builtins.int] days_since_noncurrent_time: Number of days elapsed since the noncurrent timestamp of an object. This
               										condition is relevant only for versioned objects.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] matches_prefixes: One or more matching name prefixes to satisfy this condition.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] matches_storage_classes: [Storage Class](https://cloud.google.com/storage/docs/storage-classes) of objects to satisfy this condition. Supported values include: `STANDARD`, `MULTI_REGIONAL`, `REGIONAL`, `NEARLINE`, `COLDLINE`, `ARCHIVE`, `DURABLE_REDUCED_AVAILABILITY`.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] matches_suffixes: One or more matching name suffixes to satisfy this condition.
        :param pulumi.Input[_builtins.str] noncurrent_time_before: Creation date of an object in RFC 3339 (e.g. 2017-06-13) to satisfy this condition.
        :param pulumi.Input[_builtins.int] num_newer_versions: Relevant only for versioned objects. The number of newer versions of an object to satisfy this condition.
        :param pulumi.Input[_builtins.bool] send_age_if_zero: While set true, `age` value will be sent in the request even for zero value of the field. This field is only useful and required for setting 0 value to the `age` field. It can be used alone or together with `age` attribute. **NOTE** `age` attibute with `0` value will be ommitted from the API request if `send_age_if_zero` field is having `false` value.
        :param pulumi.Input[_builtins.bool] send_days_since_custom_time_if_zero: While set true, `days_since_custom_time` value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the `days_since_custom_time` field. It can be used alone or together with `days_since_custom_time`.
        :param pulumi.Input[_builtins.bool] send_days_since_noncurrent_time_if_zero: While set true, `days_since_noncurrent_time` value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the `days_since_noncurrent_time` field. It can be used alone or together with `days_since_noncurrent_time`.
        :param pulumi.Input[_builtins.bool] send_num_newer_versions_if_zero: While set true, `num_newer_versions` value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the `num_newer_versions` field. It can be used alone or together with `num_newer_versions`.
        :param pulumi.Input[_builtins.str] with_state: Match to live and/or archived objects. Unversioned buckets have only live objects. Supported values include: `"LIVE"`, `"ARCHIVED"`, `"ANY"`.
        """
        if age is not None:
            pulumi.set(__self__, "age", age)
        if created_before is not None:
            pulumi.set(__self__, "created_before", created_before)
        if custom_time_before is not None:
            pulumi.set(__self__, "custom_time_before", custom_time_before)
        if days_since_custom_time is not None:
            pulumi.set(__self__, "days_since_custom_time", days_since_custom_time)
        if days_since_noncurrent_time is not None:
            pulumi.set(__self__, "days_since_noncurrent_time", days_since_noncurrent_time)
        if matches_prefixes is not None:
            pulumi.set(__self__, "matches_prefixes", matches_prefixes)
        if matches_storage_classes is not None:
            pulumi.set(__self__, "matches_storage_classes", matches_storage_classes)
        if matches_suffixes is not None:
            pulumi.set(__self__, "matches_suffixes", matches_suffixes)
        if noncurrent_time_before is not None:
            pulumi.set(__self__, "noncurrent_time_before", noncurrent_time_before)
        if num_newer_versions is not None:
            pulumi.set(__self__, "num_newer_versions", num_newer_versions)
        if send_age_if_zero is not None:
            pulumi.set(__self__, "send_age_if_zero", send_age_if_zero)
        if send_days_since_custom_time_if_zero is not None:
            pulumi.set(__self__, "send_days_since_custom_time_if_zero", send_days_since_custom_time_if_zero)
        if send_days_since_noncurrent_time_if_zero is not None:
            pulumi.set(__self__, "send_days_since_noncurrent_time_if_zero", send_days_since_noncurrent_time_if_zero)
        if send_num_newer_versions_if_zero is not None:
            pulumi.set(__self__, "send_num_newer_versions_if_zero", send_num_newer_versions_if_zero)
        if with_state is not None:
            pulumi.set(__self__, "with_state", with_state)

    @_builtins.property
    @pulumi.getter
    def age(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum age of an object in days to satisfy this condition. **Note** To set `0` value of `age`, `send_age_if_zero` should be set `true` otherwise `0` value of `age` field will be ignored.
        """
        return pulumi.get(self, "age")

    @age.setter
    def age(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "age", value)

    @_builtins.property
    @pulumi.getter(name="createdBefore")
    def created_before(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when an object is created before midnight of the specified date in UTC.
        """
        return pulumi.get(self, "created_before")

    @created_before.setter
    def created_before(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_before", value)

    @_builtins.property
    @pulumi.getter(name="customTimeBefore")
    def custom_time_before(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A date in the RFC 3339 format YYYY-MM-DD. This condition is satisfied when the customTime metadata for the object is set to an earlier date than the date used in this lifecycle condition.
        """
        return pulumi.get(self, "custom_time_before")

    @custom_time_before.setter
    def custom_time_before(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "custom_time_before", value)

    @_builtins.property
    @pulumi.getter(name="daysSinceCustomTime")
    def days_since_custom_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of days elapsed since the user-specified timestamp set on an object.
        """
        return pulumi.get(self, "days_since_custom_time")

    @days_since_custom_time.setter
    def days_since_custom_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days_since_custom_time", value)

    @_builtins.property
    @pulumi.getter(name="daysSinceNoncurrentTime")
    def days_since_noncurrent_time(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of days elapsed since the noncurrent timestamp of an object. This
        										condition is relevant only for versioned objects.
        """
        return pulumi.get(self, "days_since_noncurrent_time")

    @days_since_noncurrent_time.setter
    def days_since_noncurrent_time(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "days_since_noncurrent_time", value)

    @_builtins.property
    @pulumi.getter(name="matchesPrefixes")
    def matches_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        One or more matching name prefixes to satisfy this condition.
        """
        return pulumi.get(self, "matches_prefixes")

    @matches_prefixes.setter
    def matches_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "matches_prefixes", value)

    @_builtins.property
    @pulumi.getter(name="matchesStorageClasses")
    def matches_storage_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        [Storage Class](https://cloud.google.com/storage/docs/storage-classes) of objects to satisfy this condition. Supported values include: `STANDARD`, `MULTI_REGIONAL`, `REGIONAL`, `NEARLINE`, `COLDLINE`, `ARCHIVE`, `DURABLE_REDUCED_AVAILABILITY`.
        """
        return pulumi.get(self, "matches_storage_classes")

    @matches_storage_classes.setter
    def matches_storage_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "matches_storage_classes", value)

    @_builtins.property
    @pulumi.getter(name="matchesSuffixes")
    def matches_suffixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        One or more matching name suffixes to satisfy this condition.
        """
        return pulumi.get(self, "matches_suffixes")

    @matches_suffixes.setter
    def matches_suffixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "matches_suffixes", value)

    @_builtins.property
    @pulumi.getter(name="noncurrentTimeBefore")
    def noncurrent_time_before(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Creation date of an object in RFC 3339 (e.g. 2017-06-13) to satisfy this condition.
        """
        return pulumi.get(self, "noncurrent_time_before")

    @noncurrent_time_before.setter
    def noncurrent_time_before(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "noncurrent_time_before", value)

    @_builtins.property
    @pulumi.getter(name="numNewerVersions")
    def num_newer_versions(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Relevant only for versioned objects. The number of newer versions of an object to satisfy this condition.
        """
        return pulumi.get(self, "num_newer_versions")

    @num_newer_versions.setter
    def num_newer_versions(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "num_newer_versions", value)

    @_builtins.property
    @pulumi.getter(name="sendAgeIfZero")
    def send_age_if_zero(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        While set true, `age` value will be sent in the request even for zero value of the field. This field is only useful and required for setting 0 value to the `age` field. It can be used alone or together with `age` attribute. **NOTE** `age` attibute with `0` value will be ommitted from the API request if `send_age_if_zero` field is having `false` value.
        """
        return pulumi.get(self, "send_age_if_zero")

    @send_age_if_zero.setter
    def send_age_if_zero(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "send_age_if_zero", value)

    @_builtins.property
    @pulumi.getter(name="sendDaysSinceCustomTimeIfZero")
    def send_days_since_custom_time_if_zero(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        While set true, `days_since_custom_time` value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the `days_since_custom_time` field. It can be used alone or together with `days_since_custom_time`.
        """
        return pulumi.get(self, "send_days_since_custom_time_if_zero")

    @send_days_since_custom_time_if_zero.setter
    def send_days_since_custom_time_if_zero(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "send_days_since_custom_time_if_zero", value)

    @_builtins.property
    @pulumi.getter(name="sendDaysSinceNoncurrentTimeIfZero")
    def send_days_since_noncurrent_time_if_zero(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        While set true, `days_since_noncurrent_time` value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the `days_since_noncurrent_time` field. It can be used alone or together with `days_since_noncurrent_time`.
        """
        return pulumi.get(self, "send_days_since_noncurrent_time_if_zero")

    @send_days_since_noncurrent_time_if_zero.setter
    def send_days_since_noncurrent_time_if_zero(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "send_days_since_noncurrent_time_if_zero", value)

    @_builtins.property
    @pulumi.getter(name="sendNumNewerVersionsIfZero")
    def send_num_newer_versions_if_zero(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        While set true, `num_newer_versions` value will be sent in the request even for zero value of the field. This field is only useful for setting 0 value to the `num_newer_versions` field. It can be used alone or together with `num_newer_versions`.
        """
        return pulumi.get(self, "send_num_newer_versions_if_zero")

    @send_num_newer_versions_if_zero.setter
    def send_num_newer_versions_if_zero(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "send_num_newer_versions_if_zero", value)

    @_builtins.property
    @pulumi.getter(name="withState")
    def with_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Match to live and/or archived objects. Unversioned buckets have only live objects. Supported values include: `"LIVE"`, `"ARCHIVED"`, `"ANY"`.
        """
        return pulumi.get(self, "with_state")

    @with_state.setter
    def with_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "with_state", value)


if not MYPY:
    class BucketLoggingArgsDict(TypedDict):
        log_bucket: pulumi.Input[_builtins.str]
        """
        The bucket that will receive log objects.
        """
        log_object_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The object prefix for log objects. If it's not provided,
        by default GCS sets this to this bucket's name.
        """
elif False:
    BucketLoggingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketLoggingArgs:
    def __init__(__self__, *,
                 log_bucket: pulumi.Input[_builtins.str],
                 log_object_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] log_bucket: The bucket that will receive log objects.
        :param pulumi.Input[_builtins.str] log_object_prefix: The object prefix for log objects. If it's not provided,
               by default GCS sets this to this bucket's name.
        """
        pulumi.set(__self__, "log_bucket", log_bucket)
        if log_object_prefix is not None:
            pulumi.set(__self__, "log_object_prefix", log_object_prefix)

    @_builtins.property
    @pulumi.getter(name="logBucket")
    def log_bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The bucket that will receive log objects.
        """
        return pulumi.get(self, "log_bucket")

    @log_bucket.setter
    def log_bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "log_bucket", value)

    @_builtins.property
    @pulumi.getter(name="logObjectPrefix")
    def log_object_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The object prefix for log objects. If it's not provided,
        by default GCS sets this to this bucket's name.
        """
        return pulumi.get(self, "log_object_prefix")

    @log_object_prefix.setter
    def log_object_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "log_object_prefix", value)


if not MYPY:
    class BucketObjectContextsArgsDict(TypedDict):
        customs: pulumi.Input[Sequence[pulumi.Input['BucketObjectContextsCustomArgsDict']]]
        """
        A list of custom context key-value pairs.
        """
elif False:
    BucketObjectContextsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketObjectContextsArgs:
    def __init__(__self__, *,
                 customs: pulumi.Input[Sequence[pulumi.Input['BucketObjectContextsCustomArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BucketObjectContextsCustomArgs']]] customs: A list of custom context key-value pairs.
        """
        pulumi.set(__self__, "customs", customs)

    @_builtins.property
    @pulumi.getter
    def customs(self) -> pulumi.Input[Sequence[pulumi.Input['BucketObjectContextsCustomArgs']]]:
        """
        A list of custom context key-value pairs.
        """
        return pulumi.get(self, "customs")

    @customs.setter
    def customs(self, value: pulumi.Input[Sequence[pulumi.Input['BucketObjectContextsCustomArgs']]]):
        pulumi.set(self, "customs", value)


if not MYPY:
    class BucketObjectContextsCustomArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        An individual object context. Context keys and their corresponding values must start with an alphanumeric character.
        """
        value: pulumi.Input[_builtins.str]
        """
        The value associated with this context. This field holds the primary information for the given context key.
        """
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time when context was first added to the storage object in RFC 3399 format.
        """
        update_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time when context was last updated in RFC 3399 format.

        <a name>
        """
elif False:
    BucketObjectContextsCustomArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketObjectContextsCustomArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 value: pulumi.Input[_builtins.str],
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 update_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: An individual object context. Context keys and their corresponding values must start with an alphanumeric character.
        :param pulumi.Input[_builtins.str] value: The value associated with this context. This field holds the primary information for the given context key.
        :param pulumi.Input[_builtins.str] create_time: The time when context was first added to the storage object in RFC 3399 format.
        :param pulumi.Input[_builtins.str] update_time: The time when context was last updated in RFC 3399 format.
               
               <a name>
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        An individual object context. Context keys and their corresponding values must start with an alphanumeric character.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> pulumi.Input[_builtins.str]:
        """
        The value associated with this context. This field holds the primary information for the given context key.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time when context was first added to the storage object in RFC 3399 format.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time when context was last updated in RFC 3399 format.

        <a name>
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class BucketObjectCustomerEncryptionArgsDict(TypedDict):
        encryption_key: pulumi.Input[_builtins.str]
        """
        Base64 encoded Customer-Supplied Encryption Key.
        """
        encryption_algorithm: NotRequired[pulumi.Input[_builtins.str]]
        """
        Encryption algorithm. Default: AES256
        """
elif False:
    BucketObjectCustomerEncryptionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketObjectCustomerEncryptionArgs:
    def __init__(__self__, *,
                 encryption_key: pulumi.Input[_builtins.str],
                 encryption_algorithm: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] encryption_key: Base64 encoded Customer-Supplied Encryption Key.
        :param pulumi.Input[_builtins.str] encryption_algorithm: Encryption algorithm. Default: AES256
        """
        pulumi.set(__self__, "encryption_key", encryption_key)
        if encryption_algorithm is not None:
            pulumi.set(__self__, "encryption_algorithm", encryption_algorithm)

    @_builtins.property
    @pulumi.getter(name="encryptionKey")
    def encryption_key(self) -> pulumi.Input[_builtins.str]:
        """
        Base64 encoded Customer-Supplied Encryption Key.
        """
        return pulumi.get(self, "encryption_key")

    @encryption_key.setter
    def encryption_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "encryption_key", value)

    @_builtins.property
    @pulumi.getter(name="encryptionAlgorithm")
    def encryption_algorithm(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Encryption algorithm. Default: AES256
        """
        return pulumi.get(self, "encryption_algorithm")

    @encryption_algorithm.setter
    def encryption_algorithm(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "encryption_algorithm", value)


if not MYPY:
    class BucketObjectRetentionArgsDict(TypedDict):
        mode: pulumi.Input[_builtins.str]
        """
        The retention policy mode. Either `Locked` or `Unlocked`.
        """
        retain_until_time: pulumi.Input[_builtins.str]
        """
        The time to retain the object until in RFC 3339 format, for example 2012-11-15T16:19:00.094Z.

        <a name="nested_contexts"></a> The `contexts` block supports -
        """
elif False:
    BucketObjectRetentionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketObjectRetentionArgs:
    def __init__(__self__, *,
                 mode: pulumi.Input[_builtins.str],
                 retain_until_time: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] mode: The retention policy mode. Either `Locked` or `Unlocked`.
        :param pulumi.Input[_builtins.str] retain_until_time: The time to retain the object until in RFC 3339 format, for example 2012-11-15T16:19:00.094Z.
               
               <a name="nested_contexts"></a> The `contexts` block supports -
        """
        pulumi.set(__self__, "mode", mode)
        pulumi.set(__self__, "retain_until_time", retain_until_time)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> pulumi.Input[_builtins.str]:
        """
        The retention policy mode. Either `Locked` or `Unlocked`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="retainUntilTime")
    def retain_until_time(self) -> pulumi.Input[_builtins.str]:
        """
        The time to retain the object until in RFC 3339 format, for example 2012-11-15T16:19:00.094Z.

        <a name="nested_contexts"></a> The `contexts` block supports -
        """
        return pulumi.get(self, "retain_until_time")

    @retain_until_time.setter
    def retain_until_time(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "retain_until_time", value)


if not MYPY:
    class BucketRetentionPolicyArgsDict(TypedDict):
        retention_period: pulumi.Input[_builtins.str]
        """
        The period of time, in seconds, that objects in the bucket must be retained and cannot be deleted, overwritten, or archived. The value must be less than 3,155,760,000 seconds.
        """
        is_locked: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set to `true`, the bucket will be [locked](https://cloud.google.com/storage/docs/using-bucket-lock#lock-bucket) and permanently restrict edits to the bucket's retention policy.  Caution: Locking a bucket is an irreversible action.
        """
elif False:
    BucketRetentionPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketRetentionPolicyArgs:
    def __init__(__self__, *,
                 retention_period: pulumi.Input[_builtins.str],
                 is_locked: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] retention_period: The period of time, in seconds, that objects in the bucket must be retained and cannot be deleted, overwritten, or archived. The value must be less than 3,155,760,000 seconds.
        :param pulumi.Input[_builtins.bool] is_locked: If set to `true`, the bucket will be [locked](https://cloud.google.com/storage/docs/using-bucket-lock#lock-bucket) and permanently restrict edits to the bucket's retention policy.  Caution: Locking a bucket is an irreversible action.
        """
        pulumi.set(__self__, "retention_period", retention_period)
        if is_locked is not None:
            pulumi.set(__self__, "is_locked", is_locked)

    @_builtins.property
    @pulumi.getter(name="retentionPeriod")
    def retention_period(self) -> pulumi.Input[_builtins.str]:
        """
        The period of time, in seconds, that objects in the bucket must be retained and cannot be deleted, overwritten, or archived. The value must be less than 3,155,760,000 seconds.
        """
        return pulumi.get(self, "retention_period")

    @retention_period.setter
    def retention_period(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "retention_period", value)

    @_builtins.property
    @pulumi.getter(name="isLocked")
    def is_locked(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set to `true`, the bucket will be [locked](https://cloud.google.com/storage/docs/using-bucket-lock#lock-bucket) and permanently restrict edits to the bucket's retention policy.  Caution: Locking a bucket is an irreversible action.
        """
        return pulumi.get(self, "is_locked")

    @is_locked.setter
    def is_locked(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "is_locked", value)


if not MYPY:
    class BucketSoftDeletePolicyArgsDict(TypedDict):
        effective_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Server-determined value that indicates the time from which the policy, or one with a greater retention, was effective. This value is in RFC 3339 format.
        """
        retention_duration_seconds: NotRequired[pulumi.Input[_builtins.int]]
        """
        The duration in seconds that soft-deleted objects in the bucket will be retained and cannot be permanently deleted. Default value is 604800. The value must be in between 604800(7 days) and 7776000(90 days). **Note**: To disable the soft delete policy on a bucket, This field must be set to 0.
        """
elif False:
    BucketSoftDeletePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketSoftDeletePolicyArgs:
    def __init__(__self__, *,
                 effective_time: Optional[pulumi.Input[_builtins.str]] = None,
                 retention_duration_seconds: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] effective_time: Server-determined value that indicates the time from which the policy, or one with a greater retention, was effective. This value is in RFC 3339 format.
        :param pulumi.Input[_builtins.int] retention_duration_seconds: The duration in seconds that soft-deleted objects in the bucket will be retained and cannot be permanently deleted. Default value is 604800. The value must be in between 604800(7 days) and 7776000(90 days). **Note**: To disable the soft delete policy on a bucket, This field must be set to 0.
        """
        if effective_time is not None:
            pulumi.set(__self__, "effective_time", effective_time)
        if retention_duration_seconds is not None:
            pulumi.set(__self__, "retention_duration_seconds", retention_duration_seconds)

    @_builtins.property
    @pulumi.getter(name="effectiveTime")
    def effective_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Server-determined value that indicates the time from which the policy, or one with a greater retention, was effective. This value is in RFC 3339 format.
        """
        return pulumi.get(self, "effective_time")

    @effective_time.setter
    def effective_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effective_time", value)

    @_builtins.property
    @pulumi.getter(name="retentionDurationSeconds")
    def retention_duration_seconds(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The duration in seconds that soft-deleted objects in the bucket will be retained and cannot be permanently deleted. Default value is 604800. The value must be in between 604800(7 days) and 7776000(90 days). **Note**: To disable the soft delete policy on a bucket, This field must be set to 0.
        """
        return pulumi.get(self, "retention_duration_seconds")

    @retention_duration_seconds.setter
    def retention_duration_seconds(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "retention_duration_seconds", value)


if not MYPY:
    class BucketVersioningArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        While set to `true`, versioning is fully enabled for this bucket.
        """
elif False:
    BucketVersioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketVersioningArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] enabled: While set to `true`, versioning is fully enabled for this bucket.
        """
        pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        While set to `true`, versioning is fully enabled for this bucket.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class BucketWebsiteArgsDict(TypedDict):
        main_page_suffix: NotRequired[pulumi.Input[_builtins.str]]
        """
        Behaves as the bucket's directory index where
        missing objects are treated as potential directories.
        """
        not_found_page: NotRequired[pulumi.Input[_builtins.str]]
        """
        The custom object to return when a requested
        resource is not found.
        """
elif False:
    BucketWebsiteArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BucketWebsiteArgs:
    def __init__(__self__, *,
                 main_page_suffix: Optional[pulumi.Input[_builtins.str]] = None,
                 not_found_page: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] main_page_suffix: Behaves as the bucket's directory index where
               missing objects are treated as potential directories.
        :param pulumi.Input[_builtins.str] not_found_page: The custom object to return when a requested
               resource is not found.
        """
        if main_page_suffix is not None:
            pulumi.set(__self__, "main_page_suffix", main_page_suffix)
        if not_found_page is not None:
            pulumi.set(__self__, "not_found_page", not_found_page)

    @_builtins.property
    @pulumi.getter(name="mainPageSuffix")
    def main_page_suffix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Behaves as the bucket's directory index where
        missing objects are treated as potential directories.
        """
        return pulumi.get(self, "main_page_suffix")

    @main_page_suffix.setter
    def main_page_suffix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "main_page_suffix", value)

    @_builtins.property
    @pulumi.getter(name="notFoundPage")
    def not_found_page(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The custom object to return when a requested
        resource is not found.
        """
        return pulumi.get(self, "not_found_page")

    @not_found_page.setter
    def not_found_page(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "not_found_page", value)


if not MYPY:
    class ControlFolderIntelligenceConfigEffectiveIntelligenceConfigArgsDict(TypedDict):
        effective_edition: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The `StorageIntelligence` edition that is applicable for the resource.
        """
        intelligence_config: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The Intelligence config resource that is applied for the target resource.
        """
elif False:
    ControlFolderIntelligenceConfigEffectiveIntelligenceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlFolderIntelligenceConfigEffectiveIntelligenceConfigArgs:
    def __init__(__self__, *,
                 effective_edition: Optional[pulumi.Input[_builtins.str]] = None,
                 intelligence_config: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] effective_edition: (Output)
               The `StorageIntelligence` edition that is applicable for the resource.
        :param pulumi.Input[_builtins.str] intelligence_config: (Output)
               The Intelligence config resource that is applied for the target resource.
        """
        if effective_edition is not None:
            pulumi.set(__self__, "effective_edition", effective_edition)
        if intelligence_config is not None:
            pulumi.set(__self__, "intelligence_config", intelligence_config)

    @_builtins.property
    @pulumi.getter(name="effectiveEdition")
    def effective_edition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The `StorageIntelligence` edition that is applicable for the resource.
        """
        return pulumi.get(self, "effective_edition")

    @effective_edition.setter
    def effective_edition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effective_edition", value)

    @_builtins.property
    @pulumi.getter(name="intelligenceConfig")
    def intelligence_config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The Intelligence config resource that is applied for the target resource.
        """
        return pulumi.get(self, "intelligence_config")

    @intelligence_config.setter
    def intelligence_config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "intelligence_config", value)


if not MYPY:
    class ControlFolderIntelligenceConfigFilterArgsDict(TypedDict):
        excluded_cloud_storage_buckets: NotRequired[pulumi.Input['ControlFolderIntelligenceConfigFilterExcludedCloudStorageBucketsArgsDict']]
        """
        Buckets to exclude from the Storage Intelligence plan.
        Structure is documented below.
        """
        excluded_cloud_storage_locations: NotRequired[pulumi.Input['ControlFolderIntelligenceConfigFilterExcludedCloudStorageLocationsArgsDict']]
        """
        Locations to exclude from the Storage Intelligence plan.
        Structure is documented below.
        """
        included_cloud_storage_buckets: NotRequired[pulumi.Input['ControlFolderIntelligenceConfigFilterIncludedCloudStorageBucketsArgsDict']]
        """
        Buckets to include in the Storage Intelligence plan.
        Structure is documented below.
        """
        included_cloud_storage_locations: NotRequired[pulumi.Input['ControlFolderIntelligenceConfigFilterIncludedCloudStorageLocationsArgsDict']]
        """
        Locations to include in the Storage Intelligence plan.
        Structure is documented below.
        """
elif False:
    ControlFolderIntelligenceConfigFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlFolderIntelligenceConfigFilterArgs:
    def __init__(__self__, *,
                 excluded_cloud_storage_buckets: Optional[pulumi.Input['ControlFolderIntelligenceConfigFilterExcludedCloudStorageBucketsArgs']] = None,
                 excluded_cloud_storage_locations: Optional[pulumi.Input['ControlFolderIntelligenceConfigFilterExcludedCloudStorageLocationsArgs']] = None,
                 included_cloud_storage_buckets: Optional[pulumi.Input['ControlFolderIntelligenceConfigFilterIncludedCloudStorageBucketsArgs']] = None,
                 included_cloud_storage_locations: Optional[pulumi.Input['ControlFolderIntelligenceConfigFilterIncludedCloudStorageLocationsArgs']] = None):
        """
        :param pulumi.Input['ControlFolderIntelligenceConfigFilterExcludedCloudStorageBucketsArgs'] excluded_cloud_storage_buckets: Buckets to exclude from the Storage Intelligence plan.
               Structure is documented below.
        :param pulumi.Input['ControlFolderIntelligenceConfigFilterExcludedCloudStorageLocationsArgs'] excluded_cloud_storage_locations: Locations to exclude from the Storage Intelligence plan.
               Structure is documented below.
        :param pulumi.Input['ControlFolderIntelligenceConfigFilterIncludedCloudStorageBucketsArgs'] included_cloud_storage_buckets: Buckets to include in the Storage Intelligence plan.
               Structure is documented below.
        :param pulumi.Input['ControlFolderIntelligenceConfigFilterIncludedCloudStorageLocationsArgs'] included_cloud_storage_locations: Locations to include in the Storage Intelligence plan.
               Structure is documented below.
        """
        if excluded_cloud_storage_buckets is not None:
            pulumi.set(__self__, "excluded_cloud_storage_buckets", excluded_cloud_storage_buckets)
        if excluded_cloud_storage_locations is not None:
            pulumi.set(__self__, "excluded_cloud_storage_locations", excluded_cloud_storage_locations)
        if included_cloud_storage_buckets is not None:
            pulumi.set(__self__, "included_cloud_storage_buckets", included_cloud_storage_buckets)
        if included_cloud_storage_locations is not None:
            pulumi.set(__self__, "included_cloud_storage_locations", included_cloud_storage_locations)

    @_builtins.property
    @pulumi.getter(name="excludedCloudStorageBuckets")
    def excluded_cloud_storage_buckets(self) -> Optional[pulumi.Input['ControlFolderIntelligenceConfigFilterExcludedCloudStorageBucketsArgs']]:
        """
        Buckets to exclude from the Storage Intelligence plan.
        Structure is documented below.
        """
        return pulumi.get(self, "excluded_cloud_storage_buckets")

    @excluded_cloud_storage_buckets.setter
    def excluded_cloud_storage_buckets(self, value: Optional[pulumi.Input['ControlFolderIntelligenceConfigFilterExcludedCloudStorageBucketsArgs']]):
        pulumi.set(self, "excluded_cloud_storage_buckets", value)

    @_builtins.property
    @pulumi.getter(name="excludedCloudStorageLocations")
    def excluded_cloud_storage_locations(self) -> Optional[pulumi.Input['ControlFolderIntelligenceConfigFilterExcludedCloudStorageLocationsArgs']]:
        """
        Locations to exclude from the Storage Intelligence plan.
        Structure is documented below.
        """
        return pulumi.get(self, "excluded_cloud_storage_locations")

    @excluded_cloud_storage_locations.setter
    def excluded_cloud_storage_locations(self, value: Optional[pulumi.Input['ControlFolderIntelligenceConfigFilterExcludedCloudStorageLocationsArgs']]):
        pulumi.set(self, "excluded_cloud_storage_locations", value)

    @_builtins.property
    @pulumi.getter(name="includedCloudStorageBuckets")
    def included_cloud_storage_buckets(self) -> Optional[pulumi.Input['ControlFolderIntelligenceConfigFilterIncludedCloudStorageBucketsArgs']]:
        """
        Buckets to include in the Storage Intelligence plan.
        Structure is documented below.
        """
        return pulumi.get(self, "included_cloud_storage_buckets")

    @included_cloud_storage_buckets.setter
    def included_cloud_storage_buckets(self, value: Optional[pulumi.Input['ControlFolderIntelligenceConfigFilterIncludedCloudStorageBucketsArgs']]):
        pulumi.set(self, "included_cloud_storage_buckets", value)

    @_builtins.property
    @pulumi.getter(name="includedCloudStorageLocations")
    def included_cloud_storage_locations(self) -> Optional[pulumi.Input['ControlFolderIntelligenceConfigFilterIncludedCloudStorageLocationsArgs']]:
        """
        Locations to include in the Storage Intelligence plan.
        Structure is documented below.
        """
        return pulumi.get(self, "included_cloud_storage_locations")

    @included_cloud_storage_locations.setter
    def included_cloud_storage_locations(self, value: Optional[pulumi.Input['ControlFolderIntelligenceConfigFilterIncludedCloudStorageLocationsArgs']]):
        pulumi.set(self, "included_cloud_storage_locations", value)


if not MYPY:
    class ControlFolderIntelligenceConfigFilterExcludedCloudStorageBucketsArgsDict(TypedDict):
        bucket_id_regexes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of bucket id regexes to exclude in the storage intelligence plan.
        """
elif False:
    ControlFolderIntelligenceConfigFilterExcludedCloudStorageBucketsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlFolderIntelligenceConfigFilterExcludedCloudStorageBucketsArgs:
    def __init__(__self__, *,
                 bucket_id_regexes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] bucket_id_regexes: List of bucket id regexes to exclude in the storage intelligence plan.
        """
        pulumi.set(__self__, "bucket_id_regexes", bucket_id_regexes)

    @_builtins.property
    @pulumi.getter(name="bucketIdRegexes")
    def bucket_id_regexes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of bucket id regexes to exclude in the storage intelligence plan.
        """
        return pulumi.get(self, "bucket_id_regexes")

    @bucket_id_regexes.setter
    def bucket_id_regexes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "bucket_id_regexes", value)


if not MYPY:
    class ControlFolderIntelligenceConfigFilterExcludedCloudStorageLocationsArgsDict(TypedDict):
        locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of locations.
        """
elif False:
    ControlFolderIntelligenceConfigFilterExcludedCloudStorageLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlFolderIntelligenceConfigFilterExcludedCloudStorageLocationsArgs:
    def __init__(__self__, *,
                 locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] locations: List of locations.
        """
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of locations.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class ControlFolderIntelligenceConfigFilterIncludedCloudStorageBucketsArgsDict(TypedDict):
        bucket_id_regexes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of bucket id regexes to exclude in the storage intelligence plan.
        """
elif False:
    ControlFolderIntelligenceConfigFilterIncludedCloudStorageBucketsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlFolderIntelligenceConfigFilterIncludedCloudStorageBucketsArgs:
    def __init__(__self__, *,
                 bucket_id_regexes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] bucket_id_regexes: List of bucket id regexes to exclude in the storage intelligence plan.
        """
        pulumi.set(__self__, "bucket_id_regexes", bucket_id_regexes)

    @_builtins.property
    @pulumi.getter(name="bucketIdRegexes")
    def bucket_id_regexes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of bucket id regexes to exclude in the storage intelligence plan.
        """
        return pulumi.get(self, "bucket_id_regexes")

    @bucket_id_regexes.setter
    def bucket_id_regexes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "bucket_id_regexes", value)


if not MYPY:
    class ControlFolderIntelligenceConfigFilterIncludedCloudStorageLocationsArgsDict(TypedDict):
        locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of locations.
        """
elif False:
    ControlFolderIntelligenceConfigFilterIncludedCloudStorageLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlFolderIntelligenceConfigFilterIncludedCloudStorageLocationsArgs:
    def __init__(__self__, *,
                 locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] locations: List of locations.
        """
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of locations.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class ControlFolderIntelligenceConfigTrialConfigArgsDict(TypedDict):
        expire_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The time at which the trial expires.
        """
elif False:
    ControlFolderIntelligenceConfigTrialConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlFolderIntelligenceConfigTrialConfigArgs:
    def __init__(__self__, *,
                 expire_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expire_time: (Output)
               The time at which the trial expires.
        """
        if expire_time is not None:
            pulumi.set(__self__, "expire_time", expire_time)

    @_builtins.property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The time at which the trial expires.
        """
        return pulumi.get(self, "expire_time")

    @expire_time.setter
    def expire_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expire_time", value)


if not MYPY:
    class ControlOrganizationIntelligenceConfigEffectiveIntelligenceConfigArgsDict(TypedDict):
        effective_edition: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The `StorageIntelligence` edition that is applicable for the resource.
        """
        intelligence_config: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The Intelligence config resource that is applied for the target resource.
        """
elif False:
    ControlOrganizationIntelligenceConfigEffectiveIntelligenceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlOrganizationIntelligenceConfigEffectiveIntelligenceConfigArgs:
    def __init__(__self__, *,
                 effective_edition: Optional[pulumi.Input[_builtins.str]] = None,
                 intelligence_config: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] effective_edition: (Output)
               The `StorageIntelligence` edition that is applicable for the resource.
        :param pulumi.Input[_builtins.str] intelligence_config: (Output)
               The Intelligence config resource that is applied for the target resource.
        """
        if effective_edition is not None:
            pulumi.set(__self__, "effective_edition", effective_edition)
        if intelligence_config is not None:
            pulumi.set(__self__, "intelligence_config", intelligence_config)

    @_builtins.property
    @pulumi.getter(name="effectiveEdition")
    def effective_edition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The `StorageIntelligence` edition that is applicable for the resource.
        """
        return pulumi.get(self, "effective_edition")

    @effective_edition.setter
    def effective_edition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effective_edition", value)

    @_builtins.property
    @pulumi.getter(name="intelligenceConfig")
    def intelligence_config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The Intelligence config resource that is applied for the target resource.
        """
        return pulumi.get(self, "intelligence_config")

    @intelligence_config.setter
    def intelligence_config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "intelligence_config", value)


if not MYPY:
    class ControlOrganizationIntelligenceConfigFilterArgsDict(TypedDict):
        excluded_cloud_storage_buckets: NotRequired[pulumi.Input['ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageBucketsArgsDict']]
        """
        Buckets to exclude from the Storage Intelligence plan.
        Structure is documented below.
        """
        excluded_cloud_storage_locations: NotRequired[pulumi.Input['ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageLocationsArgsDict']]
        """
        Locations to exclude from the Storage Intelligence plan.
        Structure is documented below.
        """
        included_cloud_storage_buckets: NotRequired[pulumi.Input['ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageBucketsArgsDict']]
        """
        Buckets to include in the Storage Intelligence plan.
        Structure is documented below.
        """
        included_cloud_storage_locations: NotRequired[pulumi.Input['ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageLocationsArgsDict']]
        """
        Locations to include in the Storage Intelligence plan.
        Structure is documented below.
        """
elif False:
    ControlOrganizationIntelligenceConfigFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlOrganizationIntelligenceConfigFilterArgs:
    def __init__(__self__, *,
                 excluded_cloud_storage_buckets: Optional[pulumi.Input['ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageBucketsArgs']] = None,
                 excluded_cloud_storage_locations: Optional[pulumi.Input['ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageLocationsArgs']] = None,
                 included_cloud_storage_buckets: Optional[pulumi.Input['ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageBucketsArgs']] = None,
                 included_cloud_storage_locations: Optional[pulumi.Input['ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageLocationsArgs']] = None):
        """
        :param pulumi.Input['ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageBucketsArgs'] excluded_cloud_storage_buckets: Buckets to exclude from the Storage Intelligence plan.
               Structure is documented below.
        :param pulumi.Input['ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageLocationsArgs'] excluded_cloud_storage_locations: Locations to exclude from the Storage Intelligence plan.
               Structure is documented below.
        :param pulumi.Input['ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageBucketsArgs'] included_cloud_storage_buckets: Buckets to include in the Storage Intelligence plan.
               Structure is documented below.
        :param pulumi.Input['ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageLocationsArgs'] included_cloud_storage_locations: Locations to include in the Storage Intelligence plan.
               Structure is documented below.
        """
        if excluded_cloud_storage_buckets is not None:
            pulumi.set(__self__, "excluded_cloud_storage_buckets", excluded_cloud_storage_buckets)
        if excluded_cloud_storage_locations is not None:
            pulumi.set(__self__, "excluded_cloud_storage_locations", excluded_cloud_storage_locations)
        if included_cloud_storage_buckets is not None:
            pulumi.set(__self__, "included_cloud_storage_buckets", included_cloud_storage_buckets)
        if included_cloud_storage_locations is not None:
            pulumi.set(__self__, "included_cloud_storage_locations", included_cloud_storage_locations)

    @_builtins.property
    @pulumi.getter(name="excludedCloudStorageBuckets")
    def excluded_cloud_storage_buckets(self) -> Optional[pulumi.Input['ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageBucketsArgs']]:
        """
        Buckets to exclude from the Storage Intelligence plan.
        Structure is documented below.
        """
        return pulumi.get(self, "excluded_cloud_storage_buckets")

    @excluded_cloud_storage_buckets.setter
    def excluded_cloud_storage_buckets(self, value: Optional[pulumi.Input['ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageBucketsArgs']]):
        pulumi.set(self, "excluded_cloud_storage_buckets", value)

    @_builtins.property
    @pulumi.getter(name="excludedCloudStorageLocations")
    def excluded_cloud_storage_locations(self) -> Optional[pulumi.Input['ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageLocationsArgs']]:
        """
        Locations to exclude from the Storage Intelligence plan.
        Structure is documented below.
        """
        return pulumi.get(self, "excluded_cloud_storage_locations")

    @excluded_cloud_storage_locations.setter
    def excluded_cloud_storage_locations(self, value: Optional[pulumi.Input['ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageLocationsArgs']]):
        pulumi.set(self, "excluded_cloud_storage_locations", value)

    @_builtins.property
    @pulumi.getter(name="includedCloudStorageBuckets")
    def included_cloud_storage_buckets(self) -> Optional[pulumi.Input['ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageBucketsArgs']]:
        """
        Buckets to include in the Storage Intelligence plan.
        Structure is documented below.
        """
        return pulumi.get(self, "included_cloud_storage_buckets")

    @included_cloud_storage_buckets.setter
    def included_cloud_storage_buckets(self, value: Optional[pulumi.Input['ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageBucketsArgs']]):
        pulumi.set(self, "included_cloud_storage_buckets", value)

    @_builtins.property
    @pulumi.getter(name="includedCloudStorageLocations")
    def included_cloud_storage_locations(self) -> Optional[pulumi.Input['ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageLocationsArgs']]:
        """
        Locations to include in the Storage Intelligence plan.
        Structure is documented below.
        """
        return pulumi.get(self, "included_cloud_storage_locations")

    @included_cloud_storage_locations.setter
    def included_cloud_storage_locations(self, value: Optional[pulumi.Input['ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageLocationsArgs']]):
        pulumi.set(self, "included_cloud_storage_locations", value)


if not MYPY:
    class ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageBucketsArgsDict(TypedDict):
        bucket_id_regexes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of bucket id regexes to exclude in the storage intelligence plan.
        """
elif False:
    ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageBucketsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageBucketsArgs:
    def __init__(__self__, *,
                 bucket_id_regexes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] bucket_id_regexes: List of bucket id regexes to exclude in the storage intelligence plan.
        """
        pulumi.set(__self__, "bucket_id_regexes", bucket_id_regexes)

    @_builtins.property
    @pulumi.getter(name="bucketIdRegexes")
    def bucket_id_regexes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of bucket id regexes to exclude in the storage intelligence plan.
        """
        return pulumi.get(self, "bucket_id_regexes")

    @bucket_id_regexes.setter
    def bucket_id_regexes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "bucket_id_regexes", value)


if not MYPY:
    class ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageLocationsArgsDict(TypedDict):
        locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of locations.
        """
elif False:
    ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlOrganizationIntelligenceConfigFilterExcludedCloudStorageLocationsArgs:
    def __init__(__self__, *,
                 locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] locations: List of locations.
        """
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of locations.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageBucketsArgsDict(TypedDict):
        bucket_id_regexes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of bucket id regexes to exclude in the storage intelligence plan.
        """
elif False:
    ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageBucketsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageBucketsArgs:
    def __init__(__self__, *,
                 bucket_id_regexes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] bucket_id_regexes: List of bucket id regexes to exclude in the storage intelligence plan.
        """
        pulumi.set(__self__, "bucket_id_regexes", bucket_id_regexes)

    @_builtins.property
    @pulumi.getter(name="bucketIdRegexes")
    def bucket_id_regexes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of bucket id regexes to exclude in the storage intelligence plan.
        """
        return pulumi.get(self, "bucket_id_regexes")

    @bucket_id_regexes.setter
    def bucket_id_regexes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "bucket_id_regexes", value)


if not MYPY:
    class ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageLocationsArgsDict(TypedDict):
        locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of locations.
        """
elif False:
    ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlOrganizationIntelligenceConfigFilterIncludedCloudStorageLocationsArgs:
    def __init__(__self__, *,
                 locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] locations: List of locations.
        """
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of locations.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class ControlOrganizationIntelligenceConfigTrialConfigArgsDict(TypedDict):
        expire_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The time at which the trial expires.
        """
elif False:
    ControlOrganizationIntelligenceConfigTrialConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlOrganizationIntelligenceConfigTrialConfigArgs:
    def __init__(__self__, *,
                 expire_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expire_time: (Output)
               The time at which the trial expires.
        """
        if expire_time is not None:
            pulumi.set(__self__, "expire_time", expire_time)

    @_builtins.property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The time at which the trial expires.
        """
        return pulumi.get(self, "expire_time")

    @expire_time.setter
    def expire_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expire_time", value)


if not MYPY:
    class ControlProjectIntelligenceConfigEffectiveIntelligenceConfigArgsDict(TypedDict):
        effective_edition: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The `StorageIntelligence` edition that is applicable for the resource.
        """
        intelligence_config: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The Intelligence config resource that is applied for the target resource.
        """
elif False:
    ControlProjectIntelligenceConfigEffectiveIntelligenceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlProjectIntelligenceConfigEffectiveIntelligenceConfigArgs:
    def __init__(__self__, *,
                 effective_edition: Optional[pulumi.Input[_builtins.str]] = None,
                 intelligence_config: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] effective_edition: (Output)
               The `StorageIntelligence` edition that is applicable for the resource.
        :param pulumi.Input[_builtins.str] intelligence_config: (Output)
               The Intelligence config resource that is applied for the target resource.
        """
        if effective_edition is not None:
            pulumi.set(__self__, "effective_edition", effective_edition)
        if intelligence_config is not None:
            pulumi.set(__self__, "intelligence_config", intelligence_config)

    @_builtins.property
    @pulumi.getter(name="effectiveEdition")
    def effective_edition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The `StorageIntelligence` edition that is applicable for the resource.
        """
        return pulumi.get(self, "effective_edition")

    @effective_edition.setter
    def effective_edition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "effective_edition", value)

    @_builtins.property
    @pulumi.getter(name="intelligenceConfig")
    def intelligence_config(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The Intelligence config resource that is applied for the target resource.
        """
        return pulumi.get(self, "intelligence_config")

    @intelligence_config.setter
    def intelligence_config(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "intelligence_config", value)


if not MYPY:
    class ControlProjectIntelligenceConfigFilterArgsDict(TypedDict):
        excluded_cloud_storage_buckets: NotRequired[pulumi.Input['ControlProjectIntelligenceConfigFilterExcludedCloudStorageBucketsArgsDict']]
        """
        Buckets to exclude from the Storage Intelligence plan.
        Structure is documented below.
        """
        excluded_cloud_storage_locations: NotRequired[pulumi.Input['ControlProjectIntelligenceConfigFilterExcludedCloudStorageLocationsArgsDict']]
        """
        Locations to exclude from the Storage Intelligence plan.
        Structure is documented below.
        """
        included_cloud_storage_buckets: NotRequired[pulumi.Input['ControlProjectIntelligenceConfigFilterIncludedCloudStorageBucketsArgsDict']]
        """
        Buckets to include in the Storage Intelligence plan.
        Structure is documented below.
        """
        included_cloud_storage_locations: NotRequired[pulumi.Input['ControlProjectIntelligenceConfigFilterIncludedCloudStorageLocationsArgsDict']]
        """
        Locations to include in the Storage Intelligence plan.
        Structure is documented below.
        """
elif False:
    ControlProjectIntelligenceConfigFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlProjectIntelligenceConfigFilterArgs:
    def __init__(__self__, *,
                 excluded_cloud_storage_buckets: Optional[pulumi.Input['ControlProjectIntelligenceConfigFilterExcludedCloudStorageBucketsArgs']] = None,
                 excluded_cloud_storage_locations: Optional[pulumi.Input['ControlProjectIntelligenceConfigFilterExcludedCloudStorageLocationsArgs']] = None,
                 included_cloud_storage_buckets: Optional[pulumi.Input['ControlProjectIntelligenceConfigFilterIncludedCloudStorageBucketsArgs']] = None,
                 included_cloud_storage_locations: Optional[pulumi.Input['ControlProjectIntelligenceConfigFilterIncludedCloudStorageLocationsArgs']] = None):
        """
        :param pulumi.Input['ControlProjectIntelligenceConfigFilterExcludedCloudStorageBucketsArgs'] excluded_cloud_storage_buckets: Buckets to exclude from the Storage Intelligence plan.
               Structure is documented below.
        :param pulumi.Input['ControlProjectIntelligenceConfigFilterExcludedCloudStorageLocationsArgs'] excluded_cloud_storage_locations: Locations to exclude from the Storage Intelligence plan.
               Structure is documented below.
        :param pulumi.Input['ControlProjectIntelligenceConfigFilterIncludedCloudStorageBucketsArgs'] included_cloud_storage_buckets: Buckets to include in the Storage Intelligence plan.
               Structure is documented below.
        :param pulumi.Input['ControlProjectIntelligenceConfigFilterIncludedCloudStorageLocationsArgs'] included_cloud_storage_locations: Locations to include in the Storage Intelligence plan.
               Structure is documented below.
        """
        if excluded_cloud_storage_buckets is not None:
            pulumi.set(__self__, "excluded_cloud_storage_buckets", excluded_cloud_storage_buckets)
        if excluded_cloud_storage_locations is not None:
            pulumi.set(__self__, "excluded_cloud_storage_locations", excluded_cloud_storage_locations)
        if included_cloud_storage_buckets is not None:
            pulumi.set(__self__, "included_cloud_storage_buckets", included_cloud_storage_buckets)
        if included_cloud_storage_locations is not None:
            pulumi.set(__self__, "included_cloud_storage_locations", included_cloud_storage_locations)

    @_builtins.property
    @pulumi.getter(name="excludedCloudStorageBuckets")
    def excluded_cloud_storage_buckets(self) -> Optional[pulumi.Input['ControlProjectIntelligenceConfigFilterExcludedCloudStorageBucketsArgs']]:
        """
        Buckets to exclude from the Storage Intelligence plan.
        Structure is documented below.
        """
        return pulumi.get(self, "excluded_cloud_storage_buckets")

    @excluded_cloud_storage_buckets.setter
    def excluded_cloud_storage_buckets(self, value: Optional[pulumi.Input['ControlProjectIntelligenceConfigFilterExcludedCloudStorageBucketsArgs']]):
        pulumi.set(self, "excluded_cloud_storage_buckets", value)

    @_builtins.property
    @pulumi.getter(name="excludedCloudStorageLocations")
    def excluded_cloud_storage_locations(self) -> Optional[pulumi.Input['ControlProjectIntelligenceConfigFilterExcludedCloudStorageLocationsArgs']]:
        """
        Locations to exclude from the Storage Intelligence plan.
        Structure is documented below.
        """
        return pulumi.get(self, "excluded_cloud_storage_locations")

    @excluded_cloud_storage_locations.setter
    def excluded_cloud_storage_locations(self, value: Optional[pulumi.Input['ControlProjectIntelligenceConfigFilterExcludedCloudStorageLocationsArgs']]):
        pulumi.set(self, "excluded_cloud_storage_locations", value)

    @_builtins.property
    @pulumi.getter(name="includedCloudStorageBuckets")
    def included_cloud_storage_buckets(self) -> Optional[pulumi.Input['ControlProjectIntelligenceConfigFilterIncludedCloudStorageBucketsArgs']]:
        """
        Buckets to include in the Storage Intelligence plan.
        Structure is documented below.
        """
        return pulumi.get(self, "included_cloud_storage_buckets")

    @included_cloud_storage_buckets.setter
    def included_cloud_storage_buckets(self, value: Optional[pulumi.Input['ControlProjectIntelligenceConfigFilterIncludedCloudStorageBucketsArgs']]):
        pulumi.set(self, "included_cloud_storage_buckets", value)

    @_builtins.property
    @pulumi.getter(name="includedCloudStorageLocations")
    def included_cloud_storage_locations(self) -> Optional[pulumi.Input['ControlProjectIntelligenceConfigFilterIncludedCloudStorageLocationsArgs']]:
        """
        Locations to include in the Storage Intelligence plan.
        Structure is documented below.
        """
        return pulumi.get(self, "included_cloud_storage_locations")

    @included_cloud_storage_locations.setter
    def included_cloud_storage_locations(self, value: Optional[pulumi.Input['ControlProjectIntelligenceConfigFilterIncludedCloudStorageLocationsArgs']]):
        pulumi.set(self, "included_cloud_storage_locations", value)


if not MYPY:
    class ControlProjectIntelligenceConfigFilterExcludedCloudStorageBucketsArgsDict(TypedDict):
        bucket_id_regexes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of bucket id regexes to exclude in the storage intelligence plan.
        """
elif False:
    ControlProjectIntelligenceConfigFilterExcludedCloudStorageBucketsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlProjectIntelligenceConfigFilterExcludedCloudStorageBucketsArgs:
    def __init__(__self__, *,
                 bucket_id_regexes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] bucket_id_regexes: List of bucket id regexes to exclude in the storage intelligence plan.
        """
        pulumi.set(__self__, "bucket_id_regexes", bucket_id_regexes)

    @_builtins.property
    @pulumi.getter(name="bucketIdRegexes")
    def bucket_id_regexes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of bucket id regexes to exclude in the storage intelligence plan.
        """
        return pulumi.get(self, "bucket_id_regexes")

    @bucket_id_regexes.setter
    def bucket_id_regexes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "bucket_id_regexes", value)


if not MYPY:
    class ControlProjectIntelligenceConfigFilterExcludedCloudStorageLocationsArgsDict(TypedDict):
        locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of locations.
        """
elif False:
    ControlProjectIntelligenceConfigFilterExcludedCloudStorageLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlProjectIntelligenceConfigFilterExcludedCloudStorageLocationsArgs:
    def __init__(__self__, *,
                 locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] locations: List of locations.
        """
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of locations.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class ControlProjectIntelligenceConfigFilterIncludedCloudStorageBucketsArgsDict(TypedDict):
        bucket_id_regexes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of bucket id regexes to exclude in the storage intelligence plan.
        """
elif False:
    ControlProjectIntelligenceConfigFilterIncludedCloudStorageBucketsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlProjectIntelligenceConfigFilterIncludedCloudStorageBucketsArgs:
    def __init__(__self__, *,
                 bucket_id_regexes: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] bucket_id_regexes: List of bucket id regexes to exclude in the storage intelligence plan.
        """
        pulumi.set(__self__, "bucket_id_regexes", bucket_id_regexes)

    @_builtins.property
    @pulumi.getter(name="bucketIdRegexes")
    def bucket_id_regexes(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of bucket id regexes to exclude in the storage intelligence plan.
        """
        return pulumi.get(self, "bucket_id_regexes")

    @bucket_id_regexes.setter
    def bucket_id_regexes(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "bucket_id_regexes", value)


if not MYPY:
    class ControlProjectIntelligenceConfigFilterIncludedCloudStorageLocationsArgsDict(TypedDict):
        locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        List of locations.
        """
elif False:
    ControlProjectIntelligenceConfigFilterIncludedCloudStorageLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlProjectIntelligenceConfigFilterIncludedCloudStorageLocationsArgs:
    def __init__(__self__, *,
                 locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] locations: List of locations.
        """
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        List of locations.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class ControlProjectIntelligenceConfigTrialConfigArgsDict(TypedDict):
        expire_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The time at which the trial expires.
        """
elif False:
    ControlProjectIntelligenceConfigTrialConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ControlProjectIntelligenceConfigTrialConfigArgs:
    def __init__(__self__, *,
                 expire_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expire_time: (Output)
               The time at which the trial expires.
        """
        if expire_time is not None:
            pulumi.set(__self__, "expire_time", expire_time)

    @_builtins.property
    @pulumi.getter(name="expireTime")
    def expire_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The time at which the trial expires.
        """
        return pulumi.get(self, "expire_time")

    @expire_time.setter
    def expire_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expire_time", value)


if not MYPY:
    class DefaultObjectAccessControlProjectTeamArgsDict(TypedDict):
        project_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        The project team associated with the entity
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The team.
        Possible values are: `editors`, `owners`, `viewers`.
        """
elif False:
    DefaultObjectAccessControlProjectTeamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DefaultObjectAccessControlProjectTeamArgs:
    def __init__(__self__, *,
                 project_number: Optional[pulumi.Input[_builtins.str]] = None,
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] project_number: The project team associated with the entity
        :param pulumi.Input[_builtins.str] team: The team.
               Possible values are: `editors`, `owners`, `viewers`.
        """
        if project_number is not None:
            pulumi.set(__self__, "project_number", project_number)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="projectNumber")
    def project_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The project team associated with the entity
        """
        return pulumi.get(self, "project_number")

    @project_number.setter
    def project_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_number", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The team.
        Possible values are: `editors`, `owners`, `viewers`.
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class InsightsDatasetConfigExcludeCloudStorageBucketsArgsDict(TypedDict):
        cloud_storage_buckets: pulumi.Input[Sequence[pulumi.Input['InsightsDatasetConfigExcludeCloudStorageBucketsCloudStorageBucketArgsDict']]]
        """
        The list of cloud storage buckets/bucket prefix regexes to exclude in the DatasetConfig.
        Structure is documented below.
        """
elif False:
    InsightsDatasetConfigExcludeCloudStorageBucketsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InsightsDatasetConfigExcludeCloudStorageBucketsArgs:
    def __init__(__self__, *,
                 cloud_storage_buckets: pulumi.Input[Sequence[pulumi.Input['InsightsDatasetConfigExcludeCloudStorageBucketsCloudStorageBucketArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['InsightsDatasetConfigExcludeCloudStorageBucketsCloudStorageBucketArgs']]] cloud_storage_buckets: The list of cloud storage buckets/bucket prefix regexes to exclude in the DatasetConfig.
               Structure is documented below.
        """
        pulumi.set(__self__, "cloud_storage_buckets", cloud_storage_buckets)

    @_builtins.property
    @pulumi.getter(name="cloudStorageBuckets")
    def cloud_storage_buckets(self) -> pulumi.Input[Sequence[pulumi.Input['InsightsDatasetConfigExcludeCloudStorageBucketsCloudStorageBucketArgs']]]:
        """
        The list of cloud storage buckets/bucket prefix regexes to exclude in the DatasetConfig.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_storage_buckets")

    @cloud_storage_buckets.setter
    def cloud_storage_buckets(self, value: pulumi.Input[Sequence[pulumi.Input['InsightsDatasetConfigExcludeCloudStorageBucketsCloudStorageBucketArgs']]]):
        pulumi.set(self, "cloud_storage_buckets", value)


if not MYPY:
    class InsightsDatasetConfigExcludeCloudStorageBucketsCloudStorageBucketArgsDict(TypedDict):
        bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The list of cloud storage bucket names to exclude in the DatasetConfig.
        Exactly one of the bucket_name and bucket_prefix_regex should be specified.
        """
        bucket_prefix_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        The list of regex patterns for bucket names matching the regex.
        Regex should follow the syntax specified in google/re2 on GitHub.
        Exactly one of the bucket_name and bucket_prefix_regex should be specified.
        """
elif False:
    InsightsDatasetConfigExcludeCloudStorageBucketsCloudStorageBucketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InsightsDatasetConfigExcludeCloudStorageBucketsCloudStorageBucketArgs:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_prefix_regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: The list of cloud storage bucket names to exclude in the DatasetConfig.
               Exactly one of the bucket_name and bucket_prefix_regex should be specified.
        :param pulumi.Input[_builtins.str] bucket_prefix_regex: The list of regex patterns for bucket names matching the regex.
               Regex should follow the syntax specified in google/re2 on GitHub.
               Exactly one of the bucket_name and bucket_prefix_regex should be specified.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_prefix_regex is not None:
            pulumi.set(__self__, "bucket_prefix_regex", bucket_prefix_regex)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The list of cloud storage bucket names to exclude in the DatasetConfig.
        Exactly one of the bucket_name and bucket_prefix_regex should be specified.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="bucketPrefixRegex")
    def bucket_prefix_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The list of regex patterns for bucket names matching the regex.
        Regex should follow the syntax specified in google/re2 on GitHub.
        Exactly one of the bucket_name and bucket_prefix_regex should be specified.
        """
        return pulumi.get(self, "bucket_prefix_regex")

    @bucket_prefix_regex.setter
    def bucket_prefix_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_prefix_regex", value)


if not MYPY:
    class InsightsDatasetConfigExcludeCloudStorageLocationsArgsDict(TypedDict):
        locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The list of cloud storage locations to exclude in the DatasetConfig.
        """
elif False:
    InsightsDatasetConfigExcludeCloudStorageLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InsightsDatasetConfigExcludeCloudStorageLocationsArgs:
    def __init__(__self__, *,
                 locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] locations: The list of cloud storage locations to exclude in the DatasetConfig.
        """
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The list of cloud storage locations to exclude in the DatasetConfig.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class InsightsDatasetConfigIdentityArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        Type of identity to use for the DatasetConfig.
        Possible values are: `IDENTITY_TYPE_PER_CONFIG`, `IDENTITY_TYPE_PER_PROJECT`.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Name of the identity.
        """
elif False:
    InsightsDatasetConfigIdentityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InsightsDatasetConfigIdentityArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] type: Type of identity to use for the DatasetConfig.
               Possible values are: `IDENTITY_TYPE_PER_CONFIG`, `IDENTITY_TYPE_PER_PROJECT`.
        :param pulumi.Input[_builtins.str] name: (Output)
               Name of the identity.
        """
        pulumi.set(__self__, "type", type)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        Type of identity to use for the DatasetConfig.
        Possible values are: `IDENTITY_TYPE_PER_CONFIG`, `IDENTITY_TYPE_PER_PROJECT`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Name of the identity.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class InsightsDatasetConfigIncludeCloudStorageBucketsArgsDict(TypedDict):
        cloud_storage_buckets: pulumi.Input[Sequence[pulumi.Input['InsightsDatasetConfigIncludeCloudStorageBucketsCloudStorageBucketArgsDict']]]
        """
        The list of cloud storage buckets/bucket prefix regexes to include in the DatasetConfig.
        Structure is documented below.
        """
elif False:
    InsightsDatasetConfigIncludeCloudStorageBucketsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InsightsDatasetConfigIncludeCloudStorageBucketsArgs:
    def __init__(__self__, *,
                 cloud_storage_buckets: pulumi.Input[Sequence[pulumi.Input['InsightsDatasetConfigIncludeCloudStorageBucketsCloudStorageBucketArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['InsightsDatasetConfigIncludeCloudStorageBucketsCloudStorageBucketArgs']]] cloud_storage_buckets: The list of cloud storage buckets/bucket prefix regexes to include in the DatasetConfig.
               Structure is documented below.
        """
        pulumi.set(__self__, "cloud_storage_buckets", cloud_storage_buckets)

    @_builtins.property
    @pulumi.getter(name="cloudStorageBuckets")
    def cloud_storage_buckets(self) -> pulumi.Input[Sequence[pulumi.Input['InsightsDatasetConfigIncludeCloudStorageBucketsCloudStorageBucketArgs']]]:
        """
        The list of cloud storage buckets/bucket prefix regexes to include in the DatasetConfig.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_storage_buckets")

    @cloud_storage_buckets.setter
    def cloud_storage_buckets(self, value: pulumi.Input[Sequence[pulumi.Input['InsightsDatasetConfigIncludeCloudStorageBucketsCloudStorageBucketArgs']]]):
        pulumi.set(self, "cloud_storage_buckets", value)


if not MYPY:
    class InsightsDatasetConfigIncludeCloudStorageBucketsCloudStorageBucketArgsDict(TypedDict):
        bucket_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The list of cloud storage bucket names to exclude in the DatasetConfig.
        Exactly one of the bucket_name and bucket_prefix_regex should be specified.
        """
        bucket_prefix_regex: NotRequired[pulumi.Input[_builtins.str]]
        """
        The list of regex patterns for bucket names matching the regex.
        Regex should follow the syntax specified in google/re2 on GitHub.
        Exactly one of the bucket_name and bucket_prefix_regex should be specified.
        """
elif False:
    InsightsDatasetConfigIncludeCloudStorageBucketsCloudStorageBucketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InsightsDatasetConfigIncludeCloudStorageBucketsCloudStorageBucketArgs:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[_builtins.str]] = None,
                 bucket_prefix_regex: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: The list of cloud storage bucket names to exclude in the DatasetConfig.
               Exactly one of the bucket_name and bucket_prefix_regex should be specified.
        :param pulumi.Input[_builtins.str] bucket_prefix_regex: The list of regex patterns for bucket names matching the regex.
               Regex should follow the syntax specified in google/re2 on GitHub.
               Exactly one of the bucket_name and bucket_prefix_regex should be specified.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if bucket_prefix_regex is not None:
            pulumi.set(__self__, "bucket_prefix_regex", bucket_prefix_regex)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The list of cloud storage bucket names to exclude in the DatasetConfig.
        Exactly one of the bucket_name and bucket_prefix_regex should be specified.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="bucketPrefixRegex")
    def bucket_prefix_regex(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The list of regex patterns for bucket names matching the regex.
        Regex should follow the syntax specified in google/re2 on GitHub.
        Exactly one of the bucket_name and bucket_prefix_regex should be specified.
        """
        return pulumi.get(self, "bucket_prefix_regex")

    @bucket_prefix_regex.setter
    def bucket_prefix_regex(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket_prefix_regex", value)


if not MYPY:
    class InsightsDatasetConfigIncludeCloudStorageLocationsArgsDict(TypedDict):
        locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The list of cloud storage locations to include in the DatasetConfig.
        """
elif False:
    InsightsDatasetConfigIncludeCloudStorageLocationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InsightsDatasetConfigIncludeCloudStorageLocationsArgs:
    def __init__(__self__, *,
                 locations: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] locations: The list of cloud storage locations to include in the DatasetConfig.
        """
        pulumi.set(__self__, "locations", locations)

    @_builtins.property
    @pulumi.getter
    def locations(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The list of cloud storage locations to include in the DatasetConfig.
        """
        return pulumi.get(self, "locations")

    @locations.setter
    def locations(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "locations", value)


if not MYPY:
    class InsightsDatasetConfigLinkArgsDict(TypedDict):
        dataset: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Dataset name for the linked DatasetConfig.
        """
        linked: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        State of the linked DatasetConfig.
        """
elif False:
    InsightsDatasetConfigLinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InsightsDatasetConfigLinkArgs:
    def __init__(__self__, *,
                 dataset: Optional[pulumi.Input[_builtins.str]] = None,
                 linked: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] dataset: (Output)
               Dataset name for the linked DatasetConfig.
        :param pulumi.Input[_builtins.bool] linked: (Output)
               State of the linked DatasetConfig.
        """
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if linked is not None:
            pulumi.set(__self__, "linked", linked)

    @_builtins.property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Dataset name for the linked DatasetConfig.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dataset", value)

    @_builtins.property
    @pulumi.getter
    def linked(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        State of the linked DatasetConfig.
        """
        return pulumi.get(self, "linked")

    @linked.setter
    def linked(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "linked", value)


if not MYPY:
    class InsightsDatasetConfigSourceFoldersArgsDict(TypedDict):
        folder_numbers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of folder numbers to include in the DatasetConfig.
        """
elif False:
    InsightsDatasetConfigSourceFoldersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InsightsDatasetConfigSourceFoldersArgs:
    def __init__(__self__, *,
                 folder_numbers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] folder_numbers: The list of folder numbers to include in the DatasetConfig.
        """
        if folder_numbers is not None:
            pulumi.set(__self__, "folder_numbers", folder_numbers)

    @_builtins.property
    @pulumi.getter(name="folderNumbers")
    def folder_numbers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of folder numbers to include in the DatasetConfig.
        """
        return pulumi.get(self, "folder_numbers")

    @folder_numbers.setter
    def folder_numbers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "folder_numbers", value)


if not MYPY:
    class InsightsDatasetConfigSourceProjectsArgsDict(TypedDict):
        project_numbers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of project numbers to include in the DatasetConfig.
        """
elif False:
    InsightsDatasetConfigSourceProjectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InsightsDatasetConfigSourceProjectsArgs:
    def __init__(__self__, *,
                 project_numbers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] project_numbers: The list of project numbers to include in the DatasetConfig.
        """
        if project_numbers is not None:
            pulumi.set(__self__, "project_numbers", project_numbers)

    @_builtins.property
    @pulumi.getter(name="projectNumbers")
    def project_numbers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of project numbers to include in the DatasetConfig.
        """
        return pulumi.get(self, "project_numbers")

    @project_numbers.setter
    def project_numbers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "project_numbers", value)


if not MYPY:
    class InsightsReportConfigCsvOptionsArgsDict(TypedDict):
        delimiter: NotRequired[pulumi.Input[_builtins.str]]
        """
        The delimiter used to separate the fields in the inventory report CSV file.
        """
        header_required: NotRequired[pulumi.Input[_builtins.bool]]
        """
        The boolean that indicates whether or not headers are included in the inventory report CSV file.
        """
        record_separator: NotRequired[pulumi.Input[_builtins.str]]
        """
        The character used to separate the records in the inventory report CSV file.
        """
elif False:
    InsightsReportConfigCsvOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InsightsReportConfigCsvOptionsArgs:
    def __init__(__self__, *,
                 delimiter: Optional[pulumi.Input[_builtins.str]] = None,
                 header_required: Optional[pulumi.Input[_builtins.bool]] = None,
                 record_separator: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] delimiter: The delimiter used to separate the fields in the inventory report CSV file.
        :param pulumi.Input[_builtins.bool] header_required: The boolean that indicates whether or not headers are included in the inventory report CSV file.
        :param pulumi.Input[_builtins.str] record_separator: The character used to separate the records in the inventory report CSV file.
        """
        if delimiter is not None:
            pulumi.set(__self__, "delimiter", delimiter)
        if header_required is not None:
            pulumi.set(__self__, "header_required", header_required)
        if record_separator is not None:
            pulumi.set(__self__, "record_separator", record_separator)

    @_builtins.property
    @pulumi.getter
    def delimiter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The delimiter used to separate the fields in the inventory report CSV file.
        """
        return pulumi.get(self, "delimiter")

    @delimiter.setter
    def delimiter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delimiter", value)

    @_builtins.property
    @pulumi.getter(name="headerRequired")
    def header_required(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        The boolean that indicates whether or not headers are included in the inventory report CSV file.
        """
        return pulumi.get(self, "header_required")

    @header_required.setter
    def header_required(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "header_required", value)

    @_builtins.property
    @pulumi.getter(name="recordSeparator")
    def record_separator(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The character used to separate the records in the inventory report CSV file.
        """
        return pulumi.get(self, "record_separator")

    @record_separator.setter
    def record_separator(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "record_separator", value)


if not MYPY:
    class InsightsReportConfigFrequencyOptionsArgsDict(TypedDict):
        end_date: pulumi.Input['InsightsReportConfigFrequencyOptionsEndDateArgsDict']
        """
        The date to stop generating inventory reports. For example, {"day": 15, "month": 9, "year": 2022}.
        Structure is documented below.
        """
        frequency: pulumi.Input[_builtins.str]
        """
        The frequency in which inventory reports are generated. Values are DAILY or WEEKLY.
        Possible values are: `DAILY`, `WEEKLY`.
        """
        start_date: pulumi.Input['InsightsReportConfigFrequencyOptionsStartDateArgsDict']
        """
        The date to start generating inventory reports. For example, {"day": 15, "month": 8, "year": 2022}.
        Structure is documented below.
        """
elif False:
    InsightsReportConfigFrequencyOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InsightsReportConfigFrequencyOptionsArgs:
    def __init__(__self__, *,
                 end_date: pulumi.Input['InsightsReportConfigFrequencyOptionsEndDateArgs'],
                 frequency: pulumi.Input[_builtins.str],
                 start_date: pulumi.Input['InsightsReportConfigFrequencyOptionsStartDateArgs']):
        """
        :param pulumi.Input['InsightsReportConfigFrequencyOptionsEndDateArgs'] end_date: The date to stop generating inventory reports. For example, {"day": 15, "month": 9, "year": 2022}.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] frequency: The frequency in which inventory reports are generated. Values are DAILY or WEEKLY.
               Possible values are: `DAILY`, `WEEKLY`.
        :param pulumi.Input['InsightsReportConfigFrequencyOptionsStartDateArgs'] start_date: The date to start generating inventory reports. For example, {"day": 15, "month": 8, "year": 2022}.
               Structure is documented below.
        """
        pulumi.set(__self__, "end_date", end_date)
        pulumi.set(__self__, "frequency", frequency)
        pulumi.set(__self__, "start_date", start_date)

    @_builtins.property
    @pulumi.getter(name="endDate")
    def end_date(self) -> pulumi.Input['InsightsReportConfigFrequencyOptionsEndDateArgs']:
        """
        The date to stop generating inventory reports. For example, {"day": 15, "month": 9, "year": 2022}.
        Structure is documented below.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: pulumi.Input['InsightsReportConfigFrequencyOptionsEndDateArgs']):
        pulumi.set(self, "end_date", value)

    @_builtins.property
    @pulumi.getter
    def frequency(self) -> pulumi.Input[_builtins.str]:
        """
        The frequency in which inventory reports are generated. Values are DAILY or WEEKLY.
        Possible values are: `DAILY`, `WEEKLY`.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "frequency", value)

    @_builtins.property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input['InsightsReportConfigFrequencyOptionsStartDateArgs']:
        """
        The date to start generating inventory reports. For example, {"day": 15, "month": 8, "year": 2022}.
        Structure is documented below.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input['InsightsReportConfigFrequencyOptionsStartDateArgs']):
        pulumi.set(self, "start_date", value)


if not MYPY:
    class InsightsReportConfigFrequencyOptionsEndDateArgsDict(TypedDict):
        day: pulumi.Input[_builtins.int]
        """
        The day of the month to stop generating inventory reports.
        """
        month: pulumi.Input[_builtins.int]
        """
        The month to stop generating inventory reports.
        """
        year: pulumi.Input[_builtins.int]
        """
        The year to stop generating inventory reports
        """
elif False:
    InsightsReportConfigFrequencyOptionsEndDateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InsightsReportConfigFrequencyOptionsEndDateArgs:
    def __init__(__self__, *,
                 day: pulumi.Input[_builtins.int],
                 month: pulumi.Input[_builtins.int],
                 year: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] day: The day of the month to stop generating inventory reports.
        :param pulumi.Input[_builtins.int] month: The month to stop generating inventory reports.
        :param pulumi.Input[_builtins.int] year: The year to stop generating inventory reports
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "month", month)
        pulumi.set(__self__, "year", year)

    @_builtins.property
    @pulumi.getter
    def day(self) -> pulumi.Input[_builtins.int]:
        """
        The day of the month to stop generating inventory reports.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "day", value)

    @_builtins.property
    @pulumi.getter
    def month(self) -> pulumi.Input[_builtins.int]:
        """
        The month to stop generating inventory reports.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "month", value)

    @_builtins.property
    @pulumi.getter
    def year(self) -> pulumi.Input[_builtins.int]:
        """
        The year to stop generating inventory reports
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "year", value)


if not MYPY:
    class InsightsReportConfigFrequencyOptionsStartDateArgsDict(TypedDict):
        day: pulumi.Input[_builtins.int]
        """
        The day of the month to start generating inventory reports.
        """
        month: pulumi.Input[_builtins.int]
        """
        The month to start generating inventory reports.
        """
        year: pulumi.Input[_builtins.int]
        """
        The year to start generating inventory reports
        """
elif False:
    InsightsReportConfigFrequencyOptionsStartDateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InsightsReportConfigFrequencyOptionsStartDateArgs:
    def __init__(__self__, *,
                 day: pulumi.Input[_builtins.int],
                 month: pulumi.Input[_builtins.int],
                 year: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] day: The day of the month to start generating inventory reports.
        :param pulumi.Input[_builtins.int] month: The month to start generating inventory reports.
        :param pulumi.Input[_builtins.int] year: The year to start generating inventory reports
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "month", month)
        pulumi.set(__self__, "year", year)

    @_builtins.property
    @pulumi.getter
    def day(self) -> pulumi.Input[_builtins.int]:
        """
        The day of the month to start generating inventory reports.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "day", value)

    @_builtins.property
    @pulumi.getter
    def month(self) -> pulumi.Input[_builtins.int]:
        """
        The month to start generating inventory reports.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "month", value)

    @_builtins.property
    @pulumi.getter
    def year(self) -> pulumi.Input[_builtins.int]:
        """
        The year to start generating inventory reports
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "year", value)


if not MYPY:
    class InsightsReportConfigObjectMetadataReportOptionsArgsDict(TypedDict):
        metadata_fields: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The metadata fields included in an inventory report.
        """
        storage_destination_options: pulumi.Input['InsightsReportConfigObjectMetadataReportOptionsStorageDestinationOptionsArgsDict']
        """
        Options for where the inventory reports are stored.
        Structure is documented below.
        """
        storage_filters: NotRequired[pulumi.Input['InsightsReportConfigObjectMetadataReportOptionsStorageFiltersArgsDict']]
        """
        A nested object resource.
        Structure is documented below.
        """
elif False:
    InsightsReportConfigObjectMetadataReportOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InsightsReportConfigObjectMetadataReportOptionsArgs:
    def __init__(__self__, *,
                 metadata_fields: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 storage_destination_options: pulumi.Input['InsightsReportConfigObjectMetadataReportOptionsStorageDestinationOptionsArgs'],
                 storage_filters: Optional[pulumi.Input['InsightsReportConfigObjectMetadataReportOptionsStorageFiltersArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] metadata_fields: The metadata fields included in an inventory report.
        :param pulumi.Input['InsightsReportConfigObjectMetadataReportOptionsStorageDestinationOptionsArgs'] storage_destination_options: Options for where the inventory reports are stored.
               Structure is documented below.
        :param pulumi.Input['InsightsReportConfigObjectMetadataReportOptionsStorageFiltersArgs'] storage_filters: A nested object resource.
               Structure is documented below.
        """
        pulumi.set(__self__, "metadata_fields", metadata_fields)
        pulumi.set(__self__, "storage_destination_options", storage_destination_options)
        if storage_filters is not None:
            pulumi.set(__self__, "storage_filters", storage_filters)

    @_builtins.property
    @pulumi.getter(name="metadataFields")
    def metadata_fields(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The metadata fields included in an inventory report.
        """
        return pulumi.get(self, "metadata_fields")

    @metadata_fields.setter
    def metadata_fields(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "metadata_fields", value)

    @_builtins.property
    @pulumi.getter(name="storageDestinationOptions")
    def storage_destination_options(self) -> pulumi.Input['InsightsReportConfigObjectMetadataReportOptionsStorageDestinationOptionsArgs']:
        """
        Options for where the inventory reports are stored.
        Structure is documented below.
        """
        return pulumi.get(self, "storage_destination_options")

    @storage_destination_options.setter
    def storage_destination_options(self, value: pulumi.Input['InsightsReportConfigObjectMetadataReportOptionsStorageDestinationOptionsArgs']):
        pulumi.set(self, "storage_destination_options", value)

    @_builtins.property
    @pulumi.getter(name="storageFilters")
    def storage_filters(self) -> Optional[pulumi.Input['InsightsReportConfigObjectMetadataReportOptionsStorageFiltersArgs']]:
        """
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "storage_filters")

    @storage_filters.setter
    def storage_filters(self, value: Optional[pulumi.Input['InsightsReportConfigObjectMetadataReportOptionsStorageFiltersArgs']]):
        pulumi.set(self, "storage_filters", value)


if not MYPY:
    class InsightsReportConfigObjectMetadataReportOptionsStorageDestinationOptionsArgsDict(TypedDict):
        bucket: pulumi.Input[_builtins.str]
        """
        The destination bucket that stores the generated inventory reports.
        """
        destination_path: NotRequired[pulumi.Input[_builtins.str]]
        """
        The path within the destination bucket to store generated inventory reports.
        """
elif False:
    InsightsReportConfigObjectMetadataReportOptionsStorageDestinationOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InsightsReportConfigObjectMetadataReportOptionsStorageDestinationOptionsArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[_builtins.str],
                 destination_path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: The destination bucket that stores the generated inventory reports.
        :param pulumi.Input[_builtins.str] destination_path: The path within the destination bucket to store generated inventory reports.
        """
        pulumi.set(__self__, "bucket", bucket)
        if destination_path is not None:
            pulumi.set(__self__, "destination_path", destination_path)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[_builtins.str]:
        """
        The destination bucket that stores the generated inventory reports.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket", value)

    @_builtins.property
    @pulumi.getter(name="destinationPath")
    def destination_path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The path within the destination bucket to store generated inventory reports.
        """
        return pulumi.get(self, "destination_path")

    @destination_path.setter
    def destination_path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "destination_path", value)


if not MYPY:
    class InsightsReportConfigObjectMetadataReportOptionsStorageFiltersArgsDict(TypedDict):
        bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        The filter to use when specifying which bucket to generate inventory reports for.
        """
elif False:
    InsightsReportConfigObjectMetadataReportOptionsStorageFiltersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InsightsReportConfigObjectMetadataReportOptionsStorageFiltersArgs:
    def __init__(__self__, *,
                 bucket: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket: The filter to use when specifying which bucket to generate inventory reports for.
        """
        if bucket is not None:
            pulumi.set(__self__, "bucket", bucket)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The filter to use when specifying which bucket to generate inventory reports for.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "bucket", value)


if not MYPY:
    class InsightsReportConfigParquetOptionsArgsDict(TypedDict):
        pass
elif False:
    InsightsReportConfigParquetOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InsightsReportConfigParquetOptionsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ManagedFolderIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[_builtins.str]
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        title: pulumi.Input[_builtins.str]
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ManagedFolderIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedFolderIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 title: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expression: Textual representation of an expression in Common Expression Language syntax.
        :param pulumi.Input[_builtins.str] title: A title for the expression, i.e. a short string describing its purpose.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> pulumi.Input[_builtins.str]:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class ManagedFolderIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[_builtins.str]
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        title: pulumi.Input[_builtins.str]
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    ManagedFolderIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagedFolderIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 title: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] expression: Textual representation of an expression in Common Expression Language syntax.
        :param pulumi.Input[_builtins.str] title: A title for the expression, i.e. a short string describing its purpose.
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> pulumi.Input[_builtins.str]:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class ObjectAccessControlProjectTeamArgsDict(TypedDict):
        project_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        The project team associated with the entity
        """
        team: NotRequired[pulumi.Input[_builtins.str]]
        """
        The team.
        Possible values are: `editors`, `owners`, `viewers`.
        """
elif False:
    ObjectAccessControlProjectTeamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ObjectAccessControlProjectTeamArgs:
    def __init__(__self__, *,
                 project_number: Optional[pulumi.Input[_builtins.str]] = None,
                 team: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] project_number: The project team associated with the entity
        :param pulumi.Input[_builtins.str] team: The team.
               Possible values are: `editors`, `owners`, `viewers`.
        """
        if project_number is not None:
            pulumi.set(__self__, "project_number", project_number)
        if team is not None:
            pulumi.set(__self__, "team", team)

    @_builtins.property
    @pulumi.getter(name="projectNumber")
    def project_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The project team associated with the entity
        """
        return pulumi.get(self, "project_number")

    @project_number.setter
    def project_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_number", value)

    @_builtins.property
    @pulumi.getter
    def team(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The team.
        Possible values are: `editors`, `owners`, `viewers`.
        """
        return pulumi.get(self, "team")

    @team.setter
    def team(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "team", value)


if not MYPY:
    class TransferAgentPoolBandwidthLimitArgsDict(TypedDict):
        limit_mbps: pulumi.Input[_builtins.str]
        """
        Bandwidth rate in megabytes per second, distributed across all the agents in the pool.
        """
elif False:
    TransferAgentPoolBandwidthLimitArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferAgentPoolBandwidthLimitArgs:
    def __init__(__self__, *,
                 limit_mbps: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] limit_mbps: Bandwidth rate in megabytes per second, distributed across all the agents in the pool.
        """
        pulumi.set(__self__, "limit_mbps", limit_mbps)

    @_builtins.property
    @pulumi.getter(name="limitMbps")
    def limit_mbps(self) -> pulumi.Input[_builtins.str]:
        """
        Bandwidth rate in megabytes per second, distributed across all the agents in the pool.
        """
        return pulumi.get(self, "limit_mbps")

    @limit_mbps.setter
    def limit_mbps(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "limit_mbps", value)


if not MYPY:
    class TransferJobEventStreamArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Specifies a unique name of the resource such as AWS SQS ARN in the form 'arn:aws:sqs:region:account_id:queue_name', or Pub/Sub subscription resource name in the form 'projects/{project}/subscriptions/{sub}'.
        """
        event_stream_expiration_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the data and time at which Storage Transfer Service stops listening for events from this stream. After this time, any transfers in progress will complete, but no new transfers are initiated.A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        event_stream_start_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the date and time that Storage Transfer Service starts listening for events from this stream. If no start time is specified or start time is in the past, Storage Transfer Service starts listening immediately. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
elif False:
    TransferJobEventStreamArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobEventStreamArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 event_stream_expiration_time: Optional[pulumi.Input[_builtins.str]] = None,
                 event_stream_start_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Specifies a unique name of the resource such as AWS SQS ARN in the form 'arn:aws:sqs:region:account_id:queue_name', or Pub/Sub subscription resource name in the form 'projects/{project}/subscriptions/{sub}'.
        :param pulumi.Input[_builtins.str] event_stream_expiration_time: Specifies the data and time at which Storage Transfer Service stops listening for events from this stream. After this time, any transfers in progress will complete, but no new transfers are initiated.A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        :param pulumi.Input[_builtins.str] event_stream_start_time: Specifies the date and time that Storage Transfer Service starts listening for events from this stream. If no start time is specified or start time is in the past, Storage Transfer Service starts listening immediately. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        pulumi.set(__self__, "name", name)
        if event_stream_expiration_time is not None:
            pulumi.set(__self__, "event_stream_expiration_time", event_stream_expiration_time)
        if event_stream_start_time is not None:
            pulumi.set(__self__, "event_stream_start_time", event_stream_start_time)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Specifies a unique name of the resource such as AWS SQS ARN in the form 'arn:aws:sqs:region:account_id:queue_name', or Pub/Sub subscription resource name in the form 'projects/{project}/subscriptions/{sub}'.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="eventStreamExpirationTime")
    def event_stream_expiration_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the data and time at which Storage Transfer Service stops listening for events from this stream. After this time, any transfers in progress will complete, but no new transfers are initiated.A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "event_stream_expiration_time")

    @event_stream_expiration_time.setter
    def event_stream_expiration_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_stream_expiration_time", value)

    @_builtins.property
    @pulumi.getter(name="eventStreamStartTime")
    def event_stream_start_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the date and time that Storage Transfer Service starts listening for events from this stream. If no start time is specified or start time is in the past, Storage Transfer Service starts listening immediately. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "event_stream_start_time")

    @event_stream_start_time.setter
    def event_stream_start_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "event_stream_start_time", value)


if not MYPY:
    class TransferJobLoggingConfigArgsDict(TypedDict):
        enable_on_prem_gcs_transfer_logs: NotRequired[pulumi.Input[_builtins.bool]]
        """
        For transfers with a PosixFilesystem source, this option enables the Cloud Storage transfer logs for this transfer.
        """
        log_action_states: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        States in which logActions are logged. Not supported for transfers with PosifxFilesystem data sources; use enable_on_prem_gcs_transfer_logs instead.
        """
        log_actions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies the actions to be logged. Not supported for transfers with PosifxFilesystem data sources; use enable_on_prem_gcs_transfer_logs instead.
        """
elif False:
    TransferJobLoggingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobLoggingConfigArgs:
    def __init__(__self__, *,
                 enable_on_prem_gcs_transfer_logs: Optional[pulumi.Input[_builtins.bool]] = None,
                 log_action_states: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 log_actions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_on_prem_gcs_transfer_logs: For transfers with a PosixFilesystem source, this option enables the Cloud Storage transfer logs for this transfer.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] log_action_states: States in which logActions are logged. Not supported for transfers with PosifxFilesystem data sources; use enable_on_prem_gcs_transfer_logs instead.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] log_actions: Specifies the actions to be logged. Not supported for transfers with PosifxFilesystem data sources; use enable_on_prem_gcs_transfer_logs instead.
        """
        if enable_on_prem_gcs_transfer_logs is not None:
            pulumi.set(__self__, "enable_on_prem_gcs_transfer_logs", enable_on_prem_gcs_transfer_logs)
        if log_action_states is not None:
            pulumi.set(__self__, "log_action_states", log_action_states)
        if log_actions is not None:
            pulumi.set(__self__, "log_actions", log_actions)

    @_builtins.property
    @pulumi.getter(name="enableOnPremGcsTransferLogs")
    def enable_on_prem_gcs_transfer_logs(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        For transfers with a PosixFilesystem source, this option enables the Cloud Storage transfer logs for this transfer.
        """
        return pulumi.get(self, "enable_on_prem_gcs_transfer_logs")

    @enable_on_prem_gcs_transfer_logs.setter
    def enable_on_prem_gcs_transfer_logs(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_on_prem_gcs_transfer_logs", value)

    @_builtins.property
    @pulumi.getter(name="logActionStates")
    def log_action_states(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        States in which logActions are logged. Not supported for transfers with PosifxFilesystem data sources; use enable_on_prem_gcs_transfer_logs instead.
        """
        return pulumi.get(self, "log_action_states")

    @log_action_states.setter
    def log_action_states(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "log_action_states", value)

    @_builtins.property
    @pulumi.getter(name="logActions")
    def log_actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies the actions to be logged. Not supported for transfers with PosifxFilesystem data sources; use enable_on_prem_gcs_transfer_logs instead.
        """
        return pulumi.get(self, "log_actions")

    @log_actions.setter
    def log_actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "log_actions", value)


if not MYPY:
    class TransferJobNotificationConfigArgsDict(TypedDict):
        payload_format: pulumi.Input[_builtins.str]
        """
        The desired format of the notification message payloads. One of "NONE" or "JSON".
        """
        pubsub_topic: pulumi.Input[_builtins.str]
        """
        The Topic.name of the Pub/Sub topic to which to publish notifications. Must be of the format: projects/{project}/topics/{topic}. Not matching this format results in an INVALID_ARGUMENT error.
        """
        event_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Event types for which a notification is desired. If empty, send notifications for all event types. The valid types are "TRANSFER_OPERATION_SUCCESS", "TRANSFER_OPERATION_FAILED", "TRANSFER_OPERATION_ABORTED".
        """
elif False:
    TransferJobNotificationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobNotificationConfigArgs:
    def __init__(__self__, *,
                 payload_format: pulumi.Input[_builtins.str],
                 pubsub_topic: pulumi.Input[_builtins.str],
                 event_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] payload_format: The desired format of the notification message payloads. One of "NONE" or "JSON".
        :param pulumi.Input[_builtins.str] pubsub_topic: The Topic.name of the Pub/Sub topic to which to publish notifications. Must be of the format: projects/{project}/topics/{topic}. Not matching this format results in an INVALID_ARGUMENT error.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] event_types: Event types for which a notification is desired. If empty, send notifications for all event types. The valid types are "TRANSFER_OPERATION_SUCCESS", "TRANSFER_OPERATION_FAILED", "TRANSFER_OPERATION_ABORTED".
        """
        pulumi.set(__self__, "payload_format", payload_format)
        pulumi.set(__self__, "pubsub_topic", pubsub_topic)
        if event_types is not None:
            pulumi.set(__self__, "event_types", event_types)

    @_builtins.property
    @pulumi.getter(name="payloadFormat")
    def payload_format(self) -> pulumi.Input[_builtins.str]:
        """
        The desired format of the notification message payloads. One of "NONE" or "JSON".
        """
        return pulumi.get(self, "payload_format")

    @payload_format.setter
    def payload_format(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "payload_format", value)

    @_builtins.property
    @pulumi.getter(name="pubsubTopic")
    def pubsub_topic(self) -> pulumi.Input[_builtins.str]:
        """
        The Topic.name of the Pub/Sub topic to which to publish notifications. Must be of the format: projects/{project}/topics/{topic}. Not matching this format results in an INVALID_ARGUMENT error.
        """
        return pulumi.get(self, "pubsub_topic")

    @pubsub_topic.setter
    def pubsub_topic(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "pubsub_topic", value)

    @_builtins.property
    @pulumi.getter(name="eventTypes")
    def event_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Event types for which a notification is desired. If empty, send notifications for all event types. The valid types are "TRANSFER_OPERATION_SUCCESS", "TRANSFER_OPERATION_FAILED", "TRANSFER_OPERATION_ABORTED".
        """
        return pulumi.get(self, "event_types")

    @event_types.setter
    def event_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "event_types", value)


if not MYPY:
    class TransferJobReplicationSpecArgsDict(TypedDict):
        gcs_data_sink: NotRequired[pulumi.Input['TransferJobReplicationSpecGcsDataSinkArgsDict']]
        """
        A Google Cloud Storage data sink. Structure documented below.
        """
        gcs_data_source: NotRequired[pulumi.Input['TransferJobReplicationSpecGcsDataSourceArgsDict']]
        """
        A Google Cloud Storage data source. Structure documented below.
        """
        object_conditions: NotRequired[pulumi.Input['TransferJobReplicationSpecObjectConditionsArgsDict']]
        """
        Only objects that satisfy these object conditions are included in the set of data source and data sink objects. Object conditions based on objects' `last_modification_time` do not exclude objects in a data sink. Structure documented below.
        """
        transfer_options: NotRequired[pulumi.Input['TransferJobReplicationSpecTransferOptionsArgsDict']]
        """
        Characteristics of how to treat files from datasource and sink during job. If the option `delete_objects_unique_in_sink` is true, object conditions based on objects' `last_modification_time` are ignored and do not exclude objects in a data source or a data sink. Structure documented below.
        """
elif False:
    TransferJobReplicationSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobReplicationSpecArgs:
    def __init__(__self__, *,
                 gcs_data_sink: Optional[pulumi.Input['TransferJobReplicationSpecGcsDataSinkArgs']] = None,
                 gcs_data_source: Optional[pulumi.Input['TransferJobReplicationSpecGcsDataSourceArgs']] = None,
                 object_conditions: Optional[pulumi.Input['TransferJobReplicationSpecObjectConditionsArgs']] = None,
                 transfer_options: Optional[pulumi.Input['TransferJobReplicationSpecTransferOptionsArgs']] = None):
        """
        :param pulumi.Input['TransferJobReplicationSpecGcsDataSinkArgs'] gcs_data_sink: A Google Cloud Storage data sink. Structure documented below.
        :param pulumi.Input['TransferJobReplicationSpecGcsDataSourceArgs'] gcs_data_source: A Google Cloud Storage data source. Structure documented below.
        :param pulumi.Input['TransferJobReplicationSpecObjectConditionsArgs'] object_conditions: Only objects that satisfy these object conditions are included in the set of data source and data sink objects. Object conditions based on objects' `last_modification_time` do not exclude objects in a data sink. Structure documented below.
        :param pulumi.Input['TransferJobReplicationSpecTransferOptionsArgs'] transfer_options: Characteristics of how to treat files from datasource and sink during job. If the option `delete_objects_unique_in_sink` is true, object conditions based on objects' `last_modification_time` are ignored and do not exclude objects in a data source or a data sink. Structure documented below.
        """
        if gcs_data_sink is not None:
            pulumi.set(__self__, "gcs_data_sink", gcs_data_sink)
        if gcs_data_source is not None:
            pulumi.set(__self__, "gcs_data_source", gcs_data_source)
        if object_conditions is not None:
            pulumi.set(__self__, "object_conditions", object_conditions)
        if transfer_options is not None:
            pulumi.set(__self__, "transfer_options", transfer_options)

    @_builtins.property
    @pulumi.getter(name="gcsDataSink")
    def gcs_data_sink(self) -> Optional[pulumi.Input['TransferJobReplicationSpecGcsDataSinkArgs']]:
        """
        A Google Cloud Storage data sink. Structure documented below.
        """
        return pulumi.get(self, "gcs_data_sink")

    @gcs_data_sink.setter
    def gcs_data_sink(self, value: Optional[pulumi.Input['TransferJobReplicationSpecGcsDataSinkArgs']]):
        pulumi.set(self, "gcs_data_sink", value)

    @_builtins.property
    @pulumi.getter(name="gcsDataSource")
    def gcs_data_source(self) -> Optional[pulumi.Input['TransferJobReplicationSpecGcsDataSourceArgs']]:
        """
        A Google Cloud Storage data source. Structure documented below.
        """
        return pulumi.get(self, "gcs_data_source")

    @gcs_data_source.setter
    def gcs_data_source(self, value: Optional[pulumi.Input['TransferJobReplicationSpecGcsDataSourceArgs']]):
        pulumi.set(self, "gcs_data_source", value)

    @_builtins.property
    @pulumi.getter(name="objectConditions")
    def object_conditions(self) -> Optional[pulumi.Input['TransferJobReplicationSpecObjectConditionsArgs']]:
        """
        Only objects that satisfy these object conditions are included in the set of data source and data sink objects. Object conditions based on objects' `last_modification_time` do not exclude objects in a data sink. Structure documented below.
        """
        return pulumi.get(self, "object_conditions")

    @object_conditions.setter
    def object_conditions(self, value: Optional[pulumi.Input['TransferJobReplicationSpecObjectConditionsArgs']]):
        pulumi.set(self, "object_conditions", value)

    @_builtins.property
    @pulumi.getter(name="transferOptions")
    def transfer_options(self) -> Optional[pulumi.Input['TransferJobReplicationSpecTransferOptionsArgs']]:
        """
        Characteristics of how to treat files from datasource and sink during job. If the option `delete_objects_unique_in_sink` is true, object conditions based on objects' `last_modification_time` are ignored and do not exclude objects in a data source or a data sink. Structure documented below.
        """
        return pulumi.get(self, "transfer_options")

    @transfer_options.setter
    def transfer_options(self, value: Optional[pulumi.Input['TransferJobReplicationSpecTransferOptionsArgs']]):
        pulumi.set(self, "transfer_options", value)


if not MYPY:
    class TransferJobReplicationSpecGcsDataSinkArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        """
        Google Cloud Storage bucket name.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
        """
elif False:
    TransferJobReplicationSpecGcsDataSinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobReplicationSpecGcsDataSinkArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: Google Cloud Storage bucket name.
        :param pulumi.Input[_builtins.str] path: Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        Google Cloud Storage bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class TransferJobReplicationSpecGcsDataSourceArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        """
        Google Cloud Storage bucket name.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
        """
elif False:
    TransferJobReplicationSpecGcsDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobReplicationSpecGcsDataSourceArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: Google Cloud Storage bucket name.
        :param pulumi.Input[_builtins.str] path: Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        Google Cloud Storage bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class TransferJobReplicationSpecObjectConditionsArgsDict(TypedDict):
        exclude_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        `exclude_prefixes` must follow the requirements described for `include_prefixes`. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
        """
        include_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        If `include_prefixes` is specified, objects that satisfy the object conditions must have names that start with one of the `include_prefixes` and that do not start with any of the `exclude_prefixes`. If `include_prefixes` is not specified, all objects except those that have names starting with one of the `exclude_prefixes` must satisfy the object conditions. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
        """
        last_modified_before: NotRequired[pulumi.Input[_builtins.str]]
        """
        If specified, only objects with a "last modification time" before this timestamp and objects that don't have a "last modification time" are transferred. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        last_modified_since: NotRequired[pulumi.Input[_builtins.str]]
        """
        If specified, only objects with a "last modification time" on or after this timestamp and objects that don't have a "last modification time" are transferred. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        max_time_elapsed_since_last_modification: NotRequired[pulumi.Input[_builtins.str]]
        """
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        min_time_elapsed_since_last_modification: NotRequired[pulumi.Input[_builtins.str]]
        """
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
elif False:
    TransferJobReplicationSpecObjectConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobReplicationSpecObjectConditionsArgs:
    def __init__(__self__, *,
                 exclude_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 last_modified_before: Optional[pulumi.Input[_builtins.str]] = None,
                 last_modified_since: Optional[pulumi.Input[_builtins.str]] = None,
                 max_time_elapsed_since_last_modification: Optional[pulumi.Input[_builtins.str]] = None,
                 min_time_elapsed_since_last_modification: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_prefixes: `exclude_prefixes` must follow the requirements described for `include_prefixes`. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_prefixes: If `include_prefixes` is specified, objects that satisfy the object conditions must have names that start with one of the `include_prefixes` and that do not start with any of the `exclude_prefixes`. If `include_prefixes` is not specified, all objects except those that have names starting with one of the `exclude_prefixes` must satisfy the object conditions. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
        :param pulumi.Input[_builtins.str] last_modified_before: If specified, only objects with a "last modification time" before this timestamp and objects that don't have a "last modification time" are transferred. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        :param pulumi.Input[_builtins.str] last_modified_since: If specified, only objects with a "last modification time" on or after this timestamp and objects that don't have a "last modification time" are transferred. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        :param pulumi.Input[_builtins.str] max_time_elapsed_since_last_modification: A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        :param pulumi.Input[_builtins.str] min_time_elapsed_since_last_modification: A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        if exclude_prefixes is not None:
            pulumi.set(__self__, "exclude_prefixes", exclude_prefixes)
        if include_prefixes is not None:
            pulumi.set(__self__, "include_prefixes", include_prefixes)
        if last_modified_before is not None:
            pulumi.set(__self__, "last_modified_before", last_modified_before)
        if last_modified_since is not None:
            pulumi.set(__self__, "last_modified_since", last_modified_since)
        if max_time_elapsed_since_last_modification is not None:
            pulumi.set(__self__, "max_time_elapsed_since_last_modification", max_time_elapsed_since_last_modification)
        if min_time_elapsed_since_last_modification is not None:
            pulumi.set(__self__, "min_time_elapsed_since_last_modification", min_time_elapsed_since_last_modification)

    @_builtins.property
    @pulumi.getter(name="excludePrefixes")
    def exclude_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        `exclude_prefixes` must follow the requirements described for `include_prefixes`. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
        """
        return pulumi.get(self, "exclude_prefixes")

    @exclude_prefixes.setter
    def exclude_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_prefixes", value)

    @_builtins.property
    @pulumi.getter(name="includePrefixes")
    def include_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        If `include_prefixes` is specified, objects that satisfy the object conditions must have names that start with one of the `include_prefixes` and that do not start with any of the `exclude_prefixes`. If `include_prefixes` is not specified, all objects except those that have names starting with one of the `exclude_prefixes` must satisfy the object conditions. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
        """
        return pulumi.get(self, "include_prefixes")

    @include_prefixes.setter
    def include_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_prefixes", value)

    @_builtins.property
    @pulumi.getter(name="lastModifiedBefore")
    def last_modified_before(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If specified, only objects with a "last modification time" before this timestamp and objects that don't have a "last modification time" are transferred. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "last_modified_before")

    @last_modified_before.setter
    def last_modified_before(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_modified_before", value)

    @_builtins.property
    @pulumi.getter(name="lastModifiedSince")
    def last_modified_since(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If specified, only objects with a "last modification time" on or after this timestamp and objects that don't have a "last modification time" are transferred. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "last_modified_since")

    @last_modified_since.setter
    def last_modified_since(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_modified_since", value)

    @_builtins.property
    @pulumi.getter(name="maxTimeElapsedSinceLastModification")
    def max_time_elapsed_since_last_modification(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        return pulumi.get(self, "max_time_elapsed_since_last_modification")

    @max_time_elapsed_since_last_modification.setter
    def max_time_elapsed_since_last_modification(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_time_elapsed_since_last_modification", value)

    @_builtins.property
    @pulumi.getter(name="minTimeElapsedSinceLastModification")
    def min_time_elapsed_since_last_modification(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        return pulumi.get(self, "min_time_elapsed_since_last_modification")

    @min_time_elapsed_since_last_modification.setter
    def min_time_elapsed_since_last_modification(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_time_elapsed_since_last_modification", value)


if not MYPY:
    class TransferJobReplicationSpecTransferOptionsArgsDict(TypedDict):
        delete_objects_from_source_after_transfer: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether objects should be deleted from the source after they are transferred to the sink. Note that this option and `delete_objects_unique_in_sink` are mutually exclusive.
        """
        delete_objects_unique_in_sink: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether objects that exist only in the sink should be deleted. Note that this option and
        `delete_objects_from_source_after_transfer` are mutually exclusive.
        """
        metadata_options: NotRequired[pulumi.Input['TransferJobReplicationSpecTransferOptionsMetadataOptionsArgsDict']]
        """
        Specifies the metadata options for running a transfer. Structure documented below.
        """
        overwrite_objects_already_existing_in_sink: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether overwriting objects that already exist in the sink is allowed.
        """
        overwrite_when: NotRequired[pulumi.Input[_builtins.str]]
        """
        When to overwrite objects that already exist in the sink. If not set, overwrite behavior is determined by `overwrite_objects_already_existing_in_sink`. Possible values: ALWAYS, DIFFERENT, NEVER.
        """
elif False:
    TransferJobReplicationSpecTransferOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobReplicationSpecTransferOptionsArgs:
    def __init__(__self__, *,
                 delete_objects_from_source_after_transfer: Optional[pulumi.Input[_builtins.bool]] = None,
                 delete_objects_unique_in_sink: Optional[pulumi.Input[_builtins.bool]] = None,
                 metadata_options: Optional[pulumi.Input['TransferJobReplicationSpecTransferOptionsMetadataOptionsArgs']] = None,
                 overwrite_objects_already_existing_in_sink: Optional[pulumi.Input[_builtins.bool]] = None,
                 overwrite_when: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] delete_objects_from_source_after_transfer: Whether objects should be deleted from the source after they are transferred to the sink. Note that this option and `delete_objects_unique_in_sink` are mutually exclusive.
        :param pulumi.Input[_builtins.bool] delete_objects_unique_in_sink: Whether objects that exist only in the sink should be deleted. Note that this option and
               `delete_objects_from_source_after_transfer` are mutually exclusive.
        :param pulumi.Input['TransferJobReplicationSpecTransferOptionsMetadataOptionsArgs'] metadata_options: Specifies the metadata options for running a transfer. Structure documented below.
        :param pulumi.Input[_builtins.bool] overwrite_objects_already_existing_in_sink: Whether overwriting objects that already exist in the sink is allowed.
        :param pulumi.Input[_builtins.str] overwrite_when: When to overwrite objects that already exist in the sink. If not set, overwrite behavior is determined by `overwrite_objects_already_existing_in_sink`. Possible values: ALWAYS, DIFFERENT, NEVER.
        """
        if delete_objects_from_source_after_transfer is not None:
            pulumi.set(__self__, "delete_objects_from_source_after_transfer", delete_objects_from_source_after_transfer)
        if delete_objects_unique_in_sink is not None:
            pulumi.set(__self__, "delete_objects_unique_in_sink", delete_objects_unique_in_sink)
        if metadata_options is not None:
            pulumi.set(__self__, "metadata_options", metadata_options)
        if overwrite_objects_already_existing_in_sink is not None:
            pulumi.set(__self__, "overwrite_objects_already_existing_in_sink", overwrite_objects_already_existing_in_sink)
        if overwrite_when is not None:
            pulumi.set(__self__, "overwrite_when", overwrite_when)

    @_builtins.property
    @pulumi.getter(name="deleteObjectsFromSourceAfterTransfer")
    def delete_objects_from_source_after_transfer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether objects should be deleted from the source after they are transferred to the sink. Note that this option and `delete_objects_unique_in_sink` are mutually exclusive.
        """
        return pulumi.get(self, "delete_objects_from_source_after_transfer")

    @delete_objects_from_source_after_transfer.setter
    def delete_objects_from_source_after_transfer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_objects_from_source_after_transfer", value)

    @_builtins.property
    @pulumi.getter(name="deleteObjectsUniqueInSink")
    def delete_objects_unique_in_sink(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether objects that exist only in the sink should be deleted. Note that this option and
        `delete_objects_from_source_after_transfer` are mutually exclusive.
        """
        return pulumi.get(self, "delete_objects_unique_in_sink")

    @delete_objects_unique_in_sink.setter
    def delete_objects_unique_in_sink(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_objects_unique_in_sink", value)

    @_builtins.property
    @pulumi.getter(name="metadataOptions")
    def metadata_options(self) -> Optional[pulumi.Input['TransferJobReplicationSpecTransferOptionsMetadataOptionsArgs']]:
        """
        Specifies the metadata options for running a transfer. Structure documented below.
        """
        return pulumi.get(self, "metadata_options")

    @metadata_options.setter
    def metadata_options(self, value: Optional[pulumi.Input['TransferJobReplicationSpecTransferOptionsMetadataOptionsArgs']]):
        pulumi.set(self, "metadata_options", value)

    @_builtins.property
    @pulumi.getter(name="overwriteObjectsAlreadyExistingInSink")
    def overwrite_objects_already_existing_in_sink(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether overwriting objects that already exist in the sink is allowed.
        """
        return pulumi.get(self, "overwrite_objects_already_existing_in_sink")

    @overwrite_objects_already_existing_in_sink.setter
    def overwrite_objects_already_existing_in_sink(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite_objects_already_existing_in_sink", value)

    @_builtins.property
    @pulumi.getter(name="overwriteWhen")
    def overwrite_when(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When to overwrite objects that already exist in the sink. If not set, overwrite behavior is determined by `overwrite_objects_already_existing_in_sink`. Possible values: ALWAYS, DIFFERENT, NEVER.
        """
        return pulumi.get(self, "overwrite_when")

    @overwrite_when.setter
    def overwrite_when(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "overwrite_when", value)


if not MYPY:
    class TransferJobReplicationSpecTransferOptionsMetadataOptionsArgsDict(TypedDict):
        acl: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies how each object's ACLs should be preserved for transfers between Google Cloud Storage buckets.
        """
        gid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies how each file's POSIX group ID (GID) attribute should be handled by the transfer.
        """
        kms_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies how each object's Cloud KMS customer-managed encryption key (CMEK) is preserved for transfers between Google Cloud Storage buckets.
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies how each file's mode attribute should be handled by the transfer.
        """
        storage_class: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the storage class to set on objects being transferred to Google Cloud Storage buckets.
        """
        symlink: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies how symlinks should be handled by the transfer.
        """
        temporary_hold: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies how each object's temporary hold status should be preserved for transfers between Google Cloud Storage buckets.
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies how each object's timeCreated metadata is preserved for transfers.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies how each file's POSIX user ID (UID) attribute should be handled by the transfer.
        """
elif False:
    TransferJobReplicationSpecTransferOptionsMetadataOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobReplicationSpecTransferOptionsMetadataOptionsArgs:
    def __init__(__self__, *,
                 acl: Optional[pulumi.Input[_builtins.str]] = None,
                 gid: Optional[pulumi.Input[_builtins.str]] = None,
                 kms_key: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 storage_class: Optional[pulumi.Input[_builtins.str]] = None,
                 symlink: Optional[pulumi.Input[_builtins.str]] = None,
                 temporary_hold: Optional[pulumi.Input[_builtins.str]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] acl: Specifies how each object's ACLs should be preserved for transfers between Google Cloud Storage buckets.
        :param pulumi.Input[_builtins.str] gid: Specifies how each file's POSIX group ID (GID) attribute should be handled by the transfer.
        :param pulumi.Input[_builtins.str] kms_key: Specifies how each object's Cloud KMS customer-managed encryption key (CMEK) is preserved for transfers between Google Cloud Storage buckets.
        :param pulumi.Input[_builtins.str] mode: Specifies how each file's mode attribute should be handled by the transfer.
        :param pulumi.Input[_builtins.str] storage_class: Specifies the storage class to set on objects being transferred to Google Cloud Storage buckets.
        :param pulumi.Input[_builtins.str] symlink: Specifies how symlinks should be handled by the transfer.
        :param pulumi.Input[_builtins.str] temporary_hold: Specifies how each object's temporary hold status should be preserved for transfers between Google Cloud Storage buckets.
        :param pulumi.Input[_builtins.str] time_created: Specifies how each object's timeCreated metadata is preserved for transfers.
        :param pulumi.Input[_builtins.str] uid: Specifies how each file's POSIX user ID (UID) attribute should be handled by the transfer.
        """
        if acl is not None:
            pulumi.set(__self__, "acl", acl)
        if gid is not None:
            pulumi.set(__self__, "gid", gid)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if storage_class is not None:
            pulumi.set(__self__, "storage_class", storage_class)
        if symlink is not None:
            pulumi.set(__self__, "symlink", symlink)
        if temporary_hold is not None:
            pulumi.set(__self__, "temporary_hold", temporary_hold)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def acl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies how each object's ACLs should be preserved for transfers between Google Cloud Storage buckets.
        """
        return pulumi.get(self, "acl")

    @acl.setter
    def acl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "acl", value)

    @_builtins.property
    @pulumi.getter
    def gid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies how each file's POSIX group ID (GID) attribute should be handled by the transfer.
        """
        return pulumi.get(self, "gid")

    @gid.setter
    def gid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gid", value)

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies how each object's Cloud KMS customer-managed encryption key (CMEK) is preserved for transfers between Google Cloud Storage buckets.
        """
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies how each file's mode attribute should be handled by the transfer.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the storage class to set on objects being transferred to Google Cloud Storage buckets.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_class", value)

    @_builtins.property
    @pulumi.getter
    def symlink(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies how symlinks should be handled by the transfer.
        """
        return pulumi.get(self, "symlink")

    @symlink.setter
    def symlink(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "symlink", value)

    @_builtins.property
    @pulumi.getter(name="temporaryHold")
    def temporary_hold(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies how each object's temporary hold status should be preserved for transfers between Google Cloud Storage buckets.
        """
        return pulumi.get(self, "temporary_hold")

    @temporary_hold.setter
    def temporary_hold(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "temporary_hold", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies how each object's timeCreated metadata is preserved for transfers.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies how each file's POSIX user ID (UID) attribute should be handled by the transfer.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class TransferJobScheduleArgsDict(TypedDict):
        schedule_start_date: pulumi.Input['TransferJobScheduleScheduleStartDateArgsDict']
        """
        The first day the recurring transfer is scheduled to run. If `schedule_start_date` is in the past, the transfer will run for the first time on the following day. Structure documented below.
        """
        repeat_interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Interval between the start of each scheduled transfer. If unspecified, the default value is 24 hours. This value may not be less than 1 hour. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        schedule_end_date: NotRequired[pulumi.Input['TransferJobScheduleScheduleEndDateArgsDict']]
        """
        The last day the recurring transfer will be run. If `schedule_end_date` is the same as `schedule_start_date`, the transfer will be executed only once. Structure documented below.
        """
        start_time_of_day: NotRequired[pulumi.Input['TransferJobScheduleStartTimeOfDayArgsDict']]
        """
        The time in UTC at which the transfer will be scheduled to start in a day. Transfers may start later than this time. If not specified, recurring and one-time transfers that are scheduled to run today will run immediately; recurring transfers that are scheduled to run on a future date will start at approximately midnight UTC on that date. Note that when configuring a transfer with the Cloud Platform Console, the transfer's start time in a day is specified in your local timezone. Structure documented below.
        """
elif False:
    TransferJobScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobScheduleArgs:
    def __init__(__self__, *,
                 schedule_start_date: pulumi.Input['TransferJobScheduleScheduleStartDateArgs'],
                 repeat_interval: Optional[pulumi.Input[_builtins.str]] = None,
                 schedule_end_date: Optional[pulumi.Input['TransferJobScheduleScheduleEndDateArgs']] = None,
                 start_time_of_day: Optional[pulumi.Input['TransferJobScheduleStartTimeOfDayArgs']] = None):
        """
        :param pulumi.Input['TransferJobScheduleScheduleStartDateArgs'] schedule_start_date: The first day the recurring transfer is scheduled to run. If `schedule_start_date` is in the past, the transfer will run for the first time on the following day. Structure documented below.
        :param pulumi.Input[_builtins.str] repeat_interval: Interval between the start of each scheduled transfer. If unspecified, the default value is 24 hours. This value may not be less than 1 hour. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        :param pulumi.Input['TransferJobScheduleScheduleEndDateArgs'] schedule_end_date: The last day the recurring transfer will be run. If `schedule_end_date` is the same as `schedule_start_date`, the transfer will be executed only once. Structure documented below.
        :param pulumi.Input['TransferJobScheduleStartTimeOfDayArgs'] start_time_of_day: The time in UTC at which the transfer will be scheduled to start in a day. Transfers may start later than this time. If not specified, recurring and one-time transfers that are scheduled to run today will run immediately; recurring transfers that are scheduled to run on a future date will start at approximately midnight UTC on that date. Note that when configuring a transfer with the Cloud Platform Console, the transfer's start time in a day is specified in your local timezone. Structure documented below.
        """
        pulumi.set(__self__, "schedule_start_date", schedule_start_date)
        if repeat_interval is not None:
            pulumi.set(__self__, "repeat_interval", repeat_interval)
        if schedule_end_date is not None:
            pulumi.set(__self__, "schedule_end_date", schedule_end_date)
        if start_time_of_day is not None:
            pulumi.set(__self__, "start_time_of_day", start_time_of_day)

    @_builtins.property
    @pulumi.getter(name="scheduleStartDate")
    def schedule_start_date(self) -> pulumi.Input['TransferJobScheduleScheduleStartDateArgs']:
        """
        The first day the recurring transfer is scheduled to run. If `schedule_start_date` is in the past, the transfer will run for the first time on the following day. Structure documented below.
        """
        return pulumi.get(self, "schedule_start_date")

    @schedule_start_date.setter
    def schedule_start_date(self, value: pulumi.Input['TransferJobScheduleScheduleStartDateArgs']):
        pulumi.set(self, "schedule_start_date", value)

    @_builtins.property
    @pulumi.getter(name="repeatInterval")
    def repeat_interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Interval between the start of each scheduled transfer. If unspecified, the default value is 24 hours. This value may not be less than 1 hour. A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        return pulumi.get(self, "repeat_interval")

    @repeat_interval.setter
    def repeat_interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "repeat_interval", value)

    @_builtins.property
    @pulumi.getter(name="scheduleEndDate")
    def schedule_end_date(self) -> Optional[pulumi.Input['TransferJobScheduleScheduleEndDateArgs']]:
        """
        The last day the recurring transfer will be run. If `schedule_end_date` is the same as `schedule_start_date`, the transfer will be executed only once. Structure documented below.
        """
        return pulumi.get(self, "schedule_end_date")

    @schedule_end_date.setter
    def schedule_end_date(self, value: Optional[pulumi.Input['TransferJobScheduleScheduleEndDateArgs']]):
        pulumi.set(self, "schedule_end_date", value)

    @_builtins.property
    @pulumi.getter(name="startTimeOfDay")
    def start_time_of_day(self) -> Optional[pulumi.Input['TransferJobScheduleStartTimeOfDayArgs']]:
        """
        The time in UTC at which the transfer will be scheduled to start in a day. Transfers may start later than this time. If not specified, recurring and one-time transfers that are scheduled to run today will run immediately; recurring transfers that are scheduled to run on a future date will start at approximately midnight UTC on that date. Note that when configuring a transfer with the Cloud Platform Console, the transfer's start time in a day is specified in your local timezone. Structure documented below.
        """
        return pulumi.get(self, "start_time_of_day")

    @start_time_of_day.setter
    def start_time_of_day(self, value: Optional[pulumi.Input['TransferJobScheduleStartTimeOfDayArgs']]):
        pulumi.set(self, "start_time_of_day", value)


if not MYPY:
    class TransferJobScheduleScheduleEndDateArgsDict(TypedDict):
        day: pulumi.Input[_builtins.int]
        """
        Day of month. Must be from 1 to 31 and valid for the year and month.
        """
        month: pulumi.Input[_builtins.int]
        """
        Month of year. Must be from 1 to 12.
        """
        year: pulumi.Input[_builtins.int]
        """
        Year of date. Must be from 1 to 9999.
        """
elif False:
    TransferJobScheduleScheduleEndDateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobScheduleScheduleEndDateArgs:
    def __init__(__self__, *,
                 day: pulumi.Input[_builtins.int],
                 month: pulumi.Input[_builtins.int],
                 year: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] day: Day of month. Must be from 1 to 31 and valid for the year and month.
        :param pulumi.Input[_builtins.int] month: Month of year. Must be from 1 to 12.
        :param pulumi.Input[_builtins.int] year: Year of date. Must be from 1 to 9999.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "month", month)
        pulumi.set(__self__, "year", year)

    @_builtins.property
    @pulumi.getter
    def day(self) -> pulumi.Input[_builtins.int]:
        """
        Day of month. Must be from 1 to 31 and valid for the year and month.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "day", value)

    @_builtins.property
    @pulumi.getter
    def month(self) -> pulumi.Input[_builtins.int]:
        """
        Month of year. Must be from 1 to 12.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "month", value)

    @_builtins.property
    @pulumi.getter
    def year(self) -> pulumi.Input[_builtins.int]:
        """
        Year of date. Must be from 1 to 9999.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "year", value)


if not MYPY:
    class TransferJobScheduleScheduleStartDateArgsDict(TypedDict):
        day: pulumi.Input[_builtins.int]
        """
        Day of month. Must be from 1 to 31 and valid for the year and month.
        """
        month: pulumi.Input[_builtins.int]
        """
        Month of year. Must be from 1 to 12.
        """
        year: pulumi.Input[_builtins.int]
        """
        Year of date. Must be from 1 to 9999.
        """
elif False:
    TransferJobScheduleScheduleStartDateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobScheduleScheduleStartDateArgs:
    def __init__(__self__, *,
                 day: pulumi.Input[_builtins.int],
                 month: pulumi.Input[_builtins.int],
                 year: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] day: Day of month. Must be from 1 to 31 and valid for the year and month.
        :param pulumi.Input[_builtins.int] month: Month of year. Must be from 1 to 12.
        :param pulumi.Input[_builtins.int] year: Year of date. Must be from 1 to 9999.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "month", month)
        pulumi.set(__self__, "year", year)

    @_builtins.property
    @pulumi.getter
    def day(self) -> pulumi.Input[_builtins.int]:
        """
        Day of month. Must be from 1 to 31 and valid for the year and month.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "day", value)

    @_builtins.property
    @pulumi.getter
    def month(self) -> pulumi.Input[_builtins.int]:
        """
        Month of year. Must be from 1 to 12.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "month", value)

    @_builtins.property
    @pulumi.getter
    def year(self) -> pulumi.Input[_builtins.int]:
        """
        Year of date. Must be from 1 to 9999.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "year", value)


if not MYPY:
    class TransferJobScheduleStartTimeOfDayArgsDict(TypedDict):
        hours: pulumi.Input[_builtins.int]
        """
        Hours of day in 24 hour format. Should be from 0 to 23.
        """
        minutes: pulumi.Input[_builtins.int]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: pulumi.Input[_builtins.int]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: pulumi.Input[_builtins.int]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59.
        """
elif False:
    TransferJobScheduleStartTimeOfDayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobScheduleStartTimeOfDayArgs:
    def __init__(__self__, *,
                 hours: pulumi.Input[_builtins.int],
                 minutes: pulumi.Input[_builtins.int],
                 nanos: pulumi.Input[_builtins.int],
                 seconds: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.int] hours: Hours of day in 24 hour format. Should be from 0 to 23.
        :param pulumi.Input[_builtins.int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[_builtins.int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[_builtins.int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59.
        """
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)
        pulumi.set(__self__, "nanos", nanos)
        pulumi.set(__self__, "seconds", seconds)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> pulumi.Input[_builtins.int]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "hours", value)

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> pulumi.Input[_builtins.int]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "minutes", value)

    @_builtins.property
    @pulumi.getter
    def nanos(self) -> pulumi.Input[_builtins.int]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "nanos", value)

    @_builtins.property
    @pulumi.getter
    def seconds(self) -> pulumi.Input[_builtins.int]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class TransferJobTransferSpecArgsDict(TypedDict):
        aws_s3_compatible_data_source: NotRequired[pulumi.Input['TransferJobTransferSpecAwsS3CompatibleDataSourceArgsDict']]
        """
        An AWS S3 Compatible data source. Structure documented below.
        """
        aws_s3_data_source: NotRequired[pulumi.Input['TransferJobTransferSpecAwsS3DataSourceArgsDict']]
        """
        An AWS S3 data source. Structure documented below.
        """
        azure_blob_storage_data_source: NotRequired[pulumi.Input['TransferJobTransferSpecAzureBlobStorageDataSourceArgsDict']]
        """
        An Azure Blob Storage data source. Structure documented below.
        """
        gcs_data_sink: NotRequired[pulumi.Input['TransferJobTransferSpecGcsDataSinkArgsDict']]
        """
        A Google Cloud Storage data sink. Structure documented below.
        """
        gcs_data_source: NotRequired[pulumi.Input['TransferJobTransferSpecGcsDataSourceArgsDict']]
        """
        A Google Cloud Storage data source. Structure documented below.
        """
        hdfs_data_source: NotRequired[pulumi.Input['TransferJobTransferSpecHdfsDataSourceArgsDict']]
        """
        An HDFS data source. Structure documented below.
        """
        http_data_source: NotRequired[pulumi.Input['TransferJobTransferSpecHttpDataSourceArgsDict']]
        """
        A HTTP URL data source. Structure documented below.
        """
        object_conditions: NotRequired[pulumi.Input['TransferJobTransferSpecObjectConditionsArgsDict']]
        """
        Only objects that satisfy these object conditions are included in the set of data source and data sink objects. Object conditions based on objects' `last_modification_time` do not exclude objects in a data sink. Structure documented below.
        """
        posix_data_sink: NotRequired[pulumi.Input['TransferJobTransferSpecPosixDataSinkArgsDict']]
        """
        A POSIX data sink. Structure documented below.
        """
        posix_data_source: NotRequired[pulumi.Input['TransferJobTransferSpecPosixDataSourceArgsDict']]
        """
        A POSIX filesystem data source. Structure documented below.
        """
        sink_agent_pool_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the agent pool name associated with the posix data sink. When unspecified, the default name is used.
        """
        source_agent_pool_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the agent pool name associated with the posix data source. When unspecified, the default name is used.
        """
        transfer_manifest: NotRequired[pulumi.Input['TransferJobTransferSpecTransferManifestArgsDict']]
        """
        Use a manifest file to limit which object are transferred. See [Storage Transfer Service manifest file format](https://cloud.google.com/storage-transfer/docs/manifest). Structure documented below.
        """
        transfer_options: NotRequired[pulumi.Input['TransferJobTransferSpecTransferOptionsArgsDict']]
        """
        Characteristics of how to treat files from datasource and sink during job. If the option `delete_objects_unique_in_sink` is true, object conditions based on objects' `last_modification_time` are ignored and do not exclude objects in a data source or a data sink. Structure documented below.
        """
elif False:
    TransferJobTransferSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobTransferSpecArgs:
    def __init__(__self__, *,
                 aws_s3_compatible_data_source: Optional[pulumi.Input['TransferJobTransferSpecAwsS3CompatibleDataSourceArgs']] = None,
                 aws_s3_data_source: Optional[pulumi.Input['TransferJobTransferSpecAwsS3DataSourceArgs']] = None,
                 azure_blob_storage_data_source: Optional[pulumi.Input['TransferJobTransferSpecAzureBlobStorageDataSourceArgs']] = None,
                 gcs_data_sink: Optional[pulumi.Input['TransferJobTransferSpecGcsDataSinkArgs']] = None,
                 gcs_data_source: Optional[pulumi.Input['TransferJobTransferSpecGcsDataSourceArgs']] = None,
                 hdfs_data_source: Optional[pulumi.Input['TransferJobTransferSpecHdfsDataSourceArgs']] = None,
                 http_data_source: Optional[pulumi.Input['TransferJobTransferSpecHttpDataSourceArgs']] = None,
                 object_conditions: Optional[pulumi.Input['TransferJobTransferSpecObjectConditionsArgs']] = None,
                 posix_data_sink: Optional[pulumi.Input['TransferJobTransferSpecPosixDataSinkArgs']] = None,
                 posix_data_source: Optional[pulumi.Input['TransferJobTransferSpecPosixDataSourceArgs']] = None,
                 sink_agent_pool_name: Optional[pulumi.Input[_builtins.str]] = None,
                 source_agent_pool_name: Optional[pulumi.Input[_builtins.str]] = None,
                 transfer_manifest: Optional[pulumi.Input['TransferJobTransferSpecTransferManifestArgs']] = None,
                 transfer_options: Optional[pulumi.Input['TransferJobTransferSpecTransferOptionsArgs']] = None):
        """
        :param pulumi.Input['TransferJobTransferSpecAwsS3CompatibleDataSourceArgs'] aws_s3_compatible_data_source: An AWS S3 Compatible data source. Structure documented below.
        :param pulumi.Input['TransferJobTransferSpecAwsS3DataSourceArgs'] aws_s3_data_source: An AWS S3 data source. Structure documented below.
        :param pulumi.Input['TransferJobTransferSpecAzureBlobStorageDataSourceArgs'] azure_blob_storage_data_source: An Azure Blob Storage data source. Structure documented below.
        :param pulumi.Input['TransferJobTransferSpecGcsDataSinkArgs'] gcs_data_sink: A Google Cloud Storage data sink. Structure documented below.
        :param pulumi.Input['TransferJobTransferSpecGcsDataSourceArgs'] gcs_data_source: A Google Cloud Storage data source. Structure documented below.
        :param pulumi.Input['TransferJobTransferSpecHdfsDataSourceArgs'] hdfs_data_source: An HDFS data source. Structure documented below.
        :param pulumi.Input['TransferJobTransferSpecHttpDataSourceArgs'] http_data_source: A HTTP URL data source. Structure documented below.
        :param pulumi.Input['TransferJobTransferSpecObjectConditionsArgs'] object_conditions: Only objects that satisfy these object conditions are included in the set of data source and data sink objects. Object conditions based on objects' `last_modification_time` do not exclude objects in a data sink. Structure documented below.
        :param pulumi.Input['TransferJobTransferSpecPosixDataSinkArgs'] posix_data_sink: A POSIX data sink. Structure documented below.
        :param pulumi.Input['TransferJobTransferSpecPosixDataSourceArgs'] posix_data_source: A POSIX filesystem data source. Structure documented below.
        :param pulumi.Input[_builtins.str] sink_agent_pool_name: Specifies the agent pool name associated with the posix data sink. When unspecified, the default name is used.
        :param pulumi.Input[_builtins.str] source_agent_pool_name: Specifies the agent pool name associated with the posix data source. When unspecified, the default name is used.
        :param pulumi.Input['TransferJobTransferSpecTransferManifestArgs'] transfer_manifest: Use a manifest file to limit which object are transferred. See [Storage Transfer Service manifest file format](https://cloud.google.com/storage-transfer/docs/manifest). Structure documented below.
        :param pulumi.Input['TransferJobTransferSpecTransferOptionsArgs'] transfer_options: Characteristics of how to treat files from datasource and sink during job. If the option `delete_objects_unique_in_sink` is true, object conditions based on objects' `last_modification_time` are ignored and do not exclude objects in a data source or a data sink. Structure documented below.
        """
        if aws_s3_compatible_data_source is not None:
            pulumi.set(__self__, "aws_s3_compatible_data_source", aws_s3_compatible_data_source)
        if aws_s3_data_source is not None:
            pulumi.set(__self__, "aws_s3_data_source", aws_s3_data_source)
        if azure_blob_storage_data_source is not None:
            pulumi.set(__self__, "azure_blob_storage_data_source", azure_blob_storage_data_source)
        if gcs_data_sink is not None:
            pulumi.set(__self__, "gcs_data_sink", gcs_data_sink)
        if gcs_data_source is not None:
            pulumi.set(__self__, "gcs_data_source", gcs_data_source)
        if hdfs_data_source is not None:
            pulumi.set(__self__, "hdfs_data_source", hdfs_data_source)
        if http_data_source is not None:
            pulumi.set(__self__, "http_data_source", http_data_source)
        if object_conditions is not None:
            pulumi.set(__self__, "object_conditions", object_conditions)
        if posix_data_sink is not None:
            pulumi.set(__self__, "posix_data_sink", posix_data_sink)
        if posix_data_source is not None:
            pulumi.set(__self__, "posix_data_source", posix_data_source)
        if sink_agent_pool_name is not None:
            pulumi.set(__self__, "sink_agent_pool_name", sink_agent_pool_name)
        if source_agent_pool_name is not None:
            pulumi.set(__self__, "source_agent_pool_name", source_agent_pool_name)
        if transfer_manifest is not None:
            pulumi.set(__self__, "transfer_manifest", transfer_manifest)
        if transfer_options is not None:
            pulumi.set(__self__, "transfer_options", transfer_options)

    @_builtins.property
    @pulumi.getter(name="awsS3CompatibleDataSource")
    def aws_s3_compatible_data_source(self) -> Optional[pulumi.Input['TransferJobTransferSpecAwsS3CompatibleDataSourceArgs']]:
        """
        An AWS S3 Compatible data source. Structure documented below.
        """
        return pulumi.get(self, "aws_s3_compatible_data_source")

    @aws_s3_compatible_data_source.setter
    def aws_s3_compatible_data_source(self, value: Optional[pulumi.Input['TransferJobTransferSpecAwsS3CompatibleDataSourceArgs']]):
        pulumi.set(self, "aws_s3_compatible_data_source", value)

    @_builtins.property
    @pulumi.getter(name="awsS3DataSource")
    def aws_s3_data_source(self) -> Optional[pulumi.Input['TransferJobTransferSpecAwsS3DataSourceArgs']]:
        """
        An AWS S3 data source. Structure documented below.
        """
        return pulumi.get(self, "aws_s3_data_source")

    @aws_s3_data_source.setter
    def aws_s3_data_source(self, value: Optional[pulumi.Input['TransferJobTransferSpecAwsS3DataSourceArgs']]):
        pulumi.set(self, "aws_s3_data_source", value)

    @_builtins.property
    @pulumi.getter(name="azureBlobStorageDataSource")
    def azure_blob_storage_data_source(self) -> Optional[pulumi.Input['TransferJobTransferSpecAzureBlobStorageDataSourceArgs']]:
        """
        An Azure Blob Storage data source. Structure documented below.
        """
        return pulumi.get(self, "azure_blob_storage_data_source")

    @azure_blob_storage_data_source.setter
    def azure_blob_storage_data_source(self, value: Optional[pulumi.Input['TransferJobTransferSpecAzureBlobStorageDataSourceArgs']]):
        pulumi.set(self, "azure_blob_storage_data_source", value)

    @_builtins.property
    @pulumi.getter(name="gcsDataSink")
    def gcs_data_sink(self) -> Optional[pulumi.Input['TransferJobTransferSpecGcsDataSinkArgs']]:
        """
        A Google Cloud Storage data sink. Structure documented below.
        """
        return pulumi.get(self, "gcs_data_sink")

    @gcs_data_sink.setter
    def gcs_data_sink(self, value: Optional[pulumi.Input['TransferJobTransferSpecGcsDataSinkArgs']]):
        pulumi.set(self, "gcs_data_sink", value)

    @_builtins.property
    @pulumi.getter(name="gcsDataSource")
    def gcs_data_source(self) -> Optional[pulumi.Input['TransferJobTransferSpecGcsDataSourceArgs']]:
        """
        A Google Cloud Storage data source. Structure documented below.
        """
        return pulumi.get(self, "gcs_data_source")

    @gcs_data_source.setter
    def gcs_data_source(self, value: Optional[pulumi.Input['TransferJobTransferSpecGcsDataSourceArgs']]):
        pulumi.set(self, "gcs_data_source", value)

    @_builtins.property
    @pulumi.getter(name="hdfsDataSource")
    def hdfs_data_source(self) -> Optional[pulumi.Input['TransferJobTransferSpecHdfsDataSourceArgs']]:
        """
        An HDFS data source. Structure documented below.
        """
        return pulumi.get(self, "hdfs_data_source")

    @hdfs_data_source.setter
    def hdfs_data_source(self, value: Optional[pulumi.Input['TransferJobTransferSpecHdfsDataSourceArgs']]):
        pulumi.set(self, "hdfs_data_source", value)

    @_builtins.property
    @pulumi.getter(name="httpDataSource")
    def http_data_source(self) -> Optional[pulumi.Input['TransferJobTransferSpecHttpDataSourceArgs']]:
        """
        A HTTP URL data source. Structure documented below.
        """
        return pulumi.get(self, "http_data_source")

    @http_data_source.setter
    def http_data_source(self, value: Optional[pulumi.Input['TransferJobTransferSpecHttpDataSourceArgs']]):
        pulumi.set(self, "http_data_source", value)

    @_builtins.property
    @pulumi.getter(name="objectConditions")
    def object_conditions(self) -> Optional[pulumi.Input['TransferJobTransferSpecObjectConditionsArgs']]:
        """
        Only objects that satisfy these object conditions are included in the set of data source and data sink objects. Object conditions based on objects' `last_modification_time` do not exclude objects in a data sink. Structure documented below.
        """
        return pulumi.get(self, "object_conditions")

    @object_conditions.setter
    def object_conditions(self, value: Optional[pulumi.Input['TransferJobTransferSpecObjectConditionsArgs']]):
        pulumi.set(self, "object_conditions", value)

    @_builtins.property
    @pulumi.getter(name="posixDataSink")
    def posix_data_sink(self) -> Optional[pulumi.Input['TransferJobTransferSpecPosixDataSinkArgs']]:
        """
        A POSIX data sink. Structure documented below.
        """
        return pulumi.get(self, "posix_data_sink")

    @posix_data_sink.setter
    def posix_data_sink(self, value: Optional[pulumi.Input['TransferJobTransferSpecPosixDataSinkArgs']]):
        pulumi.set(self, "posix_data_sink", value)

    @_builtins.property
    @pulumi.getter(name="posixDataSource")
    def posix_data_source(self) -> Optional[pulumi.Input['TransferJobTransferSpecPosixDataSourceArgs']]:
        """
        A POSIX filesystem data source. Structure documented below.
        """
        return pulumi.get(self, "posix_data_source")

    @posix_data_source.setter
    def posix_data_source(self, value: Optional[pulumi.Input['TransferJobTransferSpecPosixDataSourceArgs']]):
        pulumi.set(self, "posix_data_source", value)

    @_builtins.property
    @pulumi.getter(name="sinkAgentPoolName")
    def sink_agent_pool_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the agent pool name associated with the posix data sink. When unspecified, the default name is used.
        """
        return pulumi.get(self, "sink_agent_pool_name")

    @sink_agent_pool_name.setter
    def sink_agent_pool_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sink_agent_pool_name", value)

    @_builtins.property
    @pulumi.getter(name="sourceAgentPoolName")
    def source_agent_pool_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the agent pool name associated with the posix data source. When unspecified, the default name is used.
        """
        return pulumi.get(self, "source_agent_pool_name")

    @source_agent_pool_name.setter
    def source_agent_pool_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "source_agent_pool_name", value)

    @_builtins.property
    @pulumi.getter(name="transferManifest")
    def transfer_manifest(self) -> Optional[pulumi.Input['TransferJobTransferSpecTransferManifestArgs']]:
        """
        Use a manifest file to limit which object are transferred. See [Storage Transfer Service manifest file format](https://cloud.google.com/storage-transfer/docs/manifest). Structure documented below.
        """
        return pulumi.get(self, "transfer_manifest")

    @transfer_manifest.setter
    def transfer_manifest(self, value: Optional[pulumi.Input['TransferJobTransferSpecTransferManifestArgs']]):
        pulumi.set(self, "transfer_manifest", value)

    @_builtins.property
    @pulumi.getter(name="transferOptions")
    def transfer_options(self) -> Optional[pulumi.Input['TransferJobTransferSpecTransferOptionsArgs']]:
        """
        Characteristics of how to treat files from datasource and sink during job. If the option `delete_objects_unique_in_sink` is true, object conditions based on objects' `last_modification_time` are ignored and do not exclude objects in a data source or a data sink. Structure documented below.
        """
        return pulumi.get(self, "transfer_options")

    @transfer_options.setter
    def transfer_options(self, value: Optional[pulumi.Input['TransferJobTransferSpecTransferOptionsArgs']]):
        pulumi.set(self, "transfer_options", value)


if not MYPY:
    class TransferJobTransferSpecAwsS3CompatibleDataSourceArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        """
        Name of the bucket.
        """
        endpoint: pulumi.Input[_builtins.str]
        """
        Endpoint of the storage service.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the path to transfer objects.
        """
        region: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the region to sign requests with. This can be left blank if requests should be signed with an empty region.
        """
        s3_metadata: NotRequired[pulumi.Input['TransferJobTransferSpecAwsS3CompatibleDataSourceS3MetadataArgsDict']]
        """
        S3 compatible metadata.
        """
elif False:
    TransferJobTransferSpecAwsS3CompatibleDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobTransferSpecAwsS3CompatibleDataSourceArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 endpoint: pulumi.Input[_builtins.str],
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 region: Optional[pulumi.Input[_builtins.str]] = None,
                 s3_metadata: Optional[pulumi.Input['TransferJobTransferSpecAwsS3CompatibleDataSourceS3MetadataArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: Name of the bucket.
        :param pulumi.Input[_builtins.str] endpoint: Endpoint of the storage service.
        :param pulumi.Input[_builtins.str] path: Specifies the path to transfer objects.
        :param pulumi.Input[_builtins.str] region: Specifies the region to sign requests with. This can be left blank if requests should be signed with an empty region.
        :param pulumi.Input['TransferJobTransferSpecAwsS3CompatibleDataSourceS3MetadataArgs'] s3_metadata: S3 compatible metadata.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        pulumi.set(__self__, "endpoint", endpoint)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if region is not None:
            pulumi.set(__self__, "region", region)
        if s3_metadata is not None:
            pulumi.set(__self__, "s3_metadata", s3_metadata)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the bucket.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        Endpoint of the storage service.
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "endpoint", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the path to transfer objects.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def region(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the region to sign requests with. This can be left blank if requests should be signed with an empty region.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "region", value)

    @_builtins.property
    @pulumi.getter(name="s3Metadata")
    def s3_metadata(self) -> Optional[pulumi.Input['TransferJobTransferSpecAwsS3CompatibleDataSourceS3MetadataArgs']]:
        """
        S3 compatible metadata.
        """
        return pulumi.get(self, "s3_metadata")

    @s3_metadata.setter
    def s3_metadata(self, value: Optional[pulumi.Input['TransferJobTransferSpecAwsS3CompatibleDataSourceS3MetadataArgs']]):
        pulumi.set(self, "s3_metadata", value)


if not MYPY:
    class TransferJobTransferSpecAwsS3CompatibleDataSourceS3MetadataArgsDict(TypedDict):
        auth_method: NotRequired[pulumi.Input[_builtins.str]]
        """
        Authentication and authorization method used by the storage service. When not specified, Transfer Service will attempt to determine right auth method to use.
        """
        list_api: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Listing API to use for discovering objects. When not specified, Transfer Service will attempt to determine the right API to use.
        """
        protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The network protocol of the agent. When not specified, the default value of NetworkProtocol NETWORK_PROTOCOL_HTTPS is used.
        """
        request_model: NotRequired[pulumi.Input[_builtins.str]]
        """
        API request model used to call the storage service. When not specified, the default value of RequestModel REQUEST_MODEL_VIRTUAL_HOSTED_STYLE is used.
        """
elif False:
    TransferJobTransferSpecAwsS3CompatibleDataSourceS3MetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobTransferSpecAwsS3CompatibleDataSourceS3MetadataArgs:
    def __init__(__self__, *,
                 auth_method: Optional[pulumi.Input[_builtins.str]] = None,
                 list_api: Optional[pulumi.Input[_builtins.str]] = None,
                 protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 request_model: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] auth_method: Authentication and authorization method used by the storage service. When not specified, Transfer Service will attempt to determine right auth method to use.
        :param pulumi.Input[_builtins.str] list_api: The Listing API to use for discovering objects. When not specified, Transfer Service will attempt to determine the right API to use.
        :param pulumi.Input[_builtins.str] protocol: The network protocol of the agent. When not specified, the default value of NetworkProtocol NETWORK_PROTOCOL_HTTPS is used.
        :param pulumi.Input[_builtins.str] request_model: API request model used to call the storage service. When not specified, the default value of RequestModel REQUEST_MODEL_VIRTUAL_HOSTED_STYLE is used.
        """
        if auth_method is not None:
            pulumi.set(__self__, "auth_method", auth_method)
        if list_api is not None:
            pulumi.set(__self__, "list_api", list_api)
        if protocol is not None:
            pulumi.set(__self__, "protocol", protocol)
        if request_model is not None:
            pulumi.set(__self__, "request_model", request_model)

    @_builtins.property
    @pulumi.getter(name="authMethod")
    def auth_method(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Authentication and authorization method used by the storage service. When not specified, Transfer Service will attempt to determine right auth method to use.
        """
        return pulumi.get(self, "auth_method")

    @auth_method.setter
    def auth_method(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "auth_method", value)

    @_builtins.property
    @pulumi.getter(name="listApi")
    def list_api(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Listing API to use for discovering objects. When not specified, Transfer Service will attempt to determine the right API to use.
        """
        return pulumi.get(self, "list_api")

    @list_api.setter
    def list_api(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "list_api", value)

    @_builtins.property
    @pulumi.getter
    def protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The network protocol of the agent. When not specified, the default value of NetworkProtocol NETWORK_PROTOCOL_HTTPS is used.
        """
        return pulumi.get(self, "protocol")

    @protocol.setter
    def protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "protocol", value)

    @_builtins.property
    @pulumi.getter(name="requestModel")
    def request_model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        API request model used to call the storage service. When not specified, the default value of RequestModel REQUEST_MODEL_VIRTUAL_HOSTED_STYLE is used.
        """
        return pulumi.get(self, "request_model")

    @request_model.setter
    def request_model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request_model", value)


if not MYPY:
    class TransferJobTransferSpecAwsS3DataSourceArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        """
        S3 Bucket name.
        """
        aws_access_key: NotRequired[pulumi.Input['TransferJobTransferSpecAwsS3DataSourceAwsAccessKeyArgsDict']]
        """
        AWS credentials block.
        """
        cloudfront_domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        The CloudFront distribution domain name pointing to this bucket, to use when fetching. See [Transfer from S3 via CloudFront](https://cloud.google.com/storage-transfer/docs/s3-cloudfront) for more information. Format: https://{id}.cloudfront.net or any valid custom domain. Must begin with https://.
        """
        credentials_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Resource name of a secret in Secret Manager. AWS credentials must be stored in Secret Manager in JSON format. If credentials_secret is specified, do not specify role_arn or aws_access_key. Format: projects/{projectNumber}/secrets/{secret_name}.
        """
        managed_private_network: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Egress bytes over a Google-managed private network. This network is shared between other users of Storage Transfer Service.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        S3 Bucket path in bucket to transfer.
        """
        role_arn: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Amazon Resource Name (ARN) of the role to support temporary credentials via 'AssumeRoleWithWebIdentity'. For more information about ARNs, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns). When a role ARN is provided, Transfer Service fetches temporary credentials for the session using a 'AssumeRoleWithWebIdentity' call for the provided role using the [GoogleServiceAccount][] for this project.
        """
elif False:
    TransferJobTransferSpecAwsS3DataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobTransferSpecAwsS3DataSourceArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 aws_access_key: Optional[pulumi.Input['TransferJobTransferSpecAwsS3DataSourceAwsAccessKeyArgs']] = None,
                 cloudfront_domain: Optional[pulumi.Input[_builtins.str]] = None,
                 credentials_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 managed_private_network: Optional[pulumi.Input[_builtins.bool]] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None,
                 role_arn: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: S3 Bucket name.
        :param pulumi.Input['TransferJobTransferSpecAwsS3DataSourceAwsAccessKeyArgs'] aws_access_key: AWS credentials block.
        :param pulumi.Input[_builtins.str] cloudfront_domain: The CloudFront distribution domain name pointing to this bucket, to use when fetching. See [Transfer from S3 via CloudFront](https://cloud.google.com/storage-transfer/docs/s3-cloudfront) for more information. Format: https://{id}.cloudfront.net or any valid custom domain. Must begin with https://.
        :param pulumi.Input[_builtins.str] credentials_secret: The Resource name of a secret in Secret Manager. AWS credentials must be stored in Secret Manager in JSON format. If credentials_secret is specified, do not specify role_arn or aws_access_key. Format: projects/{projectNumber}/secrets/{secret_name}.
        :param pulumi.Input[_builtins.bool] managed_private_network: Egress bytes over a Google-managed private network. This network is shared between other users of Storage Transfer Service.
        :param pulumi.Input[_builtins.str] path: S3 Bucket path in bucket to transfer.
        :param pulumi.Input[_builtins.str] role_arn: The Amazon Resource Name (ARN) of the role to support temporary credentials via 'AssumeRoleWithWebIdentity'. For more information about ARNs, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns). When a role ARN is provided, Transfer Service fetches temporary credentials for the session using a 'AssumeRoleWithWebIdentity' call for the provided role using the [GoogleServiceAccount][] for this project.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        if aws_access_key is not None:
            pulumi.set(__self__, "aws_access_key", aws_access_key)
        if cloudfront_domain is not None:
            pulumi.set(__self__, "cloudfront_domain", cloudfront_domain)
        if credentials_secret is not None:
            pulumi.set(__self__, "credentials_secret", credentials_secret)
        if managed_private_network is not None:
            pulumi.set(__self__, "managed_private_network", managed_private_network)
        if path is not None:
            pulumi.set(__self__, "path", path)
        if role_arn is not None:
            pulumi.set(__self__, "role_arn", role_arn)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        S3 Bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter(name="awsAccessKey")
    def aws_access_key(self) -> Optional[pulumi.Input['TransferJobTransferSpecAwsS3DataSourceAwsAccessKeyArgs']]:
        """
        AWS credentials block.
        """
        return pulumi.get(self, "aws_access_key")

    @aws_access_key.setter
    def aws_access_key(self, value: Optional[pulumi.Input['TransferJobTransferSpecAwsS3DataSourceAwsAccessKeyArgs']]):
        pulumi.set(self, "aws_access_key", value)

    @_builtins.property
    @pulumi.getter(name="cloudfrontDomain")
    def cloudfront_domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The CloudFront distribution domain name pointing to this bucket, to use when fetching. See [Transfer from S3 via CloudFront](https://cloud.google.com/storage-transfer/docs/s3-cloudfront) for more information. Format: https://{id}.cloudfront.net or any valid custom domain. Must begin with https://.
        """
        return pulumi.get(self, "cloudfront_domain")

    @cloudfront_domain.setter
    def cloudfront_domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cloudfront_domain", value)

    @_builtins.property
    @pulumi.getter(name="credentialsSecret")
    def credentials_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Resource name of a secret in Secret Manager. AWS credentials must be stored in Secret Manager in JSON format. If credentials_secret is specified, do not specify role_arn or aws_access_key. Format: projects/{projectNumber}/secrets/{secret_name}.
        """
        return pulumi.get(self, "credentials_secret")

    @credentials_secret.setter
    def credentials_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "credentials_secret", value)

    @_builtins.property
    @pulumi.getter(name="managedPrivateNetwork")
    def managed_private_network(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Egress bytes over a Google-managed private network. This network is shared between other users of Storage Transfer Service.
        """
        return pulumi.get(self, "managed_private_network")

    @managed_private_network.setter
    def managed_private_network(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "managed_private_network", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        S3 Bucket path in bucket to transfer.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter(name="roleArn")
    def role_arn(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Amazon Resource Name (ARN) of the role to support temporary credentials via 'AssumeRoleWithWebIdentity'. For more information about ARNs, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html#identifiers-arns). When a role ARN is provided, Transfer Service fetches temporary credentials for the session using a 'AssumeRoleWithWebIdentity' call for the provided role using the [GoogleServiceAccount][] for this project.
        """
        return pulumi.get(self, "role_arn")

    @role_arn.setter
    def role_arn(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role_arn", value)


if not MYPY:
    class TransferJobTransferSpecAwsS3DataSourceAwsAccessKeyArgsDict(TypedDict):
        access_key_id: pulumi.Input[_builtins.str]
        """
        AWS Key ID.
        """
        secret_access_key: pulumi.Input[_builtins.str]
        """
        AWS Secret Access Key.
        """
elif False:
    TransferJobTransferSpecAwsS3DataSourceAwsAccessKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobTransferSpecAwsS3DataSourceAwsAccessKeyArgs:
    def __init__(__self__, *,
                 access_key_id: pulumi.Input[_builtins.str],
                 secret_access_key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] access_key_id: AWS Key ID.
        :param pulumi.Input[_builtins.str] secret_access_key: AWS Secret Access Key.
        """
        pulumi.set(__self__, "access_key_id", access_key_id)
        pulumi.set(__self__, "secret_access_key", secret_access_key)

    @_builtins.property
    @pulumi.getter(name="accessKeyId")
    def access_key_id(self) -> pulumi.Input[_builtins.str]:
        """
        AWS Key ID.
        """
        return pulumi.get(self, "access_key_id")

    @access_key_id.setter
    def access_key_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "access_key_id", value)

    @_builtins.property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> pulumi.Input[_builtins.str]:
        """
        AWS Secret Access Key.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret_access_key", value)


if not MYPY:
    class TransferJobTransferSpecAzureBlobStorageDataSourceArgsDict(TypedDict):
        container: pulumi.Input[_builtins.str]
        """
        The container to transfer from the Azure Storage account.`
        """
        storage_account: pulumi.Input[_builtins.str]
        """
        The name of the Azure Storage account.
        """
        azure_credentials: NotRequired[pulumi.Input['TransferJobTransferSpecAzureBlobStorageDataSourceAzureCredentialsArgsDict']]
        """
        ) Credentials used to authenticate API requests to Azure block.
        """
        credentials_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        ) Full Resource name of a secret in Secret Manager containing [SAS Credentials in JSON form](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#azureblobstoragedata:~:text=begin%20with%20a%20%27/%27.-,credentialsSecret,-string). Service Agent for Storage Transfer must have permissions to access secret. If credentials_secret is specified, do not specify azure_credentials.`,
        """
        federated_identity_config: NotRequired[pulumi.Input['TransferJobTransferSpecAzureBlobStorageDataSourceFederatedIdentityConfigArgsDict']]
        """
        Federated identity config of a user registered Azure application. Structure documented below.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
        """
elif False:
    TransferJobTransferSpecAzureBlobStorageDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobTransferSpecAzureBlobStorageDataSourceArgs:
    def __init__(__self__, *,
                 container: pulumi.Input[_builtins.str],
                 storage_account: pulumi.Input[_builtins.str],
                 azure_credentials: Optional[pulumi.Input['TransferJobTransferSpecAzureBlobStorageDataSourceAzureCredentialsArgs']] = None,
                 credentials_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 federated_identity_config: Optional[pulumi.Input['TransferJobTransferSpecAzureBlobStorageDataSourceFederatedIdentityConfigArgs']] = None,
                 path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] container: The container to transfer from the Azure Storage account.`
        :param pulumi.Input[_builtins.str] storage_account: The name of the Azure Storage account.
        :param pulumi.Input['TransferJobTransferSpecAzureBlobStorageDataSourceAzureCredentialsArgs'] azure_credentials: ) Credentials used to authenticate API requests to Azure block.
        :param pulumi.Input[_builtins.str] credentials_secret: ) Full Resource name of a secret in Secret Manager containing [SAS Credentials in JSON form](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#azureblobstoragedata:~:text=begin%20with%20a%20%27/%27.-,credentialsSecret,-string). Service Agent for Storage Transfer must have permissions to access secret. If credentials_secret is specified, do not specify azure_credentials.`,
        :param pulumi.Input['TransferJobTransferSpecAzureBlobStorageDataSourceFederatedIdentityConfigArgs'] federated_identity_config: Federated identity config of a user registered Azure application. Structure documented below.
        :param pulumi.Input[_builtins.str] path: Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
        """
        pulumi.set(__self__, "container", container)
        pulumi.set(__self__, "storage_account", storage_account)
        if azure_credentials is not None:
            pulumi.set(__self__, "azure_credentials", azure_credentials)
        if credentials_secret is not None:
            pulumi.set(__self__, "credentials_secret", credentials_secret)
        if federated_identity_config is not None:
            pulumi.set(__self__, "federated_identity_config", federated_identity_config)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def container(self) -> pulumi.Input[_builtins.str]:
        """
        The container to transfer from the Azure Storage account.`
        """
        return pulumi.get(self, "container")

    @container.setter
    def container(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "container", value)

    @_builtins.property
    @pulumi.getter(name="storageAccount")
    def storage_account(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the Azure Storage account.
        """
        return pulumi.get(self, "storage_account")

    @storage_account.setter
    def storage_account(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "storage_account", value)

    @_builtins.property
    @pulumi.getter(name="azureCredentials")
    def azure_credentials(self) -> Optional[pulumi.Input['TransferJobTransferSpecAzureBlobStorageDataSourceAzureCredentialsArgs']]:
        """
        ) Credentials used to authenticate API requests to Azure block.
        """
        return pulumi.get(self, "azure_credentials")

    @azure_credentials.setter
    def azure_credentials(self, value: Optional[pulumi.Input['TransferJobTransferSpecAzureBlobStorageDataSourceAzureCredentialsArgs']]):
        pulumi.set(self, "azure_credentials", value)

    @_builtins.property
    @pulumi.getter(name="credentialsSecret")
    def credentials_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ) Full Resource name of a secret in Secret Manager containing [SAS Credentials in JSON form](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#azureblobstoragedata:~:text=begin%20with%20a%20%27/%27.-,credentialsSecret,-string). Service Agent for Storage Transfer must have permissions to access secret. If credentials_secret is specified, do not specify azure_credentials.`,
        """
        return pulumi.get(self, "credentials_secret")

    @credentials_secret.setter
    def credentials_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "credentials_secret", value)

    @_builtins.property
    @pulumi.getter(name="federatedIdentityConfig")
    def federated_identity_config(self) -> Optional[pulumi.Input['TransferJobTransferSpecAzureBlobStorageDataSourceFederatedIdentityConfigArgs']]:
        """
        Federated identity config of a user registered Azure application. Structure documented below.
        """
        return pulumi.get(self, "federated_identity_config")

    @federated_identity_config.setter
    def federated_identity_config(self, value: Optional[pulumi.Input['TransferJobTransferSpecAzureBlobStorageDataSourceFederatedIdentityConfigArgs']]):
        pulumi.set(self, "federated_identity_config", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class TransferJobTransferSpecAzureBlobStorageDataSourceAzureCredentialsArgsDict(TypedDict):
        sas_token: pulumi.Input[_builtins.str]
        """
        Azure shared access signature. See [Grant limited access to Azure Storage resources using shared access signatures (SAS)](https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview).
        """
elif False:
    TransferJobTransferSpecAzureBlobStorageDataSourceAzureCredentialsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobTransferSpecAzureBlobStorageDataSourceAzureCredentialsArgs:
    def __init__(__self__, *,
                 sas_token: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] sas_token: Azure shared access signature. See [Grant limited access to Azure Storage resources using shared access signatures (SAS)](https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview).
        """
        pulumi.set(__self__, "sas_token", sas_token)

    @_builtins.property
    @pulumi.getter(name="sasToken")
    def sas_token(self) -> pulumi.Input[_builtins.str]:
        """
        Azure shared access signature. See [Grant limited access to Azure Storage resources using shared access signatures (SAS)](https://docs.microsoft.com/en-us/azure/storage/common/storage-sas-overview).
        """
        return pulumi.get(self, "sas_token")

    @sas_token.setter
    def sas_token(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sas_token", value)


if not MYPY:
    class TransferJobTransferSpecAzureBlobStorageDataSourceFederatedIdentityConfigArgsDict(TypedDict):
        client_id: pulumi.Input[_builtins.str]
        """
        The client (application) ID of the application with federated credentials.
        """
        tenant_id: pulumi.Input[_builtins.str]
        """
        The client (directory) ID of the application with federated credentials.

        <a name="nested_schedule_start_end_date"></a>The `schedule_start_date` and `schedule_end_date` blocks support:
        """
elif False:
    TransferJobTransferSpecAzureBlobStorageDataSourceFederatedIdentityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobTransferSpecAzureBlobStorageDataSourceFederatedIdentityConfigArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[_builtins.str],
                 tenant_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] client_id: The client (application) ID of the application with federated credentials.
        :param pulumi.Input[_builtins.str] tenant_id: The client (directory) ID of the application with federated credentials.
               
               <a name="nested_schedule_start_end_date"></a>The `schedule_start_date` and `schedule_end_date` blocks support:
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "tenant_id", tenant_id)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        """
        The client (application) ID of the application with federated credentials.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="tenantId")
    def tenant_id(self) -> pulumi.Input[_builtins.str]:
        """
        The client (directory) ID of the application with federated credentials.

        <a name="nested_schedule_start_end_date"></a>The `schedule_start_date` and `schedule_end_date` blocks support:
        """
        return pulumi.get(self, "tenant_id")

    @tenant_id.setter
    def tenant_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tenant_id", value)


if not MYPY:
    class TransferJobTransferSpecGcsDataSinkArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        """
        Google Cloud Storage bucket name.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
        """
elif False:
    TransferJobTransferSpecGcsDataSinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobTransferSpecGcsDataSinkArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: Google Cloud Storage bucket name.
        :param pulumi.Input[_builtins.str] path: Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        Google Cloud Storage bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class TransferJobTransferSpecGcsDataSourceArgsDict(TypedDict):
        bucket_name: pulumi.Input[_builtins.str]
        """
        Google Cloud Storage bucket name.
        """
        path: NotRequired[pulumi.Input[_builtins.str]]
        """
        Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
        """
elif False:
    TransferJobTransferSpecGcsDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobTransferSpecGcsDataSourceArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[_builtins.str],
                 path: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] bucket_name: Google Cloud Storage bucket name.
        :param pulumi.Input[_builtins.str] path: Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[_builtins.str]:
        """
        Google Cloud Storage bucket name.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "bucket_name", value)

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class TransferJobTransferSpecHdfsDataSourceArgsDict(TypedDict):
        path: pulumi.Input[_builtins.str]
        """
        Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
        """
elif False:
    TransferJobTransferSpecHdfsDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobTransferSpecHdfsDataSourceArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] path: Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
        """
        pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        Root path to transfer objects. Must be an empty string or full path name that ends with a '/'. This field is treated as an object prefix. As such, it should generally not begin with a '/'.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)


if not MYPY:
    class TransferJobTransferSpecHttpDataSourceArgsDict(TypedDict):
        list_url: pulumi.Input[_builtins.str]
        """
        The URL that points to the file that stores the object list entries. This file must allow public access. Currently, only URLs with HTTP and HTTPS schemes are supported.
        """
elif False:
    TransferJobTransferSpecHttpDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobTransferSpecHttpDataSourceArgs:
    def __init__(__self__, *,
                 list_url: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] list_url: The URL that points to the file that stores the object list entries. This file must allow public access. Currently, only URLs with HTTP and HTTPS schemes are supported.
        """
        pulumi.set(__self__, "list_url", list_url)

    @_builtins.property
    @pulumi.getter(name="listUrl")
    def list_url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL that points to the file that stores the object list entries. This file must allow public access. Currently, only URLs with HTTP and HTTPS schemes are supported.
        """
        return pulumi.get(self, "list_url")

    @list_url.setter
    def list_url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "list_url", value)


if not MYPY:
    class TransferJobTransferSpecObjectConditionsArgsDict(TypedDict):
        exclude_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        `exclude_prefixes` must follow the requirements described for `include_prefixes`. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
        """
        include_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        If `include_prefixes` is specified, objects that satisfy the object conditions must have names that start with one of the `include_prefixes` and that do not start with any of the `exclude_prefixes`. If `include_prefixes` is not specified, all objects except those that have names starting with one of the `exclude_prefixes` must satisfy the object conditions. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
        """
        last_modified_before: NotRequired[pulumi.Input[_builtins.str]]
        """
        If specified, only objects with a "last modification time" before this timestamp and objects that don't have a "last modification time" are transferred. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        last_modified_since: NotRequired[pulumi.Input[_builtins.str]]
        """
        If specified, only objects with a "last modification time" on or after this timestamp and objects that don't have a "last modification time" are transferred. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        max_time_elapsed_since_last_modification: NotRequired[pulumi.Input[_builtins.str]]
        """
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        min_time_elapsed_since_last_modification: NotRequired[pulumi.Input[_builtins.str]]
        """
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
elif False:
    TransferJobTransferSpecObjectConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobTransferSpecObjectConditionsArgs:
    def __init__(__self__, *,
                 exclude_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 last_modified_before: Optional[pulumi.Input[_builtins.str]] = None,
                 last_modified_since: Optional[pulumi.Input[_builtins.str]] = None,
                 max_time_elapsed_since_last_modification: Optional[pulumi.Input[_builtins.str]] = None,
                 min_time_elapsed_since_last_modification: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_prefixes: `exclude_prefixes` must follow the requirements described for `include_prefixes`. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_prefixes: If `include_prefixes` is specified, objects that satisfy the object conditions must have names that start with one of the `include_prefixes` and that do not start with any of the `exclude_prefixes`. If `include_prefixes` is not specified, all objects except those that have names starting with one of the `exclude_prefixes` must satisfy the object conditions. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
        :param pulumi.Input[_builtins.str] last_modified_before: If specified, only objects with a "last modification time" before this timestamp and objects that don't have a "last modification time" are transferred. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        :param pulumi.Input[_builtins.str] last_modified_since: If specified, only objects with a "last modification time" on or after this timestamp and objects that don't have a "last modification time" are transferred. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        :param pulumi.Input[_builtins.str] max_time_elapsed_since_last_modification: A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        :param pulumi.Input[_builtins.str] min_time_elapsed_since_last_modification: A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        if exclude_prefixes is not None:
            pulumi.set(__self__, "exclude_prefixes", exclude_prefixes)
        if include_prefixes is not None:
            pulumi.set(__self__, "include_prefixes", include_prefixes)
        if last_modified_before is not None:
            pulumi.set(__self__, "last_modified_before", last_modified_before)
        if last_modified_since is not None:
            pulumi.set(__self__, "last_modified_since", last_modified_since)
        if max_time_elapsed_since_last_modification is not None:
            pulumi.set(__self__, "max_time_elapsed_since_last_modification", max_time_elapsed_since_last_modification)
        if min_time_elapsed_since_last_modification is not None:
            pulumi.set(__self__, "min_time_elapsed_since_last_modification", min_time_elapsed_since_last_modification)

    @_builtins.property
    @pulumi.getter(name="excludePrefixes")
    def exclude_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        `exclude_prefixes` must follow the requirements described for `include_prefixes`. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
        """
        return pulumi.get(self, "exclude_prefixes")

    @exclude_prefixes.setter
    def exclude_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_prefixes", value)

    @_builtins.property
    @pulumi.getter(name="includePrefixes")
    def include_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        If `include_prefixes` is specified, objects that satisfy the object conditions must have names that start with one of the `include_prefixes` and that do not start with any of the `exclude_prefixes`. If `include_prefixes` is not specified, all objects except those that have names starting with one of the `exclude_prefixes` must satisfy the object conditions. See [Requirements](https://cloud.google.com/storage-transfer/docs/reference/rest/v1/TransferSpec#ObjectConditions).
        """
        return pulumi.get(self, "include_prefixes")

    @include_prefixes.setter
    def include_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_prefixes", value)

    @_builtins.property
    @pulumi.getter(name="lastModifiedBefore")
    def last_modified_before(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If specified, only objects with a "last modification time" before this timestamp and objects that don't have a "last modification time" are transferred. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "last_modified_before")

    @last_modified_before.setter
    def last_modified_before(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_modified_before", value)

    @_builtins.property
    @pulumi.getter(name="lastModifiedSince")
    def last_modified_since(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        If specified, only objects with a "last modification time" on or after this timestamp and objects that don't have a "last modification time" are transferred. A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "last_modified_since")

    @last_modified_since.setter
    def last_modified_since(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_modified_since", value)

    @_builtins.property
    @pulumi.getter(name="maxTimeElapsedSinceLastModification")
    def max_time_elapsed_since_last_modification(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        return pulumi.get(self, "max_time_elapsed_since_last_modification")

    @max_time_elapsed_since_last_modification.setter
    def max_time_elapsed_since_last_modification(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_time_elapsed_since_last_modification", value)

    @_builtins.property
    @pulumi.getter(name="minTimeElapsedSinceLastModification")
    def min_time_elapsed_since_last_modification(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        return pulumi.get(self, "min_time_elapsed_since_last_modification")

    @min_time_elapsed_since_last_modification.setter
    def min_time_elapsed_since_last_modification(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_time_elapsed_since_last_modification", value)


if not MYPY:
    class TransferJobTransferSpecPosixDataSinkArgsDict(TypedDict):
        root_directory: pulumi.Input[_builtins.str]
        """
        Root directory path to the filesystem.
        """
elif False:
    TransferJobTransferSpecPosixDataSinkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobTransferSpecPosixDataSinkArgs:
    def __init__(__self__, *,
                 root_directory: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] root_directory: Root directory path to the filesystem.
        """
        pulumi.set(__self__, "root_directory", root_directory)

    @_builtins.property
    @pulumi.getter(name="rootDirectory")
    def root_directory(self) -> pulumi.Input[_builtins.str]:
        """
        Root directory path to the filesystem.
        """
        return pulumi.get(self, "root_directory")

    @root_directory.setter
    def root_directory(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "root_directory", value)


if not MYPY:
    class TransferJobTransferSpecPosixDataSourceArgsDict(TypedDict):
        root_directory: pulumi.Input[_builtins.str]
        """
        Root directory path to the filesystem.
        """
elif False:
    TransferJobTransferSpecPosixDataSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobTransferSpecPosixDataSourceArgs:
    def __init__(__self__, *,
                 root_directory: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] root_directory: Root directory path to the filesystem.
        """
        pulumi.set(__self__, "root_directory", root_directory)

    @_builtins.property
    @pulumi.getter(name="rootDirectory")
    def root_directory(self) -> pulumi.Input[_builtins.str]:
        """
        Root directory path to the filesystem.
        """
        return pulumi.get(self, "root_directory")

    @root_directory.setter
    def root_directory(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "root_directory", value)


if not MYPY:
    class TransferJobTransferSpecTransferManifestArgsDict(TypedDict):
        location: pulumi.Input[_builtins.str]
        """
        The **GCS URI** to the manifest file (CSV or line-delimited). Example: `gs://my-bucket/manifest.csv`
        """
elif False:
    TransferJobTransferSpecTransferManifestArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobTransferSpecTransferManifestArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] location: The **GCS URI** to the manifest file (CSV or line-delimited). Example: `gs://my-bucket/manifest.csv`
        """
        pulumi.set(__self__, "location", location)

    @_builtins.property
    @pulumi.getter
    def location(self) -> pulumi.Input[_builtins.str]:
        """
        The **GCS URI** to the manifest file (CSV or line-delimited). Example: `gs://my-bucket/manifest.csv`
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "location", value)


if not MYPY:
    class TransferJobTransferSpecTransferOptionsArgsDict(TypedDict):
        delete_objects_from_source_after_transfer: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether objects should be deleted from the source after they are transferred to the sink. Note that this option and `delete_objects_unique_in_sink` are mutually exclusive.
        """
        delete_objects_unique_in_sink: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether objects that exist only in the sink should be deleted. Note that this option and
        `delete_objects_from_source_after_transfer` are mutually exclusive.
        """
        metadata_options: NotRequired[pulumi.Input['TransferJobTransferSpecTransferOptionsMetadataOptionsArgsDict']]
        """
        Specifies the metadata options for running a transfer. Structure documented below.
        """
        overwrite_objects_already_existing_in_sink: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether overwriting objects that already exist in the sink is allowed.
        """
        overwrite_when: NotRequired[pulumi.Input[_builtins.str]]
        """
        When to overwrite objects that already exist in the sink. If not set, overwrite behavior is determined by `overwrite_objects_already_existing_in_sink`. Possible values: ALWAYS, DIFFERENT, NEVER.
        """
elif False:
    TransferJobTransferSpecTransferOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobTransferSpecTransferOptionsArgs:
    def __init__(__self__, *,
                 delete_objects_from_source_after_transfer: Optional[pulumi.Input[_builtins.bool]] = None,
                 delete_objects_unique_in_sink: Optional[pulumi.Input[_builtins.bool]] = None,
                 metadata_options: Optional[pulumi.Input['TransferJobTransferSpecTransferOptionsMetadataOptionsArgs']] = None,
                 overwrite_objects_already_existing_in_sink: Optional[pulumi.Input[_builtins.bool]] = None,
                 overwrite_when: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] delete_objects_from_source_after_transfer: Whether objects should be deleted from the source after they are transferred to the sink. Note that this option and `delete_objects_unique_in_sink` are mutually exclusive.
        :param pulumi.Input[_builtins.bool] delete_objects_unique_in_sink: Whether objects that exist only in the sink should be deleted. Note that this option and
               `delete_objects_from_source_after_transfer` are mutually exclusive.
        :param pulumi.Input['TransferJobTransferSpecTransferOptionsMetadataOptionsArgs'] metadata_options: Specifies the metadata options for running a transfer. Structure documented below.
        :param pulumi.Input[_builtins.bool] overwrite_objects_already_existing_in_sink: Whether overwriting objects that already exist in the sink is allowed.
        :param pulumi.Input[_builtins.str] overwrite_when: When to overwrite objects that already exist in the sink. If not set, overwrite behavior is determined by `overwrite_objects_already_existing_in_sink`. Possible values: ALWAYS, DIFFERENT, NEVER.
        """
        if delete_objects_from_source_after_transfer is not None:
            pulumi.set(__self__, "delete_objects_from_source_after_transfer", delete_objects_from_source_after_transfer)
        if delete_objects_unique_in_sink is not None:
            pulumi.set(__self__, "delete_objects_unique_in_sink", delete_objects_unique_in_sink)
        if metadata_options is not None:
            pulumi.set(__self__, "metadata_options", metadata_options)
        if overwrite_objects_already_existing_in_sink is not None:
            pulumi.set(__self__, "overwrite_objects_already_existing_in_sink", overwrite_objects_already_existing_in_sink)
        if overwrite_when is not None:
            pulumi.set(__self__, "overwrite_when", overwrite_when)

    @_builtins.property
    @pulumi.getter(name="deleteObjectsFromSourceAfterTransfer")
    def delete_objects_from_source_after_transfer(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether objects should be deleted from the source after they are transferred to the sink. Note that this option and `delete_objects_unique_in_sink` are mutually exclusive.
        """
        return pulumi.get(self, "delete_objects_from_source_after_transfer")

    @delete_objects_from_source_after_transfer.setter
    def delete_objects_from_source_after_transfer(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_objects_from_source_after_transfer", value)

    @_builtins.property
    @pulumi.getter(name="deleteObjectsUniqueInSink")
    def delete_objects_unique_in_sink(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether objects that exist only in the sink should be deleted. Note that this option and
        `delete_objects_from_source_after_transfer` are mutually exclusive.
        """
        return pulumi.get(self, "delete_objects_unique_in_sink")

    @delete_objects_unique_in_sink.setter
    def delete_objects_unique_in_sink(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "delete_objects_unique_in_sink", value)

    @_builtins.property
    @pulumi.getter(name="metadataOptions")
    def metadata_options(self) -> Optional[pulumi.Input['TransferJobTransferSpecTransferOptionsMetadataOptionsArgs']]:
        """
        Specifies the metadata options for running a transfer. Structure documented below.
        """
        return pulumi.get(self, "metadata_options")

    @metadata_options.setter
    def metadata_options(self, value: Optional[pulumi.Input['TransferJobTransferSpecTransferOptionsMetadataOptionsArgs']]):
        pulumi.set(self, "metadata_options", value)

    @_builtins.property
    @pulumi.getter(name="overwriteObjectsAlreadyExistingInSink")
    def overwrite_objects_already_existing_in_sink(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether overwriting objects that already exist in the sink is allowed.
        """
        return pulumi.get(self, "overwrite_objects_already_existing_in_sink")

    @overwrite_objects_already_existing_in_sink.setter
    def overwrite_objects_already_existing_in_sink(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "overwrite_objects_already_existing_in_sink", value)

    @_builtins.property
    @pulumi.getter(name="overwriteWhen")
    def overwrite_when(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        When to overwrite objects that already exist in the sink. If not set, overwrite behavior is determined by `overwrite_objects_already_existing_in_sink`. Possible values: ALWAYS, DIFFERENT, NEVER.
        """
        return pulumi.get(self, "overwrite_when")

    @overwrite_when.setter
    def overwrite_when(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "overwrite_when", value)


if not MYPY:
    class TransferJobTransferSpecTransferOptionsMetadataOptionsArgsDict(TypedDict):
        acl: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies how each object's ACLs should be preserved for transfers between Google Cloud Storage buckets.
        """
        gid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies how each file's POSIX group ID (GID) attribute should be handled by the transfer.
        """
        kms_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies how each object's Cloud KMS customer-managed encryption key (CMEK) is preserved for transfers between Google Cloud Storage buckets.
        """
        mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies how each file's mode attribute should be handled by the transfer.
        """
        storage_class: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies the storage class to set on objects being transferred to Google Cloud Storage buckets.
        """
        symlink: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies how symlinks should be handled by the transfer.
        """
        temporary_hold: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies how each object's temporary hold status should be preserved for transfers between Google Cloud Storage buckets.
        """
        time_created: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies how each object's timeCreated metadata is preserved for transfers.
        """
        uid: NotRequired[pulumi.Input[_builtins.str]]
        """
        Specifies how each file's POSIX user ID (UID) attribute should be handled by the transfer.
        """
elif False:
    TransferJobTransferSpecTransferOptionsMetadataOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TransferJobTransferSpecTransferOptionsMetadataOptionsArgs:
    def __init__(__self__, *,
                 acl: Optional[pulumi.Input[_builtins.str]] = None,
                 gid: Optional[pulumi.Input[_builtins.str]] = None,
                 kms_key: Optional[pulumi.Input[_builtins.str]] = None,
                 mode: Optional[pulumi.Input[_builtins.str]] = None,
                 storage_class: Optional[pulumi.Input[_builtins.str]] = None,
                 symlink: Optional[pulumi.Input[_builtins.str]] = None,
                 temporary_hold: Optional[pulumi.Input[_builtins.str]] = None,
                 time_created: Optional[pulumi.Input[_builtins.str]] = None,
                 uid: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] acl: Specifies how each object's ACLs should be preserved for transfers between Google Cloud Storage buckets.
        :param pulumi.Input[_builtins.str] gid: Specifies how each file's POSIX group ID (GID) attribute should be handled by the transfer.
        :param pulumi.Input[_builtins.str] kms_key: Specifies how each object's Cloud KMS customer-managed encryption key (CMEK) is preserved for transfers between Google Cloud Storage buckets.
        :param pulumi.Input[_builtins.str] mode: Specifies how each file's mode attribute should be handled by the transfer.
        :param pulumi.Input[_builtins.str] storage_class: Specifies the storage class to set on objects being transferred to Google Cloud Storage buckets.
        :param pulumi.Input[_builtins.str] symlink: Specifies how symlinks should be handled by the transfer.
        :param pulumi.Input[_builtins.str] temporary_hold: Specifies how each object's temporary hold status should be preserved for transfers between Google Cloud Storage buckets.
        :param pulumi.Input[_builtins.str] time_created: Specifies how each object's timeCreated metadata is preserved for transfers.
        :param pulumi.Input[_builtins.str] uid: Specifies how each file's POSIX user ID (UID) attribute should be handled by the transfer.
        """
        if acl is not None:
            pulumi.set(__self__, "acl", acl)
        if gid is not None:
            pulumi.set(__self__, "gid", gid)
        if kms_key is not None:
            pulumi.set(__self__, "kms_key", kms_key)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if storage_class is not None:
            pulumi.set(__self__, "storage_class", storage_class)
        if symlink is not None:
            pulumi.set(__self__, "symlink", symlink)
        if temporary_hold is not None:
            pulumi.set(__self__, "temporary_hold", temporary_hold)
        if time_created is not None:
            pulumi.set(__self__, "time_created", time_created)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @_builtins.property
    @pulumi.getter
    def acl(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies how each object's ACLs should be preserved for transfers between Google Cloud Storage buckets.
        """
        return pulumi.get(self, "acl")

    @acl.setter
    def acl(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "acl", value)

    @_builtins.property
    @pulumi.getter
    def gid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies how each file's POSIX group ID (GID) attribute should be handled by the transfer.
        """
        return pulumi.get(self, "gid")

    @gid.setter
    def gid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gid", value)

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies how each object's Cloud KMS customer-managed encryption key (CMEK) is preserved for transfers between Google Cloud Storage buckets.
        """
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "kms_key", value)

    @_builtins.property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies how each file's mode attribute should be handled by the transfer.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mode", value)

    @_builtins.property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies the storage class to set on objects being transferred to Google Cloud Storage buckets.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "storage_class", value)

    @_builtins.property
    @pulumi.getter
    def symlink(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies how symlinks should be handled by the transfer.
        """
        return pulumi.get(self, "symlink")

    @symlink.setter
    def symlink(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "symlink", value)

    @_builtins.property
    @pulumi.getter(name="temporaryHold")
    def temporary_hold(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies how each object's temporary hold status should be preserved for transfers between Google Cloud Storage buckets.
        """
        return pulumi.get(self, "temporary_hold")

    @temporary_hold.setter
    def temporary_hold(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "temporary_hold", value)

    @_builtins.property
    @pulumi.getter(name="timeCreated")
    def time_created(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies how each object's timeCreated metadata is preserved for transfers.
        """
        return pulumi.get(self, "time_created")

    @time_created.setter
    def time_created(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_created", value)

    @_builtins.property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Specifies how each file's POSIX user ID (UID) attribute should be handled by the transfer.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uid", value)


