# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'ConfigBlockingFunctionsArgs',
    'ConfigBlockingFunctionsForwardInboundCredentialsArgs',
    'ConfigBlockingFunctionsTriggerArgs',
    'ConfigClientArgs',
    'ConfigClientPermissionsArgs',
    'ConfigMfaArgs',
    'ConfigMfaProviderConfigArgs',
    'ConfigMfaProviderConfigTotpProviderConfigArgs',
    'ConfigMonitoringArgs',
    'ConfigMonitoringRequestLoggingArgs',
    'ConfigMultiTenantArgs',
    'ConfigQuotaArgs',
    'ConfigQuotaSignUpQuotaConfigArgs',
    'ConfigSignInArgs',
    'ConfigSignInAnonymousArgs',
    'ConfigSignInEmailArgs',
    'ConfigSignInHashConfigArgs',
    'ConfigSignInPhoneNumberArgs',
    'ConfigSmsRegionConfigArgs',
    'ConfigSmsRegionConfigAllowByDefaultArgs',
    'ConfigSmsRegionConfigAllowlistOnlyArgs',
    'InboundSamlConfigIdpConfigArgs',
    'InboundSamlConfigIdpConfigIdpCertificateArgs',
    'InboundSamlConfigSpConfigArgs',
    'InboundSamlConfigSpConfigSpCertificateArgs',
    'ProjectDefaultConfigSignInArgs',
    'ProjectDefaultConfigSignInAnonymousArgs',
    'ProjectDefaultConfigSignInEmailArgs',
    'ProjectDefaultConfigSignInHashConfigArgs',
    'ProjectDefaultConfigSignInPhoneNumberArgs',
    'TenantInboundSamlConfigIdpConfigArgs',
    'TenantInboundSamlConfigIdpConfigIdpCertificateArgs',
    'TenantInboundSamlConfigSpConfigArgs',
    'TenantInboundSamlConfigSpConfigSpCertificateArgs',
]

@pulumi.input_type
class ConfigBlockingFunctionsArgs:
    def __init__(__self__, *,
                 triggers: pulumi.Input[Sequence[pulumi.Input['ConfigBlockingFunctionsTriggerArgs']]],
                 forward_inbound_credentials: Optional[pulumi.Input['ConfigBlockingFunctionsForwardInboundCredentialsArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ConfigBlockingFunctionsTriggerArgs']]] triggers: Map of Trigger to event type. Key should be one of the supported event types: "beforeCreate", "beforeSignIn".
               Structure is documented below.
        :param pulumi.Input['ConfigBlockingFunctionsForwardInboundCredentialsArgs'] forward_inbound_credentials: The user credentials to include in the JWT payload that is sent to the registered Blocking Functions.
               Structure is documented below.
        """
        pulumi.set(__self__, "triggers", triggers)
        if forward_inbound_credentials is not None:
            pulumi.set(__self__, "forward_inbound_credentials", forward_inbound_credentials)

    @property
    @pulumi.getter
    def triggers(self) -> pulumi.Input[Sequence[pulumi.Input['ConfigBlockingFunctionsTriggerArgs']]]:
        """
        Map of Trigger to event type. Key should be one of the supported event types: "beforeCreate", "beforeSignIn".
        Structure is documented below.
        """
        return pulumi.get(self, "triggers")

    @triggers.setter
    def triggers(self, value: pulumi.Input[Sequence[pulumi.Input['ConfigBlockingFunctionsTriggerArgs']]]):
        pulumi.set(self, "triggers", value)

    @property
    @pulumi.getter(name="forwardInboundCredentials")
    def forward_inbound_credentials(self) -> Optional[pulumi.Input['ConfigBlockingFunctionsForwardInboundCredentialsArgs']]:
        """
        The user credentials to include in the JWT payload that is sent to the registered Blocking Functions.
        Structure is documented below.
        """
        return pulumi.get(self, "forward_inbound_credentials")

    @forward_inbound_credentials.setter
    def forward_inbound_credentials(self, value: Optional[pulumi.Input['ConfigBlockingFunctionsForwardInboundCredentialsArgs']]):
        pulumi.set(self, "forward_inbound_credentials", value)


@pulumi.input_type
class ConfigBlockingFunctionsForwardInboundCredentialsArgs:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input[bool]] = None,
                 id_token: Optional[pulumi.Input[bool]] = None,
                 refresh_token: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] access_token: Whether to pass the user's OAuth identity provider's access token.
        :param pulumi.Input[bool] id_token: Whether to pass the user's OIDC identity provider's ID token.
        :param pulumi.Input[bool] refresh_token: Whether to pass the user's OAuth identity provider's refresh token.
        """
        if access_token is not None:
            pulumi.set(__self__, "access_token", access_token)
        if id_token is not None:
            pulumi.set(__self__, "id_token", id_token)
        if refresh_token is not None:
            pulumi.set(__self__, "refresh_token", refresh_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to pass the user's OAuth identity provider's access token.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="idToken")
    def id_token(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to pass the user's OIDC identity provider's ID token.
        """
        return pulumi.get(self, "id_token")

    @id_token.setter
    def id_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "id_token", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to pass the user's OAuth identity provider's refresh token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "refresh_token", value)


@pulumi.input_type
class ConfigBlockingFunctionsTriggerArgs:
    def __init__(__self__, *,
                 event_type: pulumi.Input[str],
                 function_uri: pulumi.Input[str],
                 update_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] event_type: The identifier for this object. Format specified above.
        :param pulumi.Input[str] function_uri: HTTP URI trigger for the Cloud Function.
        :param pulumi.Input[str] update_time: (Output)
               When the trigger was changed.
        """
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "function_uri", function_uri)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> pulumi.Input[str]:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "event_type", value)

    @property
    @pulumi.getter(name="functionUri")
    def function_uri(self) -> pulumi.Input[str]:
        """
        HTTP URI trigger for the Cloud Function.
        """
        return pulumi.get(self, "function_uri")

    @function_uri.setter
    def function_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "function_uri", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        When the trigger was changed.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)


@pulumi.input_type
class ConfigClientArgs:
    def __init__(__self__, *,
                 api_key: Optional[pulumi.Input[str]] = None,
                 firebase_subdomain: Optional[pulumi.Input[str]] = None,
                 permissions: Optional[pulumi.Input['ConfigClientPermissionsArgs']] = None):
        """
        :param pulumi.Input[str] api_key: (Output)
               API key that can be used when making requests for this project.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[str] firebase_subdomain: (Output)
               Firebase subdomain.
        :param pulumi.Input['ConfigClientPermissionsArgs'] permissions: Configuration related to restricting a user's ability to affect their account.
               Structure is documented below.
        """
        if api_key is not None:
            pulumi.set(__self__, "api_key", api_key)
        if firebase_subdomain is not None:
            pulumi.set(__self__, "firebase_subdomain", firebase_subdomain)
        if permissions is not None:
            pulumi.set(__self__, "permissions", permissions)

    @property
    @pulumi.getter(name="apiKey")
    def api_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        API key that can be used when making requests for this project.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "api_key")

    @api_key.setter
    def api_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "api_key", value)

    @property
    @pulumi.getter(name="firebaseSubdomain")
    def firebase_subdomain(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Firebase subdomain.
        """
        return pulumi.get(self, "firebase_subdomain")

    @firebase_subdomain.setter
    def firebase_subdomain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "firebase_subdomain", value)

    @property
    @pulumi.getter
    def permissions(self) -> Optional[pulumi.Input['ConfigClientPermissionsArgs']]:
        """
        Configuration related to restricting a user's ability to affect their account.
        Structure is documented below.
        """
        return pulumi.get(self, "permissions")

    @permissions.setter
    def permissions(self, value: Optional[pulumi.Input['ConfigClientPermissionsArgs']]):
        pulumi.set(self, "permissions", value)


@pulumi.input_type
class ConfigClientPermissionsArgs:
    def __init__(__self__, *,
                 disabled_user_deletion: Optional[pulumi.Input[bool]] = None,
                 disabled_user_signup: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] disabled_user_deletion: When true, end users cannot delete their account on the associated project through any of our API methods
        :param pulumi.Input[bool] disabled_user_signup: When true, end users cannot sign up for a new account on the associated project through any of our API methods
        """
        if disabled_user_deletion is not None:
            pulumi.set(__self__, "disabled_user_deletion", disabled_user_deletion)
        if disabled_user_signup is not None:
            pulumi.set(__self__, "disabled_user_signup", disabled_user_signup)

    @property
    @pulumi.getter(name="disabledUserDeletion")
    def disabled_user_deletion(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, end users cannot delete their account on the associated project through any of our API methods
        """
        return pulumi.get(self, "disabled_user_deletion")

    @disabled_user_deletion.setter
    def disabled_user_deletion(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled_user_deletion", value)

    @property
    @pulumi.getter(name="disabledUserSignup")
    def disabled_user_signup(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, end users cannot sign up for a new account on the associated project through any of our API methods
        """
        return pulumi.get(self, "disabled_user_signup")

    @disabled_user_signup.setter
    def disabled_user_signup(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disabled_user_signup", value)


@pulumi.input_type
class ConfigMfaArgs:
    def __init__(__self__, *,
                 enabled_providers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 provider_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigMfaProviderConfigArgs']]]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] enabled_providers: A list of usable second factors for this project.
               Each value may be one of: `PHONE_SMS`.
        :param pulumi.Input[Sequence[pulumi.Input['ConfigMfaProviderConfigArgs']]] provider_configs: A list of usable second factors for this project along with their configurations.
               This field does not support phone based MFA, for that use the 'enabledProviders' field.
               Structure is documented below.
        :param pulumi.Input[str] state: Whether MultiFactor Authentication has been enabled for this project.
               Possible values are: `DISABLED`, `ENABLED`, `MANDATORY`.
        """
        if enabled_providers is not None:
            pulumi.set(__self__, "enabled_providers", enabled_providers)
        if provider_configs is not None:
            pulumi.set(__self__, "provider_configs", provider_configs)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="enabledProviders")
    def enabled_providers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of usable second factors for this project.
        Each value may be one of: `PHONE_SMS`.
        """
        return pulumi.get(self, "enabled_providers")

    @enabled_providers.setter
    def enabled_providers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "enabled_providers", value)

    @property
    @pulumi.getter(name="providerConfigs")
    def provider_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigMfaProviderConfigArgs']]]]:
        """
        A list of usable second factors for this project along with their configurations.
        This field does not support phone based MFA, for that use the 'enabledProviders' field.
        Structure is documented below.
        """
        return pulumi.get(self, "provider_configs")

    @provider_configs.setter
    def provider_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigMfaProviderConfigArgs']]]]):
        pulumi.set(self, "provider_configs", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        Whether MultiFactor Authentication has been enabled for this project.
        Possible values are: `DISABLED`, `ENABLED`, `MANDATORY`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


@pulumi.input_type
class ConfigMfaProviderConfigArgs:
    def __init__(__self__, *,
                 state: Optional[pulumi.Input[str]] = None,
                 totp_provider_config: Optional[pulumi.Input['ConfigMfaProviderConfigTotpProviderConfigArgs']] = None):
        """
        :param pulumi.Input[str] state: Whether MultiFactor Authentication has been enabled for this project.
               Possible values are: `DISABLED`, `ENABLED`, `MANDATORY`.
        :param pulumi.Input['ConfigMfaProviderConfigTotpProviderConfigArgs'] totp_provider_config: TOTP MFA provider config for this project.
               Structure is documented below.
        """
        if state is not None:
            pulumi.set(__self__, "state", state)
        if totp_provider_config is not None:
            pulumi.set(__self__, "totp_provider_config", totp_provider_config)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        Whether MultiFactor Authentication has been enabled for this project.
        Possible values are: `DISABLED`, `ENABLED`, `MANDATORY`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="totpProviderConfig")
    def totp_provider_config(self) -> Optional[pulumi.Input['ConfigMfaProviderConfigTotpProviderConfigArgs']]:
        """
        TOTP MFA provider config for this project.
        Structure is documented below.
        """
        return pulumi.get(self, "totp_provider_config")

    @totp_provider_config.setter
    def totp_provider_config(self, value: Optional[pulumi.Input['ConfigMfaProviderConfigTotpProviderConfigArgs']]):
        pulumi.set(self, "totp_provider_config", value)


@pulumi.input_type
class ConfigMfaProviderConfigTotpProviderConfigArgs:
    def __init__(__self__, *,
                 adjacent_intervals: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] adjacent_intervals: The allowed number of adjacent intervals that will be used for verification to avoid clock skew.
        """
        if adjacent_intervals is not None:
            pulumi.set(__self__, "adjacent_intervals", adjacent_intervals)

    @property
    @pulumi.getter(name="adjacentIntervals")
    def adjacent_intervals(self) -> Optional[pulumi.Input[int]]:
        """
        The allowed number of adjacent intervals that will be used for verification to avoid clock skew.
        """
        return pulumi.get(self, "adjacent_intervals")

    @adjacent_intervals.setter
    def adjacent_intervals(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "adjacent_intervals", value)


@pulumi.input_type
class ConfigMonitoringArgs:
    def __init__(__self__, *,
                 request_logging: Optional[pulumi.Input['ConfigMonitoringRequestLoggingArgs']] = None):
        """
        :param pulumi.Input['ConfigMonitoringRequestLoggingArgs'] request_logging: Configuration for logging requests made to this project to Stackdriver Logging
               Structure is documented below.
        """
        if request_logging is not None:
            pulumi.set(__self__, "request_logging", request_logging)

    @property
    @pulumi.getter(name="requestLogging")
    def request_logging(self) -> Optional[pulumi.Input['ConfigMonitoringRequestLoggingArgs']]:
        """
        Configuration for logging requests made to this project to Stackdriver Logging
        Structure is documented below.
        """
        return pulumi.get(self, "request_logging")

    @request_logging.setter
    def request_logging(self, value: Optional[pulumi.Input['ConfigMonitoringRequestLoggingArgs']]):
        pulumi.set(self, "request_logging", value)


@pulumi.input_type
class ConfigMonitoringRequestLoggingArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether logging is enabled for this project or not.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether logging is enabled for this project or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ConfigMultiTenantArgs:
    def __init__(__self__, *,
                 allow_tenants: Optional[pulumi.Input[bool]] = None,
                 default_tenant_location: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] allow_tenants: Whether this project can have tenants or not.
        :param pulumi.Input[str] default_tenant_location: The default cloud parent org or folder that the tenant project should be created under.
               The parent resource name should be in the format of "/", such as "folders/123" or "organizations/456".
               If the value is not set, the tenant will be created under the same organization or folder as the agent project.
        """
        if allow_tenants is not None:
            pulumi.set(__self__, "allow_tenants", allow_tenants)
        if default_tenant_location is not None:
            pulumi.set(__self__, "default_tenant_location", default_tenant_location)

    @property
    @pulumi.getter(name="allowTenants")
    def allow_tenants(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether this project can have tenants or not.
        """
        return pulumi.get(self, "allow_tenants")

    @allow_tenants.setter
    def allow_tenants(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_tenants", value)

    @property
    @pulumi.getter(name="defaultTenantLocation")
    def default_tenant_location(self) -> Optional[pulumi.Input[str]]:
        """
        The default cloud parent org or folder that the tenant project should be created under.
        The parent resource name should be in the format of "/", such as "folders/123" or "organizations/456".
        If the value is not set, the tenant will be created under the same organization or folder as the agent project.
        """
        return pulumi.get(self, "default_tenant_location")

    @default_tenant_location.setter
    def default_tenant_location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_tenant_location", value)


@pulumi.input_type
class ConfigQuotaArgs:
    def __init__(__self__, *,
                 sign_up_quota_config: Optional[pulumi.Input['ConfigQuotaSignUpQuotaConfigArgs']] = None):
        """
        :param pulumi.Input['ConfigQuotaSignUpQuotaConfigArgs'] sign_up_quota_config: Quota for the Signup endpoint, if overwritten. Signup quota is measured in sign ups per project per hour per IP.
               Structure is documented below.
        """
        if sign_up_quota_config is not None:
            pulumi.set(__self__, "sign_up_quota_config", sign_up_quota_config)

    @property
    @pulumi.getter(name="signUpQuotaConfig")
    def sign_up_quota_config(self) -> Optional[pulumi.Input['ConfigQuotaSignUpQuotaConfigArgs']]:
        """
        Quota for the Signup endpoint, if overwritten. Signup quota is measured in sign ups per project per hour per IP.
        Structure is documented below.
        """
        return pulumi.get(self, "sign_up_quota_config")

    @sign_up_quota_config.setter
    def sign_up_quota_config(self, value: Optional[pulumi.Input['ConfigQuotaSignUpQuotaConfigArgs']]):
        pulumi.set(self, "sign_up_quota_config", value)


@pulumi.input_type
class ConfigQuotaSignUpQuotaConfigArgs:
    def __init__(__self__, *,
                 quota: Optional[pulumi.Input[int]] = None,
                 quota_duration: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] quota: A sign up APIs quota that customers can override temporarily.
        :param pulumi.Input[str] quota_duration: How long this quota will be active for. It is measurred in seconds, e.g., Example: "9.615s".
        :param pulumi.Input[str] start_time: When this quota will take affect.
        """
        if quota is not None:
            pulumi.set(__self__, "quota", quota)
        if quota_duration is not None:
            pulumi.set(__self__, "quota_duration", quota_duration)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter
    def quota(self) -> Optional[pulumi.Input[int]]:
        """
        A sign up APIs quota that customers can override temporarily.
        """
        return pulumi.get(self, "quota")

    @quota.setter
    def quota(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "quota", value)

    @property
    @pulumi.getter(name="quotaDuration")
    def quota_duration(self) -> Optional[pulumi.Input[str]]:
        """
        How long this quota will be active for. It is measurred in seconds, e.g., Example: "9.615s".
        """
        return pulumi.get(self, "quota_duration")

    @quota_duration.setter
    def quota_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quota_duration", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        When this quota will take affect.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


@pulumi.input_type
class ConfigSignInArgs:
    def __init__(__self__, *,
                 allow_duplicate_emails: Optional[pulumi.Input[bool]] = None,
                 anonymous: Optional[pulumi.Input['ConfigSignInAnonymousArgs']] = None,
                 email: Optional[pulumi.Input['ConfigSignInEmailArgs']] = None,
                 hash_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigSignInHashConfigArgs']]]] = None,
                 phone_number: Optional[pulumi.Input['ConfigSignInPhoneNumberArgs']] = None):
        """
        :param pulumi.Input[bool] allow_duplicate_emails: Whether to allow more than one account to have the same email.
        :param pulumi.Input['ConfigSignInAnonymousArgs'] anonymous: Configuration options related to authenticating an anonymous user.
               Structure is documented below.
        :param pulumi.Input['ConfigSignInEmailArgs'] email: Configuration options related to authenticating a user by their email address.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ConfigSignInHashConfigArgs']]] hash_configs: (Output)
               Output only. Hash config information.
               Structure is documented below.
        :param pulumi.Input['ConfigSignInPhoneNumberArgs'] phone_number: Configuration options related to authenticated a user by their phone number.
               Structure is documented below.
        """
        if allow_duplicate_emails is not None:
            pulumi.set(__self__, "allow_duplicate_emails", allow_duplicate_emails)
        if anonymous is not None:
            pulumi.set(__self__, "anonymous", anonymous)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if hash_configs is not None:
            pulumi.set(__self__, "hash_configs", hash_configs)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="allowDuplicateEmails")
    def allow_duplicate_emails(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow more than one account to have the same email.
        """
        return pulumi.get(self, "allow_duplicate_emails")

    @allow_duplicate_emails.setter
    def allow_duplicate_emails(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_duplicate_emails", value)

    @property
    @pulumi.getter
    def anonymous(self) -> Optional[pulumi.Input['ConfigSignInAnonymousArgs']]:
        """
        Configuration options related to authenticating an anonymous user.
        Structure is documented below.
        """
        return pulumi.get(self, "anonymous")

    @anonymous.setter
    def anonymous(self, value: Optional[pulumi.Input['ConfigSignInAnonymousArgs']]):
        pulumi.set(self, "anonymous", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ConfigSignInEmailArgs']]:
        """
        Configuration options related to authenticating a user by their email address.
        Structure is documented below.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ConfigSignInEmailArgs']]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="hashConfigs")
    def hash_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigSignInHashConfigArgs']]]]:
        """
        (Output)
        Output only. Hash config information.
        Structure is documented below.
        """
        return pulumi.get(self, "hash_configs")

    @hash_configs.setter
    def hash_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigSignInHashConfigArgs']]]]):
        pulumi.set(self, "hash_configs", value)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[pulumi.Input['ConfigSignInPhoneNumberArgs']]:
        """
        Configuration options related to authenticated a user by their phone number.
        Structure is documented below.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: Optional[pulumi.Input['ConfigSignInPhoneNumberArgs']]):
        pulumi.set(self, "phone_number", value)


@pulumi.input_type
class ConfigSignInAnonymousArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Whether anonymous user auth is enabled for the project or not.
               
               <a name="nested_hash_config"></a>The `hash_config` block contains:
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether anonymous user auth is enabled for the project or not.

        <a name="nested_hash_config"></a>The `hash_config` block contains:
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ConfigSignInEmailArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 password_required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether email auth is enabled for the project or not.
        :param pulumi.Input[bool] password_required: Whether a password is required for email auth or not. If true, both an email and
               password must be provided to sign in. If false, a user may sign in via either
               email/password or email link.
        """
        pulumi.set(__self__, "enabled", enabled)
        if password_required is not None:
            pulumi.set(__self__, "password_required", password_required)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether email auth is enabled for the project or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="passwordRequired")
    def password_required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether a password is required for email auth or not. If true, both an email and
        password must be provided to sign in. If false, a user may sign in via either
        email/password or email link.
        """
        return pulumi.get(self, "password_required")

    @password_required.setter
    def password_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "password_required", value)


@pulumi.input_type
class ConfigSignInHashConfigArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[str]] = None,
                 memory_cost: Optional[pulumi.Input[int]] = None,
                 rounds: Optional[pulumi.Input[int]] = None,
                 salt_separator: Optional[pulumi.Input[str]] = None,
                 signer_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] algorithm: (Output)
               Different password hash algorithms used in Identity Toolkit.
        :param pulumi.Input[int] memory_cost: (Output)
               Memory cost for hash calculation. Used by scrypt and other similar password derivation algorithms. See https://tools.ietf.org/html/rfc7914 for explanation of field.
        :param pulumi.Input[int] rounds: (Output)
               How many rounds for hash calculation. Used by scrypt and other similar password derivation algorithms.
        :param pulumi.Input[str] salt_separator: (Output)
               Non-printable character to be inserted between the salt and plain text password in base64.
        :param pulumi.Input[str] signer_key: (Output)
               Signer key in base64.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if memory_cost is not None:
            pulumi.set(__self__, "memory_cost", memory_cost)
        if rounds is not None:
            pulumi.set(__self__, "rounds", rounds)
        if salt_separator is not None:
            pulumi.set(__self__, "salt_separator", salt_separator)
        if signer_key is not None:
            pulumi.set(__self__, "signer_key", signer_key)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Different password hash algorithms used in Identity Toolkit.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter(name="memoryCost")
    def memory_cost(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Memory cost for hash calculation. Used by scrypt and other similar password derivation algorithms. See https://tools.ietf.org/html/rfc7914 for explanation of field.
        """
        return pulumi.get(self, "memory_cost")

    @memory_cost.setter
    def memory_cost(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_cost", value)

    @property
    @pulumi.getter
    def rounds(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        How many rounds for hash calculation. Used by scrypt and other similar password derivation algorithms.
        """
        return pulumi.get(self, "rounds")

    @rounds.setter
    def rounds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rounds", value)

    @property
    @pulumi.getter(name="saltSeparator")
    def salt_separator(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Non-printable character to be inserted between the salt and plain text password in base64.
        """
        return pulumi.get(self, "salt_separator")

    @salt_separator.setter
    def salt_separator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "salt_separator", value)

    @property
    @pulumi.getter(name="signerKey")
    def signer_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Signer key in base64.
        """
        return pulumi.get(self, "signer_key")

    @signer_key.setter
    def signer_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signer_key", value)


@pulumi.input_type
class ConfigSignInPhoneNumberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 test_phone_numbers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether phone number auth is enabled for the project or not.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] test_phone_numbers: A map of <test phone number, fake code> that can be used for phone auth testing.
        """
        pulumi.set(__self__, "enabled", enabled)
        if test_phone_numbers is not None:
            pulumi.set(__self__, "test_phone_numbers", test_phone_numbers)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether phone number auth is enabled for the project or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="testPhoneNumbers")
    def test_phone_numbers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of <test phone number, fake code> that can be used for phone auth testing.
        """
        return pulumi.get(self, "test_phone_numbers")

    @test_phone_numbers.setter
    def test_phone_numbers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "test_phone_numbers", value)


@pulumi.input_type
class ConfigSmsRegionConfigArgs:
    def __init__(__self__, *,
                 allow_by_default: Optional[pulumi.Input['ConfigSmsRegionConfigAllowByDefaultArgs']] = None,
                 allowlist_only: Optional[pulumi.Input['ConfigSmsRegionConfigAllowlistOnlyArgs']] = None):
        """
        :param pulumi.Input['ConfigSmsRegionConfigAllowByDefaultArgs'] allow_by_default: A policy of allowing SMS to every region by default and adding disallowed regions to a disallow list.
               Structure is documented below.
        :param pulumi.Input['ConfigSmsRegionConfigAllowlistOnlyArgs'] allowlist_only: A policy of only allowing regions by explicitly adding them to an allowlist.
               Structure is documented below.
        """
        if allow_by_default is not None:
            pulumi.set(__self__, "allow_by_default", allow_by_default)
        if allowlist_only is not None:
            pulumi.set(__self__, "allowlist_only", allowlist_only)

    @property
    @pulumi.getter(name="allowByDefault")
    def allow_by_default(self) -> Optional[pulumi.Input['ConfigSmsRegionConfigAllowByDefaultArgs']]:
        """
        A policy of allowing SMS to every region by default and adding disallowed regions to a disallow list.
        Structure is documented below.
        """
        return pulumi.get(self, "allow_by_default")

    @allow_by_default.setter
    def allow_by_default(self, value: Optional[pulumi.Input['ConfigSmsRegionConfigAllowByDefaultArgs']]):
        pulumi.set(self, "allow_by_default", value)

    @property
    @pulumi.getter(name="allowlistOnly")
    def allowlist_only(self) -> Optional[pulumi.Input['ConfigSmsRegionConfigAllowlistOnlyArgs']]:
        """
        A policy of only allowing regions by explicitly adding them to an allowlist.
        Structure is documented below.
        """
        return pulumi.get(self, "allowlist_only")

    @allowlist_only.setter
    def allowlist_only(self, value: Optional[pulumi.Input['ConfigSmsRegionConfigAllowlistOnlyArgs']]):
        pulumi.set(self, "allowlist_only", value)


@pulumi.input_type
class ConfigSmsRegionConfigAllowByDefaultArgs:
    def __init__(__self__, *,
                 disallowed_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] disallowed_regions: Two letter unicode region codes to disallow as defined by https://cldr.unicode.org/ The full list of these region codes is here: https://github.com/unicode-cldr/cldr-localenames-full/blob/master/main/en/territories.json
        """
        if disallowed_regions is not None:
            pulumi.set(__self__, "disallowed_regions", disallowed_regions)

    @property
    @pulumi.getter(name="disallowedRegions")
    def disallowed_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Two letter unicode region codes to disallow as defined by https://cldr.unicode.org/ The full list of these region codes is here: https://github.com/unicode-cldr/cldr-localenames-full/blob/master/main/en/territories.json
        """
        return pulumi.get(self, "disallowed_regions")

    @disallowed_regions.setter
    def disallowed_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "disallowed_regions", value)


@pulumi.input_type
class ConfigSmsRegionConfigAllowlistOnlyArgs:
    def __init__(__self__, *,
                 allowed_regions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] allowed_regions: Two letter unicode region codes to allow as defined by https://cldr.unicode.org/ The full list of these region codes is here: https://github.com/unicode-cldr/cldr-localenames-full/blob/master/main/en/territories.json
        """
        if allowed_regions is not None:
            pulumi.set(__self__, "allowed_regions", allowed_regions)

    @property
    @pulumi.getter(name="allowedRegions")
    def allowed_regions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Two letter unicode region codes to allow as defined by https://cldr.unicode.org/ The full list of these region codes is here: https://github.com/unicode-cldr/cldr-localenames-full/blob/master/main/en/territories.json
        """
        return pulumi.get(self, "allowed_regions")

    @allowed_regions.setter
    def allowed_regions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "allowed_regions", value)


@pulumi.input_type
class InboundSamlConfigIdpConfigArgs:
    def __init__(__self__, *,
                 idp_certificates: pulumi.Input[Sequence[pulumi.Input['InboundSamlConfigIdpConfigIdpCertificateArgs']]],
                 idp_entity_id: pulumi.Input[str],
                 sso_url: pulumi.Input[str],
                 sign_request: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['InboundSamlConfigIdpConfigIdpCertificateArgs']]] idp_certificates: The IdP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
               Structure is documented below.
        :param pulumi.Input[str] idp_entity_id: Unique identifier for all SAML entities
        :param pulumi.Input[str] sso_url: URL to send Authentication request to.
        :param pulumi.Input[bool] sign_request: Indicates if outbounding SAMLRequest should be signed.
        """
        pulumi.set(__self__, "idp_certificates", idp_certificates)
        pulumi.set(__self__, "idp_entity_id", idp_entity_id)
        pulumi.set(__self__, "sso_url", sso_url)
        if sign_request is not None:
            pulumi.set(__self__, "sign_request", sign_request)

    @property
    @pulumi.getter(name="idpCertificates")
    def idp_certificates(self) -> pulumi.Input[Sequence[pulumi.Input['InboundSamlConfigIdpConfigIdpCertificateArgs']]]:
        """
        The IdP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
        Structure is documented below.
        """
        return pulumi.get(self, "idp_certificates")

    @idp_certificates.setter
    def idp_certificates(self, value: pulumi.Input[Sequence[pulumi.Input['InboundSamlConfigIdpConfigIdpCertificateArgs']]]):
        pulumi.set(self, "idp_certificates", value)

    @property
    @pulumi.getter(name="idpEntityId")
    def idp_entity_id(self) -> pulumi.Input[str]:
        """
        Unique identifier for all SAML entities
        """
        return pulumi.get(self, "idp_entity_id")

    @idp_entity_id.setter
    def idp_entity_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "idp_entity_id", value)

    @property
    @pulumi.getter(name="ssoUrl")
    def sso_url(self) -> pulumi.Input[str]:
        """
        URL to send Authentication request to.
        """
        return pulumi.get(self, "sso_url")

    @sso_url.setter
    def sso_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "sso_url", value)

    @property
    @pulumi.getter(name="signRequest")
    def sign_request(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if outbounding SAMLRequest should be signed.
        """
        return pulumi.get(self, "sign_request")

    @sign_request.setter
    def sign_request(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sign_request", value)


@pulumi.input_type
class InboundSamlConfigIdpConfigIdpCertificateArgs:
    def __init__(__self__, *,
                 x509_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] x509_certificate: The IdP's x509 certificate.
        """
        if x509_certificate is not None:
            pulumi.set(__self__, "x509_certificate", x509_certificate)

    @property
    @pulumi.getter(name="x509Certificate")
    def x509_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        The IdP's x509 certificate.
        """
        return pulumi.get(self, "x509_certificate")

    @x509_certificate.setter
    def x509_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x509_certificate", value)


@pulumi.input_type
class InboundSamlConfigSpConfigArgs:
    def __init__(__self__, *,
                 callback_uri: Optional[pulumi.Input[str]] = None,
                 sp_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['InboundSamlConfigSpConfigSpCertificateArgs']]]] = None,
                 sp_entity_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] callback_uri: Callback URI where responses from IDP are handled. Must start with `https://`.
        :param pulumi.Input[Sequence[pulumi.Input['InboundSamlConfigSpConfigSpCertificateArgs']]] sp_certificates: (Output)
               The IDP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
               Structure is documented below.
               
               
               <a name="nested_sp_certificates"></a>The `sp_certificates` block contains:
        :param pulumi.Input[str] sp_entity_id: Unique identifier for all SAML entities.
        """
        if callback_uri is not None:
            pulumi.set(__self__, "callback_uri", callback_uri)
        if sp_certificates is not None:
            pulumi.set(__self__, "sp_certificates", sp_certificates)
        if sp_entity_id is not None:
            pulumi.set(__self__, "sp_entity_id", sp_entity_id)

    @property
    @pulumi.getter(name="callbackUri")
    def callback_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Callback URI where responses from IDP are handled. Must start with `https://`.
        """
        return pulumi.get(self, "callback_uri")

    @callback_uri.setter
    def callback_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "callback_uri", value)

    @property
    @pulumi.getter(name="spCertificates")
    def sp_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InboundSamlConfigSpConfigSpCertificateArgs']]]]:
        """
        (Output)
        The IDP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
        Structure is documented below.


        <a name="nested_sp_certificates"></a>The `sp_certificates` block contains:
        """
        return pulumi.get(self, "sp_certificates")

    @sp_certificates.setter
    def sp_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InboundSamlConfigSpConfigSpCertificateArgs']]]]):
        pulumi.set(self, "sp_certificates", value)

    @property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier for all SAML entities.
        """
        return pulumi.get(self, "sp_entity_id")

    @sp_entity_id.setter
    def sp_entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sp_entity_id", value)


@pulumi.input_type
class InboundSamlConfigSpConfigSpCertificateArgs:
    def __init__(__self__, *,
                 x509_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] x509_certificate: The IdP's x509 certificate.
        """
        if x509_certificate is not None:
            pulumi.set(__self__, "x509_certificate", x509_certificate)

    @property
    @pulumi.getter(name="x509Certificate")
    def x509_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        The IdP's x509 certificate.
        """
        return pulumi.get(self, "x509_certificate")

    @x509_certificate.setter
    def x509_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x509_certificate", value)


@pulumi.input_type
class ProjectDefaultConfigSignInArgs:
    def __init__(__self__, *,
                 allow_duplicate_emails: Optional[pulumi.Input[bool]] = None,
                 anonymous: Optional[pulumi.Input['ProjectDefaultConfigSignInAnonymousArgs']] = None,
                 email: Optional[pulumi.Input['ProjectDefaultConfigSignInEmailArgs']] = None,
                 hash_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectDefaultConfigSignInHashConfigArgs']]]] = None,
                 phone_number: Optional[pulumi.Input['ProjectDefaultConfigSignInPhoneNumberArgs']] = None):
        """
        :param pulumi.Input[bool] allow_duplicate_emails: Whether to allow more than one account to have the same email.
        :param pulumi.Input['ProjectDefaultConfigSignInAnonymousArgs'] anonymous: Configuration options related to authenticating an anonymous user.
               Structure is documented below.
        :param pulumi.Input['ProjectDefaultConfigSignInEmailArgs'] email: Configuration options related to authenticating a user by their email address.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectDefaultConfigSignInHashConfigArgs']]] hash_configs: (Output)
               Output only. Hash config information.
               Structure is documented below.
        :param pulumi.Input['ProjectDefaultConfigSignInPhoneNumberArgs'] phone_number: Configuration options related to authenticated a user by their phone number.
               Structure is documented below.
        """
        if allow_duplicate_emails is not None:
            pulumi.set(__self__, "allow_duplicate_emails", allow_duplicate_emails)
        if anonymous is not None:
            pulumi.set(__self__, "anonymous", anonymous)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if hash_configs is not None:
            pulumi.set(__self__, "hash_configs", hash_configs)
        if phone_number is not None:
            pulumi.set(__self__, "phone_number", phone_number)

    @property
    @pulumi.getter(name="allowDuplicateEmails")
    def allow_duplicate_emails(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow more than one account to have the same email.
        """
        return pulumi.get(self, "allow_duplicate_emails")

    @allow_duplicate_emails.setter
    def allow_duplicate_emails(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_duplicate_emails", value)

    @property
    @pulumi.getter
    def anonymous(self) -> Optional[pulumi.Input['ProjectDefaultConfigSignInAnonymousArgs']]:
        """
        Configuration options related to authenticating an anonymous user.
        Structure is documented below.
        """
        return pulumi.get(self, "anonymous")

    @anonymous.setter
    def anonymous(self, value: Optional[pulumi.Input['ProjectDefaultConfigSignInAnonymousArgs']]):
        pulumi.set(self, "anonymous", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ProjectDefaultConfigSignInEmailArgs']]:
        """
        Configuration options related to authenticating a user by their email address.
        Structure is documented below.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ProjectDefaultConfigSignInEmailArgs']]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="hashConfigs")
    def hash_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectDefaultConfigSignInHashConfigArgs']]]]:
        """
        (Output)
        Output only. Hash config information.
        Structure is documented below.
        """
        return pulumi.get(self, "hash_configs")

    @hash_configs.setter
    def hash_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectDefaultConfigSignInHashConfigArgs']]]]):
        pulumi.set(self, "hash_configs", value)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[pulumi.Input['ProjectDefaultConfigSignInPhoneNumberArgs']]:
        """
        Configuration options related to authenticated a user by their phone number.
        Structure is documented below.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: Optional[pulumi.Input['ProjectDefaultConfigSignInPhoneNumberArgs']]):
        pulumi.set(self, "phone_number", value)


@pulumi.input_type
class ProjectDefaultConfigSignInAnonymousArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Whether anonymous user auth is enabled for the project or not.
               
               <a name="nested_hash_config"></a>The `hash_config` block contains:
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether anonymous user auth is enabled for the project or not.

        <a name="nested_hash_config"></a>The `hash_config` block contains:
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ProjectDefaultConfigSignInEmailArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 password_required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether email auth is enabled for the project or not.
        :param pulumi.Input[bool] password_required: Whether a password is required for email auth or not. If true, both an email and
               password must be provided to sign in. If false, a user may sign in via either
               email/password or email link.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if password_required is not None:
            pulumi.set(__self__, "password_required", password_required)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether email auth is enabled for the project or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="passwordRequired")
    def password_required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether a password is required for email auth or not. If true, both an email and
        password must be provided to sign in. If false, a user may sign in via either
        email/password or email link.
        """
        return pulumi.get(self, "password_required")

    @password_required.setter
    def password_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "password_required", value)


@pulumi.input_type
class ProjectDefaultConfigSignInHashConfigArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[str]] = None,
                 memory_cost: Optional[pulumi.Input[int]] = None,
                 rounds: Optional[pulumi.Input[int]] = None,
                 salt_separator: Optional[pulumi.Input[str]] = None,
                 signer_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] algorithm: (Output)
               Different password hash algorithms used in Identity Toolkit.
        :param pulumi.Input[int] memory_cost: (Output)
               Memory cost for hash calculation. Used by scrypt and other similar password derivation algorithms. See https://tools.ietf.org/html/rfc7914 for explanation of field.
        :param pulumi.Input[int] rounds: (Output)
               How many rounds for hash calculation. Used by scrypt and other similar password derivation algorithms.
        :param pulumi.Input[str] salt_separator: (Output)
               Non-printable character to be inserted between the salt and plain text password in base64.
        :param pulumi.Input[str] signer_key: (Output)
               Signer key in base64.
        """
        if algorithm is not None:
            pulumi.set(__self__, "algorithm", algorithm)
        if memory_cost is not None:
            pulumi.set(__self__, "memory_cost", memory_cost)
        if rounds is not None:
            pulumi.set(__self__, "rounds", rounds)
        if salt_separator is not None:
            pulumi.set(__self__, "salt_separator", salt_separator)
        if signer_key is not None:
            pulumi.set(__self__, "signer_key", signer_key)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Different password hash algorithms used in Identity Toolkit.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter(name="memoryCost")
    def memory_cost(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Memory cost for hash calculation. Used by scrypt and other similar password derivation algorithms. See https://tools.ietf.org/html/rfc7914 for explanation of field.
        """
        return pulumi.get(self, "memory_cost")

    @memory_cost.setter
    def memory_cost(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_cost", value)

    @property
    @pulumi.getter
    def rounds(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        How many rounds for hash calculation. Used by scrypt and other similar password derivation algorithms.
        """
        return pulumi.get(self, "rounds")

    @rounds.setter
    def rounds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rounds", value)

    @property
    @pulumi.getter(name="saltSeparator")
    def salt_separator(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Non-printable character to be inserted between the salt and plain text password in base64.
        """
        return pulumi.get(self, "salt_separator")

    @salt_separator.setter
    def salt_separator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "salt_separator", value)

    @property
    @pulumi.getter(name="signerKey")
    def signer_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Signer key in base64.
        """
        return pulumi.get(self, "signer_key")

    @signer_key.setter
    def signer_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signer_key", value)


@pulumi.input_type
class ProjectDefaultConfigSignInPhoneNumberArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 test_phone_numbers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether phone number auth is enabled for the project or not.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] test_phone_numbers: A map of <test phone number, fake code> that can be used for phone auth testing.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if test_phone_numbers is not None:
            pulumi.set(__self__, "test_phone_numbers", test_phone_numbers)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether phone number auth is enabled for the project or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="testPhoneNumbers")
    def test_phone_numbers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of <test phone number, fake code> that can be used for phone auth testing.
        """
        return pulumi.get(self, "test_phone_numbers")

    @test_phone_numbers.setter
    def test_phone_numbers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "test_phone_numbers", value)


@pulumi.input_type
class TenantInboundSamlConfigIdpConfigArgs:
    def __init__(__self__, *,
                 idp_certificates: pulumi.Input[Sequence[pulumi.Input['TenantInboundSamlConfigIdpConfigIdpCertificateArgs']]],
                 idp_entity_id: pulumi.Input[str],
                 sso_url: pulumi.Input[str],
                 sign_request: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TenantInboundSamlConfigIdpConfigIdpCertificateArgs']]] idp_certificates: The IDP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
               Structure is documented below.
        :param pulumi.Input[str] idp_entity_id: Unique identifier for all SAML entities
        :param pulumi.Input[str] sso_url: URL to send Authentication request to.
        :param pulumi.Input[bool] sign_request: Indicates if outbounding SAMLRequest should be signed.
        """
        pulumi.set(__self__, "idp_certificates", idp_certificates)
        pulumi.set(__self__, "idp_entity_id", idp_entity_id)
        pulumi.set(__self__, "sso_url", sso_url)
        if sign_request is not None:
            pulumi.set(__self__, "sign_request", sign_request)

    @property
    @pulumi.getter(name="idpCertificates")
    def idp_certificates(self) -> pulumi.Input[Sequence[pulumi.Input['TenantInboundSamlConfigIdpConfigIdpCertificateArgs']]]:
        """
        The IDP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
        Structure is documented below.
        """
        return pulumi.get(self, "idp_certificates")

    @idp_certificates.setter
    def idp_certificates(self, value: pulumi.Input[Sequence[pulumi.Input['TenantInboundSamlConfigIdpConfigIdpCertificateArgs']]]):
        pulumi.set(self, "idp_certificates", value)

    @property
    @pulumi.getter(name="idpEntityId")
    def idp_entity_id(self) -> pulumi.Input[str]:
        """
        Unique identifier for all SAML entities
        """
        return pulumi.get(self, "idp_entity_id")

    @idp_entity_id.setter
    def idp_entity_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "idp_entity_id", value)

    @property
    @pulumi.getter(name="ssoUrl")
    def sso_url(self) -> pulumi.Input[str]:
        """
        URL to send Authentication request to.
        """
        return pulumi.get(self, "sso_url")

    @sso_url.setter
    def sso_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "sso_url", value)

    @property
    @pulumi.getter(name="signRequest")
    def sign_request(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if outbounding SAMLRequest should be signed.
        """
        return pulumi.get(self, "sign_request")

    @sign_request.setter
    def sign_request(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sign_request", value)


@pulumi.input_type
class TenantInboundSamlConfigIdpConfigIdpCertificateArgs:
    def __init__(__self__, *,
                 x509_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] x509_certificate: The x509 certificate
        """
        if x509_certificate is not None:
            pulumi.set(__self__, "x509_certificate", x509_certificate)

    @property
    @pulumi.getter(name="x509Certificate")
    def x509_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        The x509 certificate
        """
        return pulumi.get(self, "x509_certificate")

    @x509_certificate.setter
    def x509_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x509_certificate", value)


@pulumi.input_type
class TenantInboundSamlConfigSpConfigArgs:
    def __init__(__self__, *,
                 callback_uri: pulumi.Input[str],
                 sp_entity_id: pulumi.Input[str],
                 sp_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['TenantInboundSamlConfigSpConfigSpCertificateArgs']]]] = None):
        """
        :param pulumi.Input[str] callback_uri: Callback URI where responses from IDP are handled. Must start with `https://`.
        :param pulumi.Input[str] sp_entity_id: Unique identifier for all SAML entities.
        :param pulumi.Input[Sequence[pulumi.Input['TenantInboundSamlConfigSpConfigSpCertificateArgs']]] sp_certificates: (Output)
               The IDP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
               Structure is documented below.
               
               
               <a name="nested_sp_certificates"></a>The `sp_certificates` block contains:
        """
        pulumi.set(__self__, "callback_uri", callback_uri)
        pulumi.set(__self__, "sp_entity_id", sp_entity_id)
        if sp_certificates is not None:
            pulumi.set(__self__, "sp_certificates", sp_certificates)

    @property
    @pulumi.getter(name="callbackUri")
    def callback_uri(self) -> pulumi.Input[str]:
        """
        Callback URI where responses from IDP are handled. Must start with `https://`.
        """
        return pulumi.get(self, "callback_uri")

    @callback_uri.setter
    def callback_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "callback_uri", value)

    @property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> pulumi.Input[str]:
        """
        Unique identifier for all SAML entities.
        """
        return pulumi.get(self, "sp_entity_id")

    @sp_entity_id.setter
    def sp_entity_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "sp_entity_id", value)

    @property
    @pulumi.getter(name="spCertificates")
    def sp_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TenantInboundSamlConfigSpConfigSpCertificateArgs']]]]:
        """
        (Output)
        The IDP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
        Structure is documented below.


        <a name="nested_sp_certificates"></a>The `sp_certificates` block contains:
        """
        return pulumi.get(self, "sp_certificates")

    @sp_certificates.setter
    def sp_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TenantInboundSamlConfigSpConfigSpCertificateArgs']]]]):
        pulumi.set(self, "sp_certificates", value)


@pulumi.input_type
class TenantInboundSamlConfigSpConfigSpCertificateArgs:
    def __init__(__self__, *,
                 x509_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] x509_certificate: The x509 certificate
        """
        if x509_certificate is not None:
            pulumi.set(__self__, "x509_certificate", x509_certificate)

    @property
    @pulumi.getter(name="x509Certificate")
    def x509_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        The x509 certificate
        """
        return pulumi.get(self, "x509_certificate")

    @x509_certificate.setter
    def x509_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x509_certificate", value)


