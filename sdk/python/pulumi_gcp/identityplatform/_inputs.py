# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'ConfigBlockingFunctionsArgs',
    'ConfigBlockingFunctionsForwardInboundCredentialsArgs',
    'ConfigBlockingFunctionsTriggerArgs',
    'ConfigQuotaArgs',
    'ConfigQuotaSignUpQuotaConfigArgs',
    'ConfigSignInArgs',
    'ConfigSignInAnonymousArgs',
    'ConfigSignInEmailArgs',
    'ConfigSignInHashConfigArgs',
    'ConfigSignInPhoneNumberArgs',
    'InboundSamlConfigIdpConfigArgs',
    'InboundSamlConfigIdpConfigIdpCertificateArgs',
    'InboundSamlConfigSpConfigArgs',
    'InboundSamlConfigSpConfigSpCertificateArgs',
    'ProjectDefaultConfigSignInArgs',
    'ProjectDefaultConfigSignInAnonymousArgs',
    'ProjectDefaultConfigSignInEmailArgs',
    'ProjectDefaultConfigSignInHashConfigArgs',
    'ProjectDefaultConfigSignInPhoneNumberArgs',
    'TenantInboundSamlConfigIdpConfigArgs',
    'TenantInboundSamlConfigIdpConfigIdpCertificateArgs',
    'TenantInboundSamlConfigSpConfigArgs',
    'TenantInboundSamlConfigSpConfigSpCertificateArgs',
]

@pulumi.input_type
class ConfigBlockingFunctionsArgs:
    def __init__(__self__, *,
                 triggers: pulumi.Input[Sequence[pulumi.Input['ConfigBlockingFunctionsTriggerArgs']]],
                 forward_inbound_credentials: Optional[pulumi.Input['ConfigBlockingFunctionsForwardInboundCredentialsArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ConfigBlockingFunctionsTriggerArgs']]] triggers: Map of Trigger to event type. Key should be one of the supported event types: "beforeCreate", "beforeSignIn".
               Structure is documented below.
        :param pulumi.Input['ConfigBlockingFunctionsForwardInboundCredentialsArgs'] forward_inbound_credentials: The user credentials to include in the JWT payload that is sent to the registered Blocking Functions.
               Structure is documented below.
        """
        ConfigBlockingFunctionsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            triggers=triggers,
            forward_inbound_credentials=forward_inbound_credentials,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             triggers: pulumi.Input[Sequence[pulumi.Input['ConfigBlockingFunctionsTriggerArgs']]],
             forward_inbound_credentials: Optional[pulumi.Input['ConfigBlockingFunctionsForwardInboundCredentialsArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("triggers", triggers)
        if forward_inbound_credentials is not None:
            _setter("forward_inbound_credentials", forward_inbound_credentials)

    @property
    @pulumi.getter
    def triggers(self) -> pulumi.Input[Sequence[pulumi.Input['ConfigBlockingFunctionsTriggerArgs']]]:
        """
        Map of Trigger to event type. Key should be one of the supported event types: "beforeCreate", "beforeSignIn".
        Structure is documented below.
        """
        return pulumi.get(self, "triggers")

    @triggers.setter
    def triggers(self, value: pulumi.Input[Sequence[pulumi.Input['ConfigBlockingFunctionsTriggerArgs']]]):
        pulumi.set(self, "triggers", value)

    @property
    @pulumi.getter(name="forwardInboundCredentials")
    def forward_inbound_credentials(self) -> Optional[pulumi.Input['ConfigBlockingFunctionsForwardInboundCredentialsArgs']]:
        """
        The user credentials to include in the JWT payload that is sent to the registered Blocking Functions.
        Structure is documented below.
        """
        return pulumi.get(self, "forward_inbound_credentials")

    @forward_inbound_credentials.setter
    def forward_inbound_credentials(self, value: Optional[pulumi.Input['ConfigBlockingFunctionsForwardInboundCredentialsArgs']]):
        pulumi.set(self, "forward_inbound_credentials", value)


@pulumi.input_type
class ConfigBlockingFunctionsForwardInboundCredentialsArgs:
    def __init__(__self__, *,
                 access_token: Optional[pulumi.Input[bool]] = None,
                 id_token: Optional[pulumi.Input[bool]] = None,
                 refresh_token: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] access_token: Whether to pass the user's OAuth identity provider's access token.
        :param pulumi.Input[bool] id_token: Whether to pass the user's OIDC identity provider's ID token.
        :param pulumi.Input[bool] refresh_token: Whether to pass the user's OAuth identity provider's refresh token.
        """
        ConfigBlockingFunctionsForwardInboundCredentialsArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            access_token=access_token,
            id_token=id_token,
            refresh_token=refresh_token,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             access_token: Optional[pulumi.Input[bool]] = None,
             id_token: Optional[pulumi.Input[bool]] = None,
             refresh_token: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if access_token is not None:
            _setter("access_token", access_token)
        if id_token is not None:
            _setter("id_token", id_token)
        if refresh_token is not None:
            _setter("refresh_token", refresh_token)

    @property
    @pulumi.getter(name="accessToken")
    def access_token(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to pass the user's OAuth identity provider's access token.
        """
        return pulumi.get(self, "access_token")

    @access_token.setter
    def access_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "access_token", value)

    @property
    @pulumi.getter(name="idToken")
    def id_token(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to pass the user's OIDC identity provider's ID token.
        """
        return pulumi.get(self, "id_token")

    @id_token.setter
    def id_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "id_token", value)

    @property
    @pulumi.getter(name="refreshToken")
    def refresh_token(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to pass the user's OAuth identity provider's refresh token.
        """
        return pulumi.get(self, "refresh_token")

    @refresh_token.setter
    def refresh_token(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "refresh_token", value)


@pulumi.input_type
class ConfigBlockingFunctionsTriggerArgs:
    def __init__(__self__, *,
                 event_type: pulumi.Input[str],
                 function_uri: pulumi.Input[str],
                 update_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] event_type: The identifier for this object. Format specified above.
        :param pulumi.Input[str] function_uri: HTTP URI trigger for the Cloud Function.
        :param pulumi.Input[str] update_time: (Output)
               When the trigger was changed.
        """
        ConfigBlockingFunctionsTriggerArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            event_type=event_type,
            function_uri=function_uri,
            update_time=update_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             event_type: pulumi.Input[str],
             function_uri: pulumi.Input[str],
             update_time: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("event_type", event_type)
        _setter("function_uri", function_uri)
        if update_time is not None:
            _setter("update_time", update_time)

    @property
    @pulumi.getter(name="eventType")
    def event_type(self) -> pulumi.Input[str]:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "event_type", value)

    @property
    @pulumi.getter(name="functionUri")
    def function_uri(self) -> pulumi.Input[str]:
        """
        HTTP URI trigger for the Cloud Function.
        """
        return pulumi.get(self, "function_uri")

    @function_uri.setter
    def function_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "function_uri", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        When the trigger was changed.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)


@pulumi.input_type
class ConfigQuotaArgs:
    def __init__(__self__, *,
                 sign_up_quota_config: Optional[pulumi.Input['ConfigQuotaSignUpQuotaConfigArgs']] = None):
        """
        :param pulumi.Input['ConfigQuotaSignUpQuotaConfigArgs'] sign_up_quota_config: Quota for the Signup endpoint, if overwritten. Signup quota is measured in sign ups per project per hour per IP.
               Structure is documented below.
        """
        ConfigQuotaArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            sign_up_quota_config=sign_up_quota_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             sign_up_quota_config: Optional[pulumi.Input['ConfigQuotaSignUpQuotaConfigArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if sign_up_quota_config is not None:
            _setter("sign_up_quota_config", sign_up_quota_config)

    @property
    @pulumi.getter(name="signUpQuotaConfig")
    def sign_up_quota_config(self) -> Optional[pulumi.Input['ConfigQuotaSignUpQuotaConfigArgs']]:
        """
        Quota for the Signup endpoint, if overwritten. Signup quota is measured in sign ups per project per hour per IP.
        Structure is documented below.
        """
        return pulumi.get(self, "sign_up_quota_config")

    @sign_up_quota_config.setter
    def sign_up_quota_config(self, value: Optional[pulumi.Input['ConfigQuotaSignUpQuotaConfigArgs']]):
        pulumi.set(self, "sign_up_quota_config", value)


@pulumi.input_type
class ConfigQuotaSignUpQuotaConfigArgs:
    def __init__(__self__, *,
                 quota: Optional[pulumi.Input[int]] = None,
                 quota_duration: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] quota: A sign up APIs quota that customers can override temporarily.
        :param pulumi.Input[str] quota_duration: How long this quota will be active for. It is measurred in seconds, e.g., Example: "9.615s".
        :param pulumi.Input[str] start_time: When this quota will take affect.
        """
        ConfigQuotaSignUpQuotaConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            quota=quota,
            quota_duration=quota_duration,
            start_time=start_time,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             quota: Optional[pulumi.Input[int]] = None,
             quota_duration: Optional[pulumi.Input[str]] = None,
             start_time: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if quota is not None:
            _setter("quota", quota)
        if quota_duration is not None:
            _setter("quota_duration", quota_duration)
        if start_time is not None:
            _setter("start_time", start_time)

    @property
    @pulumi.getter
    def quota(self) -> Optional[pulumi.Input[int]]:
        """
        A sign up APIs quota that customers can override temporarily.
        """
        return pulumi.get(self, "quota")

    @quota.setter
    def quota(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "quota", value)

    @property
    @pulumi.getter(name="quotaDuration")
    def quota_duration(self) -> Optional[pulumi.Input[str]]:
        """
        How long this quota will be active for. It is measurred in seconds, e.g., Example: "9.615s".
        """
        return pulumi.get(self, "quota_duration")

    @quota_duration.setter
    def quota_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quota_duration", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        When this quota will take affect.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


@pulumi.input_type
class ConfigSignInArgs:
    def __init__(__self__, *,
                 allow_duplicate_emails: Optional[pulumi.Input[bool]] = None,
                 anonymous: Optional[pulumi.Input['ConfigSignInAnonymousArgs']] = None,
                 email: Optional[pulumi.Input['ConfigSignInEmailArgs']] = None,
                 hash_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigSignInHashConfigArgs']]]] = None,
                 phone_number: Optional[pulumi.Input['ConfigSignInPhoneNumberArgs']] = None):
        """
        :param pulumi.Input[bool] allow_duplicate_emails: Whether to allow more than one account to have the same email.
        :param pulumi.Input['ConfigSignInAnonymousArgs'] anonymous: Configuration options related to authenticating an anonymous user.
               Structure is documented below.
        :param pulumi.Input['ConfigSignInEmailArgs'] email: Configuration options related to authenticating a user by their email address.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ConfigSignInHashConfigArgs']]] hash_configs: (Output)
               Output only. Hash config information.
               Structure is documented below.
        :param pulumi.Input['ConfigSignInPhoneNumberArgs'] phone_number: Configuration options related to authenticated a user by their phone number.
               Structure is documented below.
        """
        ConfigSignInArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_duplicate_emails=allow_duplicate_emails,
            anonymous=anonymous,
            email=email,
            hash_configs=hash_configs,
            phone_number=phone_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_duplicate_emails: Optional[pulumi.Input[bool]] = None,
             anonymous: Optional[pulumi.Input['ConfigSignInAnonymousArgs']] = None,
             email: Optional[pulumi.Input['ConfigSignInEmailArgs']] = None,
             hash_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigSignInHashConfigArgs']]]] = None,
             phone_number: Optional[pulumi.Input['ConfigSignInPhoneNumberArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if allow_duplicate_emails is not None:
            _setter("allow_duplicate_emails", allow_duplicate_emails)
        if anonymous is not None:
            _setter("anonymous", anonymous)
        if email is not None:
            _setter("email", email)
        if hash_configs is not None:
            _setter("hash_configs", hash_configs)
        if phone_number is not None:
            _setter("phone_number", phone_number)

    @property
    @pulumi.getter(name="allowDuplicateEmails")
    def allow_duplicate_emails(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow more than one account to have the same email.
        """
        return pulumi.get(self, "allow_duplicate_emails")

    @allow_duplicate_emails.setter
    def allow_duplicate_emails(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_duplicate_emails", value)

    @property
    @pulumi.getter
    def anonymous(self) -> Optional[pulumi.Input['ConfigSignInAnonymousArgs']]:
        """
        Configuration options related to authenticating an anonymous user.
        Structure is documented below.
        """
        return pulumi.get(self, "anonymous")

    @anonymous.setter
    def anonymous(self, value: Optional[pulumi.Input['ConfigSignInAnonymousArgs']]):
        pulumi.set(self, "anonymous", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ConfigSignInEmailArgs']]:
        """
        Configuration options related to authenticating a user by their email address.
        Structure is documented below.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ConfigSignInEmailArgs']]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="hashConfigs")
    def hash_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ConfigSignInHashConfigArgs']]]]:
        """
        (Output)
        Output only. Hash config information.
        Structure is documented below.
        """
        return pulumi.get(self, "hash_configs")

    @hash_configs.setter
    def hash_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ConfigSignInHashConfigArgs']]]]):
        pulumi.set(self, "hash_configs", value)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[pulumi.Input['ConfigSignInPhoneNumberArgs']]:
        """
        Configuration options related to authenticated a user by their phone number.
        Structure is documented below.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: Optional[pulumi.Input['ConfigSignInPhoneNumberArgs']]):
        pulumi.set(self, "phone_number", value)


@pulumi.input_type
class ConfigSignInAnonymousArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Whether anonymous user auth is enabled for the project or not.
               
               <a name="nested_hash_config"></a>The `hash_config` block contains:
        """
        ConfigSignInAnonymousArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: pulumi.Input[bool],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether anonymous user auth is enabled for the project or not.

        <a name="nested_hash_config"></a>The `hash_config` block contains:
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ConfigSignInEmailArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 password_required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether email auth is enabled for the project or not.
        :param pulumi.Input[bool] password_required: Whether a password is required for email auth or not. If true, both an email and
               password must be provided to sign in. If false, a user may sign in via either
               email/password or email link.
        """
        ConfigSignInEmailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            password_required=password_required,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: pulumi.Input[bool],
             password_required: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enabled", enabled)
        if password_required is not None:
            _setter("password_required", password_required)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether email auth is enabled for the project or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="passwordRequired")
    def password_required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether a password is required for email auth or not. If true, both an email and
        password must be provided to sign in. If false, a user may sign in via either
        email/password or email link.
        """
        return pulumi.get(self, "password_required")

    @password_required.setter
    def password_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "password_required", value)


@pulumi.input_type
class ConfigSignInHashConfigArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[str]] = None,
                 memory_cost: Optional[pulumi.Input[int]] = None,
                 rounds: Optional[pulumi.Input[int]] = None,
                 salt_separator: Optional[pulumi.Input[str]] = None,
                 signer_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] algorithm: (Output)
               Different password hash algorithms used in Identity Toolkit.
        :param pulumi.Input[int] memory_cost: (Output)
               Memory cost for hash calculation. Used by scrypt and other similar password derivation algorithms. See https://tools.ietf.org/html/rfc7914 for explanation of field.
        :param pulumi.Input[int] rounds: (Output)
               How many rounds for hash calculation. Used by scrypt and other similar password derivation algorithms.
        :param pulumi.Input[str] salt_separator: (Output)
               Non-printable character to be inserted between the salt and plain text password in base64.
        :param pulumi.Input[str] signer_key: (Output)
               Signer key in base64.
        """
        ConfigSignInHashConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            algorithm=algorithm,
            memory_cost=memory_cost,
            rounds=rounds,
            salt_separator=salt_separator,
            signer_key=signer_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             algorithm: Optional[pulumi.Input[str]] = None,
             memory_cost: Optional[pulumi.Input[int]] = None,
             rounds: Optional[pulumi.Input[int]] = None,
             salt_separator: Optional[pulumi.Input[str]] = None,
             signer_key: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if algorithm is not None:
            _setter("algorithm", algorithm)
        if memory_cost is not None:
            _setter("memory_cost", memory_cost)
        if rounds is not None:
            _setter("rounds", rounds)
        if salt_separator is not None:
            _setter("salt_separator", salt_separator)
        if signer_key is not None:
            _setter("signer_key", signer_key)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Different password hash algorithms used in Identity Toolkit.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter(name="memoryCost")
    def memory_cost(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Memory cost for hash calculation. Used by scrypt and other similar password derivation algorithms. See https://tools.ietf.org/html/rfc7914 for explanation of field.
        """
        return pulumi.get(self, "memory_cost")

    @memory_cost.setter
    def memory_cost(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_cost", value)

    @property
    @pulumi.getter
    def rounds(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        How many rounds for hash calculation. Used by scrypt and other similar password derivation algorithms.
        """
        return pulumi.get(self, "rounds")

    @rounds.setter
    def rounds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rounds", value)

    @property
    @pulumi.getter(name="saltSeparator")
    def salt_separator(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Non-printable character to be inserted between the salt and plain text password in base64.
        """
        return pulumi.get(self, "salt_separator")

    @salt_separator.setter
    def salt_separator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "salt_separator", value)

    @property
    @pulumi.getter(name="signerKey")
    def signer_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Signer key in base64.
        """
        return pulumi.get(self, "signer_key")

    @signer_key.setter
    def signer_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signer_key", value)


@pulumi.input_type
class ConfigSignInPhoneNumberArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool],
                 test_phone_numbers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether phone number auth is enabled for the project or not.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] test_phone_numbers: A map of <test phone number, fake code> that can be used for phone auth testing.
        """
        ConfigSignInPhoneNumberArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            test_phone_numbers=test_phone_numbers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: pulumi.Input[bool],
             test_phone_numbers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enabled", enabled)
        if test_phone_numbers is not None:
            _setter("test_phone_numbers", test_phone_numbers)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether phone number auth is enabled for the project or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="testPhoneNumbers")
    def test_phone_numbers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of <test phone number, fake code> that can be used for phone auth testing.
        """
        return pulumi.get(self, "test_phone_numbers")

    @test_phone_numbers.setter
    def test_phone_numbers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "test_phone_numbers", value)


@pulumi.input_type
class InboundSamlConfigIdpConfigArgs:
    def __init__(__self__, *,
                 idp_certificates: pulumi.Input[Sequence[pulumi.Input['InboundSamlConfigIdpConfigIdpCertificateArgs']]],
                 idp_entity_id: pulumi.Input[str],
                 sso_url: pulumi.Input[str],
                 sign_request: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['InboundSamlConfigIdpConfigIdpCertificateArgs']]] idp_certificates: The IdP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
               Structure is documented below.
        :param pulumi.Input[str] idp_entity_id: Unique identifier for all SAML entities
        :param pulumi.Input[str] sso_url: URL to send Authentication request to.
        :param pulumi.Input[bool] sign_request: Indicates if outbounding SAMLRequest should be signed.
        """
        InboundSamlConfigIdpConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idp_certificates=idp_certificates,
            idp_entity_id=idp_entity_id,
            sso_url=sso_url,
            sign_request=sign_request,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idp_certificates: pulumi.Input[Sequence[pulumi.Input['InboundSamlConfigIdpConfigIdpCertificateArgs']]],
             idp_entity_id: pulumi.Input[str],
             sso_url: pulumi.Input[str],
             sign_request: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("idp_certificates", idp_certificates)
        _setter("idp_entity_id", idp_entity_id)
        _setter("sso_url", sso_url)
        if sign_request is not None:
            _setter("sign_request", sign_request)

    @property
    @pulumi.getter(name="idpCertificates")
    def idp_certificates(self) -> pulumi.Input[Sequence[pulumi.Input['InboundSamlConfigIdpConfigIdpCertificateArgs']]]:
        """
        The IdP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
        Structure is documented below.
        """
        return pulumi.get(self, "idp_certificates")

    @idp_certificates.setter
    def idp_certificates(self, value: pulumi.Input[Sequence[pulumi.Input['InboundSamlConfigIdpConfigIdpCertificateArgs']]]):
        pulumi.set(self, "idp_certificates", value)

    @property
    @pulumi.getter(name="idpEntityId")
    def idp_entity_id(self) -> pulumi.Input[str]:
        """
        Unique identifier for all SAML entities
        """
        return pulumi.get(self, "idp_entity_id")

    @idp_entity_id.setter
    def idp_entity_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "idp_entity_id", value)

    @property
    @pulumi.getter(name="ssoUrl")
    def sso_url(self) -> pulumi.Input[str]:
        """
        URL to send Authentication request to.
        """
        return pulumi.get(self, "sso_url")

    @sso_url.setter
    def sso_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "sso_url", value)

    @property
    @pulumi.getter(name="signRequest")
    def sign_request(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if outbounding SAMLRequest should be signed.
        """
        return pulumi.get(self, "sign_request")

    @sign_request.setter
    def sign_request(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sign_request", value)


@pulumi.input_type
class InboundSamlConfigIdpConfigIdpCertificateArgs:
    def __init__(__self__, *,
                 x509_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] x509_certificate: The IdP's x509 certificate.
        """
        InboundSamlConfigIdpConfigIdpCertificateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            x509_certificate=x509_certificate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             x509_certificate: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if x509_certificate is not None:
            _setter("x509_certificate", x509_certificate)

    @property
    @pulumi.getter(name="x509Certificate")
    def x509_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        The IdP's x509 certificate.
        """
        return pulumi.get(self, "x509_certificate")

    @x509_certificate.setter
    def x509_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x509_certificate", value)


@pulumi.input_type
class InboundSamlConfigSpConfigArgs:
    def __init__(__self__, *,
                 callback_uri: Optional[pulumi.Input[str]] = None,
                 sp_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['InboundSamlConfigSpConfigSpCertificateArgs']]]] = None,
                 sp_entity_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] callback_uri: Callback URI where responses from IDP are handled. Must start with `https://`.
        :param pulumi.Input[Sequence[pulumi.Input['InboundSamlConfigSpConfigSpCertificateArgs']]] sp_certificates: (Output)
               The IDP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
               Structure is documented below.
               
               
               <a name="nested_sp_certificates"></a>The `sp_certificates` block contains:
        :param pulumi.Input[str] sp_entity_id: Unique identifier for all SAML entities.
        """
        InboundSamlConfigSpConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            callback_uri=callback_uri,
            sp_certificates=sp_certificates,
            sp_entity_id=sp_entity_id,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             callback_uri: Optional[pulumi.Input[str]] = None,
             sp_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['InboundSamlConfigSpConfigSpCertificateArgs']]]] = None,
             sp_entity_id: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if callback_uri is not None:
            _setter("callback_uri", callback_uri)
        if sp_certificates is not None:
            _setter("sp_certificates", sp_certificates)
        if sp_entity_id is not None:
            _setter("sp_entity_id", sp_entity_id)

    @property
    @pulumi.getter(name="callbackUri")
    def callback_uri(self) -> Optional[pulumi.Input[str]]:
        """
        Callback URI where responses from IDP are handled. Must start with `https://`.
        """
        return pulumi.get(self, "callback_uri")

    @callback_uri.setter
    def callback_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "callback_uri", value)

    @property
    @pulumi.getter(name="spCertificates")
    def sp_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InboundSamlConfigSpConfigSpCertificateArgs']]]]:
        """
        (Output)
        The IDP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
        Structure is documented below.


        <a name="nested_sp_certificates"></a>The `sp_certificates` block contains:
        """
        return pulumi.get(self, "sp_certificates")

    @sp_certificates.setter
    def sp_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InboundSamlConfigSpConfigSpCertificateArgs']]]]):
        pulumi.set(self, "sp_certificates", value)

    @property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> Optional[pulumi.Input[str]]:
        """
        Unique identifier for all SAML entities.
        """
        return pulumi.get(self, "sp_entity_id")

    @sp_entity_id.setter
    def sp_entity_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sp_entity_id", value)


@pulumi.input_type
class InboundSamlConfigSpConfigSpCertificateArgs:
    def __init__(__self__, *,
                 x509_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] x509_certificate: The IdP's x509 certificate.
        """
        InboundSamlConfigSpConfigSpCertificateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            x509_certificate=x509_certificate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             x509_certificate: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if x509_certificate is not None:
            _setter("x509_certificate", x509_certificate)

    @property
    @pulumi.getter(name="x509Certificate")
    def x509_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        The IdP's x509 certificate.
        """
        return pulumi.get(self, "x509_certificate")

    @x509_certificate.setter
    def x509_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x509_certificate", value)


@pulumi.input_type
class ProjectDefaultConfigSignInArgs:
    def __init__(__self__, *,
                 allow_duplicate_emails: Optional[pulumi.Input[bool]] = None,
                 anonymous: Optional[pulumi.Input['ProjectDefaultConfigSignInAnonymousArgs']] = None,
                 email: Optional[pulumi.Input['ProjectDefaultConfigSignInEmailArgs']] = None,
                 hash_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectDefaultConfigSignInHashConfigArgs']]]] = None,
                 phone_number: Optional[pulumi.Input['ProjectDefaultConfigSignInPhoneNumberArgs']] = None):
        """
        :param pulumi.Input[bool] allow_duplicate_emails: Whether to allow more than one account to have the same email.
        :param pulumi.Input['ProjectDefaultConfigSignInAnonymousArgs'] anonymous: Configuration options related to authenticating an anonymous user.
               Structure is documented below.
        :param pulumi.Input['ProjectDefaultConfigSignInEmailArgs'] email: Configuration options related to authenticating a user by their email address.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ProjectDefaultConfigSignInHashConfigArgs']]] hash_configs: (Output)
               Output only. Hash config information.
               Structure is documented below.
        :param pulumi.Input['ProjectDefaultConfigSignInPhoneNumberArgs'] phone_number: Configuration options related to authenticated a user by their phone number.
               Structure is documented below.
        """
        ProjectDefaultConfigSignInArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_duplicate_emails=allow_duplicate_emails,
            anonymous=anonymous,
            email=email,
            hash_configs=hash_configs,
            phone_number=phone_number,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_duplicate_emails: Optional[pulumi.Input[bool]] = None,
             anonymous: Optional[pulumi.Input['ProjectDefaultConfigSignInAnonymousArgs']] = None,
             email: Optional[pulumi.Input['ProjectDefaultConfigSignInEmailArgs']] = None,
             hash_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectDefaultConfigSignInHashConfigArgs']]]] = None,
             phone_number: Optional[pulumi.Input['ProjectDefaultConfigSignInPhoneNumberArgs']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if allow_duplicate_emails is not None:
            _setter("allow_duplicate_emails", allow_duplicate_emails)
        if anonymous is not None:
            _setter("anonymous", anonymous)
        if email is not None:
            _setter("email", email)
        if hash_configs is not None:
            _setter("hash_configs", hash_configs)
        if phone_number is not None:
            _setter("phone_number", phone_number)

    @property
    @pulumi.getter(name="allowDuplicateEmails")
    def allow_duplicate_emails(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to allow more than one account to have the same email.
        """
        return pulumi.get(self, "allow_duplicate_emails")

    @allow_duplicate_emails.setter
    def allow_duplicate_emails(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_duplicate_emails", value)

    @property
    @pulumi.getter
    def anonymous(self) -> Optional[pulumi.Input['ProjectDefaultConfigSignInAnonymousArgs']]:
        """
        Configuration options related to authenticating an anonymous user.
        Structure is documented below.
        """
        return pulumi.get(self, "anonymous")

    @anonymous.setter
    def anonymous(self, value: Optional[pulumi.Input['ProjectDefaultConfigSignInAnonymousArgs']]):
        pulumi.set(self, "anonymous", value)

    @property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input['ProjectDefaultConfigSignInEmailArgs']]:
        """
        Configuration options related to authenticating a user by their email address.
        Structure is documented below.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input['ProjectDefaultConfigSignInEmailArgs']]):
        pulumi.set(self, "email", value)

    @property
    @pulumi.getter(name="hashConfigs")
    def hash_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ProjectDefaultConfigSignInHashConfigArgs']]]]:
        """
        (Output)
        Output only. Hash config information.
        Structure is documented below.
        """
        return pulumi.get(self, "hash_configs")

    @hash_configs.setter
    def hash_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ProjectDefaultConfigSignInHashConfigArgs']]]]):
        pulumi.set(self, "hash_configs", value)

    @property
    @pulumi.getter(name="phoneNumber")
    def phone_number(self) -> Optional[pulumi.Input['ProjectDefaultConfigSignInPhoneNumberArgs']]:
        """
        Configuration options related to authenticated a user by their phone number.
        Structure is documented below.
        """
        return pulumi.get(self, "phone_number")

    @phone_number.setter
    def phone_number(self, value: Optional[pulumi.Input['ProjectDefaultConfigSignInPhoneNumberArgs']]):
        pulumi.set(self, "phone_number", value)


@pulumi.input_type
class ProjectDefaultConfigSignInAnonymousArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Whether anonymous user auth is enabled for the project or not.
               
               <a name="nested_hash_config"></a>The `hash_config` block contains:
        """
        ProjectDefaultConfigSignInAnonymousArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: pulumi.Input[bool],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether anonymous user auth is enabled for the project or not.

        <a name="nested_hash_config"></a>The `hash_config` block contains:
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class ProjectDefaultConfigSignInEmailArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 password_required: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether email auth is enabled for the project or not.
        :param pulumi.Input[bool] password_required: Whether a password is required for email auth or not. If true, both an email and
               password must be provided to sign in. If false, a user may sign in via either
               email/password or email link.
        """
        ProjectDefaultConfigSignInEmailArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            password_required=password_required,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             password_required: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)
        if password_required is not None:
            _setter("password_required", password_required)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether email auth is enabled for the project or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="passwordRequired")
    def password_required(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether a password is required for email auth or not. If true, both an email and
        password must be provided to sign in. If false, a user may sign in via either
        email/password or email link.
        """
        return pulumi.get(self, "password_required")

    @password_required.setter
    def password_required(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "password_required", value)


@pulumi.input_type
class ProjectDefaultConfigSignInHashConfigArgs:
    def __init__(__self__, *,
                 algorithm: Optional[pulumi.Input[str]] = None,
                 memory_cost: Optional[pulumi.Input[int]] = None,
                 rounds: Optional[pulumi.Input[int]] = None,
                 salt_separator: Optional[pulumi.Input[str]] = None,
                 signer_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] algorithm: (Output)
               Different password hash algorithms used in Identity Toolkit.
        :param pulumi.Input[int] memory_cost: (Output)
               Memory cost for hash calculation. Used by scrypt and other similar password derivation algorithms. See https://tools.ietf.org/html/rfc7914 for explanation of field.
        :param pulumi.Input[int] rounds: (Output)
               How many rounds for hash calculation. Used by scrypt and other similar password derivation algorithms.
        :param pulumi.Input[str] salt_separator: (Output)
               Non-printable character to be inserted between the salt and plain text password in base64.
        :param pulumi.Input[str] signer_key: (Output)
               Signer key in base64.
        """
        ProjectDefaultConfigSignInHashConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            algorithm=algorithm,
            memory_cost=memory_cost,
            rounds=rounds,
            salt_separator=salt_separator,
            signer_key=signer_key,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             algorithm: Optional[pulumi.Input[str]] = None,
             memory_cost: Optional[pulumi.Input[int]] = None,
             rounds: Optional[pulumi.Input[int]] = None,
             salt_separator: Optional[pulumi.Input[str]] = None,
             signer_key: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if algorithm is not None:
            _setter("algorithm", algorithm)
        if memory_cost is not None:
            _setter("memory_cost", memory_cost)
        if rounds is not None:
            _setter("rounds", rounds)
        if salt_separator is not None:
            _setter("salt_separator", salt_separator)
        if signer_key is not None:
            _setter("signer_key", signer_key)

    @property
    @pulumi.getter
    def algorithm(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Different password hash algorithms used in Identity Toolkit.
        """
        return pulumi.get(self, "algorithm")

    @algorithm.setter
    def algorithm(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "algorithm", value)

    @property
    @pulumi.getter(name="memoryCost")
    def memory_cost(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Memory cost for hash calculation. Used by scrypt and other similar password derivation algorithms. See https://tools.ietf.org/html/rfc7914 for explanation of field.
        """
        return pulumi.get(self, "memory_cost")

    @memory_cost.setter
    def memory_cost(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_cost", value)

    @property
    @pulumi.getter
    def rounds(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        How many rounds for hash calculation. Used by scrypt and other similar password derivation algorithms.
        """
        return pulumi.get(self, "rounds")

    @rounds.setter
    def rounds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rounds", value)

    @property
    @pulumi.getter(name="saltSeparator")
    def salt_separator(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Non-printable character to be inserted between the salt and plain text password in base64.
        """
        return pulumi.get(self, "salt_separator")

    @salt_separator.setter
    def salt_separator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "salt_separator", value)

    @property
    @pulumi.getter(name="signerKey")
    def signer_key(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Signer key in base64.
        """
        return pulumi.get(self, "signer_key")

    @signer_key.setter
    def signer_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "signer_key", value)


@pulumi.input_type
class ProjectDefaultConfigSignInPhoneNumberArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 test_phone_numbers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether phone number auth is enabled for the project or not.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] test_phone_numbers: A map of <test phone number, fake code> that can be used for phone auth testing.
        """
        ProjectDefaultConfigSignInPhoneNumberArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
            test_phone_numbers=test_phone_numbers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[pulumi.Input[bool]] = None,
             test_phone_numbers: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)
        if test_phone_numbers is not None:
            _setter("test_phone_numbers", test_phone_numbers)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether phone number auth is enabled for the project or not.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="testPhoneNumbers")
    def test_phone_numbers(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of <test phone number, fake code> that can be used for phone auth testing.
        """
        return pulumi.get(self, "test_phone_numbers")

    @test_phone_numbers.setter
    def test_phone_numbers(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "test_phone_numbers", value)


@pulumi.input_type
class TenantInboundSamlConfigIdpConfigArgs:
    def __init__(__self__, *,
                 idp_certificates: pulumi.Input[Sequence[pulumi.Input['TenantInboundSamlConfigIdpConfigIdpCertificateArgs']]],
                 idp_entity_id: pulumi.Input[str],
                 sso_url: pulumi.Input[str],
                 sign_request: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TenantInboundSamlConfigIdpConfigIdpCertificateArgs']]] idp_certificates: The IDP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
               Structure is documented below.
        :param pulumi.Input[str] idp_entity_id: Unique identifier for all SAML entities
        :param pulumi.Input[str] sso_url: URL to send Authentication request to.
        :param pulumi.Input[bool] sign_request: Indicates if outbounding SAMLRequest should be signed.
        """
        TenantInboundSamlConfigIdpConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            idp_certificates=idp_certificates,
            idp_entity_id=idp_entity_id,
            sso_url=sso_url,
            sign_request=sign_request,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             idp_certificates: pulumi.Input[Sequence[pulumi.Input['TenantInboundSamlConfigIdpConfigIdpCertificateArgs']]],
             idp_entity_id: pulumi.Input[str],
             sso_url: pulumi.Input[str],
             sign_request: Optional[pulumi.Input[bool]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("idp_certificates", idp_certificates)
        _setter("idp_entity_id", idp_entity_id)
        _setter("sso_url", sso_url)
        if sign_request is not None:
            _setter("sign_request", sign_request)

    @property
    @pulumi.getter(name="idpCertificates")
    def idp_certificates(self) -> pulumi.Input[Sequence[pulumi.Input['TenantInboundSamlConfigIdpConfigIdpCertificateArgs']]]:
        """
        The IDP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
        Structure is documented below.
        """
        return pulumi.get(self, "idp_certificates")

    @idp_certificates.setter
    def idp_certificates(self, value: pulumi.Input[Sequence[pulumi.Input['TenantInboundSamlConfigIdpConfigIdpCertificateArgs']]]):
        pulumi.set(self, "idp_certificates", value)

    @property
    @pulumi.getter(name="idpEntityId")
    def idp_entity_id(self) -> pulumi.Input[str]:
        """
        Unique identifier for all SAML entities
        """
        return pulumi.get(self, "idp_entity_id")

    @idp_entity_id.setter
    def idp_entity_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "idp_entity_id", value)

    @property
    @pulumi.getter(name="ssoUrl")
    def sso_url(self) -> pulumi.Input[str]:
        """
        URL to send Authentication request to.
        """
        return pulumi.get(self, "sso_url")

    @sso_url.setter
    def sso_url(self, value: pulumi.Input[str]):
        pulumi.set(self, "sso_url", value)

    @property
    @pulumi.getter(name="signRequest")
    def sign_request(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if outbounding SAMLRequest should be signed.
        """
        return pulumi.get(self, "sign_request")

    @sign_request.setter
    def sign_request(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "sign_request", value)


@pulumi.input_type
class TenantInboundSamlConfigIdpConfigIdpCertificateArgs:
    def __init__(__self__, *,
                 x509_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] x509_certificate: The x509 certificate
        """
        TenantInboundSamlConfigIdpConfigIdpCertificateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            x509_certificate=x509_certificate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             x509_certificate: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if x509_certificate is not None:
            _setter("x509_certificate", x509_certificate)

    @property
    @pulumi.getter(name="x509Certificate")
    def x509_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        The x509 certificate
        """
        return pulumi.get(self, "x509_certificate")

    @x509_certificate.setter
    def x509_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x509_certificate", value)


@pulumi.input_type
class TenantInboundSamlConfigSpConfigArgs:
    def __init__(__self__, *,
                 callback_uri: pulumi.Input[str],
                 sp_entity_id: pulumi.Input[str],
                 sp_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['TenantInboundSamlConfigSpConfigSpCertificateArgs']]]] = None):
        """
        :param pulumi.Input[str] callback_uri: Callback URI where responses from IDP are handled. Must start with `https://`.
        :param pulumi.Input[str] sp_entity_id: Unique identifier for all SAML entities.
        :param pulumi.Input[Sequence[pulumi.Input['TenantInboundSamlConfigSpConfigSpCertificateArgs']]] sp_certificates: (Output)
               The IDP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
               Structure is documented below.
               
               
               <a name="nested_sp_certificates"></a>The `sp_certificates` block contains:
        """
        TenantInboundSamlConfigSpConfigArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            callback_uri=callback_uri,
            sp_entity_id=sp_entity_id,
            sp_certificates=sp_certificates,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             callback_uri: pulumi.Input[str],
             sp_entity_id: pulumi.Input[str],
             sp_certificates: Optional[pulumi.Input[Sequence[pulumi.Input['TenantInboundSamlConfigSpConfigSpCertificateArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("callback_uri", callback_uri)
        _setter("sp_entity_id", sp_entity_id)
        if sp_certificates is not None:
            _setter("sp_certificates", sp_certificates)

    @property
    @pulumi.getter(name="callbackUri")
    def callback_uri(self) -> pulumi.Input[str]:
        """
        Callback URI where responses from IDP are handled. Must start with `https://`.
        """
        return pulumi.get(self, "callback_uri")

    @callback_uri.setter
    def callback_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "callback_uri", value)

    @property
    @pulumi.getter(name="spEntityId")
    def sp_entity_id(self) -> pulumi.Input[str]:
        """
        Unique identifier for all SAML entities.
        """
        return pulumi.get(self, "sp_entity_id")

    @sp_entity_id.setter
    def sp_entity_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "sp_entity_id", value)

    @property
    @pulumi.getter(name="spCertificates")
    def sp_certificates(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TenantInboundSamlConfigSpConfigSpCertificateArgs']]]]:
        """
        (Output)
        The IDP's certificate data to verify the signature in the SAMLResponse issued by the IDP.
        Structure is documented below.


        <a name="nested_sp_certificates"></a>The `sp_certificates` block contains:
        """
        return pulumi.get(self, "sp_certificates")

    @sp_certificates.setter
    def sp_certificates(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TenantInboundSamlConfigSpConfigSpCertificateArgs']]]]):
        pulumi.set(self, "sp_certificates", value)


@pulumi.input_type
class TenantInboundSamlConfigSpConfigSpCertificateArgs:
    def __init__(__self__, *,
                 x509_certificate: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] x509_certificate: The x509 certificate
        """
        TenantInboundSamlConfigSpConfigSpCertificateArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            x509_certificate=x509_certificate,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             x509_certificate: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if x509_certificate is not None:
            _setter("x509_certificate", x509_certificate)

    @property
    @pulumi.getter(name="x509Certificate")
    def x509_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        The x509 certificate
        """
        return pulumi.get(self, "x509_certificate")

    @x509_certificate.setter
    def x509_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "x509_certificate", value)


