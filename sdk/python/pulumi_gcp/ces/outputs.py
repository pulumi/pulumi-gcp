# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AgentAfterAgentCallback',
    'AgentAfterModelCallback',
    'AgentAfterToolCallback',
    'AgentBeforeAgentCallback',
    'AgentBeforeModelCallback',
    'AgentBeforeToolCallback',
    'AgentLlmAgent',
    'AgentModelSettings',
    'AgentRemoteDialogflowAgent',
    'AgentToolset',
    'AppAudioProcessingConfig',
    'AppAudioProcessingConfigAmbientSoundConfig',
    'AppAudioProcessingConfigBargeInConfig',
    'AppAudioProcessingConfigSynthesizeSpeechConfig',
    'AppClientCertificateSettings',
    'AppDataStoreSettings',
    'AppDataStoreSettingsEngine',
    'AppDefaultChannelProfile',
    'AppDefaultChannelProfilePersonaProperty',
    'AppDefaultChannelProfileWebWidgetConfig',
    'AppEvaluationMetricsThresholds',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholds',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholds',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholds',
    'AppLanguageSettings',
    'AppLoggingSettings',
    'AppLoggingSettingsAudioRecordingConfig',
    'AppLoggingSettingsBigqueryExportSettings',
    'AppLoggingSettingsCloudLoggingSettings',
    'AppLoggingSettingsConversationLoggingSettings',
    'AppLoggingSettingsRedactionConfig',
    'AppModelSettings',
    'AppTimeZoneSettings',
    'AppVariableDeclaration',
    'AppVariableDeclarationSchema',
    'AppVersionSnapshot',
    'AppVersionSnapshotAgent',
    'AppVersionSnapshotAgentAfterAgentCallback',
    'AppVersionSnapshotAgentAfterModelCallback',
    'AppVersionSnapshotAgentAfterToolCallback',
    'AppVersionSnapshotAgentBeforeAgentCallback',
    'AppVersionSnapshotAgentBeforeModelCallback',
    'AppVersionSnapshotAgentBeforeToolCallback',
    'AppVersionSnapshotAgentLlmAgent',
    'AppVersionSnapshotAgentModelSetting',
    'AppVersionSnapshotAgentRemoteDialogflowAgent',
    'AppVersionSnapshotAgentToolset',
    'AppVersionSnapshotApp',
    'AppVersionSnapshotAppAudioProcessingConfig',
    'AppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfig',
    'AppVersionSnapshotAppAudioProcessingConfigBargeInConfig',
    'AppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfig',
    'AppVersionSnapshotAppClientCertificateSetting',
    'AppVersionSnapshotAppDataStoreSetting',
    'AppVersionSnapshotAppDataStoreSettingEngine',
    'AppVersionSnapshotAppDefaultChannelProfile',
    'AppVersionSnapshotAppDefaultChannelProfilePersonaProperty',
    'AppVersionSnapshotAppDefaultChannelProfileWebWidgetConfig',
    'AppVersionSnapshotAppEvaluationMetricsThreshold',
    'AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThreshold',
    'AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdExpectationLevelMetricsThreshold',
    'AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdTurnLevelMetricsThreshold',
    'AppVersionSnapshotAppLanguageSetting',
    'AppVersionSnapshotAppLoggingSetting',
    'AppVersionSnapshotAppLoggingSettingAudioRecordingConfig',
    'AppVersionSnapshotAppLoggingSettingBigqueryExportSetting',
    'AppVersionSnapshotAppLoggingSettingCloudLoggingSetting',
    'AppVersionSnapshotAppLoggingSettingConversationLoggingSetting',
    'AppVersionSnapshotAppLoggingSettingRedactionConfig',
    'AppVersionSnapshotAppModelSetting',
    'AppVersionSnapshotAppTimeZoneSetting',
    'AppVersionSnapshotAppVariableDeclaration',
    'AppVersionSnapshotAppVariableDeclarationSchema',
    'AppVersionSnapshotExample',
    'AppVersionSnapshotExampleMessage',
    'AppVersionSnapshotExampleMessageChunk',
    'AppVersionSnapshotExampleMessageChunkAgentTransfer',
    'AppVersionSnapshotExampleMessageChunkImage',
    'AppVersionSnapshotExampleMessageChunkToolCall',
    'AppVersionSnapshotExampleMessageChunkToolCallToolsetTool',
    'AppVersionSnapshotExampleMessageChunkToolResponse',
    'AppVersionSnapshotExampleMessageChunkToolResponseToolsetTool',
    'AppVersionSnapshotGuardrail',
    'AppVersionSnapshotGuardrailAction',
    'AppVersionSnapshotGuardrailActionGenerativeAnswer',
    'AppVersionSnapshotGuardrailActionRespondImmediately',
    'AppVersionSnapshotGuardrailActionRespondImmediatelyResponse',
    'AppVersionSnapshotGuardrailActionTransferAgent',
    'AppVersionSnapshotGuardrailCodeCallback',
    'AppVersionSnapshotGuardrailCodeCallbackAfterAgentCallback',
    'AppVersionSnapshotGuardrailCodeCallbackAfterModelCallback',
    'AppVersionSnapshotGuardrailCodeCallbackBeforeAgentCallback',
    'AppVersionSnapshotGuardrailCodeCallbackBeforeModelCallback',
    'AppVersionSnapshotGuardrailContentFilter',
    'AppVersionSnapshotGuardrailLlmPolicy',
    'AppVersionSnapshotGuardrailLlmPolicyModelSetting',
    'AppVersionSnapshotGuardrailLlmPromptSecurity',
    'AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicy',
    'AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyModelSetting',
    'AppVersionSnapshotGuardrailLlmPromptSecurityDefaultSetting',
    'AppVersionSnapshotGuardrailModelSafety',
    'AppVersionSnapshotGuardrailModelSafetySafetySetting',
    'AppVersionSnapshotTool',
    'AppVersionSnapshotToolClientFunction',
    'AppVersionSnapshotToolClientFunctionParameter',
    'AppVersionSnapshotToolClientFunctionResponse',
    'AppVersionSnapshotToolDataStoreTool',
    'AppVersionSnapshotToolDataStoreToolBoostSpec',
    'AppVersionSnapshotToolDataStoreToolBoostSpecSpec',
    'AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpec',
    'AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpec',
    'AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPoint',
    'AppVersionSnapshotToolDataStoreToolEngineSource',
    'AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSource',
    'AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStore',
    'AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfig',
    'AppVersionSnapshotToolDataStoreToolModalityConfig',
    'AppVersionSnapshotToolDataStoreToolModalityConfigGroundingConfig',
    'AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfig',
    'AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigModelSetting',
    'AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfig',
    'AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigModelSetting',
    'AppVersionSnapshotToolGoogleSearchTool',
    'AppVersionSnapshotToolOpenApiTool',
    'AppVersionSnapshotToolOpenApiToolApiAuthentication',
    'AppVersionSnapshotToolOpenApiToolApiAuthenticationApiKeyConfig',
    'AppVersionSnapshotToolOpenApiToolApiAuthenticationOauthConfig',
    'AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAccountAuthConfig',
    'AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfig',
    'AppVersionSnapshotToolOpenApiToolServiceDirectoryConfig',
    'AppVersionSnapshotToolOpenApiToolTlsConfig',
    'AppVersionSnapshotToolOpenApiToolTlsConfigCaCert',
    'AppVersionSnapshotToolPythonFunction',
    'AppVersionSnapshotToolSystemTool',
    'AppVersionSnapshotToolset',
    'AppVersionSnapshotToolsetOpenApiToolset',
    'AppVersionSnapshotToolsetOpenApiToolsetApiAuthentication',
    'AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationApiKeyConfig',
    'AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationBearerTokenConfig',
    'AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationOauthConfig',
    'AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfig',
    'AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfig',
    'AppVersionSnapshotToolsetOpenApiToolsetServiceDirectoryConfig',
    'AppVersionSnapshotToolsetOpenApiToolsetTlsConfig',
    'AppVersionSnapshotToolsetOpenApiToolsetTlsConfigCaCert',
    'DeploymentChannelProfile',
    'DeploymentChannelProfilePersonaProperty',
    'DeploymentChannelProfileWebWidgetConfig',
    'ExampleMessage',
    'ExampleMessageChunk',
    'ExampleMessageChunkAgentTransfer',
    'ExampleMessageChunkImage',
    'ExampleMessageChunkToolCall',
    'ExampleMessageChunkToolCallToolsetTool',
    'ExampleMessageChunkToolResponse',
    'ExampleMessageChunkToolResponseToolsetTool',
    'GuardrailAction',
    'GuardrailActionGenerativeAnswer',
    'GuardrailActionRespondImmediately',
    'GuardrailActionRespondImmediatelyResponse',
    'GuardrailActionTransferAgent',
    'GuardrailCodeCallback',
    'GuardrailCodeCallbackAfterAgentCallback',
    'GuardrailCodeCallbackAfterModelCallback',
    'GuardrailCodeCallbackBeforeAgentCallback',
    'GuardrailCodeCallbackBeforeModelCallback',
    'GuardrailContentFilter',
    'GuardrailLlmPolicy',
    'GuardrailLlmPolicyModelSettings',
    'GuardrailLlmPromptSecurity',
    'GuardrailLlmPromptSecurityCustomPolicy',
    'GuardrailLlmPromptSecurityCustomPolicyModelSettings',
    'GuardrailLlmPromptSecurityDefaultSettings',
    'GuardrailModelSafety',
    'GuardrailModelSafetySafetySetting',
    'ToolClientFunction',
    'ToolClientFunctionParameters',
    'ToolClientFunctionResponse',
    'ToolDataStoreTool',
    'ToolDataStoreToolBoostSpec',
    'ToolDataStoreToolBoostSpecSpec',
    'ToolDataStoreToolBoostSpecSpecConditionBoostSpec',
    'ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpec',
    'ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPoint',
    'ToolDataStoreToolEngineSource',
    'ToolDataStoreToolEngineSourceDataStoreSource',
    'ToolDataStoreToolEngineSourceDataStoreSourceDataStore',
    'ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfig',
    'ToolDataStoreToolModalityConfig',
    'ToolDataStoreToolModalityConfigGroundingConfig',
    'ToolDataStoreToolModalityConfigRewriterConfig',
    'ToolDataStoreToolModalityConfigRewriterConfigModelSettings',
    'ToolDataStoreToolModalityConfigSummarizationConfig',
    'ToolDataStoreToolModalityConfigSummarizationConfigModelSettings',
    'ToolGoogleSearchTool',
    'ToolOpenApiTool',
    'ToolOpenApiToolApiAuthentication',
    'ToolOpenApiToolApiAuthenticationApiKeyConfig',
    'ToolOpenApiToolApiAuthenticationBearerTokenConfig',
    'ToolOpenApiToolApiAuthenticationOauthConfig',
    'ToolOpenApiToolApiAuthenticationServiceAccountAuthConfig',
    'ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfig',
    'ToolOpenApiToolServiceDirectoryConfig',
    'ToolOpenApiToolTlsConfig',
    'ToolOpenApiToolTlsConfigCaCert',
    'ToolPythonFunction',
    'ToolSystemTool',
    'ToolsetOpenApiToolset',
    'ToolsetOpenApiToolsetApiAuthentication',
    'ToolsetOpenApiToolsetApiAuthenticationApiKeyConfig',
    'ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfig',
    'ToolsetOpenApiToolsetApiAuthenticationOauthConfig',
    'ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfig',
    'ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfig',
    'ToolsetOpenApiToolsetServiceDirectoryConfig',
    'ToolsetOpenApiToolsetTlsConfig',
    'ToolsetOpenApiToolsetTlsConfigCaCert',
]

@pulumi.output_type
class AgentAfterAgentCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAfterAgentCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAfterAgentCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAfterAgentCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 python_code: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str python_code: The python code to execute for the callback.
        :param _builtins.str description: Human-readable description of the callback.
        :param _builtins.bool disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> _builtins.str:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class AgentAfterModelCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAfterModelCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAfterModelCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAfterModelCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 python_code: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str python_code: The python code to execute for the callback.
        :param _builtins.str description: Human-readable description of the callback.
        :param _builtins.bool disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> _builtins.str:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class AgentAfterToolCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentAfterToolCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentAfterToolCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentAfterToolCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 python_code: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str python_code: The python code to execute for the callback.
        :param _builtins.str description: Human-readable description of the callback.
        :param _builtins.bool disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> _builtins.str:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class AgentBeforeAgentCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentBeforeAgentCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentBeforeAgentCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentBeforeAgentCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 python_code: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str python_code: The python code to execute for the callback.
        :param _builtins.str description: Human-readable description of the callback.
        :param _builtins.bool disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> _builtins.str:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class AgentBeforeModelCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentBeforeModelCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentBeforeModelCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentBeforeModelCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 python_code: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str python_code: The python code to execute for the callback.
        :param _builtins.str description: Human-readable description of the callback.
        :param _builtins.bool disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> _builtins.str:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class AgentBeforeToolCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentBeforeToolCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentBeforeToolCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentBeforeToolCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 python_code: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str python_code: The python code to execute for the callback.
        :param _builtins.str description: Human-readable description of the callback.
        :param _builtins.bool disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> _builtins.str:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class AgentLlmAgent(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class AgentModelSettings(dict):
    def __init__(__self__, *,
                 model: Optional[_builtins.str] = None,
                 temperature: Optional[_builtins.float] = None):
        """
        :param _builtins.str model: The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param _builtins.float temperature: If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")


@pulumi.output_type
class AgentRemoteDialogflowAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "flowId":
            suggest = "flow_id"
        elif key == "environmentId":
            suggest = "environment_id"
        elif key == "inputVariableMapping":
            suggest = "input_variable_mapping"
        elif key == "outputVariableMapping":
            suggest = "output_variable_mapping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentRemoteDialogflowAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentRemoteDialogflowAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentRemoteDialogflowAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent: _builtins.str,
                 flow_id: _builtins.str,
                 environment_id: Optional[_builtins.str] = None,
                 input_variable_mapping: Optional[Mapping[str, _builtins.str]] = None,
                 output_variable_mapping: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str agent: The
               [Dialogflow](https://cloud.google.com/dialogflow/cx/docs/concept/console-conversational-agents
               agent resource name.
               Format: `projects/{project}/locations/{location}/agents/{agent}`
        :param _builtins.str flow_id: The flow ID of the flow in the Dialogflow agent.
        :param _builtins.str environment_id: The environment ID of the Dialogflow agent be used for the agent
               execution. If not specified, the draft environment will be used.
        :param Mapping[str, _builtins.str] input_variable_mapping: The mapping of the app variables names to the Dialogflow session
               parameters names to be sent to the Dialogflow agent as input.
        :param Mapping[str, _builtins.str] output_variable_mapping: The mapping of the Dialogflow session parameters names to the app
               variables names to be sent back to the CES agent after the Dialogflow
               agent execution ends.
        """
        pulumi.set(__self__, "agent", agent)
        pulumi.set(__self__, "flow_id", flow_id)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)
        if input_variable_mapping is not None:
            pulumi.set(__self__, "input_variable_mapping", input_variable_mapping)
        if output_variable_mapping is not None:
            pulumi.set(__self__, "output_variable_mapping", output_variable_mapping)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> _builtins.str:
        """
        The
        [Dialogflow](https://cloud.google.com/dialogflow/cx/docs/concept/console-conversational-agents
        agent resource name.
        Format: `projects/{project}/locations/{location}/agents/{agent}`
        """
        return pulumi.get(self, "agent")

    @_builtins.property
    @pulumi.getter(name="flowId")
    def flow_id(self) -> _builtins.str:
        """
        The flow ID of the flow in the Dialogflow agent.
        """
        return pulumi.get(self, "flow_id")

    @_builtins.property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[_builtins.str]:
        """
        The environment ID of the Dialogflow agent be used for the agent
        execution. If not specified, the draft environment will be used.
        """
        return pulumi.get(self, "environment_id")

    @_builtins.property
    @pulumi.getter(name="inputVariableMapping")
    def input_variable_mapping(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The mapping of the app variables names to the Dialogflow session
        parameters names to be sent to the Dialogflow agent as input.
        """
        return pulumi.get(self, "input_variable_mapping")

    @_builtins.property
    @pulumi.getter(name="outputVariableMapping")
    def output_variable_mapping(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        The mapping of the Dialogflow session parameters names to the app
        variables names to be sent back to the CES agent after the Dialogflow
        agent execution ends.
        """
        return pulumi.get(self, "output_variable_mapping")


@pulumi.output_type
class AgentToolset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toolIds":
            suggest = "tool_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AgentToolset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AgentToolset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AgentToolset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 toolset: _builtins.str,
                 tool_ids: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str toolset: The resource name of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param Sequence[_builtins.str] tool_ids: The tools IDs to filter the toolset.
        """
        pulumi.set(__self__, "toolset", toolset)
        if tool_ids is not None:
            pulumi.set(__self__, "tool_ids", tool_ids)

    @_builtins.property
    @pulumi.getter
    def toolset(self) -> _builtins.str:
        """
        The resource name of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "toolset")

    @_builtins.property
    @pulumi.getter(name="toolIds")
    def tool_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        The tools IDs to filter the toolset.
        """
        return pulumi.get(self, "tool_ids")


@pulumi.output_type
class AppAudioProcessingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ambientSoundConfig":
            suggest = "ambient_sound_config"
        elif key == "bargeInConfig":
            suggest = "barge_in_config"
        elif key == "inactivityTimeout":
            suggest = "inactivity_timeout"
        elif key == "synthesizeSpeechConfigs":
            suggest = "synthesize_speech_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppAudioProcessingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppAudioProcessingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppAudioProcessingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ambient_sound_config: Optional['outputs.AppAudioProcessingConfigAmbientSoundConfig'] = None,
                 barge_in_config: Optional['outputs.AppAudioProcessingConfigBargeInConfig'] = None,
                 inactivity_timeout: Optional[_builtins.str] = None,
                 synthesize_speech_configs: Optional[Sequence['outputs.AppAudioProcessingConfigSynthesizeSpeechConfig']] = None):
        """
        :param 'AppAudioProcessingConfigAmbientSoundConfigArgs' ambient_sound_config: Configuration for the ambient sound to be played with the synthesized agent
               response, to enhance the naturalness of the conversation.
               Structure is documented below.
        :param 'AppAudioProcessingConfigBargeInConfigArgs' barge_in_config: Configuration for how the user barge-in activities should be handled.
               Structure is documented below.
        :param _builtins.str inactivity_timeout: The duration of user inactivity (no speech or interaction) before the agent
               prompts the user for reengagement. If not set, the agent will not prompt
               the user for reengagement.
        :param Sequence['AppAudioProcessingConfigSynthesizeSpeechConfigArgs'] synthesize_speech_configs: Configuration of how the agent response should be synthesized, mapping from
               the language code to SynthesizeSpeechConfig.
               If the configuration for the specified language code is not found, the
               configuration for the root language code will be used. For example, if the
               map contains "en-us" and "en", and the specified language code is "en-gb",
               then "en" configuration will be used.
               Note: Language code is case-insensitive.
               Structure is documented below.
        """
        if ambient_sound_config is not None:
            pulumi.set(__self__, "ambient_sound_config", ambient_sound_config)
        if barge_in_config is not None:
            pulumi.set(__self__, "barge_in_config", barge_in_config)
        if inactivity_timeout is not None:
            pulumi.set(__self__, "inactivity_timeout", inactivity_timeout)
        if synthesize_speech_configs is not None:
            pulumi.set(__self__, "synthesize_speech_configs", synthesize_speech_configs)

    @_builtins.property
    @pulumi.getter(name="ambientSoundConfig")
    def ambient_sound_config(self) -> Optional['outputs.AppAudioProcessingConfigAmbientSoundConfig']:
        """
        Configuration for the ambient sound to be played with the synthesized agent
        response, to enhance the naturalness of the conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "ambient_sound_config")

    @_builtins.property
    @pulumi.getter(name="bargeInConfig")
    def barge_in_config(self) -> Optional['outputs.AppAudioProcessingConfigBargeInConfig']:
        """
        Configuration for how the user barge-in activities should be handled.
        Structure is documented below.
        """
        return pulumi.get(self, "barge_in_config")

    @_builtins.property
    @pulumi.getter(name="inactivityTimeout")
    def inactivity_timeout(self) -> Optional[_builtins.str]:
        """
        The duration of user inactivity (no speech or interaction) before the agent
        prompts the user for reengagement. If not set, the agent will not prompt
        the user for reengagement.
        """
        return pulumi.get(self, "inactivity_timeout")

    @_builtins.property
    @pulumi.getter(name="synthesizeSpeechConfigs")
    def synthesize_speech_configs(self) -> Optional[Sequence['outputs.AppAudioProcessingConfigSynthesizeSpeechConfig']]:
        """
        Configuration of how the agent response should be synthesized, mapping from
        the language code to SynthesizeSpeechConfig.
        If the configuration for the specified language code is not found, the
        configuration for the root language code will be used. For example, if the
        map contains "en-us" and "en", and the specified language code is "en-gb",
        then "en" configuration will be used.
        Note: Language code is case-insensitive.
        Structure is documented below.
        """
        return pulumi.get(self, "synthesize_speech_configs")


@pulumi.output_type
class AppAudioProcessingConfigAmbientSoundConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gcsUri":
            suggest = "gcs_uri"
        elif key == "prebuiltAmbientSound":
            suggest = "prebuilt_ambient_sound"
        elif key == "volumeGainDb":
            suggest = "volume_gain_db"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppAudioProcessingConfigAmbientSoundConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppAudioProcessingConfigAmbientSoundConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppAudioProcessingConfigAmbientSoundConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gcs_uri: Optional[_builtins.str] = None,
                 prebuilt_ambient_sound: Optional[_builtins.str] = None,
                 volume_gain_db: Optional[_builtins.float] = None):
        """
        :param _builtins.str gcs_uri: Ambient noise as a mono-channel, 16kHz WAV file stored in [Cloud
               Storage](https://cloud.google.com/storage).
               Note: Please make sure the CES service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com` has
               `storage.objects.get` permission to the Cloud Storage object.
        :param _builtins.str prebuilt_ambient_sound: Name of the prebuilt ambient sound.
               Valid values are: - "coffee_shop" - "keyboard" - "keypad" - "hum"
               -"office_1" - "office_2" - "office_3"
               -"room_1" - "room_2" - "room_3"
               -"room_4" - "room_5" - "air_conditioner"
        :param _builtins.float volume_gain_db: Volume gain (in dB) of the normal native volume supported by
               ambient noise, in the range [-96.0, 16.0]. If unset, or set to a value of
               0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
               will play at approximately half the amplitude of the normal native signal
               amplitude. A value of +6.0 (dB) will play at approximately twice the
               amplitude of the normal native signal amplitude. We strongly recommend not
               to exceed +10 (dB) as there's usually no effective increase in loudness for
               any value greater than that.
        """
        if gcs_uri is not None:
            pulumi.set(__self__, "gcs_uri", gcs_uri)
        if prebuilt_ambient_sound is not None:
            pulumi.set(__self__, "prebuilt_ambient_sound", prebuilt_ambient_sound)
        if volume_gain_db is not None:
            pulumi.set(__self__, "volume_gain_db", volume_gain_db)

    @_builtins.property
    @pulumi.getter(name="gcsUri")
    def gcs_uri(self) -> Optional[_builtins.str]:
        """
        Ambient noise as a mono-channel, 16kHz WAV file stored in [Cloud
        Storage](https://cloud.google.com/storage).
        Note: Please make sure the CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com` has
        `storage.objects.get` permission to the Cloud Storage object.
        """
        return pulumi.get(self, "gcs_uri")

    @_builtins.property
    @pulumi.getter(name="prebuiltAmbientSound")
    def prebuilt_ambient_sound(self) -> Optional[_builtins.str]:
        """
        Name of the prebuilt ambient sound.
        Valid values are: - "coffee_shop" - "keyboard" - "keypad" - "hum"
        -"office_1" - "office_2" - "office_3"
        -"room_1" - "room_2" - "room_3"
        -"room_4" - "room_5" - "air_conditioner"
        """
        return pulumi.get(self, "prebuilt_ambient_sound")

    @_builtins.property
    @pulumi.getter(name="volumeGainDb")
    def volume_gain_db(self) -> Optional[_builtins.float]:
        """
        Volume gain (in dB) of the normal native volume supported by
        ambient noise, in the range [-96.0, 16.0]. If unset, or set to a value of
        0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
        will play at approximately half the amplitude of the normal native signal
        amplitude. A value of +6.0 (dB) will play at approximately twice the
        amplitude of the normal native signal amplitude. We strongly recommend not
        to exceed +10 (dB) as there's usually no effective increase in loudness for
        any value greater than that.
        """
        return pulumi.get(self, "volume_gain_db")


@pulumi.output_type
class AppAudioProcessingConfigBargeInConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bargeInAwareness":
            suggest = "barge_in_awareness"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppAudioProcessingConfigBargeInConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppAudioProcessingConfigBargeInConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppAudioProcessingConfigBargeInConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 barge_in_awareness: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool barge_in_awareness: If enabled, the agent will adapt its next response based on the assumption
               that the user hasn't heard the full preceding agent message.
               This should not be used in scenarios where agent responses are displayed
               visually.
        """
        if barge_in_awareness is not None:
            pulumi.set(__self__, "barge_in_awareness", barge_in_awareness)

    @_builtins.property
    @pulumi.getter(name="bargeInAwareness")
    def barge_in_awareness(self) -> Optional[_builtins.bool]:
        """
        If enabled, the agent will adapt its next response based on the assumption
        that the user hasn't heard the full preceding agent message.
        This should not be used in scenarios where agent responses are displayed
        visually.
        """
        return pulumi.get(self, "barge_in_awareness")


@pulumi.output_type
class AppAudioProcessingConfigSynthesizeSpeechConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "languageCode":
            suggest = "language_code"
        elif key == "speakingRate":
            suggest = "speaking_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppAudioProcessingConfigSynthesizeSpeechConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppAudioProcessingConfigSynthesizeSpeechConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppAudioProcessingConfigSynthesizeSpeechConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 language_code: _builtins.str,
                 speaking_rate: Optional[_builtins.float] = None,
                 voice: Optional[_builtins.str] = None):
        """
        :param _builtins.str language_code: The identifier for this object. Format specified above.
        :param _builtins.float speaking_rate: The speaking rate/speed in the range [0.25, 2.0]. 1.0 is the normal native
               speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is
               half as fast. Values outside of the range [0.25, 2.0] will return an error.
        :param _builtins.str voice: The name of the voice. If not set, the service will choose a
               voice based on the other parameters such as language_code.
               For the list of available voices, please refer to Supported voices and
               languages from Cloud Text-to-Speech.
        """
        pulumi.set(__self__, "language_code", language_code)
        if speaking_rate is not None:
            pulumi.set(__self__, "speaking_rate", speaking_rate)
        if voice is not None:
            pulumi.set(__self__, "voice", voice)

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "language_code")

    @_builtins.property
    @pulumi.getter(name="speakingRate")
    def speaking_rate(self) -> Optional[_builtins.float]:
        """
        The speaking rate/speed in the range [0.25, 2.0]. 1.0 is the normal native
        speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is
        half as fast. Values outside of the range [0.25, 2.0] will return an error.
        """
        return pulumi.get(self, "speaking_rate")

    @_builtins.property
    @pulumi.getter
    def voice(self) -> Optional[_builtins.str]:
        """
        The name of the voice. If not set, the service will choose a
        voice based on the other parameters such as language_code.
        For the list of available voices, please refer to Supported voices and
        languages from Cloud Text-to-Speech.
        """
        return pulumi.get(self, "voice")


@pulumi.output_type
class AppClientCertificateSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKey":
            suggest = "private_key"
        elif key == "tlsCertificate":
            suggest = "tls_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppClientCertificateSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppClientCertificateSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppClientCertificateSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_key: _builtins.str,
                 tls_certificate: _builtins.str,
                 passphrase: Optional[_builtins.str] = None):
        """
        :param _builtins.str private_key: The name of the SecretManager secret version resource
               storing the private key encoded in PEM format.
               Format: projects/{project}/secrets/{secret}/versions/{version}
        :param _builtins.str tls_certificate: The TLS certificate encoded in PEM format.
               This string must include the begin header and end footer lines.
        :param _builtins.str passphrase: The passphrase to decrypt the private key.
               Should be left unset if the private key is not encrypted.
        """
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "tls_certificate", tls_certificate)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> _builtins.str:
        """
        The name of the SecretManager secret version resource
        storing the private key encoded in PEM format.
        Format: projects/{project}/secrets/{secret}/versions/{version}
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="tlsCertificate")
    def tls_certificate(self) -> _builtins.str:
        """
        The TLS certificate encoded in PEM format.
        This string must include the begin header and end footer lines.
        """
        return pulumi.get(self, "tls_certificate")

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[_builtins.str]:
        """
        The passphrase to decrypt the private key.
        Should be left unset if the private key is not encrypted.
        """
        return pulumi.get(self, "passphrase")


@pulumi.output_type
class AppDataStoreSettings(dict):
    def __init__(__self__, *,
                 engines: Optional[Sequence['outputs.AppDataStoreSettingsEngine']] = None):
        """
        :param Sequence['AppDataStoreSettingsEngineArgs'] engines: (Output)
               The engines for the app.
               Structure is documented below.
               
               
               <a name="nested_data_store_settings_engines"></a>The `engines` block contains:
        """
        if engines is not None:
            pulumi.set(__self__, "engines", engines)

    @_builtins.property
    @pulumi.getter
    def engines(self) -> Optional[Sequence['outputs.AppDataStoreSettingsEngine']]:
        """
        (Output)
        The engines for the app.
        Structure is documented below.


        <a name="nested_data_store_settings_engines"></a>The `engines` block contains:
        """
        return pulumi.get(self, "engines")


@pulumi.output_type
class AppDataStoreSettingsEngine(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Identifier. The unique identifier of the app.
               Format: `projects/{project}/locations/{location}/apps/{app}`
        :param _builtins.str type: The type of the engine.
               Possible values:
               ENGINE_TYPE_SEARCH
               ENGINE_TYPE_CHAT
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Identifier. The unique identifier of the app.
        Format: `projects/{project}/locations/{location}/apps/{app}`
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of the engine.
        Possible values:
        ENGINE_TYPE_SEARCH
        ENGINE_TYPE_CHAT
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AppDefaultChannelProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelType":
            suggest = "channel_type"
        elif key == "disableBargeInControl":
            suggest = "disable_barge_in_control"
        elif key == "disableDtmf":
            suggest = "disable_dtmf"
        elif key == "personaProperty":
            suggest = "persona_property"
        elif key == "profileId":
            suggest = "profile_id"
        elif key == "webWidgetConfig":
            suggest = "web_widget_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppDefaultChannelProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppDefaultChannelProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppDefaultChannelProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_type: Optional[_builtins.str] = None,
                 disable_barge_in_control: Optional[_builtins.bool] = None,
                 disable_dtmf: Optional[_builtins.bool] = None,
                 persona_property: Optional['outputs.AppDefaultChannelProfilePersonaProperty'] = None,
                 profile_id: Optional[_builtins.str] = None,
                 web_widget_config: Optional['outputs.AppDefaultChannelProfileWebWidgetConfig'] = None):
        """
        :param _builtins.str channel_type: The type of the channel profile.
               Possible values:
               UNKNOWN
               WEB_UI
               API
               TWILIO
               GOOGLE_TELEPHONY_PLATFORM
               CONTACT_CENTER_AS_A_SERVICE
        :param _builtins.bool disable_barge_in_control: Whether to disable user barge-in in the conversation.
               - true: User interruptions are disabled while the agent is speaking.
               - false: The agent retains automatic control over when the user can interrupt.
        :param _builtins.bool disable_dtmf: Whether to disable DTMF (dual-tone multi-frequency).
        :param 'AppDefaultChannelProfilePersonaPropertyArgs' persona_property: Represents the persona property of a channel.
               Structure is documented below.
        :param _builtins.str profile_id: The unique identifier of the channel profile.
        :param 'AppDefaultChannelProfileWebWidgetConfigArgs' web_widget_config: Message for configuration for the web widget.
               Structure is documented below.
        """
        if channel_type is not None:
            pulumi.set(__self__, "channel_type", channel_type)
        if disable_barge_in_control is not None:
            pulumi.set(__self__, "disable_barge_in_control", disable_barge_in_control)
        if disable_dtmf is not None:
            pulumi.set(__self__, "disable_dtmf", disable_dtmf)
        if persona_property is not None:
            pulumi.set(__self__, "persona_property", persona_property)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if web_widget_config is not None:
            pulumi.set(__self__, "web_widget_config", web_widget_config)

    @_builtins.property
    @pulumi.getter(name="channelType")
    def channel_type(self) -> Optional[_builtins.str]:
        """
        The type of the channel profile.
        Possible values:
        UNKNOWN
        WEB_UI
        API
        TWILIO
        GOOGLE_TELEPHONY_PLATFORM
        CONTACT_CENTER_AS_A_SERVICE
        """
        return pulumi.get(self, "channel_type")

    @_builtins.property
    @pulumi.getter(name="disableBargeInControl")
    def disable_barge_in_control(self) -> Optional[_builtins.bool]:
        """
        Whether to disable user barge-in in the conversation.
        - true: User interruptions are disabled while the agent is speaking.
        - false: The agent retains automatic control over when the user can interrupt.
        """
        return pulumi.get(self, "disable_barge_in_control")

    @_builtins.property
    @pulumi.getter(name="disableDtmf")
    def disable_dtmf(self) -> Optional[_builtins.bool]:
        """
        Whether to disable DTMF (dual-tone multi-frequency).
        """
        return pulumi.get(self, "disable_dtmf")

    @_builtins.property
    @pulumi.getter(name="personaProperty")
    def persona_property(self) -> Optional['outputs.AppDefaultChannelProfilePersonaProperty']:
        """
        Represents the persona property of a channel.
        Structure is documented below.
        """
        return pulumi.get(self, "persona_property")

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[_builtins.str]:
        """
        The unique identifier of the channel profile.
        """
        return pulumi.get(self, "profile_id")

    @_builtins.property
    @pulumi.getter(name="webWidgetConfig")
    def web_widget_config(self) -> Optional['outputs.AppDefaultChannelProfileWebWidgetConfig']:
        """
        Message for configuration for the web widget.
        Structure is documented below.
        """
        return pulumi.get(self, "web_widget_config")


@pulumi.output_type
class AppDefaultChannelProfilePersonaProperty(dict):
    def __init__(__self__, *,
                 persona: Optional[_builtins.str] = None):
        """
        :param _builtins.str persona: The persona of the channel.
               Possible values:
               UNKNOWN
               CONCISE
               CHATTY
        """
        if persona is not None:
            pulumi.set(__self__, "persona", persona)

    @_builtins.property
    @pulumi.getter
    def persona(self) -> Optional[_builtins.str]:
        """
        The persona of the channel.
        Possible values:
        UNKNOWN
        CONCISE
        CHATTY
        """
        return pulumi.get(self, "persona")


@pulumi.output_type
class AppDefaultChannelProfileWebWidgetConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "webWidgetTitle":
            suggest = "web_widget_title"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppDefaultChannelProfileWebWidgetConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppDefaultChannelProfileWebWidgetConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppDefaultChannelProfileWebWidgetConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 modality: Optional[_builtins.str] = None,
                 theme: Optional[_builtins.str] = None,
                 web_widget_title: Optional[_builtins.str] = None):
        """
        :param _builtins.str modality: The modality of the web widget.
               Possible values:
               UNKNOWN_MODALITY
               CHAT_AND_VOICE
               VOICE_ONLY
               CHAT_ONLY
        :param _builtins.str theme: The theme of the web widget.
               Possible values:
               UNKNOWN_THEME
               LIGHT
               DARK
        :param _builtins.str web_widget_title: The title of the web widget.
        """
        if modality is not None:
            pulumi.set(__self__, "modality", modality)
        if theme is not None:
            pulumi.set(__self__, "theme", theme)
        if web_widget_title is not None:
            pulumi.set(__self__, "web_widget_title", web_widget_title)

    @_builtins.property
    @pulumi.getter
    def modality(self) -> Optional[_builtins.str]:
        """
        The modality of the web widget.
        Possible values:
        UNKNOWN_MODALITY
        CHAT_AND_VOICE
        VOICE_ONLY
        CHAT_ONLY
        """
        return pulumi.get(self, "modality")

    @_builtins.property
    @pulumi.getter
    def theme(self) -> Optional[_builtins.str]:
        """
        The theme of the web widget.
        Possible values:
        UNKNOWN_THEME
        LIGHT
        DARK
        """
        return pulumi.get(self, "theme")

    @_builtins.property
    @pulumi.getter(name="webWidgetTitle")
    def web_widget_title(self) -> Optional[_builtins.str]:
        """
        The title of the web widget.
        """
        return pulumi.get(self, "web_widget_title")


@pulumi.output_type
class AppEvaluationMetricsThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "goldenEvaluationMetricsThresholds":
            suggest = "golden_evaluation_metrics_thresholds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppEvaluationMetricsThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppEvaluationMetricsThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppEvaluationMetricsThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 golden_evaluation_metrics_thresholds: Optional['outputs.AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholds'] = None):
        """
        :param 'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgs' golden_evaluation_metrics_thresholds: Settings for golden evaluations.
               Structure is documented below.
        """
        if golden_evaluation_metrics_thresholds is not None:
            pulumi.set(__self__, "golden_evaluation_metrics_thresholds", golden_evaluation_metrics_thresholds)

    @_builtins.property
    @pulumi.getter(name="goldenEvaluationMetricsThresholds")
    def golden_evaluation_metrics_thresholds(self) -> Optional['outputs.AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholds']:
        """
        Settings for golden evaluations.
        Structure is documented below.
        """
        return pulumi.get(self, "golden_evaluation_metrics_thresholds")


@pulumi.output_type
class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectationLevelMetricsThresholds":
            suggest = "expectation_level_metrics_thresholds"
        elif key == "turnLevelMetricsThresholds":
            suggest = "turn_level_metrics_thresholds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expectation_level_metrics_thresholds: Optional['outputs.AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholds'] = None,
                 turn_level_metrics_thresholds: Optional['outputs.AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholds'] = None):
        """
        :param 'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgs' expectation_level_metrics_thresholds: Expectation level metrics thresholds.
               Structure is documented below.
        :param 'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgs' turn_level_metrics_thresholds: Turn level metrics thresholds.
               Structure is documented below.
        """
        if expectation_level_metrics_thresholds is not None:
            pulumi.set(__self__, "expectation_level_metrics_thresholds", expectation_level_metrics_thresholds)
        if turn_level_metrics_thresholds is not None:
            pulumi.set(__self__, "turn_level_metrics_thresholds", turn_level_metrics_thresholds)

    @_builtins.property
    @pulumi.getter(name="expectationLevelMetricsThresholds")
    def expectation_level_metrics_thresholds(self) -> Optional['outputs.AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholds']:
        """
        Expectation level metrics thresholds.
        Structure is documented below.
        """
        return pulumi.get(self, "expectation_level_metrics_thresholds")

    @_builtins.property
    @pulumi.getter(name="turnLevelMetricsThresholds")
    def turn_level_metrics_thresholds(self) -> Optional['outputs.AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholds']:
        """
        Turn level metrics thresholds.
        Structure is documented below.
        """
        return pulumi.get(self, "turn_level_metrics_thresholds")


@pulumi.output_type
class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toolInvocationParameterCorrectnessThreshold":
            suggest = "tool_invocation_parameter_correctness_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tool_invocation_parameter_correctness_threshold: Optional[_builtins.float] = None):
        """
        :param _builtins.float tool_invocation_parameter_correctness_threshold: The success threshold for individual tool invocation parameter
               correctness. Must be a float between 0 and 1. Default is 1.0.
        """
        if tool_invocation_parameter_correctness_threshold is not None:
            pulumi.set(__self__, "tool_invocation_parameter_correctness_threshold", tool_invocation_parameter_correctness_threshold)

    @_builtins.property
    @pulumi.getter(name="toolInvocationParameterCorrectnessThreshold")
    def tool_invocation_parameter_correctness_threshold(self) -> Optional[_builtins.float]:
        """
        The success threshold for individual tool invocation parameter
        correctness. Must be a float between 0 and 1. Default is 1.0.
        """
        return pulumi.get(self, "tool_invocation_parameter_correctness_threshold")


@pulumi.output_type
class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overallToolInvocationCorrectnessThreshold":
            suggest = "overall_tool_invocation_correctness_threshold"
        elif key == "semanticSimilaritySuccessThreshold":
            suggest = "semantic_similarity_success_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 overall_tool_invocation_correctness_threshold: Optional[_builtins.float] = None,
                 semantic_similarity_success_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.float overall_tool_invocation_correctness_threshold: The success threshold for overall tool invocation correctness. Must be
               a float between 0 and 1. Default is 1.0.
        :param _builtins.int semantic_similarity_success_threshold: The success threshold for semantic similarity. Must be an integer
               between 0 and 4. Default is >= 3.
        """
        if overall_tool_invocation_correctness_threshold is not None:
            pulumi.set(__self__, "overall_tool_invocation_correctness_threshold", overall_tool_invocation_correctness_threshold)
        if semantic_similarity_success_threshold is not None:
            pulumi.set(__self__, "semantic_similarity_success_threshold", semantic_similarity_success_threshold)

    @_builtins.property
    @pulumi.getter(name="overallToolInvocationCorrectnessThreshold")
    def overall_tool_invocation_correctness_threshold(self) -> Optional[_builtins.float]:
        """
        The success threshold for overall tool invocation correctness. Must be
        a float between 0 and 1. Default is 1.0.
        """
        return pulumi.get(self, "overall_tool_invocation_correctness_threshold")

    @_builtins.property
    @pulumi.getter(name="semanticSimilaritySuccessThreshold")
    def semantic_similarity_success_threshold(self) -> Optional[_builtins.int]:
        """
        The success threshold for semantic similarity. Must be an integer
        between 0 and 4. Default is >= 3.
        """
        return pulumi.get(self, "semantic_similarity_success_threshold")


@pulumi.output_type
class AppLanguageSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultLanguageCode":
            suggest = "default_language_code"
        elif key == "enableMultilingualSupport":
            suggest = "enable_multilingual_support"
        elif key == "fallbackAction":
            suggest = "fallback_action"
        elif key == "supportedLanguageCodes":
            suggest = "supported_language_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppLanguageSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppLanguageSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppLanguageSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_language_code: Optional[_builtins.str] = None,
                 enable_multilingual_support: Optional[_builtins.bool] = None,
                 fallback_action: Optional[_builtins.str] = None,
                 supported_language_codes: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str default_language_code: The default language code of the app.
        :param _builtins.bool enable_multilingual_support: Enables multilingual support. If true, agents in the app will use pre-built
               instructions to improve handling of multilingual input.
        :param _builtins.str fallback_action: The action to perform when an agent receives input in an unsupported
               language.
               This can be a predefined action or a custom tool call.
               Valid values are:
               - A tool's full resource name, which triggers a specific tool execution.
               - A predefined system action, such as "escalate" or "exit", which triggers
               an EndSession signal with corresponding metadata
               to terminate the conversation.
        :param Sequence[_builtins.str] supported_language_codes: List of languages codes supported by the app, in addition to the
               `default_language_code`.
        """
        if default_language_code is not None:
            pulumi.set(__self__, "default_language_code", default_language_code)
        if enable_multilingual_support is not None:
            pulumi.set(__self__, "enable_multilingual_support", enable_multilingual_support)
        if fallback_action is not None:
            pulumi.set(__self__, "fallback_action", fallback_action)
        if supported_language_codes is not None:
            pulumi.set(__self__, "supported_language_codes", supported_language_codes)

    @_builtins.property
    @pulumi.getter(name="defaultLanguageCode")
    def default_language_code(self) -> Optional[_builtins.str]:
        """
        The default language code of the app.
        """
        return pulumi.get(self, "default_language_code")

    @_builtins.property
    @pulumi.getter(name="enableMultilingualSupport")
    def enable_multilingual_support(self) -> Optional[_builtins.bool]:
        """
        Enables multilingual support. If true, agents in the app will use pre-built
        instructions to improve handling of multilingual input.
        """
        return pulumi.get(self, "enable_multilingual_support")

    @_builtins.property
    @pulumi.getter(name="fallbackAction")
    def fallback_action(self) -> Optional[_builtins.str]:
        """
        The action to perform when an agent receives input in an unsupported
        language.
        This can be a predefined action or a custom tool call.
        Valid values are:
        - A tool's full resource name, which triggers a specific tool execution.
        - A predefined system action, such as "escalate" or "exit", which triggers
        an EndSession signal with corresponding metadata
        to terminate the conversation.
        """
        return pulumi.get(self, "fallback_action")

    @_builtins.property
    @pulumi.getter(name="supportedLanguageCodes")
    def supported_language_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of languages codes supported by the app, in addition to the
        `default_language_code`.
        """
        return pulumi.get(self, "supported_language_codes")


@pulumi.output_type
class AppLoggingSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioRecordingConfig":
            suggest = "audio_recording_config"
        elif key == "bigqueryExportSettings":
            suggest = "bigquery_export_settings"
        elif key == "cloudLoggingSettings":
            suggest = "cloud_logging_settings"
        elif key == "conversationLoggingSettings":
            suggest = "conversation_logging_settings"
        elif key == "redactionConfig":
            suggest = "redaction_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppLoggingSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppLoggingSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppLoggingSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_recording_config: Optional['outputs.AppLoggingSettingsAudioRecordingConfig'] = None,
                 bigquery_export_settings: Optional['outputs.AppLoggingSettingsBigqueryExportSettings'] = None,
                 cloud_logging_settings: Optional['outputs.AppLoggingSettingsCloudLoggingSettings'] = None,
                 conversation_logging_settings: Optional['outputs.AppLoggingSettingsConversationLoggingSettings'] = None,
                 redaction_config: Optional['outputs.AppLoggingSettingsRedactionConfig'] = None):
        """
        :param 'AppLoggingSettingsAudioRecordingConfigArgs' audio_recording_config: Configuration for how the audio interactions should be recorded.
               Structure is documented below.
        :param 'AppLoggingSettingsBigqueryExportSettingsArgs' bigquery_export_settings: Settings to describe the BigQuery export behaviors for the app.
               Structure is documented below.
        :param 'AppLoggingSettingsCloudLoggingSettingsArgs' cloud_logging_settings: Settings to describe the Cloud Logging behaviors for the app.
               Structure is documented below.
        :param 'AppLoggingSettingsConversationLoggingSettingsArgs' conversation_logging_settings: Settings to describe the conversation logging behaviors for the app.
               Structure is documented below.
        :param 'AppLoggingSettingsRedactionConfigArgs' redaction_config: Configuration to instruct how sensitive data should be handled.
               Structure is documented below.
        """
        if audio_recording_config is not None:
            pulumi.set(__self__, "audio_recording_config", audio_recording_config)
        if bigquery_export_settings is not None:
            pulumi.set(__self__, "bigquery_export_settings", bigquery_export_settings)
        if cloud_logging_settings is not None:
            pulumi.set(__self__, "cloud_logging_settings", cloud_logging_settings)
        if conversation_logging_settings is not None:
            pulumi.set(__self__, "conversation_logging_settings", conversation_logging_settings)
        if redaction_config is not None:
            pulumi.set(__self__, "redaction_config", redaction_config)

    @_builtins.property
    @pulumi.getter(name="audioRecordingConfig")
    def audio_recording_config(self) -> Optional['outputs.AppLoggingSettingsAudioRecordingConfig']:
        """
        Configuration for how the audio interactions should be recorded.
        Structure is documented below.
        """
        return pulumi.get(self, "audio_recording_config")

    @_builtins.property
    @pulumi.getter(name="bigqueryExportSettings")
    def bigquery_export_settings(self) -> Optional['outputs.AppLoggingSettingsBigqueryExportSettings']:
        """
        Settings to describe the BigQuery export behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "bigquery_export_settings")

    @_builtins.property
    @pulumi.getter(name="cloudLoggingSettings")
    def cloud_logging_settings(self) -> Optional['outputs.AppLoggingSettingsCloudLoggingSettings']:
        """
        Settings to describe the Cloud Logging behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_logging_settings")

    @_builtins.property
    @pulumi.getter(name="conversationLoggingSettings")
    def conversation_logging_settings(self) -> Optional['outputs.AppLoggingSettingsConversationLoggingSettings']:
        """
        Settings to describe the conversation logging behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_logging_settings")

    @_builtins.property
    @pulumi.getter(name="redactionConfig")
    def redaction_config(self) -> Optional['outputs.AppLoggingSettingsRedactionConfig']:
        """
        Configuration to instruct how sensitive data should be handled.
        Structure is documented below.
        """
        return pulumi.get(self, "redaction_config")


@pulumi.output_type
class AppLoggingSettingsAudioRecordingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gcsBucket":
            suggest = "gcs_bucket"
        elif key == "gcsPathPrefix":
            suggest = "gcs_path_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppLoggingSettingsAudioRecordingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppLoggingSettingsAudioRecordingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppLoggingSettingsAudioRecordingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gcs_bucket: Optional[_builtins.str] = None,
                 gcs_path_prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str gcs_bucket: The [Cloud Storage](https://cloud.google.com/storage) bucket to store the
               session audio recordings. The URI must start with "gs://".
               Note: If the Cloud Storage bucket is in a different project from the app,
               you should grant `storage.objects.create` permission to the CES service
               agent `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param _builtins.str gcs_path_prefix: The Cloud Storage path prefix for audio recordings.
               This prefix can include the following placeholders, which will be
               dynamically substituted at serving time:
               - $project:   project ID
               - $location:  app location
               - $app:       app ID
               - $date:      session date in YYYY-MM-DD format
               - $session:   session ID
               If the path prefix is not specified, the default prefix
               `$project/$location/$app/$date/$session/` will be used.
        """
        if gcs_bucket is not None:
            pulumi.set(__self__, "gcs_bucket", gcs_bucket)
        if gcs_path_prefix is not None:
            pulumi.set(__self__, "gcs_path_prefix", gcs_path_prefix)

    @_builtins.property
    @pulumi.getter(name="gcsBucket")
    def gcs_bucket(self) -> Optional[_builtins.str]:
        """
        The [Cloud Storage](https://cloud.google.com/storage) bucket to store the
        session audio recordings. The URI must start with "gs://".
        Note: If the Cloud Storage bucket is in a different project from the app,
        you should grant `storage.objects.create` permission to the CES service
        agent `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "gcs_bucket")

    @_builtins.property
    @pulumi.getter(name="gcsPathPrefix")
    def gcs_path_prefix(self) -> Optional[_builtins.str]:
        """
        The Cloud Storage path prefix for audio recordings.
        This prefix can include the following placeholders, which will be
        dynamically substituted at serving time:
        - $project:   project ID
        - $location:  app location
        - $app:       app ID
        - $date:      session date in YYYY-MM-DD format
        - $session:   session ID
        If the path prefix is not specified, the default prefix
        `$project/$location/$app/$date/$session/` will be used.
        """
        return pulumi.get(self, "gcs_path_prefix")


@pulumi.output_type
class AppLoggingSettingsBigqueryExportSettings(dict):
    def __init__(__self__, *,
                 dataset: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 project: Optional[_builtins.str] = None):
        """
        :param _builtins.str dataset: The BigQuery dataset to export the data to.
        :param _builtins.bool enabled: Indicates whether the BigQuery export is enabled.
        :param _builtins.str project: The project ID of the BigQuery dataset to export the data to.
               Note: If the BigQuery dataset is in a different project from the app, you should grant
               roles/bigquery.admin role to the CES service agent service-<PROJECT-
               NUMBER>@gcp-sa-ces.iam.gserviceaccount.com.
        """
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if project is not None:
            pulumi.set(__self__, "project", project)

    @_builtins.property
    @pulumi.getter
    def dataset(self) -> Optional[_builtins.str]:
        """
        The BigQuery dataset to export the data to.
        """
        return pulumi.get(self, "dataset")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Indicates whether the BigQuery export is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def project(self) -> Optional[_builtins.str]:
        """
        The project ID of the BigQuery dataset to export the data to.
        Note: If the BigQuery dataset is in a different project from the app, you should grant
        roles/bigquery.admin role to the CES service agent service-<PROJECT-
        NUMBER>@gcp-sa-ces.iam.gserviceaccount.com.
        """
        return pulumi.get(self, "project")


@pulumi.output_type
class AppLoggingSettingsCloudLoggingSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableCloudLogging":
            suggest = "enable_cloud_logging"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppLoggingSettingsCloudLoggingSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppLoggingSettingsCloudLoggingSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppLoggingSettingsCloudLoggingSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_cloud_logging: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enable_cloud_logging: Whether to enable Cloud Logging for the sessions.
        """
        if enable_cloud_logging is not None:
            pulumi.set(__self__, "enable_cloud_logging", enable_cloud_logging)

    @_builtins.property
    @pulumi.getter(name="enableCloudLogging")
    def enable_cloud_logging(self) -> Optional[_builtins.bool]:
        """
        Whether to enable Cloud Logging for the sessions.
        """
        return pulumi.get(self, "enable_cloud_logging")


@pulumi.output_type
class AppLoggingSettingsConversationLoggingSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableConversationLogging":
            suggest = "disable_conversation_logging"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppLoggingSettingsConversationLoggingSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppLoggingSettingsConversationLoggingSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppLoggingSettingsConversationLoggingSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_conversation_logging: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool disable_conversation_logging: Whether to disable conversation logging for the sessions.
        """
        if disable_conversation_logging is not None:
            pulumi.set(__self__, "disable_conversation_logging", disable_conversation_logging)

    @_builtins.property
    @pulumi.getter(name="disableConversationLogging")
    def disable_conversation_logging(self) -> Optional[_builtins.bool]:
        """
        Whether to disable conversation logging for the sessions.
        """
        return pulumi.get(self, "disable_conversation_logging")


@pulumi.output_type
class AppLoggingSettingsRedactionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deidentifyTemplate":
            suggest = "deidentify_template"
        elif key == "enableRedaction":
            suggest = "enable_redaction"
        elif key == "inspectTemplate":
            suggest = "inspect_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppLoggingSettingsRedactionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppLoggingSettingsRedactionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppLoggingSettingsRedactionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deidentify_template: Optional[_builtins.str] = None,
                 enable_redaction: Optional[_builtins.bool] = None,
                 inspect_template: Optional[_builtins.str] = None):
        """
        :param _builtins.str deidentify_template: [DLP](https://cloud.google.com/dlp/docs) deidentify template name to
               instruct on how to de-identify content.
               Format:
               `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
        :param _builtins.bool enable_redaction: If true, redaction will be applied in various logging scenarios, including
               conversation history, Cloud Logging and audio recording.
        :param _builtins.str inspect_template: [DLP](https://cloud.google.com/dlp/docs) inspect template name to configure
               detection of sensitive data types.
               Format:
               `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
        """
        if deidentify_template is not None:
            pulumi.set(__self__, "deidentify_template", deidentify_template)
        if enable_redaction is not None:
            pulumi.set(__self__, "enable_redaction", enable_redaction)
        if inspect_template is not None:
            pulumi.set(__self__, "inspect_template", inspect_template)

    @_builtins.property
    @pulumi.getter(name="deidentifyTemplate")
    def deidentify_template(self) -> Optional[_builtins.str]:
        """
        [DLP](https://cloud.google.com/dlp/docs) deidentify template name to
        instruct on how to de-identify content.
        Format:
        `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
        """
        return pulumi.get(self, "deidentify_template")

    @_builtins.property
    @pulumi.getter(name="enableRedaction")
    def enable_redaction(self) -> Optional[_builtins.bool]:
        """
        If true, redaction will be applied in various logging scenarios, including
        conversation history, Cloud Logging and audio recording.
        """
        return pulumi.get(self, "enable_redaction")

    @_builtins.property
    @pulumi.getter(name="inspectTemplate")
    def inspect_template(self) -> Optional[_builtins.str]:
        """
        [DLP](https://cloud.google.com/dlp/docs) inspect template name to configure
        detection of sensitive data types.
        Format:
        `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
        """
        return pulumi.get(self, "inspect_template")


@pulumi.output_type
class AppModelSettings(dict):
    def __init__(__self__, *,
                 model: Optional[_builtins.str] = None,
                 temperature: Optional[_builtins.float] = None):
        """
        :param _builtins.str model: The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param _builtins.float temperature: If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")


@pulumi.output_type
class AppTimeZoneSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppTimeZoneSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppTimeZoneSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppTimeZoneSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_zone: Optional[_builtins.str] = None):
        """
        :param _builtins.str time_zone: The time zone of the app from the time zone database, e.g., America/Los_Angeles, Europe/Paris.
        """
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[_builtins.str]:
        """
        The time zone of the app from the time zone database, e.g., America/Los_Angeles, Europe/Paris.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class AppVariableDeclaration(dict):
    def __init__(__self__, *,
                 description: _builtins.str,
                 name: _builtins.str,
                 schema: 'outputs.AppVariableDeclarationSchema'):
        """
        :param _builtins.str description: The description of the variable.
        :param _builtins.str name: The name of the variable. The name must start with a letter or underscore
               and contain only letters, numbers, or underscores.
        :param 'AppVariableDeclarationSchemaArgs' schema: Represents a select subset of an OpenAPI 3.0 schema object.
               Structure is documented below.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema", schema)

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        The description of the variable.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the variable. The name must start with a letter or underscore
        and contain only letters, numbers, or underscores.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def schema(self) -> 'outputs.AppVariableDeclarationSchema':
        """
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        return pulumi.get(self, "schema")


@pulumi.output_type
class AppVariableDeclarationSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalProperties":
            suggest = "additional_properties"
        elif key == "anyOf":
            suggest = "any_of"
        elif key == "prefixItems":
            suggest = "prefix_items"
        elif key == "uniqueItems":
            suggest = "unique_items"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVariableDeclarationSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVariableDeclarationSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVariableDeclarationSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 additional_properties: Optional[_builtins.str] = None,
                 any_of: Optional[_builtins.str] = None,
                 default: Optional[_builtins.str] = None,
                 defs: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 enums: Optional[Sequence[_builtins.str]] = None,
                 items: Optional[_builtins.str] = None,
                 nullable: Optional[_builtins.bool] = None,
                 prefix_items: Optional[_builtins.str] = None,
                 properties: Optional[_builtins.str] = None,
                 ref: Optional[_builtins.str] = None,
                 requireds: Optional[Sequence[_builtins.str]] = None,
                 title: Optional[_builtins.str] = None,
                 unique_items: Optional[_builtins.bool] = None):
        """
        :param _builtins.str type: The type of the data.
               Possible values:
               STRING
               INTEGER
               NUMBER
               BOOLEAN
               OBJECT
               ARRAY
        :param _builtins.str additional_properties: Optional. Defines the schema for additional properties allowed in an object.
               The value must be a valid JSON string representing the Schema object.
               (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        :param _builtins.str any_of: Optional. The instance value should be valid against at least one of the schemas in this list.
        :param _builtins.str default: Optional. Default value of the data. Represents a dynamically typed value
               which can be either null, a number, a string, a boolean, a struct,
               or a list of values. The provided default value must be compatible
               with the defined 'type' and other schema constraints.
        :param _builtins.str defs: A map of definitions for use by ref. Only allowed at the root of the schema.
        :param _builtins.str description: The description of the data.
        :param Sequence[_builtins.str] enums: Possible values of the element of primitive type with enum format.
               Examples:
               1. We can define direction as :
               {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
               2. We can define apartment number as :
               {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        :param _builtins.str items: Schema of the elements of Type.ARRAY.
        :param _builtins.bool nullable: Indicates if the value may be null.
        :param _builtins.str prefix_items: Optional. Schemas of initial elements of Type.ARRAY.
        :param _builtins.str properties: Properties of Type.OBJECT.
        :param _builtins.str ref: Allows indirect references between schema nodes. The value should be a
               valid reference to a child of the root `defs`.
               For example, the following schema defines a reference to a schema node
               named "Pet":
               type: object
               properties:
               pet:
               ref: #/defs/Pet
               defs:
               Pet:
               type: object
               properties:
               name:
               type: string
               The value of the "pet" property is a reference to the schema node
               named "Pet".
               See details in
               https://json-schema.org/understanding-json-schema/structuring.
        :param Sequence[_builtins.str] requireds: Required properties of Type.OBJECT.
        :param _builtins.str title: The title of the schema.
        :param _builtins.bool unique_items: Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        pulumi.set(__self__, "type", type)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if any_of is not None:
            pulumi.set(__self__, "any_of", any_of)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if defs is not None:
            pulumi.set(__self__, "defs", defs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enums is not None:
            pulumi.set(__self__, "enums", enums)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if prefix_items is not None:
            pulumi.set(__self__, "prefix_items", prefix_items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if requireds is not None:
            pulumi.set(__self__, "requireds", requireds)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the data.
        Possible values:
        STRING
        INTEGER
        NUMBER
        BOOLEAN
        OBJECT
        ARRAY
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[_builtins.str]:
        """
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        return pulumi.get(self, "additional_properties")

    @_builtins.property
    @pulumi.getter(name="anyOf")
    def any_of(self) -> Optional[_builtins.str]:
        """
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        return pulumi.get(self, "any_of")

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        """
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def defs(self) -> Optional[_builtins.str]:
        """
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        return pulumi.get(self, "defs")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the data.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def enums(self) -> Optional[Sequence[_builtins.str]]:
        """
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        return pulumi.get(self, "enums")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[_builtins.str]:
        """
        Schema of the elements of Type.ARRAY.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        Indicates if the value may be null.
        """
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="prefixItems")
    def prefix_items(self) -> Optional[_builtins.str]:
        """
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        return pulumi.get(self, "prefix_items")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[_builtins.str]:
        """
        Properties of Type.OBJECT.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[_builtins.str]:
        """
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        return pulumi.get(self, "ref")

    @_builtins.property
    @pulumi.getter
    def requireds(self) -> Optional[Sequence[_builtins.str]]:
        """
        Required properties of Type.OBJECT.
        """
        return pulumi.get(self, "requireds")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        The title of the schema.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[_builtins.bool]:
        """
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        return pulumi.get(self, "unique_items")


@pulumi.output_type
class AppVersionSnapshot(dict):
    def __init__(__self__, *,
                 agents: Optional[Sequence['outputs.AppVersionSnapshotAgent']] = None,
                 apps: Optional[Sequence['outputs.AppVersionSnapshotApp']] = None,
                 examples: Optional[Sequence['outputs.AppVersionSnapshotExample']] = None,
                 guardrails: Optional[Sequence['outputs.AppVersionSnapshotGuardrail']] = None,
                 tools: Optional[Sequence['outputs.AppVersionSnapshotTool']] = None,
                 toolsets: Optional[Sequence['outputs.AppVersionSnapshotToolset']] = None):
        """
        :param Sequence['AppVersionSnapshotAgentArgs'] agents: (Output)
               List of agents in the app.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotAppArgs'] apps: Resource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122.
        :param Sequence['AppVersionSnapshotExampleArgs'] examples: (Output)
               List of examples in the app.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotGuardrailArgs'] guardrails: (Output)
               List of guardrails for the app.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
        :param Sequence['AppVersionSnapshotToolArgs'] tools: (Output)
               List of available tools for the agent.
               Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        :param Sequence['AppVersionSnapshotToolsetArgs'] toolsets: (Output)
               List of toolsets for the agent.
               Structure is documented below.
        """
        if agents is not None:
            pulumi.set(__self__, "agents", agents)
        if apps is not None:
            pulumi.set(__self__, "apps", apps)
        if examples is not None:
            pulumi.set(__self__, "examples", examples)
        if guardrails is not None:
            pulumi.set(__self__, "guardrails", guardrails)
        if tools is not None:
            pulumi.set(__self__, "tools", tools)
        if toolsets is not None:
            pulumi.set(__self__, "toolsets", toolsets)

    @_builtins.property
    @pulumi.getter
    def agents(self) -> Optional[Sequence['outputs.AppVersionSnapshotAgent']]:
        """
        (Output)
        List of agents in the app.
        Structure is documented below.
        """
        return pulumi.get(self, "agents")

    @_builtins.property
    @pulumi.getter
    def apps(self) -> Optional[Sequence['outputs.AppVersionSnapshotApp']]:
        """
        Resource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122.
        """
        return pulumi.get(self, "apps")

    @_builtins.property
    @pulumi.getter
    def examples(self) -> Optional[Sequence['outputs.AppVersionSnapshotExample']]:
        """
        (Output)
        List of examples in the app.
        Structure is documented below.
        """
        return pulumi.get(self, "examples")

    @_builtins.property
    @pulumi.getter
    def guardrails(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrail']]:
        """
        (Output)
        List of guardrails for the app.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
        """
        return pulumi.get(self, "guardrails")

    @_builtins.property
    @pulumi.getter
    def tools(self) -> Optional[Sequence['outputs.AppVersionSnapshotTool']]:
        """
        (Output)
        List of available tools for the agent.
        Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        """
        return pulumi.get(self, "tools")

    @_builtins.property
    @pulumi.getter
    def toolsets(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolset']]:
        """
        (Output)
        List of toolsets for the agent.
        Structure is documented below.
        """
        return pulumi.get(self, "toolsets")


@pulumi.output_type
class AppVersionSnapshotAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "afterAgentCallbacks":
            suggest = "after_agent_callbacks"
        elif key == "afterModelCallbacks":
            suggest = "after_model_callbacks"
        elif key == "afterToolCallbacks":
            suggest = "after_tool_callbacks"
        elif key == "beforeAgentCallbacks":
            suggest = "before_agent_callbacks"
        elif key == "beforeModelCallbacks":
            suggest = "before_model_callbacks"
        elif key == "beforeToolCallbacks":
            suggest = "before_tool_callbacks"
        elif key == "childAgents":
            suggest = "child_agents"
        elif key == "createTime":
            suggest = "create_time"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "generatedSummary":
            suggest = "generated_summary"
        elif key == "llmAgents":
            suggest = "llm_agents"
        elif key == "modelSettings":
            suggest = "model_settings"
        elif key == "remoteDialogflowAgents":
            suggest = "remote_dialogflow_agents"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 after_agent_callbacks: Optional[Sequence['outputs.AppVersionSnapshotAgentAfterAgentCallback']] = None,
                 after_model_callbacks: Optional[Sequence['outputs.AppVersionSnapshotAgentAfterModelCallback']] = None,
                 after_tool_callbacks: Optional[Sequence['outputs.AppVersionSnapshotAgentAfterToolCallback']] = None,
                 before_agent_callbacks: Optional[Sequence['outputs.AppVersionSnapshotAgentBeforeAgentCallback']] = None,
                 before_model_callbacks: Optional[Sequence['outputs.AppVersionSnapshotAgentBeforeModelCallback']] = None,
                 before_tool_callbacks: Optional[Sequence['outputs.AppVersionSnapshotAgentBeforeToolCallback']] = None,
                 child_agents: Optional[Sequence[_builtins.str]] = None,
                 create_time: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 etag: Optional[_builtins.str] = None,
                 generated_summary: Optional[_builtins.str] = None,
                 guardrails: Optional[Sequence[_builtins.str]] = None,
                 instruction: Optional[_builtins.str] = None,
                 llm_agents: Optional[Sequence['outputs.AppVersionSnapshotAgentLlmAgent']] = None,
                 model_settings: Optional[Sequence['outputs.AppVersionSnapshotAgentModelSetting']] = None,
                 name: Optional[_builtins.str] = None,
                 remote_dialogflow_agents: Optional[Sequence['outputs.AppVersionSnapshotAgentRemoteDialogflowAgent']] = None,
                 tools: Optional[Sequence[_builtins.str]] = None,
                 toolsets: Optional[Sequence['outputs.AppVersionSnapshotAgentToolset']] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param Sequence['AppVersionSnapshotAgentAfterAgentCallbackArgs'] after_agent_callbacks: (Output)
               The callbacks to execute after the agent is called.
               The provided callbacks are executed sequentially in the exact order they
               are given in the list. If a callback returns an overridden response,
               execution stops and any remaining callbacks are skipped.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotAgentAfterModelCallbackArgs'] after_model_callbacks: (Output)
               The callbacks to execute after the model is called. If there are multiple
               calls to the model, the callback will be executed multiple times.
               The provided callbacks are executed sequentially in the exact order they
               are given in the list. If a callback returns an overridden response,
               execution stops and any remaining callbacks are skipped.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotAgentAfterToolCallbackArgs'] after_tool_callbacks: (Output)
               The callbacks to execute after the tool is invoked. If there are multiple
               tool invocations, the callback will be executed multiple times.
               The provided callbacks are executed sequentially in the exact order they
               are given in the list. If a callback returns an overridden response,
               execution stops and any remaining callbacks are skipped.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotAgentBeforeAgentCallbackArgs'] before_agent_callbacks: (Output)
               The callbacks to execute before the agent is called.
               The provided callbacks are executed sequentially in the exact order they
               are given in the list. If a callback returns an overridden response,
               execution stops and any remaining callbacks are skipped.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotAgentBeforeModelCallbackArgs'] before_model_callbacks: (Output)
               The callbacks to execute before the model is called. If there are multiple
               calls to the model, the callback will be executed multiple times.
               The provided callbacks are executed sequentially in the exact order they
               are given in the list. If a callback returns an overridden response,
               execution stops and any remaining callbacks are skipped.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotAgentBeforeToolCallbackArgs'] before_tool_callbacks: (Output)
               The callbacks to execute before the tool is invoked. If there are multiple
               tool invocations, the callback will be executed multiple times.
               The provided callbacks are executed sequentially in the exact order they
               are given in the list. If a callback returns an overridden response,
               execution stops and any remaining callbacks are skipped.
               Structure is documented below.
        :param Sequence[_builtins.str] child_agents: (Output)
               List of child agents in the agent tree.
               Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        :param _builtins.str create_time: (Output)
               Timestamp when the toolset was created.
        :param _builtins.str description: The description of the app version.
        :param _builtins.str display_name: The display name of the app version.
        :param _builtins.str etag: (Output)
               ETag used to ensure the object hasn't changed during a read-modify-write
               operation. If the etag is empty, the update will overwrite any concurrent
               changes.
        :param _builtins.str generated_summary: (Output)
               If the tool is generated by the LLM assistant, this field contains a
               descriptive summary of the generation.
        :param Sequence[_builtins.str] guardrails: (Output)
               List of guardrails for the app.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
        :param _builtins.str instruction: (Output)
               Instructions for the LLM model to guide the agent's behavior.
        :param Sequence['AppVersionSnapshotAgentLlmAgentArgs'] llm_agents: (Output)
               Default agent type. The agent uses instructions and callbacks specified in
               the agent to perform the task using a large language model.
        :param Sequence['AppVersionSnapshotAgentModelSettingArgs'] model_settings: (Output)
               Model settings contains various configurations for the LLM model.
               Structure is documented below.
        :param _builtins.str name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param Sequence['AppVersionSnapshotAgentRemoteDialogflowAgentArgs'] remote_dialogflow_agents: (Output)
               The agent which will transfer execution to an existing remote
               [Dialogflow](https://cloud.google.com/dialogflow/cx/docs/concept/console-conversational-agents)
               agent flow. The corresponding Dialogflow agent will process subsequent user
               queries until the session ends or flow ends and the control is transferred
               back to the parent CES agent.
               Structure is documented below.
        :param Sequence[_builtins.str] tools: (Output)
               List of available tools for the agent.
               Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        :param Sequence['AppVersionSnapshotAgentToolsetArgs'] toolsets: (Output)
               List of toolsets for the agent.
               Structure is documented below.
        :param _builtins.str update_time: (Output)
               Timestamp when the toolset was last updated.
        """
        if after_agent_callbacks is not None:
            pulumi.set(__self__, "after_agent_callbacks", after_agent_callbacks)
        if after_model_callbacks is not None:
            pulumi.set(__self__, "after_model_callbacks", after_model_callbacks)
        if after_tool_callbacks is not None:
            pulumi.set(__self__, "after_tool_callbacks", after_tool_callbacks)
        if before_agent_callbacks is not None:
            pulumi.set(__self__, "before_agent_callbacks", before_agent_callbacks)
        if before_model_callbacks is not None:
            pulumi.set(__self__, "before_model_callbacks", before_model_callbacks)
        if before_tool_callbacks is not None:
            pulumi.set(__self__, "before_tool_callbacks", before_tool_callbacks)
        if child_agents is not None:
            pulumi.set(__self__, "child_agents", child_agents)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if etag is not None:
            pulumi.set(__self__, "etag", etag)
        if generated_summary is not None:
            pulumi.set(__self__, "generated_summary", generated_summary)
        if guardrails is not None:
            pulumi.set(__self__, "guardrails", guardrails)
        if instruction is not None:
            pulumi.set(__self__, "instruction", instruction)
        if llm_agents is not None:
            pulumi.set(__self__, "llm_agents", llm_agents)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if remote_dialogflow_agents is not None:
            pulumi.set(__self__, "remote_dialogflow_agents", remote_dialogflow_agents)
        if tools is not None:
            pulumi.set(__self__, "tools", tools)
        if toolsets is not None:
            pulumi.set(__self__, "toolsets", toolsets)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="afterAgentCallbacks")
    def after_agent_callbacks(self) -> Optional[Sequence['outputs.AppVersionSnapshotAgentAfterAgentCallback']]:
        """
        (Output)
        The callbacks to execute after the agent is called.
        The provided callbacks are executed sequentially in the exact order they
        are given in the list. If a callback returns an overridden response,
        execution stops and any remaining callbacks are skipped.
        Structure is documented below.
        """
        return pulumi.get(self, "after_agent_callbacks")

    @_builtins.property
    @pulumi.getter(name="afterModelCallbacks")
    def after_model_callbacks(self) -> Optional[Sequence['outputs.AppVersionSnapshotAgentAfterModelCallback']]:
        """
        (Output)
        The callbacks to execute after the model is called. If there are multiple
        calls to the model, the callback will be executed multiple times.
        The provided callbacks are executed sequentially in the exact order they
        are given in the list. If a callback returns an overridden response,
        execution stops and any remaining callbacks are skipped.
        Structure is documented below.
        """
        return pulumi.get(self, "after_model_callbacks")

    @_builtins.property
    @pulumi.getter(name="afterToolCallbacks")
    def after_tool_callbacks(self) -> Optional[Sequence['outputs.AppVersionSnapshotAgentAfterToolCallback']]:
        """
        (Output)
        The callbacks to execute after the tool is invoked. If there are multiple
        tool invocations, the callback will be executed multiple times.
        The provided callbacks are executed sequentially in the exact order they
        are given in the list. If a callback returns an overridden response,
        execution stops and any remaining callbacks are skipped.
        Structure is documented below.
        """
        return pulumi.get(self, "after_tool_callbacks")

    @_builtins.property
    @pulumi.getter(name="beforeAgentCallbacks")
    def before_agent_callbacks(self) -> Optional[Sequence['outputs.AppVersionSnapshotAgentBeforeAgentCallback']]:
        """
        (Output)
        The callbacks to execute before the agent is called.
        The provided callbacks are executed sequentially in the exact order they
        are given in the list. If a callback returns an overridden response,
        execution stops and any remaining callbacks are skipped.
        Structure is documented below.
        """
        return pulumi.get(self, "before_agent_callbacks")

    @_builtins.property
    @pulumi.getter(name="beforeModelCallbacks")
    def before_model_callbacks(self) -> Optional[Sequence['outputs.AppVersionSnapshotAgentBeforeModelCallback']]:
        """
        (Output)
        The callbacks to execute before the model is called. If there are multiple
        calls to the model, the callback will be executed multiple times.
        The provided callbacks are executed sequentially in the exact order they
        are given in the list. If a callback returns an overridden response,
        execution stops and any remaining callbacks are skipped.
        Structure is documented below.
        """
        return pulumi.get(self, "before_model_callbacks")

    @_builtins.property
    @pulumi.getter(name="beforeToolCallbacks")
    def before_tool_callbacks(self) -> Optional[Sequence['outputs.AppVersionSnapshotAgentBeforeToolCallback']]:
        """
        (Output)
        The callbacks to execute before the tool is invoked. If there are multiple
        tool invocations, the callback will be executed multiple times.
        The provided callbacks are executed sequentially in the exact order they
        are given in the list. If a callback returns an overridden response,
        execution stops and any remaining callbacks are skipped.
        Structure is documented below.
        """
        return pulumi.get(self, "before_tool_callbacks")

    @_builtins.property
    @pulumi.getter(name="childAgents")
    def child_agents(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        List of child agents in the agent tree.
        Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        return pulumi.get(self, "child_agents")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        Timestamp when the toolset was created.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def etag(self) -> Optional[_builtins.str]:
        """
        (Output)
        ETag used to ensure the object hasn't changed during a read-modify-write
        operation. If the etag is empty, the update will overwrite any concurrent
        changes.
        """
        return pulumi.get(self, "etag")

    @_builtins.property
    @pulumi.getter(name="generatedSummary")
    def generated_summary(self) -> Optional[_builtins.str]:
        """
        (Output)
        If the tool is generated by the LLM assistant, this field contains a
        descriptive summary of the generation.
        """
        return pulumi.get(self, "generated_summary")

    @_builtins.property
    @pulumi.getter
    def guardrails(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        List of guardrails for the app.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
        """
        return pulumi.get(self, "guardrails")

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> Optional[_builtins.str]:
        """
        (Output)
        Instructions for the LLM model to guide the agent's behavior.
        """
        return pulumi.get(self, "instruction")

    @_builtins.property
    @pulumi.getter(name="llmAgents")
    def llm_agents(self) -> Optional[Sequence['outputs.AppVersionSnapshotAgentLlmAgent']]:
        """
        (Output)
        Default agent type. The agent uses instructions and callbacks specified in
        the agent to perform the task using a large language model.
        """
        return pulumi.get(self, "llm_agents")

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional[Sequence['outputs.AppVersionSnapshotAgentModelSetting']]:
        """
        (Output)
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="remoteDialogflowAgents")
    def remote_dialogflow_agents(self) -> Optional[Sequence['outputs.AppVersionSnapshotAgentRemoteDialogflowAgent']]:
        """
        (Output)
        The agent which will transfer execution to an existing remote
        [Dialogflow](https://cloud.google.com/dialogflow/cx/docs/concept/console-conversational-agents)
        agent flow. The corresponding Dialogflow agent will process subsequent user
        queries until the session ends or flow ends and the control is transferred
        back to the parent CES agent.
        Structure is documented below.
        """
        return pulumi.get(self, "remote_dialogflow_agents")

    @_builtins.property
    @pulumi.getter
    def tools(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        List of available tools for the agent.
        Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        """
        return pulumi.get(self, "tools")

    @_builtins.property
    @pulumi.getter
    def toolsets(self) -> Optional[Sequence['outputs.AppVersionSnapshotAgentToolset']]:
        """
        (Output)
        List of toolsets for the agent.
        Structure is documented below.
        """
        return pulumi.get(self, "toolsets")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        Timestamp when the toolset was last updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class AppVersionSnapshotAgentAfterAgentCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAgentAfterAgentCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAgentAfterAgentCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAgentAfterAgentCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 python_code: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: The description of the app version.
        :param _builtins.bool disabled: (Output)
               Whether summarization is disabled.
        :param _builtins.str python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[_builtins.str]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")


@pulumi.output_type
class AppVersionSnapshotAgentAfterModelCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAgentAfterModelCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAgentAfterModelCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAgentAfterModelCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 python_code: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: The description of the app version.
        :param _builtins.bool disabled: (Output)
               Whether summarization is disabled.
        :param _builtins.str python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[_builtins.str]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")


@pulumi.output_type
class AppVersionSnapshotAgentAfterToolCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAgentAfterToolCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAgentAfterToolCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAgentAfterToolCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 python_code: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: The description of the app version.
        :param _builtins.bool disabled: (Output)
               Whether summarization is disabled.
        :param _builtins.str python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[_builtins.str]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")


@pulumi.output_type
class AppVersionSnapshotAgentBeforeAgentCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAgentBeforeAgentCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAgentBeforeAgentCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAgentBeforeAgentCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 python_code: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: The description of the app version.
        :param _builtins.bool disabled: (Output)
               Whether summarization is disabled.
        :param _builtins.str python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[_builtins.str]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")


@pulumi.output_type
class AppVersionSnapshotAgentBeforeModelCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAgentBeforeModelCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAgentBeforeModelCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAgentBeforeModelCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 python_code: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: The description of the app version.
        :param _builtins.bool disabled: (Output)
               Whether summarization is disabled.
        :param _builtins.str python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[_builtins.str]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")


@pulumi.output_type
class AppVersionSnapshotAgentBeforeToolCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAgentBeforeToolCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAgentBeforeToolCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAgentBeforeToolCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 python_code: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: The description of the app version.
        :param _builtins.bool disabled: (Output)
               Whether summarization is disabled.
        :param _builtins.str python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[_builtins.str]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")


@pulumi.output_type
class AppVersionSnapshotAgentLlmAgent(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class AppVersionSnapshotAgentModelSetting(dict):
    def __init__(__self__, *,
                 model: Optional[_builtins.str] = None,
                 temperature: Optional[_builtins.float] = None):
        """
        :param _builtins.str model: (Output)
               The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param _builtins.float temperature: (Output)
               If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        (Output)
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        (Output)
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")


@pulumi.output_type
class AppVersionSnapshotAgentRemoteDialogflowAgent(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "environmentId":
            suggest = "environment_id"
        elif key == "flowId":
            suggest = "flow_id"
        elif key == "inputVariableMapping":
            suggest = "input_variable_mapping"
        elif key == "outputVariableMapping":
            suggest = "output_variable_mapping"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAgentRemoteDialogflowAgent. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAgentRemoteDialogflowAgent.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAgentRemoteDialogflowAgent.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent: Optional[_builtins.str] = None,
                 environment_id: Optional[_builtins.str] = None,
                 flow_id: Optional[_builtins.str] = None,
                 input_variable_mapping: Optional[Mapping[str, _builtins.str]] = None,
                 output_variable_mapping: Optional[Mapping[str, _builtins.str]] = None):
        """
        :param _builtins.str agent: (Output)
               The name of the agent to transfer the conversation to. The agent must be
               in the same app as the current agent.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        :param _builtins.str environment_id: (Output)
               The environment ID of the Dialogflow agent be used for the agent
               execution. If not specified, the draft environment will be used.
        :param _builtins.str flow_id: (Output)
               The flow ID of the flow in the Dialogflow agent.
        :param Mapping[str, _builtins.str] input_variable_mapping: (Output)
               The mapping of the app variables names to the Dialogflow session
               parameters names to be sent to the Dialogflow agent as input.
        :param Mapping[str, _builtins.str] output_variable_mapping: (Output)
               The mapping of the Dialogflow session parameters names to the app
               variables names to be sent back to the CES agent after the Dialogflow
               agent execution ends.
        """
        if agent is not None:
            pulumi.set(__self__, "agent", agent)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)
        if flow_id is not None:
            pulumi.set(__self__, "flow_id", flow_id)
        if input_variable_mapping is not None:
            pulumi.set(__self__, "input_variable_mapping", input_variable_mapping)
        if output_variable_mapping is not None:
            pulumi.set(__self__, "output_variable_mapping", output_variable_mapping)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the agent to transfer the conversation to. The agent must be
        in the same app as the current agent.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        return pulumi.get(self, "agent")

    @_builtins.property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[_builtins.str]:
        """
        (Output)
        The environment ID of the Dialogflow agent be used for the agent
        execution. If not specified, the draft environment will be used.
        """
        return pulumi.get(self, "environment_id")

    @_builtins.property
    @pulumi.getter(name="flowId")
    def flow_id(self) -> Optional[_builtins.str]:
        """
        (Output)
        The flow ID of the flow in the Dialogflow agent.
        """
        return pulumi.get(self, "flow_id")

    @_builtins.property
    @pulumi.getter(name="inputVariableMapping")
    def input_variable_mapping(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Output)
        The mapping of the app variables names to the Dialogflow session
        parameters names to be sent to the Dialogflow agent as input.
        """
        return pulumi.get(self, "input_variable_mapping")

    @_builtins.property
    @pulumi.getter(name="outputVariableMapping")
    def output_variable_mapping(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Output)
        The mapping of the Dialogflow session parameters names to the app
        variables names to be sent back to the CES agent after the Dialogflow
        agent execution ends.
        """
        return pulumi.get(self, "output_variable_mapping")


@pulumi.output_type
class AppVersionSnapshotAgentToolset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toolIds":
            suggest = "tool_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAgentToolset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAgentToolset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAgentToolset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tool_ids: Optional[Sequence[_builtins.str]] = None,
                 toolset: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] tool_ids: (Output)
               The tools IDs to filter the toolset.
        :param _builtins.str toolset: (Output)
               The resource name of the Toolset from which this tool is derived.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        if tool_ids is not None:
            pulumi.set(__self__, "tool_ids", tool_ids)
        if toolset is not None:
            pulumi.set(__self__, "toolset", toolset)

    @_builtins.property
    @pulumi.getter(name="toolIds")
    def tool_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        The tools IDs to filter the toolset.
        """
        return pulumi.get(self, "tool_ids")

    @_builtins.property
    @pulumi.getter
    def toolset(self) -> Optional[_builtins.str]:
        """
        (Output)
        The resource name of the Toolset from which this tool is derived.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "toolset")


@pulumi.output_type
class AppVersionSnapshotApp(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioProcessingConfigs":
            suggest = "audio_processing_configs"
        elif key == "clientCertificateSettings":
            suggest = "client_certificate_settings"
        elif key == "createTime":
            suggest = "create_time"
        elif key == "dataStoreSettings":
            suggest = "data_store_settings"
        elif key == "defaultChannelProfiles":
            suggest = "default_channel_profiles"
        elif key == "deploymentCount":
            suggest = "deployment_count"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "evaluationMetricsThresholds":
            suggest = "evaluation_metrics_thresholds"
        elif key == "globalInstruction":
            suggest = "global_instruction"
        elif key == "languageSettings":
            suggest = "language_settings"
        elif key == "loggingSettings":
            suggest = "logging_settings"
        elif key == "modelSettings":
            suggest = "model_settings"
        elif key == "rootAgent":
            suggest = "root_agent"
        elif key == "timeZoneSettings":
            suggest = "time_zone_settings"
        elif key == "updateTime":
            suggest = "update_time"
        elif key == "variableDeclarations":
            suggest = "variable_declarations"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotApp. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotApp.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotApp.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_processing_configs: Optional[Sequence['outputs.AppVersionSnapshotAppAudioProcessingConfig']] = None,
                 client_certificate_settings: Optional[Sequence['outputs.AppVersionSnapshotAppClientCertificateSetting']] = None,
                 create_time: Optional[_builtins.str] = None,
                 data_store_settings: Optional[Sequence['outputs.AppVersionSnapshotAppDataStoreSetting']] = None,
                 default_channel_profiles: Optional[Sequence['outputs.AppVersionSnapshotAppDefaultChannelProfile']] = None,
                 deployment_count: Optional[_builtins.int] = None,
                 description: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 etag: Optional[_builtins.str] = None,
                 evaluation_metrics_thresholds: Optional[Sequence['outputs.AppVersionSnapshotAppEvaluationMetricsThreshold']] = None,
                 global_instruction: Optional[_builtins.str] = None,
                 guardrails: Optional[Sequence[_builtins.str]] = None,
                 language_settings: Optional[Sequence['outputs.AppVersionSnapshotAppLanguageSetting']] = None,
                 logging_settings: Optional[Sequence['outputs.AppVersionSnapshotAppLoggingSetting']] = None,
                 metadata: Optional[Mapping[str, _builtins.str]] = None,
                 model_settings: Optional[Sequence['outputs.AppVersionSnapshotAppModelSetting']] = None,
                 name: Optional[_builtins.str] = None,
                 root_agent: Optional[_builtins.str] = None,
                 time_zone_settings: Optional[Sequence['outputs.AppVersionSnapshotAppTimeZoneSetting']] = None,
                 update_time: Optional[_builtins.str] = None,
                 variable_declarations: Optional[Sequence['outputs.AppVersionSnapshotAppVariableDeclaration']] = None):
        """
        :param Sequence['AppVersionSnapshotAppAudioProcessingConfigArgs'] audio_processing_configs: (Output)
               Configuration for how the input and output audio should be processed and
               delivered.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotAppClientCertificateSettingArgs'] client_certificate_settings: (Output)
               The default client certificate settings for the app.
               Structure is documented below.
        :param _builtins.str create_time: (Output)
               Timestamp when the toolset was created.
        :param Sequence['AppVersionSnapshotAppDataStoreSettingArgs'] data_store_settings: (Output)
               Data store related settings for the app.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotAppDefaultChannelProfileArgs'] default_channel_profiles: (Output)
               A ChannelProfile configures the agent's behavior for a specific communication
               channel, such as web UI or telephony.
               Structure is documented below.
        :param _builtins.int deployment_count: (Output)
               Number of deployments in the app.
        :param _builtins.str description: The description of the app version.
        :param _builtins.str display_name: The display name of the app version.
        :param _builtins.str etag: (Output)
               ETag used to ensure the object hasn't changed during a read-modify-write
               operation. If the etag is empty, the update will overwrite any concurrent
               changes.
        :param Sequence['AppVersionSnapshotAppEvaluationMetricsThresholdArgs'] evaluation_metrics_thresholds: (Output)
               Threshold settings for metrics in an Evaluation.
               Structure is documented below.
        :param _builtins.str global_instruction: (Output)
               Instructions for all the agents in the app.
               You can use this instruction to set up a stable identity or personality
               across all the agents.
        :param Sequence[_builtins.str] guardrails: (Output)
               List of guardrails for the app.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
        :param Sequence['AppVersionSnapshotAppLanguageSettingArgs'] language_settings: (Output)
               Language settings of the app.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotAppLoggingSettingArgs'] logging_settings: (Output)
               Settings to describe the logging behaviors for the app.
               Structure is documented below.
        :param Mapping[str, _builtins.str] metadata: (Output)
               Metadata about the app. This field can be used to store additional
               information relevant to the app's details or intended usages.
        :param Sequence['AppVersionSnapshotAppModelSettingArgs'] model_settings: (Output)
               Model settings contains various configurations for the LLM model.
               Structure is documented below.
        :param _builtins.str name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param _builtins.str root_agent: (Output)
               The root agent is the entry point of the app.
               Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        :param Sequence['AppVersionSnapshotAppTimeZoneSettingArgs'] time_zone_settings: (Output)
               TimeZone settings of the app.
               Structure is documented below.
        :param _builtins.str update_time: (Output)
               Timestamp when the toolset was last updated.
        :param Sequence['AppVersionSnapshotAppVariableDeclarationArgs'] variable_declarations: (Output)
               The declarations of the variables.
               Structure is documented below.
        """
        if audio_processing_configs is not None:
            pulumi.set(__self__, "audio_processing_configs", audio_processing_configs)
        if client_certificate_settings is not None:
            pulumi.set(__self__, "client_certificate_settings", client_certificate_settings)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if data_store_settings is not None:
            pulumi.set(__self__, "data_store_settings", data_store_settings)
        if default_channel_profiles is not None:
            pulumi.set(__self__, "default_channel_profiles", default_channel_profiles)
        if deployment_count is not None:
            pulumi.set(__self__, "deployment_count", deployment_count)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if etag is not None:
            pulumi.set(__self__, "etag", etag)
        if evaluation_metrics_thresholds is not None:
            pulumi.set(__self__, "evaluation_metrics_thresholds", evaluation_metrics_thresholds)
        if global_instruction is not None:
            pulumi.set(__self__, "global_instruction", global_instruction)
        if guardrails is not None:
            pulumi.set(__self__, "guardrails", guardrails)
        if language_settings is not None:
            pulumi.set(__self__, "language_settings", language_settings)
        if logging_settings is not None:
            pulumi.set(__self__, "logging_settings", logging_settings)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if root_agent is not None:
            pulumi.set(__self__, "root_agent", root_agent)
        if time_zone_settings is not None:
            pulumi.set(__self__, "time_zone_settings", time_zone_settings)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)
        if variable_declarations is not None:
            pulumi.set(__self__, "variable_declarations", variable_declarations)

    @_builtins.property
    @pulumi.getter(name="audioProcessingConfigs")
    def audio_processing_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppAudioProcessingConfig']]:
        """
        (Output)
        Configuration for how the input and output audio should be processed and
        delivered.
        Structure is documented below.
        """
        return pulumi.get(self, "audio_processing_configs")

    @_builtins.property
    @pulumi.getter(name="clientCertificateSettings")
    def client_certificate_settings(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppClientCertificateSetting']]:
        """
        (Output)
        The default client certificate settings for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "client_certificate_settings")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        Timestamp when the toolset was created.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="dataStoreSettings")
    def data_store_settings(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppDataStoreSetting']]:
        """
        (Output)
        Data store related settings for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "data_store_settings")

    @_builtins.property
    @pulumi.getter(name="defaultChannelProfiles")
    def default_channel_profiles(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppDefaultChannelProfile']]:
        """
        (Output)
        A ChannelProfile configures the agent's behavior for a specific communication
        channel, such as web UI or telephony.
        Structure is documented below.
        """
        return pulumi.get(self, "default_channel_profiles")

    @_builtins.property
    @pulumi.getter(name="deploymentCount")
    def deployment_count(self) -> Optional[_builtins.int]:
        """
        (Output)
        Number of deployments in the app.
        """
        return pulumi.get(self, "deployment_count")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def etag(self) -> Optional[_builtins.str]:
        """
        (Output)
        ETag used to ensure the object hasn't changed during a read-modify-write
        operation. If the etag is empty, the update will overwrite any concurrent
        changes.
        """
        return pulumi.get(self, "etag")

    @_builtins.property
    @pulumi.getter(name="evaluationMetricsThresholds")
    def evaluation_metrics_thresholds(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppEvaluationMetricsThreshold']]:
        """
        (Output)
        Threshold settings for metrics in an Evaluation.
        Structure is documented below.
        """
        return pulumi.get(self, "evaluation_metrics_thresholds")

    @_builtins.property
    @pulumi.getter(name="globalInstruction")
    def global_instruction(self) -> Optional[_builtins.str]:
        """
        (Output)
        Instructions for all the agents in the app.
        You can use this instruction to set up a stable identity or personality
        across all the agents.
        """
        return pulumi.get(self, "global_instruction")

    @_builtins.property
    @pulumi.getter
    def guardrails(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        List of guardrails for the app.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
        """
        return pulumi.get(self, "guardrails")

    @_builtins.property
    @pulumi.getter(name="languageSettings")
    def language_settings(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppLanguageSetting']]:
        """
        (Output)
        Language settings of the app.
        Structure is documented below.
        """
        return pulumi.get(self, "language_settings")

    @_builtins.property
    @pulumi.getter(name="loggingSettings")
    def logging_settings(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppLoggingSetting']]:
        """
        (Output)
        Settings to describe the logging behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "logging_settings")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        (Output)
        Metadata about the app. This field can be used to store additional
        information relevant to the app's details or intended usages.
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppModelSetting']]:
        """
        (Output)
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="rootAgent")
    def root_agent(self) -> Optional[_builtins.str]:
        """
        (Output)
        The root agent is the entry point of the app.
        Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        return pulumi.get(self, "root_agent")

    @_builtins.property
    @pulumi.getter(name="timeZoneSettings")
    def time_zone_settings(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppTimeZoneSetting']]:
        """
        (Output)
        TimeZone settings of the app.
        Structure is documented below.
        """
        return pulumi.get(self, "time_zone_settings")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        Timestamp when the toolset was last updated.
        """
        return pulumi.get(self, "update_time")

    @_builtins.property
    @pulumi.getter(name="variableDeclarations")
    def variable_declarations(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppVariableDeclaration']]:
        """
        (Output)
        The declarations of the variables.
        Structure is documented below.
        """
        return pulumi.get(self, "variable_declarations")


@pulumi.output_type
class AppVersionSnapshotAppAudioProcessingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ambientSoundConfigs":
            suggest = "ambient_sound_configs"
        elif key == "bargeInConfigs":
            suggest = "barge_in_configs"
        elif key == "inactivityTimeout":
            suggest = "inactivity_timeout"
        elif key == "synthesizeSpeechConfigs":
            suggest = "synthesize_speech_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAppAudioProcessingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAppAudioProcessingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAppAudioProcessingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ambient_sound_configs: Optional[Sequence['outputs.AppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfig']] = None,
                 barge_in_configs: Optional[Sequence['outputs.AppVersionSnapshotAppAudioProcessingConfigBargeInConfig']] = None,
                 inactivity_timeout: Optional[_builtins.str] = None,
                 synthesize_speech_configs: Optional[Sequence['outputs.AppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfig']] = None):
        """
        :param Sequence['AppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfigArgs'] ambient_sound_configs: (Output)
               Configuration for the ambient sound to be played with the synthesized agent
               response, to enhance the naturalness of the conversation.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotAppAudioProcessingConfigBargeInConfigArgs'] barge_in_configs: (Output)
               Configuration for how the user barge-in activities should be handled.
               Structure is documented below.
        :param _builtins.str inactivity_timeout: (Output)
               The duration of user inactivity (no speech or interaction) before the agent
               prompts the user for reengagement. If not set, the agent will not prompt
               the user for reengagement.
        :param Sequence['AppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfigArgs'] synthesize_speech_configs: (Output)
               Configuration of how the agent response should be synthesized, mapping from
               the language code to SynthesizeSpeechConfig.
               If the configuration for the specified language code is not found, the
               configuration for the root language code will be used. For example, if the
               map contains "en-us" and "en", and the specified language code is "en-gb",
               then "en" configuration will be used.
               Note: Language code is case-insensitive.
               Structure is documented below.
        """
        if ambient_sound_configs is not None:
            pulumi.set(__self__, "ambient_sound_configs", ambient_sound_configs)
        if barge_in_configs is not None:
            pulumi.set(__self__, "barge_in_configs", barge_in_configs)
        if inactivity_timeout is not None:
            pulumi.set(__self__, "inactivity_timeout", inactivity_timeout)
        if synthesize_speech_configs is not None:
            pulumi.set(__self__, "synthesize_speech_configs", synthesize_speech_configs)

    @_builtins.property
    @pulumi.getter(name="ambientSoundConfigs")
    def ambient_sound_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfig']]:
        """
        (Output)
        Configuration for the ambient sound to be played with the synthesized agent
        response, to enhance the naturalness of the conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "ambient_sound_configs")

    @_builtins.property
    @pulumi.getter(name="bargeInConfigs")
    def barge_in_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppAudioProcessingConfigBargeInConfig']]:
        """
        (Output)
        Configuration for how the user barge-in activities should be handled.
        Structure is documented below.
        """
        return pulumi.get(self, "barge_in_configs")

    @_builtins.property
    @pulumi.getter(name="inactivityTimeout")
    def inactivity_timeout(self) -> Optional[_builtins.str]:
        """
        (Output)
        The duration of user inactivity (no speech or interaction) before the agent
        prompts the user for reengagement. If not set, the agent will not prompt
        the user for reengagement.
        """
        return pulumi.get(self, "inactivity_timeout")

    @_builtins.property
    @pulumi.getter(name="synthesizeSpeechConfigs")
    def synthesize_speech_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfig']]:
        """
        (Output)
        Configuration of how the agent response should be synthesized, mapping from
        the language code to SynthesizeSpeechConfig.
        If the configuration for the specified language code is not found, the
        configuration for the root language code will be used. For example, if the
        map contains "en-us" and "en", and the specified language code is "en-gb",
        then "en" configuration will be used.
        Note: Language code is case-insensitive.
        Structure is documented below.
        """
        return pulumi.get(self, "synthesize_speech_configs")


@pulumi.output_type
class AppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gcsUri":
            suggest = "gcs_uri"
        elif key == "prebuiltAmbientSound":
            suggest = "prebuilt_ambient_sound"
        elif key == "volumeGainDb":
            suggest = "volume_gain_db"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gcs_uri: Optional[_builtins.str] = None,
                 prebuilt_ambient_sound: Optional[_builtins.str] = None,
                 volume_gain_db: Optional[_builtins.float] = None):
        """
        :param _builtins.str gcs_uri: (Output)
               Ambient noise as a mono-channel, 16kHz WAV file stored in [Cloud
               Storage](https://cloud.google.com/storage).
               Note: Please make sure the CES service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com` has
               `storage.objects.get` permission to the Cloud Storage object.
        :param _builtins.str prebuilt_ambient_sound: (Output)
               Name of the prebuilt ambient sound.
               Valid values are: - "coffee_shop" - "keyboard" - "keypad" - "hum"
               -"office_1" - "office_2" - "office_3"
               -"room_1" - "room_2" - "room_3"
               -"room_4" - "room_5" - "air_conditioner"
        :param _builtins.float volume_gain_db: (Output)
               Volume gain (in dB) of the normal native volume supported by
               ambient noise, in the range [-96.0, 16.0]. If unset, or set to a value of
               0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
               will play at approximately half the amplitude of the normal native signal
               amplitude. A value of +6.0 (dB) will play at approximately twice the
               amplitude of the normal native signal amplitude. We strongly recommend not
               to exceed +10 (dB) as there's usually no effective increase in loudness for
               any value greater than that.
        """
        if gcs_uri is not None:
            pulumi.set(__self__, "gcs_uri", gcs_uri)
        if prebuilt_ambient_sound is not None:
            pulumi.set(__self__, "prebuilt_ambient_sound", prebuilt_ambient_sound)
        if volume_gain_db is not None:
            pulumi.set(__self__, "volume_gain_db", volume_gain_db)

    @_builtins.property
    @pulumi.getter(name="gcsUri")
    def gcs_uri(self) -> Optional[_builtins.str]:
        """
        (Output)
        Ambient noise as a mono-channel, 16kHz WAV file stored in [Cloud
        Storage](https://cloud.google.com/storage).
        Note: Please make sure the CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com` has
        `storage.objects.get` permission to the Cloud Storage object.
        """
        return pulumi.get(self, "gcs_uri")

    @_builtins.property
    @pulumi.getter(name="prebuiltAmbientSound")
    def prebuilt_ambient_sound(self) -> Optional[_builtins.str]:
        """
        (Output)
        Name of the prebuilt ambient sound.
        Valid values are: - "coffee_shop" - "keyboard" - "keypad" - "hum"
        -"office_1" - "office_2" - "office_3"
        -"room_1" - "room_2" - "room_3"
        -"room_4" - "room_5" - "air_conditioner"
        """
        return pulumi.get(self, "prebuilt_ambient_sound")

    @_builtins.property
    @pulumi.getter(name="volumeGainDb")
    def volume_gain_db(self) -> Optional[_builtins.float]:
        """
        (Output)
        Volume gain (in dB) of the normal native volume supported by
        ambient noise, in the range [-96.0, 16.0]. If unset, or set to a value of
        0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
        will play at approximately half the amplitude of the normal native signal
        amplitude. A value of +6.0 (dB) will play at approximately twice the
        amplitude of the normal native signal amplitude. We strongly recommend not
        to exceed +10 (dB) as there's usually no effective increase in loudness for
        any value greater than that.
        """
        return pulumi.get(self, "volume_gain_db")


@pulumi.output_type
class AppVersionSnapshotAppAudioProcessingConfigBargeInConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bargeInAwareness":
            suggest = "barge_in_awareness"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAppAudioProcessingConfigBargeInConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAppAudioProcessingConfigBargeInConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAppAudioProcessingConfigBargeInConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 barge_in_awareness: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool barge_in_awareness: (Output)
               If enabled, the agent will adapt its next response based on the assumption
               that the user hasn't heard the full preceding agent message.
               This should not be used in scenarios where agent responses are displayed
               visually.
        """
        if barge_in_awareness is not None:
            pulumi.set(__self__, "barge_in_awareness", barge_in_awareness)

    @_builtins.property
    @pulumi.getter(name="bargeInAwareness")
    def barge_in_awareness(self) -> Optional[_builtins.bool]:
        """
        (Output)
        If enabled, the agent will adapt its next response based on the assumption
        that the user hasn't heard the full preceding agent message.
        This should not be used in scenarios where agent responses are displayed
        visually.
        """
        return pulumi.get(self, "barge_in_awareness")


@pulumi.output_type
class AppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "languageCode":
            suggest = "language_code"
        elif key == "speakingRate":
            suggest = "speaking_rate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 language_code: _builtins.str,
                 speaking_rate: Optional[_builtins.float] = None,
                 voice: Optional[_builtins.str] = None):
        """
        :param _builtins.str language_code: (Required) The identifier for this object. Format specified above.
        :param _builtins.float speaking_rate: (Output)
               The speaking rate/speed in the range [0.25, 2.0]. 1.0 is the normal native
               speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is
               half as fast. Values outside of the range [0.25, 2.0] will return an error.
        :param _builtins.str voice: (Output)
               The name of the voice. If not set, the service will choose a
               voice based on the other parameters such as language_code.
               For the list of available voices, please refer to Supported voices and
               languages from Cloud Text-to-Speech.
        """
        pulumi.set(__self__, "language_code", language_code)
        if speaking_rate is not None:
            pulumi.set(__self__, "speaking_rate", speaking_rate)
        if voice is not None:
            pulumi.set(__self__, "voice", voice)

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> _builtins.str:
        """
        (Required) The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "language_code")

    @_builtins.property
    @pulumi.getter(name="speakingRate")
    def speaking_rate(self) -> Optional[_builtins.float]:
        """
        (Output)
        The speaking rate/speed in the range [0.25, 2.0]. 1.0 is the normal native
        speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is
        half as fast. Values outside of the range [0.25, 2.0] will return an error.
        """
        return pulumi.get(self, "speaking_rate")

    @_builtins.property
    @pulumi.getter
    def voice(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the voice. If not set, the service will choose a
        voice based on the other parameters such as language_code.
        For the list of available voices, please refer to Supported voices and
        languages from Cloud Text-to-Speech.
        """
        return pulumi.get(self, "voice")


@pulumi.output_type
class AppVersionSnapshotAppClientCertificateSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKey":
            suggest = "private_key"
        elif key == "tlsCertificate":
            suggest = "tls_certificate"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAppClientCertificateSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAppClientCertificateSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAppClientCertificateSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 passphrase: Optional[_builtins.str] = None,
                 private_key: Optional[_builtins.str] = None,
                 tls_certificate: Optional[_builtins.str] = None):
        """
        :param _builtins.str passphrase: (Output)
               The passphrase to decrypt the private key.
               Should be left unset if the private key is not encrypted.
        :param _builtins.str private_key: (Output)
               The name of the SecretManager secret version resource
               storing the private key encoded in PEM format.
               Format: projects/{project}/secrets/{secret}/versions/{version}
        :param _builtins.str tls_certificate: (Output)
               The TLS certificate encoded in PEM format.
               This string must include the begin header and end footer lines.
        """
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if tls_certificate is not None:
            pulumi.set(__self__, "tls_certificate", tls_certificate)

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[_builtins.str]:
        """
        (Output)
        The passphrase to decrypt the private key.
        Should be left unset if the private key is not encrypted.
        """
        return pulumi.get(self, "passphrase")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the SecretManager secret version resource
        storing the private key encoded in PEM format.
        Format: projects/{project}/secrets/{secret}/versions/{version}
        """
        return pulumi.get(self, "private_key")

    @_builtins.property
    @pulumi.getter(name="tlsCertificate")
    def tls_certificate(self) -> Optional[_builtins.str]:
        """
        (Output)
        The TLS certificate encoded in PEM format.
        This string must include the begin header and end footer lines.
        """
        return pulumi.get(self, "tls_certificate")


@pulumi.output_type
class AppVersionSnapshotAppDataStoreSetting(dict):
    def __init__(__self__, *,
                 engines: Optional[Sequence['outputs.AppVersionSnapshotAppDataStoreSettingEngine']] = None):
        """
        :param Sequence['AppVersionSnapshotAppDataStoreSettingEngineArgs'] engines: (Output)
               The engines for the app.
               Structure is documented below.
        """
        if engines is not None:
            pulumi.set(__self__, "engines", engines)

    @_builtins.property
    @pulumi.getter
    def engines(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppDataStoreSettingEngine']]:
        """
        (Output)
        The engines for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "engines")


@pulumi.output_type
class AppVersionSnapshotAppDataStoreSettingEngine(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param _builtins.str type: (Output)
               The type of the data store. This field is readonly and populated by the
               server.
               Possible values:
               PUBLIC_WEB
               UNSTRUCTURED
               FAQ
               CONNECTOR
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AppVersionSnapshotAppDefaultChannelProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelType":
            suggest = "channel_type"
        elif key == "disableBargeInControl":
            suggest = "disable_barge_in_control"
        elif key == "disableDtmf":
            suggest = "disable_dtmf"
        elif key == "personaProperties":
            suggest = "persona_properties"
        elif key == "profileId":
            suggest = "profile_id"
        elif key == "webWidgetConfigs":
            suggest = "web_widget_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAppDefaultChannelProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAppDefaultChannelProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAppDefaultChannelProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_type: Optional[_builtins.str] = None,
                 disable_barge_in_control: Optional[_builtins.bool] = None,
                 disable_dtmf: Optional[_builtins.bool] = None,
                 persona_properties: Optional[Sequence['outputs.AppVersionSnapshotAppDefaultChannelProfilePersonaProperty']] = None,
                 profile_id: Optional[_builtins.str] = None,
                 web_widget_configs: Optional[Sequence['outputs.AppVersionSnapshotAppDefaultChannelProfileWebWidgetConfig']] = None):
        """
        :param _builtins.str channel_type: (Output)
               The type of the channel profile.
               Possible values:
               UNKNOWN
               WEB_UI
               API
               TWILIO
               GOOGLE_TELEPHONY_PLATFORM
               CONTACT_CENTER_AS_A_SERVICE
        :param _builtins.bool disable_barge_in_control: (Output)
               Whether to disable user barge-in in the conversation.
               - true: User interruptions are disabled while the agent is speaking.
               - false: The agent retains automatic control over when the user can interrupt.
        :param _builtins.bool disable_dtmf: (Output)
               Whether to disable DTMF (dual-tone multi-frequency).
        :param Sequence['AppVersionSnapshotAppDefaultChannelProfilePersonaPropertyArgs'] persona_properties: (Output)
               Represents the persona property of a channel.
               Structure is documented below.
        :param _builtins.str profile_id: (Output)
               The unique identifier of the channel profile.
        :param Sequence['AppVersionSnapshotAppDefaultChannelProfileWebWidgetConfigArgs'] web_widget_configs: (Output)
               Message for configuration for the web widget.
               Structure is documented below.
        """
        if channel_type is not None:
            pulumi.set(__self__, "channel_type", channel_type)
        if disable_barge_in_control is not None:
            pulumi.set(__self__, "disable_barge_in_control", disable_barge_in_control)
        if disable_dtmf is not None:
            pulumi.set(__self__, "disable_dtmf", disable_dtmf)
        if persona_properties is not None:
            pulumi.set(__self__, "persona_properties", persona_properties)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if web_widget_configs is not None:
            pulumi.set(__self__, "web_widget_configs", web_widget_configs)

    @_builtins.property
    @pulumi.getter(name="channelType")
    def channel_type(self) -> Optional[_builtins.str]:
        """
        (Output)
        The type of the channel profile.
        Possible values:
        UNKNOWN
        WEB_UI
        API
        TWILIO
        GOOGLE_TELEPHONY_PLATFORM
        CONTACT_CENTER_AS_A_SERVICE
        """
        return pulumi.get(self, "channel_type")

    @_builtins.property
    @pulumi.getter(name="disableBargeInControl")
    def disable_barge_in_control(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether to disable user barge-in in the conversation.
        - true: User interruptions are disabled while the agent is speaking.
        - false: The agent retains automatic control over when the user can interrupt.
        """
        return pulumi.get(self, "disable_barge_in_control")

    @_builtins.property
    @pulumi.getter(name="disableDtmf")
    def disable_dtmf(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether to disable DTMF (dual-tone multi-frequency).
        """
        return pulumi.get(self, "disable_dtmf")

    @_builtins.property
    @pulumi.getter(name="personaProperties")
    def persona_properties(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppDefaultChannelProfilePersonaProperty']]:
        """
        (Output)
        Represents the persona property of a channel.
        Structure is documented below.
        """
        return pulumi.get(self, "persona_properties")

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[_builtins.str]:
        """
        (Output)
        The unique identifier of the channel profile.
        """
        return pulumi.get(self, "profile_id")

    @_builtins.property
    @pulumi.getter(name="webWidgetConfigs")
    def web_widget_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppDefaultChannelProfileWebWidgetConfig']]:
        """
        (Output)
        Message for configuration for the web widget.
        Structure is documented below.
        """
        return pulumi.get(self, "web_widget_configs")


@pulumi.output_type
class AppVersionSnapshotAppDefaultChannelProfilePersonaProperty(dict):
    def __init__(__self__, *,
                 persona: Optional[_builtins.str] = None):
        """
        :param _builtins.str persona: (Output)
               The persona of the channel.
               Possible values:
               UNKNOWN
               CONCISE
               CHATTY
        """
        if persona is not None:
            pulumi.set(__self__, "persona", persona)

    @_builtins.property
    @pulumi.getter
    def persona(self) -> Optional[_builtins.str]:
        """
        (Output)
        The persona of the channel.
        Possible values:
        UNKNOWN
        CONCISE
        CHATTY
        """
        return pulumi.get(self, "persona")


@pulumi.output_type
class AppVersionSnapshotAppDefaultChannelProfileWebWidgetConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "webWidgetTitle":
            suggest = "web_widget_title"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAppDefaultChannelProfileWebWidgetConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAppDefaultChannelProfileWebWidgetConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAppDefaultChannelProfileWebWidgetConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 modality: Optional[_builtins.str] = None,
                 theme: Optional[_builtins.str] = None,
                 web_widget_title: Optional[_builtins.str] = None):
        """
        :param _builtins.str modality: (Output)
               The modality of the web widget.
               Possible values:
               UNKNOWN_MODALITY
               CHAT_AND_VOICE
               VOICE_ONLY
               CHAT_ONLY
        :param _builtins.str theme: (Output)
               The theme of the web widget.
               Possible values:
               UNKNOWN_THEME
               LIGHT
               DARK
        :param _builtins.str web_widget_title: (Output)
               The title of the web widget.
        """
        if modality is not None:
            pulumi.set(__self__, "modality", modality)
        if theme is not None:
            pulumi.set(__self__, "theme", theme)
        if web_widget_title is not None:
            pulumi.set(__self__, "web_widget_title", web_widget_title)

    @_builtins.property
    @pulumi.getter
    def modality(self) -> Optional[_builtins.str]:
        """
        (Output)
        The modality of the web widget.
        Possible values:
        UNKNOWN_MODALITY
        CHAT_AND_VOICE
        VOICE_ONLY
        CHAT_ONLY
        """
        return pulumi.get(self, "modality")

    @_builtins.property
    @pulumi.getter
    def theme(self) -> Optional[_builtins.str]:
        """
        (Output)
        The theme of the web widget.
        Possible values:
        UNKNOWN_THEME
        LIGHT
        DARK
        """
        return pulumi.get(self, "theme")

    @_builtins.property
    @pulumi.getter(name="webWidgetTitle")
    def web_widget_title(self) -> Optional[_builtins.str]:
        """
        (Output)
        The title of the web widget.
        """
        return pulumi.get(self, "web_widget_title")


@pulumi.output_type
class AppVersionSnapshotAppEvaluationMetricsThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "goldenEvaluationMetricsThresholds":
            suggest = "golden_evaluation_metrics_thresholds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAppEvaluationMetricsThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAppEvaluationMetricsThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAppEvaluationMetricsThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 golden_evaluation_metrics_thresholds: Optional[Sequence['outputs.AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThreshold']] = None):
        """
        :param Sequence['AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdArgs'] golden_evaluation_metrics_thresholds: (Output)
               Settings for golden evaluations.
               Structure is documented below.
        """
        if golden_evaluation_metrics_thresholds is not None:
            pulumi.set(__self__, "golden_evaluation_metrics_thresholds", golden_evaluation_metrics_thresholds)

    @_builtins.property
    @pulumi.getter(name="goldenEvaluationMetricsThresholds")
    def golden_evaluation_metrics_thresholds(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThreshold']]:
        """
        (Output)
        Settings for golden evaluations.
        Structure is documented below.
        """
        return pulumi.get(self, "golden_evaluation_metrics_thresholds")


@pulumi.output_type
class AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "expectationLevelMetricsThresholds":
            suggest = "expectation_level_metrics_thresholds"
        elif key == "turnLevelMetricsThresholds":
            suggest = "turn_level_metrics_thresholds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 expectation_level_metrics_thresholds: Optional[Sequence['outputs.AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdExpectationLevelMetricsThreshold']] = None,
                 turn_level_metrics_thresholds: Optional[Sequence['outputs.AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdTurnLevelMetricsThreshold']] = None):
        """
        :param Sequence['AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdExpectationLevelMetricsThresholdArgs'] expectation_level_metrics_thresholds: (Output)
               Expectation level metrics thresholds.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdTurnLevelMetricsThresholdArgs'] turn_level_metrics_thresholds: (Output)
               Turn level metrics thresholds.
               Structure is documented below.
        """
        if expectation_level_metrics_thresholds is not None:
            pulumi.set(__self__, "expectation_level_metrics_thresholds", expectation_level_metrics_thresholds)
        if turn_level_metrics_thresholds is not None:
            pulumi.set(__self__, "turn_level_metrics_thresholds", turn_level_metrics_thresholds)

    @_builtins.property
    @pulumi.getter(name="expectationLevelMetricsThresholds")
    def expectation_level_metrics_thresholds(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdExpectationLevelMetricsThreshold']]:
        """
        (Output)
        Expectation level metrics thresholds.
        Structure is documented below.
        """
        return pulumi.get(self, "expectation_level_metrics_thresholds")

    @_builtins.property
    @pulumi.getter(name="turnLevelMetricsThresholds")
    def turn_level_metrics_thresholds(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdTurnLevelMetricsThreshold']]:
        """
        (Output)
        Turn level metrics thresholds.
        Structure is documented below.
        """
        return pulumi.get(self, "turn_level_metrics_thresholds")


@pulumi.output_type
class AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdExpectationLevelMetricsThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toolInvocationParameterCorrectnessThreshold":
            suggest = "tool_invocation_parameter_correctness_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdExpectationLevelMetricsThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdExpectationLevelMetricsThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdExpectationLevelMetricsThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tool_invocation_parameter_correctness_threshold: Optional[_builtins.float] = None):
        """
        :param _builtins.float tool_invocation_parameter_correctness_threshold: (Output)
               The success threshold for individual tool invocation parameter
               correctness. Must be a float between 0 and 1. Default is 1.0.
        """
        if tool_invocation_parameter_correctness_threshold is not None:
            pulumi.set(__self__, "tool_invocation_parameter_correctness_threshold", tool_invocation_parameter_correctness_threshold)

    @_builtins.property
    @pulumi.getter(name="toolInvocationParameterCorrectnessThreshold")
    def tool_invocation_parameter_correctness_threshold(self) -> Optional[_builtins.float]:
        """
        (Output)
        The success threshold for individual tool invocation parameter
        correctness. Must be a float between 0 and 1. Default is 1.0.
        """
        return pulumi.get(self, "tool_invocation_parameter_correctness_threshold")


@pulumi.output_type
class AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdTurnLevelMetricsThreshold(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "overallToolInvocationCorrectnessThreshold":
            suggest = "overall_tool_invocation_correctness_threshold"
        elif key == "semanticSimilaritySuccessThreshold":
            suggest = "semantic_similarity_success_threshold"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdTurnLevelMetricsThreshold. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdTurnLevelMetricsThreshold.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdTurnLevelMetricsThreshold.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 overall_tool_invocation_correctness_threshold: Optional[_builtins.float] = None,
                 semantic_similarity_success_threshold: Optional[_builtins.int] = None):
        """
        :param _builtins.float overall_tool_invocation_correctness_threshold: (Output)
               The success threshold for overall tool invocation correctness. Must be
               a float between 0 and 1. Default is 1.0.
        :param _builtins.int semantic_similarity_success_threshold: (Output)
               The success threshold for semantic similarity. Must be an integer
               between 0 and 4. Default is >= 3.
        """
        if overall_tool_invocation_correctness_threshold is not None:
            pulumi.set(__self__, "overall_tool_invocation_correctness_threshold", overall_tool_invocation_correctness_threshold)
        if semantic_similarity_success_threshold is not None:
            pulumi.set(__self__, "semantic_similarity_success_threshold", semantic_similarity_success_threshold)

    @_builtins.property
    @pulumi.getter(name="overallToolInvocationCorrectnessThreshold")
    def overall_tool_invocation_correctness_threshold(self) -> Optional[_builtins.float]:
        """
        (Output)
        The success threshold for overall tool invocation correctness. Must be
        a float between 0 and 1. Default is 1.0.
        """
        return pulumi.get(self, "overall_tool_invocation_correctness_threshold")

    @_builtins.property
    @pulumi.getter(name="semanticSimilaritySuccessThreshold")
    def semantic_similarity_success_threshold(self) -> Optional[_builtins.int]:
        """
        (Output)
        The success threshold for semantic similarity. Must be an integer
        between 0 and 4. Default is >= 3.
        """
        return pulumi.get(self, "semantic_similarity_success_threshold")


@pulumi.output_type
class AppVersionSnapshotAppLanguageSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultLanguageCode":
            suggest = "default_language_code"
        elif key == "enableMultilingualSupport":
            suggest = "enable_multilingual_support"
        elif key == "fallbackAction":
            suggest = "fallback_action"
        elif key == "supportedLanguageCodes":
            suggest = "supported_language_codes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAppLanguageSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAppLanguageSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAppLanguageSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_language_code: Optional[_builtins.str] = None,
                 enable_multilingual_support: Optional[_builtins.bool] = None,
                 fallback_action: Optional[_builtins.str] = None,
                 supported_language_codes: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str default_language_code: (Output)
               The default language code of the app.
        :param _builtins.bool enable_multilingual_support: (Output)
               Enables multilingual support. If true, agents in the app will use pre-built
               instructions to improve handling of multilingual input.
        :param _builtins.str fallback_action: (Output)
               The action to perform when an agent receives input in an unsupported
               language.
               This can be a predefined action or a custom tool call.
               Valid values are:
               - A tool's full resource name, which triggers a specific tool execution.
               - A predefined system action, such as "escalate" or "exit", which triggers
               an EndSession signal with corresponding metadata
               to terminate the conversation.
        :param Sequence[_builtins.str] supported_language_codes: (Output)
               List of languages codes supported by the app, in addition to the
               `default_language_code`.
        """
        if default_language_code is not None:
            pulumi.set(__self__, "default_language_code", default_language_code)
        if enable_multilingual_support is not None:
            pulumi.set(__self__, "enable_multilingual_support", enable_multilingual_support)
        if fallback_action is not None:
            pulumi.set(__self__, "fallback_action", fallback_action)
        if supported_language_codes is not None:
            pulumi.set(__self__, "supported_language_codes", supported_language_codes)

    @_builtins.property
    @pulumi.getter(name="defaultLanguageCode")
    def default_language_code(self) -> Optional[_builtins.str]:
        """
        (Output)
        The default language code of the app.
        """
        return pulumi.get(self, "default_language_code")

    @_builtins.property
    @pulumi.getter(name="enableMultilingualSupport")
    def enable_multilingual_support(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Enables multilingual support. If true, agents in the app will use pre-built
        instructions to improve handling of multilingual input.
        """
        return pulumi.get(self, "enable_multilingual_support")

    @_builtins.property
    @pulumi.getter(name="fallbackAction")
    def fallback_action(self) -> Optional[_builtins.str]:
        """
        (Output)
        The action to perform when an agent receives input in an unsupported
        language.
        This can be a predefined action or a custom tool call.
        Valid values are:
        - A tool's full resource name, which triggers a specific tool execution.
        - A predefined system action, such as "escalate" or "exit", which triggers
        an EndSession signal with corresponding metadata
        to terminate the conversation.
        """
        return pulumi.get(self, "fallback_action")

    @_builtins.property
    @pulumi.getter(name="supportedLanguageCodes")
    def supported_language_codes(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        List of languages codes supported by the app, in addition to the
        `default_language_code`.
        """
        return pulumi.get(self, "supported_language_codes")


@pulumi.output_type
class AppVersionSnapshotAppLoggingSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "audioRecordingConfigs":
            suggest = "audio_recording_configs"
        elif key == "bigqueryExportSettings":
            suggest = "bigquery_export_settings"
        elif key == "cloudLoggingSettings":
            suggest = "cloud_logging_settings"
        elif key == "conversationLoggingSettings":
            suggest = "conversation_logging_settings"
        elif key == "redactionConfigs":
            suggest = "redaction_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAppLoggingSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAppLoggingSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAppLoggingSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 audio_recording_configs: Optional[Sequence['outputs.AppVersionSnapshotAppLoggingSettingAudioRecordingConfig']] = None,
                 bigquery_export_settings: Optional[Sequence['outputs.AppVersionSnapshotAppLoggingSettingBigqueryExportSetting']] = None,
                 cloud_logging_settings: Optional[Sequence['outputs.AppVersionSnapshotAppLoggingSettingCloudLoggingSetting']] = None,
                 conversation_logging_settings: Optional[Sequence['outputs.AppVersionSnapshotAppLoggingSettingConversationLoggingSetting']] = None,
                 redaction_configs: Optional[Sequence['outputs.AppVersionSnapshotAppLoggingSettingRedactionConfig']] = None):
        """
        :param Sequence['AppVersionSnapshotAppLoggingSettingAudioRecordingConfigArgs'] audio_recording_configs: (Output)
               Configuration for how the audio interactions should be recorded.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotAppLoggingSettingBigqueryExportSettingArgs'] bigquery_export_settings: (Output)
               Settings to describe the BigQuery export behaviors for the app.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotAppLoggingSettingCloudLoggingSettingArgs'] cloud_logging_settings: (Output)
               Settings to describe the Cloud Logging behaviors for the app.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotAppLoggingSettingConversationLoggingSettingArgs'] conversation_logging_settings: (Output)
               Settings to describe the conversation logging behaviors for the app.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotAppLoggingSettingRedactionConfigArgs'] redaction_configs: (Output)
               Configuration to instruct how sensitive data should be handled.
               Structure is documented below.
        """
        if audio_recording_configs is not None:
            pulumi.set(__self__, "audio_recording_configs", audio_recording_configs)
        if bigquery_export_settings is not None:
            pulumi.set(__self__, "bigquery_export_settings", bigquery_export_settings)
        if cloud_logging_settings is not None:
            pulumi.set(__self__, "cloud_logging_settings", cloud_logging_settings)
        if conversation_logging_settings is not None:
            pulumi.set(__self__, "conversation_logging_settings", conversation_logging_settings)
        if redaction_configs is not None:
            pulumi.set(__self__, "redaction_configs", redaction_configs)

    @_builtins.property
    @pulumi.getter(name="audioRecordingConfigs")
    def audio_recording_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppLoggingSettingAudioRecordingConfig']]:
        """
        (Output)
        Configuration for how the audio interactions should be recorded.
        Structure is documented below.
        """
        return pulumi.get(self, "audio_recording_configs")

    @_builtins.property
    @pulumi.getter(name="bigqueryExportSettings")
    def bigquery_export_settings(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppLoggingSettingBigqueryExportSetting']]:
        """
        (Output)
        Settings to describe the BigQuery export behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "bigquery_export_settings")

    @_builtins.property
    @pulumi.getter(name="cloudLoggingSettings")
    def cloud_logging_settings(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppLoggingSettingCloudLoggingSetting']]:
        """
        (Output)
        Settings to describe the Cloud Logging behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_logging_settings")

    @_builtins.property
    @pulumi.getter(name="conversationLoggingSettings")
    def conversation_logging_settings(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppLoggingSettingConversationLoggingSetting']]:
        """
        (Output)
        Settings to describe the conversation logging behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_logging_settings")

    @_builtins.property
    @pulumi.getter(name="redactionConfigs")
    def redaction_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppLoggingSettingRedactionConfig']]:
        """
        (Output)
        Configuration to instruct how sensitive data should be handled.
        Structure is documented below.
        """
        return pulumi.get(self, "redaction_configs")


@pulumi.output_type
class AppVersionSnapshotAppLoggingSettingAudioRecordingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "gcsBucket":
            suggest = "gcs_bucket"
        elif key == "gcsPathPrefix":
            suggest = "gcs_path_prefix"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAppLoggingSettingAudioRecordingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAppLoggingSettingAudioRecordingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAppLoggingSettingAudioRecordingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 gcs_bucket: Optional[_builtins.str] = None,
                 gcs_path_prefix: Optional[_builtins.str] = None):
        """
        :param _builtins.str gcs_bucket: (Output)
               The [Cloud Storage](https://cloud.google.com/storage) bucket to store the
               session audio recordings. The URI must start with "gs://".
               Note: If the Cloud Storage bucket is in a different project from the app,
               you should grant `storage.objects.create` permission to the CES service
               agent `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param _builtins.str gcs_path_prefix: (Output)
               The Cloud Storage path prefix for audio recordings.
               This prefix can include the following placeholders, which will be
               dynamically substituted at serving time:
               - $project:   project ID
               - $location:  app location
               - $app:       app ID
               - $date:      session date in YYYY-MM-DD format
               - $session:   session ID
               If the path prefix is not specified, the default prefix
               `$project/$location/$app/$date/$session/` will be used.
        """
        if gcs_bucket is not None:
            pulumi.set(__self__, "gcs_bucket", gcs_bucket)
        if gcs_path_prefix is not None:
            pulumi.set(__self__, "gcs_path_prefix", gcs_path_prefix)

    @_builtins.property
    @pulumi.getter(name="gcsBucket")
    def gcs_bucket(self) -> Optional[_builtins.str]:
        """
        (Output)
        The [Cloud Storage](https://cloud.google.com/storage) bucket to store the
        session audio recordings. The URI must start with "gs://".
        Note: If the Cloud Storage bucket is in a different project from the app,
        you should grant `storage.objects.create` permission to the CES service
        agent `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "gcs_bucket")

    @_builtins.property
    @pulumi.getter(name="gcsPathPrefix")
    def gcs_path_prefix(self) -> Optional[_builtins.str]:
        """
        (Output)
        The Cloud Storage path prefix for audio recordings.
        This prefix can include the following placeholders, which will be
        dynamically substituted at serving time:
        - $project:   project ID
        - $location:  app location
        - $app:       app ID
        - $date:      session date in YYYY-MM-DD format
        - $session:   session ID
        If the path prefix is not specified, the default prefix
        `$project/$location/$app/$date/$session/` will be used.
        """
        return pulumi.get(self, "gcs_path_prefix")


@pulumi.output_type
class AppVersionSnapshotAppLoggingSettingBigqueryExportSetting(dict):
    def __init__(__self__, *,
                 dataset: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 project: Optional[_builtins.str] = None):
        """
        :param _builtins.str dataset: (Output)
               The BigQuery dataset to export the data to.
        :param _builtins.bool enabled: (Output)
               Whether the guardrail is enabled.
        :param _builtins.str project: The ID of the project in which the resource belongs.
               If it is not provided, the provider project is used.
        """
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if project is not None:
            pulumi.set(__self__, "project", project)

    @_builtins.property
    @pulumi.getter
    def dataset(self) -> Optional[_builtins.str]:
        """
        (Output)
        The BigQuery dataset to export the data to.
        """
        return pulumi.get(self, "dataset")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether the guardrail is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def project(self) -> Optional[_builtins.str]:
        """
        The ID of the project in which the resource belongs.
        If it is not provided, the provider project is used.
        """
        return pulumi.get(self, "project")


@pulumi.output_type
class AppVersionSnapshotAppLoggingSettingCloudLoggingSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableCloudLogging":
            suggest = "enable_cloud_logging"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAppLoggingSettingCloudLoggingSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAppLoggingSettingCloudLoggingSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAppLoggingSettingCloudLoggingSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_cloud_logging: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool enable_cloud_logging: (Output)
               Whether to enable Cloud Logging for the sessions.
        """
        if enable_cloud_logging is not None:
            pulumi.set(__self__, "enable_cloud_logging", enable_cloud_logging)

    @_builtins.property
    @pulumi.getter(name="enableCloudLogging")
    def enable_cloud_logging(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether to enable Cloud Logging for the sessions.
        """
        return pulumi.get(self, "enable_cloud_logging")


@pulumi.output_type
class AppVersionSnapshotAppLoggingSettingConversationLoggingSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableConversationLogging":
            suggest = "disable_conversation_logging"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAppLoggingSettingConversationLoggingSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAppLoggingSettingConversationLoggingSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAppLoggingSettingConversationLoggingSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_conversation_logging: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool disable_conversation_logging: (Output)
               Whether to disable conversation logging for the sessions.
        """
        if disable_conversation_logging is not None:
            pulumi.set(__self__, "disable_conversation_logging", disable_conversation_logging)

    @_builtins.property
    @pulumi.getter(name="disableConversationLogging")
    def disable_conversation_logging(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether to disable conversation logging for the sessions.
        """
        return pulumi.get(self, "disable_conversation_logging")


@pulumi.output_type
class AppVersionSnapshotAppLoggingSettingRedactionConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "deidentifyTemplate":
            suggest = "deidentify_template"
        elif key == "enableRedaction":
            suggest = "enable_redaction"
        elif key == "inspectTemplate":
            suggest = "inspect_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAppLoggingSettingRedactionConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAppLoggingSettingRedactionConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAppLoggingSettingRedactionConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 deidentify_template: Optional[_builtins.str] = None,
                 enable_redaction: Optional[_builtins.bool] = None,
                 inspect_template: Optional[_builtins.str] = None):
        """
        :param _builtins.str deidentify_template: (Output)
               [DLP](https://cloud.google.com/dlp/docs) deidentify template name to
               instruct on how to de-identify content.
               Format:
               `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
        :param _builtins.bool enable_redaction: (Output)
               If true, redaction will be applied in various logging scenarios, including
               conversation history, Cloud Logging and audio recording.
        :param _builtins.str inspect_template: (Output)
               [DLP](https://cloud.google.com/dlp/docs) inspect template name to configure
               detection of sensitive data types.
               Format:
               `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
        """
        if deidentify_template is not None:
            pulumi.set(__self__, "deidentify_template", deidentify_template)
        if enable_redaction is not None:
            pulumi.set(__self__, "enable_redaction", enable_redaction)
        if inspect_template is not None:
            pulumi.set(__self__, "inspect_template", inspect_template)

    @_builtins.property
    @pulumi.getter(name="deidentifyTemplate")
    def deidentify_template(self) -> Optional[_builtins.str]:
        """
        (Output)
        [DLP](https://cloud.google.com/dlp/docs) deidentify template name to
        instruct on how to de-identify content.
        Format:
        `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
        """
        return pulumi.get(self, "deidentify_template")

    @_builtins.property
    @pulumi.getter(name="enableRedaction")
    def enable_redaction(self) -> Optional[_builtins.bool]:
        """
        (Output)
        If true, redaction will be applied in various logging scenarios, including
        conversation history, Cloud Logging and audio recording.
        """
        return pulumi.get(self, "enable_redaction")

    @_builtins.property
    @pulumi.getter(name="inspectTemplate")
    def inspect_template(self) -> Optional[_builtins.str]:
        """
        (Output)
        [DLP](https://cloud.google.com/dlp/docs) inspect template name to configure
        detection of sensitive data types.
        Format:
        `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
        """
        return pulumi.get(self, "inspect_template")


@pulumi.output_type
class AppVersionSnapshotAppModelSetting(dict):
    def __init__(__self__, *,
                 model: Optional[_builtins.str] = None,
                 temperature: Optional[_builtins.float] = None):
        """
        :param _builtins.str model: (Output)
               The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param _builtins.float temperature: (Output)
               If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        (Output)
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        (Output)
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")


@pulumi.output_type
class AppVersionSnapshotAppTimeZoneSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAppTimeZoneSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAppTimeZoneSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAppTimeZoneSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_zone: Optional[_builtins.str] = None):
        """
        :param _builtins.str time_zone: (Output)
               The time zone of the app from the time zone database, e.g., America/Los_Angeles, Europe/Paris.
        """
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[_builtins.str]:
        """
        (Output)
        The time zone of the app from the time zone database, e.g., America/Los_Angeles, Europe/Paris.
        """
        return pulumi.get(self, "time_zone")


@pulumi.output_type
class AppVersionSnapshotAppVariableDeclaration(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 schemas: Optional[Sequence['outputs.AppVersionSnapshotAppVariableDeclarationSchema']] = None):
        """
        :param _builtins.str description: The description of the app version.
        :param _builtins.str name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param Sequence['AppVersionSnapshotAppVariableDeclarationSchemaArgs'] schemas: (Output)
               Represents a select subset of an OpenAPI 3.0 schema object.
               Structure is documented below.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def schemas(self) -> Optional[Sequence['outputs.AppVersionSnapshotAppVariableDeclarationSchema']]:
        """
        (Output)
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        return pulumi.get(self, "schemas")


@pulumi.output_type
class AppVersionSnapshotAppVariableDeclarationSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalProperties":
            suggest = "additional_properties"
        elif key == "anyOf":
            suggest = "any_of"
        elif key == "prefixItems":
            suggest = "prefix_items"
        elif key == "uniqueItems":
            suggest = "unique_items"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotAppVariableDeclarationSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotAppVariableDeclarationSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotAppVariableDeclarationSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_properties: Optional[_builtins.str] = None,
                 any_of: Optional[_builtins.str] = None,
                 default: Optional[_builtins.str] = None,
                 defs: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 enums: Optional[Sequence[_builtins.str]] = None,
                 items: Optional[_builtins.str] = None,
                 nullable: Optional[_builtins.bool] = None,
                 prefix_items: Optional[_builtins.str] = None,
                 properties: Optional[_builtins.str] = None,
                 ref: Optional[_builtins.str] = None,
                 requireds: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None,
                 unique_items: Optional[_builtins.bool] = None):
        """
        :param _builtins.str additional_properties: (Output)
               Optional. Defines the schema for additional properties allowed in an object.
               The value must be a valid JSON string representing the Schema object.
               (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        :param _builtins.str any_of: (Output)
               Optional. The instance value should be valid against at least one of the schemas in this list.
        :param _builtins.str default: (Output)
               Optional. Default value of the data. Represents a dynamically typed value
               which can be either null, a number, a string, a boolean, a struct,
               or a list of values. The provided default value must be compatible
               with the defined 'type' and other schema constraints.
        :param _builtins.str defs: (Output)
               A map of definitions for use by ref. Only allowed at the root of the schema.
        :param _builtins.str description: The description of the app version.
        :param Sequence[_builtins.str] enums: (Output)
               Possible values of the element of primitive type with enum format.
               Examples:
               1. We can define direction as :
               {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
               2. We can define apartment number as :
               {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        :param _builtins.str items: (Output)
               Schema of the elements of Type.ARRAY.
        :param _builtins.bool nullable: (Output)
               Indicates if the value may be null.
        :param _builtins.str prefix_items: (Output)
               Optional. Schemas of initial elements of Type.ARRAY.
        :param _builtins.str properties: (Output)
               Properties of Type.OBJECT.
        :param _builtins.str ref: (Output)
               Allows indirect references between schema nodes. The value should be a
               valid reference to a child of the root `defs`.
               For example, the following schema defines a reference to a schema node
               named "Pet":
               type: object
               properties:
               pet:
               ref: #/defs/Pet
               defs:
               Pet:
               type: object
               properties:
               name:
               type: string
               The value of the "pet" property is a reference to the schema node
               named "Pet".
               See details in
               https://json-schema.org/understanding-json-schema/structuring.
        :param Sequence[_builtins.str] requireds: (Output)
               Required properties of Type.OBJECT.
        :param _builtins.str type: (Output)
               The type of the data store. This field is readonly and populated by the
               server.
               Possible values:
               PUBLIC_WEB
               UNSTRUCTURED
               FAQ
               CONNECTOR
        :param _builtins.bool unique_items: (Output)
               Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if any_of is not None:
            pulumi.set(__self__, "any_of", any_of)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if defs is not None:
            pulumi.set(__self__, "defs", defs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enums is not None:
            pulumi.set(__self__, "enums", enums)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if prefix_items is not None:
            pulumi.set(__self__, "prefix_items", prefix_items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if requireds is not None:
            pulumi.set(__self__, "requireds", requireds)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)

    @_builtins.property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[_builtins.str]:
        """
        (Output)
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        return pulumi.get(self, "additional_properties")

    @_builtins.property
    @pulumi.getter(name="anyOf")
    def any_of(self) -> Optional[_builtins.str]:
        """
        (Output)
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        return pulumi.get(self, "any_of")

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        """
        (Output)
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def defs(self) -> Optional[_builtins.str]:
        """
        (Output)
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        return pulumi.get(self, "defs")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def enums(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        return pulumi.get(self, "enums")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[_builtins.str]:
        """
        (Output)
        Schema of the elements of Type.ARRAY.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Indicates if the value may be null.
        """
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="prefixItems")
    def prefix_items(self) -> Optional[_builtins.str]:
        """
        (Output)
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        return pulumi.get(self, "prefix_items")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[_builtins.str]:
        """
        (Output)
        Properties of Type.OBJECT.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[_builtins.str]:
        """
        (Output)
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        return pulumi.get(self, "ref")

    @_builtins.property
    @pulumi.getter
    def requireds(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        Required properties of Type.OBJECT.
        """
        return pulumi.get(self, "requireds")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        return pulumi.get(self, "unique_items")


@pulumi.output_type
class AppVersionSnapshotExample(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createTime":
            suggest = "create_time"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "entryAgent":
            suggest = "entry_agent"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotExample. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotExample.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotExample.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_time: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 entry_agent: Optional[_builtins.str] = None,
                 etag: Optional[_builtins.str] = None,
                 invalid: Optional[_builtins.bool] = None,
                 messages: Optional[Sequence['outputs.AppVersionSnapshotExampleMessage']] = None,
                 name: Optional[_builtins.str] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str create_time: (Output)
               Timestamp when the toolset was created.
        :param _builtins.str description: The description of the app version.
        :param _builtins.str display_name: The display name of the app version.
        :param _builtins.str entry_agent: (Output)
               The agent that initially handles the conversation. If not specified, the
               example represents a conversation that is handled by the root agent.
               Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        :param _builtins.str etag: (Output)
               ETag used to ensure the object hasn't changed during a read-modify-write
               operation. If the etag is empty, the update will overwrite any concurrent
               changes.
        :param _builtins.bool invalid: (Output)
               The example may become invalid if referencing resources are deleted.
               Invalid examples will not be used as few-shot examples.
        :param Sequence['AppVersionSnapshotExampleMessageArgs'] messages: (Output)
               The collection of messages that make up the conversation.
               Structure is documented below.
        :param _builtins.str name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param _builtins.str update_time: (Output)
               Timestamp when the toolset was last updated.
        """
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if entry_agent is not None:
            pulumi.set(__self__, "entry_agent", entry_agent)
        if etag is not None:
            pulumi.set(__self__, "etag", etag)
        if invalid is not None:
            pulumi.set(__self__, "invalid", invalid)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        Timestamp when the toolset was created.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="entryAgent")
    def entry_agent(self) -> Optional[_builtins.str]:
        """
        (Output)
        The agent that initially handles the conversation. If not specified, the
        example represents a conversation that is handled by the root agent.
        Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        return pulumi.get(self, "entry_agent")

    @_builtins.property
    @pulumi.getter
    def etag(self) -> Optional[_builtins.str]:
        """
        (Output)
        ETag used to ensure the object hasn't changed during a read-modify-write
        operation. If the etag is empty, the update will overwrite any concurrent
        changes.
        """
        return pulumi.get(self, "etag")

    @_builtins.property
    @pulumi.getter
    def invalid(self) -> Optional[_builtins.bool]:
        """
        (Output)
        The example may become invalid if referencing resources are deleted.
        Invalid examples will not be used as few-shot examples.
        """
        return pulumi.get(self, "invalid")

    @_builtins.property
    @pulumi.getter
    def messages(self) -> Optional[Sequence['outputs.AppVersionSnapshotExampleMessage']]:
        """
        (Output)
        The collection of messages that make up the conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "messages")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        Timestamp when the toolset was last updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class AppVersionSnapshotExampleMessage(dict):
    def __init__(__self__, *,
                 chunks: Optional[Sequence['outputs.AppVersionSnapshotExampleMessageChunk']] = None,
                 role: Optional[_builtins.str] = None):
        """
        :param Sequence['AppVersionSnapshotExampleMessageChunkArgs'] chunks: (Output)
               Content of the message as a series of chunks.
               Structure is documented below.
        :param _builtins.str role: (Output)
               The role within the conversation, e.g., user, agent.
        """
        if chunks is not None:
            pulumi.set(__self__, "chunks", chunks)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def chunks(self) -> Optional[Sequence['outputs.AppVersionSnapshotExampleMessageChunk']]:
        """
        (Output)
        Content of the message as a series of chunks.
        Structure is documented below.
        """
        return pulumi.get(self, "chunks")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        (Output)
        The role within the conversation, e.g., user, agent.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class AppVersionSnapshotExampleMessageChunk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentTransfers":
            suggest = "agent_transfers"
        elif key == "toolCalls":
            suggest = "tool_calls"
        elif key == "toolResponses":
            suggest = "tool_responses"
        elif key == "updatedVariables":
            suggest = "updated_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotExampleMessageChunk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotExampleMessageChunk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotExampleMessageChunk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_transfers: Optional[Sequence['outputs.AppVersionSnapshotExampleMessageChunkAgentTransfer']] = None,
                 images: Optional[Sequence['outputs.AppVersionSnapshotExampleMessageChunkImage']] = None,
                 text: Optional[_builtins.str] = None,
                 tool_calls: Optional[Sequence['outputs.AppVersionSnapshotExampleMessageChunkToolCall']] = None,
                 tool_responses: Optional[Sequence['outputs.AppVersionSnapshotExampleMessageChunkToolResponse']] = None,
                 updated_variables: Optional[_builtins.str] = None):
        """
        :param Sequence['AppVersionSnapshotExampleMessageChunkAgentTransferArgs'] agent_transfers: (Output)
               Represents an event indicating the transfer of a conversation to a different
               agent.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotExampleMessageChunkImageArgs'] images: (Output)
               Represents an image input or output in the conversation.
               Structure is documented below.
        :param _builtins.str text: (Output)
               Text for the agent to respond with.
        :param Sequence['AppVersionSnapshotExampleMessageChunkToolCallArgs'] tool_calls: (Output)
               Request for the client or the agent to execute the specified tool.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotExampleMessageChunkToolResponseArgs'] tool_responses: (Output)
               The execution result of a specific tool from the client or the agent.
               Structure is documented below.
        :param _builtins.str updated_variables: (Output)
               A struct represents variables that were updated in the conversation,
               keyed by variable names.
        """
        if agent_transfers is not None:
            pulumi.set(__self__, "agent_transfers", agent_transfers)
        if images is not None:
            pulumi.set(__self__, "images", images)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if tool_calls is not None:
            pulumi.set(__self__, "tool_calls", tool_calls)
        if tool_responses is not None:
            pulumi.set(__self__, "tool_responses", tool_responses)
        if updated_variables is not None:
            pulumi.set(__self__, "updated_variables", updated_variables)

    @_builtins.property
    @pulumi.getter(name="agentTransfers")
    def agent_transfers(self) -> Optional[Sequence['outputs.AppVersionSnapshotExampleMessageChunkAgentTransfer']]:
        """
        (Output)
        Represents an event indicating the transfer of a conversation to a different
        agent.
        Structure is documented below.
        """
        return pulumi.get(self, "agent_transfers")

    @_builtins.property
    @pulumi.getter
    def images(self) -> Optional[Sequence['outputs.AppVersionSnapshotExampleMessageChunkImage']]:
        """
        (Output)
        Represents an image input or output in the conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "images")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        (Output)
        Text for the agent to respond with.
        """
        return pulumi.get(self, "text")

    @_builtins.property
    @pulumi.getter(name="toolCalls")
    def tool_calls(self) -> Optional[Sequence['outputs.AppVersionSnapshotExampleMessageChunkToolCall']]:
        """
        (Output)
        Request for the client or the agent to execute the specified tool.
        Structure is documented below.
        """
        return pulumi.get(self, "tool_calls")

    @_builtins.property
    @pulumi.getter(name="toolResponses")
    def tool_responses(self) -> Optional[Sequence['outputs.AppVersionSnapshotExampleMessageChunkToolResponse']]:
        """
        (Output)
        The execution result of a specific tool from the client or the agent.
        Structure is documented below.
        """
        return pulumi.get(self, "tool_responses")

    @_builtins.property
    @pulumi.getter(name="updatedVariables")
    def updated_variables(self) -> Optional[_builtins.str]:
        """
        (Output)
        A struct represents variables that were updated in the conversation,
        keyed by variable names.
        """
        return pulumi.get(self, "updated_variables")


@pulumi.output_type
class AppVersionSnapshotExampleMessageChunkAgentTransfer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "targetAgent":
            suggest = "target_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotExampleMessageChunkAgentTransfer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotExampleMessageChunkAgentTransfer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotExampleMessageChunkAgentTransfer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[_builtins.str] = None,
                 target_agent: Optional[_builtins.str] = None):
        """
        :param _builtins.str display_name: The display name of the app version.
        :param _builtins.str target_agent: (Output)
               The agent to which the conversation is being transferred. The agent will
               handle the conversation from this point forward.
               Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if target_agent is not None:
            pulumi.set(__self__, "target_agent", target_agent)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="targetAgent")
    def target_agent(self) -> Optional[_builtins.str]:
        """
        (Output)
        The agent to which the conversation is being transferred. The agent will
        handle the conversation from this point forward.
        Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        return pulumi.get(self, "target_agent")


@pulumi.output_type
class AppVersionSnapshotExampleMessageChunkImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mimeType":
            suggest = "mime_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotExampleMessageChunkImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotExampleMessageChunkImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotExampleMessageChunkImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data: Optional[_builtins.str] = None,
                 mime_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str data: (Output)
               Raw bytes of the image.
        :param _builtins.str mime_type: (Output)
               The IANA standard MIME type of the source data.
               Supported image types includes:
               * image/png
               * image/jpeg
               * image/webp
        """
        if data is not None:
            pulumi.set(__self__, "data", data)
        if mime_type is not None:
            pulumi.set(__self__, "mime_type", mime_type)

    @_builtins.property
    @pulumi.getter
    def data(self) -> Optional[_builtins.str]:
        """
        (Output)
        Raw bytes of the image.
        """
        return pulumi.get(self, "data")

    @_builtins.property
    @pulumi.getter(name="mimeType")
    def mime_type(self) -> Optional[_builtins.str]:
        """
        (Output)
        The IANA standard MIME type of the source data.
        Supported image types includes:
        * image/png
        * image/jpeg
        * image/webp
        """
        return pulumi.get(self, "mime_type")


@pulumi.output_type
class AppVersionSnapshotExampleMessageChunkToolCall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "toolsetTools":
            suggest = "toolset_tools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotExampleMessageChunkToolCall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotExampleMessageChunkToolCall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotExampleMessageChunkToolCall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 args: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 tool: Optional[_builtins.str] = None,
                 toolset_tools: Optional[Sequence['outputs.AppVersionSnapshotExampleMessageChunkToolCallToolsetTool']] = None):
        """
        :param _builtins.str args: (Output)
               The input parameters and values for the tool in JSON object format.
        :param _builtins.str display_name: The display name of the app version.
        :param _builtins.str id: (Output)
               The matching ID of the tool call the response is for.
        :param _builtins.str tool: (Output)
               The name of the tool to execute.
               Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        :param Sequence['AppVersionSnapshotExampleMessageChunkToolCallToolsetToolArgs'] toolset_tools: (Output)
               A tool that is created from a toolset.
               Structure is documented below.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if tool is not None:
            pulumi.set(__self__, "tool", tool)
        if toolset_tools is not None:
            pulumi.set(__self__, "toolset_tools", toolset_tools)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[_builtins.str]:
        """
        (Output)
        The input parameters and values for the tool in JSON object format.
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        (Output)
        The matching ID of the tool call the response is for.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def tool(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the tool to execute.
        Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        """
        return pulumi.get(self, "tool")

    @_builtins.property
    @pulumi.getter(name="toolsetTools")
    def toolset_tools(self) -> Optional[Sequence['outputs.AppVersionSnapshotExampleMessageChunkToolCallToolsetTool']]:
        """
        (Output)
        A tool that is created from a toolset.
        Structure is documented below.
        """
        return pulumi.get(self, "toolset_tools")


@pulumi.output_type
class AppVersionSnapshotExampleMessageChunkToolCallToolsetTool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toolId":
            suggest = "tool_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotExampleMessageChunkToolCallToolsetTool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotExampleMessageChunkToolCallToolsetTool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotExampleMessageChunkToolCallToolsetTool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tool_id: Optional[_builtins.str] = None,
                 toolset: Optional[_builtins.str] = None):
        """
        :param _builtins.str tool_id: (Output)
               The tool ID to filter the tools to retrieve the schema for.
        :param _builtins.str toolset: (Output)
               The resource name of the Toolset from which this tool is derived.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        if tool_id is not None:
            pulumi.set(__self__, "tool_id", tool_id)
        if toolset is not None:
            pulumi.set(__self__, "toolset", toolset)

    @_builtins.property
    @pulumi.getter(name="toolId")
    def tool_id(self) -> Optional[_builtins.str]:
        """
        (Output)
        The tool ID to filter the tools to retrieve the schema for.
        """
        return pulumi.get(self, "tool_id")

    @_builtins.property
    @pulumi.getter
    def toolset(self) -> Optional[_builtins.str]:
        """
        (Output)
        The resource name of the Toolset from which this tool is derived.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "toolset")


@pulumi.output_type
class AppVersionSnapshotExampleMessageChunkToolResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "toolsetTools":
            suggest = "toolset_tools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotExampleMessageChunkToolResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotExampleMessageChunkToolResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotExampleMessageChunkToolResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 response: Optional[_builtins.str] = None,
                 tool: Optional[_builtins.str] = None,
                 toolset_tools: Optional[Sequence['outputs.AppVersionSnapshotExampleMessageChunkToolResponseToolsetTool']] = None):
        """
        :param _builtins.str display_name: The display name of the app version.
        :param _builtins.str id: (Output)
               The matching ID of the tool call the response is for.
        :param _builtins.str response: (Output)
               Represents a select subset of an OpenAPI 3.0 schema object.
               Structure is documented below.
        :param _builtins.str tool: (Output)
               The name of the tool to execute.
               Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        :param Sequence['AppVersionSnapshotExampleMessageChunkToolResponseToolsetToolArgs'] toolset_tools: (Output)
               A tool that is created from a toolset.
               Structure is documented below.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if tool is not None:
            pulumi.set(__self__, "tool", tool)
        if toolset_tools is not None:
            pulumi.set(__self__, "toolset_tools", toolset_tools)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        (Output)
        The matching ID of the tool call the response is for.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[_builtins.str]:
        """
        (Output)
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        return pulumi.get(self, "response")

    @_builtins.property
    @pulumi.getter
    def tool(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the tool to execute.
        Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        """
        return pulumi.get(self, "tool")

    @_builtins.property
    @pulumi.getter(name="toolsetTools")
    def toolset_tools(self) -> Optional[Sequence['outputs.AppVersionSnapshotExampleMessageChunkToolResponseToolsetTool']]:
        """
        (Output)
        A tool that is created from a toolset.
        Structure is documented below.
        """
        return pulumi.get(self, "toolset_tools")


@pulumi.output_type
class AppVersionSnapshotExampleMessageChunkToolResponseToolsetTool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toolId":
            suggest = "tool_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotExampleMessageChunkToolResponseToolsetTool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotExampleMessageChunkToolResponseToolsetTool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotExampleMessageChunkToolResponseToolsetTool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 tool_id: Optional[_builtins.str] = None,
                 toolset: Optional[_builtins.str] = None):
        """
        :param _builtins.str tool_id: (Output)
               The tool ID to filter the tools to retrieve the schema for.
        :param _builtins.str toolset: (Output)
               The resource name of the Toolset from which this tool is derived.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        if tool_id is not None:
            pulumi.set(__self__, "tool_id", tool_id)
        if toolset is not None:
            pulumi.set(__self__, "toolset", toolset)

    @_builtins.property
    @pulumi.getter(name="toolId")
    def tool_id(self) -> Optional[_builtins.str]:
        """
        (Output)
        The tool ID to filter the tools to retrieve the schema for.
        """
        return pulumi.get(self, "tool_id")

    @_builtins.property
    @pulumi.getter
    def toolset(self) -> Optional[_builtins.str]:
        """
        (Output)
        The resource name of the Toolset from which this tool is derived.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "toolset")


@pulumi.output_type
class AppVersionSnapshotGuardrail(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "codeCallbacks":
            suggest = "code_callbacks"
        elif key == "contentFilters":
            suggest = "content_filters"
        elif key == "createTime":
            suggest = "create_time"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "llmPolicies":
            suggest = "llm_policies"
        elif key == "llmPromptSecurities":
            suggest = "llm_prompt_securities"
        elif key == "modelSafeties":
            suggest = "model_safeties"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotGuardrail. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotGuardrail.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotGuardrail.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 actions: Optional[Sequence['outputs.AppVersionSnapshotGuardrailAction']] = None,
                 code_callbacks: Optional[Sequence['outputs.AppVersionSnapshotGuardrailCodeCallback']] = None,
                 content_filters: Optional[Sequence['outputs.AppVersionSnapshotGuardrailContentFilter']] = None,
                 create_time: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 etag: Optional[_builtins.str] = None,
                 llm_policies: Optional[Sequence['outputs.AppVersionSnapshotGuardrailLlmPolicy']] = None,
                 llm_prompt_securities: Optional[Sequence['outputs.AppVersionSnapshotGuardrailLlmPromptSecurity']] = None,
                 model_safeties: Optional[Sequence['outputs.AppVersionSnapshotGuardrailModelSafety']] = None,
                 name: Optional[_builtins.str] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param Sequence['AppVersionSnapshotGuardrailActionArgs'] actions: (Output)
               Action that is taken when a certain precondition is met.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotGuardrailCodeCallbackArgs'] code_callbacks: (Output)
               Guardrail that blocks the conversation based on the code callbacks
               provided.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotGuardrailContentFilterArgs'] content_filters: (Output)
               Guardrail that bans certain content from being used in the conversation.
               Structure is documented below.
        :param _builtins.str create_time: (Output)
               Timestamp when the toolset was created.
        :param _builtins.str description: The description of the app version.
        :param _builtins.str display_name: The display name of the app version.
        :param _builtins.bool enabled: (Output)
               Whether the guardrail is enabled.
        :param _builtins.str etag: (Output)
               ETag used to ensure the object hasn't changed during a read-modify-write
               operation. If the etag is empty, the update will overwrite any concurrent
               changes.
        :param Sequence['AppVersionSnapshotGuardrailLlmPolicyArgs'] llm_policies: (Output)
               Guardrail that blocks the conversation if the LLM response is considered
               violating the policy based on the LLM classification.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotGuardrailLlmPromptSecurityArgs'] llm_prompt_securities: (Output)
               Guardrail that blocks the conversation if the input is considered unsafe
               based on the LLM classification.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotGuardrailModelSafetyArgs'] model_safeties: (Output)
               Model safety settings overrides. When this is set, it will override the
               default settings and trigger the guardrail if the response is considered
               unsafe.
               Structure is documented below.
        :param _builtins.str name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param _builtins.str update_time: (Output)
               Timestamp when the toolset was last updated.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if code_callbacks is not None:
            pulumi.set(__self__, "code_callbacks", code_callbacks)
        if content_filters is not None:
            pulumi.set(__self__, "content_filters", content_filters)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if etag is not None:
            pulumi.set(__self__, "etag", etag)
        if llm_policies is not None:
            pulumi.set(__self__, "llm_policies", llm_policies)
        if llm_prompt_securities is not None:
            pulumi.set(__self__, "llm_prompt_securities", llm_prompt_securities)
        if model_safeties is not None:
            pulumi.set(__self__, "model_safeties", model_safeties)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrailAction']]:
        """
        (Output)
        Action that is taken when a certain precondition is met.
        Structure is documented below.
        """
        return pulumi.get(self, "actions")

    @_builtins.property
    @pulumi.getter(name="codeCallbacks")
    def code_callbacks(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrailCodeCallback']]:
        """
        (Output)
        Guardrail that blocks the conversation based on the code callbacks
        provided.
        Structure is documented below.
        """
        return pulumi.get(self, "code_callbacks")

    @_builtins.property
    @pulumi.getter(name="contentFilters")
    def content_filters(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrailContentFilter']]:
        """
        (Output)
        Guardrail that bans certain content from being used in the conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "content_filters")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        Timestamp when the toolset was created.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether the guardrail is enabled.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def etag(self) -> Optional[_builtins.str]:
        """
        (Output)
        ETag used to ensure the object hasn't changed during a read-modify-write
        operation. If the etag is empty, the update will overwrite any concurrent
        changes.
        """
        return pulumi.get(self, "etag")

    @_builtins.property
    @pulumi.getter(name="llmPolicies")
    def llm_policies(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrailLlmPolicy']]:
        """
        (Output)
        Guardrail that blocks the conversation if the LLM response is considered
        violating the policy based on the LLM classification.
        Structure is documented below.
        """
        return pulumi.get(self, "llm_policies")

    @_builtins.property
    @pulumi.getter(name="llmPromptSecurities")
    def llm_prompt_securities(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrailLlmPromptSecurity']]:
        """
        (Output)
        Guardrail that blocks the conversation if the input is considered unsafe
        based on the LLM classification.
        Structure is documented below.
        """
        return pulumi.get(self, "llm_prompt_securities")

    @_builtins.property
    @pulumi.getter(name="modelSafeties")
    def model_safeties(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrailModelSafety']]:
        """
        (Output)
        Model safety settings overrides. When this is set, it will override the
        default settings and trigger the guardrail if the response is considered
        unsafe.
        Structure is documented below.
        """
        return pulumi.get(self, "model_safeties")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        Timestamp when the toolset was last updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class AppVersionSnapshotGuardrailAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "generativeAnswers":
            suggest = "generative_answers"
        elif key == "respondImmediatelies":
            suggest = "respond_immediatelies"
        elif key == "transferAgents":
            suggest = "transfer_agents"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotGuardrailAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotGuardrailAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotGuardrailAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 generative_answers: Optional[Sequence['outputs.AppVersionSnapshotGuardrailActionGenerativeAnswer']] = None,
                 respond_immediatelies: Optional[Sequence['outputs.AppVersionSnapshotGuardrailActionRespondImmediately']] = None,
                 transfer_agents: Optional[Sequence['outputs.AppVersionSnapshotGuardrailActionTransferAgent']] = None):
        """
        :param Sequence['AppVersionSnapshotGuardrailActionGenerativeAnswerArgs'] generative_answers: (Output)
               The agent will immediately respond with a generative answer.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotGuardrailActionRespondImmediatelyArgs'] respond_immediatelies: (Output)
               The agent will immediately respond with a preconfigured response.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotGuardrailActionTransferAgentArgs'] transfer_agents: (Output)
               The agent will transfer the conversation to a different agent.
               Structure is documented below.
        """
        if generative_answers is not None:
            pulumi.set(__self__, "generative_answers", generative_answers)
        if respond_immediatelies is not None:
            pulumi.set(__self__, "respond_immediatelies", respond_immediatelies)
        if transfer_agents is not None:
            pulumi.set(__self__, "transfer_agents", transfer_agents)

    @_builtins.property
    @pulumi.getter(name="generativeAnswers")
    def generative_answers(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrailActionGenerativeAnswer']]:
        """
        (Output)
        The agent will immediately respond with a generative answer.
        Structure is documented below.
        """
        return pulumi.get(self, "generative_answers")

    @_builtins.property
    @pulumi.getter(name="respondImmediatelies")
    def respond_immediatelies(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrailActionRespondImmediately']]:
        """
        (Output)
        The agent will immediately respond with a preconfigured response.
        Structure is documented below.
        """
        return pulumi.get(self, "respond_immediatelies")

    @_builtins.property
    @pulumi.getter(name="transferAgents")
    def transfer_agents(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrailActionTransferAgent']]:
        """
        (Output)
        The agent will transfer the conversation to a different agent.
        Structure is documented below.
        """
        return pulumi.get(self, "transfer_agents")


@pulumi.output_type
class AppVersionSnapshotGuardrailActionGenerativeAnswer(dict):
    def __init__(__self__, *,
                 prompt: Optional[_builtins.str] = None):
        """
        :param _builtins.str prompt: (Output)
               The prompt definition. If not set, default prompt will be used.
        """
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[_builtins.str]:
        """
        (Output)
        The prompt definition. If not set, default prompt will be used.
        """
        return pulumi.get(self, "prompt")


@pulumi.output_type
class AppVersionSnapshotGuardrailActionRespondImmediately(dict):
    def __init__(__self__, *,
                 responses: Optional[Sequence['outputs.AppVersionSnapshotGuardrailActionRespondImmediatelyResponse']] = None):
        """
        :param Sequence['AppVersionSnapshotGuardrailActionRespondImmediatelyResponseArgs'] responses: (Output)
               The canned responses for the agent to choose from. The response is chosen
               randomly.
               Structure is documented below.
        """
        if responses is not None:
            pulumi.set(__self__, "responses", responses)

    @_builtins.property
    @pulumi.getter
    def responses(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrailActionRespondImmediatelyResponse']]:
        """
        (Output)
        The canned responses for the agent to choose from. The response is chosen
        randomly.
        Structure is documented below.
        """
        return pulumi.get(self, "responses")


@pulumi.output_type
class AppVersionSnapshotGuardrailActionRespondImmediatelyResponse(dict):
    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 text: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disabled: (Output)
               Whether summarization is disabled.
        :param _builtins.str text: (Output)
               Text for the agent to respond with.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        (Output)
        Text for the agent to respond with.
        """
        return pulumi.get(self, "text")


@pulumi.output_type
class AppVersionSnapshotGuardrailActionTransferAgent(dict):
    def __init__(__self__, *,
                 agent: Optional[_builtins.str] = None):
        """
        :param _builtins.str agent: (Output)
               The name of the agent to transfer the conversation to. The agent must be
               in the same app as the current agent.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        if agent is not None:
            pulumi.set(__self__, "agent", agent)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the agent to transfer the conversation to. The agent must be
        in the same app as the current agent.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        return pulumi.get(self, "agent")


@pulumi.output_type
class AppVersionSnapshotGuardrailCodeCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "afterAgentCallbacks":
            suggest = "after_agent_callbacks"
        elif key == "afterModelCallbacks":
            suggest = "after_model_callbacks"
        elif key == "beforeAgentCallbacks":
            suggest = "before_agent_callbacks"
        elif key == "beforeModelCallbacks":
            suggest = "before_model_callbacks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotGuardrailCodeCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotGuardrailCodeCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotGuardrailCodeCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 after_agent_callbacks: Optional[Sequence['outputs.AppVersionSnapshotGuardrailCodeCallbackAfterAgentCallback']] = None,
                 after_model_callbacks: Optional[Sequence['outputs.AppVersionSnapshotGuardrailCodeCallbackAfterModelCallback']] = None,
                 before_agent_callbacks: Optional[Sequence['outputs.AppVersionSnapshotGuardrailCodeCallbackBeforeAgentCallback']] = None,
                 before_model_callbacks: Optional[Sequence['outputs.AppVersionSnapshotGuardrailCodeCallbackBeforeModelCallback']] = None):
        """
        :param Sequence['AppVersionSnapshotGuardrailCodeCallbackAfterAgentCallbackArgs'] after_agent_callbacks: (Output)
               A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotGuardrailCodeCallbackAfterModelCallbackArgs'] after_model_callbacks: (Output)
               A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotGuardrailCodeCallbackBeforeAgentCallbackArgs'] before_agent_callbacks: (Output)
               A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotGuardrailCodeCallbackBeforeModelCallbackArgs'] before_model_callbacks: (Output)
               A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        """
        if after_agent_callbacks is not None:
            pulumi.set(__self__, "after_agent_callbacks", after_agent_callbacks)
        if after_model_callbacks is not None:
            pulumi.set(__self__, "after_model_callbacks", after_model_callbacks)
        if before_agent_callbacks is not None:
            pulumi.set(__self__, "before_agent_callbacks", before_agent_callbacks)
        if before_model_callbacks is not None:
            pulumi.set(__self__, "before_model_callbacks", before_model_callbacks)

    @_builtins.property
    @pulumi.getter(name="afterAgentCallbacks")
    def after_agent_callbacks(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrailCodeCallbackAfterAgentCallback']]:
        """
        (Output)
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "after_agent_callbacks")

    @_builtins.property
    @pulumi.getter(name="afterModelCallbacks")
    def after_model_callbacks(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrailCodeCallbackAfterModelCallback']]:
        """
        (Output)
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "after_model_callbacks")

    @_builtins.property
    @pulumi.getter(name="beforeAgentCallbacks")
    def before_agent_callbacks(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrailCodeCallbackBeforeAgentCallback']]:
        """
        (Output)
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "before_agent_callbacks")

    @_builtins.property
    @pulumi.getter(name="beforeModelCallbacks")
    def before_model_callbacks(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrailCodeCallbackBeforeModelCallback']]:
        """
        (Output)
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "before_model_callbacks")


@pulumi.output_type
class AppVersionSnapshotGuardrailCodeCallbackAfterAgentCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotGuardrailCodeCallbackAfterAgentCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotGuardrailCodeCallbackAfterAgentCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotGuardrailCodeCallbackAfterAgentCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 python_code: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: The description of the app version.
        :param _builtins.bool disabled: (Output)
               Whether summarization is disabled.
        :param _builtins.str python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[_builtins.str]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")


@pulumi.output_type
class AppVersionSnapshotGuardrailCodeCallbackAfterModelCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotGuardrailCodeCallbackAfterModelCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotGuardrailCodeCallbackAfterModelCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotGuardrailCodeCallbackAfterModelCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 python_code: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: The description of the app version.
        :param _builtins.bool disabled: (Output)
               Whether summarization is disabled.
        :param _builtins.str python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[_builtins.str]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")


@pulumi.output_type
class AppVersionSnapshotGuardrailCodeCallbackBeforeAgentCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotGuardrailCodeCallbackBeforeAgentCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotGuardrailCodeCallbackBeforeAgentCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotGuardrailCodeCallbackBeforeAgentCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 python_code: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: The description of the app version.
        :param _builtins.bool disabled: (Output)
               Whether summarization is disabled.
        :param _builtins.str python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[_builtins.str]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")


@pulumi.output_type
class AppVersionSnapshotGuardrailCodeCallbackBeforeModelCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotGuardrailCodeCallbackBeforeModelCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotGuardrailCodeCallbackBeforeModelCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotGuardrailCodeCallbackBeforeModelCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None,
                 python_code: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: The description of the app version.
        :param _builtins.bool disabled: (Output)
               Whether summarization is disabled.
        :param _builtins.str python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[_builtins.str]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")


@pulumi.output_type
class AppVersionSnapshotGuardrailContentFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bannedContents":
            suggest = "banned_contents"
        elif key == "bannedContentsInAgentResponses":
            suggest = "banned_contents_in_agent_responses"
        elif key == "bannedContentsInUserInputs":
            suggest = "banned_contents_in_user_inputs"
        elif key == "disregardDiacritics":
            suggest = "disregard_diacritics"
        elif key == "matchType":
            suggest = "match_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotGuardrailContentFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotGuardrailContentFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotGuardrailContentFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 banned_contents: Optional[Sequence[_builtins.str]] = None,
                 banned_contents_in_agent_responses: Optional[Sequence[_builtins.str]] = None,
                 banned_contents_in_user_inputs: Optional[Sequence[_builtins.str]] = None,
                 disregard_diacritics: Optional[_builtins.bool] = None,
                 match_type: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] banned_contents: (Output)
               List of banned phrases. Applies to both user inputs and agent responses.
        :param Sequence[_builtins.str] banned_contents_in_agent_responses: (Output)
               List of banned phrases. Applies only to agent responses.
        :param Sequence[_builtins.str] banned_contents_in_user_inputs: (Output)
               List of banned phrases. Applies only to user inputs.
        :param _builtins.bool disregard_diacritics: (Output)
               If true, diacritics are ignored during matching.
        :param _builtins.str match_type: (Output)
               Match type for the content filter.
               Possible values:
               SIMPLE_STRING_MATCH
               WORD_BOUNDARY_STRING_MATCH
               REGEXP_MATCH
        """
        if banned_contents is not None:
            pulumi.set(__self__, "banned_contents", banned_contents)
        if banned_contents_in_agent_responses is not None:
            pulumi.set(__self__, "banned_contents_in_agent_responses", banned_contents_in_agent_responses)
        if banned_contents_in_user_inputs is not None:
            pulumi.set(__self__, "banned_contents_in_user_inputs", banned_contents_in_user_inputs)
        if disregard_diacritics is not None:
            pulumi.set(__self__, "disregard_diacritics", disregard_diacritics)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)

    @_builtins.property
    @pulumi.getter(name="bannedContents")
    def banned_contents(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        List of banned phrases. Applies to both user inputs and agent responses.
        """
        return pulumi.get(self, "banned_contents")

    @_builtins.property
    @pulumi.getter(name="bannedContentsInAgentResponses")
    def banned_contents_in_agent_responses(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        List of banned phrases. Applies only to agent responses.
        """
        return pulumi.get(self, "banned_contents_in_agent_responses")

    @_builtins.property
    @pulumi.getter(name="bannedContentsInUserInputs")
    def banned_contents_in_user_inputs(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        List of banned phrases. Applies only to user inputs.
        """
        return pulumi.get(self, "banned_contents_in_user_inputs")

    @_builtins.property
    @pulumi.getter(name="disregardDiacritics")
    def disregard_diacritics(self) -> Optional[_builtins.bool]:
        """
        (Output)
        If true, diacritics are ignored during matching.
        """
        return pulumi.get(self, "disregard_diacritics")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        (Output)
        Match type for the content filter.
        Possible values:
        SIMPLE_STRING_MATCH
        WORD_BOUNDARY_STRING_MATCH
        REGEXP_MATCH
        """
        return pulumi.get(self, "match_type")


@pulumi.output_type
class AppVersionSnapshotGuardrailLlmPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failOpen":
            suggest = "fail_open"
        elif key == "maxConversationMessages":
            suggest = "max_conversation_messages"
        elif key == "modelSettings":
            suggest = "model_settings"
        elif key == "policyScope":
            suggest = "policy_scope"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotGuardrailLlmPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotGuardrailLlmPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotGuardrailLlmPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fail_open: Optional[_builtins.bool] = None,
                 max_conversation_messages: Optional[_builtins.int] = None,
                 model_settings: Optional[Sequence['outputs.AppVersionSnapshotGuardrailLlmPolicyModelSetting']] = None,
                 policy_scope: Optional[_builtins.str] = None,
                 prompt: Optional[_builtins.str] = None):
        """
        :param _builtins.bool fail_open: (Output)
               If an error occurs during the policy check, fail open and do not trigger
               the guardrail.
        :param _builtins.int max_conversation_messages: (Output)
               When checking this policy, consider the last 'n' messages in the
               conversation.
               When not set a default value of 10 will be used.
        :param Sequence['AppVersionSnapshotGuardrailLlmPolicyModelSettingArgs'] model_settings: (Output)
               Model settings contains various configurations for the LLM model.
               Structure is documented below.
        :param _builtins.str policy_scope: (Output)
               Defines when to apply the policy check during the conversation. If set to
               `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
               When applying the policy to the agent response, additional latency will
               be introduced before the agent can respond.
               Possible values:
               USER_QUERY
               AGENT_RESPONSE
               USER_QUERY_AND_AGENT_RESPONSE
        :param _builtins.str prompt: (Output)
               The prompt definition. If not set, default prompt will be used.
        """
        if fail_open is not None:
            pulumi.set(__self__, "fail_open", fail_open)
        if max_conversation_messages is not None:
            pulumi.set(__self__, "max_conversation_messages", max_conversation_messages)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)
        if policy_scope is not None:
            pulumi.set(__self__, "policy_scope", policy_scope)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[_builtins.bool]:
        """
        (Output)
        If an error occurs during the policy check, fail open and do not trigger
        the guardrail.
        """
        return pulumi.get(self, "fail_open")

    @_builtins.property
    @pulumi.getter(name="maxConversationMessages")
    def max_conversation_messages(self) -> Optional[_builtins.int]:
        """
        (Output)
        When checking this policy, consider the last 'n' messages in the
        conversation.
        When not set a default value of 10 will be used.
        """
        return pulumi.get(self, "max_conversation_messages")

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrailLlmPolicyModelSetting']]:
        """
        (Output)
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @_builtins.property
    @pulumi.getter(name="policyScope")
    def policy_scope(self) -> Optional[_builtins.str]:
        """
        (Output)
        Defines when to apply the policy check during the conversation. If set to
        `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
        When applying the policy to the agent response, additional latency will
        be introduced before the agent can respond.
        Possible values:
        USER_QUERY
        AGENT_RESPONSE
        USER_QUERY_AND_AGENT_RESPONSE
        """
        return pulumi.get(self, "policy_scope")

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[_builtins.str]:
        """
        (Output)
        The prompt definition. If not set, default prompt will be used.
        """
        return pulumi.get(self, "prompt")


@pulumi.output_type
class AppVersionSnapshotGuardrailLlmPolicyModelSetting(dict):
    def __init__(__self__, *,
                 model: Optional[_builtins.str] = None,
                 temperature: Optional[_builtins.float] = None):
        """
        :param _builtins.str model: (Output)
               The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param _builtins.float temperature: (Output)
               If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        (Output)
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        (Output)
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")


@pulumi.output_type
class AppVersionSnapshotGuardrailLlmPromptSecurity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customPolicies":
            suggest = "custom_policies"
        elif key == "defaultSettings":
            suggest = "default_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotGuardrailLlmPromptSecurity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotGuardrailLlmPromptSecurity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotGuardrailLlmPromptSecurity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_policies: Optional[Sequence['outputs.AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicy']] = None,
                 default_settings: Optional[Sequence['outputs.AppVersionSnapshotGuardrailLlmPromptSecurityDefaultSetting']] = None):
        """
        :param Sequence['AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyArgs'] custom_policies: (Output)
               Guardrail that blocks the conversation if the LLM response is considered
               violating the policy based on the LLM classification.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotGuardrailLlmPromptSecurityDefaultSettingArgs'] default_settings: (Output)
               Configuration for default system security settings.
               Structure is documented below.
        """
        if custom_policies is not None:
            pulumi.set(__self__, "custom_policies", custom_policies)
        if default_settings is not None:
            pulumi.set(__self__, "default_settings", default_settings)

    @_builtins.property
    @pulumi.getter(name="customPolicies")
    def custom_policies(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicy']]:
        """
        (Output)
        Guardrail that blocks the conversation if the LLM response is considered
        violating the policy based on the LLM classification.
        Structure is documented below.
        """
        return pulumi.get(self, "custom_policies")

    @_builtins.property
    @pulumi.getter(name="defaultSettings")
    def default_settings(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrailLlmPromptSecurityDefaultSetting']]:
        """
        (Output)
        Configuration for default system security settings.
        Structure is documented below.
        """
        return pulumi.get(self, "default_settings")


@pulumi.output_type
class AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "failOpen":
            suggest = "fail_open"
        elif key == "maxConversationMessages":
            suggest = "max_conversation_messages"
        elif key == "modelSettings":
            suggest = "model_settings"
        elif key == "policyScope":
            suggest = "policy_scope"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fail_open: Optional[_builtins.bool] = None,
                 max_conversation_messages: Optional[_builtins.int] = None,
                 model_settings: Optional[Sequence['outputs.AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyModelSetting']] = None,
                 policy_scope: Optional[_builtins.str] = None,
                 prompt: Optional[_builtins.str] = None):
        """
        :param _builtins.bool fail_open: (Output)
               If an error occurs during the policy check, fail open and do not trigger
               the guardrail.
        :param _builtins.int max_conversation_messages: (Output)
               When checking this policy, consider the last 'n' messages in the
               conversation.
               When not set a default value of 10 will be used.
        :param Sequence['AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyModelSettingArgs'] model_settings: (Output)
               Model settings contains various configurations for the LLM model.
               Structure is documented below.
        :param _builtins.str policy_scope: (Output)
               Defines when to apply the policy check during the conversation. If set to
               `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
               When applying the policy to the agent response, additional latency will
               be introduced before the agent can respond.
               Possible values:
               USER_QUERY
               AGENT_RESPONSE
               USER_QUERY_AND_AGENT_RESPONSE
        :param _builtins.str prompt: (Output)
               The prompt definition. If not set, default prompt will be used.
        """
        if fail_open is not None:
            pulumi.set(__self__, "fail_open", fail_open)
        if max_conversation_messages is not None:
            pulumi.set(__self__, "max_conversation_messages", max_conversation_messages)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)
        if policy_scope is not None:
            pulumi.set(__self__, "policy_scope", policy_scope)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[_builtins.bool]:
        """
        (Output)
        If an error occurs during the policy check, fail open and do not trigger
        the guardrail.
        """
        return pulumi.get(self, "fail_open")

    @_builtins.property
    @pulumi.getter(name="maxConversationMessages")
    def max_conversation_messages(self) -> Optional[_builtins.int]:
        """
        (Output)
        When checking this policy, consider the last 'n' messages in the
        conversation.
        When not set a default value of 10 will be used.
        """
        return pulumi.get(self, "max_conversation_messages")

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyModelSetting']]:
        """
        (Output)
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @_builtins.property
    @pulumi.getter(name="policyScope")
    def policy_scope(self) -> Optional[_builtins.str]:
        """
        (Output)
        Defines when to apply the policy check during the conversation. If set to
        `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
        When applying the policy to the agent response, additional latency will
        be introduced before the agent can respond.
        Possible values:
        USER_QUERY
        AGENT_RESPONSE
        USER_QUERY_AND_AGENT_RESPONSE
        """
        return pulumi.get(self, "policy_scope")

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[_builtins.str]:
        """
        (Output)
        The prompt definition. If not set, default prompt will be used.
        """
        return pulumi.get(self, "prompt")


@pulumi.output_type
class AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyModelSetting(dict):
    def __init__(__self__, *,
                 model: Optional[_builtins.str] = None,
                 temperature: Optional[_builtins.float] = None):
        """
        :param _builtins.str model: (Output)
               The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param _builtins.float temperature: (Output)
               If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        (Output)
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        (Output)
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")


@pulumi.output_type
class AppVersionSnapshotGuardrailLlmPromptSecurityDefaultSetting(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultPromptTemplate":
            suggest = "default_prompt_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotGuardrailLlmPromptSecurityDefaultSetting. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotGuardrailLlmPromptSecurityDefaultSetting.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotGuardrailLlmPromptSecurityDefaultSetting.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_prompt_template: Optional[_builtins.str] = None):
        """
        :param _builtins.str default_prompt_template: (Output)
               The default prompt template used by the system.
               This field is for display purposes to show the user what prompt
               the system uses by default. It is OUTPUT_ONLY.
        """
        if default_prompt_template is not None:
            pulumi.set(__self__, "default_prompt_template", default_prompt_template)

    @_builtins.property
    @pulumi.getter(name="defaultPromptTemplate")
    def default_prompt_template(self) -> Optional[_builtins.str]:
        """
        (Output)
        The default prompt template used by the system.
        This field is for display purposes to show the user what prompt
        the system uses by default. It is OUTPUT_ONLY.
        """
        return pulumi.get(self, "default_prompt_template")


@pulumi.output_type
class AppVersionSnapshotGuardrailModelSafety(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "safetySettings":
            suggest = "safety_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotGuardrailModelSafety. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotGuardrailModelSafety.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotGuardrailModelSafety.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 safety_settings: Optional[Sequence['outputs.AppVersionSnapshotGuardrailModelSafetySafetySetting']] = None):
        """
        :param Sequence['AppVersionSnapshotGuardrailModelSafetySafetySettingArgs'] safety_settings: (Output)
               List of safety settings.
               Structure is documented below.
        """
        if safety_settings is not None:
            pulumi.set(__self__, "safety_settings", safety_settings)

    @_builtins.property
    @pulumi.getter(name="safetySettings")
    def safety_settings(self) -> Optional[Sequence['outputs.AppVersionSnapshotGuardrailModelSafetySafetySetting']]:
        """
        (Output)
        List of safety settings.
        Structure is documented below.
        """
        return pulumi.get(self, "safety_settings")


@pulumi.output_type
class AppVersionSnapshotGuardrailModelSafetySafetySetting(dict):
    def __init__(__self__, *,
                 category: Optional[_builtins.str] = None,
                 threshold: Optional[_builtins.str] = None):
        """
        :param _builtins.str category: (Output)
               The harm category.
               Possible values:
               HARM_CATEGORY_HATE_SPEECH
               HARM_CATEGORY_DANGEROUS_CONTENT
               HARM_CATEGORY_HARASSMENT
               HARM_CATEGORY_SEXUALLY_EXPLICIT
        :param _builtins.str threshold: (Output)
               The harm block threshold.
               Possible values:
               BLOCK_LOW_AND_ABOVE
               BLOCK_MEDIUM_AND_ABOVE
               BLOCK_ONLY_HIGH
               BLOCK_NONE
               OFF
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[_builtins.str]:
        """
        (Output)
        The harm category.
        Possible values:
        HARM_CATEGORY_HATE_SPEECH
        HARM_CATEGORY_DANGEROUS_CONTENT
        HARM_CATEGORY_HARASSMENT
        HARM_CATEGORY_SEXUALLY_EXPLICIT
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[_builtins.str]:
        """
        (Output)
        The harm block threshold.
        Possible values:
        BLOCK_LOW_AND_ABOVE
        BLOCK_MEDIUM_AND_ABOVE
        BLOCK_ONLY_HIGH
        BLOCK_NONE
        OFF
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class AppVersionSnapshotTool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientFunctions":
            suggest = "client_functions"
        elif key == "createTime":
            suggest = "create_time"
        elif key == "dataStoreTools":
            suggest = "data_store_tools"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "executionType":
            suggest = "execution_type"
        elif key == "generatedSummary":
            suggest = "generated_summary"
        elif key == "googleSearchTools":
            suggest = "google_search_tools"
        elif key == "openApiTools":
            suggest = "open_api_tools"
        elif key == "pythonFunctions":
            suggest = "python_functions"
        elif key == "systemTools":
            suggest = "system_tools"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotTool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotTool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotTool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_functions: Optional[Sequence['outputs.AppVersionSnapshotToolClientFunction']] = None,
                 create_time: Optional[_builtins.str] = None,
                 data_store_tools: Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreTool']] = None,
                 display_name: Optional[_builtins.str] = None,
                 etag: Optional[_builtins.str] = None,
                 execution_type: Optional[_builtins.str] = None,
                 generated_summary: Optional[_builtins.str] = None,
                 google_search_tools: Optional[Sequence['outputs.AppVersionSnapshotToolGoogleSearchTool']] = None,
                 name: Optional[_builtins.str] = None,
                 open_api_tools: Optional[Sequence['outputs.AppVersionSnapshotToolOpenApiTool']] = None,
                 python_functions: Optional[Sequence['outputs.AppVersionSnapshotToolPythonFunction']] = None,
                 system_tools: Optional[Sequence['outputs.AppVersionSnapshotToolSystemTool']] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param Sequence['AppVersionSnapshotToolClientFunctionArgs'] client_functions: (Output)
               Represents a client-side function that the agent can invoke. When the
               tool is chosen by the agent, control is handed off to the client.
               The client is responsible for executing the function and returning the result
               as a ToolResponse to continue the interaction with the agent.
               Structure is documented below.
        :param _builtins.str create_time: (Output)
               Timestamp when the toolset was created.
        :param Sequence['AppVersionSnapshotToolDataStoreToolArgs'] data_store_tools: (Output)
               Tool to retrieve from Vertex AI Search datastore or engine for grounding.
               Accepts either a datastore or an engine, but not both.
               See Vertex AI Search:
               https://cloud.google.com/generative-ai-app-builder/docs/enterprise-search-introduction.
               Structure is documented below.
        :param _builtins.str display_name: The display name of the app version.
        :param _builtins.str etag: (Output)
               ETag used to ensure the object hasn't changed during a read-modify-write
               operation. If the etag is empty, the update will overwrite any concurrent
               changes.
        :param _builtins.str execution_type: (Output)
               Possible values:
               SYNCHRONOUS
               ASYNCHRONOUS
        :param _builtins.str generated_summary: (Output)
               If the tool is generated by the LLM assistant, this field contains a
               descriptive summary of the generation.
        :param Sequence['AppVersionSnapshotToolGoogleSearchToolArgs'] google_search_tools: (Output)
               Represents a tool to perform Google web searches for grounding.
               See
               https://cloud.google.com/vertex-ai/generative-ai/docs/grounding/grounding-with-google-search.
               Structure is documented below.
        :param _builtins.str name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param Sequence['AppVersionSnapshotToolOpenApiToolArgs'] open_api_tools: (Output)
               A remote API tool defined by an OpenAPI schema.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotToolPythonFunctionArgs'] python_functions: (Output)
               A Python function tool.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotToolSystemToolArgs'] system_tools: (Output)
               The system tool.
               Structure is documented below.
        :param _builtins.str update_time: (Output)
               Timestamp when the toolset was last updated.
        """
        if client_functions is not None:
            pulumi.set(__self__, "client_functions", client_functions)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if data_store_tools is not None:
            pulumi.set(__self__, "data_store_tools", data_store_tools)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if etag is not None:
            pulumi.set(__self__, "etag", etag)
        if execution_type is not None:
            pulumi.set(__self__, "execution_type", execution_type)
        if generated_summary is not None:
            pulumi.set(__self__, "generated_summary", generated_summary)
        if google_search_tools is not None:
            pulumi.set(__self__, "google_search_tools", google_search_tools)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if open_api_tools is not None:
            pulumi.set(__self__, "open_api_tools", open_api_tools)
        if python_functions is not None:
            pulumi.set(__self__, "python_functions", python_functions)
        if system_tools is not None:
            pulumi.set(__self__, "system_tools", system_tools)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="clientFunctions")
    def client_functions(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolClientFunction']]:
        """
        (Output)
        Represents a client-side function that the agent can invoke. When the
        tool is chosen by the agent, control is handed off to the client.
        The client is responsible for executing the function and returning the result
        as a ToolResponse to continue the interaction with the agent.
        Structure is documented below.
        """
        return pulumi.get(self, "client_functions")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        Timestamp when the toolset was created.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="dataStoreTools")
    def data_store_tools(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreTool']]:
        """
        (Output)
        Tool to retrieve from Vertex AI Search datastore or engine for grounding.
        Accepts either a datastore or an engine, but not both.
        See Vertex AI Search:
        https://cloud.google.com/generative-ai-app-builder/docs/enterprise-search-introduction.
        Structure is documented below.
        """
        return pulumi.get(self, "data_store_tools")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def etag(self) -> Optional[_builtins.str]:
        """
        (Output)
        ETag used to ensure the object hasn't changed during a read-modify-write
        operation. If the etag is empty, the update will overwrite any concurrent
        changes.
        """
        return pulumi.get(self, "etag")

    @_builtins.property
    @pulumi.getter(name="executionType")
    def execution_type(self) -> Optional[_builtins.str]:
        """
        (Output)
        Possible values:
        SYNCHRONOUS
        ASYNCHRONOUS
        """
        return pulumi.get(self, "execution_type")

    @_builtins.property
    @pulumi.getter(name="generatedSummary")
    def generated_summary(self) -> Optional[_builtins.str]:
        """
        (Output)
        If the tool is generated by the LLM assistant, this field contains a
        descriptive summary of the generation.
        """
        return pulumi.get(self, "generated_summary")

    @_builtins.property
    @pulumi.getter(name="googleSearchTools")
    def google_search_tools(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolGoogleSearchTool']]:
        """
        (Output)
        Represents a tool to perform Google web searches for grounding.
        See
        https://cloud.google.com/vertex-ai/generative-ai/docs/grounding/grounding-with-google-search.
        Structure is documented below.
        """
        return pulumi.get(self, "google_search_tools")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="openApiTools")
    def open_api_tools(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolOpenApiTool']]:
        """
        (Output)
        A remote API tool defined by an OpenAPI schema.
        Structure is documented below.
        """
        return pulumi.get(self, "open_api_tools")

    @_builtins.property
    @pulumi.getter(name="pythonFunctions")
    def python_functions(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolPythonFunction']]:
        """
        (Output)
        A Python function tool.
        Structure is documented below.
        """
        return pulumi.get(self, "python_functions")

    @_builtins.property
    @pulumi.getter(name="systemTools")
    def system_tools(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolSystemTool']]:
        """
        (Output)
        The system tool.
        Structure is documented below.
        """
        return pulumi.get(self, "system_tools")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        Timestamp when the toolset was last updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class AppVersionSnapshotToolClientFunction(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 parameters: Optional[Sequence['outputs.AppVersionSnapshotToolClientFunctionParameter']] = None,
                 responses: Optional[Sequence['outputs.AppVersionSnapshotToolClientFunctionResponse']] = None):
        """
        :param _builtins.str description: The description of the app version.
        :param _builtins.str name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param Sequence['AppVersionSnapshotToolClientFunctionParameterArgs'] parameters: (Output)
               Represents a select subset of an OpenAPI 3.0 schema object.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotToolClientFunctionResponseArgs'] responses: (Output)
               Represents a select subset of an OpenAPI 3.0 schema object.
               Structure is documented below.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if responses is not None:
            pulumi.set(__self__, "responses", responses)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolClientFunctionParameter']]:
        """
        (Output)
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def responses(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolClientFunctionResponse']]:
        """
        (Output)
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        return pulumi.get(self, "responses")


@pulumi.output_type
class AppVersionSnapshotToolClientFunctionParameter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalProperties":
            suggest = "additional_properties"
        elif key == "anyOf":
            suggest = "any_of"
        elif key == "prefixItems":
            suggest = "prefix_items"
        elif key == "uniqueItems":
            suggest = "unique_items"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolClientFunctionParameter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolClientFunctionParameter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolClientFunctionParameter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_properties: Optional[_builtins.str] = None,
                 any_of: Optional[_builtins.str] = None,
                 default: Optional[_builtins.str] = None,
                 defs: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 enums: Optional[Sequence[_builtins.str]] = None,
                 items: Optional[_builtins.str] = None,
                 nullable: Optional[_builtins.bool] = None,
                 prefix_items: Optional[_builtins.str] = None,
                 properties: Optional[_builtins.str] = None,
                 ref: Optional[_builtins.str] = None,
                 requireds: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None,
                 unique_items: Optional[_builtins.bool] = None):
        """
        :param _builtins.str additional_properties: (Output)
               Optional. Defines the schema for additional properties allowed in an object.
               The value must be a valid JSON string representing the Schema object.
               (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        :param _builtins.str any_of: (Output)
               Optional. The instance value should be valid against at least one of the schemas in this list.
        :param _builtins.str default: (Output)
               Optional. Default value of the data. Represents a dynamically typed value
               which can be either null, a number, a string, a boolean, a struct,
               or a list of values. The provided default value must be compatible
               with the defined 'type' and other schema constraints.
        :param _builtins.str defs: (Output)
               A map of definitions for use by ref. Only allowed at the root of the schema.
        :param _builtins.str description: The description of the app version.
        :param Sequence[_builtins.str] enums: (Output)
               Possible values of the element of primitive type with enum format.
               Examples:
               1. We can define direction as :
               {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
               2. We can define apartment number as :
               {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        :param _builtins.str items: (Output)
               Schema of the elements of Type.ARRAY.
        :param _builtins.bool nullable: (Output)
               Indicates if the value may be null.
        :param _builtins.str prefix_items: (Output)
               Optional. Schemas of initial elements of Type.ARRAY.
        :param _builtins.str properties: (Output)
               Properties of Type.OBJECT.
        :param _builtins.str ref: (Output)
               Allows indirect references between schema nodes. The value should be a
               valid reference to a child of the root `defs`.
               For example, the following schema defines a reference to a schema node
               named "Pet":
               type: object
               properties:
               pet:
               ref: #/defs/Pet
               defs:
               Pet:
               type: object
               properties:
               name:
               type: string
               The value of the "pet" property is a reference to the schema node
               named "Pet".
               See details in
               https://json-schema.org/understanding-json-schema/structuring.
        :param Sequence[_builtins.str] requireds: (Output)
               Required properties of Type.OBJECT.
        :param _builtins.str type: (Output)
               The type of the data store. This field is readonly and populated by the
               server.
               Possible values:
               PUBLIC_WEB
               UNSTRUCTURED
               FAQ
               CONNECTOR
        :param _builtins.bool unique_items: (Output)
               Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if any_of is not None:
            pulumi.set(__self__, "any_of", any_of)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if defs is not None:
            pulumi.set(__self__, "defs", defs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enums is not None:
            pulumi.set(__self__, "enums", enums)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if prefix_items is not None:
            pulumi.set(__self__, "prefix_items", prefix_items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if requireds is not None:
            pulumi.set(__self__, "requireds", requireds)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)

    @_builtins.property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[_builtins.str]:
        """
        (Output)
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        return pulumi.get(self, "additional_properties")

    @_builtins.property
    @pulumi.getter(name="anyOf")
    def any_of(self) -> Optional[_builtins.str]:
        """
        (Output)
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        return pulumi.get(self, "any_of")

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        """
        (Output)
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def defs(self) -> Optional[_builtins.str]:
        """
        (Output)
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        return pulumi.get(self, "defs")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def enums(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        return pulumi.get(self, "enums")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[_builtins.str]:
        """
        (Output)
        Schema of the elements of Type.ARRAY.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Indicates if the value may be null.
        """
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="prefixItems")
    def prefix_items(self) -> Optional[_builtins.str]:
        """
        (Output)
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        return pulumi.get(self, "prefix_items")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[_builtins.str]:
        """
        (Output)
        Properties of Type.OBJECT.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[_builtins.str]:
        """
        (Output)
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        return pulumi.get(self, "ref")

    @_builtins.property
    @pulumi.getter
    def requireds(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        Required properties of Type.OBJECT.
        """
        return pulumi.get(self, "requireds")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        return pulumi.get(self, "unique_items")


@pulumi.output_type
class AppVersionSnapshotToolClientFunctionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalProperties":
            suggest = "additional_properties"
        elif key == "anyOf":
            suggest = "any_of"
        elif key == "prefixItems":
            suggest = "prefix_items"
        elif key == "uniqueItems":
            suggest = "unique_items"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolClientFunctionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolClientFunctionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolClientFunctionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_properties: Optional[_builtins.str] = None,
                 any_of: Optional[_builtins.str] = None,
                 default: Optional[_builtins.str] = None,
                 defs: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 enums: Optional[Sequence[_builtins.str]] = None,
                 items: Optional[_builtins.str] = None,
                 nullable: Optional[_builtins.bool] = None,
                 prefix_items: Optional[_builtins.str] = None,
                 properties: Optional[_builtins.str] = None,
                 ref: Optional[_builtins.str] = None,
                 requireds: Optional[Sequence[_builtins.str]] = None,
                 type: Optional[_builtins.str] = None,
                 unique_items: Optional[_builtins.bool] = None):
        """
        :param _builtins.str additional_properties: (Output)
               Optional. Defines the schema for additional properties allowed in an object.
               The value must be a valid JSON string representing the Schema object.
               (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        :param _builtins.str any_of: (Output)
               Optional. The instance value should be valid against at least one of the schemas in this list.
        :param _builtins.str default: (Output)
               Optional. Default value of the data. Represents a dynamically typed value
               which can be either null, a number, a string, a boolean, a struct,
               or a list of values. The provided default value must be compatible
               with the defined 'type' and other schema constraints.
        :param _builtins.str defs: (Output)
               A map of definitions for use by ref. Only allowed at the root of the schema.
        :param _builtins.str description: The description of the app version.
        :param Sequence[_builtins.str] enums: (Output)
               Possible values of the element of primitive type with enum format.
               Examples:
               1. We can define direction as :
               {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
               2. We can define apartment number as :
               {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        :param _builtins.str items: (Output)
               Schema of the elements of Type.ARRAY.
        :param _builtins.bool nullable: (Output)
               Indicates if the value may be null.
        :param _builtins.str prefix_items: (Output)
               Optional. Schemas of initial elements of Type.ARRAY.
        :param _builtins.str properties: (Output)
               Properties of Type.OBJECT.
        :param _builtins.str ref: (Output)
               Allows indirect references between schema nodes. The value should be a
               valid reference to a child of the root `defs`.
               For example, the following schema defines a reference to a schema node
               named "Pet":
               type: object
               properties:
               pet:
               ref: #/defs/Pet
               defs:
               Pet:
               type: object
               properties:
               name:
               type: string
               The value of the "pet" property is a reference to the schema node
               named "Pet".
               See details in
               https://json-schema.org/understanding-json-schema/structuring.
        :param Sequence[_builtins.str] requireds: (Output)
               Required properties of Type.OBJECT.
        :param _builtins.str type: (Output)
               The type of the data store. This field is readonly and populated by the
               server.
               Possible values:
               PUBLIC_WEB
               UNSTRUCTURED
               FAQ
               CONNECTOR
        :param _builtins.bool unique_items: (Output)
               Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if any_of is not None:
            pulumi.set(__self__, "any_of", any_of)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if defs is not None:
            pulumi.set(__self__, "defs", defs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enums is not None:
            pulumi.set(__self__, "enums", enums)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if prefix_items is not None:
            pulumi.set(__self__, "prefix_items", prefix_items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if requireds is not None:
            pulumi.set(__self__, "requireds", requireds)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)

    @_builtins.property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[_builtins.str]:
        """
        (Output)
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        return pulumi.get(self, "additional_properties")

    @_builtins.property
    @pulumi.getter(name="anyOf")
    def any_of(self) -> Optional[_builtins.str]:
        """
        (Output)
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        return pulumi.get(self, "any_of")

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        """
        (Output)
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def defs(self) -> Optional[_builtins.str]:
        """
        (Output)
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        return pulumi.get(self, "defs")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def enums(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        return pulumi.get(self, "enums")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[_builtins.str]:
        """
        (Output)
        Schema of the elements of Type.ARRAY.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Indicates if the value may be null.
        """
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="prefixItems")
    def prefix_items(self) -> Optional[_builtins.str]:
        """
        (Output)
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        return pulumi.get(self, "prefix_items")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[_builtins.str]:
        """
        (Output)
        Properties of Type.OBJECT.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[_builtins.str]:
        """
        (Output)
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        return pulumi.get(self, "ref")

    @_builtins.property
    @pulumi.getter
    def requireds(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        Required properties of Type.OBJECT.
        """
        return pulumi.get(self, "requireds")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        return pulumi.get(self, "unique_items")


@pulumi.output_type
class AppVersionSnapshotToolDataStoreTool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boostSpecs":
            suggest = "boost_specs"
        elif key == "engineSources":
            suggest = "engine_sources"
        elif key == "maxResults":
            suggest = "max_results"
        elif key == "modalityConfigs":
            suggest = "modality_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolDataStoreTool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolDataStoreTool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolDataStoreTool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boost_specs: Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolBoostSpec']] = None,
                 description: Optional[_builtins.str] = None,
                 engine_sources: Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolEngineSource']] = None,
                 max_results: Optional[_builtins.int] = None,
                 modality_configs: Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolModalityConfig']] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param Sequence['AppVersionSnapshotToolDataStoreToolBoostSpecArgs'] boost_specs: (Output)
               Boost specification to boost certain documents.
               Structure is documented below.
        :param _builtins.str description: The description of the app version.
        :param Sequence['AppVersionSnapshotToolDataStoreToolEngineSourceArgs'] engine_sources: (Output)
               Configuration for searching within an Engine, potentially targeting
               specific DataStores.
               Structure is documented below.
        :param _builtins.int max_results: (Output)
               Number of search results to return per query.
               The default value is 10. The maximum allowed value is 10.
        :param Sequence['AppVersionSnapshotToolDataStoreToolModalityConfigArgs'] modality_configs: (Output)
               The modality configs for the data store.
               Structure is documented below.
        :param _builtins.str name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        if boost_specs is not None:
            pulumi.set(__self__, "boost_specs", boost_specs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if engine_sources is not None:
            pulumi.set(__self__, "engine_sources", engine_sources)
        if max_results is not None:
            pulumi.set(__self__, "max_results", max_results)
        if modality_configs is not None:
            pulumi.set(__self__, "modality_configs", modality_configs)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="boostSpecs")
    def boost_specs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolBoostSpec']]:
        """
        (Output)
        Boost specification to boost certain documents.
        Structure is documented below.
        """
        return pulumi.get(self, "boost_specs")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="engineSources")
    def engine_sources(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolEngineSource']]:
        """
        (Output)
        Configuration for searching within an Engine, potentially targeting
        specific DataStores.
        Structure is documented below.
        """
        return pulumi.get(self, "engine_sources")

    @_builtins.property
    @pulumi.getter(name="maxResults")
    def max_results(self) -> Optional[_builtins.int]:
        """
        (Output)
        Number of search results to return per query.
        The default value is 10. The maximum allowed value is 10.
        """
        return pulumi.get(self, "max_results")

    @_builtins.property
    @pulumi.getter(name="modalityConfigs")
    def modality_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolModalityConfig']]:
        """
        (Output)
        The modality configs for the data store.
        Structure is documented below.
        """
        return pulumi.get(self, "modality_configs")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AppVersionSnapshotToolDataStoreToolBoostSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStores":
            suggest = "data_stores"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolDataStoreToolBoostSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolDataStoreToolBoostSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolDataStoreToolBoostSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_stores: Optional[Sequence[_builtins.str]] = None,
                 specs: Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolBoostSpecSpec']] = None):
        """
        :param Sequence[_builtins.str] data_stores: (Output)
               The Data Store where the boosting configuration is applied. Full resource
               name of DataStore, such as
               projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}.
        :param Sequence['AppVersionSnapshotToolDataStoreToolBoostSpecSpecArgs'] specs: (Output)
               A list of boosting specifications.
               Structure is documented below.
        """
        if data_stores is not None:
            pulumi.set(__self__, "data_stores", data_stores)
        if specs is not None:
            pulumi.set(__self__, "specs", specs)

    @_builtins.property
    @pulumi.getter(name="dataStores")
    def data_stores(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        The Data Store where the boosting configuration is applied. Full resource
        name of DataStore, such as
        projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}.
        """
        return pulumi.get(self, "data_stores")

    @_builtins.property
    @pulumi.getter
    def specs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolBoostSpecSpec']]:
        """
        (Output)
        A list of boosting specifications.
        Structure is documented below.
        """
        return pulumi.get(self, "specs")


@pulumi.output_type
class AppVersionSnapshotToolDataStoreToolBoostSpecSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionBoostSpecs":
            suggest = "condition_boost_specs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolDataStoreToolBoostSpecSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolDataStoreToolBoostSpecSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolDataStoreToolBoostSpecSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_boost_specs: Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpec']] = None):
        """
        :param Sequence['AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs'] condition_boost_specs: (Output)
               A list of boosting specifications.
               Structure is documented below.
        """
        if condition_boost_specs is not None:
            pulumi.set(__self__, "condition_boost_specs", condition_boost_specs)

    @_builtins.property
    @pulumi.getter(name="conditionBoostSpecs")
    def condition_boost_specs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpec']]:
        """
        (Output)
        A list of boosting specifications.
        Structure is documented below.
        """
        return pulumi.get(self, "condition_boost_specs")


@pulumi.output_type
class AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boostControlSpecs":
            suggest = "boost_control_specs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 boost: Optional[_builtins.float] = None,
                 boost_control_specs: Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpec']] = None,
                 condition: Optional[_builtins.str] = None):
        """
        :param _builtins.float boost: (Output)
               Strength of the boost, which should be in [-1, 1]. Negative boost means
               demotion. Default is 0.0.
               Setting to 1.0 gives the suggestions a big promotion. However, it does
               not necessarily mean that the top result will be a boosted suggestion.
               Setting to -1.0 gives the suggestions a big demotion. However, other
               suggestions that are relevant might still be shown.
               Setting to 0.0 means no boost applied. The boosting condition is
               ignored.
        :param Sequence['AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs'] boost_control_specs: (Output)
               Specification for custom ranking based on customer specified attribute
               value. It provides more controls for customized ranking than the simple
               (condition, boost) combination above.
               Structure is documented below.
        :param _builtins.str condition: (Output)
               An expression which specifies a boost condition. The syntax is the same
               as filter expression syntax. Currently, the only supported condition is
               a list of BCP-47 lang codes.
               Example: To boost suggestions in languages en or fr:
               (lang_code: ANY("en", "fr"))
        """
        if boost is not None:
            pulumi.set(__self__, "boost", boost)
        if boost_control_specs is not None:
            pulumi.set(__self__, "boost_control_specs", boost_control_specs)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def boost(self) -> Optional[_builtins.float]:
        """
        (Output)
        Strength of the boost, which should be in [-1, 1]. Negative boost means
        demotion. Default is 0.0.
        Setting to 1.0 gives the suggestions a big promotion. However, it does
        not necessarily mean that the top result will be a boosted suggestion.
        Setting to -1.0 gives the suggestions a big demotion. However, other
        suggestions that are relevant might still be shown.
        Setting to 0.0 means no boost applied. The boosting condition is
        ignored.
        """
        return pulumi.get(self, "boost")

    @_builtins.property
    @pulumi.getter(name="boostControlSpecs")
    def boost_control_specs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpec']]:
        """
        (Output)
        Specification for custom ranking based on customer specified attribute
        value. It provides more controls for customized ranking than the simple
        (condition, boost) combination above.
        Structure is documented below.
        """
        return pulumi.get(self, "boost_control_specs")

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[_builtins.str]:
        """
        (Output)
        An expression which specifies a boost condition. The syntax is the same
        as filter expression syntax. Currently, the only supported condition is
        a list of BCP-47 lang codes.
        Example: To boost suggestions in languages en or fr:
        (lang_code: ANY("en", "fr"))
        """
        return pulumi.get(self, "condition")


@pulumi.output_type
class AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeType":
            suggest = "attribute_type"
        elif key == "controlPoints":
            suggest = "control_points"
        elif key == "fieldName":
            suggest = "field_name"
        elif key == "interpolationType":
            suggest = "interpolation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_type: Optional[_builtins.str] = None,
                 control_points: Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPoint']] = None,
                 field_name: Optional[_builtins.str] = None,
                 interpolation_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str attribute_type: (Output)
               The attribute type to be used to determine the boost amount. The
               attribute value can be derived from the field value of the specified
               field_name. In the case of numerical it is straightforward i.e.
               attribute_value = numerical_field_value. In the case of freshness
               however, attribute_value = (time.now() - datetime_field_value).
               Possible values:
               NUMERICAL
               FRESHNESS
        :param Sequence['AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs'] control_points: (Output)
               The control points used to define the curve. The monotonic function
               (defined through the interpolation_type above) passes through the
               control points listed here.
               Structure is documented below.
        :param _builtins.str field_name: (Output)
               The name of the field whose value will be used to determine the
               boost amount.
        :param _builtins.str interpolation_type: (Output)
               The interpolation type to be applied to connect the control points
               listed below.
               Possible values:
               LINEAR
        """
        if attribute_type is not None:
            pulumi.set(__self__, "attribute_type", attribute_type)
        if control_points is not None:
            pulumi.set(__self__, "control_points", control_points)
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)
        if interpolation_type is not None:
            pulumi.set(__self__, "interpolation_type", interpolation_type)

    @_builtins.property
    @pulumi.getter(name="attributeType")
    def attribute_type(self) -> Optional[_builtins.str]:
        """
        (Output)
        The attribute type to be used to determine the boost amount. The
        attribute value can be derived from the field value of the specified
        field_name. In the case of numerical it is straightforward i.e.
        attribute_value = numerical_field_value. In the case of freshness
        however, attribute_value = (time.now() - datetime_field_value).
        Possible values:
        NUMERICAL
        FRESHNESS
        """
        return pulumi.get(self, "attribute_type")

    @_builtins.property
    @pulumi.getter(name="controlPoints")
    def control_points(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPoint']]:
        """
        (Output)
        The control points used to define the curve. The monotonic function
        (defined through the interpolation_type above) passes through the
        control points listed here.
        Structure is documented below.
        """
        return pulumi.get(self, "control_points")

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the field whose value will be used to determine the
        boost amount.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter(name="interpolationType")
    def interpolation_type(self) -> Optional[_builtins.str]:
        """
        (Output)
        The interpolation type to be applied to connect the control points
        listed below.
        Possible values:
        LINEAR
        """
        return pulumi.get(self, "interpolation_type")


@pulumi.output_type
class AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeValue":
            suggest = "attribute_value"
        elif key == "boostAmount":
            suggest = "boost_amount"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_value: Optional[_builtins.str] = None,
                 boost_amount: Optional[_builtins.float] = None):
        """
        :param _builtins.str attribute_value: (Output)
               Can be one of:
               1. The numerical field value.
               2. The duration spec for freshness:
               The value must be formatted as an XSD `dayTimeDuration` value (a
               restricted subset of an ISO 8601 duration value). The pattern for
               this is: `nDnM]`.
        :param _builtins.float boost_amount: (Output)
               The value between -1 to 1 by which to boost the score if the
               attribute_value evaluates to the value specified above.
        """
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if boost_amount is not None:
            pulumi.set(__self__, "boost_amount", boost_amount)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[_builtins.str]:
        """
        (Output)
        Can be one of:
        1. The numerical field value.
        2. The duration spec for freshness:
        The value must be formatted as an XSD `dayTimeDuration` value (a
        restricted subset of an ISO 8601 duration value). The pattern for
        this is: `nDnM]`.
        """
        return pulumi.get(self, "attribute_value")

    @_builtins.property
    @pulumi.getter(name="boostAmount")
    def boost_amount(self) -> Optional[_builtins.float]:
        """
        (Output)
        The value between -1 to 1 by which to boost the score if the
        attribute_value evaluates to the value specified above.
        """
        return pulumi.get(self, "boost_amount")


@pulumi.output_type
class AppVersionSnapshotToolDataStoreToolEngineSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStoreSources":
            suggest = "data_store_sources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolDataStoreToolEngineSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolDataStoreToolEngineSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolDataStoreToolEngineSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_store_sources: Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSource']] = None,
                 engine: Optional[_builtins.str] = None,
                 filter: Optional[_builtins.str] = None):
        """
        :param Sequence['AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceArgs'] data_store_sources: (Output)
               Use to target specific DataStores within the Engine.
               If empty, the search applies to all DataStores associated with the
               Engine.
               Structure is documented below.
        :param _builtins.str engine: (Output)
               Full resource name of the Engine.
               Format:
               `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
        :param _builtins.str filter: (Output)
               Filter specification for the DataStore.
               See:
               https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        if data_store_sources is not None:
            pulumi.set(__self__, "data_store_sources", data_store_sources)
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)

    @_builtins.property
    @pulumi.getter(name="dataStoreSources")
    def data_store_sources(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSource']]:
        """
        (Output)
        Use to target specific DataStores within the Engine.
        If empty, the search applies to all DataStores associated with the
        Engine.
        Structure is documented below.
        """
        return pulumi.get(self, "data_store_sources")

    @_builtins.property
    @pulumi.getter
    def engine(self) -> Optional[_builtins.str]:
        """
        (Output)
        Full resource name of the Engine.
        Format:
        `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
        """
        return pulumi.get(self, "engine")

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[_builtins.str]:
        """
        (Output)
        Filter specification for the DataStore.
        See:
        https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        return pulumi.get(self, "filter")


@pulumi.output_type
class AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStores":
            suggest = "data_stores"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_stores: Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStore']] = None,
                 filter: Optional[_builtins.str] = None):
        """
        :param Sequence['AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs'] data_stores: (Output)
               A DataStore resource in Vertex AI Search.
               Structure is documented below.
        :param _builtins.str filter: (Output)
               Filter specification for the DataStore.
               See:
               https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        if data_stores is not None:
            pulumi.set(__self__, "data_stores", data_stores)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)

    @_builtins.property
    @pulumi.getter(name="dataStores")
    def data_stores(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStore']]:
        """
        (Output)
        A DataStore resource in Vertex AI Search.
        Structure is documented below.
        """
        return pulumi.get(self, "data_stores")

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[_builtins.str]:
        """
        (Output)
        Filter specification for the DataStore.
        See:
        https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        return pulumi.get(self, "filter")


@pulumi.output_type
class AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorConfigs":
            suggest = "connector_configs"
        elif key == "createTime":
            suggest = "create_time"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "documentProcessingMode":
            suggest = "document_processing_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 connector_configs: Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfig']] = None,
                 create_time: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 document_processing_mode: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param Sequence['AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs'] connector_configs: (Output)
               The connector config for the data store connection.
               Structure is documented below.
        :param _builtins.str create_time: (Output)
               Timestamp when the toolset was created.
        :param _builtins.str display_name: The display name of the app version.
        :param _builtins.str document_processing_mode: (Output)
               The document processing mode for the data store connection.
               Only set for PUBLIC_WEB and UNSTRUCTURED data stores.
               Possible values:
               DOCUMENTS
               CHUNKS
        :param _builtins.str name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param _builtins.str type: (Output)
               The type of the data store. This field is readonly and populated by the
               server.
               Possible values:
               PUBLIC_WEB
               UNSTRUCTURED
               FAQ
               CONNECTOR
        """
        if connector_configs is not None:
            pulumi.set(__self__, "connector_configs", connector_configs)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if document_processing_mode is not None:
            pulumi.set(__self__, "document_processing_mode", document_processing_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="connectorConfigs")
    def connector_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfig']]:
        """
        (Output)
        The connector config for the data store connection.
        Structure is documented below.
        """
        return pulumi.get(self, "connector_configs")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        Timestamp when the toolset was created.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="documentProcessingMode")
    def document_processing_mode(self) -> Optional[_builtins.str]:
        """
        (Output)
        The document processing mode for the data store connection.
        Only set for PUBLIC_WEB and UNSTRUCTURED data stores.
        Possible values:
        DOCUMENTS
        CHUNKS
        """
        return pulumi.get(self, "document_processing_mode")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionDisplayName":
            suggest = "collection_display_name"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection: Optional[_builtins.str] = None,
                 collection_display_name: Optional[_builtins.str] = None,
                 data_source: Optional[_builtins.str] = None):
        """
        :param _builtins.str collection: (Output)
               Resource name of the collection the data store belongs to.
        :param _builtins.str collection_display_name: (Output)
               Display name of the collection the data store belongs to.
        :param _builtins.str data_source: (Output)
               The name of the data source.
               Example: `salesforce`, `jira`, `confluence`, `bigquery`.
        """
        if collection is not None:
            pulumi.set(__self__, "collection", collection)
        if collection_display_name is not None:
            pulumi.set(__self__, "collection_display_name", collection_display_name)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @_builtins.property
    @pulumi.getter
    def collection(self) -> Optional[_builtins.str]:
        """
        (Output)
        Resource name of the collection the data store belongs to.
        """
        return pulumi.get(self, "collection")

    @_builtins.property
    @pulumi.getter(name="collectionDisplayName")
    def collection_display_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        Display name of the collection the data store belongs to.
        """
        return pulumi.get(self, "collection_display_name")

    @_builtins.property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the data source.
        Example: `salesforce`, `jira`, `confluence`, `bigquery`.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class AppVersionSnapshotToolDataStoreToolModalityConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groundingConfigs":
            suggest = "grounding_configs"
        elif key == "modalityType":
            suggest = "modality_type"
        elif key == "rewriterConfigs":
            suggest = "rewriter_configs"
        elif key == "summarizationConfigs":
            suggest = "summarization_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolDataStoreToolModalityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolDataStoreToolModalityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolDataStoreToolModalityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 grounding_configs: Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolModalityConfigGroundingConfig']] = None,
                 modality_type: Optional[_builtins.str] = None,
                 rewriter_configs: Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfig']] = None,
                 summarization_configs: Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfig']] = None):
        """
        :param Sequence['AppVersionSnapshotToolDataStoreToolModalityConfigGroundingConfigArgs'] grounding_configs: (Output)
               Grounding configuration.
               Structure is documented below.
        :param _builtins.str modality_type: (Output)
               The modality type.
               Possible values:
               TEXT
               AUDIO
        :param Sequence['AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigArgs'] rewriter_configs: (Output)
               Rewriter configuration.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigArgs'] summarization_configs: (Output)
               Summarization configuration.
               Structure is documented below.
        """
        if grounding_configs is not None:
            pulumi.set(__self__, "grounding_configs", grounding_configs)
        if modality_type is not None:
            pulumi.set(__self__, "modality_type", modality_type)
        if rewriter_configs is not None:
            pulumi.set(__self__, "rewriter_configs", rewriter_configs)
        if summarization_configs is not None:
            pulumi.set(__self__, "summarization_configs", summarization_configs)

    @_builtins.property
    @pulumi.getter(name="groundingConfigs")
    def grounding_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolModalityConfigGroundingConfig']]:
        """
        (Output)
        Grounding configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "grounding_configs")

    @_builtins.property
    @pulumi.getter(name="modalityType")
    def modality_type(self) -> Optional[_builtins.str]:
        """
        (Output)
        The modality type.
        Possible values:
        TEXT
        AUDIO
        """
        return pulumi.get(self, "modality_type")

    @_builtins.property
    @pulumi.getter(name="rewriterConfigs")
    def rewriter_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfig']]:
        """
        (Output)
        Rewriter configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "rewriter_configs")

    @_builtins.property
    @pulumi.getter(name="summarizationConfigs")
    def summarization_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfig']]:
        """
        (Output)
        Summarization configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "summarization_configs")


@pulumi.output_type
class AppVersionSnapshotToolDataStoreToolModalityConfigGroundingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groundingLevel":
            suggest = "grounding_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolDataStoreToolModalityConfigGroundingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolDataStoreToolModalityConfigGroundingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolDataStoreToolModalityConfigGroundingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 grounding_level: Optional[_builtins.float] = None):
        """
        :param _builtins.bool disabled: (Output)
               Whether summarization is disabled.
        :param _builtins.float grounding_level: (Output)
               The groundedness threshold of the answer based on the retrieved sources.
               The value has a configurable range of [1, 5]. The level is used to
               threshold the groundedness of the answer, meaning that all responses with
               a groundedness score below the threshold will fall back to returning
               relevant snippets only.
               For example, a level of 3 means that the groundedness score must be
               3 or higher for the response to be returned.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if grounding_level is not None:
            pulumi.set(__self__, "grounding_level", grounding_level)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="groundingLevel")
    def grounding_level(self) -> Optional[_builtins.float]:
        """
        (Output)
        The groundedness threshold of the answer based on the retrieved sources.
        The value has a configurable range of [1, 5]. The level is used to
        threshold the groundedness of the answer, meaning that all responses with
        a groundedness score below the threshold will fall back to returning
        relevant snippets only.
        For example, a level of 3 means that the groundedness score must be
        3 or higher for the response to be returned.
        """
        return pulumi.get(self, "grounding_level")


@pulumi.output_type
class AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelSettings":
            suggest = "model_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 model_settings: Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigModelSetting']] = None,
                 prompt: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disabled: (Output)
               Whether summarization is disabled.
        :param Sequence['AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigModelSettingArgs'] model_settings: (Output)
               Model settings contains various configurations for the LLM model.
               Structure is documented below.
        :param _builtins.str prompt: (Output)
               The prompt definition. If not set, default prompt will be used.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigModelSetting']]:
        """
        (Output)
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[_builtins.str]:
        """
        (Output)
        The prompt definition. If not set, default prompt will be used.
        """
        return pulumi.get(self, "prompt")


@pulumi.output_type
class AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigModelSetting(dict):
    def __init__(__self__, *,
                 model: Optional[_builtins.str] = None,
                 temperature: Optional[_builtins.float] = None):
        """
        :param _builtins.str model: (Output)
               The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param _builtins.float temperature: (Output)
               If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        (Output)
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        (Output)
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")


@pulumi.output_type
class AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelSettings":
            suggest = "model_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 model_settings: Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigModelSetting']] = None,
                 prompt: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disabled: (Output)
               Whether summarization is disabled.
        :param Sequence['AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigModelSettingArgs'] model_settings: (Output)
               Model settings contains various configurations for the LLM model.
               Structure is documented below.
        :param _builtins.str prompt: (Output)
               The prompt definition. If not set, default prompt will be used.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigModelSetting']]:
        """
        (Output)
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[_builtins.str]:
        """
        (Output)
        The prompt definition. If not set, default prompt will be used.
        """
        return pulumi.get(self, "prompt")


@pulumi.output_type
class AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigModelSetting(dict):
    def __init__(__self__, *,
                 model: Optional[_builtins.str] = None,
                 temperature: Optional[_builtins.float] = None):
        """
        :param _builtins.str model: (Output)
               The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param _builtins.float temperature: (Output)
               If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        (Output)
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        (Output)
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")


@pulumi.output_type
class AppVersionSnapshotToolGoogleSearchTool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeDomains":
            suggest = "exclude_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolGoogleSearchTool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolGoogleSearchTool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolGoogleSearchTool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 exclude_domains: Optional[Sequence[_builtins.str]] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: The description of the app version.
        :param Sequence[_builtins.str] exclude_domains: (Output)
               List of domains to be excluded from the search results.
               Example: "example.com".
               A maximum of 2000 domains can be excluded.
        :param _builtins.str name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exclude_domains is not None:
            pulumi.set(__self__, "exclude_domains", exclude_domains)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="excludeDomains")
    def exclude_domains(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        List of domains to be excluded from the search results.
        Example: "example.com".
        A maximum of 2000 domains can be excluded.
        """
        return pulumi.get(self, "exclude_domains")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AppVersionSnapshotToolOpenApiTool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiAuthentications":
            suggest = "api_authentications"
        elif key == "ignoreUnknownFields":
            suggest = "ignore_unknown_fields"
        elif key == "openApiSchema":
            suggest = "open_api_schema"
        elif key == "serviceDirectoryConfigs":
            suggest = "service_directory_configs"
        elif key == "tlsConfigs":
            suggest = "tls_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolOpenApiTool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolOpenApiTool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolOpenApiTool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_authentications: Optional[Sequence['outputs.AppVersionSnapshotToolOpenApiToolApiAuthentication']] = None,
                 description: Optional[_builtins.str] = None,
                 ignore_unknown_fields: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 open_api_schema: Optional[_builtins.str] = None,
                 service_directory_configs: Optional[Sequence['outputs.AppVersionSnapshotToolOpenApiToolServiceDirectoryConfig']] = None,
                 tls_configs: Optional[Sequence['outputs.AppVersionSnapshotToolOpenApiToolTlsConfig']] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param Sequence['AppVersionSnapshotToolOpenApiToolApiAuthenticationArgs'] api_authentications: (Output)
               Authentication information required for API calls.
               Structure is documented below.
        :param _builtins.str description: The description of the app version.
        :param _builtins.bool ignore_unknown_fields: (Output)
               If true, the agent will ignore unknown fields in the API response for all
               operations defined in the OpenAPI schema.
        :param _builtins.str name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param _builtins.str open_api_schema: (Output)
               The OpenAPI schema of the toolset.
        :param Sequence['AppVersionSnapshotToolOpenApiToolServiceDirectoryConfigArgs'] service_directory_configs: (Output)
               Configuration for tools using Service Directory.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotToolOpenApiToolTlsConfigArgs'] tls_configs: (Output)
               The TLS configuration.
               Structure is documented below.
        :param _builtins.str url: (Output)
               The server URL of the Open API schema.
               This field is only set in toolsets in the environment dependencies
               during the export process if the schema contains a server url.
               During the import process, if this url is present in the environment dependencies
               and the schema has the $env_var placeholder,
               it will replace the placeholder in the schema.
        """
        if api_authentications is not None:
            pulumi.set(__self__, "api_authentications", api_authentications)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ignore_unknown_fields is not None:
            pulumi.set(__self__, "ignore_unknown_fields", ignore_unknown_fields)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if open_api_schema is not None:
            pulumi.set(__self__, "open_api_schema", open_api_schema)
        if service_directory_configs is not None:
            pulumi.set(__self__, "service_directory_configs", service_directory_configs)
        if tls_configs is not None:
            pulumi.set(__self__, "tls_configs", tls_configs)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="apiAuthentications")
    def api_authentications(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolOpenApiToolApiAuthentication']]:
        """
        (Output)
        Authentication information required for API calls.
        Structure is documented below.
        """
        return pulumi.get(self, "api_authentications")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="ignoreUnknownFields")
    def ignore_unknown_fields(self) -> Optional[_builtins.bool]:
        """
        (Output)
        If true, the agent will ignore unknown fields in the API response for all
        operations defined in the OpenAPI schema.
        """
        return pulumi.get(self, "ignore_unknown_fields")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="openApiSchema")
    def open_api_schema(self) -> Optional[_builtins.str]:
        """
        (Output)
        The OpenAPI schema of the toolset.
        """
        return pulumi.get(self, "open_api_schema")

    @_builtins.property
    @pulumi.getter(name="serviceDirectoryConfigs")
    def service_directory_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolOpenApiToolServiceDirectoryConfig']]:
        """
        (Output)
        Configuration for tools using Service Directory.
        Structure is documented below.
        """
        return pulumi.get(self, "service_directory_configs")

    @_builtins.property
    @pulumi.getter(name="tlsConfigs")
    def tls_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolOpenApiToolTlsConfig']]:
        """
        (Output)
        The TLS configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "tls_configs")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        (Output)
        The server URL of the Open API schema.
        This field is only set in toolsets in the environment dependencies
        during the export process if the schema contains a server url.
        During the import process, if this url is present in the environment dependencies
        and the schema has the $env_var placeholder,
        it will replace the placeholder in the schema.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AppVersionSnapshotToolOpenApiToolApiAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKeyConfigs":
            suggest = "api_key_configs"
        elif key == "oauthConfigs":
            suggest = "oauth_configs"
        elif key == "serviceAccountAuthConfigs":
            suggest = "service_account_auth_configs"
        elif key == "serviceAgentIdTokenAuthConfigs":
            suggest = "service_agent_id_token_auth_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolOpenApiToolApiAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolOpenApiToolApiAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolOpenApiToolApiAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key_configs: Optional[Sequence['outputs.AppVersionSnapshotToolOpenApiToolApiAuthenticationApiKeyConfig']] = None,
                 oauth_configs: Optional[Sequence['outputs.AppVersionSnapshotToolOpenApiToolApiAuthenticationOauthConfig']] = None,
                 service_account_auth_configs: Optional[Sequence['outputs.AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAccountAuthConfig']] = None,
                 service_agent_id_token_auth_configs: Optional[Sequence['outputs.AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfig']] = None):
        """
        :param Sequence['AppVersionSnapshotToolOpenApiToolApiAuthenticationApiKeyConfigArgs'] api_key_configs: (Output)
               Configurations for authentication with API key.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotToolOpenApiToolApiAuthenticationOauthConfigArgs'] oauth_configs: (Output)
               Configurations for authentication with OAuth.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs'] service_account_auth_configs: (Output)
               Configurations for authentication using a custom service account.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs'] service_agent_id_token_auth_configs: (Output)
               Configurations for authentication with [ID
               token](https://cloud.google.com/docs/authentication/token-types#id) generated
               from service agent.
        """
        if api_key_configs is not None:
            pulumi.set(__self__, "api_key_configs", api_key_configs)
        if oauth_configs is not None:
            pulumi.set(__self__, "oauth_configs", oauth_configs)
        if service_account_auth_configs is not None:
            pulumi.set(__self__, "service_account_auth_configs", service_account_auth_configs)
        if service_agent_id_token_auth_configs is not None:
            pulumi.set(__self__, "service_agent_id_token_auth_configs", service_agent_id_token_auth_configs)

    @_builtins.property
    @pulumi.getter(name="apiKeyConfigs")
    def api_key_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolOpenApiToolApiAuthenticationApiKeyConfig']]:
        """
        (Output)
        Configurations for authentication with API key.
        Structure is documented below.
        """
        return pulumi.get(self, "api_key_configs")

    @_builtins.property
    @pulumi.getter(name="oauthConfigs")
    def oauth_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolOpenApiToolApiAuthenticationOauthConfig']]:
        """
        (Output)
        Configurations for authentication with OAuth.
        Structure is documented below.
        """
        return pulumi.get(self, "oauth_configs")

    @_builtins.property
    @pulumi.getter(name="serviceAccountAuthConfigs")
    def service_account_auth_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAccountAuthConfig']]:
        """
        (Output)
        Configurations for authentication using a custom service account.
        Structure is documented below.
        """
        return pulumi.get(self, "service_account_auth_configs")

    @_builtins.property
    @pulumi.getter(name="serviceAgentIdTokenAuthConfigs")
    def service_agent_id_token_auth_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfig']]:
        """
        (Output)
        Configurations for authentication with [ID
        token](https://cloud.google.com/docs/authentication/token-types#id) generated
        from service agent.
        """
        return pulumi.get(self, "service_agent_id_token_auth_configs")


@pulumi.output_type
class AppVersionSnapshotToolOpenApiToolApiAuthenticationApiKeyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKeySecretVersion":
            suggest = "api_key_secret_version"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "requestLocation":
            suggest = "request_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolOpenApiToolApiAuthenticationApiKeyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolOpenApiToolApiAuthenticationApiKeyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolOpenApiToolApiAuthenticationApiKeyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key_secret_version: Optional[_builtins.str] = None,
                 key_name: Optional[_builtins.str] = None,
                 request_location: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key_secret_version: (Output)
               The name of the SecretManager secret version resource storing the API key.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param _builtins.str key_name: (Output)
               The parameter name or the header name of the API key.
               E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        :param _builtins.str request_location: (Output)
               Key location in the request.
               Possible values:
               HEADER
               QUERY_STRING
        """
        if api_key_secret_version is not None:
            pulumi.set(__self__, "api_key_secret_version", api_key_secret_version)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if request_location is not None:
            pulumi.set(__self__, "request_location", request_location)

    @_builtins.property
    @pulumi.getter(name="apiKeySecretVersion")
    def api_key_secret_version(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the SecretManager secret version resource storing the API key.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "api_key_secret_version")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter(name="requestLocation")
    def request_location(self) -> Optional[_builtins.str]:
        """
        (Output)
        Key location in the request.
        Possible values:
        HEADER
        QUERY_STRING
        """
        return pulumi.get(self, "request_location")


@pulumi.output_type
class AppVersionSnapshotToolOpenApiToolApiAuthenticationOauthConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretVersion":
            suggest = "client_secret_version"
        elif key == "oauthGrantType":
            suggest = "oauth_grant_type"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolOpenApiToolApiAuthenticationOauthConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolOpenApiToolApiAuthenticationOauthConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolOpenApiToolApiAuthenticationOauthConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 client_secret_version: Optional[_builtins.str] = None,
                 oauth_grant_type: Optional[_builtins.str] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 token_endpoint: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: (Output)
               The client ID from the OAuth provider.
        :param _builtins.str client_secret_version: (Output)
               The name of the SecretManager secret version resource storing the
               client secret.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param _builtins.str oauth_grant_type: (Output)
               OAuth grant types.
               Possible values:
               CLIENT_CREDENTIAL
        :param Sequence[_builtins.str] scopes: (Output)
               The OAuth scopes to grant.
        :param _builtins.str token_endpoint: (Output)
               The token endpoint in the OAuth provider to exchange for an access token.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_version is not None:
            pulumi.set(__self__, "client_secret_version", client_secret_version)
        if oauth_grant_type is not None:
            pulumi.set(__self__, "oauth_grant_type", oauth_grant_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        (Output)
        The client ID from the OAuth provider.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecretVersion")
    def client_secret_version(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the SecretManager secret version resource storing the
        client secret.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "client_secret_version")

    @_builtins.property
    @pulumi.getter(name="oauthGrantType")
    def oauth_grant_type(self) -> Optional[_builtins.str]:
        """
        (Output)
        OAuth grant types.
        Possible values:
        CLIENT_CREDENTIAL
        """
        return pulumi.get(self, "oauth_grant_type")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        The OAuth scopes to grant.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[_builtins.str]:
        """
        (Output)
        The token endpoint in the OAuth provider to exchange for an access token.
        """
        return pulumi.get(self, "token_endpoint")


@pulumi.output_type
class AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAccountAuthConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccount":
            suggest = "service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAccountAuthConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAccountAuthConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAccountAuthConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_account: (Output)
               The email address of the service account used for authenticatation. CES
               uses this service account to exchange an access token and the access token
               is then sent in the `Authorization` header of the request.
               The service account must have the
               `roles/iam.serviceAccountTokenCreator` role granted to the
               CES service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[_builtins.str]:
        """
        (Output)
        The email address of the service account used for authenticatation. CES
        uses this service account to exchange an access token and the access token
        is then sent in the `Authorization` header of the request.
        The service account must have the
        `roles/iam.serviceAccountTokenCreator` role granted to the
        CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "service_account")


@pulumi.output_type
class AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class AppVersionSnapshotToolOpenApiToolServiceDirectoryConfig(dict):
    def __init__(__self__, *,
                 service: Optional[_builtins.str] = None):
        """
        :param _builtins.str service: (Output)
               The name of [Service
               Directory](https://cloud.google.com/service-directory) service.
               Format:
               `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
               Location of the service directory must be the same as the location of the
               app.
        """
        if service is not None:
            pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of [Service
        Directory](https://cloud.google.com/service-directory) service.
        Format:
        `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
        Location of the service directory must be the same as the location of the
        app.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class AppVersionSnapshotToolOpenApiToolTlsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCerts":
            suggest = "ca_certs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolOpenApiToolTlsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolOpenApiToolTlsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolOpenApiToolTlsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certs: Optional[Sequence['outputs.AppVersionSnapshotToolOpenApiToolTlsConfigCaCert']] = None):
        """
        :param Sequence['AppVersionSnapshotToolOpenApiToolTlsConfigCaCertArgs'] ca_certs: (Output)
               Specifies a list of allowed custom CA certificates for HTTPS
               verification.
               Structure is documented below.
        """
        if ca_certs is not None:
            pulumi.set(__self__, "ca_certs", ca_certs)

    @_builtins.property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolOpenApiToolTlsConfigCaCert']]:
        """
        (Output)
        Specifies a list of allowed custom CA certificates for HTTPS
        verification.
        Structure is documented below.
        """
        return pulumi.get(self, "ca_certs")


@pulumi.output_type
class AppVersionSnapshotToolOpenApiToolTlsConfigCaCert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolOpenApiToolTlsConfigCaCert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolOpenApiToolTlsConfigCaCert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolOpenApiToolTlsConfigCaCert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str cert: (Output)
               The allowed custom CA certificates (in DER format) for
               HTTPS verification. This overrides the default SSL trust store. If this
               is empty or unspecified, CES will use Google's default trust
               store to verify certificates. N.B. Make sure the HTTPS server
               certificates are signed with "subject alt name". For instance a
               certificate can be self-signed using the following command,
               openssl x509 -req -days 200 -in example.com.csr \\
               -signkey example.com.key \\
               -out example.com.crt \\
               -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        :param _builtins.str display_name: The display name of the app version.
        """
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> Optional[_builtins.str]:
        """
        (Output)
        The allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, CES will use Google's default trust
        store to verify certificates. N.B. Make sure the HTTPS server
        certificates are signed with "subject alt name". For instance a
        certificate can be self-signed using the following command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        """
        return pulumi.get(self, "cert")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class AppVersionSnapshotToolPythonFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolPythonFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolPythonFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolPythonFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 python_code: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: The description of the app version.
        :param _builtins.str name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param _builtins.str python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[_builtins.str]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")


@pulumi.output_type
class AppVersionSnapshotToolSystemTool(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: The description of the app version.
        :param _builtins.str name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class AppVersionSnapshotToolset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "createTime":
            suggest = "create_time"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "executionType":
            suggest = "execution_type"
        elif key == "openApiToolsets":
            suggest = "open_api_toolsets"
        elif key == "updateTime":
            suggest = "update_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 create_time: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 etag: Optional[_builtins.str] = None,
                 execution_type: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 open_api_toolsets: Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolset']] = None,
                 update_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str create_time: (Output)
               Timestamp when the toolset was created.
        :param _builtins.str description: The description of the app version.
        :param _builtins.str display_name: The display name of the app version.
        :param _builtins.str etag: (Output)
               ETag used to ensure the object hasn't changed during a read-modify-write
               operation. If the etag is empty, the update will overwrite any concurrent
               changes.
        :param _builtins.str execution_type: (Output)
               Possible values:
               SYNCHRONOUS
               ASYNCHRONOUS
        :param _builtins.str name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param Sequence['AppVersionSnapshotToolsetOpenApiToolsetArgs'] open_api_toolsets: (Output)
               A toolset that contains a list of tools that are defined by an OpenAPI
               schema.
               Structure is documented below.
        :param _builtins.str update_time: (Output)
               Timestamp when the toolset was last updated.
        """
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if etag is not None:
            pulumi.set(__self__, "etag", etag)
        if execution_type is not None:
            pulumi.set(__self__, "execution_type", execution_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if open_api_toolsets is not None:
            pulumi.set(__self__, "open_api_toolsets", open_api_toolsets)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        Timestamp when the toolset was created.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def etag(self) -> Optional[_builtins.str]:
        """
        (Output)
        ETag used to ensure the object hasn't changed during a read-modify-write
        operation. If the etag is empty, the update will overwrite any concurrent
        changes.
        """
        return pulumi.get(self, "etag")

    @_builtins.property
    @pulumi.getter(name="executionType")
    def execution_type(self) -> Optional[_builtins.str]:
        """
        (Output)
        Possible values:
        SYNCHRONOUS
        ASYNCHRONOUS
        """
        return pulumi.get(self, "execution_type")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="openApiToolsets")
    def open_api_toolsets(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolset']]:
        """
        (Output)
        A toolset that contains a list of tools that are defined by an OpenAPI
        schema.
        Structure is documented below.
        """
        return pulumi.get(self, "open_api_toolsets")

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        Timestamp when the toolset was last updated.
        """
        return pulumi.get(self, "update_time")


@pulumi.output_type
class AppVersionSnapshotToolsetOpenApiToolset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiAuthentications":
            suggest = "api_authentications"
        elif key == "ignoreUnknownFields":
            suggest = "ignore_unknown_fields"
        elif key == "openApiSchema":
            suggest = "open_api_schema"
        elif key == "serviceDirectoryConfigs":
            suggest = "service_directory_configs"
        elif key == "tlsConfigs":
            suggest = "tls_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolsetOpenApiToolset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolsetOpenApiToolset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolsetOpenApiToolset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_authentications: Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolsetApiAuthentication']] = None,
                 ignore_unknown_fields: Optional[_builtins.bool] = None,
                 open_api_schema: Optional[_builtins.str] = None,
                 service_directory_configs: Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolsetServiceDirectoryConfig']] = None,
                 tls_configs: Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolsetTlsConfig']] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param Sequence['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationArgs'] api_authentications: (Output)
               Authentication information required for API calls.
               Structure is documented below.
        :param _builtins.bool ignore_unknown_fields: (Output)
               If true, the agent will ignore unknown fields in the API response for all
               operations defined in the OpenAPI schema.
        :param _builtins.str open_api_schema: (Output)
               The OpenAPI schema of the toolset.
        :param Sequence['AppVersionSnapshotToolsetOpenApiToolsetServiceDirectoryConfigArgs'] service_directory_configs: (Output)
               Configuration for tools using Service Directory.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotToolsetOpenApiToolsetTlsConfigArgs'] tls_configs: (Output)
               The TLS configuration.
               Structure is documented below.
        :param _builtins.str url: (Output)
               The server URL of the Open API schema.
               This field is only set in toolsets in the environment dependencies
               during the export process if the schema contains a server url.
               During the import process, if this url is present in the environment dependencies
               and the schema has the $env_var placeholder,
               it will replace the placeholder in the schema.
        """
        if api_authentications is not None:
            pulumi.set(__self__, "api_authentications", api_authentications)
        if ignore_unknown_fields is not None:
            pulumi.set(__self__, "ignore_unknown_fields", ignore_unknown_fields)
        if open_api_schema is not None:
            pulumi.set(__self__, "open_api_schema", open_api_schema)
        if service_directory_configs is not None:
            pulumi.set(__self__, "service_directory_configs", service_directory_configs)
        if tls_configs is not None:
            pulumi.set(__self__, "tls_configs", tls_configs)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="apiAuthentications")
    def api_authentications(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolsetApiAuthentication']]:
        """
        (Output)
        Authentication information required for API calls.
        Structure is documented below.
        """
        return pulumi.get(self, "api_authentications")

    @_builtins.property
    @pulumi.getter(name="ignoreUnknownFields")
    def ignore_unknown_fields(self) -> Optional[_builtins.bool]:
        """
        (Output)
        If true, the agent will ignore unknown fields in the API response for all
        operations defined in the OpenAPI schema.
        """
        return pulumi.get(self, "ignore_unknown_fields")

    @_builtins.property
    @pulumi.getter(name="openApiSchema")
    def open_api_schema(self) -> Optional[_builtins.str]:
        """
        (Output)
        The OpenAPI schema of the toolset.
        """
        return pulumi.get(self, "open_api_schema")

    @_builtins.property
    @pulumi.getter(name="serviceDirectoryConfigs")
    def service_directory_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolsetServiceDirectoryConfig']]:
        """
        (Output)
        Configuration for tools using Service Directory.
        Structure is documented below.
        """
        return pulumi.get(self, "service_directory_configs")

    @_builtins.property
    @pulumi.getter(name="tlsConfigs")
    def tls_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolsetTlsConfig']]:
        """
        (Output)
        The TLS configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "tls_configs")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        (Output)
        The server URL of the Open API schema.
        This field is only set in toolsets in the environment dependencies
        during the export process if the schema contains a server url.
        During the import process, if this url is present in the environment dependencies
        and the schema has the $env_var placeholder,
        it will replace the placeholder in the schema.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class AppVersionSnapshotToolsetOpenApiToolsetApiAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKeyConfigs":
            suggest = "api_key_configs"
        elif key == "bearerTokenConfigs":
            suggest = "bearer_token_configs"
        elif key == "oauthConfigs":
            suggest = "oauth_configs"
        elif key == "serviceAccountAuthConfigs":
            suggest = "service_account_auth_configs"
        elif key == "serviceAgentIdTokenAuthConfigs":
            suggest = "service_agent_id_token_auth_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolsetOpenApiToolsetApiAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolsetOpenApiToolsetApiAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolsetOpenApiToolsetApiAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key_configs: Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationApiKeyConfig']] = None,
                 bearer_token_configs: Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationBearerTokenConfig']] = None,
                 oauth_configs: Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationOauthConfig']] = None,
                 service_account_auth_configs: Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfig']] = None,
                 service_agent_id_token_auth_configs: Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfig']] = None):
        """
        :param Sequence['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs'] api_key_configs: (Output)
               Configurations for authentication with API key.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs'] bearer_token_configs: (Output)
               Configurations for authentication with a bearer token.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs'] oauth_configs: (Output)
               Configurations for authentication with OAuth.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs'] service_account_auth_configs: (Output)
               Configurations for authentication using a custom service account.
               Structure is documented below.
        :param Sequence['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs'] service_agent_id_token_auth_configs: (Output)
               Configurations for authentication with [ID
               token](https://cloud.google.com/docs/authentication/token-types#id) generated
               from service agent.
        """
        if api_key_configs is not None:
            pulumi.set(__self__, "api_key_configs", api_key_configs)
        if bearer_token_configs is not None:
            pulumi.set(__self__, "bearer_token_configs", bearer_token_configs)
        if oauth_configs is not None:
            pulumi.set(__self__, "oauth_configs", oauth_configs)
        if service_account_auth_configs is not None:
            pulumi.set(__self__, "service_account_auth_configs", service_account_auth_configs)
        if service_agent_id_token_auth_configs is not None:
            pulumi.set(__self__, "service_agent_id_token_auth_configs", service_agent_id_token_auth_configs)

    @_builtins.property
    @pulumi.getter(name="apiKeyConfigs")
    def api_key_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationApiKeyConfig']]:
        """
        (Output)
        Configurations for authentication with API key.
        Structure is documented below.
        """
        return pulumi.get(self, "api_key_configs")

    @_builtins.property
    @pulumi.getter(name="bearerTokenConfigs")
    def bearer_token_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationBearerTokenConfig']]:
        """
        (Output)
        Configurations for authentication with a bearer token.
        Structure is documented below.
        """
        return pulumi.get(self, "bearer_token_configs")

    @_builtins.property
    @pulumi.getter(name="oauthConfigs")
    def oauth_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationOauthConfig']]:
        """
        (Output)
        Configurations for authentication with OAuth.
        Structure is documented below.
        """
        return pulumi.get(self, "oauth_configs")

    @_builtins.property
    @pulumi.getter(name="serviceAccountAuthConfigs")
    def service_account_auth_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfig']]:
        """
        (Output)
        Configurations for authentication using a custom service account.
        Structure is documented below.
        """
        return pulumi.get(self, "service_account_auth_configs")

    @_builtins.property
    @pulumi.getter(name="serviceAgentIdTokenAuthConfigs")
    def service_agent_id_token_auth_configs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfig']]:
        """
        (Output)
        Configurations for authentication with [ID
        token](https://cloud.google.com/docs/authentication/token-types#id) generated
        from service agent.
        """
        return pulumi.get(self, "service_agent_id_token_auth_configs")


@pulumi.output_type
class AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationApiKeyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKeySecretVersion":
            suggest = "api_key_secret_version"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "requestLocation":
            suggest = "request_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationApiKeyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationApiKeyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationApiKeyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key_secret_version: Optional[_builtins.str] = None,
                 key_name: Optional[_builtins.str] = None,
                 request_location: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key_secret_version: (Output)
               The name of the SecretManager secret version resource storing the API key.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param _builtins.str key_name: (Output)
               The parameter name or the header name of the API key.
               E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        :param _builtins.str request_location: (Output)
               Key location in the request.
               Possible values:
               HEADER
               QUERY_STRING
        """
        if api_key_secret_version is not None:
            pulumi.set(__self__, "api_key_secret_version", api_key_secret_version)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if request_location is not None:
            pulumi.set(__self__, "request_location", request_location)

    @_builtins.property
    @pulumi.getter(name="apiKeySecretVersion")
    def api_key_secret_version(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the SecretManager secret version resource storing the API key.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "api_key_secret_version")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter(name="requestLocation")
    def request_location(self) -> Optional[_builtins.str]:
        """
        (Output)
        Key location in the request.
        Possible values:
        HEADER
        QUERY_STRING
        """
        return pulumi.get(self, "request_location")


@pulumi.output_type
class AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationBearerTokenConfig(dict):
    def __init__(__self__, *,
                 token: Optional[_builtins.str] = None):
        """
        :param _builtins.str token: (Output)
        """
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        (Output)
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationOauthConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretVersion":
            suggest = "client_secret_version"
        elif key == "oauthGrantType":
            suggest = "oauth_grant_type"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationOauthConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationOauthConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationOauthConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 client_secret_version: Optional[_builtins.str] = None,
                 oauth_grant_type: Optional[_builtins.str] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 token_endpoint: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: (Output)
               The client ID from the OAuth provider.
        :param _builtins.str client_secret_version: (Output)
               The name of the SecretManager secret version resource storing the
               client secret.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param _builtins.str oauth_grant_type: (Output)
               OAuth grant types.
               Possible values:
               CLIENT_CREDENTIAL
        :param Sequence[_builtins.str] scopes: (Output)
               The OAuth scopes to grant.
        :param _builtins.str token_endpoint: (Output)
               The token endpoint in the OAuth provider to exchange for an access token.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_version is not None:
            pulumi.set(__self__, "client_secret_version", client_secret_version)
        if oauth_grant_type is not None:
            pulumi.set(__self__, "oauth_grant_type", oauth_grant_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        (Output)
        The client ID from the OAuth provider.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecretVersion")
    def client_secret_version(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the SecretManager secret version resource storing the
        client secret.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "client_secret_version")

    @_builtins.property
    @pulumi.getter(name="oauthGrantType")
    def oauth_grant_type(self) -> Optional[_builtins.str]:
        """
        (Output)
        OAuth grant types.
        Possible values:
        CLIENT_CREDENTIAL
        """
        return pulumi.get(self, "oauth_grant_type")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        The OAuth scopes to grant.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[_builtins.str]:
        """
        (Output)
        The token endpoint in the OAuth provider to exchange for an access token.
        """
        return pulumi.get(self, "token_endpoint")


@pulumi.output_type
class AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccount":
            suggest = "service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_account: (Output)
               The email address of the service account used for authenticatation. CES
               uses this service account to exchange an access token and the access token
               is then sent in the `Authorization` header of the request.
               The service account must have the
               `roles/iam.serviceAccountTokenCreator` role granted to the
               CES service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[_builtins.str]:
        """
        (Output)
        The email address of the service account used for authenticatation. CES
        uses this service account to exchange an access token and the access token
        is then sent in the `Authorization` header of the request.
        The service account must have the
        `roles/iam.serviceAccountTokenCreator` role granted to the
        CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "service_account")


@pulumi.output_type
class AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class AppVersionSnapshotToolsetOpenApiToolsetServiceDirectoryConfig(dict):
    def __init__(__self__, *,
                 service: Optional[_builtins.str] = None):
        """
        :param _builtins.str service: (Output)
               The name of [Service
               Directory](https://cloud.google.com/service-directory) service.
               Format:
               `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
               Location of the service directory must be the same as the location of the
               app.
        """
        if service is not None:
            pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of [Service
        Directory](https://cloud.google.com/service-directory) service.
        Format:
        `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
        Location of the service directory must be the same as the location of the
        app.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class AppVersionSnapshotToolsetOpenApiToolsetTlsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCerts":
            suggest = "ca_certs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolsetOpenApiToolsetTlsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolsetOpenApiToolsetTlsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolsetOpenApiToolsetTlsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certs: Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolsetTlsConfigCaCert']] = None):
        """
        :param Sequence['AppVersionSnapshotToolsetOpenApiToolsetTlsConfigCaCertArgs'] ca_certs: (Output)
               Specifies a list of allowed custom CA certificates for HTTPS
               verification.
               Structure is documented below.
        """
        if ca_certs is not None:
            pulumi.set(__self__, "ca_certs", ca_certs)

    @_builtins.property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> Optional[Sequence['outputs.AppVersionSnapshotToolsetOpenApiToolsetTlsConfigCaCert']]:
        """
        (Output)
        Specifies a list of allowed custom CA certificates for HTTPS
        verification.
        Structure is documented below.
        """
        return pulumi.get(self, "ca_certs")


@pulumi.output_type
class AppVersionSnapshotToolsetOpenApiToolsetTlsConfigCaCert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AppVersionSnapshotToolsetOpenApiToolsetTlsConfigCaCert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AppVersionSnapshotToolsetOpenApiToolsetTlsConfigCaCert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AppVersionSnapshotToolsetOpenApiToolsetTlsConfigCaCert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str cert: (Output)
               The allowed custom CA certificates (in DER format) for
               HTTPS verification. This overrides the default SSL trust store. If this
               is empty or unspecified, CES will use Google's default trust
               store to verify certificates. N.B. Make sure the HTTPS server
               certificates are signed with "subject alt name". For instance a
               certificate can be self-signed using the following command,
               openssl x509 -req -days 200 -in example.com.csr \\
               -signkey example.com.key \\
               -out example.com.crt \\
               -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        :param _builtins.str display_name: The display name of the app version.
        """
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> Optional[_builtins.str]:
        """
        (Output)
        The allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, CES will use Google's default trust
        store to verify certificates. N.B. Make sure the HTTPS server
        certificates are signed with "subject alt name". For instance a
        certificate can be self-signed using the following command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        """
        return pulumi.get(self, "cert")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class DeploymentChannelProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "channelType":
            suggest = "channel_type"
        elif key == "disableBargeInControl":
            suggest = "disable_barge_in_control"
        elif key == "disableDtmf":
            suggest = "disable_dtmf"
        elif key == "personaProperty":
            suggest = "persona_property"
        elif key == "profileId":
            suggest = "profile_id"
        elif key == "webWidgetConfig":
            suggest = "web_widget_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentChannelProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentChannelProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentChannelProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 channel_type: Optional[_builtins.str] = None,
                 disable_barge_in_control: Optional[_builtins.bool] = None,
                 disable_dtmf: Optional[_builtins.bool] = None,
                 persona_property: Optional['outputs.DeploymentChannelProfilePersonaProperty'] = None,
                 profile_id: Optional[_builtins.str] = None,
                 web_widget_config: Optional['outputs.DeploymentChannelProfileWebWidgetConfig'] = None):
        """
        :param _builtins.str channel_type: The type of the channel profile.
               Possible values:
               UNKNOWN
               WEB_UI
               API
               TWILIO
               GOOGLE_TELEPHONY_PLATFORM
               CONTACT_CENTER_AS_A_SERVICE
        :param _builtins.bool disable_barge_in_control: Whether to disable user barge-in control in the conversation.
               - **true**: User interruptions are disabled while the agent is speaking.
               - **false**: The agent retains automatic control over when the user can
               interrupt.
        :param _builtins.bool disable_dtmf: Whether to disable DTMF (dual-tone multi-frequency).
        :param 'DeploymentChannelProfilePersonaPropertyArgs' persona_property: Represents the persona property of a channel.
               Structure is documented below.
        :param _builtins.str profile_id: The unique identifier of the channel profile.
        :param 'DeploymentChannelProfileWebWidgetConfigArgs' web_widget_config: Message for configuration for the web widget.
               Structure is documented below.
        """
        if channel_type is not None:
            pulumi.set(__self__, "channel_type", channel_type)
        if disable_barge_in_control is not None:
            pulumi.set(__self__, "disable_barge_in_control", disable_barge_in_control)
        if disable_dtmf is not None:
            pulumi.set(__self__, "disable_dtmf", disable_dtmf)
        if persona_property is not None:
            pulumi.set(__self__, "persona_property", persona_property)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if web_widget_config is not None:
            pulumi.set(__self__, "web_widget_config", web_widget_config)

    @_builtins.property
    @pulumi.getter(name="channelType")
    def channel_type(self) -> Optional[_builtins.str]:
        """
        The type of the channel profile.
        Possible values:
        UNKNOWN
        WEB_UI
        API
        TWILIO
        GOOGLE_TELEPHONY_PLATFORM
        CONTACT_CENTER_AS_A_SERVICE
        """
        return pulumi.get(self, "channel_type")

    @_builtins.property
    @pulumi.getter(name="disableBargeInControl")
    def disable_barge_in_control(self) -> Optional[_builtins.bool]:
        """
        Whether to disable user barge-in control in the conversation.
        - **true**: User interruptions are disabled while the agent is speaking.
        - **false**: The agent retains automatic control over when the user can
        interrupt.
        """
        return pulumi.get(self, "disable_barge_in_control")

    @_builtins.property
    @pulumi.getter(name="disableDtmf")
    def disable_dtmf(self) -> Optional[_builtins.bool]:
        """
        Whether to disable DTMF (dual-tone multi-frequency).
        """
        return pulumi.get(self, "disable_dtmf")

    @_builtins.property
    @pulumi.getter(name="personaProperty")
    def persona_property(self) -> Optional['outputs.DeploymentChannelProfilePersonaProperty']:
        """
        Represents the persona property of a channel.
        Structure is documented below.
        """
        return pulumi.get(self, "persona_property")

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[_builtins.str]:
        """
        The unique identifier of the channel profile.
        """
        return pulumi.get(self, "profile_id")

    @_builtins.property
    @pulumi.getter(name="webWidgetConfig")
    def web_widget_config(self) -> Optional['outputs.DeploymentChannelProfileWebWidgetConfig']:
        """
        Message for configuration for the web widget.
        Structure is documented below.
        """
        return pulumi.get(self, "web_widget_config")


@pulumi.output_type
class DeploymentChannelProfilePersonaProperty(dict):
    def __init__(__self__, *,
                 persona: Optional[_builtins.str] = None):
        """
        :param _builtins.str persona: The persona of the channel.
               Possible values:
               UNKNOWN
               CONCISE
               CHATTY
        """
        if persona is not None:
            pulumi.set(__self__, "persona", persona)

    @_builtins.property
    @pulumi.getter
    def persona(self) -> Optional[_builtins.str]:
        """
        The persona of the channel.
        Possible values:
        UNKNOWN
        CONCISE
        CHATTY
        """
        return pulumi.get(self, "persona")


@pulumi.output_type
class DeploymentChannelProfileWebWidgetConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "webWidgetTitle":
            suggest = "web_widget_title"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DeploymentChannelProfileWebWidgetConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DeploymentChannelProfileWebWidgetConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DeploymentChannelProfileWebWidgetConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 modality: Optional[_builtins.str] = None,
                 theme: Optional[_builtins.str] = None,
                 web_widget_title: Optional[_builtins.str] = None):
        """
        :param _builtins.str modality: The modality of the web widget.
               Possible values:
               UNKNOWN_MODALITY
               CHAT_AND_VOICE
               VOICE_ONLY
               CHAT_ONLY
        :param _builtins.str theme: The theme of the web widget.
               Possible values:
               UNKNOWN_THEME
               LIGHT
               DARK
        :param _builtins.str web_widget_title: The title of the web widget.
        """
        if modality is not None:
            pulumi.set(__self__, "modality", modality)
        if theme is not None:
            pulumi.set(__self__, "theme", theme)
        if web_widget_title is not None:
            pulumi.set(__self__, "web_widget_title", web_widget_title)

    @_builtins.property
    @pulumi.getter
    def modality(self) -> Optional[_builtins.str]:
        """
        The modality of the web widget.
        Possible values:
        UNKNOWN_MODALITY
        CHAT_AND_VOICE
        VOICE_ONLY
        CHAT_ONLY
        """
        return pulumi.get(self, "modality")

    @_builtins.property
    @pulumi.getter
    def theme(self) -> Optional[_builtins.str]:
        """
        The theme of the web widget.
        Possible values:
        UNKNOWN_THEME
        LIGHT
        DARK
        """
        return pulumi.get(self, "theme")

    @_builtins.property
    @pulumi.getter(name="webWidgetTitle")
    def web_widget_title(self) -> Optional[_builtins.str]:
        """
        The title of the web widget.
        """
        return pulumi.get(self, "web_widget_title")


@pulumi.output_type
class ExampleMessage(dict):
    def __init__(__self__, *,
                 chunks: Optional[Sequence['outputs.ExampleMessageChunk']] = None,
                 role: Optional[_builtins.str] = None):
        """
        :param Sequence['ExampleMessageChunkArgs'] chunks: Content of the message as a series of chunks.
               Structure is documented below.
        :param _builtins.str role: The role within the conversation, e.g., user, agent.
        """
        if chunks is not None:
            pulumi.set(__self__, "chunks", chunks)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def chunks(self) -> Optional[Sequence['outputs.ExampleMessageChunk']]:
        """
        Content of the message as a series of chunks.
        Structure is documented below.
        """
        return pulumi.get(self, "chunks")

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[_builtins.str]:
        """
        The role within the conversation, e.g., user, agent.
        """
        return pulumi.get(self, "role")


@pulumi.output_type
class ExampleMessageChunk(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentTransfer":
            suggest = "agent_transfer"
        elif key == "toolCall":
            suggest = "tool_call"
        elif key == "toolResponse":
            suggest = "tool_response"
        elif key == "updatedVariables":
            suggest = "updated_variables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExampleMessageChunk. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExampleMessageChunk.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExampleMessageChunk.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_transfer: Optional['outputs.ExampleMessageChunkAgentTransfer'] = None,
                 image: Optional['outputs.ExampleMessageChunkImage'] = None,
                 text: Optional[_builtins.str] = None,
                 tool_call: Optional['outputs.ExampleMessageChunkToolCall'] = None,
                 tool_response: Optional['outputs.ExampleMessageChunkToolResponse'] = None,
                 updated_variables: Optional[_builtins.str] = None):
        """
        :param 'ExampleMessageChunkAgentTransferArgs' agent_transfer: Represents an event indicating the transfer of a conversation to a different
               agent.
               Structure is documented below.
        :param 'ExampleMessageChunkImageArgs' image: Represents an image input or output in the conversation.
               Structure is documented below.
        :param _builtins.str text: Text data.
        :param 'ExampleMessageChunkToolCallArgs' tool_call: Request for the client or the agent to execute the specified tool.
               Structure is documented below.
        :param 'ExampleMessageChunkToolResponseArgs' tool_response: The execution result of a specific tool from the client or the agent.
               Structure is documented below.
        :param _builtins.str updated_variables: A struct represents variables that were updated in the conversation,
               keyed by variable names.
        """
        if agent_transfer is not None:
            pulumi.set(__self__, "agent_transfer", agent_transfer)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if tool_call is not None:
            pulumi.set(__self__, "tool_call", tool_call)
        if tool_response is not None:
            pulumi.set(__self__, "tool_response", tool_response)
        if updated_variables is not None:
            pulumi.set(__self__, "updated_variables", updated_variables)

    @_builtins.property
    @pulumi.getter(name="agentTransfer")
    def agent_transfer(self) -> Optional['outputs.ExampleMessageChunkAgentTransfer']:
        """
        Represents an event indicating the transfer of a conversation to a different
        agent.
        Structure is documented below.
        """
        return pulumi.get(self, "agent_transfer")

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional['outputs.ExampleMessageChunkImage']:
        """
        Represents an image input or output in the conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "image")

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[_builtins.str]:
        """
        Text data.
        """
        return pulumi.get(self, "text")

    @_builtins.property
    @pulumi.getter(name="toolCall")
    def tool_call(self) -> Optional['outputs.ExampleMessageChunkToolCall']:
        """
        Request for the client or the agent to execute the specified tool.
        Structure is documented below.
        """
        return pulumi.get(self, "tool_call")

    @_builtins.property
    @pulumi.getter(name="toolResponse")
    def tool_response(self) -> Optional['outputs.ExampleMessageChunkToolResponse']:
        """
        The execution result of a specific tool from the client or the agent.
        Structure is documented below.
        """
        return pulumi.get(self, "tool_response")

    @_builtins.property
    @pulumi.getter(name="updatedVariables")
    def updated_variables(self) -> Optional[_builtins.str]:
        """
        A struct represents variables that were updated in the conversation,
        keyed by variable names.
        """
        return pulumi.get(self, "updated_variables")


@pulumi.output_type
class ExampleMessageChunkAgentTransfer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetAgent":
            suggest = "target_agent"
        elif key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExampleMessageChunkAgentTransfer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExampleMessageChunkAgentTransfer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExampleMessageChunkAgentTransfer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_agent: _builtins.str,
                 display_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str target_agent: The agent to which the conversation is being transferred. The agent will
               handle the conversation from this point forward.
               Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        :param _builtins.str display_name: (Output)
               Display name of the agent.
        """
        pulumi.set(__self__, "target_agent", target_agent)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter(name="targetAgent")
    def target_agent(self) -> _builtins.str:
        """
        The agent to which the conversation is being transferred. The agent will
        handle the conversation from this point forward.
        Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        return pulumi.get(self, "target_agent")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        Display name of the agent.
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class ExampleMessageChunkImage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mimeType":
            suggest = "mime_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExampleMessageChunkImage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExampleMessageChunkImage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExampleMessageChunkImage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data: _builtins.str,
                 mime_type: _builtins.str):
        """
        :param _builtins.str data: Raw bytes of the image.
        :param _builtins.str mime_type: The IANA standard MIME type of the source data.
               Supported image types includes:
               * image/png
               * image/jpeg
               * image/webp
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "mime_type", mime_type)

    @_builtins.property
    @pulumi.getter
    def data(self) -> _builtins.str:
        """
        Raw bytes of the image.
        """
        return pulumi.get(self, "data")

    @_builtins.property
    @pulumi.getter(name="mimeType")
    def mime_type(self) -> _builtins.str:
        """
        The IANA standard MIME type of the source data.
        Supported image types includes:
        * image/png
        * image/jpeg
        * image/webp
        """
        return pulumi.get(self, "mime_type")


@pulumi.output_type
class ExampleMessageChunkToolCall(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "toolsetTool":
            suggest = "toolset_tool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExampleMessageChunkToolCall. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExampleMessageChunkToolCall.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExampleMessageChunkToolCall.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 args: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 tool: Optional[_builtins.str] = None,
                 toolset_tool: Optional['outputs.ExampleMessageChunkToolCallToolsetTool'] = None):
        """
        :param _builtins.str args: The input parameters and values for the tool in JSON object format.
        :param _builtins.str display_name: (Output)
               Display name of the tool.
        :param _builtins.str id: The unique identifier of the tool call. If populated, the client should
               return the execution result with the matching ID in
               ToolResponse.
        :param _builtins.str tool: The name of the tool to execute.
               Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        :param 'ExampleMessageChunkToolCallToolsetToolArgs' toolset_tool: A tool that is created from a toolset.
               Structure is documented below.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if tool is not None:
            pulumi.set(__self__, "tool", tool)
        if toolset_tool is not None:
            pulumi.set(__self__, "toolset_tool", toolset_tool)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[_builtins.str]:
        """
        The input parameters and values for the tool in JSON object format.
        """
        return pulumi.get(self, "args")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        Display name of the tool.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The unique identifier of the tool call. If populated, the client should
        return the execution result with the matching ID in
        ToolResponse.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def tool(self) -> Optional[_builtins.str]:
        """
        The name of the tool to execute.
        Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        """
        return pulumi.get(self, "tool")

    @_builtins.property
    @pulumi.getter(name="toolsetTool")
    def toolset_tool(self) -> Optional['outputs.ExampleMessageChunkToolCallToolsetTool']:
        """
        A tool that is created from a toolset.
        Structure is documented below.
        """
        return pulumi.get(self, "toolset_tool")


@pulumi.output_type
class ExampleMessageChunkToolCallToolsetTool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toolId":
            suggest = "tool_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExampleMessageChunkToolCallToolsetTool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExampleMessageChunkToolCallToolsetTool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExampleMessageChunkToolCallToolsetTool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 toolset: _builtins.str,
                 tool_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str toolset: The resource name of the Toolset from which this tool is derived.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param _builtins.str tool_id: The tool ID to filter the tools to retrieve the schema for.
        """
        pulumi.set(__self__, "toolset", toolset)
        if tool_id is not None:
            pulumi.set(__self__, "tool_id", tool_id)

    @_builtins.property
    @pulumi.getter
    def toolset(self) -> _builtins.str:
        """
        The resource name of the Toolset from which this tool is derived.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "toolset")

    @_builtins.property
    @pulumi.getter(name="toolId")
    def tool_id(self) -> Optional[_builtins.str]:
        """
        The tool ID to filter the tools to retrieve the schema for.
        """
        return pulumi.get(self, "tool_id")


@pulumi.output_type
class ExampleMessageChunkToolResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"
        elif key == "toolsetTool":
            suggest = "toolset_tool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExampleMessageChunkToolResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExampleMessageChunkToolResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExampleMessageChunkToolResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response: _builtins.str,
                 display_name: Optional[_builtins.str] = None,
                 id: Optional[_builtins.str] = None,
                 tool: Optional[_builtins.str] = None,
                 toolset_tool: Optional['outputs.ExampleMessageChunkToolResponseToolsetTool'] = None):
        """
        :param _builtins.str response: The tool execution result in JSON object format.
               Use "output" key to specify tool response and "error" key to specify
               error details (if any). If "output" and "error" keys are not specified,
               then whole "response" is treated as tool execution result.
        :param _builtins.str display_name: (Output)
               Display name of the tool.
        :param _builtins.str id: The matching ID of the tool call the response is for.
        :param _builtins.str tool: The name of the tool to execute.
               Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        :param 'ExampleMessageChunkToolResponseToolsetToolArgs' toolset_tool: A tool that is created from a toolset.
               Structure is documented below.
        """
        pulumi.set(__self__, "response", response)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if tool is not None:
            pulumi.set(__self__, "tool", tool)
        if toolset_tool is not None:
            pulumi.set(__self__, "toolset_tool", toolset_tool)

    @_builtins.property
    @pulumi.getter
    def response(self) -> _builtins.str:
        """
        The tool execution result in JSON object format.
        Use "output" key to specify tool response and "error" key to specify
        error details (if any). If "output" and "error" keys are not specified,
        then whole "response" is treated as tool execution result.
        """
        return pulumi.get(self, "response")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        Display name of the tool.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[_builtins.str]:
        """
        The matching ID of the tool call the response is for.
        """
        return pulumi.get(self, "id")

    @_builtins.property
    @pulumi.getter
    def tool(self) -> Optional[_builtins.str]:
        """
        The name of the tool to execute.
        Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        """
        return pulumi.get(self, "tool")

    @_builtins.property
    @pulumi.getter(name="toolsetTool")
    def toolset_tool(self) -> Optional['outputs.ExampleMessageChunkToolResponseToolsetTool']:
        """
        A tool that is created from a toolset.
        Structure is documented below.
        """
        return pulumi.get(self, "toolset_tool")


@pulumi.output_type
class ExampleMessageChunkToolResponseToolsetTool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "toolId":
            suggest = "tool_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExampleMessageChunkToolResponseToolsetTool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExampleMessageChunkToolResponseToolsetTool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExampleMessageChunkToolResponseToolsetTool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 toolset: _builtins.str,
                 tool_id: Optional[_builtins.str] = None):
        """
        :param _builtins.str toolset: The resource name of the Toolset from which this tool is derived.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param _builtins.str tool_id: The tool ID to filter the tools to retrieve the schema for.
        """
        pulumi.set(__self__, "toolset", toolset)
        if tool_id is not None:
            pulumi.set(__self__, "tool_id", tool_id)

    @_builtins.property
    @pulumi.getter
    def toolset(self) -> _builtins.str:
        """
        The resource name of the Toolset from which this tool is derived.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "toolset")

    @_builtins.property
    @pulumi.getter(name="toolId")
    def tool_id(self) -> Optional[_builtins.str]:
        """
        The tool ID to filter the tools to retrieve the schema for.
        """
        return pulumi.get(self, "tool_id")


@pulumi.output_type
class GuardrailAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "generativeAnswer":
            suggest = "generative_answer"
        elif key == "respondImmediately":
            suggest = "respond_immediately"
        elif key == "transferAgent":
            suggest = "transfer_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 generative_answer: Optional['outputs.GuardrailActionGenerativeAnswer'] = None,
                 respond_immediately: Optional['outputs.GuardrailActionRespondImmediately'] = None,
                 transfer_agent: Optional['outputs.GuardrailActionTransferAgent'] = None):
        """
        :param 'GuardrailActionGenerativeAnswerArgs' generative_answer: The agent will immediately respond with a generative answer.
               Structure is documented below.
        :param 'GuardrailActionRespondImmediatelyArgs' respond_immediately: The agent will immediately respond with a preconfigured response.
               Structure is documented below.
        :param 'GuardrailActionTransferAgentArgs' transfer_agent: The agent will transfer the conversation to a different agent.
               Structure is documented below.
        """
        if generative_answer is not None:
            pulumi.set(__self__, "generative_answer", generative_answer)
        if respond_immediately is not None:
            pulumi.set(__self__, "respond_immediately", respond_immediately)
        if transfer_agent is not None:
            pulumi.set(__self__, "transfer_agent", transfer_agent)

    @_builtins.property
    @pulumi.getter(name="generativeAnswer")
    def generative_answer(self) -> Optional['outputs.GuardrailActionGenerativeAnswer']:
        """
        The agent will immediately respond with a generative answer.
        Structure is documented below.
        """
        return pulumi.get(self, "generative_answer")

    @_builtins.property
    @pulumi.getter(name="respondImmediately")
    def respond_immediately(self) -> Optional['outputs.GuardrailActionRespondImmediately']:
        """
        The agent will immediately respond with a preconfigured response.
        Structure is documented below.
        """
        return pulumi.get(self, "respond_immediately")

    @_builtins.property
    @pulumi.getter(name="transferAgent")
    def transfer_agent(self) -> Optional['outputs.GuardrailActionTransferAgent']:
        """
        The agent will transfer the conversation to a different agent.
        Structure is documented below.
        """
        return pulumi.get(self, "transfer_agent")


@pulumi.output_type
class GuardrailActionGenerativeAnswer(dict):
    def __init__(__self__, *,
                 prompt: _builtins.str):
        """
        :param _builtins.str prompt: The prompt to use for the generative answer.
        """
        pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> _builtins.str:
        """
        The prompt to use for the generative answer.
        """
        return pulumi.get(self, "prompt")


@pulumi.output_type
class GuardrailActionRespondImmediately(dict):
    def __init__(__self__, *,
                 responses: Sequence['outputs.GuardrailActionRespondImmediatelyResponse']):
        """
        :param Sequence['GuardrailActionRespondImmediatelyResponseArgs'] responses: The canned responses for the agent to choose from. The response is chosen
               randomly.
               Structure is documented below.
        """
        pulumi.set(__self__, "responses", responses)

    @_builtins.property
    @pulumi.getter
    def responses(self) -> Sequence['outputs.GuardrailActionRespondImmediatelyResponse']:
        """
        The canned responses for the agent to choose from. The response is chosen
        randomly.
        Structure is documented below.
        """
        return pulumi.get(self, "responses")


@pulumi.output_type
class GuardrailActionRespondImmediatelyResponse(dict):
    def __init__(__self__, *,
                 text: _builtins.str,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str text: Text for the agent to respond with.
        :param _builtins.bool disabled: Whether the response is disabled. Disabled responses are not used by the
               agent.
        """
        pulumi.set(__self__, "text", text)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def text(self) -> _builtins.str:
        """
        Text for the agent to respond with.
        """
        return pulumi.get(self, "text")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether the response is disabled. Disabled responses are not used by the
        agent.
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class GuardrailActionTransferAgent(dict):
    def __init__(__self__, *,
                 agent: _builtins.str):
        """
        :param _builtins.str agent: The name of the agent to transfer the conversation to. The agent must be
               in the same app as the current agent.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        pulumi.set(__self__, "agent", agent)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> _builtins.str:
        """
        The name of the agent to transfer the conversation to. The agent must be
        in the same app as the current agent.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        return pulumi.get(self, "agent")


@pulumi.output_type
class GuardrailCodeCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "afterAgentCallback":
            suggest = "after_agent_callback"
        elif key == "afterModelCallback":
            suggest = "after_model_callback"
        elif key == "beforeAgentCallback":
            suggest = "before_agent_callback"
        elif key == "beforeModelCallback":
            suggest = "before_model_callback"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailCodeCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailCodeCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailCodeCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 after_agent_callback: Optional['outputs.GuardrailCodeCallbackAfterAgentCallback'] = None,
                 after_model_callback: Optional['outputs.GuardrailCodeCallbackAfterModelCallback'] = None,
                 before_agent_callback: Optional['outputs.GuardrailCodeCallbackBeforeAgentCallback'] = None,
                 before_model_callback: Optional['outputs.GuardrailCodeCallbackBeforeModelCallback'] = None):
        """
        :param 'GuardrailCodeCallbackAfterAgentCallbackArgs' after_agent_callback: A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        :param 'GuardrailCodeCallbackAfterModelCallbackArgs' after_model_callback: A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        :param 'GuardrailCodeCallbackBeforeAgentCallbackArgs' before_agent_callback: A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        :param 'GuardrailCodeCallbackBeforeModelCallbackArgs' before_model_callback: A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        """
        if after_agent_callback is not None:
            pulumi.set(__self__, "after_agent_callback", after_agent_callback)
        if after_model_callback is not None:
            pulumi.set(__self__, "after_model_callback", after_model_callback)
        if before_agent_callback is not None:
            pulumi.set(__self__, "before_agent_callback", before_agent_callback)
        if before_model_callback is not None:
            pulumi.set(__self__, "before_model_callback", before_model_callback)

    @_builtins.property
    @pulumi.getter(name="afterAgentCallback")
    def after_agent_callback(self) -> Optional['outputs.GuardrailCodeCallbackAfterAgentCallback']:
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "after_agent_callback")

    @_builtins.property
    @pulumi.getter(name="afterModelCallback")
    def after_model_callback(self) -> Optional['outputs.GuardrailCodeCallbackAfterModelCallback']:
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "after_model_callback")

    @_builtins.property
    @pulumi.getter(name="beforeAgentCallback")
    def before_agent_callback(self) -> Optional['outputs.GuardrailCodeCallbackBeforeAgentCallback']:
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "before_agent_callback")

    @_builtins.property
    @pulumi.getter(name="beforeModelCallback")
    def before_model_callback(self) -> Optional['outputs.GuardrailCodeCallbackBeforeModelCallback']:
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "before_model_callback")


@pulumi.output_type
class GuardrailCodeCallbackAfterAgentCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailCodeCallbackAfterAgentCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailCodeCallbackAfterAgentCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailCodeCallbackAfterAgentCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 python_code: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str python_code: The python code to execute for the callback.
        :param _builtins.str description: Human-readable description of the callback.
        :param _builtins.bool disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> _builtins.str:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class GuardrailCodeCallbackAfterModelCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailCodeCallbackAfterModelCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailCodeCallbackAfterModelCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailCodeCallbackAfterModelCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 python_code: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str python_code: The python code to execute for the callback.
        :param _builtins.str description: Human-readable description of the callback.
        :param _builtins.bool disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> _builtins.str:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class GuardrailCodeCallbackBeforeAgentCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailCodeCallbackBeforeAgentCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailCodeCallbackBeforeAgentCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailCodeCallbackBeforeAgentCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 python_code: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str python_code: The python code to execute for the callback.
        :param _builtins.str description: Human-readable description of the callback.
        :param _builtins.bool disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> _builtins.str:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class GuardrailCodeCallbackBeforeModelCallback(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailCodeCallbackBeforeModelCallback. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailCodeCallbackBeforeModelCallback.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailCodeCallbackBeforeModelCallback.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 python_code: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 disabled: Optional[_builtins.bool] = None):
        """
        :param _builtins.str python_code: The python code to execute for the callback.
        :param _builtins.str description: Human-readable description of the callback.
        :param _builtins.bool disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> _builtins.str:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")


@pulumi.output_type
class GuardrailContentFilter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "matchType":
            suggest = "match_type"
        elif key == "bannedContents":
            suggest = "banned_contents"
        elif key == "bannedContentsInAgentResponses":
            suggest = "banned_contents_in_agent_responses"
        elif key == "bannedContentsInUserInputs":
            suggest = "banned_contents_in_user_inputs"
        elif key == "disregardDiacritics":
            suggest = "disregard_diacritics"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailContentFilter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailContentFilter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailContentFilter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 match_type: _builtins.str,
                 banned_contents: Optional[Sequence[_builtins.str]] = None,
                 banned_contents_in_agent_responses: Optional[Sequence[_builtins.str]] = None,
                 banned_contents_in_user_inputs: Optional[Sequence[_builtins.str]] = None,
                 disregard_diacritics: Optional[_builtins.bool] = None):
        """
        :param _builtins.str match_type: Match type for the content filter.
               Possible values:
               SIMPLE_STRING_MATCH
               WORD_BOUNDARY_STRING_MATCH
               REGEXP_MATCH
        :param Sequence[_builtins.str] banned_contents: List of banned phrases. Applies to both user inputs and agent responses.
        :param Sequence[_builtins.str] banned_contents_in_agent_responses: List of banned phrases. Applies only to agent responses.
        :param Sequence[_builtins.str] banned_contents_in_user_inputs: List of banned phrases. Applies only to user inputs.
        :param _builtins.bool disregard_diacritics: If true, diacritics are ignored during matching.
        """
        pulumi.set(__self__, "match_type", match_type)
        if banned_contents is not None:
            pulumi.set(__self__, "banned_contents", banned_contents)
        if banned_contents_in_agent_responses is not None:
            pulumi.set(__self__, "banned_contents_in_agent_responses", banned_contents_in_agent_responses)
        if banned_contents_in_user_inputs is not None:
            pulumi.set(__self__, "banned_contents_in_user_inputs", banned_contents_in_user_inputs)
        if disregard_diacritics is not None:
            pulumi.set(__self__, "disregard_diacritics", disregard_diacritics)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> _builtins.str:
        """
        Match type for the content filter.
        Possible values:
        SIMPLE_STRING_MATCH
        WORD_BOUNDARY_STRING_MATCH
        REGEXP_MATCH
        """
        return pulumi.get(self, "match_type")

    @_builtins.property
    @pulumi.getter(name="bannedContents")
    def banned_contents(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of banned phrases. Applies to both user inputs and agent responses.
        """
        return pulumi.get(self, "banned_contents")

    @_builtins.property
    @pulumi.getter(name="bannedContentsInAgentResponses")
    def banned_contents_in_agent_responses(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of banned phrases. Applies only to agent responses.
        """
        return pulumi.get(self, "banned_contents_in_agent_responses")

    @_builtins.property
    @pulumi.getter(name="bannedContentsInUserInputs")
    def banned_contents_in_user_inputs(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of banned phrases. Applies only to user inputs.
        """
        return pulumi.get(self, "banned_contents_in_user_inputs")

    @_builtins.property
    @pulumi.getter(name="disregardDiacritics")
    def disregard_diacritics(self) -> Optional[_builtins.bool]:
        """
        If true, diacritics are ignored during matching.
        """
        return pulumi.get(self, "disregard_diacritics")


@pulumi.output_type
class GuardrailLlmPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyScope":
            suggest = "policy_scope"
        elif key == "allowShortUtterance":
            suggest = "allow_short_utterance"
        elif key == "failOpen":
            suggest = "fail_open"
        elif key == "maxConversationMessages":
            suggest = "max_conversation_messages"
        elif key == "modelSettings":
            suggest = "model_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailLlmPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailLlmPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailLlmPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_scope: _builtins.str,
                 prompt: _builtins.str,
                 allow_short_utterance: Optional[_builtins.bool] = None,
                 fail_open: Optional[_builtins.bool] = None,
                 max_conversation_messages: Optional[_builtins.int] = None,
                 model_settings: Optional['outputs.GuardrailLlmPolicyModelSettings'] = None):
        """
        :param _builtins.str policy_scope: Defines when to apply the policy check during the conversation. If set to
               `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
               When applying the policy to the agent response, additional latency will
               be introduced before the agent can respond.
               Possible values:
               USER_QUERY
               AGENT_RESPONSE
               USER_QUERY_AND_AGENT_RESPONSE
               Possible values are: `USER_QUERY`, `AGENT_RESPONSE`, `USER_QUERY_AND_AGENT_RESPONSE`.
        :param _builtins.str prompt: Policy prompt.
        :param _builtins.bool allow_short_utterance: By default, the LLM policy check is bypassed for short utterances.
               Enabling this setting applies the policy check to all utterances,
               including those that would normally be skipped.
        :param _builtins.bool fail_open: If an error occurs during the policy check, fail open and do not trigger
               the guardrail.
        :param _builtins.int max_conversation_messages: When checking this policy, consider the last 'n' messages in the
               conversation.
               When not set a default value of 10 will be used.
        :param 'GuardrailLlmPolicyModelSettingsArgs' model_settings: Model settings contains various configurations for the LLM model.
               Structure is documented below.
        """
        pulumi.set(__self__, "policy_scope", policy_scope)
        pulumi.set(__self__, "prompt", prompt)
        if allow_short_utterance is not None:
            pulumi.set(__self__, "allow_short_utterance", allow_short_utterance)
        if fail_open is not None:
            pulumi.set(__self__, "fail_open", fail_open)
        if max_conversation_messages is not None:
            pulumi.set(__self__, "max_conversation_messages", max_conversation_messages)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)

    @_builtins.property
    @pulumi.getter(name="policyScope")
    def policy_scope(self) -> _builtins.str:
        """
        Defines when to apply the policy check during the conversation. If set to
        `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
        When applying the policy to the agent response, additional latency will
        be introduced before the agent can respond.
        Possible values:
        USER_QUERY
        AGENT_RESPONSE
        USER_QUERY_AND_AGENT_RESPONSE
        Possible values are: `USER_QUERY`, `AGENT_RESPONSE`, `USER_QUERY_AND_AGENT_RESPONSE`.
        """
        return pulumi.get(self, "policy_scope")

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> _builtins.str:
        """
        Policy prompt.
        """
        return pulumi.get(self, "prompt")

    @_builtins.property
    @pulumi.getter(name="allowShortUtterance")
    def allow_short_utterance(self) -> Optional[_builtins.bool]:
        """
        By default, the LLM policy check is bypassed for short utterances.
        Enabling this setting applies the policy check to all utterances,
        including those that would normally be skipped.
        """
        return pulumi.get(self, "allow_short_utterance")

    @_builtins.property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[_builtins.bool]:
        """
        If an error occurs during the policy check, fail open and do not trigger
        the guardrail.
        """
        return pulumi.get(self, "fail_open")

    @_builtins.property
    @pulumi.getter(name="maxConversationMessages")
    def max_conversation_messages(self) -> Optional[_builtins.int]:
        """
        When checking this policy, consider the last 'n' messages in the
        conversation.
        When not set a default value of 10 will be used.
        """
        return pulumi.get(self, "max_conversation_messages")

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional['outputs.GuardrailLlmPolicyModelSettings']:
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")


@pulumi.output_type
class GuardrailLlmPolicyModelSettings(dict):
    def __init__(__self__, *,
                 model: Optional[_builtins.str] = None,
                 temperature: Optional[_builtins.float] = None):
        """
        :param _builtins.str model: The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param _builtins.float temperature: If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")


@pulumi.output_type
class GuardrailLlmPromptSecurity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "customPolicy":
            suggest = "custom_policy"
        elif key == "defaultSettings":
            suggest = "default_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailLlmPromptSecurity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailLlmPromptSecurity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailLlmPromptSecurity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 custom_policy: Optional['outputs.GuardrailLlmPromptSecurityCustomPolicy'] = None,
                 default_settings: Optional['outputs.GuardrailLlmPromptSecurityDefaultSettings'] = None):
        """
        :param 'GuardrailLlmPromptSecurityCustomPolicyArgs' custom_policy: Guardrail that blocks the conversation if the LLM response is considered
               violating the policy based on the LLM classification.
               Structure is documented below.
        :param 'GuardrailLlmPromptSecurityDefaultSettingsArgs' default_settings: Configuration for default system security settings.
               Structure is documented below.
        """
        if custom_policy is not None:
            pulumi.set(__self__, "custom_policy", custom_policy)
        if default_settings is not None:
            pulumi.set(__self__, "default_settings", default_settings)

    @_builtins.property
    @pulumi.getter(name="customPolicy")
    def custom_policy(self) -> Optional['outputs.GuardrailLlmPromptSecurityCustomPolicy']:
        """
        Guardrail that blocks the conversation if the LLM response is considered
        violating the policy based on the LLM classification.
        Structure is documented below.
        """
        return pulumi.get(self, "custom_policy")

    @_builtins.property
    @pulumi.getter(name="defaultSettings")
    def default_settings(self) -> Optional['outputs.GuardrailLlmPromptSecurityDefaultSettings']:
        """
        Configuration for default system security settings.
        Structure is documented below.
        """
        return pulumi.get(self, "default_settings")


@pulumi.output_type
class GuardrailLlmPromptSecurityCustomPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "policyScope":
            suggest = "policy_scope"
        elif key == "allowShortUtterance":
            suggest = "allow_short_utterance"
        elif key == "failOpen":
            suggest = "fail_open"
        elif key == "maxConversationMessages":
            suggest = "max_conversation_messages"
        elif key == "modelSettings":
            suggest = "model_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailLlmPromptSecurityCustomPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailLlmPromptSecurityCustomPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailLlmPromptSecurityCustomPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 policy_scope: _builtins.str,
                 prompt: _builtins.str,
                 allow_short_utterance: Optional[_builtins.bool] = None,
                 fail_open: Optional[_builtins.bool] = None,
                 max_conversation_messages: Optional[_builtins.int] = None,
                 model_settings: Optional['outputs.GuardrailLlmPromptSecurityCustomPolicyModelSettings'] = None):
        """
        :param _builtins.str policy_scope: Defines when to apply the policy check during the conversation. If set to
               `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
               When applying the policy to the agent response, additional latency will
               be introduced before the agent can respond.
               Possible values:
               USER_QUERY
               AGENT_RESPONSE
               USER_QUERY_AND_AGENT_RESPONSE
        :param _builtins.str prompt: Policy prompt.
        :param _builtins.bool allow_short_utterance: By default, the LLM policy check is bypassed for short utterances.
               Enabling this setting applies the policy check to all utterances,
               including those that would normally be skipped.
        :param _builtins.bool fail_open: If an error occurs during the policy check, fail open and do not trigger
               the guardrail.
        :param _builtins.int max_conversation_messages: When checking this policy, consider the last 'n' messages in the
               conversation.
               When not set a default value of 10 will be used.
        :param 'GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgs' model_settings: Model settings contains various configurations for the LLM model.
               Structure is documented below.
        """
        pulumi.set(__self__, "policy_scope", policy_scope)
        pulumi.set(__self__, "prompt", prompt)
        if allow_short_utterance is not None:
            pulumi.set(__self__, "allow_short_utterance", allow_short_utterance)
        if fail_open is not None:
            pulumi.set(__self__, "fail_open", fail_open)
        if max_conversation_messages is not None:
            pulumi.set(__self__, "max_conversation_messages", max_conversation_messages)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)

    @_builtins.property
    @pulumi.getter(name="policyScope")
    def policy_scope(self) -> _builtins.str:
        """
        Defines when to apply the policy check during the conversation. If set to
        `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
        When applying the policy to the agent response, additional latency will
        be introduced before the agent can respond.
        Possible values:
        USER_QUERY
        AGENT_RESPONSE
        USER_QUERY_AND_AGENT_RESPONSE
        """
        return pulumi.get(self, "policy_scope")

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> _builtins.str:
        """
        Policy prompt.
        """
        return pulumi.get(self, "prompt")

    @_builtins.property
    @pulumi.getter(name="allowShortUtterance")
    def allow_short_utterance(self) -> Optional[_builtins.bool]:
        """
        By default, the LLM policy check is bypassed for short utterances.
        Enabling this setting applies the policy check to all utterances,
        including those that would normally be skipped.
        """
        return pulumi.get(self, "allow_short_utterance")

    @_builtins.property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[_builtins.bool]:
        """
        If an error occurs during the policy check, fail open and do not trigger
        the guardrail.
        """
        return pulumi.get(self, "fail_open")

    @_builtins.property
    @pulumi.getter(name="maxConversationMessages")
    def max_conversation_messages(self) -> Optional[_builtins.int]:
        """
        When checking this policy, consider the last 'n' messages in the
        conversation.
        When not set a default value of 10 will be used.
        """
        return pulumi.get(self, "max_conversation_messages")

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional['outputs.GuardrailLlmPromptSecurityCustomPolicyModelSettings']:
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")


@pulumi.output_type
class GuardrailLlmPromptSecurityCustomPolicyModelSettings(dict):
    def __init__(__self__, *,
                 model: Optional[_builtins.str] = None,
                 temperature: Optional[_builtins.float] = None):
        """
        :param _builtins.str model: The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param _builtins.float temperature: If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")


@pulumi.output_type
class GuardrailLlmPromptSecurityDefaultSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultPromptTemplate":
            suggest = "default_prompt_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailLlmPromptSecurityDefaultSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailLlmPromptSecurityDefaultSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailLlmPromptSecurityDefaultSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_prompt_template: Optional[_builtins.str] = None):
        """
        :param _builtins.str default_prompt_template: (Output)
               The default prompt template used by the system.
               This field is for display purposes to show the user what prompt
               the system uses by default. It is OUTPUT_ONLY.
        """
        if default_prompt_template is not None:
            pulumi.set(__self__, "default_prompt_template", default_prompt_template)

    @_builtins.property
    @pulumi.getter(name="defaultPromptTemplate")
    def default_prompt_template(self) -> Optional[_builtins.str]:
        """
        (Output)
        The default prompt template used by the system.
        This field is for display purposes to show the user what prompt
        the system uses by default. It is OUTPUT_ONLY.
        """
        return pulumi.get(self, "default_prompt_template")


@pulumi.output_type
class GuardrailModelSafety(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "safetySettings":
            suggest = "safety_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in GuardrailModelSafety. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        GuardrailModelSafety.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        GuardrailModelSafety.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 safety_settings: Sequence['outputs.GuardrailModelSafetySafetySetting']):
        """
        :param Sequence['GuardrailModelSafetySafetySettingArgs'] safety_settings: List of safety settings.
               Structure is documented below.
        """
        pulumi.set(__self__, "safety_settings", safety_settings)

    @_builtins.property
    @pulumi.getter(name="safetySettings")
    def safety_settings(self) -> Sequence['outputs.GuardrailModelSafetySafetySetting']:
        """
        List of safety settings.
        Structure is documented below.
        """
        return pulumi.get(self, "safety_settings")


@pulumi.output_type
class GuardrailModelSafetySafetySetting(dict):
    def __init__(__self__, *,
                 category: _builtins.str,
                 threshold: _builtins.str):
        """
        :param _builtins.str category: The harm category.
               Possible values:
               HARM_CATEGORY_HATE_SPEECH
               HARM_CATEGORY_DANGEROUS_CONTENT
               HARM_CATEGORY_HARASSMENT
               HARM_CATEGORY_SEXUALLY_EXPLICIT
               Possible values are: `HARM_CATEGORY_HATE_SPEECH`, `HARM_CATEGORY_DANGEROUS_CONTENT`, `HARM_CATEGORY_HARASSMENT`, `HARM_CATEGORY_SEXUALLY_EXPLICIT`.
        :param _builtins.str threshold: The harm block threshold.
               Possible values:
               BLOCK_LOW_AND_ABOVE
               BLOCK_MEDIUM_AND_ABOVE
               BLOCK_ONLY_HIGH
               BLOCK_NONE
               OFF
               Possible values are: `BLOCK_LOW_AND_ABOVE`, `BLOCK_MEDIUM_AND_ABOVE`, `BLOCK_ONLY_HIGH`, `BLOCK_NONE`, `OFF`.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def category(self) -> _builtins.str:
        """
        The harm category.
        Possible values:
        HARM_CATEGORY_HATE_SPEECH
        HARM_CATEGORY_DANGEROUS_CONTENT
        HARM_CATEGORY_HARASSMENT
        HARM_CATEGORY_SEXUALLY_EXPLICIT
        Possible values are: `HARM_CATEGORY_HATE_SPEECH`, `HARM_CATEGORY_DANGEROUS_CONTENT`, `HARM_CATEGORY_HARASSMENT`, `HARM_CATEGORY_SEXUALLY_EXPLICIT`.
        """
        return pulumi.get(self, "category")

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> _builtins.str:
        """
        The harm block threshold.
        Possible values:
        BLOCK_LOW_AND_ABOVE
        BLOCK_MEDIUM_AND_ABOVE
        BLOCK_ONLY_HIGH
        BLOCK_NONE
        OFF
        Possible values are: `BLOCK_LOW_AND_ABOVE`, `BLOCK_MEDIUM_AND_ABOVE`, `BLOCK_ONLY_HIGH`, `BLOCK_NONE`, `OFF`.
        """
        return pulumi.get(self, "threshold")


@pulumi.output_type
class ToolClientFunction(dict):
    def __init__(__self__, *,
                 name: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 parameters: Optional['outputs.ToolClientFunctionParameters'] = None,
                 response: Optional['outputs.ToolClientFunctionResponse'] = None):
        """
        :param _builtins.str name: The function name.
        :param _builtins.str description: The function description.
        :param 'ToolClientFunctionParametersArgs' parameters: Represents a select subset of an OpenAPI 3.0 schema object.
               Structure is documented below.
        :param 'ToolClientFunctionResponseArgs' response: Represents a select subset of an OpenAPI 3.0 schema object.
               Structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The function name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The function description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional['outputs.ToolClientFunctionParameters']:
        """
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        return pulumi.get(self, "parameters")

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional['outputs.ToolClientFunctionResponse']:
        """
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        return pulumi.get(self, "response")


@pulumi.output_type
class ToolClientFunctionParameters(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalProperties":
            suggest = "additional_properties"
        elif key == "anyOf":
            suggest = "any_of"
        elif key == "maxItems":
            suggest = "max_items"
        elif key == "minItems":
            suggest = "min_items"
        elif key == "prefixItems":
            suggest = "prefix_items"
        elif key == "uniqueItems":
            suggest = "unique_items"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolClientFunctionParameters. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolClientFunctionParameters.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolClientFunctionParameters.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 additional_properties: Optional[_builtins.str] = None,
                 any_of: Optional[_builtins.str] = None,
                 default: Optional[_builtins.str] = None,
                 defs: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 enums: Optional[Sequence[_builtins.str]] = None,
                 items: Optional[_builtins.str] = None,
                 max_items: Optional[_builtins.int] = None,
                 maximum: Optional[_builtins.float] = None,
                 min_items: Optional[_builtins.int] = None,
                 minimum: Optional[_builtins.float] = None,
                 nullable: Optional[_builtins.bool] = None,
                 prefix_items: Optional[_builtins.str] = None,
                 properties: Optional[_builtins.str] = None,
                 ref: Optional[_builtins.str] = None,
                 requireds: Optional[Sequence[_builtins.str]] = None,
                 title: Optional[_builtins.str] = None,
                 unique_items: Optional[_builtins.bool] = None):
        """
        :param _builtins.str type: The type of the data.
               Possible values:
               STRING
               INTEGER
               NUMBER
               BOOLEAN
               OBJECT
               ARRAY
        :param _builtins.str additional_properties: Defines the schema for additional properties allowed in an object.
               The value must be a valid JSON string representing the Schema object.
               (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        :param _builtins.str any_of: The instance value should be valid against at least one of the schemas in this list.
        :param _builtins.str default: Default value of the data. Represents a dynamically typed value
               which can be either null, a number, a string, a boolean, a struct,
               or a list of values. The provided default value must be compatible
               with the defined 'type' and other schema constraints.
        :param _builtins.str defs: A map of definitions for use by ref. Only allowed at the root of the schema.
        :param _builtins.str description: The description of the data.
        :param Sequence[_builtins.str] enums: Possible values of the element of primitive type with enum format.
               Examples:
               1. We can define direction as :
               {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
               2. We can define apartment number as :
               {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        :param _builtins.str items: Schema of the elements of Type.ARRAY.
        :param _builtins.int max_items: Maximum number of the elements for Type.ARRAY. (int64 format)
        :param _builtins.float maximum: Maximum value for Type.INTEGER and Type.NUMBER.
        :param _builtins.int min_items: Minimum number of the elements for Type.ARRAY. (int64 format)
        :param _builtins.float minimum: Minimum value for Type.INTEGER and Type.NUMBER.
        :param _builtins.bool nullable: Indicates if the value may be null.
        :param _builtins.str prefix_items: Schemas of initial elements of Type.ARRAY.
        :param _builtins.str properties: Properties of Type.OBJECT.
        :param _builtins.str ref: Allows indirect references between schema nodes. The value should be a
               valid reference to a child of the root `defs`.
               For example, the following schema defines a reference to a schema node
               named "Pet":
               type: object
               properties:
               pet:
               ref: #/defs/Pet
               defs:
               Pet:
               type: object
               properties:
               name:
               type: string
               The value of the "pet" property is a reference to the schema node
               named "Pet".
               See details in
               https://json-schema.org/understanding-json-schema/structuring.
        :param Sequence[_builtins.str] requireds: Required properties of Type.OBJECT.
        :param _builtins.str title: The title of the schema.
        :param _builtins.bool unique_items: Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        pulumi.set(__self__, "type", type)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if any_of is not None:
            pulumi.set(__self__, "any_of", any_of)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if defs is not None:
            pulumi.set(__self__, "defs", defs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enums is not None:
            pulumi.set(__self__, "enums", enums)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if max_items is not None:
            pulumi.set(__self__, "max_items", max_items)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_items is not None:
            pulumi.set(__self__, "min_items", min_items)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if prefix_items is not None:
            pulumi.set(__self__, "prefix_items", prefix_items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if requireds is not None:
            pulumi.set(__self__, "requireds", requireds)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the data.
        Possible values:
        STRING
        INTEGER
        NUMBER
        BOOLEAN
        OBJECT
        ARRAY
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[_builtins.str]:
        """
        Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        return pulumi.get(self, "additional_properties")

    @_builtins.property
    @pulumi.getter(name="anyOf")
    def any_of(self) -> Optional[_builtins.str]:
        """
        The instance value should be valid against at least one of the schemas in this list.
        """
        return pulumi.get(self, "any_of")

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        """
        Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def defs(self) -> Optional[_builtins.str]:
        """
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        return pulumi.get(self, "defs")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the data.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def enums(self) -> Optional[Sequence[_builtins.str]]:
        """
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        return pulumi.get(self, "enums")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[_builtins.str]:
        """
        Schema of the elements of Type.ARRAY.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter(name="maxItems")
    def max_items(self) -> Optional[_builtins.int]:
        """
        Maximum number of the elements for Type.ARRAY. (int64 format)
        """
        return pulumi.get(self, "max_items")

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[_builtins.float]:
        """
        Maximum value for Type.INTEGER and Type.NUMBER.
        """
        return pulumi.get(self, "maximum")

    @_builtins.property
    @pulumi.getter(name="minItems")
    def min_items(self) -> Optional[_builtins.int]:
        """
        Minimum number of the elements for Type.ARRAY. (int64 format)
        """
        return pulumi.get(self, "min_items")

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[_builtins.float]:
        """
        Minimum value for Type.INTEGER and Type.NUMBER.
        """
        return pulumi.get(self, "minimum")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        Indicates if the value may be null.
        """
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="prefixItems")
    def prefix_items(self) -> Optional[_builtins.str]:
        """
        Schemas of initial elements of Type.ARRAY.
        """
        return pulumi.get(self, "prefix_items")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[_builtins.str]:
        """
        Properties of Type.OBJECT.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[_builtins.str]:
        """
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        return pulumi.get(self, "ref")

    @_builtins.property
    @pulumi.getter
    def requireds(self) -> Optional[Sequence[_builtins.str]]:
        """
        Required properties of Type.OBJECT.
        """
        return pulumi.get(self, "requireds")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        The title of the schema.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[_builtins.bool]:
        """
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        return pulumi.get(self, "unique_items")


@pulumi.output_type
class ToolClientFunctionResponse(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalProperties":
            suggest = "additional_properties"
        elif key == "anyOf":
            suggest = "any_of"
        elif key == "maxItems":
            suggest = "max_items"
        elif key == "minItems":
            suggest = "min_items"
        elif key == "prefixItems":
            suggest = "prefix_items"
        elif key == "uniqueItems":
            suggest = "unique_items"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolClientFunctionResponse. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolClientFunctionResponse.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolClientFunctionResponse.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 type: _builtins.str,
                 additional_properties: Optional[_builtins.str] = None,
                 any_of: Optional[_builtins.str] = None,
                 default: Optional[_builtins.str] = None,
                 defs: Optional[_builtins.str] = None,
                 description: Optional[_builtins.str] = None,
                 enums: Optional[Sequence[_builtins.str]] = None,
                 items: Optional[_builtins.str] = None,
                 max_items: Optional[_builtins.int] = None,
                 maximum: Optional[_builtins.float] = None,
                 min_items: Optional[_builtins.int] = None,
                 minimum: Optional[_builtins.float] = None,
                 nullable: Optional[_builtins.bool] = None,
                 prefix_items: Optional[_builtins.str] = None,
                 properties: Optional[_builtins.str] = None,
                 ref: Optional[_builtins.str] = None,
                 requireds: Optional[Sequence[_builtins.str]] = None,
                 title: Optional[_builtins.str] = None,
                 unique_items: Optional[_builtins.bool] = None):
        """
        :param _builtins.str type: The type of the data.
               Possible values:
               STRING
               INTEGER
               NUMBER
               BOOLEAN
               OBJECT
               ARRAY
        :param _builtins.str additional_properties: Defines the schema for additional properties allowed in an object.
               The value must be a valid JSON string representing the Schema object.
               (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        :param _builtins.str any_of: The instance value should be valid against at least one of the schemas in this list.
        :param _builtins.str default: Default value of the data. Represents a dynamically typed value
               which can be either null, a number, a string, a boolean, a struct,
               or a list of values. The provided default value must be compatible
               with the defined 'type' and other schema constraints.
        :param _builtins.str defs: A map of definitions for use by ref. Only allowed at the root of the schema.
        :param _builtins.str description: The description of the data.
        :param Sequence[_builtins.str] enums: Possible values of the element of primitive type with enum format.
               Examples:
               1. We can define direction as :
               {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
               2. We can define apartment number as :
               {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        :param _builtins.str items: Schema of the elements of Type.ARRAY.
        :param _builtins.int max_items: Maximum number of the elements for Type.ARRAY. (int64 format)
        :param _builtins.float maximum: Maximum value for Type.INTEGER and Type.NUMBER.
        :param _builtins.int min_items: Minimum number of the elements for Type.ARRAY. (int64 format)
        :param _builtins.float minimum: Minimum value for Type.INTEGER and Type.NUMBER.
        :param _builtins.bool nullable: Indicates if the value may be null.
        :param _builtins.str prefix_items: Schemas of initial elements of Type.ARRAY.
        :param _builtins.str properties: Properties of Type.OBJECT.
        :param _builtins.str ref: Allows indirect references between schema nodes. The value should be a
               valid reference to a child of the root `defs`.
               For example, the following schema defines a reference to a schema node
               named "Pet":
               type: object
               properties:
               pet:
               ref: #/defs/Pet
               defs:
               Pet:
               type: object
               properties:
               name:
               type: string
               The value of the "pet" property is a reference to the schema node
               named "Pet".
               See details in
               https://json-schema.org/understanding-json-schema/structuring.
        :param Sequence[_builtins.str] requireds: Required properties of Type.OBJECT.
        :param _builtins.str title: The title of the schema.
        :param _builtins.bool unique_items: Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        pulumi.set(__self__, "type", type)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if any_of is not None:
            pulumi.set(__self__, "any_of", any_of)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if defs is not None:
            pulumi.set(__self__, "defs", defs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enums is not None:
            pulumi.set(__self__, "enums", enums)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if max_items is not None:
            pulumi.set(__self__, "max_items", max_items)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_items is not None:
            pulumi.set(__self__, "min_items", min_items)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if prefix_items is not None:
            pulumi.set(__self__, "prefix_items", prefix_items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if requireds is not None:
            pulumi.set(__self__, "requireds", requireds)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of the data.
        Possible values:
        STRING
        INTEGER
        NUMBER
        BOOLEAN
        OBJECT
        ARRAY
        """
        return pulumi.get(self, "type")

    @_builtins.property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[_builtins.str]:
        """
        Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        return pulumi.get(self, "additional_properties")

    @_builtins.property
    @pulumi.getter(name="anyOf")
    def any_of(self) -> Optional[_builtins.str]:
        """
        The instance value should be valid against at least one of the schemas in this list.
        """
        return pulumi.get(self, "any_of")

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[_builtins.str]:
        """
        Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        return pulumi.get(self, "default")

    @_builtins.property
    @pulumi.getter
    def defs(self) -> Optional[_builtins.str]:
        """
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        return pulumi.get(self, "defs")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the data.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def enums(self) -> Optional[Sequence[_builtins.str]]:
        """
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        return pulumi.get(self, "enums")

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[_builtins.str]:
        """
        Schema of the elements of Type.ARRAY.
        """
        return pulumi.get(self, "items")

    @_builtins.property
    @pulumi.getter(name="maxItems")
    def max_items(self) -> Optional[_builtins.int]:
        """
        Maximum number of the elements for Type.ARRAY. (int64 format)
        """
        return pulumi.get(self, "max_items")

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[_builtins.float]:
        """
        Maximum value for Type.INTEGER and Type.NUMBER.
        """
        return pulumi.get(self, "maximum")

    @_builtins.property
    @pulumi.getter(name="minItems")
    def min_items(self) -> Optional[_builtins.int]:
        """
        Minimum number of the elements for Type.ARRAY. (int64 format)
        """
        return pulumi.get(self, "min_items")

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[_builtins.float]:
        """
        Minimum value for Type.INTEGER and Type.NUMBER.
        """
        return pulumi.get(self, "minimum")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        Indicates if the value may be null.
        """
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="prefixItems")
    def prefix_items(self) -> Optional[_builtins.str]:
        """
        Schemas of initial elements of Type.ARRAY.
        """
        return pulumi.get(self, "prefix_items")

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[_builtins.str]:
        """
        Properties of Type.OBJECT.
        """
        return pulumi.get(self, "properties")

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[_builtins.str]:
        """
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        return pulumi.get(self, "ref")

    @_builtins.property
    @pulumi.getter
    def requireds(self) -> Optional[Sequence[_builtins.str]]:
        """
        Required properties of Type.OBJECT.
        """
        return pulumi.get(self, "requireds")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        The title of the schema.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[_builtins.bool]:
        """
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        return pulumi.get(self, "unique_items")


@pulumi.output_type
class ToolDataStoreTool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boostSpecs":
            suggest = "boost_specs"
        elif key == "engineSource":
            suggest = "engine_source"
        elif key == "maxResults":
            suggest = "max_results"
        elif key == "modalityConfigs":
            suggest = "modality_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolDataStoreTool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolDataStoreTool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolDataStoreTool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 boost_specs: Optional[Sequence['outputs.ToolDataStoreToolBoostSpec']] = None,
                 description: Optional[_builtins.str] = None,
                 engine_source: Optional['outputs.ToolDataStoreToolEngineSource'] = None,
                 max_results: Optional[_builtins.int] = None,
                 modality_configs: Optional[Sequence['outputs.ToolDataStoreToolModalityConfig']] = None):
        """
        :param _builtins.str name: The data store tool name.
        :param Sequence['ToolDataStoreToolBoostSpecArgs'] boost_specs: Boost specification to boost certain documents.
               Structure is documented below.
        :param _builtins.str description: The tool description.
        :param 'ToolDataStoreToolEngineSourceArgs' engine_source: Configuration for searching within an Engine, potentially targeting
               specific DataStores.
               Structure is documented below.
        :param _builtins.int max_results: Number of search results to return per query.
               The default value is 10. The maximum allowed value is 10.
        :param Sequence['ToolDataStoreToolModalityConfigArgs'] modality_configs: The modality configs for the data store.
               Structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        if boost_specs is not None:
            pulumi.set(__self__, "boost_specs", boost_specs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if engine_source is not None:
            pulumi.set(__self__, "engine_source", engine_source)
        if max_results is not None:
            pulumi.set(__self__, "max_results", max_results)
        if modality_configs is not None:
            pulumi.set(__self__, "modality_configs", modality_configs)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The data store tool name.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="boostSpecs")
    def boost_specs(self) -> Optional[Sequence['outputs.ToolDataStoreToolBoostSpec']]:
        """
        Boost specification to boost certain documents.
        Structure is documented below.
        """
        return pulumi.get(self, "boost_specs")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The tool description.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="engineSource")
    def engine_source(self) -> Optional['outputs.ToolDataStoreToolEngineSource']:
        """
        Configuration for searching within an Engine, potentially targeting
        specific DataStores.
        Structure is documented below.
        """
        return pulumi.get(self, "engine_source")

    @_builtins.property
    @pulumi.getter(name="maxResults")
    def max_results(self) -> Optional[_builtins.int]:
        """
        Number of search results to return per query.
        The default value is 10. The maximum allowed value is 10.
        """
        return pulumi.get(self, "max_results")

    @_builtins.property
    @pulumi.getter(name="modalityConfigs")
    def modality_configs(self) -> Optional[Sequence['outputs.ToolDataStoreToolModalityConfig']]:
        """
        The modality configs for the data store.
        Structure is documented below.
        """
        return pulumi.get(self, "modality_configs")


@pulumi.output_type
class ToolDataStoreToolBoostSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStores":
            suggest = "data_stores"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolDataStoreToolBoostSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolDataStoreToolBoostSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolDataStoreToolBoostSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_stores: Sequence[_builtins.str],
                 specs: Sequence['outputs.ToolDataStoreToolBoostSpecSpec']):
        """
        :param Sequence[_builtins.str] data_stores: The Data Store where the boosting configuration is applied. Full resource
               name of DataStore, such as
               projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}.
        :param Sequence['ToolDataStoreToolBoostSpecSpecArgs'] specs: A list of boosting specifications.
               Structure is documented below.
        """
        pulumi.set(__self__, "data_stores", data_stores)
        pulumi.set(__self__, "specs", specs)

    @_builtins.property
    @pulumi.getter(name="dataStores")
    def data_stores(self) -> Sequence[_builtins.str]:
        """
        The Data Store where the boosting configuration is applied. Full resource
        name of DataStore, such as
        projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}.
        """
        return pulumi.get(self, "data_stores")

    @_builtins.property
    @pulumi.getter
    def specs(self) -> Sequence['outputs.ToolDataStoreToolBoostSpecSpec']:
        """
        A list of boosting specifications.
        Structure is documented below.
        """
        return pulumi.get(self, "specs")


@pulumi.output_type
class ToolDataStoreToolBoostSpecSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "conditionBoostSpecs":
            suggest = "condition_boost_specs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolDataStoreToolBoostSpecSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolDataStoreToolBoostSpecSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolDataStoreToolBoostSpecSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition_boost_specs: Sequence['outputs.ToolDataStoreToolBoostSpecSpecConditionBoostSpec']):
        """
        :param Sequence['ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs'] condition_boost_specs: A list of boosting specifications.
               Structure is documented below.
        """
        pulumi.set(__self__, "condition_boost_specs", condition_boost_specs)

    @_builtins.property
    @pulumi.getter(name="conditionBoostSpecs")
    def condition_boost_specs(self) -> Sequence['outputs.ToolDataStoreToolBoostSpecSpecConditionBoostSpec']:
        """
        A list of boosting specifications.
        Structure is documented below.
        """
        return pulumi.get(self, "condition_boost_specs")


@pulumi.output_type
class ToolDataStoreToolBoostSpecSpecConditionBoostSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "boostControlSpec":
            suggest = "boost_control_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolDataStoreToolBoostSpecSpecConditionBoostSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolDataStoreToolBoostSpecSpecConditionBoostSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolDataStoreToolBoostSpecSpecConditionBoostSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 condition: _builtins.str,
                 boost: Optional[_builtins.float] = None,
                 boost_control_spec: Optional['outputs.ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpec'] = None):
        """
        :param _builtins.str condition: An expression which specifies a boost condition. The syntax is the same
               as filter expression syntax. Currently, the only supported condition is
               a list of BCP-47 lang codes.
               Example: To boost suggestions in languages en or fr:
               (lang_code: ANY("en", "fr"))
        :param _builtins.float boost: Strength of the boost, which should be in [-1, 1]. Negative boost means
               demotion. Default is 0.0.
               Setting to 1.0 gives the suggestions a big promotion. However, it does
               not necessarily mean that the top result will be a boosted suggestion.
               Setting to -1.0 gives the suggestions a big demotion. However, other
               suggestions that are relevant might still be shown.
               Setting to 0.0 means no boost applied. The boosting condition is
               ignored.
        :param 'ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs' boost_control_spec: Specification for custom ranking based on customer specified attribute
               value. It provides more controls for customized ranking than the simple
               (condition, boost) combination above.
               Structure is documented below.
        """
        pulumi.set(__self__, "condition", condition)
        if boost is not None:
            pulumi.set(__self__, "boost", boost)
        if boost_control_spec is not None:
            pulumi.set(__self__, "boost_control_spec", boost_control_spec)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> _builtins.str:
        """
        An expression which specifies a boost condition. The syntax is the same
        as filter expression syntax. Currently, the only supported condition is
        a list of BCP-47 lang codes.
        Example: To boost suggestions in languages en or fr:
        (lang_code: ANY("en", "fr"))
        """
        return pulumi.get(self, "condition")

    @_builtins.property
    @pulumi.getter
    def boost(self) -> Optional[_builtins.float]:
        """
        Strength of the boost, which should be in [-1, 1]. Negative boost means
        demotion. Default is 0.0.
        Setting to 1.0 gives the suggestions a big promotion. However, it does
        not necessarily mean that the top result will be a boosted suggestion.
        Setting to -1.0 gives the suggestions a big demotion. However, other
        suggestions that are relevant might still be shown.
        Setting to 0.0 means no boost applied. The boosting condition is
        ignored.
        """
        return pulumi.get(self, "boost")

    @_builtins.property
    @pulumi.getter(name="boostControlSpec")
    def boost_control_spec(self) -> Optional['outputs.ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpec']:
        """
        Specification for custom ranking based on customer specified attribute
        value. It provides more controls for customized ranking than the simple
        (condition, boost) combination above.
        Structure is documented below.
        """
        return pulumi.get(self, "boost_control_spec")


@pulumi.output_type
class ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeType":
            suggest = "attribute_type"
        elif key == "controlPoints":
            suggest = "control_points"
        elif key == "fieldName":
            suggest = "field_name"
        elif key == "interpolationType":
            suggest = "interpolation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_type: Optional[_builtins.str] = None,
                 control_points: Optional[Sequence['outputs.ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPoint']] = None,
                 field_name: Optional[_builtins.str] = None,
                 interpolation_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str attribute_type: The attribute type to be used to determine the boost amount. The
               attribute value can be derived from the field value of the specified
               field_name. In the case of numerical it is straightforward i.e.
               attribute_value = numerical_field_value. In the case of freshness
               however, attribute_value = (time.now() - datetime_field_value).
               Possible values:
               NUMERICAL
               FRESHNESS
        :param Sequence['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs'] control_points: The control points used to define the curve. The monotonic function
               (defined through the interpolation_type above) passes through the
               control points listed here.
               Structure is documented below.
        :param _builtins.str field_name: The name of the field whose value will be used to determine the
               boost amount.
        :param _builtins.str interpolation_type: The interpolation type to be applied to connect the control points
               listed below.
               Possible values:
               LINEAR
        """
        if attribute_type is not None:
            pulumi.set(__self__, "attribute_type", attribute_type)
        if control_points is not None:
            pulumi.set(__self__, "control_points", control_points)
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)
        if interpolation_type is not None:
            pulumi.set(__self__, "interpolation_type", interpolation_type)

    @_builtins.property
    @pulumi.getter(name="attributeType")
    def attribute_type(self) -> Optional[_builtins.str]:
        """
        The attribute type to be used to determine the boost amount. The
        attribute value can be derived from the field value of the specified
        field_name. In the case of numerical it is straightforward i.e.
        attribute_value = numerical_field_value. In the case of freshness
        however, attribute_value = (time.now() - datetime_field_value).
        Possible values:
        NUMERICAL
        FRESHNESS
        """
        return pulumi.get(self, "attribute_type")

    @_builtins.property
    @pulumi.getter(name="controlPoints")
    def control_points(self) -> Optional[Sequence['outputs.ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPoint']]:
        """
        The control points used to define the curve. The monotonic function
        (defined through the interpolation_type above) passes through the
        control points listed here.
        Structure is documented below.
        """
        return pulumi.get(self, "control_points")

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[_builtins.str]:
        """
        The name of the field whose value will be used to determine the
        boost amount.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter(name="interpolationType")
    def interpolation_type(self) -> Optional[_builtins.str]:
        """
        The interpolation type to be applied to connect the control points
        listed below.
        Possible values:
        LINEAR
        """
        return pulumi.get(self, "interpolation_type")


@pulumi.output_type
class ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeValue":
            suggest = "attribute_value"
        elif key == "boostAmount":
            suggest = "boost_amount"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_value: Optional[_builtins.str] = None,
                 boost_amount: Optional[_builtins.float] = None):
        """
        :param _builtins.str attribute_value: Can be one of:
               1. The numerical field value.
               2. The duration spec for freshness:
               The value must be formatted as an XSD `dayTimeDuration` value (a
               restricted subset of an ISO 8601 duration value). The pattern for
               this is: `nDnM]`.
        :param _builtins.float boost_amount: The value between -1 to 1 by which to boost the score if the
               attribute_value evaluates to the value specified above.
        """
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if boost_amount is not None:
            pulumi.set(__self__, "boost_amount", boost_amount)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[_builtins.str]:
        """
        Can be one of:
        1. The numerical field value.
        2. The duration spec for freshness:
        The value must be formatted as an XSD `dayTimeDuration` value (a
        restricted subset of an ISO 8601 duration value). The pattern for
        this is: `nDnM]`.
        """
        return pulumi.get(self, "attribute_value")

    @_builtins.property
    @pulumi.getter(name="boostAmount")
    def boost_amount(self) -> Optional[_builtins.float]:
        """
        The value between -1 to 1 by which to boost the score if the
        attribute_value evaluates to the value specified above.
        """
        return pulumi.get(self, "boost_amount")


@pulumi.output_type
class ToolDataStoreToolEngineSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStoreSources":
            suggest = "data_store_sources"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolDataStoreToolEngineSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolDataStoreToolEngineSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolDataStoreToolEngineSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 engine: _builtins.str,
                 data_store_sources: Optional[Sequence['outputs.ToolDataStoreToolEngineSourceDataStoreSource']] = None,
                 filter: Optional[_builtins.str] = None):
        """
        :param _builtins.str engine: Full resource name of the Engine.
               Format:
               `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
        :param Sequence['ToolDataStoreToolEngineSourceDataStoreSourceArgs'] data_store_sources: Use to target specific DataStores within the Engine.
               If empty, the search applies to all DataStores associated with the
               Engine.
               Structure is documented below.
        :param _builtins.str filter: A filter applied to the search across the Engine. Not relevant and not
               used if 'data_store_sources' is provided.
               See:
               https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        pulumi.set(__self__, "engine", engine)
        if data_store_sources is not None:
            pulumi.set(__self__, "data_store_sources", data_store_sources)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)

    @_builtins.property
    @pulumi.getter
    def engine(self) -> _builtins.str:
        """
        Full resource name of the Engine.
        Format:
        `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
        """
        return pulumi.get(self, "engine")

    @_builtins.property
    @pulumi.getter(name="dataStoreSources")
    def data_store_sources(self) -> Optional[Sequence['outputs.ToolDataStoreToolEngineSourceDataStoreSource']]:
        """
        Use to target specific DataStores within the Engine.
        If empty, the search applies to all DataStores associated with the
        Engine.
        Structure is documented below.
        """
        return pulumi.get(self, "data_store_sources")

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[_builtins.str]:
        """
        A filter applied to the search across the Engine. Not relevant and not
        used if 'data_store_sources' is provided.
        See:
        https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        return pulumi.get(self, "filter")


@pulumi.output_type
class ToolDataStoreToolEngineSourceDataStoreSource(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStore":
            suggest = "data_store"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolDataStoreToolEngineSourceDataStoreSource. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolDataStoreToolEngineSourceDataStoreSource.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolDataStoreToolEngineSourceDataStoreSource.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_store: Optional['outputs.ToolDataStoreToolEngineSourceDataStoreSourceDataStore'] = None,
                 filter: Optional[_builtins.str] = None):
        """
        :param 'ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs' data_store: A DataStore resource in Vertex AI Search.
               Structure is documented below.
        :param _builtins.str filter: Filter specification for the DataStore.
               See:
               https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        if data_store is not None:
            pulumi.set(__self__, "data_store", data_store)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)

    @_builtins.property
    @pulumi.getter(name="dataStore")
    def data_store(self) -> Optional['outputs.ToolDataStoreToolEngineSourceDataStoreSourceDataStore']:
        """
        A DataStore resource in Vertex AI Search.
        Structure is documented below.
        """
        return pulumi.get(self, "data_store")

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[_builtins.str]:
        """
        Filter specification for the DataStore.
        See:
        https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        return pulumi.get(self, "filter")


@pulumi.output_type
class ToolDataStoreToolEngineSourceDataStoreSourceDataStore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectorConfigs":
            suggest = "connector_configs"
        elif key == "createTime":
            suggest = "create_time"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "documentProcessingMode":
            suggest = "document_processing_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolDataStoreToolEngineSourceDataStoreSourceDataStore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolDataStoreToolEngineSourceDataStoreSourceDataStore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolDataStoreToolEngineSourceDataStoreSourceDataStore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 connector_configs: Optional[Sequence['outputs.ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfig']] = None,
                 create_time: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None,
                 document_processing_mode: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Full resource name of the DataStore.
               Format:
               `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
        :param Sequence['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs'] connector_configs: (Output)
               The connector config for the data store connection.
               Structure is documented below.
        :param _builtins.str create_time: (Output)
               Timestamp when the data store was created.
        :param _builtins.str display_name: (Output)
               The display name of the data store.
        :param _builtins.str document_processing_mode: (Output)
               The document processing mode for the data store connection.
               Only set for PUBLIC_WEB and UNSTRUCTURED data stores.
               Possible values:
               DOCUMENTS
               CHUNKS
        :param _builtins.str type: (Output)
               The type of the data store. This field is readonly and populated by the
               server.
               Possible values:
               PUBLIC_WEB
               UNSTRUCTURED
               FAQ
               CONNECTOR
               
               
               <a name="nested_data_store_tool_engine_source_data_store_sources_data_store_sources_data_store_connector_config"></a>The `connector_config` block contains:
        """
        pulumi.set(__self__, "name", name)
        if connector_configs is not None:
            pulumi.set(__self__, "connector_configs", connector_configs)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if document_processing_mode is not None:
            pulumi.set(__self__, "document_processing_mode", document_processing_mode)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        Full resource name of the DataStore.
        Format:
        `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="connectorConfigs")
    def connector_configs(self) -> Optional[Sequence['outputs.ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfig']]:
        """
        (Output)
        The connector config for the data store connection.
        Structure is documented below.
        """
        return pulumi.get(self, "connector_configs")

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[_builtins.str]:
        """
        (Output)
        Timestamp when the data store was created.
        """
        return pulumi.get(self, "create_time")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        The display name of the data store.
        """
        return pulumi.get(self, "display_name")

    @_builtins.property
    @pulumi.getter(name="documentProcessingMode")
    def document_processing_mode(self) -> Optional[_builtins.str]:
        """
        (Output)
        The document processing mode for the data store connection.
        Only set for PUBLIC_WEB and UNSTRUCTURED data stores.
        Possible values:
        DOCUMENTS
        CHUNKS
        """
        return pulumi.get(self, "document_processing_mode")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR


        <a name="nested_data_store_tool_engine_source_data_store_sources_data_store_sources_data_store_connector_config"></a>The `connector_config` block contains:
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "collectionDisplayName":
            suggest = "collection_display_name"
        elif key == "dataSource":
            suggest = "data_source"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collection: Optional[_builtins.str] = None,
                 collection_display_name: Optional[_builtins.str] = None,
                 data_source: Optional[_builtins.str] = None):
        """
        :param _builtins.str collection: Resource name of the collection the data store belongs to.
        :param _builtins.str collection_display_name: Display name of the collection the data store belongs to.
        :param _builtins.str data_source: The name of the data source.
               Example: 'salesforce', 'jira', 'confluence', 'bigquery'.
        """
        if collection is not None:
            pulumi.set(__self__, "collection", collection)
        if collection_display_name is not None:
            pulumi.set(__self__, "collection_display_name", collection_display_name)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @_builtins.property
    @pulumi.getter
    def collection(self) -> Optional[_builtins.str]:
        """
        Resource name of the collection the data store belongs to.
        """
        return pulumi.get(self, "collection")

    @_builtins.property
    @pulumi.getter(name="collectionDisplayName")
    def collection_display_name(self) -> Optional[_builtins.str]:
        """
        Display name of the collection the data store belongs to.
        """
        return pulumi.get(self, "collection_display_name")

    @_builtins.property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[_builtins.str]:
        """
        The name of the data source.
        Example: 'salesforce', 'jira', 'confluence', 'bigquery'.
        """
        return pulumi.get(self, "data_source")


@pulumi.output_type
class ToolDataStoreToolModalityConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modalityType":
            suggest = "modality_type"
        elif key == "groundingConfig":
            suggest = "grounding_config"
        elif key == "rewriterConfig":
            suggest = "rewriter_config"
        elif key == "summarizationConfig":
            suggest = "summarization_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolDataStoreToolModalityConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolDataStoreToolModalityConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolDataStoreToolModalityConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 modality_type: _builtins.str,
                 grounding_config: Optional['outputs.ToolDataStoreToolModalityConfigGroundingConfig'] = None,
                 rewriter_config: Optional['outputs.ToolDataStoreToolModalityConfigRewriterConfig'] = None,
                 summarization_config: Optional['outputs.ToolDataStoreToolModalityConfigSummarizationConfig'] = None):
        """
        :param _builtins.str modality_type: The modality type.
               Possible values:
               TEXT
               AUDIO
        :param 'ToolDataStoreToolModalityConfigGroundingConfigArgs' grounding_config: Grounding configuration.
               Structure is documented below.
        :param 'ToolDataStoreToolModalityConfigRewriterConfigArgs' rewriter_config: Rewriter configuration.
               Structure is documented below.
        :param 'ToolDataStoreToolModalityConfigSummarizationConfigArgs' summarization_config: Summarization configuration.
               Structure is documented below.
        """
        pulumi.set(__self__, "modality_type", modality_type)
        if grounding_config is not None:
            pulumi.set(__self__, "grounding_config", grounding_config)
        if rewriter_config is not None:
            pulumi.set(__self__, "rewriter_config", rewriter_config)
        if summarization_config is not None:
            pulumi.set(__self__, "summarization_config", summarization_config)

    @_builtins.property
    @pulumi.getter(name="modalityType")
    def modality_type(self) -> _builtins.str:
        """
        The modality type.
        Possible values:
        TEXT
        AUDIO
        """
        return pulumi.get(self, "modality_type")

    @_builtins.property
    @pulumi.getter(name="groundingConfig")
    def grounding_config(self) -> Optional['outputs.ToolDataStoreToolModalityConfigGroundingConfig']:
        """
        Grounding configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "grounding_config")

    @_builtins.property
    @pulumi.getter(name="rewriterConfig")
    def rewriter_config(self) -> Optional['outputs.ToolDataStoreToolModalityConfigRewriterConfig']:
        """
        Rewriter configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "rewriter_config")

    @_builtins.property
    @pulumi.getter(name="summarizationConfig")
    def summarization_config(self) -> Optional['outputs.ToolDataStoreToolModalityConfigSummarizationConfig']:
        """
        Summarization configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "summarization_config")


@pulumi.output_type
class ToolDataStoreToolModalityConfigGroundingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "groundingLevel":
            suggest = "grounding_level"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolDataStoreToolModalityConfigGroundingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolDataStoreToolModalityConfigGroundingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolDataStoreToolModalityConfigGroundingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 grounding_level: Optional[_builtins.float] = None):
        """
        :param _builtins.bool disabled: Whether grounding is disabled.
        :param _builtins.float grounding_level: The groundedness threshold of the answer based on the retrieved sources.
               The value has a configurable range of [1, 5]. The level is used to
               threshold the groundedness of the answer, meaning that all responses with
               a groundedness score below the threshold will fall back to returning
               relevant snippets only.
               For example, a level of 3 means that the groundedness score must be
               3 or higher for the response to be returned.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if grounding_level is not None:
            pulumi.set(__self__, "grounding_level", grounding_level)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether grounding is disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="groundingLevel")
    def grounding_level(self) -> Optional[_builtins.float]:
        """
        The groundedness threshold of the answer based on the retrieved sources.
        The value has a configurable range of [1, 5]. The level is used to
        threshold the groundedness of the answer, meaning that all responses with
        a groundedness score below the threshold will fall back to returning
        relevant snippets only.
        For example, a level of 3 means that the groundedness score must be
        3 or higher for the response to be returned.
        """
        return pulumi.get(self, "grounding_level")


@pulumi.output_type
class ToolDataStoreToolModalityConfigRewriterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelSettings":
            suggest = "model_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolDataStoreToolModalityConfigRewriterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolDataStoreToolModalityConfigRewriterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolDataStoreToolModalityConfigRewriterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 model_settings: 'outputs.ToolDataStoreToolModalityConfigRewriterConfigModelSettings',
                 disabled: Optional[_builtins.bool] = None,
                 prompt: Optional[_builtins.str] = None):
        """
        :param 'ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgs' model_settings: Model settings contains various configurations for the LLM model.
               Structure is documented below.
        :param _builtins.bool disabled: Whether the rewriter is disabled.
        :param _builtins.str prompt: The prompt definition. If not set, default prompt will be used.
        """
        pulumi.set(__self__, "model_settings", model_settings)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> 'outputs.ToolDataStoreToolModalityConfigRewriterConfigModelSettings':
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether the rewriter is disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[_builtins.str]:
        """
        The prompt definition. If not set, default prompt will be used.
        """
        return pulumi.get(self, "prompt")


@pulumi.output_type
class ToolDataStoreToolModalityConfigRewriterConfigModelSettings(dict):
    def __init__(__self__, *,
                 model: Optional[_builtins.str] = None,
                 temperature: Optional[_builtins.float] = None):
        """
        :param _builtins.str model: The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param _builtins.float temperature: If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")


@pulumi.output_type
class ToolDataStoreToolModalityConfigSummarizationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "modelSettings":
            suggest = "model_settings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolDataStoreToolModalityConfigSummarizationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolDataStoreToolModalityConfigSummarizationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolDataStoreToolModalityConfigSummarizationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disabled: Optional[_builtins.bool] = None,
                 model_settings: Optional['outputs.ToolDataStoreToolModalityConfigSummarizationConfigModelSettings'] = None,
                 prompt: Optional[_builtins.str] = None):
        """
        :param _builtins.bool disabled: Whether summarization is disabled.
        :param 'ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgs' model_settings: Model settings contains various configurations for the LLM model.
               Structure is documented below.
        :param _builtins.str prompt: The prompt definition. If not set, default prompt will be used.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[_builtins.bool]:
        """
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional['outputs.ToolDataStoreToolModalityConfigSummarizationConfigModelSettings']:
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[_builtins.str]:
        """
        The prompt definition. If not set, default prompt will be used.
        """
        return pulumi.get(self, "prompt")


@pulumi.output_type
class ToolDataStoreToolModalityConfigSummarizationConfigModelSettings(dict):
    def __init__(__self__, *,
                 model: Optional[_builtins.str] = None,
                 temperature: Optional[_builtins.float] = None):
        """
        :param _builtins.str model: The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param _builtins.float temperature: If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[_builtins.str]:
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[_builtins.float]:
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")


@pulumi.output_type
class ToolGoogleSearchTool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contextUrls":
            suggest = "context_urls"
        elif key == "excludeDomains":
            suggest = "exclude_domains"
        elif key == "preferredDomains":
            suggest = "preferred_domains"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolGoogleSearchTool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolGoogleSearchTool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolGoogleSearchTool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 name: _builtins.str,
                 context_urls: Optional[Sequence[_builtins.str]] = None,
                 description: Optional[_builtins.str] = None,
                 exclude_domains: Optional[Sequence[_builtins.str]] = None,
                 preferred_domains: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str name: The name of the tool.
        :param Sequence[_builtins.str] context_urls: Content will be fetched directly from these URLs for context and grounding.
               More details: https://cloud.google.com/vertex-ai/generative-ai/docs/url-context.
               Example: "https://example.com/path.html". A maximum of 20 URLs are allowed.
        :param _builtins.str description: Description of the tool's purpose.
        :param Sequence[_builtins.str] exclude_domains: List of domains to be excluded from the search results.
               Example: "example.com".
               A maximum of 2000 domains can be excluded.
        :param Sequence[_builtins.str] preferred_domains: Specifies domain names to guide the search.
               The model will be instructed to prioritize these domains
               when formulating queries for google search.
               This is a best-effort hint and these domains may or may
               not be exclusively reflected in the final search results.
               Example: "example.com", "another.site".
               A maximum of 20 domains can be specified.
        """
        pulumi.set(__self__, "name", name)
        if context_urls is not None:
            pulumi.set(__self__, "context_urls", context_urls)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exclude_domains is not None:
            pulumi.set(__self__, "exclude_domains", exclude_domains)
        if preferred_domains is not None:
            pulumi.set(__self__, "preferred_domains", preferred_domains)

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The name of the tool.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="contextUrls")
    def context_urls(self) -> Optional[Sequence[_builtins.str]]:
        """
        Content will be fetched directly from these URLs for context and grounding.
        More details: https://cloud.google.com/vertex-ai/generative-ai/docs/url-context.
        Example: "https://example.com/path.html". A maximum of 20 URLs are allowed.
        """
        return pulumi.get(self, "context_urls")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        Description of the tool's purpose.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="excludeDomains")
    def exclude_domains(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of domains to be excluded from the search results.
        Example: "example.com".
        A maximum of 2000 domains can be excluded.
        """
        return pulumi.get(self, "exclude_domains")

    @_builtins.property
    @pulumi.getter(name="preferredDomains")
    def preferred_domains(self) -> Optional[Sequence[_builtins.str]]:
        """
        Specifies domain names to guide the search.
        The model will be instructed to prioritize these domains
        when formulating queries for google search.
        This is a best-effort hint and these domains may or may
        not be exclusively reflected in the final search results.
        Example: "example.com", "another.site".
        A maximum of 20 domains can be specified.
        """
        return pulumi.get(self, "preferred_domains")


@pulumi.output_type
class ToolOpenApiTool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiAuthentications":
            suggest = "api_authentications"
        elif key == "ignoreUnknownFields":
            suggest = "ignore_unknown_fields"
        elif key == "openApiSchema":
            suggest = "open_api_schema"
        elif key == "serviceDirectoryConfigs":
            suggest = "service_directory_configs"
        elif key == "tlsConfigs":
            suggest = "tls_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolOpenApiTool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolOpenApiTool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolOpenApiTool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_authentications: Optional[Sequence['outputs.ToolOpenApiToolApiAuthentication']] = None,
                 description: Optional[_builtins.str] = None,
                 ignore_unknown_fields: Optional[_builtins.bool] = None,
                 name: Optional[_builtins.str] = None,
                 open_api_schema: Optional[_builtins.str] = None,
                 service_directory_configs: Optional[Sequence['outputs.ToolOpenApiToolServiceDirectoryConfig']] = None,
                 tls_configs: Optional[Sequence['outputs.ToolOpenApiToolTlsConfig']] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param Sequence['ToolOpenApiToolApiAuthenticationArgs'] api_authentications: (Output)
               Authentication information required for API calls.
               Structure is documented below.
        :param _builtins.str description: (Output)
               The description of the system tool.
        :param _builtins.bool ignore_unknown_fields: (Output)
               If true, the agent will ignore unknown fields in the API response.
        :param _builtins.str name: (Output)
               The name of the system tool.
        :param _builtins.str open_api_schema: (Output)
               The OpenAPI schema in JSON or YAML format.
        :param Sequence['ToolOpenApiToolServiceDirectoryConfigArgs'] service_directory_configs: (Output)
               Configuration for tools using Service Directory.
               Structure is documented below.
        :param Sequence['ToolOpenApiToolTlsConfigArgs'] tls_configs: (Output)
               The TLS configuration.
               Structure is documented below.
        :param _builtins.str url: (Output)
               The server URL of the Open API schema. This field is only set in tools in the
               environment dependencies during the export process if the schema contains a
               server url. During the import process, if this url is present in the environment
               dependencies and the schema has the $env_var placeholder, it will replace the
               placeholder in the schema.
        """
        if api_authentications is not None:
            pulumi.set(__self__, "api_authentications", api_authentications)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ignore_unknown_fields is not None:
            pulumi.set(__self__, "ignore_unknown_fields", ignore_unknown_fields)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if open_api_schema is not None:
            pulumi.set(__self__, "open_api_schema", open_api_schema)
        if service_directory_configs is not None:
            pulumi.set(__self__, "service_directory_configs", service_directory_configs)
        if tls_configs is not None:
            pulumi.set(__self__, "tls_configs", tls_configs)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="apiAuthentications")
    def api_authentications(self) -> Optional[Sequence['outputs.ToolOpenApiToolApiAuthentication']]:
        """
        (Output)
        Authentication information required for API calls.
        Structure is documented below.
        """
        return pulumi.get(self, "api_authentications")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        (Output)
        The description of the system tool.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="ignoreUnknownFields")
    def ignore_unknown_fields(self) -> Optional[_builtins.bool]:
        """
        (Output)
        If true, the agent will ignore unknown fields in the API response.
        """
        return pulumi.get(self, "ignore_unknown_fields")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the system tool.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="openApiSchema")
    def open_api_schema(self) -> Optional[_builtins.str]:
        """
        (Output)
        The OpenAPI schema in JSON or YAML format.
        """
        return pulumi.get(self, "open_api_schema")

    @_builtins.property
    @pulumi.getter(name="serviceDirectoryConfigs")
    def service_directory_configs(self) -> Optional[Sequence['outputs.ToolOpenApiToolServiceDirectoryConfig']]:
        """
        (Output)
        Configuration for tools using Service Directory.
        Structure is documented below.
        """
        return pulumi.get(self, "service_directory_configs")

    @_builtins.property
    @pulumi.getter(name="tlsConfigs")
    def tls_configs(self) -> Optional[Sequence['outputs.ToolOpenApiToolTlsConfig']]:
        """
        (Output)
        The TLS configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "tls_configs")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        (Output)
        The server URL of the Open API schema. This field is only set in tools in the
        environment dependencies during the export process if the schema contains a
        server url. During the import process, if this url is present in the environment
        dependencies and the schema has the $env_var placeholder, it will replace the
        placeholder in the schema.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ToolOpenApiToolApiAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKeyConfigs":
            suggest = "api_key_configs"
        elif key == "bearerTokenConfigs":
            suggest = "bearer_token_configs"
        elif key == "oauthConfigs":
            suggest = "oauth_configs"
        elif key == "serviceAccountAuthConfigs":
            suggest = "service_account_auth_configs"
        elif key == "serviceAgentIdTokenAuthConfigs":
            suggest = "service_agent_id_token_auth_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolOpenApiToolApiAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolOpenApiToolApiAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolOpenApiToolApiAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key_configs: Optional[Sequence['outputs.ToolOpenApiToolApiAuthenticationApiKeyConfig']] = None,
                 bearer_token_configs: Optional[Sequence['outputs.ToolOpenApiToolApiAuthenticationBearerTokenConfig']] = None,
                 oauth_configs: Optional[Sequence['outputs.ToolOpenApiToolApiAuthenticationOauthConfig']] = None,
                 service_account_auth_configs: Optional[Sequence['outputs.ToolOpenApiToolApiAuthenticationServiceAccountAuthConfig']] = None,
                 service_agent_id_token_auth_configs: Optional[Sequence['outputs.ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfig']] = None):
        """
        :param Sequence['ToolOpenApiToolApiAuthenticationApiKeyConfigArgs'] api_key_configs: (Output)
               Configurations for authentication with API key.
               Structure is documented below.
        :param Sequence['ToolOpenApiToolApiAuthenticationBearerTokenConfigArgs'] bearer_token_configs: (Output)
               Configurations for authentication with a bearer token.
               Structure is documented below.
        :param Sequence['ToolOpenApiToolApiAuthenticationOauthConfigArgs'] oauth_configs: (Output)
               Configurations for authentication with OAuth.
               Structure is documented below.
        :param Sequence['ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs'] service_account_auth_configs: (Output)
               Configurations for authentication using a custom service account.
               Structure is documented below.
        :param Sequence['ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs'] service_agent_id_token_auth_configs: (Output)
               Configurations for authentication with [ID
               token](https://cloud.google.com/docs/authentication/token-types#id) generated
               from service agent.
        """
        if api_key_configs is not None:
            pulumi.set(__self__, "api_key_configs", api_key_configs)
        if bearer_token_configs is not None:
            pulumi.set(__self__, "bearer_token_configs", bearer_token_configs)
        if oauth_configs is not None:
            pulumi.set(__self__, "oauth_configs", oauth_configs)
        if service_account_auth_configs is not None:
            pulumi.set(__self__, "service_account_auth_configs", service_account_auth_configs)
        if service_agent_id_token_auth_configs is not None:
            pulumi.set(__self__, "service_agent_id_token_auth_configs", service_agent_id_token_auth_configs)

    @_builtins.property
    @pulumi.getter(name="apiKeyConfigs")
    def api_key_configs(self) -> Optional[Sequence['outputs.ToolOpenApiToolApiAuthenticationApiKeyConfig']]:
        """
        (Output)
        Configurations for authentication with API key.
        Structure is documented below.
        """
        return pulumi.get(self, "api_key_configs")

    @_builtins.property
    @pulumi.getter(name="bearerTokenConfigs")
    def bearer_token_configs(self) -> Optional[Sequence['outputs.ToolOpenApiToolApiAuthenticationBearerTokenConfig']]:
        """
        (Output)
        Configurations for authentication with a bearer token.
        Structure is documented below.
        """
        return pulumi.get(self, "bearer_token_configs")

    @_builtins.property
    @pulumi.getter(name="oauthConfigs")
    def oauth_configs(self) -> Optional[Sequence['outputs.ToolOpenApiToolApiAuthenticationOauthConfig']]:
        """
        (Output)
        Configurations for authentication with OAuth.
        Structure is documented below.
        """
        return pulumi.get(self, "oauth_configs")

    @_builtins.property
    @pulumi.getter(name="serviceAccountAuthConfigs")
    def service_account_auth_configs(self) -> Optional[Sequence['outputs.ToolOpenApiToolApiAuthenticationServiceAccountAuthConfig']]:
        """
        (Output)
        Configurations for authentication using a custom service account.
        Structure is documented below.
        """
        return pulumi.get(self, "service_account_auth_configs")

    @_builtins.property
    @pulumi.getter(name="serviceAgentIdTokenAuthConfigs")
    def service_agent_id_token_auth_configs(self) -> Optional[Sequence['outputs.ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfig']]:
        """
        (Output)
        Configurations for authentication with [ID
        token](https://cloud.google.com/docs/authentication/token-types#id) generated
        from service agent.
        """
        return pulumi.get(self, "service_agent_id_token_auth_configs")


@pulumi.output_type
class ToolOpenApiToolApiAuthenticationApiKeyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKeySecretVersion":
            suggest = "api_key_secret_version"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "requestLocation":
            suggest = "request_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolOpenApiToolApiAuthenticationApiKeyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolOpenApiToolApiAuthenticationApiKeyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolOpenApiToolApiAuthenticationApiKeyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key_secret_version: Optional[_builtins.str] = None,
                 key_name: Optional[_builtins.str] = None,
                 request_location: Optional[_builtins.str] = None):
        """
        :param _builtins.str api_key_secret_version: (Output)
               The name of the SecretManager secret version resource storing the API key.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        :param _builtins.str key_name: (Output)
               The parameter name or the header name of the API key.
               E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        :param _builtins.str request_location: (Output)
               Key location in the request.
               Possible values:
               HEADER
               QUERY_STRING
        """
        if api_key_secret_version is not None:
            pulumi.set(__self__, "api_key_secret_version", api_key_secret_version)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if request_location is not None:
            pulumi.set(__self__, "request_location", request_location)

    @_builtins.property
    @pulumi.getter(name="apiKeySecretVersion")
    def api_key_secret_version(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the SecretManager secret version resource storing the API key.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "api_key_secret_version")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter(name="requestLocation")
    def request_location(self) -> Optional[_builtins.str]:
        """
        (Output)
        Key location in the request.
        Possible values:
        HEADER
        QUERY_STRING
        """
        return pulumi.get(self, "request_location")


@pulumi.output_type
class ToolOpenApiToolApiAuthenticationBearerTokenConfig(dict):
    def __init__(__self__, *,
                 token: Optional[_builtins.str] = None):
        """
        :param _builtins.str token: (Output)
               The bearer token. Must be in the format $context.variables.<name_of_variable>.
        """
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        (Output)
        The bearer token. Must be in the format $context.variables.<name_of_variable>.
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ToolOpenApiToolApiAuthenticationOauthConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretVersion":
            suggest = "client_secret_version"
        elif key == "oauthGrantType":
            suggest = "oauth_grant_type"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolOpenApiToolApiAuthenticationOauthConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolOpenApiToolApiAuthenticationOauthConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolOpenApiToolApiAuthenticationOauthConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 client_secret_version: Optional[_builtins.str] = None,
                 oauth_grant_type: Optional[_builtins.str] = None,
                 scopes: Optional[Sequence[_builtins.str]] = None,
                 token_endpoint: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: (Output)
               The client ID from the OAuth provider.
        :param _builtins.str client_secret_version: (Output)
               The name of the SecretManager secret version resource storing the
               client secret.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        :param _builtins.str oauth_grant_type: (Output)
               OAuth grant types.
               Possible values:
               CLIENT_CREDENTIAL
        :param Sequence[_builtins.str] scopes: (Output)
               The OAuth scopes to grant.
        :param _builtins.str token_endpoint: (Output)
               The token endpoint in the OAuth provider to exchange for an access token.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_version is not None:
            pulumi.set(__self__, "client_secret_version", client_secret_version)
        if oauth_grant_type is not None:
            pulumi.set(__self__, "oauth_grant_type", oauth_grant_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        (Output)
        The client ID from the OAuth provider.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecretVersion")
    def client_secret_version(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the SecretManager secret version resource storing the
        client secret.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "client_secret_version")

    @_builtins.property
    @pulumi.getter(name="oauthGrantType")
    def oauth_grant_type(self) -> Optional[_builtins.str]:
        """
        (Output)
        OAuth grant types.
        Possible values:
        CLIENT_CREDENTIAL
        """
        return pulumi.get(self, "oauth_grant_type")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        The OAuth scopes to grant.
        """
        return pulumi.get(self, "scopes")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[_builtins.str]:
        """
        (Output)
        The token endpoint in the OAuth provider to exchange for an access token.
        """
        return pulumi.get(self, "token_endpoint")


@pulumi.output_type
class ToolOpenApiToolApiAuthenticationServiceAccountAuthConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccount":
            suggest = "service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolOpenApiToolApiAuthenticationServiceAccountAuthConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolOpenApiToolApiAuthenticationServiceAccountAuthConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolOpenApiToolApiAuthenticationServiceAccountAuthConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account: Optional[_builtins.str] = None):
        """
        :param _builtins.str service_account: (Output)
               The email address of the service account used for authenticatation. CES
               uses this service account to exchange an access token and the access token
               is then sent in the `Authorization` header of the request.
               The service account must have the
               `roles/iam.serviceAccountTokenCreator` role granted to the
               CES service agent
               `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[_builtins.str]:
        """
        (Output)
        The email address of the service account used for authenticatation. CES
        uses this service account to exchange an access token and the access token
        is then sent in the `Authorization` header of the request.
        The service account must have the
        `roles/iam.serviceAccountTokenCreator` role granted to the
        CES service agent
        `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "service_account")


@pulumi.output_type
class ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ToolOpenApiToolServiceDirectoryConfig(dict):
    def __init__(__self__, *,
                 service: Optional[_builtins.str] = None):
        """
        :param _builtins.str service: (Output)
               The name of [Service
               Directory](https://cloud.google.com/service-directory) service.
               Format:
               `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
               Location of the service directory must be the same as the location of the
               app.
        """
        if service is not None:
            pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of [Service
        Directory](https://cloud.google.com/service-directory) service.
        Format:
        `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
        Location of the service directory must be the same as the location of the
        app.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class ToolOpenApiToolTlsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCerts":
            suggest = "ca_certs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolOpenApiToolTlsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolOpenApiToolTlsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolOpenApiToolTlsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certs: Optional[Sequence['outputs.ToolOpenApiToolTlsConfigCaCert']] = None):
        """
        :param Sequence['ToolOpenApiToolTlsConfigCaCertArgs'] ca_certs: (Output)
               Specifies a list of allowed custom CA certificates for HTTPS
               verification.
               Structure is documented below.
        """
        if ca_certs is not None:
            pulumi.set(__self__, "ca_certs", ca_certs)

    @_builtins.property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> Optional[Sequence['outputs.ToolOpenApiToolTlsConfigCaCert']]:
        """
        (Output)
        Specifies a list of allowed custom CA certificates for HTTPS
        verification.
        Structure is documented below.
        """
        return pulumi.get(self, "ca_certs")


@pulumi.output_type
class ToolOpenApiToolTlsConfigCaCert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolOpenApiToolTlsConfigCaCert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolOpenApiToolTlsConfigCaCert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolOpenApiToolTlsConfigCaCert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert: Optional[_builtins.str] = None,
                 display_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str cert: (Output)
               The allowed custom CA certificates (in DER format) for
               HTTPS verification. This overrides the default SSL trust store. If this
               is empty or unspecified, CES will use Google's default trust
               store to verify certificates. N.B. Make sure the HTTPS server
               certificates are signed with "subject alt name". For instance a
               certificate can be self-signed using the following command,
               openssl x509 -req -days 200 -in example.com.csr \\
               -signkey example.com.key \\
               -out example.com.crt \\
               -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
               A base64-encoded string.
        :param _builtins.str display_name: (Output)
               The name of the allowed custom CA certificates. This
               can be used to disambiguate the custom CA certificates.
        """
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> Optional[_builtins.str]:
        """
        (Output)
        The allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, CES will use Google's default trust
        store to verify certificates. N.B. Make sure the HTTPS server
        certificates are signed with "subject alt name". For instance a
        certificate can be self-signed using the following command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        A base64-encoded string.
        """
        return pulumi.get(self, "cert")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the allowed custom CA certificates. This
        can be used to disambiguate the custom CA certificates.
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class ToolPythonFunction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pythonCode":
            suggest = "python_code"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolPythonFunction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolPythonFunction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolPythonFunction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None,
                 python_code: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: (Output)
               The description of the Python function, parsed from the python code's
               docstring.
        :param _builtins.str name: The name of the Python function to execute. Must match a Python function
               name defined in the python code. Case sensitive. If the name is not
               provided, the first function defined in the python code will be used.
        :param _builtins.str python_code: The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        (Output)
        The description of the Python function, parsed from the python code's
        docstring.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the Python function to execute. Must match a Python function
        name defined in the python code. Case sensitive. If the name is not
        provided, the first function defined in the python code will be used.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[_builtins.str]:
        """
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")


@pulumi.output_type
class ToolSystemTool(dict):
    def __init__(__self__, *,
                 description: Optional[_builtins.str] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str description: (Output)
               The description of the system tool.
        :param _builtins.str name: (Output)
               The name of the system tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        (Output)
        The description of the system tool.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Output)
        The name of the system tool.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class ToolsetOpenApiToolset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "openApiSchema":
            suggest = "open_api_schema"
        elif key == "apiAuthentication":
            suggest = "api_authentication"
        elif key == "ignoreUnknownFields":
            suggest = "ignore_unknown_fields"
        elif key == "serviceDirectoryConfig":
            suggest = "service_directory_config"
        elif key == "tlsConfig":
            suggest = "tls_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolsetOpenApiToolset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolsetOpenApiToolset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolsetOpenApiToolset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 open_api_schema: _builtins.str,
                 api_authentication: Optional['outputs.ToolsetOpenApiToolsetApiAuthentication'] = None,
                 ignore_unknown_fields: Optional[_builtins.bool] = None,
                 service_directory_config: Optional['outputs.ToolsetOpenApiToolsetServiceDirectoryConfig'] = None,
                 tls_config: Optional['outputs.ToolsetOpenApiToolsetTlsConfig'] = None,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str open_api_schema: The OpenAPI schema of the toolset.
        :param 'ToolsetOpenApiToolsetApiAuthenticationArgs' api_authentication: Authentication information required for API calls.
               Structure is documented below.
        :param _builtins.bool ignore_unknown_fields: If true, the agent will ignore unknown fields in the API response for all
               operations defined in the OpenAPI schema.
        :param 'ToolsetOpenApiToolsetServiceDirectoryConfigArgs' service_directory_config: Configuration for tools using Service Directory.
               Structure is documented below.
        :param 'ToolsetOpenApiToolsetTlsConfigArgs' tls_config: The TLS configuration.
               Structure is documented below.
        :param _builtins.str url: (Output)
               The server URL of the Open API schema.
               This field is only set in toolsets in the environment dependencies
               during the export process if the schema contains a server url.
               During the import process, if this url is present in the environment dependencies
               and the schema has the $env_var placeholder,
               it will replace the placeholder in the schema.
        """
        pulumi.set(__self__, "open_api_schema", open_api_schema)
        if api_authentication is not None:
            pulumi.set(__self__, "api_authentication", api_authentication)
        if ignore_unknown_fields is not None:
            pulumi.set(__self__, "ignore_unknown_fields", ignore_unknown_fields)
        if service_directory_config is not None:
            pulumi.set(__self__, "service_directory_config", service_directory_config)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="openApiSchema")
    def open_api_schema(self) -> _builtins.str:
        """
        The OpenAPI schema of the toolset.
        """
        return pulumi.get(self, "open_api_schema")

    @_builtins.property
    @pulumi.getter(name="apiAuthentication")
    def api_authentication(self) -> Optional['outputs.ToolsetOpenApiToolsetApiAuthentication']:
        """
        Authentication information required for API calls.
        Structure is documented below.
        """
        return pulumi.get(self, "api_authentication")

    @_builtins.property
    @pulumi.getter(name="ignoreUnknownFields")
    def ignore_unknown_fields(self) -> Optional[_builtins.bool]:
        """
        If true, the agent will ignore unknown fields in the API response for all
        operations defined in the OpenAPI schema.
        """
        return pulumi.get(self, "ignore_unknown_fields")

    @_builtins.property
    @pulumi.getter(name="serviceDirectoryConfig")
    def service_directory_config(self) -> Optional['outputs.ToolsetOpenApiToolsetServiceDirectoryConfig']:
        """
        Configuration for tools using Service Directory.
        Structure is documented below.
        """
        return pulumi.get(self, "service_directory_config")

    @_builtins.property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional['outputs.ToolsetOpenApiToolsetTlsConfig']:
        """
        The TLS configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "tls_config")

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        (Output)
        The server URL of the Open API schema.
        This field is only set in toolsets in the environment dependencies
        during the export process if the schema contains a server url.
        During the import process, if this url is present in the environment dependencies
        and the schema has the $env_var placeholder,
        it will replace the placeholder in the schema.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class ToolsetOpenApiToolsetApiAuthentication(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKeyConfig":
            suggest = "api_key_config"
        elif key == "bearerTokenConfig":
            suggest = "bearer_token_config"
        elif key == "oauthConfig":
            suggest = "oauth_config"
        elif key == "serviceAccountAuthConfig":
            suggest = "service_account_auth_config"
        elif key == "serviceAgentIdTokenAuthConfig":
            suggest = "service_agent_id_token_auth_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolsetOpenApiToolsetApiAuthentication. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolsetOpenApiToolsetApiAuthentication.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolsetOpenApiToolsetApiAuthentication.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key_config: Optional['outputs.ToolsetOpenApiToolsetApiAuthenticationApiKeyConfig'] = None,
                 bearer_token_config: Optional['outputs.ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfig'] = None,
                 oauth_config: Optional['outputs.ToolsetOpenApiToolsetApiAuthenticationOauthConfig'] = None,
                 service_account_auth_config: Optional['outputs.ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfig'] = None,
                 service_agent_id_token_auth_config: Optional['outputs.ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfig'] = None):
        """
        :param 'ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs' api_key_config: Configurations for authentication with API key.
               Structure is documented below.
        :param 'ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs' bearer_token_config: Configurations for authentication with a bearer token.
               Structure is documented below.
        :param 'ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs' oauth_config: Configurations for authentication with OAuth.
               Structure is documented below.
        :param 'ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs' service_account_auth_config: Configurations for authentication using a custom service account.
               Structure is documented below.
        :param 'ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs' service_agent_id_token_auth_config: Configurations for authentication with [ID
               token](https://cloud.google.com/docs/authentication/token-types#id) generated
               from service agent.
        """
        if api_key_config is not None:
            pulumi.set(__self__, "api_key_config", api_key_config)
        if bearer_token_config is not None:
            pulumi.set(__self__, "bearer_token_config", bearer_token_config)
        if oauth_config is not None:
            pulumi.set(__self__, "oauth_config", oauth_config)
        if service_account_auth_config is not None:
            pulumi.set(__self__, "service_account_auth_config", service_account_auth_config)
        if service_agent_id_token_auth_config is not None:
            pulumi.set(__self__, "service_agent_id_token_auth_config", service_agent_id_token_auth_config)

    @_builtins.property
    @pulumi.getter(name="apiKeyConfig")
    def api_key_config(self) -> Optional['outputs.ToolsetOpenApiToolsetApiAuthenticationApiKeyConfig']:
        """
        Configurations for authentication with API key.
        Structure is documented below.
        """
        return pulumi.get(self, "api_key_config")

    @_builtins.property
    @pulumi.getter(name="bearerTokenConfig")
    def bearer_token_config(self) -> Optional['outputs.ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfig']:
        """
        Configurations for authentication with a bearer token.
        Structure is documented below.
        """
        return pulumi.get(self, "bearer_token_config")

    @_builtins.property
    @pulumi.getter(name="oauthConfig")
    def oauth_config(self) -> Optional['outputs.ToolsetOpenApiToolsetApiAuthenticationOauthConfig']:
        """
        Configurations for authentication with OAuth.
        Structure is documented below.
        """
        return pulumi.get(self, "oauth_config")

    @_builtins.property
    @pulumi.getter(name="serviceAccountAuthConfig")
    def service_account_auth_config(self) -> Optional['outputs.ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfig']:
        """
        Configurations for authentication using a custom service account.
        Structure is documented below.
        """
        return pulumi.get(self, "service_account_auth_config")

    @_builtins.property
    @pulumi.getter(name="serviceAgentIdTokenAuthConfig")
    def service_agent_id_token_auth_config(self) -> Optional['outputs.ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfig']:
        """
        Configurations for authentication with [ID
        token](https://cloud.google.com/docs/authentication/token-types#id) generated
        from service agent.
        """
        return pulumi.get(self, "service_agent_id_token_auth_config")


@pulumi.output_type
class ToolsetOpenApiToolsetApiAuthenticationApiKeyConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "apiKeySecretVersion":
            suggest = "api_key_secret_version"
        elif key == "keyName":
            suggest = "key_name"
        elif key == "requestLocation":
            suggest = "request_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolsetOpenApiToolsetApiAuthenticationApiKeyConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolsetOpenApiToolsetApiAuthenticationApiKeyConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolsetOpenApiToolsetApiAuthenticationApiKeyConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 api_key_secret_version: _builtins.str,
                 key_name: _builtins.str,
                 request_location: _builtins.str):
        """
        :param _builtins.str api_key_secret_version: The name of the SecretManager secret version resource storing the API key.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param _builtins.str key_name: The parameter name or the header name of the API key.
               E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        :param _builtins.str request_location: Key location in the request.
               Possible values:
               HEADER
               QUERY_STRING
        """
        pulumi.set(__self__, "api_key_secret_version", api_key_secret_version)
        pulumi.set(__self__, "key_name", key_name)
        pulumi.set(__self__, "request_location", request_location)

    @_builtins.property
    @pulumi.getter(name="apiKeySecretVersion")
    def api_key_secret_version(self) -> _builtins.str:
        """
        The name of the SecretManager secret version resource storing the API key.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "api_key_secret_version")

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> _builtins.str:
        """
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        return pulumi.get(self, "key_name")

    @_builtins.property
    @pulumi.getter(name="requestLocation")
    def request_location(self) -> _builtins.str:
        """
        Key location in the request.
        Possible values:
        HEADER
        QUERY_STRING
        """
        return pulumi.get(self, "request_location")


@pulumi.output_type
class ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfig(dict):
    def __init__(__self__, *,
                 token: Optional[_builtins.str] = None):
        """
        :param _builtins.str token: (Optional)
        """
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[_builtins.str]:
        """
        (Optional)
        """
        return pulumi.get(self, "token")


@pulumi.output_type
class ToolsetOpenApiToolsetApiAuthenticationOauthConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecretVersion":
            suggest = "client_secret_version"
        elif key == "oauthGrantType":
            suggest = "oauth_grant_type"
        elif key == "tokenEndpoint":
            suggest = "token_endpoint"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolsetOpenApiToolsetApiAuthenticationOauthConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolsetOpenApiToolsetApiAuthenticationOauthConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolsetOpenApiToolsetApiAuthenticationOauthConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: _builtins.str,
                 client_secret_version: _builtins.str,
                 oauth_grant_type: _builtins.str,
                 token_endpoint: _builtins.str,
                 scopes: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str client_id: The client ID from the OAuth provider.
        :param _builtins.str client_secret_version: The name of the SecretManager secret version resource storing the
               client secret.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param _builtins.str oauth_grant_type: OAuth grant types.
               Possible values:
               CLIENT_CREDENTIAL
        :param _builtins.str token_endpoint: The token endpoint in the OAuth provider to exchange for an access token.
        :param Sequence[_builtins.str] scopes: The OAuth scopes to grant.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_version", client_secret_version)
        pulumi.set(__self__, "oauth_grant_type", oauth_grant_type)
        pulumi.set(__self__, "token_endpoint", token_endpoint)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> _builtins.str:
        """
        The client ID from the OAuth provider.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecretVersion")
    def client_secret_version(self) -> _builtins.str:
        """
        The name of the SecretManager secret version resource storing the
        client secret.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "client_secret_version")

    @_builtins.property
    @pulumi.getter(name="oauthGrantType")
    def oauth_grant_type(self) -> _builtins.str:
        """
        OAuth grant types.
        Possible values:
        CLIENT_CREDENTIAL
        """
        return pulumi.get(self, "oauth_grant_type")

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> _builtins.str:
        """
        The token endpoint in the OAuth provider to exchange for an access token.
        """
        return pulumi.get(self, "token_endpoint")

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[Sequence[_builtins.str]]:
        """
        The OAuth scopes to grant.
        """
        return pulumi.get(self, "scopes")


@pulumi.output_type
class ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "serviceAccount":
            suggest = "service_account"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 service_account: _builtins.str):
        """
        :param _builtins.str service_account: The email address of the service account used for authenticatation. CES
               uses this service account to exchange an access token and the access token
               is then sent in the `Authorization` header of the request.
               The service account must have the
               `roles/iam.serviceAccountTokenCreator` role granted to the
               CES service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        pulumi.set(__self__, "service_account", service_account)

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> _builtins.str:
        """
        The email address of the service account used for authenticatation. CES
        uses this service account to exchange an access token and the access token
        is then sent in the `Authorization` header of the request.
        The service account must have the
        `roles/iam.serviceAccountTokenCreator` role granted to the
        CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "service_account")


@pulumi.output_type
class ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ToolsetOpenApiToolsetServiceDirectoryConfig(dict):
    def __init__(__self__, *,
                 service: _builtins.str):
        """
        :param _builtins.str service: The name of [Service
               Directory](https://cloud.google.com/service-directory) service.
               Format:
               `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
               Location of the service directory must be the same as the location of the
               app.
        """
        pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def service(self) -> _builtins.str:
        """
        The name of [Service
        Directory](https://cloud.google.com/service-directory) service.
        Format:
        `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
        Location of the service directory must be the same as the location of the
        app.
        """
        return pulumi.get(self, "service")


@pulumi.output_type
class ToolsetOpenApiToolsetTlsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCerts":
            suggest = "ca_certs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolsetOpenApiToolsetTlsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolsetOpenApiToolsetTlsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolsetOpenApiToolsetTlsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certs: Sequence['outputs.ToolsetOpenApiToolsetTlsConfigCaCert']):
        """
        :param Sequence['ToolsetOpenApiToolsetTlsConfigCaCertArgs'] ca_certs: Specifies a list of allowed custom CA certificates for HTTPS
               verification.
               Structure is documented below.
        """
        pulumi.set(__self__, "ca_certs", ca_certs)

    @_builtins.property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> Sequence['outputs.ToolsetOpenApiToolsetTlsConfigCaCert']:
        """
        Specifies a list of allowed custom CA certificates for HTTPS
        verification.
        Structure is documented below.
        """
        return pulumi.get(self, "ca_certs")


@pulumi.output_type
class ToolsetOpenApiToolsetTlsConfigCaCert(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ToolsetOpenApiToolsetTlsConfigCaCert. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ToolsetOpenApiToolsetTlsConfigCaCert.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ToolsetOpenApiToolsetTlsConfigCaCert.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cert: _builtins.str,
                 display_name: _builtins.str):
        """
        :param _builtins.str cert: The allowed custom CA certificates (in DER format) for
               HTTPS verification. This overrides the default SSL trust store. If this
               is empty or unspecified, CES will use Google's default trust
               store to verify certificates. N.B. Make sure the HTTPS server
               certificates are signed with "subject alt name". For instance a
               certificate can be self-signed using the following command,
               openssl x509 -req -days 200 -in example.com.csr \\
               -signkey example.com.key \\
               -out example.com.crt \\
               -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        :param _builtins.str display_name: The name of the allowed custom CA certificates. This
               can be used to disambiguate the custom CA certificates.
        """
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> _builtins.str:
        """
        The allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, CES will use Google's default trust
        store to verify certificates. N.B. Make sure the HTTPS server
        certificates are signed with "subject alt name". For instance a
        certificate can be self-signed using the following command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        """
        return pulumi.get(self, "cert")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> _builtins.str:
        """
        The name of the allowed custom CA certificates. This
        can be used to disambiguate the custom CA certificates.
        """
        return pulumi.get(self, "display_name")


