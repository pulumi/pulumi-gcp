# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AgentAfterAgentCallbackArgs',
    'AgentAfterAgentCallbackArgsDict',
    'AgentAfterModelCallbackArgs',
    'AgentAfterModelCallbackArgsDict',
    'AgentAfterToolCallbackArgs',
    'AgentAfterToolCallbackArgsDict',
    'AgentBeforeAgentCallbackArgs',
    'AgentBeforeAgentCallbackArgsDict',
    'AgentBeforeModelCallbackArgs',
    'AgentBeforeModelCallbackArgsDict',
    'AgentBeforeToolCallbackArgs',
    'AgentBeforeToolCallbackArgsDict',
    'AgentLlmAgentArgs',
    'AgentLlmAgentArgsDict',
    'AgentModelSettingsArgs',
    'AgentModelSettingsArgsDict',
    'AgentRemoteDialogflowAgentArgs',
    'AgentRemoteDialogflowAgentArgsDict',
    'AgentToolsetArgs',
    'AgentToolsetArgsDict',
    'AppAudioProcessingConfigArgs',
    'AppAudioProcessingConfigArgsDict',
    'AppAudioProcessingConfigAmbientSoundConfigArgs',
    'AppAudioProcessingConfigAmbientSoundConfigArgsDict',
    'AppAudioProcessingConfigBargeInConfigArgs',
    'AppAudioProcessingConfigBargeInConfigArgsDict',
    'AppAudioProcessingConfigSynthesizeSpeechConfigArgs',
    'AppAudioProcessingConfigSynthesizeSpeechConfigArgsDict',
    'AppClientCertificateSettingsArgs',
    'AppClientCertificateSettingsArgsDict',
    'AppDataStoreSettingsArgs',
    'AppDataStoreSettingsArgsDict',
    'AppDataStoreSettingsEngineArgs',
    'AppDataStoreSettingsEngineArgsDict',
    'AppDefaultChannelProfileArgs',
    'AppDefaultChannelProfileArgsDict',
    'AppDefaultChannelProfilePersonaPropertyArgs',
    'AppDefaultChannelProfilePersonaPropertyArgsDict',
    'AppDefaultChannelProfileWebWidgetConfigArgs',
    'AppDefaultChannelProfileWebWidgetConfigArgsDict',
    'AppEvaluationMetricsThresholdsArgs',
    'AppEvaluationMetricsThresholdsArgsDict',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgs',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgsDict',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgs',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgsDict',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgs',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgsDict',
    'AppLanguageSettingsArgs',
    'AppLanguageSettingsArgsDict',
    'AppLoggingSettingsArgs',
    'AppLoggingSettingsArgsDict',
    'AppLoggingSettingsAudioRecordingConfigArgs',
    'AppLoggingSettingsAudioRecordingConfigArgsDict',
    'AppLoggingSettingsBigqueryExportSettingsArgs',
    'AppLoggingSettingsBigqueryExportSettingsArgsDict',
    'AppLoggingSettingsCloudLoggingSettingsArgs',
    'AppLoggingSettingsCloudLoggingSettingsArgsDict',
    'AppLoggingSettingsConversationLoggingSettingsArgs',
    'AppLoggingSettingsConversationLoggingSettingsArgsDict',
    'AppLoggingSettingsRedactionConfigArgs',
    'AppLoggingSettingsRedactionConfigArgsDict',
    'AppModelSettingsArgs',
    'AppModelSettingsArgsDict',
    'AppTimeZoneSettingsArgs',
    'AppTimeZoneSettingsArgsDict',
    'AppVariableDeclarationArgs',
    'AppVariableDeclarationArgsDict',
    'AppVariableDeclarationSchemaArgs',
    'AppVariableDeclarationSchemaArgsDict',
    'AppVersionSnapshotArgs',
    'AppVersionSnapshotArgsDict',
    'AppVersionSnapshotAgentArgs',
    'AppVersionSnapshotAgentArgsDict',
    'AppVersionSnapshotAgentAfterAgentCallbackArgs',
    'AppVersionSnapshotAgentAfterAgentCallbackArgsDict',
    'AppVersionSnapshotAgentAfterModelCallbackArgs',
    'AppVersionSnapshotAgentAfterModelCallbackArgsDict',
    'AppVersionSnapshotAgentAfterToolCallbackArgs',
    'AppVersionSnapshotAgentAfterToolCallbackArgsDict',
    'AppVersionSnapshotAgentBeforeAgentCallbackArgs',
    'AppVersionSnapshotAgentBeforeAgentCallbackArgsDict',
    'AppVersionSnapshotAgentBeforeModelCallbackArgs',
    'AppVersionSnapshotAgentBeforeModelCallbackArgsDict',
    'AppVersionSnapshotAgentBeforeToolCallbackArgs',
    'AppVersionSnapshotAgentBeforeToolCallbackArgsDict',
    'AppVersionSnapshotAgentLlmAgentArgs',
    'AppVersionSnapshotAgentLlmAgentArgsDict',
    'AppVersionSnapshotAgentModelSettingArgs',
    'AppVersionSnapshotAgentModelSettingArgsDict',
    'AppVersionSnapshotAgentRemoteDialogflowAgentArgs',
    'AppVersionSnapshotAgentRemoteDialogflowAgentArgsDict',
    'AppVersionSnapshotAgentToolsetArgs',
    'AppVersionSnapshotAgentToolsetArgsDict',
    'AppVersionSnapshotAppArgs',
    'AppVersionSnapshotAppArgsDict',
    'AppVersionSnapshotAppAudioProcessingConfigArgs',
    'AppVersionSnapshotAppAudioProcessingConfigArgsDict',
    'AppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfigArgs',
    'AppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfigArgsDict',
    'AppVersionSnapshotAppAudioProcessingConfigBargeInConfigArgs',
    'AppVersionSnapshotAppAudioProcessingConfigBargeInConfigArgsDict',
    'AppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfigArgs',
    'AppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfigArgsDict',
    'AppVersionSnapshotAppClientCertificateSettingArgs',
    'AppVersionSnapshotAppClientCertificateSettingArgsDict',
    'AppVersionSnapshotAppDataStoreSettingArgs',
    'AppVersionSnapshotAppDataStoreSettingArgsDict',
    'AppVersionSnapshotAppDataStoreSettingEngineArgs',
    'AppVersionSnapshotAppDataStoreSettingEngineArgsDict',
    'AppVersionSnapshotAppDefaultChannelProfileArgs',
    'AppVersionSnapshotAppDefaultChannelProfileArgsDict',
    'AppVersionSnapshotAppDefaultChannelProfilePersonaPropertyArgs',
    'AppVersionSnapshotAppDefaultChannelProfilePersonaPropertyArgsDict',
    'AppVersionSnapshotAppDefaultChannelProfileWebWidgetConfigArgs',
    'AppVersionSnapshotAppDefaultChannelProfileWebWidgetConfigArgsDict',
    'AppVersionSnapshotAppEvaluationMetricsThresholdArgs',
    'AppVersionSnapshotAppEvaluationMetricsThresholdArgsDict',
    'AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdArgs',
    'AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdArgsDict',
    'AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdExpectationLevelMetricsThresholdArgs',
    'AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdExpectationLevelMetricsThresholdArgsDict',
    'AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdTurnLevelMetricsThresholdArgs',
    'AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdTurnLevelMetricsThresholdArgsDict',
    'AppVersionSnapshotAppLanguageSettingArgs',
    'AppVersionSnapshotAppLanguageSettingArgsDict',
    'AppVersionSnapshotAppLoggingSettingArgs',
    'AppVersionSnapshotAppLoggingSettingArgsDict',
    'AppVersionSnapshotAppLoggingSettingAudioRecordingConfigArgs',
    'AppVersionSnapshotAppLoggingSettingAudioRecordingConfigArgsDict',
    'AppVersionSnapshotAppLoggingSettingBigqueryExportSettingArgs',
    'AppVersionSnapshotAppLoggingSettingBigqueryExportSettingArgsDict',
    'AppVersionSnapshotAppLoggingSettingCloudLoggingSettingArgs',
    'AppVersionSnapshotAppLoggingSettingCloudLoggingSettingArgsDict',
    'AppVersionSnapshotAppLoggingSettingConversationLoggingSettingArgs',
    'AppVersionSnapshotAppLoggingSettingConversationLoggingSettingArgsDict',
    'AppVersionSnapshotAppLoggingSettingRedactionConfigArgs',
    'AppVersionSnapshotAppLoggingSettingRedactionConfigArgsDict',
    'AppVersionSnapshotAppModelSettingArgs',
    'AppVersionSnapshotAppModelSettingArgsDict',
    'AppVersionSnapshotAppTimeZoneSettingArgs',
    'AppVersionSnapshotAppTimeZoneSettingArgsDict',
    'AppVersionSnapshotAppVariableDeclarationArgs',
    'AppVersionSnapshotAppVariableDeclarationArgsDict',
    'AppVersionSnapshotAppVariableDeclarationSchemaArgs',
    'AppVersionSnapshotAppVariableDeclarationSchemaArgsDict',
    'AppVersionSnapshotExampleArgs',
    'AppVersionSnapshotExampleArgsDict',
    'AppVersionSnapshotExampleMessageArgs',
    'AppVersionSnapshotExampleMessageArgsDict',
    'AppVersionSnapshotExampleMessageChunkArgs',
    'AppVersionSnapshotExampleMessageChunkArgsDict',
    'AppVersionSnapshotExampleMessageChunkAgentTransferArgs',
    'AppVersionSnapshotExampleMessageChunkAgentTransferArgsDict',
    'AppVersionSnapshotExampleMessageChunkImageArgs',
    'AppVersionSnapshotExampleMessageChunkImageArgsDict',
    'AppVersionSnapshotExampleMessageChunkToolCallArgs',
    'AppVersionSnapshotExampleMessageChunkToolCallArgsDict',
    'AppVersionSnapshotExampleMessageChunkToolCallToolsetToolArgs',
    'AppVersionSnapshotExampleMessageChunkToolCallToolsetToolArgsDict',
    'AppVersionSnapshotExampleMessageChunkToolResponseArgs',
    'AppVersionSnapshotExampleMessageChunkToolResponseArgsDict',
    'AppVersionSnapshotExampleMessageChunkToolResponseToolsetToolArgs',
    'AppVersionSnapshotExampleMessageChunkToolResponseToolsetToolArgsDict',
    'AppVersionSnapshotGuardrailArgs',
    'AppVersionSnapshotGuardrailArgsDict',
    'AppVersionSnapshotGuardrailActionArgs',
    'AppVersionSnapshotGuardrailActionArgsDict',
    'AppVersionSnapshotGuardrailActionGenerativeAnswerArgs',
    'AppVersionSnapshotGuardrailActionGenerativeAnswerArgsDict',
    'AppVersionSnapshotGuardrailActionRespondImmediatelyArgs',
    'AppVersionSnapshotGuardrailActionRespondImmediatelyArgsDict',
    'AppVersionSnapshotGuardrailActionRespondImmediatelyResponseArgs',
    'AppVersionSnapshotGuardrailActionRespondImmediatelyResponseArgsDict',
    'AppVersionSnapshotGuardrailActionTransferAgentArgs',
    'AppVersionSnapshotGuardrailActionTransferAgentArgsDict',
    'AppVersionSnapshotGuardrailCodeCallbackArgs',
    'AppVersionSnapshotGuardrailCodeCallbackArgsDict',
    'AppVersionSnapshotGuardrailCodeCallbackAfterAgentCallbackArgs',
    'AppVersionSnapshotGuardrailCodeCallbackAfterAgentCallbackArgsDict',
    'AppVersionSnapshotGuardrailCodeCallbackAfterModelCallbackArgs',
    'AppVersionSnapshotGuardrailCodeCallbackAfterModelCallbackArgsDict',
    'AppVersionSnapshotGuardrailCodeCallbackBeforeAgentCallbackArgs',
    'AppVersionSnapshotGuardrailCodeCallbackBeforeAgentCallbackArgsDict',
    'AppVersionSnapshotGuardrailCodeCallbackBeforeModelCallbackArgs',
    'AppVersionSnapshotGuardrailCodeCallbackBeforeModelCallbackArgsDict',
    'AppVersionSnapshotGuardrailContentFilterArgs',
    'AppVersionSnapshotGuardrailContentFilterArgsDict',
    'AppVersionSnapshotGuardrailLlmPolicyArgs',
    'AppVersionSnapshotGuardrailLlmPolicyArgsDict',
    'AppVersionSnapshotGuardrailLlmPolicyModelSettingArgs',
    'AppVersionSnapshotGuardrailLlmPolicyModelSettingArgsDict',
    'AppVersionSnapshotGuardrailLlmPromptSecurityArgs',
    'AppVersionSnapshotGuardrailLlmPromptSecurityArgsDict',
    'AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyArgs',
    'AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyArgsDict',
    'AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyModelSettingArgs',
    'AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyModelSettingArgsDict',
    'AppVersionSnapshotGuardrailLlmPromptSecurityDefaultSettingArgs',
    'AppVersionSnapshotGuardrailLlmPromptSecurityDefaultSettingArgsDict',
    'AppVersionSnapshotGuardrailModelSafetyArgs',
    'AppVersionSnapshotGuardrailModelSafetyArgsDict',
    'AppVersionSnapshotGuardrailModelSafetySafetySettingArgs',
    'AppVersionSnapshotGuardrailModelSafetySafetySettingArgsDict',
    'AppVersionSnapshotToolArgs',
    'AppVersionSnapshotToolArgsDict',
    'AppVersionSnapshotToolClientFunctionArgs',
    'AppVersionSnapshotToolClientFunctionArgsDict',
    'AppVersionSnapshotToolClientFunctionParameterArgs',
    'AppVersionSnapshotToolClientFunctionParameterArgsDict',
    'AppVersionSnapshotToolClientFunctionResponseArgs',
    'AppVersionSnapshotToolClientFunctionResponseArgsDict',
    'AppVersionSnapshotToolDataStoreToolArgs',
    'AppVersionSnapshotToolDataStoreToolArgsDict',
    'AppVersionSnapshotToolDataStoreToolBoostSpecArgs',
    'AppVersionSnapshotToolDataStoreToolBoostSpecArgsDict',
    'AppVersionSnapshotToolDataStoreToolBoostSpecSpecArgs',
    'AppVersionSnapshotToolDataStoreToolBoostSpecSpecArgsDict',
    'AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs',
    'AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecArgsDict',
    'AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs',
    'AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgsDict',
    'AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs',
    'AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgsDict',
    'AppVersionSnapshotToolDataStoreToolEngineSourceArgs',
    'AppVersionSnapshotToolDataStoreToolEngineSourceArgsDict',
    'AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceArgs',
    'AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceArgsDict',
    'AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs',
    'AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgsDict',
    'AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs',
    'AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgsDict',
    'AppVersionSnapshotToolDataStoreToolModalityConfigArgs',
    'AppVersionSnapshotToolDataStoreToolModalityConfigArgsDict',
    'AppVersionSnapshotToolDataStoreToolModalityConfigGroundingConfigArgs',
    'AppVersionSnapshotToolDataStoreToolModalityConfigGroundingConfigArgsDict',
    'AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigArgs',
    'AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigArgsDict',
    'AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigModelSettingArgs',
    'AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigModelSettingArgsDict',
    'AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigArgs',
    'AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigArgsDict',
    'AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigModelSettingArgs',
    'AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigModelSettingArgsDict',
    'AppVersionSnapshotToolGoogleSearchToolArgs',
    'AppVersionSnapshotToolGoogleSearchToolArgsDict',
    'AppVersionSnapshotToolOpenApiToolArgs',
    'AppVersionSnapshotToolOpenApiToolArgsDict',
    'AppVersionSnapshotToolOpenApiToolApiAuthenticationArgs',
    'AppVersionSnapshotToolOpenApiToolApiAuthenticationArgsDict',
    'AppVersionSnapshotToolOpenApiToolApiAuthenticationApiKeyConfigArgs',
    'AppVersionSnapshotToolOpenApiToolApiAuthenticationApiKeyConfigArgsDict',
    'AppVersionSnapshotToolOpenApiToolApiAuthenticationOauthConfigArgs',
    'AppVersionSnapshotToolOpenApiToolApiAuthenticationOauthConfigArgsDict',
    'AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs',
    'AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgsDict',
    'AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs',
    'AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict',
    'AppVersionSnapshotToolOpenApiToolServiceDirectoryConfigArgs',
    'AppVersionSnapshotToolOpenApiToolServiceDirectoryConfigArgsDict',
    'AppVersionSnapshotToolOpenApiToolTlsConfigArgs',
    'AppVersionSnapshotToolOpenApiToolTlsConfigArgsDict',
    'AppVersionSnapshotToolOpenApiToolTlsConfigCaCertArgs',
    'AppVersionSnapshotToolOpenApiToolTlsConfigCaCertArgsDict',
    'AppVersionSnapshotToolPythonFunctionArgs',
    'AppVersionSnapshotToolPythonFunctionArgsDict',
    'AppVersionSnapshotToolSystemToolArgs',
    'AppVersionSnapshotToolSystemToolArgsDict',
    'AppVersionSnapshotToolsetArgs',
    'AppVersionSnapshotToolsetArgsDict',
    'AppVersionSnapshotToolsetOpenApiToolsetArgs',
    'AppVersionSnapshotToolsetOpenApiToolsetArgsDict',
    'AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationArgs',
    'AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationArgsDict',
    'AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs',
    'AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgsDict',
    'AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs',
    'AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgsDict',
    'AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs',
    'AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationOauthConfigArgsDict',
    'AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs',
    'AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgsDict',
    'AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs',
    'AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict',
    'AppVersionSnapshotToolsetOpenApiToolsetServiceDirectoryConfigArgs',
    'AppVersionSnapshotToolsetOpenApiToolsetServiceDirectoryConfigArgsDict',
    'AppVersionSnapshotToolsetOpenApiToolsetTlsConfigArgs',
    'AppVersionSnapshotToolsetOpenApiToolsetTlsConfigArgsDict',
    'AppVersionSnapshotToolsetOpenApiToolsetTlsConfigCaCertArgs',
    'AppVersionSnapshotToolsetOpenApiToolsetTlsConfigCaCertArgsDict',
    'DeploymentChannelProfileArgs',
    'DeploymentChannelProfileArgsDict',
    'DeploymentChannelProfilePersonaPropertyArgs',
    'DeploymentChannelProfilePersonaPropertyArgsDict',
    'DeploymentChannelProfileWebWidgetConfigArgs',
    'DeploymentChannelProfileWebWidgetConfigArgsDict',
    'ExampleMessageArgs',
    'ExampleMessageArgsDict',
    'ExampleMessageChunkArgs',
    'ExampleMessageChunkArgsDict',
    'ExampleMessageChunkAgentTransferArgs',
    'ExampleMessageChunkAgentTransferArgsDict',
    'ExampleMessageChunkImageArgs',
    'ExampleMessageChunkImageArgsDict',
    'ExampleMessageChunkToolCallArgs',
    'ExampleMessageChunkToolCallArgsDict',
    'ExampleMessageChunkToolCallToolsetToolArgs',
    'ExampleMessageChunkToolCallToolsetToolArgsDict',
    'ExampleMessageChunkToolResponseArgs',
    'ExampleMessageChunkToolResponseArgsDict',
    'ExampleMessageChunkToolResponseToolsetToolArgs',
    'ExampleMessageChunkToolResponseToolsetToolArgsDict',
    'GuardrailActionArgs',
    'GuardrailActionArgsDict',
    'GuardrailActionGenerativeAnswerArgs',
    'GuardrailActionGenerativeAnswerArgsDict',
    'GuardrailActionRespondImmediatelyArgs',
    'GuardrailActionRespondImmediatelyArgsDict',
    'GuardrailActionRespondImmediatelyResponseArgs',
    'GuardrailActionRespondImmediatelyResponseArgsDict',
    'GuardrailActionTransferAgentArgs',
    'GuardrailActionTransferAgentArgsDict',
    'GuardrailCodeCallbackArgs',
    'GuardrailCodeCallbackArgsDict',
    'GuardrailCodeCallbackAfterAgentCallbackArgs',
    'GuardrailCodeCallbackAfterAgentCallbackArgsDict',
    'GuardrailCodeCallbackAfterModelCallbackArgs',
    'GuardrailCodeCallbackAfterModelCallbackArgsDict',
    'GuardrailCodeCallbackBeforeAgentCallbackArgs',
    'GuardrailCodeCallbackBeforeAgentCallbackArgsDict',
    'GuardrailCodeCallbackBeforeModelCallbackArgs',
    'GuardrailCodeCallbackBeforeModelCallbackArgsDict',
    'GuardrailContentFilterArgs',
    'GuardrailContentFilterArgsDict',
    'GuardrailLlmPolicyArgs',
    'GuardrailLlmPolicyArgsDict',
    'GuardrailLlmPolicyModelSettingsArgs',
    'GuardrailLlmPolicyModelSettingsArgsDict',
    'GuardrailLlmPromptSecurityArgs',
    'GuardrailLlmPromptSecurityArgsDict',
    'GuardrailLlmPromptSecurityCustomPolicyArgs',
    'GuardrailLlmPromptSecurityCustomPolicyArgsDict',
    'GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgs',
    'GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgsDict',
    'GuardrailLlmPromptSecurityDefaultSettingsArgs',
    'GuardrailLlmPromptSecurityDefaultSettingsArgsDict',
    'GuardrailModelSafetyArgs',
    'GuardrailModelSafetyArgsDict',
    'GuardrailModelSafetySafetySettingArgs',
    'GuardrailModelSafetySafetySettingArgsDict',
    'ToolClientFunctionArgs',
    'ToolClientFunctionArgsDict',
    'ToolClientFunctionParametersArgs',
    'ToolClientFunctionParametersArgsDict',
    'ToolClientFunctionResponseArgs',
    'ToolClientFunctionResponseArgsDict',
    'ToolDataStoreToolArgs',
    'ToolDataStoreToolArgsDict',
    'ToolDataStoreToolBoostSpecArgs',
    'ToolDataStoreToolBoostSpecArgsDict',
    'ToolDataStoreToolBoostSpecSpecArgs',
    'ToolDataStoreToolBoostSpecSpecArgsDict',
    'ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs',
    'ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgsDict',
    'ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs',
    'ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgsDict',
    'ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs',
    'ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgsDict',
    'ToolDataStoreToolEngineSourceArgs',
    'ToolDataStoreToolEngineSourceArgsDict',
    'ToolDataStoreToolEngineSourceDataStoreSourceArgs',
    'ToolDataStoreToolEngineSourceDataStoreSourceArgsDict',
    'ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs',
    'ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgsDict',
    'ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs',
    'ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgsDict',
    'ToolDataStoreToolModalityConfigArgs',
    'ToolDataStoreToolModalityConfigArgsDict',
    'ToolDataStoreToolModalityConfigGroundingConfigArgs',
    'ToolDataStoreToolModalityConfigGroundingConfigArgsDict',
    'ToolDataStoreToolModalityConfigRewriterConfigArgs',
    'ToolDataStoreToolModalityConfigRewriterConfigArgsDict',
    'ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgs',
    'ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgsDict',
    'ToolDataStoreToolModalityConfigSummarizationConfigArgs',
    'ToolDataStoreToolModalityConfigSummarizationConfigArgsDict',
    'ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgs',
    'ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgsDict',
    'ToolGoogleSearchToolArgs',
    'ToolGoogleSearchToolArgsDict',
    'ToolOpenApiToolArgs',
    'ToolOpenApiToolArgsDict',
    'ToolOpenApiToolApiAuthenticationArgs',
    'ToolOpenApiToolApiAuthenticationArgsDict',
    'ToolOpenApiToolApiAuthenticationApiKeyConfigArgs',
    'ToolOpenApiToolApiAuthenticationApiKeyConfigArgsDict',
    'ToolOpenApiToolApiAuthenticationBearerTokenConfigArgs',
    'ToolOpenApiToolApiAuthenticationBearerTokenConfigArgsDict',
    'ToolOpenApiToolApiAuthenticationOauthConfigArgs',
    'ToolOpenApiToolApiAuthenticationOauthConfigArgsDict',
    'ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs',
    'ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgsDict',
    'ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs',
    'ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict',
    'ToolOpenApiToolServiceDirectoryConfigArgs',
    'ToolOpenApiToolServiceDirectoryConfigArgsDict',
    'ToolOpenApiToolTlsConfigArgs',
    'ToolOpenApiToolTlsConfigArgsDict',
    'ToolOpenApiToolTlsConfigCaCertArgs',
    'ToolOpenApiToolTlsConfigCaCertArgsDict',
    'ToolPythonFunctionArgs',
    'ToolPythonFunctionArgsDict',
    'ToolSystemToolArgs',
    'ToolSystemToolArgsDict',
    'ToolsetOpenApiToolsetArgs',
    'ToolsetOpenApiToolsetArgsDict',
    'ToolsetOpenApiToolsetApiAuthenticationArgs',
    'ToolsetOpenApiToolsetApiAuthenticationArgsDict',
    'ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs',
    'ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgsDict',
    'ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs',
    'ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgsDict',
    'ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs',
    'ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgsDict',
    'ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs',
    'ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgsDict',
    'ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs',
    'ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict',
    'ToolsetOpenApiToolsetServiceDirectoryConfigArgs',
    'ToolsetOpenApiToolsetServiceDirectoryConfigArgsDict',
    'ToolsetOpenApiToolsetTlsConfigArgs',
    'ToolsetOpenApiToolsetTlsConfigArgsDict',
    'ToolsetOpenApiToolsetTlsConfigCaCertArgs',
    'ToolsetOpenApiToolsetTlsConfigCaCertArgsDict',
]

MYPY = False

if not MYPY:
    class AgentAfterAgentCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    AgentAfterAgentCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAfterAgentCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AgentAfterModelCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    AgentAfterModelCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAfterModelCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AgentAfterToolCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    AgentAfterToolCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAfterToolCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AgentBeforeAgentCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    AgentBeforeAgentCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentBeforeAgentCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AgentBeforeModelCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    AgentBeforeModelCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentBeforeModelCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AgentBeforeToolCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    AgentBeforeToolCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentBeforeToolCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AgentLlmAgentArgsDict(TypedDict):
        pass
elif False:
    AgentLlmAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentLlmAgentArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AgentModelSettingsArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
elif False:
    AgentModelSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentModelSettingsArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] model: The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param pulumi.Input[_builtins.float] temperature: If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)


if not MYPY:
    class AgentRemoteDialogflowAgentArgsDict(TypedDict):
        agent: pulumi.Input[_builtins.str]
        """
        The
        [Dialogflow](https://cloud.google.com/dialogflow/cx/docs/concept/console-conversational-agents
        agent resource name.
        Format: `projects/{project}/locations/{location}/agents/{agent}`
        """
        flow_id: pulumi.Input[_builtins.str]
        """
        The flow ID of the flow in the Dialogflow agent.
        """
        environment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The environment ID of the Dialogflow agent be used for the agent
        execution. If not specified, the draft environment will be used.
        """
        input_variable_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The mapping of the app variables names to the Dialogflow session
        parameters names to be sent to the Dialogflow agent as input.
        """
        output_variable_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The mapping of the Dialogflow session parameters names to the app
        variables names to be sent back to the CES agent after the Dialogflow
        agent execution ends.
        """
elif False:
    AgentRemoteDialogflowAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentRemoteDialogflowAgentArgs:
    def __init__(__self__, *,
                 agent: pulumi.Input[_builtins.str],
                 flow_id: pulumi.Input[_builtins.str],
                 environment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 input_variable_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 output_variable_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] agent: The
               [Dialogflow](https://cloud.google.com/dialogflow/cx/docs/concept/console-conversational-agents
               agent resource name.
               Format: `projects/{project}/locations/{location}/agents/{agent}`
        :param pulumi.Input[_builtins.str] flow_id: The flow ID of the flow in the Dialogflow agent.
        :param pulumi.Input[_builtins.str] environment_id: The environment ID of the Dialogflow agent be used for the agent
               execution. If not specified, the draft environment will be used.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] input_variable_mapping: The mapping of the app variables names to the Dialogflow session
               parameters names to be sent to the Dialogflow agent as input.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] output_variable_mapping: The mapping of the Dialogflow session parameters names to the app
               variables names to be sent back to the CES agent after the Dialogflow
               agent execution ends.
        """
        pulumi.set(__self__, "agent", agent)
        pulumi.set(__self__, "flow_id", flow_id)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)
        if input_variable_mapping is not None:
            pulumi.set(__self__, "input_variable_mapping", input_variable_mapping)
        if output_variable_mapping is not None:
            pulumi.set(__self__, "output_variable_mapping", output_variable_mapping)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> pulumi.Input[_builtins.str]:
        """
        The
        [Dialogflow](https://cloud.google.com/dialogflow/cx/docs/concept/console-conversational-agents
        agent resource name.
        Format: `projects/{project}/locations/{location}/agents/{agent}`
        """
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agent", value)

    @_builtins.property
    @pulumi.getter(name="flowId")
    def flow_id(self) -> pulumi.Input[_builtins.str]:
        """
        The flow ID of the flow in the Dialogflow agent.
        """
        return pulumi.get(self, "flow_id")

    @flow_id.setter
    def flow_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flow_id", value)

    @_builtins.property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The environment ID of the Dialogflow agent be used for the agent
        execution. If not specified, the draft environment will be used.
        """
        return pulumi.get(self, "environment_id")

    @environment_id.setter
    def environment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment_id", value)

    @_builtins.property
    @pulumi.getter(name="inputVariableMapping")
    def input_variable_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The mapping of the app variables names to the Dialogflow session
        parameters names to be sent to the Dialogflow agent as input.
        """
        return pulumi.get(self, "input_variable_mapping")

    @input_variable_mapping.setter
    def input_variable_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "input_variable_mapping", value)

    @_builtins.property
    @pulumi.getter(name="outputVariableMapping")
    def output_variable_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The mapping of the Dialogflow session parameters names to the app
        variables names to be sent back to the CES agent after the Dialogflow
        agent execution ends.
        """
        return pulumi.get(self, "output_variable_mapping")

    @output_variable_mapping.setter
    def output_variable_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "output_variable_mapping", value)


if not MYPY:
    class AgentToolsetArgsDict(TypedDict):
        toolset: pulumi.Input[_builtins.str]
        """
        The resource name of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        tool_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The tools IDs to filter the toolset.
        """
elif False:
    AgentToolsetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentToolsetArgs:
    def __init__(__self__, *,
                 toolset: pulumi.Input[_builtins.str],
                 tool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] toolset: The resource name of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tool_ids: The tools IDs to filter the toolset.
        """
        pulumi.set(__self__, "toolset", toolset)
        if tool_ids is not None:
            pulumi.set(__self__, "tool_ids", tool_ids)

    @_builtins.property
    @pulumi.getter
    def toolset(self) -> pulumi.Input[_builtins.str]:
        """
        The resource name of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "toolset")

    @toolset.setter
    def toolset(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "toolset", value)

    @_builtins.property
    @pulumi.getter(name="toolIds")
    def tool_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The tools IDs to filter the toolset.
        """
        return pulumi.get(self, "tool_ids")

    @tool_ids.setter
    def tool_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tool_ids", value)


if not MYPY:
    class AppAudioProcessingConfigArgsDict(TypedDict):
        ambient_sound_config: NotRequired[pulumi.Input['AppAudioProcessingConfigAmbientSoundConfigArgsDict']]
        """
        Configuration for the ambient sound to be played with the synthesized agent
        response, to enhance the naturalness of the conversation.
        Structure is documented below.
        """
        barge_in_config: NotRequired[pulumi.Input['AppAudioProcessingConfigBargeInConfigArgsDict']]
        """
        Configuration for how the user barge-in activities should be handled.
        Structure is documented below.
        """
        inactivity_timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        The duration of user inactivity (no speech or interaction) before the agent
        prompts the user for reengagement. If not set, the agent will not prompt
        the user for reengagement.
        """
        synthesize_speech_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppAudioProcessingConfigSynthesizeSpeechConfigArgsDict']]]]
        """
        Configuration of how the agent response should be synthesized, mapping from
        the language code to SynthesizeSpeechConfig.
        If the configuration for the specified language code is not found, the
        configuration for the root language code will be used. For example, if the
        map contains "en-us" and "en", and the specified language code is "en-gb",
        then "en" configuration will be used.
        Note: Language code is case-insensitive.
        Structure is documented below.
        """
elif False:
    AppAudioProcessingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppAudioProcessingConfigArgs:
    def __init__(__self__, *,
                 ambient_sound_config: Optional[pulumi.Input['AppAudioProcessingConfigAmbientSoundConfigArgs']] = None,
                 barge_in_config: Optional[pulumi.Input['AppAudioProcessingConfigBargeInConfigArgs']] = None,
                 inactivity_timeout: Optional[pulumi.Input[_builtins.str]] = None,
                 synthesize_speech_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppAudioProcessingConfigSynthesizeSpeechConfigArgs']]]] = None):
        """
        :param pulumi.Input['AppAudioProcessingConfigAmbientSoundConfigArgs'] ambient_sound_config: Configuration for the ambient sound to be played with the synthesized agent
               response, to enhance the naturalness of the conversation.
               Structure is documented below.
        :param pulumi.Input['AppAudioProcessingConfigBargeInConfigArgs'] barge_in_config: Configuration for how the user barge-in activities should be handled.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] inactivity_timeout: The duration of user inactivity (no speech or interaction) before the agent
               prompts the user for reengagement. If not set, the agent will not prompt
               the user for reengagement.
        :param pulumi.Input[Sequence[pulumi.Input['AppAudioProcessingConfigSynthesizeSpeechConfigArgs']]] synthesize_speech_configs: Configuration of how the agent response should be synthesized, mapping from
               the language code to SynthesizeSpeechConfig.
               If the configuration for the specified language code is not found, the
               configuration for the root language code will be used. For example, if the
               map contains "en-us" and "en", and the specified language code is "en-gb",
               then "en" configuration will be used.
               Note: Language code is case-insensitive.
               Structure is documented below.
        """
        if ambient_sound_config is not None:
            pulumi.set(__self__, "ambient_sound_config", ambient_sound_config)
        if barge_in_config is not None:
            pulumi.set(__self__, "barge_in_config", barge_in_config)
        if inactivity_timeout is not None:
            pulumi.set(__self__, "inactivity_timeout", inactivity_timeout)
        if synthesize_speech_configs is not None:
            pulumi.set(__self__, "synthesize_speech_configs", synthesize_speech_configs)

    @_builtins.property
    @pulumi.getter(name="ambientSoundConfig")
    def ambient_sound_config(self) -> Optional[pulumi.Input['AppAudioProcessingConfigAmbientSoundConfigArgs']]:
        """
        Configuration for the ambient sound to be played with the synthesized agent
        response, to enhance the naturalness of the conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "ambient_sound_config")

    @ambient_sound_config.setter
    def ambient_sound_config(self, value: Optional[pulumi.Input['AppAudioProcessingConfigAmbientSoundConfigArgs']]):
        pulumi.set(self, "ambient_sound_config", value)

    @_builtins.property
    @pulumi.getter(name="bargeInConfig")
    def barge_in_config(self) -> Optional[pulumi.Input['AppAudioProcessingConfigBargeInConfigArgs']]:
        """
        Configuration for how the user barge-in activities should be handled.
        Structure is documented below.
        """
        return pulumi.get(self, "barge_in_config")

    @barge_in_config.setter
    def barge_in_config(self, value: Optional[pulumi.Input['AppAudioProcessingConfigBargeInConfigArgs']]):
        pulumi.set(self, "barge_in_config", value)

    @_builtins.property
    @pulumi.getter(name="inactivityTimeout")
    def inactivity_timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The duration of user inactivity (no speech or interaction) before the agent
        prompts the user for reengagement. If not set, the agent will not prompt
        the user for reengagement.
        """
        return pulumi.get(self, "inactivity_timeout")

    @inactivity_timeout.setter
    def inactivity_timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inactivity_timeout", value)

    @_builtins.property
    @pulumi.getter(name="synthesizeSpeechConfigs")
    def synthesize_speech_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppAudioProcessingConfigSynthesizeSpeechConfigArgs']]]]:
        """
        Configuration of how the agent response should be synthesized, mapping from
        the language code to SynthesizeSpeechConfig.
        If the configuration for the specified language code is not found, the
        configuration for the root language code will be used. For example, if the
        map contains "en-us" and "en", and the specified language code is "en-gb",
        then "en" configuration will be used.
        Note: Language code is case-insensitive.
        Structure is documented below.
        """
        return pulumi.get(self, "synthesize_speech_configs")

    @synthesize_speech_configs.setter
    def synthesize_speech_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppAudioProcessingConfigSynthesizeSpeechConfigArgs']]]]):
        pulumi.set(self, "synthesize_speech_configs", value)


if not MYPY:
    class AppAudioProcessingConfigAmbientSoundConfigArgsDict(TypedDict):
        gcs_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ambient noise as a mono-channel, 16kHz WAV file stored in [Cloud
        Storage](https://cloud.google.com/storage).
        Note: Please make sure the CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com` has
        `storage.objects.get` permission to the Cloud Storage object.
        """
        prebuilt_ambient_sound: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the prebuilt ambient sound.
        Valid values are: - "coffee_shop" - "keyboard" - "keypad" - "hum"
        -"office_1" - "office_2" - "office_3"
        -"room_1" - "room_2" - "room_3"
        -"room_4" - "room_5" - "air_conditioner"
        """
        volume_gain_db: NotRequired[pulumi.Input[_builtins.float]]
        """
        Volume gain (in dB) of the normal native volume supported by
        ambient noise, in the range [-96.0, 16.0]. If unset, or set to a value of
        0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
        will play at approximately half the amplitude of the normal native signal
        amplitude. A value of +6.0 (dB) will play at approximately twice the
        amplitude of the normal native signal amplitude. We strongly recommend not
        to exceed +10 (dB) as there's usually no effective increase in loudness for
        any value greater than that.
        """
elif False:
    AppAudioProcessingConfigAmbientSoundConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppAudioProcessingConfigAmbientSoundConfigArgs:
    def __init__(__self__, *,
                 gcs_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 prebuilt_ambient_sound: Optional[pulumi.Input[_builtins.str]] = None,
                 volume_gain_db: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] gcs_uri: Ambient noise as a mono-channel, 16kHz WAV file stored in [Cloud
               Storage](https://cloud.google.com/storage).
               Note: Please make sure the CES service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com` has
               `storage.objects.get` permission to the Cloud Storage object.
        :param pulumi.Input[_builtins.str] prebuilt_ambient_sound: Name of the prebuilt ambient sound.
               Valid values are: - "coffee_shop" - "keyboard" - "keypad" - "hum"
               -"office_1" - "office_2" - "office_3"
               -"room_1" - "room_2" - "room_3"
               -"room_4" - "room_5" - "air_conditioner"
        :param pulumi.Input[_builtins.float] volume_gain_db: Volume gain (in dB) of the normal native volume supported by
               ambient noise, in the range [-96.0, 16.0]. If unset, or set to a value of
               0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
               will play at approximately half the amplitude of the normal native signal
               amplitude. A value of +6.0 (dB) will play at approximately twice the
               amplitude of the normal native signal amplitude. We strongly recommend not
               to exceed +10 (dB) as there's usually no effective increase in loudness for
               any value greater than that.
        """
        if gcs_uri is not None:
            pulumi.set(__self__, "gcs_uri", gcs_uri)
        if prebuilt_ambient_sound is not None:
            pulumi.set(__self__, "prebuilt_ambient_sound", prebuilt_ambient_sound)
        if volume_gain_db is not None:
            pulumi.set(__self__, "volume_gain_db", volume_gain_db)

    @_builtins.property
    @pulumi.getter(name="gcsUri")
    def gcs_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ambient noise as a mono-channel, 16kHz WAV file stored in [Cloud
        Storage](https://cloud.google.com/storage).
        Note: Please make sure the CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com` has
        `storage.objects.get` permission to the Cloud Storage object.
        """
        return pulumi.get(self, "gcs_uri")

    @gcs_uri.setter
    def gcs_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gcs_uri", value)

    @_builtins.property
    @pulumi.getter(name="prebuiltAmbientSound")
    def prebuilt_ambient_sound(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the prebuilt ambient sound.
        Valid values are: - "coffee_shop" - "keyboard" - "keypad" - "hum"
        -"office_1" - "office_2" - "office_3"
        -"room_1" - "room_2" - "room_3"
        -"room_4" - "room_5" - "air_conditioner"
        """
        return pulumi.get(self, "prebuilt_ambient_sound")

    @prebuilt_ambient_sound.setter
    def prebuilt_ambient_sound(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prebuilt_ambient_sound", value)

    @_builtins.property
    @pulumi.getter(name="volumeGainDb")
    def volume_gain_db(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Volume gain (in dB) of the normal native volume supported by
        ambient noise, in the range [-96.0, 16.0]. If unset, or set to a value of
        0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
        will play at approximately half the amplitude of the normal native signal
        amplitude. A value of +6.0 (dB) will play at approximately twice the
        amplitude of the normal native signal amplitude. We strongly recommend not
        to exceed +10 (dB) as there's usually no effective increase in loudness for
        any value greater than that.
        """
        return pulumi.get(self, "volume_gain_db")

    @volume_gain_db.setter
    def volume_gain_db(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "volume_gain_db", value)


if not MYPY:
    class AppAudioProcessingConfigBargeInConfigArgsDict(TypedDict):
        barge_in_awareness: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If enabled, the agent will adapt its next response based on the assumption
        that the user hasn't heard the full preceding agent message.
        This should not be used in scenarios where agent responses are displayed
        visually.
        """
elif False:
    AppAudioProcessingConfigBargeInConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppAudioProcessingConfigBargeInConfigArgs:
    def __init__(__self__, *,
                 barge_in_awareness: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] barge_in_awareness: If enabled, the agent will adapt its next response based on the assumption
               that the user hasn't heard the full preceding agent message.
               This should not be used in scenarios where agent responses are displayed
               visually.
        """
        if barge_in_awareness is not None:
            pulumi.set(__self__, "barge_in_awareness", barge_in_awareness)

    @_builtins.property
    @pulumi.getter(name="bargeInAwareness")
    def barge_in_awareness(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If enabled, the agent will adapt its next response based on the assumption
        that the user hasn't heard the full preceding agent message.
        This should not be used in scenarios where agent responses are displayed
        visually.
        """
        return pulumi.get(self, "barge_in_awareness")

    @barge_in_awareness.setter
    def barge_in_awareness(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "barge_in_awareness", value)


if not MYPY:
    class AppAudioProcessingConfigSynthesizeSpeechConfigArgsDict(TypedDict):
        language_code: pulumi.Input[_builtins.str]
        """
        The identifier for this object. Format specified above.
        """
        speaking_rate: NotRequired[pulumi.Input[_builtins.float]]
        """
        The speaking rate/speed in the range [0.25, 2.0]. 1.0 is the normal native
        speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is
        half as fast. Values outside of the range [0.25, 2.0] will return an error.
        """
        voice: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the voice. If not set, the service will choose a
        voice based on the other parameters such as language_code.
        For the list of available voices, please refer to Supported voices and
        languages from Cloud Text-to-Speech.
        """
elif False:
    AppAudioProcessingConfigSynthesizeSpeechConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppAudioProcessingConfigSynthesizeSpeechConfigArgs:
    def __init__(__self__, *,
                 language_code: pulumi.Input[_builtins.str],
                 speaking_rate: Optional[pulumi.Input[_builtins.float]] = None,
                 voice: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] language_code: The identifier for this object. Format specified above.
        :param pulumi.Input[_builtins.float] speaking_rate: The speaking rate/speed in the range [0.25, 2.0]. 1.0 is the normal native
               speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is
               half as fast. Values outside of the range [0.25, 2.0] will return an error.
        :param pulumi.Input[_builtins.str] voice: The name of the voice. If not set, the service will choose a
               voice based on the other parameters such as language_code.
               For the list of available voices, please refer to Supported voices and
               languages from Cloud Text-to-Speech.
        """
        pulumi.set(__self__, "language_code", language_code)
        if speaking_rate is not None:
            pulumi.set(__self__, "speaking_rate", speaking_rate)
        if voice is not None:
            pulumi.set(__self__, "voice", voice)

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "language_code", value)

    @_builtins.property
    @pulumi.getter(name="speakingRate")
    def speaking_rate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The speaking rate/speed in the range [0.25, 2.0]. 1.0 is the normal native
        speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is
        half as fast. Values outside of the range [0.25, 2.0] will return an error.
        """
        return pulumi.get(self, "speaking_rate")

    @speaking_rate.setter
    def speaking_rate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "speaking_rate", value)

    @_builtins.property
    @pulumi.getter
    def voice(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the voice. If not set, the service will choose a
        voice based on the other parameters such as language_code.
        For the list of available voices, please refer to Supported voices and
        languages from Cloud Text-to-Speech.
        """
        return pulumi.get(self, "voice")

    @voice.setter
    def voice(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "voice", value)


if not MYPY:
    class AppClientCertificateSettingsArgsDict(TypedDict):
        private_key: pulumi.Input[_builtins.str]
        """
        The name of the SecretManager secret version resource
        storing the private key encoded in PEM format.
        Format: projects/{project}/secrets/{secret}/versions/{version}
        """
        tls_certificate: pulumi.Input[_builtins.str]
        """
        The TLS certificate encoded in PEM format.
        This string must include the begin header and end footer lines.
        """
        passphrase: NotRequired[pulumi.Input[_builtins.str]]
        """
        The passphrase to decrypt the private key.
        Should be left unset if the private key is not encrypted.
        """
elif False:
    AppClientCertificateSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppClientCertificateSettingsArgs:
    def __init__(__self__, *,
                 private_key: pulumi.Input[_builtins.str],
                 tls_certificate: pulumi.Input[_builtins.str],
                 passphrase: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] private_key: The name of the SecretManager secret version resource
               storing the private key encoded in PEM format.
               Format: projects/{project}/secrets/{secret}/versions/{version}
        :param pulumi.Input[_builtins.str] tls_certificate: The TLS certificate encoded in PEM format.
               This string must include the begin header and end footer lines.
        :param pulumi.Input[_builtins.str] passphrase: The passphrase to decrypt the private key.
               Should be left unset if the private key is not encrypted.
        """
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "tls_certificate", tls_certificate)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SecretManager secret version resource
        storing the private key encoded in PEM format.
        Format: projects/{project}/secrets/{secret}/versions/{version}
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="tlsCertificate")
    def tls_certificate(self) -> pulumi.Input[_builtins.str]:
        """
        The TLS certificate encoded in PEM format.
        This string must include the begin header and end footer lines.
        """
        return pulumi.get(self, "tls_certificate")

    @tls_certificate.setter
    def tls_certificate(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tls_certificate", value)

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The passphrase to decrypt the private key.
        Should be left unset if the private key is not encrypted.
        """
        return pulumi.get(self, "passphrase")

    @passphrase.setter
    def passphrase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "passphrase", value)


if not MYPY:
    class AppDataStoreSettingsArgsDict(TypedDict):
        engines: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppDataStoreSettingsEngineArgsDict']]]]
        """
        (Output)
        The engines for the app.
        Structure is documented below.


        <a name="nested_data_store_settings_engines"></a>The `engines` block contains:
        """
elif False:
    AppDataStoreSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppDataStoreSettingsArgs:
    def __init__(__self__, *,
                 engines: Optional[pulumi.Input[Sequence[pulumi.Input['AppDataStoreSettingsEngineArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppDataStoreSettingsEngineArgs']]] engines: (Output)
               The engines for the app.
               Structure is documented below.
               
               
               <a name="nested_data_store_settings_engines"></a>The `engines` block contains:
        """
        if engines is not None:
            pulumi.set(__self__, "engines", engines)

    @_builtins.property
    @pulumi.getter
    def engines(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppDataStoreSettingsEngineArgs']]]]:
        """
        (Output)
        The engines for the app.
        Structure is documented below.


        <a name="nested_data_store_settings_engines"></a>The `engines` block contains:
        """
        return pulumi.get(self, "engines")

    @engines.setter
    def engines(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppDataStoreSettingsEngineArgs']]]]):
        pulumi.set(self, "engines", value)


if not MYPY:
    class AppDataStoreSettingsEngineArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier. The unique identifier of the app.
        Format: `projects/{project}/locations/{location}/apps/{app}`
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the engine.
        Possible values:
        ENGINE_TYPE_SEARCH
        ENGINE_TYPE_CHAT
        """
elif False:
    AppDataStoreSettingsEngineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppDataStoreSettingsEngineArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Identifier. The unique identifier of the app.
               Format: `projects/{project}/locations/{location}/apps/{app}`
        :param pulumi.Input[_builtins.str] type: The type of the engine.
               Possible values:
               ENGINE_TYPE_SEARCH
               ENGINE_TYPE_CHAT
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier. The unique identifier of the app.
        Format: `projects/{project}/locations/{location}/apps/{app}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the engine.
        Possible values:
        ENGINE_TYPE_SEARCH
        ENGINE_TYPE_CHAT
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AppDefaultChannelProfileArgsDict(TypedDict):
        channel_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the channel profile.
        Possible values:
        UNKNOWN
        WEB_UI
        API
        TWILIO
        GOOGLE_TELEPHONY_PLATFORM
        CONTACT_CENTER_AS_A_SERVICE
        """
        disable_barge_in_control: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable user barge-in in the conversation.
        - true: User interruptions are disabled while the agent is speaking.
        - false: The agent retains automatic control over when the user can interrupt.
        """
        disable_dtmf: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable DTMF (dual-tone multi-frequency).
        """
        persona_property: NotRequired[pulumi.Input['AppDefaultChannelProfilePersonaPropertyArgsDict']]
        """
        Represents the persona property of a channel.
        Structure is documented below.
        """
        profile_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier of the channel profile.
        """
        web_widget_config: NotRequired[pulumi.Input['AppDefaultChannelProfileWebWidgetConfigArgsDict']]
        """
        Message for configuration for the web widget.
        Structure is documented below.
        """
elif False:
    AppDefaultChannelProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppDefaultChannelProfileArgs:
    def __init__(__self__, *,
                 channel_type: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_barge_in_control: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_dtmf: Optional[pulumi.Input[_builtins.bool]] = None,
                 persona_property: Optional[pulumi.Input['AppDefaultChannelProfilePersonaPropertyArgs']] = None,
                 profile_id: Optional[pulumi.Input[_builtins.str]] = None,
                 web_widget_config: Optional[pulumi.Input['AppDefaultChannelProfileWebWidgetConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] channel_type: The type of the channel profile.
               Possible values:
               UNKNOWN
               WEB_UI
               API
               TWILIO
               GOOGLE_TELEPHONY_PLATFORM
               CONTACT_CENTER_AS_A_SERVICE
        :param pulumi.Input[_builtins.bool] disable_barge_in_control: Whether to disable user barge-in in the conversation.
               - true: User interruptions are disabled while the agent is speaking.
               - false: The agent retains automatic control over when the user can interrupt.
        :param pulumi.Input[_builtins.bool] disable_dtmf: Whether to disable DTMF (dual-tone multi-frequency).
        :param pulumi.Input['AppDefaultChannelProfilePersonaPropertyArgs'] persona_property: Represents the persona property of a channel.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] profile_id: The unique identifier of the channel profile.
        :param pulumi.Input['AppDefaultChannelProfileWebWidgetConfigArgs'] web_widget_config: Message for configuration for the web widget.
               Structure is documented below.
        """
        if channel_type is not None:
            pulumi.set(__self__, "channel_type", channel_type)
        if disable_barge_in_control is not None:
            pulumi.set(__self__, "disable_barge_in_control", disable_barge_in_control)
        if disable_dtmf is not None:
            pulumi.set(__self__, "disable_dtmf", disable_dtmf)
        if persona_property is not None:
            pulumi.set(__self__, "persona_property", persona_property)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if web_widget_config is not None:
            pulumi.set(__self__, "web_widget_config", web_widget_config)

    @_builtins.property
    @pulumi.getter(name="channelType")
    def channel_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the channel profile.
        Possible values:
        UNKNOWN
        WEB_UI
        API
        TWILIO
        GOOGLE_TELEPHONY_PLATFORM
        CONTACT_CENTER_AS_A_SERVICE
        """
        return pulumi.get(self, "channel_type")

    @channel_type.setter
    def channel_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel_type", value)

    @_builtins.property
    @pulumi.getter(name="disableBargeInControl")
    def disable_barge_in_control(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable user barge-in in the conversation.
        - true: User interruptions are disabled while the agent is speaking.
        - false: The agent retains automatic control over when the user can interrupt.
        """
        return pulumi.get(self, "disable_barge_in_control")

    @disable_barge_in_control.setter
    def disable_barge_in_control(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_barge_in_control", value)

    @_builtins.property
    @pulumi.getter(name="disableDtmf")
    def disable_dtmf(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable DTMF (dual-tone multi-frequency).
        """
        return pulumi.get(self, "disable_dtmf")

    @disable_dtmf.setter
    def disable_dtmf(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_dtmf", value)

    @_builtins.property
    @pulumi.getter(name="personaProperty")
    def persona_property(self) -> Optional[pulumi.Input['AppDefaultChannelProfilePersonaPropertyArgs']]:
        """
        Represents the persona property of a channel.
        Structure is documented below.
        """
        return pulumi.get(self, "persona_property")

    @persona_property.setter
    def persona_property(self, value: Optional[pulumi.Input['AppDefaultChannelProfilePersonaPropertyArgs']]):
        pulumi.set(self, "persona_property", value)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier of the channel profile.
        """
        return pulumi.get(self, "profile_id")

    @profile_id.setter
    def profile_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile_id", value)

    @_builtins.property
    @pulumi.getter(name="webWidgetConfig")
    def web_widget_config(self) -> Optional[pulumi.Input['AppDefaultChannelProfileWebWidgetConfigArgs']]:
        """
        Message for configuration for the web widget.
        Structure is documented below.
        """
        return pulumi.get(self, "web_widget_config")

    @web_widget_config.setter
    def web_widget_config(self, value: Optional[pulumi.Input['AppDefaultChannelProfileWebWidgetConfigArgs']]):
        pulumi.set(self, "web_widget_config", value)


if not MYPY:
    class AppDefaultChannelProfilePersonaPropertyArgsDict(TypedDict):
        persona: NotRequired[pulumi.Input[_builtins.str]]
        """
        The persona of the channel.
        Possible values:
        UNKNOWN
        CONCISE
        CHATTY
        """
elif False:
    AppDefaultChannelProfilePersonaPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppDefaultChannelProfilePersonaPropertyArgs:
    def __init__(__self__, *,
                 persona: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] persona: The persona of the channel.
               Possible values:
               UNKNOWN
               CONCISE
               CHATTY
        """
        if persona is not None:
            pulumi.set(__self__, "persona", persona)

    @_builtins.property
    @pulumi.getter
    def persona(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The persona of the channel.
        Possible values:
        UNKNOWN
        CONCISE
        CHATTY
        """
        return pulumi.get(self, "persona")

    @persona.setter
    def persona(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "persona", value)


if not MYPY:
    class AppDefaultChannelProfileWebWidgetConfigArgsDict(TypedDict):
        modality: NotRequired[pulumi.Input[_builtins.str]]
        """
        The modality of the web widget.
        Possible values:
        UNKNOWN_MODALITY
        CHAT_AND_VOICE
        VOICE_ONLY
        CHAT_ONLY
        """
        theme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The theme of the web widget.
        Possible values:
        UNKNOWN_THEME
        LIGHT
        DARK
        """
        web_widget_title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The title of the web widget.
        """
elif False:
    AppDefaultChannelProfileWebWidgetConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppDefaultChannelProfileWebWidgetConfigArgs:
    def __init__(__self__, *,
                 modality: Optional[pulumi.Input[_builtins.str]] = None,
                 theme: Optional[pulumi.Input[_builtins.str]] = None,
                 web_widget_title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] modality: The modality of the web widget.
               Possible values:
               UNKNOWN_MODALITY
               CHAT_AND_VOICE
               VOICE_ONLY
               CHAT_ONLY
        :param pulumi.Input[_builtins.str] theme: The theme of the web widget.
               Possible values:
               UNKNOWN_THEME
               LIGHT
               DARK
        :param pulumi.Input[_builtins.str] web_widget_title: The title of the web widget.
        """
        if modality is not None:
            pulumi.set(__self__, "modality", modality)
        if theme is not None:
            pulumi.set(__self__, "theme", theme)
        if web_widget_title is not None:
            pulumi.set(__self__, "web_widget_title", web_widget_title)

    @_builtins.property
    @pulumi.getter
    def modality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The modality of the web widget.
        Possible values:
        UNKNOWN_MODALITY
        CHAT_AND_VOICE
        VOICE_ONLY
        CHAT_ONLY
        """
        return pulumi.get(self, "modality")

    @modality.setter
    def modality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "modality", value)

    @_builtins.property
    @pulumi.getter
    def theme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The theme of the web widget.
        Possible values:
        UNKNOWN_THEME
        LIGHT
        DARK
        """
        return pulumi.get(self, "theme")

    @theme.setter
    def theme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "theme", value)

    @_builtins.property
    @pulumi.getter(name="webWidgetTitle")
    def web_widget_title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The title of the web widget.
        """
        return pulumi.get(self, "web_widget_title")

    @web_widget_title.setter
    def web_widget_title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_widget_title", value)


if not MYPY:
    class AppEvaluationMetricsThresholdsArgsDict(TypedDict):
        golden_evaluation_metrics_thresholds: NotRequired[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgsDict']]
        """
        Settings for golden evaluations.
        Structure is documented below.
        """
elif False:
    AppEvaluationMetricsThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppEvaluationMetricsThresholdsArgs:
    def __init__(__self__, *,
                 golden_evaluation_metrics_thresholds: Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgs']] = None):
        """
        :param pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgs'] golden_evaluation_metrics_thresholds: Settings for golden evaluations.
               Structure is documented below.
        """
        if golden_evaluation_metrics_thresholds is not None:
            pulumi.set(__self__, "golden_evaluation_metrics_thresholds", golden_evaluation_metrics_thresholds)

    @_builtins.property
    @pulumi.getter(name="goldenEvaluationMetricsThresholds")
    def golden_evaluation_metrics_thresholds(self) -> Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgs']]:
        """
        Settings for golden evaluations.
        Structure is documented below.
        """
        return pulumi.get(self, "golden_evaluation_metrics_thresholds")

    @golden_evaluation_metrics_thresholds.setter
    def golden_evaluation_metrics_thresholds(self, value: Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgs']]):
        pulumi.set(self, "golden_evaluation_metrics_thresholds", value)


if not MYPY:
    class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgsDict(TypedDict):
        expectation_level_metrics_thresholds: NotRequired[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgsDict']]
        """
        Expectation level metrics thresholds.
        Structure is documented below.
        """
        turn_level_metrics_thresholds: NotRequired[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgsDict']]
        """
        Turn level metrics thresholds.
        Structure is documented below.
        """
elif False:
    AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgs:
    def __init__(__self__, *,
                 expectation_level_metrics_thresholds: Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgs']] = None,
                 turn_level_metrics_thresholds: Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgs']] = None):
        """
        :param pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgs'] expectation_level_metrics_thresholds: Expectation level metrics thresholds.
               Structure is documented below.
        :param pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgs'] turn_level_metrics_thresholds: Turn level metrics thresholds.
               Structure is documented below.
        """
        if expectation_level_metrics_thresholds is not None:
            pulumi.set(__self__, "expectation_level_metrics_thresholds", expectation_level_metrics_thresholds)
        if turn_level_metrics_thresholds is not None:
            pulumi.set(__self__, "turn_level_metrics_thresholds", turn_level_metrics_thresholds)

    @_builtins.property
    @pulumi.getter(name="expectationLevelMetricsThresholds")
    def expectation_level_metrics_thresholds(self) -> Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgs']]:
        """
        Expectation level metrics thresholds.
        Structure is documented below.
        """
        return pulumi.get(self, "expectation_level_metrics_thresholds")

    @expectation_level_metrics_thresholds.setter
    def expectation_level_metrics_thresholds(self, value: Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgs']]):
        pulumi.set(self, "expectation_level_metrics_thresholds", value)

    @_builtins.property
    @pulumi.getter(name="turnLevelMetricsThresholds")
    def turn_level_metrics_thresholds(self) -> Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgs']]:
        """
        Turn level metrics thresholds.
        Structure is documented below.
        """
        return pulumi.get(self, "turn_level_metrics_thresholds")

    @turn_level_metrics_thresholds.setter
    def turn_level_metrics_thresholds(self, value: Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgs']]):
        pulumi.set(self, "turn_level_metrics_thresholds", value)


if not MYPY:
    class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgsDict(TypedDict):
        tool_invocation_parameter_correctness_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        The success threshold for individual tool invocation parameter
        correctness. Must be a float between 0 and 1. Default is 1.0.
        """
elif False:
    AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgs:
    def __init__(__self__, *,
                 tool_invocation_parameter_correctness_threshold: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] tool_invocation_parameter_correctness_threshold: The success threshold for individual tool invocation parameter
               correctness. Must be a float between 0 and 1. Default is 1.0.
        """
        if tool_invocation_parameter_correctness_threshold is not None:
            pulumi.set(__self__, "tool_invocation_parameter_correctness_threshold", tool_invocation_parameter_correctness_threshold)

    @_builtins.property
    @pulumi.getter(name="toolInvocationParameterCorrectnessThreshold")
    def tool_invocation_parameter_correctness_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The success threshold for individual tool invocation parameter
        correctness. Must be a float between 0 and 1. Default is 1.0.
        """
        return pulumi.get(self, "tool_invocation_parameter_correctness_threshold")

    @tool_invocation_parameter_correctness_threshold.setter
    def tool_invocation_parameter_correctness_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "tool_invocation_parameter_correctness_threshold", value)


if not MYPY:
    class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgsDict(TypedDict):
        overall_tool_invocation_correctness_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        The success threshold for overall tool invocation correctness. Must be
        a float between 0 and 1. Default is 1.0.
        """
        semantic_similarity_success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The success threshold for semantic similarity. Must be an integer
        between 0 and 4. Default is >= 3.
        """
elif False:
    AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgs:
    def __init__(__self__, *,
                 overall_tool_invocation_correctness_threshold: Optional[pulumi.Input[_builtins.float]] = None,
                 semantic_similarity_success_threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.float] overall_tool_invocation_correctness_threshold: The success threshold for overall tool invocation correctness. Must be
               a float between 0 and 1. Default is 1.0.
        :param pulumi.Input[_builtins.int] semantic_similarity_success_threshold: The success threshold for semantic similarity. Must be an integer
               between 0 and 4. Default is >= 3.
        """
        if overall_tool_invocation_correctness_threshold is not None:
            pulumi.set(__self__, "overall_tool_invocation_correctness_threshold", overall_tool_invocation_correctness_threshold)
        if semantic_similarity_success_threshold is not None:
            pulumi.set(__self__, "semantic_similarity_success_threshold", semantic_similarity_success_threshold)

    @_builtins.property
    @pulumi.getter(name="overallToolInvocationCorrectnessThreshold")
    def overall_tool_invocation_correctness_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The success threshold for overall tool invocation correctness. Must be
        a float between 0 and 1. Default is 1.0.
        """
        return pulumi.get(self, "overall_tool_invocation_correctness_threshold")

    @overall_tool_invocation_correctness_threshold.setter
    def overall_tool_invocation_correctness_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "overall_tool_invocation_correctness_threshold", value)

    @_builtins.property
    @pulumi.getter(name="semanticSimilaritySuccessThreshold")
    def semantic_similarity_success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The success threshold for semantic similarity. Must be an integer
        between 0 and 4. Default is >= 3.
        """
        return pulumi.get(self, "semantic_similarity_success_threshold")

    @semantic_similarity_success_threshold.setter
    def semantic_similarity_success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "semantic_similarity_success_threshold", value)


if not MYPY:
    class AppLanguageSettingsArgsDict(TypedDict):
        default_language_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default language code of the app.
        """
        enable_multilingual_support: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables multilingual support. If true, agents in the app will use pre-built
        instructions to improve handling of multilingual input.
        """
        fallback_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        The action to perform when an agent receives input in an unsupported
        language.
        This can be a predefined action or a custom tool call.
        Valid values are:
        - A tool's full resource name, which triggers a specific tool execution.
        - A predefined system action, such as "escalate" or "exit", which triggers
        an EndSession signal with corresponding metadata
        to terminate the conversation.
        """
        supported_language_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of languages codes supported by the app, in addition to the
        `default_language_code`.
        """
elif False:
    AppLanguageSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLanguageSettingsArgs:
    def __init__(__self__, *,
                 default_language_code: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_multilingual_support: Optional[pulumi.Input[_builtins.bool]] = None,
                 fallback_action: Optional[pulumi.Input[_builtins.str]] = None,
                 supported_language_codes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] default_language_code: The default language code of the app.
        :param pulumi.Input[_builtins.bool] enable_multilingual_support: Enables multilingual support. If true, agents in the app will use pre-built
               instructions to improve handling of multilingual input.
        :param pulumi.Input[_builtins.str] fallback_action: The action to perform when an agent receives input in an unsupported
               language.
               This can be a predefined action or a custom tool call.
               Valid values are:
               - A tool's full resource name, which triggers a specific tool execution.
               - A predefined system action, such as "escalate" or "exit", which triggers
               an EndSession signal with corresponding metadata
               to terminate the conversation.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] supported_language_codes: List of languages codes supported by the app, in addition to the
               `default_language_code`.
        """
        if default_language_code is not None:
            pulumi.set(__self__, "default_language_code", default_language_code)
        if enable_multilingual_support is not None:
            pulumi.set(__self__, "enable_multilingual_support", enable_multilingual_support)
        if fallback_action is not None:
            pulumi.set(__self__, "fallback_action", fallback_action)
        if supported_language_codes is not None:
            pulumi.set(__self__, "supported_language_codes", supported_language_codes)

    @_builtins.property
    @pulumi.getter(name="defaultLanguageCode")
    def default_language_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default language code of the app.
        """
        return pulumi.get(self, "default_language_code")

    @default_language_code.setter
    def default_language_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_language_code", value)

    @_builtins.property
    @pulumi.getter(name="enableMultilingualSupport")
    def enable_multilingual_support(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables multilingual support. If true, agents in the app will use pre-built
        instructions to improve handling of multilingual input.
        """
        return pulumi.get(self, "enable_multilingual_support")

    @enable_multilingual_support.setter
    def enable_multilingual_support(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_multilingual_support", value)

    @_builtins.property
    @pulumi.getter(name="fallbackAction")
    def fallback_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The action to perform when an agent receives input in an unsupported
        language.
        This can be a predefined action or a custom tool call.
        Valid values are:
        - A tool's full resource name, which triggers a specific tool execution.
        - A predefined system action, such as "escalate" or "exit", which triggers
        an EndSession signal with corresponding metadata
        to terminate the conversation.
        """
        return pulumi.get(self, "fallback_action")

    @fallback_action.setter
    def fallback_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_action", value)

    @_builtins.property
    @pulumi.getter(name="supportedLanguageCodes")
    def supported_language_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of languages codes supported by the app, in addition to the
        `default_language_code`.
        """
        return pulumi.get(self, "supported_language_codes")

    @supported_language_codes.setter
    def supported_language_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "supported_language_codes", value)


if not MYPY:
    class AppLoggingSettingsArgsDict(TypedDict):
        audio_recording_config: NotRequired[pulumi.Input['AppLoggingSettingsAudioRecordingConfigArgsDict']]
        """
        Configuration for how the audio interactions should be recorded.
        Structure is documented below.
        """
        bigquery_export_settings: NotRequired[pulumi.Input['AppLoggingSettingsBigqueryExportSettingsArgsDict']]
        """
        Settings to describe the BigQuery export behaviors for the app.
        Structure is documented below.
        """
        cloud_logging_settings: NotRequired[pulumi.Input['AppLoggingSettingsCloudLoggingSettingsArgsDict']]
        """
        Settings to describe the Cloud Logging behaviors for the app.
        Structure is documented below.
        """
        conversation_logging_settings: NotRequired[pulumi.Input['AppLoggingSettingsConversationLoggingSettingsArgsDict']]
        """
        Settings to describe the conversation logging behaviors for the app.
        Structure is documented below.
        """
        redaction_config: NotRequired[pulumi.Input['AppLoggingSettingsRedactionConfigArgsDict']]
        """
        Configuration to instruct how sensitive data should be handled.
        Structure is documented below.
        """
elif False:
    AppLoggingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLoggingSettingsArgs:
    def __init__(__self__, *,
                 audio_recording_config: Optional[pulumi.Input['AppLoggingSettingsAudioRecordingConfigArgs']] = None,
                 bigquery_export_settings: Optional[pulumi.Input['AppLoggingSettingsBigqueryExportSettingsArgs']] = None,
                 cloud_logging_settings: Optional[pulumi.Input['AppLoggingSettingsCloudLoggingSettingsArgs']] = None,
                 conversation_logging_settings: Optional[pulumi.Input['AppLoggingSettingsConversationLoggingSettingsArgs']] = None,
                 redaction_config: Optional[pulumi.Input['AppLoggingSettingsRedactionConfigArgs']] = None):
        """
        :param pulumi.Input['AppLoggingSettingsAudioRecordingConfigArgs'] audio_recording_config: Configuration for how the audio interactions should be recorded.
               Structure is documented below.
        :param pulumi.Input['AppLoggingSettingsBigqueryExportSettingsArgs'] bigquery_export_settings: Settings to describe the BigQuery export behaviors for the app.
               Structure is documented below.
        :param pulumi.Input['AppLoggingSettingsCloudLoggingSettingsArgs'] cloud_logging_settings: Settings to describe the Cloud Logging behaviors for the app.
               Structure is documented below.
        :param pulumi.Input['AppLoggingSettingsConversationLoggingSettingsArgs'] conversation_logging_settings: Settings to describe the conversation logging behaviors for the app.
               Structure is documented below.
        :param pulumi.Input['AppLoggingSettingsRedactionConfigArgs'] redaction_config: Configuration to instruct how sensitive data should be handled.
               Structure is documented below.
        """
        if audio_recording_config is not None:
            pulumi.set(__self__, "audio_recording_config", audio_recording_config)
        if bigquery_export_settings is not None:
            pulumi.set(__self__, "bigquery_export_settings", bigquery_export_settings)
        if cloud_logging_settings is not None:
            pulumi.set(__self__, "cloud_logging_settings", cloud_logging_settings)
        if conversation_logging_settings is not None:
            pulumi.set(__self__, "conversation_logging_settings", conversation_logging_settings)
        if redaction_config is not None:
            pulumi.set(__self__, "redaction_config", redaction_config)

    @_builtins.property
    @pulumi.getter(name="audioRecordingConfig")
    def audio_recording_config(self) -> Optional[pulumi.Input['AppLoggingSettingsAudioRecordingConfigArgs']]:
        """
        Configuration for how the audio interactions should be recorded.
        Structure is documented below.
        """
        return pulumi.get(self, "audio_recording_config")

    @audio_recording_config.setter
    def audio_recording_config(self, value: Optional[pulumi.Input['AppLoggingSettingsAudioRecordingConfigArgs']]):
        pulumi.set(self, "audio_recording_config", value)

    @_builtins.property
    @pulumi.getter(name="bigqueryExportSettings")
    def bigquery_export_settings(self) -> Optional[pulumi.Input['AppLoggingSettingsBigqueryExportSettingsArgs']]:
        """
        Settings to describe the BigQuery export behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "bigquery_export_settings")

    @bigquery_export_settings.setter
    def bigquery_export_settings(self, value: Optional[pulumi.Input['AppLoggingSettingsBigqueryExportSettingsArgs']]):
        pulumi.set(self, "bigquery_export_settings", value)

    @_builtins.property
    @pulumi.getter(name="cloudLoggingSettings")
    def cloud_logging_settings(self) -> Optional[pulumi.Input['AppLoggingSettingsCloudLoggingSettingsArgs']]:
        """
        Settings to describe the Cloud Logging behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_logging_settings")

    @cloud_logging_settings.setter
    def cloud_logging_settings(self, value: Optional[pulumi.Input['AppLoggingSettingsCloudLoggingSettingsArgs']]):
        pulumi.set(self, "cloud_logging_settings", value)

    @_builtins.property
    @pulumi.getter(name="conversationLoggingSettings")
    def conversation_logging_settings(self) -> Optional[pulumi.Input['AppLoggingSettingsConversationLoggingSettingsArgs']]:
        """
        Settings to describe the conversation logging behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_logging_settings")

    @conversation_logging_settings.setter
    def conversation_logging_settings(self, value: Optional[pulumi.Input['AppLoggingSettingsConversationLoggingSettingsArgs']]):
        pulumi.set(self, "conversation_logging_settings", value)

    @_builtins.property
    @pulumi.getter(name="redactionConfig")
    def redaction_config(self) -> Optional[pulumi.Input['AppLoggingSettingsRedactionConfigArgs']]:
        """
        Configuration to instruct how sensitive data should be handled.
        Structure is documented below.
        """
        return pulumi.get(self, "redaction_config")

    @redaction_config.setter
    def redaction_config(self, value: Optional[pulumi.Input['AppLoggingSettingsRedactionConfigArgs']]):
        pulumi.set(self, "redaction_config", value)


if not MYPY:
    class AppLoggingSettingsAudioRecordingConfigArgsDict(TypedDict):
        gcs_bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [Cloud Storage](https://cloud.google.com/storage) bucket to store the
        session audio recordings. The URI must start with "gs://".
        Note: If the Cloud Storage bucket is in a different project from the app,
        you should grant `storage.objects.create` permission to the CES service
        agent `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        gcs_path_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Cloud Storage path prefix for audio recordings.
        This prefix can include the following placeholders, which will be
        dynamically substituted at serving time:
        - $project:   project ID
        - $location:  app location
        - $app:       app ID
        - $date:      session date in YYYY-MM-DD format
        - $session:   session ID
        If the path prefix is not specified, the default prefix
        `$project/$location/$app/$date/$session/` will be used.
        """
elif False:
    AppLoggingSettingsAudioRecordingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLoggingSettingsAudioRecordingConfigArgs:
    def __init__(__self__, *,
                 gcs_bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 gcs_path_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] gcs_bucket: The [Cloud Storage](https://cloud.google.com/storage) bucket to store the
               session audio recordings. The URI must start with "gs://".
               Note: If the Cloud Storage bucket is in a different project from the app,
               you should grant `storage.objects.create` permission to the CES service
               agent `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param pulumi.Input[_builtins.str] gcs_path_prefix: The Cloud Storage path prefix for audio recordings.
               This prefix can include the following placeholders, which will be
               dynamically substituted at serving time:
               - $project:   project ID
               - $location:  app location
               - $app:       app ID
               - $date:      session date in YYYY-MM-DD format
               - $session:   session ID
               If the path prefix is not specified, the default prefix
               `$project/$location/$app/$date/$session/` will be used.
        """
        if gcs_bucket is not None:
            pulumi.set(__self__, "gcs_bucket", gcs_bucket)
        if gcs_path_prefix is not None:
            pulumi.set(__self__, "gcs_path_prefix", gcs_path_prefix)

    @_builtins.property
    @pulumi.getter(name="gcsBucket")
    def gcs_bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [Cloud Storage](https://cloud.google.com/storage) bucket to store the
        session audio recordings. The URI must start with "gs://".
        Note: If the Cloud Storage bucket is in a different project from the app,
        you should grant `storage.objects.create` permission to the CES service
        agent `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "gcs_bucket")

    @gcs_bucket.setter
    def gcs_bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gcs_bucket", value)

    @_builtins.property
    @pulumi.getter(name="gcsPathPrefix")
    def gcs_path_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Cloud Storage path prefix for audio recordings.
        This prefix can include the following placeholders, which will be
        dynamically substituted at serving time:
        - $project:   project ID
        - $location:  app location
        - $app:       app ID
        - $date:      session date in YYYY-MM-DD format
        - $session:   session ID
        If the path prefix is not specified, the default prefix
        `$project/$location/$app/$date/$session/` will be used.
        """
        return pulumi.get(self, "gcs_path_prefix")

    @gcs_path_prefix.setter
    def gcs_path_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gcs_path_prefix", value)


if not MYPY:
    class AppLoggingSettingsBigqueryExportSettingsArgsDict(TypedDict):
        dataset: NotRequired[pulumi.Input[_builtins.str]]
        """
        The BigQuery dataset to export the data to.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the BigQuery export is enabled.
        """
        project: NotRequired[pulumi.Input[_builtins.str]]
        """
        The project ID of the BigQuery dataset to export the data to.
        Note: If the BigQuery dataset is in a different project from the app, you should grant
        roles/bigquery.admin role to the CES service agent service-<PROJECT-
        NUMBER>@gcp-sa-ces.iam.gserviceaccount.com.
        """
elif False:
    AppLoggingSettingsBigqueryExportSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLoggingSettingsBigqueryExportSettingsArgs:
    def __init__(__self__, *,
                 dataset: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 project: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dataset: The BigQuery dataset to export the data to.
        :param pulumi.Input[_builtins.bool] enabled: Indicates whether the BigQuery export is enabled.
        :param pulumi.Input[_builtins.str] project: The project ID of the BigQuery dataset to export the data to.
               Note: If the BigQuery dataset is in a different project from the app, you should grant
               roles/bigquery.admin role to the CES service agent service-<PROJECT-
               NUMBER>@gcp-sa-ces.iam.gserviceaccount.com.
        """
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if project is not None:
            pulumi.set(__self__, "project", project)

    @_builtins.property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The BigQuery dataset to export the data to.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dataset", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the BigQuery export is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The project ID of the BigQuery dataset to export the data to.
        Note: If the BigQuery dataset is in a different project from the app, you should grant
        roles/bigquery.admin role to the CES service agent service-<PROJECT-
        NUMBER>@gcp-sa-ces.iam.gserviceaccount.com.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project", value)


if not MYPY:
    class AppLoggingSettingsCloudLoggingSettingsArgsDict(TypedDict):
        enable_cloud_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable Cloud Logging for the sessions.
        """
elif False:
    AppLoggingSettingsCloudLoggingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLoggingSettingsCloudLoggingSettingsArgs:
    def __init__(__self__, *,
                 enable_cloud_logging: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_cloud_logging: Whether to enable Cloud Logging for the sessions.
        """
        if enable_cloud_logging is not None:
            pulumi.set(__self__, "enable_cloud_logging", enable_cloud_logging)

    @_builtins.property
    @pulumi.getter(name="enableCloudLogging")
    def enable_cloud_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable Cloud Logging for the sessions.
        """
        return pulumi.get(self, "enable_cloud_logging")

    @enable_cloud_logging.setter
    def enable_cloud_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_cloud_logging", value)


if not MYPY:
    class AppLoggingSettingsConversationLoggingSettingsArgsDict(TypedDict):
        disable_conversation_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable conversation logging for the sessions.
        """
elif False:
    AppLoggingSettingsConversationLoggingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLoggingSettingsConversationLoggingSettingsArgs:
    def __init__(__self__, *,
                 disable_conversation_logging: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] disable_conversation_logging: Whether to disable conversation logging for the sessions.
        """
        if disable_conversation_logging is not None:
            pulumi.set(__self__, "disable_conversation_logging", disable_conversation_logging)

    @_builtins.property
    @pulumi.getter(name="disableConversationLogging")
    def disable_conversation_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable conversation logging for the sessions.
        """
        return pulumi.get(self, "disable_conversation_logging")

    @disable_conversation_logging.setter
    def disable_conversation_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_conversation_logging", value)


if not MYPY:
    class AppLoggingSettingsRedactionConfigArgsDict(TypedDict):
        deidentify_template: NotRequired[pulumi.Input[_builtins.str]]
        """
        [DLP](https://cloud.google.com/dlp/docs) deidentify template name to
        instruct on how to de-identify content.
        Format:
        `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
        """
        enable_redaction: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, redaction will be applied in various logging scenarios, including
        conversation history, Cloud Logging and audio recording.
        """
        inspect_template: NotRequired[pulumi.Input[_builtins.str]]
        """
        [DLP](https://cloud.google.com/dlp/docs) inspect template name to configure
        detection of sensitive data types.
        Format:
        `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
        """
elif False:
    AppLoggingSettingsRedactionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLoggingSettingsRedactionConfigArgs:
    def __init__(__self__, *,
                 deidentify_template: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_redaction: Optional[pulumi.Input[_builtins.bool]] = None,
                 inspect_template: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] deidentify_template: [DLP](https://cloud.google.com/dlp/docs) deidentify template name to
               instruct on how to de-identify content.
               Format:
               `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
        :param pulumi.Input[_builtins.bool] enable_redaction: If true, redaction will be applied in various logging scenarios, including
               conversation history, Cloud Logging and audio recording.
        :param pulumi.Input[_builtins.str] inspect_template: [DLP](https://cloud.google.com/dlp/docs) inspect template name to configure
               detection of sensitive data types.
               Format:
               `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
        """
        if deidentify_template is not None:
            pulumi.set(__self__, "deidentify_template", deidentify_template)
        if enable_redaction is not None:
            pulumi.set(__self__, "enable_redaction", enable_redaction)
        if inspect_template is not None:
            pulumi.set(__self__, "inspect_template", inspect_template)

    @_builtins.property
    @pulumi.getter(name="deidentifyTemplate")
    def deidentify_template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        [DLP](https://cloud.google.com/dlp/docs) deidentify template name to
        instruct on how to de-identify content.
        Format:
        `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
        """
        return pulumi.get(self, "deidentify_template")

    @deidentify_template.setter
    def deidentify_template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deidentify_template", value)

    @_builtins.property
    @pulumi.getter(name="enableRedaction")
    def enable_redaction(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, redaction will be applied in various logging scenarios, including
        conversation history, Cloud Logging and audio recording.
        """
        return pulumi.get(self, "enable_redaction")

    @enable_redaction.setter
    def enable_redaction(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_redaction", value)

    @_builtins.property
    @pulumi.getter(name="inspectTemplate")
    def inspect_template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        [DLP](https://cloud.google.com/dlp/docs) inspect template name to configure
        detection of sensitive data types.
        Format:
        `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
        """
        return pulumi.get(self, "inspect_template")

    @inspect_template.setter
    def inspect_template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inspect_template", value)


if not MYPY:
    class AppModelSettingsArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
elif False:
    AppModelSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppModelSettingsArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] model: The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param pulumi.Input[_builtins.float] temperature: If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)


if not MYPY:
    class AppTimeZoneSettingsArgsDict(TypedDict):
        time_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time zone of the app from the time zone database, e.g., America/Los_Angeles, Europe/Paris.
        """
elif False:
    AppTimeZoneSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppTimeZoneSettingsArgs:
    def __init__(__self__, *,
                 time_zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] time_zone: The time zone of the app from the time zone database, e.g., America/Los_Angeles, Europe/Paris.
        """
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time zone of the app from the time zone database, e.g., America/Los_Angeles, Europe/Paris.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class AppVariableDeclarationArgsDict(TypedDict):
        description: pulumi.Input[_builtins.str]
        """
        The description of the variable.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the variable. The name must start with a letter or underscore
        and contain only letters, numbers, or underscores.
        """
        schema: pulumi.Input['AppVariableDeclarationSchemaArgsDict']
        """
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
elif False:
    AppVariableDeclarationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVariableDeclarationArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 schema: pulumi.Input['AppVariableDeclarationSchemaArgs']):
        """
        :param pulumi.Input[_builtins.str] description: The description of the variable.
        :param pulumi.Input[_builtins.str] name: The name of the variable. The name must start with a letter or underscore
               and contain only letters, numbers, or underscores.
        :param pulumi.Input['AppVariableDeclarationSchemaArgs'] schema: Represents a select subset of an OpenAPI 3.0 schema object.
               Structure is documented below.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema", schema)

    @_builtins.property
    @pulumi.getter
    def description(self) -> pulumi.Input[_builtins.str]:
        """
        The description of the variable.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the variable. The name must start with a letter or underscore
        and contain only letters, numbers, or underscores.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> pulumi.Input['AppVariableDeclarationSchemaArgs']:
        """
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input['AppVariableDeclarationSchemaArgs']):
        pulumi.set(self, "schema", value)


if not MYPY:
    class AppVariableDeclarationSchemaArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of the data.
        Possible values:
        STRING
        INTEGER
        NUMBER
        BOOLEAN
        OBJECT
        ARRAY
        """
        additional_properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        any_of: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        default: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        defs: NotRequired[pulumi.Input[_builtins.str]]
        """
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the data.
        """
        enums: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        items: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema of the elements of Type.ARRAY.
        """
        nullable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the value may be null.
        """
        prefix_items: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        Properties of Type.OBJECT.
        """
        ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        requireds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Required properties of Type.OBJECT.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The title of the schema.
        """
        unique_items: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
elif False:
    AppVariableDeclarationSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVariableDeclarationSchemaArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 additional_properties: Optional[pulumi.Input[_builtins.str]] = None,
                 any_of: Optional[pulumi.Input[_builtins.str]] = None,
                 default: Optional[pulumi.Input[_builtins.str]] = None,
                 defs: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enums: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 items: Optional[pulumi.Input[_builtins.str]] = None,
                 nullable: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix_items: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[_builtins.str]] = None,
                 ref: Optional[pulumi.Input[_builtins.str]] = None,
                 requireds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None,
                 unique_items: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of the data.
               Possible values:
               STRING
               INTEGER
               NUMBER
               BOOLEAN
               OBJECT
               ARRAY
        :param pulumi.Input[_builtins.str] additional_properties: Optional. Defines the schema for additional properties allowed in an object.
               The value must be a valid JSON string representing the Schema object.
               (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        :param pulumi.Input[_builtins.str] any_of: Optional. The instance value should be valid against at least one of the schemas in this list.
        :param pulumi.Input[_builtins.str] default: Optional. Default value of the data. Represents a dynamically typed value
               which can be either null, a number, a string, a boolean, a struct,
               or a list of values. The provided default value must be compatible
               with the defined 'type' and other schema constraints.
        :param pulumi.Input[_builtins.str] defs: A map of definitions for use by ref. Only allowed at the root of the schema.
        :param pulumi.Input[_builtins.str] description: The description of the data.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enums: Possible values of the element of primitive type with enum format.
               Examples:
               1. We can define direction as :
               {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
               2. We can define apartment number as :
               {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        :param pulumi.Input[_builtins.str] items: Schema of the elements of Type.ARRAY.
        :param pulumi.Input[_builtins.bool] nullable: Indicates if the value may be null.
        :param pulumi.Input[_builtins.str] prefix_items: Optional. Schemas of initial elements of Type.ARRAY.
        :param pulumi.Input[_builtins.str] properties: Properties of Type.OBJECT.
        :param pulumi.Input[_builtins.str] ref: Allows indirect references between schema nodes. The value should be a
               valid reference to a child of the root `defs`.
               For example, the following schema defines a reference to a schema node
               named "Pet":
               type: object
               properties:
               pet:
               ref: #/defs/Pet
               defs:
               Pet:
               type: object
               properties:
               name:
               type: string
               The value of the "pet" property is a reference to the schema node
               named "Pet".
               See details in
               https://json-schema.org/understanding-json-schema/structuring.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] requireds: Required properties of Type.OBJECT.
        :param pulumi.Input[_builtins.str] title: The title of the schema.
        :param pulumi.Input[_builtins.bool] unique_items: Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        pulumi.set(__self__, "type", type)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if any_of is not None:
            pulumi.set(__self__, "any_of", any_of)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if defs is not None:
            pulumi.set(__self__, "defs", defs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enums is not None:
            pulumi.set(__self__, "enums", enums)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if prefix_items is not None:
            pulumi.set(__self__, "prefix_items", prefix_items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if requireds is not None:
            pulumi.set(__self__, "requireds", requireds)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the data.
        Possible values:
        STRING
        INTEGER
        NUMBER
        BOOLEAN
        OBJECT
        ARRAY
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_properties", value)

    @_builtins.property
    @pulumi.getter(name="anyOf")
    def any_of(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        return pulumi.get(self, "any_of")

    @any_of.setter
    def any_of(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "any_of", value)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def defs(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        return pulumi.get(self, "defs")

    @defs.setter
    def defs(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "defs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the data.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def enums(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        return pulumi.get(self, "enums")

    @enums.setter
    def enums(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enums", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema of the elements of Type.ARRAY.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the value may be null.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "nullable", value)

    @_builtins.property
    @pulumi.getter(name="prefixItems")
    def prefix_items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        return pulumi.get(self, "prefix_items")

    @prefix_items.setter
    def prefix_items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_items", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Properties of Type.OBJECT.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ref", value)

    @_builtins.property
    @pulumi.getter
    def requireds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Required properties of Type.OBJECT.
        """
        return pulumi.get(self, "requireds")

    @requireds.setter
    def requireds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "requireds", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The title of the schema.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        return pulumi.get(self, "unique_items")

    @unique_items.setter
    def unique_items(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unique_items", value)


if not MYPY:
    class AppVersionSnapshotArgsDict(TypedDict):
        agents: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentArgsDict']]]]
        """
        (Output)
        List of agents in the app.
        Structure is documented below.
        """
        apps: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppArgsDict']]]]
        """
        Resource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122.
        """
        examples: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleArgsDict']]]]
        """
        (Output)
        List of examples in the app.
        Structure is documented below.
        """
        guardrails: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailArgsDict']]]]
        """
        (Output)
        List of guardrails for the app.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
        """
        tools: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolArgsDict']]]]
        """
        (Output)
        List of available tools for the agent.
        Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        """
        toolsets: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetArgsDict']]]]
        """
        (Output)
        List of toolsets for the agent.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotArgs:
    def __init__(__self__, *,
                 agents: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentArgs']]]] = None,
                 apps: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppArgs']]]] = None,
                 examples: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleArgs']]]] = None,
                 guardrails: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailArgs']]]] = None,
                 tools: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolArgs']]]] = None,
                 toolsets: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentArgs']]] agents: (Output)
               List of agents in the app.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppArgs']]] apps: Resource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleArgs']]] examples: (Output)
               List of examples in the app.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailArgs']]] guardrails: (Output)
               List of guardrails for the app.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolArgs']]] tools: (Output)
               List of available tools for the agent.
               Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetArgs']]] toolsets: (Output)
               List of toolsets for the agent.
               Structure is documented below.
        """
        if agents is not None:
            pulumi.set(__self__, "agents", agents)
        if apps is not None:
            pulumi.set(__self__, "apps", apps)
        if examples is not None:
            pulumi.set(__self__, "examples", examples)
        if guardrails is not None:
            pulumi.set(__self__, "guardrails", guardrails)
        if tools is not None:
            pulumi.set(__self__, "tools", tools)
        if toolsets is not None:
            pulumi.set(__self__, "toolsets", toolsets)

    @_builtins.property
    @pulumi.getter
    def agents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentArgs']]]]:
        """
        (Output)
        List of agents in the app.
        Structure is documented below.
        """
        return pulumi.get(self, "agents")

    @agents.setter
    def agents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentArgs']]]]):
        pulumi.set(self, "agents", value)

    @_builtins.property
    @pulumi.getter
    def apps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppArgs']]]]:
        """
        Resource ID segment making up resource `name`. It identifies the resource within its parent collection as described in https://google.aip.dev/122.
        """
        return pulumi.get(self, "apps")

    @apps.setter
    def apps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppArgs']]]]):
        pulumi.set(self, "apps", value)

    @_builtins.property
    @pulumi.getter
    def examples(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleArgs']]]]:
        """
        (Output)
        List of examples in the app.
        Structure is documented below.
        """
        return pulumi.get(self, "examples")

    @examples.setter
    def examples(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleArgs']]]]):
        pulumi.set(self, "examples", value)

    @_builtins.property
    @pulumi.getter
    def guardrails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailArgs']]]]:
        """
        (Output)
        List of guardrails for the app.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
        """
        return pulumi.get(self, "guardrails")

    @guardrails.setter
    def guardrails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailArgs']]]]):
        pulumi.set(self, "guardrails", value)

    @_builtins.property
    @pulumi.getter
    def tools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolArgs']]]]:
        """
        (Output)
        List of available tools for the agent.
        Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        """
        return pulumi.get(self, "tools")

    @tools.setter
    def tools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolArgs']]]]):
        pulumi.set(self, "tools", value)

    @_builtins.property
    @pulumi.getter
    def toolsets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetArgs']]]]:
        """
        (Output)
        List of toolsets for the agent.
        Structure is documented below.
        """
        return pulumi.get(self, "toolsets")

    @toolsets.setter
    def toolsets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetArgs']]]]):
        pulumi.set(self, "toolsets", value)


if not MYPY:
    class AppVersionSnapshotAgentArgsDict(TypedDict):
        after_agent_callbacks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentAfterAgentCallbackArgsDict']]]]
        """
        (Output)
        The callbacks to execute after the agent is called.
        The provided callbacks are executed sequentially in the exact order they
        are given in the list. If a callback returns an overridden response,
        execution stops and any remaining callbacks are skipped.
        Structure is documented below.
        """
        after_model_callbacks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentAfterModelCallbackArgsDict']]]]
        """
        (Output)
        The callbacks to execute after the model is called. If there are multiple
        calls to the model, the callback will be executed multiple times.
        The provided callbacks are executed sequentially in the exact order they
        are given in the list. If a callback returns an overridden response,
        execution stops and any remaining callbacks are skipped.
        Structure is documented below.
        """
        after_tool_callbacks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentAfterToolCallbackArgsDict']]]]
        """
        (Output)
        The callbacks to execute after the tool is invoked. If there are multiple
        tool invocations, the callback will be executed multiple times.
        The provided callbacks are executed sequentially in the exact order they
        are given in the list. If a callback returns an overridden response,
        execution stops and any remaining callbacks are skipped.
        Structure is documented below.
        """
        before_agent_callbacks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentBeforeAgentCallbackArgsDict']]]]
        """
        (Output)
        The callbacks to execute before the agent is called.
        The provided callbacks are executed sequentially in the exact order they
        are given in the list. If a callback returns an overridden response,
        execution stops and any remaining callbacks are skipped.
        Structure is documented below.
        """
        before_model_callbacks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentBeforeModelCallbackArgsDict']]]]
        """
        (Output)
        The callbacks to execute before the model is called. If there are multiple
        calls to the model, the callback will be executed multiple times.
        The provided callbacks are executed sequentially in the exact order they
        are given in the list. If a callback returns an overridden response,
        execution stops and any remaining callbacks are skipped.
        Structure is documented below.
        """
        before_tool_callbacks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentBeforeToolCallbackArgsDict']]]]
        """
        (Output)
        The callbacks to execute before the tool is invoked. If there are multiple
        tool invocations, the callback will be executed multiple times.
        The provided callbacks are executed sequentially in the exact order they
        are given in the list. If a callback returns an overridden response,
        execution stops and any remaining callbacks are skipped.
        Structure is documented below.
        """
        child_agents: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        List of child agents in the agent tree.
        Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Timestamp when the toolset was created.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The display name of the app version.
        """
        etag: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        ETag used to ensure the object hasn't changed during a read-modify-write
        operation. If the etag is empty, the update will overwrite any concurrent
        changes.
        """
        generated_summary: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        If the tool is generated by the LLM assistant, this field contains a
        descriptive summary of the generation.
        """
        guardrails: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        List of guardrails for the app.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
        """
        instruction: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Instructions for the LLM model to guide the agent's behavior.
        """
        llm_agents: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentLlmAgentArgsDict']]]]
        """
        (Output)
        Default agent type. The agent uses instructions and callbacks specified in
        the agent to perform the task using a large language model.
        """
        model_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentModelSettingArgsDict']]]]
        """
        (Output)
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        remote_dialogflow_agents: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentRemoteDialogflowAgentArgsDict']]]]
        """
        (Output)
        The agent which will transfer execution to an existing remote
        [Dialogflow](https://cloud.google.com/dialogflow/cx/docs/concept/console-conversational-agents)
        agent flow. The corresponding Dialogflow agent will process subsequent user
        queries until the session ends or flow ends and the control is transferred
        back to the parent CES agent.
        Structure is documented below.
        """
        tools: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        List of available tools for the agent.
        Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        """
        toolsets: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentToolsetArgsDict']]]]
        """
        (Output)
        List of toolsets for the agent.
        Structure is documented below.
        """
        update_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Timestamp when the toolset was last updated.
        """
elif False:
    AppVersionSnapshotAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAgentArgs:
    def __init__(__self__, *,
                 after_agent_callbacks: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentAfterAgentCallbackArgs']]]] = None,
                 after_model_callbacks: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentAfterModelCallbackArgs']]]] = None,
                 after_tool_callbacks: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentAfterToolCallbackArgs']]]] = None,
                 before_agent_callbacks: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentBeforeAgentCallbackArgs']]]] = None,
                 before_model_callbacks: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentBeforeModelCallbackArgs']]]] = None,
                 before_tool_callbacks: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentBeforeToolCallbackArgs']]]] = None,
                 child_agents: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 etag: Optional[pulumi.Input[_builtins.str]] = None,
                 generated_summary: Optional[pulumi.Input[_builtins.str]] = None,
                 guardrails: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 instruction: Optional[pulumi.Input[_builtins.str]] = None,
                 llm_agents: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentLlmAgentArgs']]]] = None,
                 model_settings: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentModelSettingArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 remote_dialogflow_agents: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentRemoteDialogflowAgentArgs']]]] = None,
                 tools: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 toolsets: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentToolsetArgs']]]] = None,
                 update_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentAfterAgentCallbackArgs']]] after_agent_callbacks: (Output)
               The callbacks to execute after the agent is called.
               The provided callbacks are executed sequentially in the exact order they
               are given in the list. If a callback returns an overridden response,
               execution stops and any remaining callbacks are skipped.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentAfterModelCallbackArgs']]] after_model_callbacks: (Output)
               The callbacks to execute after the model is called. If there are multiple
               calls to the model, the callback will be executed multiple times.
               The provided callbacks are executed sequentially in the exact order they
               are given in the list. If a callback returns an overridden response,
               execution stops and any remaining callbacks are skipped.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentAfterToolCallbackArgs']]] after_tool_callbacks: (Output)
               The callbacks to execute after the tool is invoked. If there are multiple
               tool invocations, the callback will be executed multiple times.
               The provided callbacks are executed sequentially in the exact order they
               are given in the list. If a callback returns an overridden response,
               execution stops and any remaining callbacks are skipped.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentBeforeAgentCallbackArgs']]] before_agent_callbacks: (Output)
               The callbacks to execute before the agent is called.
               The provided callbacks are executed sequentially in the exact order they
               are given in the list. If a callback returns an overridden response,
               execution stops and any remaining callbacks are skipped.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentBeforeModelCallbackArgs']]] before_model_callbacks: (Output)
               The callbacks to execute before the model is called. If there are multiple
               calls to the model, the callback will be executed multiple times.
               The provided callbacks are executed sequentially in the exact order they
               are given in the list. If a callback returns an overridden response,
               execution stops and any remaining callbacks are skipped.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentBeforeToolCallbackArgs']]] before_tool_callbacks: (Output)
               The callbacks to execute before the tool is invoked. If there are multiple
               tool invocations, the callback will be executed multiple times.
               The provided callbacks are executed sequentially in the exact order they
               are given in the list. If a callback returns an overridden response,
               execution stops and any remaining callbacks are skipped.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] child_agents: (Output)
               List of child agents in the agent tree.
               Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        :param pulumi.Input[_builtins.str] create_time: (Output)
               Timestamp when the toolset was created.
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.str] display_name: The display name of the app version.
        :param pulumi.Input[_builtins.str] etag: (Output)
               ETag used to ensure the object hasn't changed during a read-modify-write
               operation. If the etag is empty, the update will overwrite any concurrent
               changes.
        :param pulumi.Input[_builtins.str] generated_summary: (Output)
               If the tool is generated by the LLM assistant, this field contains a
               descriptive summary of the generation.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] guardrails: (Output)
               List of guardrails for the app.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
        :param pulumi.Input[_builtins.str] instruction: (Output)
               Instructions for the LLM model to guide the agent's behavior.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentLlmAgentArgs']]] llm_agents: (Output)
               Default agent type. The agent uses instructions and callbacks specified in
               the agent to perform the task using a large language model.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentModelSettingArgs']]] model_settings: (Output)
               Model settings contains various configurations for the LLM model.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentRemoteDialogflowAgentArgs']]] remote_dialogflow_agents: (Output)
               The agent which will transfer execution to an existing remote
               [Dialogflow](https://cloud.google.com/dialogflow/cx/docs/concept/console-conversational-agents)
               agent flow. The corresponding Dialogflow agent will process subsequent user
               queries until the session ends or flow ends and the control is transferred
               back to the parent CES agent.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tools: (Output)
               List of available tools for the agent.
               Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentToolsetArgs']]] toolsets: (Output)
               List of toolsets for the agent.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] update_time: (Output)
               Timestamp when the toolset was last updated.
        """
        if after_agent_callbacks is not None:
            pulumi.set(__self__, "after_agent_callbacks", after_agent_callbacks)
        if after_model_callbacks is not None:
            pulumi.set(__self__, "after_model_callbacks", after_model_callbacks)
        if after_tool_callbacks is not None:
            pulumi.set(__self__, "after_tool_callbacks", after_tool_callbacks)
        if before_agent_callbacks is not None:
            pulumi.set(__self__, "before_agent_callbacks", before_agent_callbacks)
        if before_model_callbacks is not None:
            pulumi.set(__self__, "before_model_callbacks", before_model_callbacks)
        if before_tool_callbacks is not None:
            pulumi.set(__self__, "before_tool_callbacks", before_tool_callbacks)
        if child_agents is not None:
            pulumi.set(__self__, "child_agents", child_agents)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if etag is not None:
            pulumi.set(__self__, "etag", etag)
        if generated_summary is not None:
            pulumi.set(__self__, "generated_summary", generated_summary)
        if guardrails is not None:
            pulumi.set(__self__, "guardrails", guardrails)
        if instruction is not None:
            pulumi.set(__self__, "instruction", instruction)
        if llm_agents is not None:
            pulumi.set(__self__, "llm_agents", llm_agents)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if remote_dialogflow_agents is not None:
            pulumi.set(__self__, "remote_dialogflow_agents", remote_dialogflow_agents)
        if tools is not None:
            pulumi.set(__self__, "tools", tools)
        if toolsets is not None:
            pulumi.set(__self__, "toolsets", toolsets)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="afterAgentCallbacks")
    def after_agent_callbacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentAfterAgentCallbackArgs']]]]:
        """
        (Output)
        The callbacks to execute after the agent is called.
        The provided callbacks are executed sequentially in the exact order they
        are given in the list. If a callback returns an overridden response,
        execution stops and any remaining callbacks are skipped.
        Structure is documented below.
        """
        return pulumi.get(self, "after_agent_callbacks")

    @after_agent_callbacks.setter
    def after_agent_callbacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentAfterAgentCallbackArgs']]]]):
        pulumi.set(self, "after_agent_callbacks", value)

    @_builtins.property
    @pulumi.getter(name="afterModelCallbacks")
    def after_model_callbacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentAfterModelCallbackArgs']]]]:
        """
        (Output)
        The callbacks to execute after the model is called. If there are multiple
        calls to the model, the callback will be executed multiple times.
        The provided callbacks are executed sequentially in the exact order they
        are given in the list. If a callback returns an overridden response,
        execution stops and any remaining callbacks are skipped.
        Structure is documented below.
        """
        return pulumi.get(self, "after_model_callbacks")

    @after_model_callbacks.setter
    def after_model_callbacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentAfterModelCallbackArgs']]]]):
        pulumi.set(self, "after_model_callbacks", value)

    @_builtins.property
    @pulumi.getter(name="afterToolCallbacks")
    def after_tool_callbacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentAfterToolCallbackArgs']]]]:
        """
        (Output)
        The callbacks to execute after the tool is invoked. If there are multiple
        tool invocations, the callback will be executed multiple times.
        The provided callbacks are executed sequentially in the exact order they
        are given in the list. If a callback returns an overridden response,
        execution stops and any remaining callbacks are skipped.
        Structure is documented below.
        """
        return pulumi.get(self, "after_tool_callbacks")

    @after_tool_callbacks.setter
    def after_tool_callbacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentAfterToolCallbackArgs']]]]):
        pulumi.set(self, "after_tool_callbacks", value)

    @_builtins.property
    @pulumi.getter(name="beforeAgentCallbacks")
    def before_agent_callbacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentBeforeAgentCallbackArgs']]]]:
        """
        (Output)
        The callbacks to execute before the agent is called.
        The provided callbacks are executed sequentially in the exact order they
        are given in the list. If a callback returns an overridden response,
        execution stops and any remaining callbacks are skipped.
        Structure is documented below.
        """
        return pulumi.get(self, "before_agent_callbacks")

    @before_agent_callbacks.setter
    def before_agent_callbacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentBeforeAgentCallbackArgs']]]]):
        pulumi.set(self, "before_agent_callbacks", value)

    @_builtins.property
    @pulumi.getter(name="beforeModelCallbacks")
    def before_model_callbacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentBeforeModelCallbackArgs']]]]:
        """
        (Output)
        The callbacks to execute before the model is called. If there are multiple
        calls to the model, the callback will be executed multiple times.
        The provided callbacks are executed sequentially in the exact order they
        are given in the list. If a callback returns an overridden response,
        execution stops and any remaining callbacks are skipped.
        Structure is documented below.
        """
        return pulumi.get(self, "before_model_callbacks")

    @before_model_callbacks.setter
    def before_model_callbacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentBeforeModelCallbackArgs']]]]):
        pulumi.set(self, "before_model_callbacks", value)

    @_builtins.property
    @pulumi.getter(name="beforeToolCallbacks")
    def before_tool_callbacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentBeforeToolCallbackArgs']]]]:
        """
        (Output)
        The callbacks to execute before the tool is invoked. If there are multiple
        tool invocations, the callback will be executed multiple times.
        The provided callbacks are executed sequentially in the exact order they
        are given in the list. If a callback returns an overridden response,
        execution stops and any remaining callbacks are skipped.
        Structure is documented below.
        """
        return pulumi.get(self, "before_tool_callbacks")

    @before_tool_callbacks.setter
    def before_tool_callbacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentBeforeToolCallbackArgs']]]]):
        pulumi.set(self, "before_tool_callbacks", value)

    @_builtins.property
    @pulumi.getter(name="childAgents")
    def child_agents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        List of child agents in the agent tree.
        Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        return pulumi.get(self, "child_agents")

    @child_agents.setter
    def child_agents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "child_agents", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Timestamp when the toolset was created.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def etag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        ETag used to ensure the object hasn't changed during a read-modify-write
        operation. If the etag is empty, the update will overwrite any concurrent
        changes.
        """
        return pulumi.get(self, "etag")

    @etag.setter
    def etag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "etag", value)

    @_builtins.property
    @pulumi.getter(name="generatedSummary")
    def generated_summary(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        If the tool is generated by the LLM assistant, this field contains a
        descriptive summary of the generation.
        """
        return pulumi.get(self, "generated_summary")

    @generated_summary.setter
    def generated_summary(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "generated_summary", value)

    @_builtins.property
    @pulumi.getter
    def guardrails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        List of guardrails for the app.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
        """
        return pulumi.get(self, "guardrails")

    @guardrails.setter
    def guardrails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "guardrails", value)

    @_builtins.property
    @pulumi.getter
    def instruction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Instructions for the LLM model to guide the agent's behavior.
        """
        return pulumi.get(self, "instruction")

    @instruction.setter
    def instruction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "instruction", value)

    @_builtins.property
    @pulumi.getter(name="llmAgents")
    def llm_agents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentLlmAgentArgs']]]]:
        """
        (Output)
        Default agent type. The agent uses instructions and callbacks specified in
        the agent to perform the task using a large language model.
        """
        return pulumi.get(self, "llm_agents")

    @llm_agents.setter
    def llm_agents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentLlmAgentArgs']]]]):
        pulumi.set(self, "llm_agents", value)

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentModelSettingArgs']]]]:
        """
        (Output)
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @model_settings.setter
    def model_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentModelSettingArgs']]]]):
        pulumi.set(self, "model_settings", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="remoteDialogflowAgents")
    def remote_dialogflow_agents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentRemoteDialogflowAgentArgs']]]]:
        """
        (Output)
        The agent which will transfer execution to an existing remote
        [Dialogflow](https://cloud.google.com/dialogflow/cx/docs/concept/console-conversational-agents)
        agent flow. The corresponding Dialogflow agent will process subsequent user
        queries until the session ends or flow ends and the control is transferred
        back to the parent CES agent.
        Structure is documented below.
        """
        return pulumi.get(self, "remote_dialogflow_agents")

    @remote_dialogflow_agents.setter
    def remote_dialogflow_agents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentRemoteDialogflowAgentArgs']]]]):
        pulumi.set(self, "remote_dialogflow_agents", value)

    @_builtins.property
    @pulumi.getter
    def tools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        List of available tools for the agent.
        Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        """
        return pulumi.get(self, "tools")

    @tools.setter
    def tools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tools", value)

    @_builtins.property
    @pulumi.getter
    def toolsets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentToolsetArgs']]]]:
        """
        (Output)
        List of toolsets for the agent.
        Structure is documented below.
        """
        return pulumi.get(self, "toolsets")

    @toolsets.setter
    def toolsets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAgentToolsetArgs']]]]):
        pulumi.set(self, "toolsets", value)

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Timestamp when the toolset was last updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class AppVersionSnapshotAgentAfterAgentCallbackArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether summarization is disabled.
        """
        python_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The Python code to execute for the tool.
        """
elif False:
    AppVersionSnapshotAgentAfterAgentCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAgentAfterAgentCallbackArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 python_code: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.bool] disabled: (Output)
               Whether summarization is disabled.
        :param pulumi.Input[_builtins.str] python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "python_code", value)


if not MYPY:
    class AppVersionSnapshotAgentAfterModelCallbackArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether summarization is disabled.
        """
        python_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The Python code to execute for the tool.
        """
elif False:
    AppVersionSnapshotAgentAfterModelCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAgentAfterModelCallbackArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 python_code: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.bool] disabled: (Output)
               Whether summarization is disabled.
        :param pulumi.Input[_builtins.str] python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "python_code", value)


if not MYPY:
    class AppVersionSnapshotAgentAfterToolCallbackArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether summarization is disabled.
        """
        python_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The Python code to execute for the tool.
        """
elif False:
    AppVersionSnapshotAgentAfterToolCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAgentAfterToolCallbackArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 python_code: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.bool] disabled: (Output)
               Whether summarization is disabled.
        :param pulumi.Input[_builtins.str] python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "python_code", value)


if not MYPY:
    class AppVersionSnapshotAgentBeforeAgentCallbackArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether summarization is disabled.
        """
        python_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The Python code to execute for the tool.
        """
elif False:
    AppVersionSnapshotAgentBeforeAgentCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAgentBeforeAgentCallbackArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 python_code: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.bool] disabled: (Output)
               Whether summarization is disabled.
        :param pulumi.Input[_builtins.str] python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "python_code", value)


if not MYPY:
    class AppVersionSnapshotAgentBeforeModelCallbackArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether summarization is disabled.
        """
        python_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The Python code to execute for the tool.
        """
elif False:
    AppVersionSnapshotAgentBeforeModelCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAgentBeforeModelCallbackArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 python_code: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.bool] disabled: (Output)
               Whether summarization is disabled.
        :param pulumi.Input[_builtins.str] python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "python_code", value)


if not MYPY:
    class AppVersionSnapshotAgentBeforeToolCallbackArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether summarization is disabled.
        """
        python_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The Python code to execute for the tool.
        """
elif False:
    AppVersionSnapshotAgentBeforeToolCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAgentBeforeToolCallbackArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 python_code: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.bool] disabled: (Output)
               Whether summarization is disabled.
        :param pulumi.Input[_builtins.str] python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "python_code", value)


if not MYPY:
    class AppVersionSnapshotAgentLlmAgentArgsDict(TypedDict):
        pass
elif False:
    AppVersionSnapshotAgentLlmAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAgentLlmAgentArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AppVersionSnapshotAgentModelSettingArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Output)
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
elif False:
    AppVersionSnapshotAgentModelSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAgentModelSettingArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] model: (Output)
               The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param pulumi.Input[_builtins.float] temperature: (Output)
               If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Output)
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)


if not MYPY:
    class AppVersionSnapshotAgentRemoteDialogflowAgentArgsDict(TypedDict):
        agent: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the agent to transfer the conversation to. The agent must be
        in the same app as the current agent.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        environment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The environment ID of the Dialogflow agent be used for the agent
        execution. If not specified, the draft environment will be used.
        """
        flow_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The flow ID of the flow in the Dialogflow agent.
        """
        input_variable_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Output)
        The mapping of the app variables names to the Dialogflow session
        parameters names to be sent to the Dialogflow agent as input.
        """
        output_variable_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Output)
        The mapping of the Dialogflow session parameters names to the app
        variables names to be sent back to the CES agent after the Dialogflow
        agent execution ends.
        """
elif False:
    AppVersionSnapshotAgentRemoteDialogflowAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAgentRemoteDialogflowAgentArgs:
    def __init__(__self__, *,
                 agent: Optional[pulumi.Input[_builtins.str]] = None,
                 environment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 flow_id: Optional[pulumi.Input[_builtins.str]] = None,
                 input_variable_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 output_variable_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] agent: (Output)
               The name of the agent to transfer the conversation to. The agent must be
               in the same app as the current agent.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        :param pulumi.Input[_builtins.str] environment_id: (Output)
               The environment ID of the Dialogflow agent be used for the agent
               execution. If not specified, the draft environment will be used.
        :param pulumi.Input[_builtins.str] flow_id: (Output)
               The flow ID of the flow in the Dialogflow agent.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] input_variable_mapping: (Output)
               The mapping of the app variables names to the Dialogflow session
               parameters names to be sent to the Dialogflow agent as input.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] output_variable_mapping: (Output)
               The mapping of the Dialogflow session parameters names to the app
               variables names to be sent back to the CES agent after the Dialogflow
               agent execution ends.
        """
        if agent is not None:
            pulumi.set(__self__, "agent", agent)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)
        if flow_id is not None:
            pulumi.set(__self__, "flow_id", flow_id)
        if input_variable_mapping is not None:
            pulumi.set(__self__, "input_variable_mapping", input_variable_mapping)
        if output_variable_mapping is not None:
            pulumi.set(__self__, "output_variable_mapping", output_variable_mapping)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the agent to transfer the conversation to. The agent must be
        in the same app as the current agent.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agent", value)

    @_builtins.property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The environment ID of the Dialogflow agent be used for the agent
        execution. If not specified, the draft environment will be used.
        """
        return pulumi.get(self, "environment_id")

    @environment_id.setter
    def environment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment_id", value)

    @_builtins.property
    @pulumi.getter(name="flowId")
    def flow_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The flow ID of the flow in the Dialogflow agent.
        """
        return pulumi.get(self, "flow_id")

    @flow_id.setter
    def flow_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "flow_id", value)

    @_builtins.property
    @pulumi.getter(name="inputVariableMapping")
    def input_variable_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        The mapping of the app variables names to the Dialogflow session
        parameters names to be sent to the Dialogflow agent as input.
        """
        return pulumi.get(self, "input_variable_mapping")

    @input_variable_mapping.setter
    def input_variable_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "input_variable_mapping", value)

    @_builtins.property
    @pulumi.getter(name="outputVariableMapping")
    def output_variable_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        The mapping of the Dialogflow session parameters names to the app
        variables names to be sent back to the CES agent after the Dialogflow
        agent execution ends.
        """
        return pulumi.get(self, "output_variable_mapping")

    @output_variable_mapping.setter
    def output_variable_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "output_variable_mapping", value)


if not MYPY:
    class AppVersionSnapshotAgentToolsetArgsDict(TypedDict):
        tool_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        The tools IDs to filter the toolset.
        """
        toolset: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The resource name of the Toolset from which this tool is derived.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
elif False:
    AppVersionSnapshotAgentToolsetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAgentToolsetArgs:
    def __init__(__self__, *,
                 tool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 toolset: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tool_ids: (Output)
               The tools IDs to filter the toolset.
        :param pulumi.Input[_builtins.str] toolset: (Output)
               The resource name of the Toolset from which this tool is derived.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        if tool_ids is not None:
            pulumi.set(__self__, "tool_ids", tool_ids)
        if toolset is not None:
            pulumi.set(__self__, "toolset", toolset)

    @_builtins.property
    @pulumi.getter(name="toolIds")
    def tool_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        The tools IDs to filter the toolset.
        """
        return pulumi.get(self, "tool_ids")

    @tool_ids.setter
    def tool_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tool_ids", value)

    @_builtins.property
    @pulumi.getter
    def toolset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The resource name of the Toolset from which this tool is derived.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "toolset")

    @toolset.setter
    def toolset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "toolset", value)


if not MYPY:
    class AppVersionSnapshotAppArgsDict(TypedDict):
        audio_processing_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigArgsDict']]]]
        """
        (Output)
        Configuration for how the input and output audio should be processed and
        delivered.
        Structure is documented below.
        """
        client_certificate_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppClientCertificateSettingArgsDict']]]]
        """
        (Output)
        The default client certificate settings for the app.
        Structure is documented below.
        """
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Timestamp when the toolset was created.
        """
        data_store_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDataStoreSettingArgsDict']]]]
        """
        (Output)
        Data store related settings for the app.
        Structure is documented below.
        """
        default_channel_profiles: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDefaultChannelProfileArgsDict']]]]
        """
        (Output)
        A ChannelProfile configures the agent's behavior for a specific communication
        channel, such as web UI or telephony.
        Structure is documented below.
        """
        deployment_count: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Output)
        Number of deployments in the app.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The display name of the app version.
        """
        etag: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        ETag used to ensure the object hasn't changed during a read-modify-write
        operation. If the etag is empty, the update will overwrite any concurrent
        changes.
        """
        evaluation_metrics_thresholds: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdArgsDict']]]]
        """
        (Output)
        Threshold settings for metrics in an Evaluation.
        Structure is documented below.
        """
        global_instruction: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Instructions for all the agents in the app.
        You can use this instruction to set up a stable identity or personality
        across all the agents.
        """
        guardrails: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        List of guardrails for the app.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
        """
        language_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLanguageSettingArgsDict']]]]
        """
        (Output)
        Language settings of the app.
        Structure is documented below.
        """
        logging_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingArgsDict']]]]
        """
        (Output)
        Settings to describe the logging behaviors for the app.
        Structure is documented below.
        """
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Output)
        Metadata about the app. This field can be used to store additional
        information relevant to the app's details or intended usages.
        """
        model_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppModelSettingArgsDict']]]]
        """
        (Output)
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        root_agent: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The root agent is the entry point of the app.
        Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        time_zone_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppTimeZoneSettingArgsDict']]]]
        """
        (Output)
        TimeZone settings of the app.
        Structure is documented below.
        """
        update_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Timestamp when the toolset was last updated.
        """
        variable_declarations: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppVariableDeclarationArgsDict']]]]
        """
        (Output)
        The declarations of the variables.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotAppArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppArgs:
    def __init__(__self__, *,
                 audio_processing_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigArgs']]]] = None,
                 client_certificate_settings: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppClientCertificateSettingArgs']]]] = None,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 data_store_settings: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDataStoreSettingArgs']]]] = None,
                 default_channel_profiles: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDefaultChannelProfileArgs']]]] = None,
                 deployment_count: Optional[pulumi.Input[_builtins.int]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 etag: Optional[pulumi.Input[_builtins.str]] = None,
                 evaluation_metrics_thresholds: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdArgs']]]] = None,
                 global_instruction: Optional[pulumi.Input[_builtins.str]] = None,
                 guardrails: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 language_settings: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLanguageSettingArgs']]]] = None,
                 logging_settings: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingArgs']]]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 model_settings: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppModelSettingArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 root_agent: Optional[pulumi.Input[_builtins.str]] = None,
                 time_zone_settings: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppTimeZoneSettingArgs']]]] = None,
                 update_time: Optional[pulumi.Input[_builtins.str]] = None,
                 variable_declarations: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppVariableDeclarationArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigArgs']]] audio_processing_configs: (Output)
               Configuration for how the input and output audio should be processed and
               delivered.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppClientCertificateSettingArgs']]] client_certificate_settings: (Output)
               The default client certificate settings for the app.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] create_time: (Output)
               Timestamp when the toolset was created.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDataStoreSettingArgs']]] data_store_settings: (Output)
               Data store related settings for the app.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDefaultChannelProfileArgs']]] default_channel_profiles: (Output)
               A ChannelProfile configures the agent's behavior for a specific communication
               channel, such as web UI or telephony.
               Structure is documented below.
        :param pulumi.Input[_builtins.int] deployment_count: (Output)
               Number of deployments in the app.
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.str] display_name: The display name of the app version.
        :param pulumi.Input[_builtins.str] etag: (Output)
               ETag used to ensure the object hasn't changed during a read-modify-write
               operation. If the etag is empty, the update will overwrite any concurrent
               changes.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdArgs']]] evaluation_metrics_thresholds: (Output)
               Threshold settings for metrics in an Evaluation.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] global_instruction: (Output)
               Instructions for all the agents in the app.
               You can use this instruction to set up a stable identity or personality
               across all the agents.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] guardrails: (Output)
               List of guardrails for the app.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLanguageSettingArgs']]] language_settings: (Output)
               Language settings of the app.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingArgs']]] logging_settings: (Output)
               Settings to describe the logging behaviors for the app.
               Structure is documented below.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] metadata: (Output)
               Metadata about the app. This field can be used to store additional
               information relevant to the app's details or intended usages.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppModelSettingArgs']]] model_settings: (Output)
               Model settings contains various configurations for the LLM model.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param pulumi.Input[_builtins.str] root_agent: (Output)
               The root agent is the entry point of the app.
               Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppTimeZoneSettingArgs']]] time_zone_settings: (Output)
               TimeZone settings of the app.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] update_time: (Output)
               Timestamp when the toolset was last updated.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppVariableDeclarationArgs']]] variable_declarations: (Output)
               The declarations of the variables.
               Structure is documented below.
        """
        if audio_processing_configs is not None:
            pulumi.set(__self__, "audio_processing_configs", audio_processing_configs)
        if client_certificate_settings is not None:
            pulumi.set(__self__, "client_certificate_settings", client_certificate_settings)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if data_store_settings is not None:
            pulumi.set(__self__, "data_store_settings", data_store_settings)
        if default_channel_profiles is not None:
            pulumi.set(__self__, "default_channel_profiles", default_channel_profiles)
        if deployment_count is not None:
            pulumi.set(__self__, "deployment_count", deployment_count)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if etag is not None:
            pulumi.set(__self__, "etag", etag)
        if evaluation_metrics_thresholds is not None:
            pulumi.set(__self__, "evaluation_metrics_thresholds", evaluation_metrics_thresholds)
        if global_instruction is not None:
            pulumi.set(__self__, "global_instruction", global_instruction)
        if guardrails is not None:
            pulumi.set(__self__, "guardrails", guardrails)
        if language_settings is not None:
            pulumi.set(__self__, "language_settings", language_settings)
        if logging_settings is not None:
            pulumi.set(__self__, "logging_settings", logging_settings)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if root_agent is not None:
            pulumi.set(__self__, "root_agent", root_agent)
        if time_zone_settings is not None:
            pulumi.set(__self__, "time_zone_settings", time_zone_settings)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)
        if variable_declarations is not None:
            pulumi.set(__self__, "variable_declarations", variable_declarations)

    @_builtins.property
    @pulumi.getter(name="audioProcessingConfigs")
    def audio_processing_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigArgs']]]]:
        """
        (Output)
        Configuration for how the input and output audio should be processed and
        delivered.
        Structure is documented below.
        """
        return pulumi.get(self, "audio_processing_configs")

    @audio_processing_configs.setter
    def audio_processing_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigArgs']]]]):
        pulumi.set(self, "audio_processing_configs", value)

    @_builtins.property
    @pulumi.getter(name="clientCertificateSettings")
    def client_certificate_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppClientCertificateSettingArgs']]]]:
        """
        (Output)
        The default client certificate settings for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "client_certificate_settings")

    @client_certificate_settings.setter
    def client_certificate_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppClientCertificateSettingArgs']]]]):
        pulumi.set(self, "client_certificate_settings", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Timestamp when the toolset was created.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter(name="dataStoreSettings")
    def data_store_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDataStoreSettingArgs']]]]:
        """
        (Output)
        Data store related settings for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "data_store_settings")

    @data_store_settings.setter
    def data_store_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDataStoreSettingArgs']]]]):
        pulumi.set(self, "data_store_settings", value)

    @_builtins.property
    @pulumi.getter(name="defaultChannelProfiles")
    def default_channel_profiles(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDefaultChannelProfileArgs']]]]:
        """
        (Output)
        A ChannelProfile configures the agent's behavior for a specific communication
        channel, such as web UI or telephony.
        Structure is documented below.
        """
        return pulumi.get(self, "default_channel_profiles")

    @default_channel_profiles.setter
    def default_channel_profiles(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDefaultChannelProfileArgs']]]]):
        pulumi.set(self, "default_channel_profiles", value)

    @_builtins.property
    @pulumi.getter(name="deploymentCount")
    def deployment_count(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Output)
        Number of deployments in the app.
        """
        return pulumi.get(self, "deployment_count")

    @deployment_count.setter
    def deployment_count(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "deployment_count", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def etag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        ETag used to ensure the object hasn't changed during a read-modify-write
        operation. If the etag is empty, the update will overwrite any concurrent
        changes.
        """
        return pulumi.get(self, "etag")

    @etag.setter
    def etag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "etag", value)

    @_builtins.property
    @pulumi.getter(name="evaluationMetricsThresholds")
    def evaluation_metrics_thresholds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdArgs']]]]:
        """
        (Output)
        Threshold settings for metrics in an Evaluation.
        Structure is documented below.
        """
        return pulumi.get(self, "evaluation_metrics_thresholds")

    @evaluation_metrics_thresholds.setter
    def evaluation_metrics_thresholds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdArgs']]]]):
        pulumi.set(self, "evaluation_metrics_thresholds", value)

    @_builtins.property
    @pulumi.getter(name="globalInstruction")
    def global_instruction(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Instructions for all the agents in the app.
        You can use this instruction to set up a stable identity or personality
        across all the agents.
        """
        return pulumi.get(self, "global_instruction")

    @global_instruction.setter
    def global_instruction(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "global_instruction", value)

    @_builtins.property
    @pulumi.getter
    def guardrails(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        List of guardrails for the app.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/guardrails/{guardrail}`
        """
        return pulumi.get(self, "guardrails")

    @guardrails.setter
    def guardrails(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "guardrails", value)

    @_builtins.property
    @pulumi.getter(name="languageSettings")
    def language_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLanguageSettingArgs']]]]:
        """
        (Output)
        Language settings of the app.
        Structure is documented below.
        """
        return pulumi.get(self, "language_settings")

    @language_settings.setter
    def language_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLanguageSettingArgs']]]]):
        pulumi.set(self, "language_settings", value)

    @_builtins.property
    @pulumi.getter(name="loggingSettings")
    def logging_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingArgs']]]]:
        """
        (Output)
        Settings to describe the logging behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "logging_settings")

    @logging_settings.setter
    def logging_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingArgs']]]]):
        pulumi.set(self, "logging_settings", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        Metadata about the app. This field can be used to store additional
        information relevant to the app's details or intended usages.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppModelSettingArgs']]]]:
        """
        (Output)
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @model_settings.setter
    def model_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppModelSettingArgs']]]]):
        pulumi.set(self, "model_settings", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="rootAgent")
    def root_agent(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The root agent is the entry point of the app.
        Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        return pulumi.get(self, "root_agent")

    @root_agent.setter
    def root_agent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "root_agent", value)

    @_builtins.property
    @pulumi.getter(name="timeZoneSettings")
    def time_zone_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppTimeZoneSettingArgs']]]]:
        """
        (Output)
        TimeZone settings of the app.
        Structure is documented below.
        """
        return pulumi.get(self, "time_zone_settings")

    @time_zone_settings.setter
    def time_zone_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppTimeZoneSettingArgs']]]]):
        pulumi.set(self, "time_zone_settings", value)

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Timestamp when the toolset was last updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update_time", value)

    @_builtins.property
    @pulumi.getter(name="variableDeclarations")
    def variable_declarations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppVariableDeclarationArgs']]]]:
        """
        (Output)
        The declarations of the variables.
        Structure is documented below.
        """
        return pulumi.get(self, "variable_declarations")

    @variable_declarations.setter
    def variable_declarations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppVariableDeclarationArgs']]]]):
        pulumi.set(self, "variable_declarations", value)


if not MYPY:
    class AppVersionSnapshotAppAudioProcessingConfigArgsDict(TypedDict):
        ambient_sound_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfigArgsDict']]]]
        """
        (Output)
        Configuration for the ambient sound to be played with the synthesized agent
        response, to enhance the naturalness of the conversation.
        Structure is documented below.
        """
        barge_in_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigBargeInConfigArgsDict']]]]
        """
        (Output)
        Configuration for how the user barge-in activities should be handled.
        Structure is documented below.
        """
        inactivity_timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The duration of user inactivity (no speech or interaction) before the agent
        prompts the user for reengagement. If not set, the agent will not prompt
        the user for reengagement.
        """
        synthesize_speech_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfigArgsDict']]]]
        """
        (Output)
        Configuration of how the agent response should be synthesized, mapping from
        the language code to SynthesizeSpeechConfig.
        If the configuration for the specified language code is not found, the
        configuration for the root language code will be used. For example, if the
        map contains "en-us" and "en", and the specified language code is "en-gb",
        then "en" configuration will be used.
        Note: Language code is case-insensitive.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotAppAudioProcessingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppAudioProcessingConfigArgs:
    def __init__(__self__, *,
                 ambient_sound_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfigArgs']]]] = None,
                 barge_in_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigBargeInConfigArgs']]]] = None,
                 inactivity_timeout: Optional[pulumi.Input[_builtins.str]] = None,
                 synthesize_speech_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfigArgs']]] ambient_sound_configs: (Output)
               Configuration for the ambient sound to be played with the synthesized agent
               response, to enhance the naturalness of the conversation.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigBargeInConfigArgs']]] barge_in_configs: (Output)
               Configuration for how the user barge-in activities should be handled.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] inactivity_timeout: (Output)
               The duration of user inactivity (no speech or interaction) before the agent
               prompts the user for reengagement. If not set, the agent will not prompt
               the user for reengagement.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfigArgs']]] synthesize_speech_configs: (Output)
               Configuration of how the agent response should be synthesized, mapping from
               the language code to SynthesizeSpeechConfig.
               If the configuration for the specified language code is not found, the
               configuration for the root language code will be used. For example, if the
               map contains "en-us" and "en", and the specified language code is "en-gb",
               then "en" configuration will be used.
               Note: Language code is case-insensitive.
               Structure is documented below.
        """
        if ambient_sound_configs is not None:
            pulumi.set(__self__, "ambient_sound_configs", ambient_sound_configs)
        if barge_in_configs is not None:
            pulumi.set(__self__, "barge_in_configs", barge_in_configs)
        if inactivity_timeout is not None:
            pulumi.set(__self__, "inactivity_timeout", inactivity_timeout)
        if synthesize_speech_configs is not None:
            pulumi.set(__self__, "synthesize_speech_configs", synthesize_speech_configs)

    @_builtins.property
    @pulumi.getter(name="ambientSoundConfigs")
    def ambient_sound_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfigArgs']]]]:
        """
        (Output)
        Configuration for the ambient sound to be played with the synthesized agent
        response, to enhance the naturalness of the conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "ambient_sound_configs")

    @ambient_sound_configs.setter
    def ambient_sound_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfigArgs']]]]):
        pulumi.set(self, "ambient_sound_configs", value)

    @_builtins.property
    @pulumi.getter(name="bargeInConfigs")
    def barge_in_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigBargeInConfigArgs']]]]:
        """
        (Output)
        Configuration for how the user barge-in activities should be handled.
        Structure is documented below.
        """
        return pulumi.get(self, "barge_in_configs")

    @barge_in_configs.setter
    def barge_in_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigBargeInConfigArgs']]]]):
        pulumi.set(self, "barge_in_configs", value)

    @_builtins.property
    @pulumi.getter(name="inactivityTimeout")
    def inactivity_timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The duration of user inactivity (no speech or interaction) before the agent
        prompts the user for reengagement. If not set, the agent will not prompt
        the user for reengagement.
        """
        return pulumi.get(self, "inactivity_timeout")

    @inactivity_timeout.setter
    def inactivity_timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inactivity_timeout", value)

    @_builtins.property
    @pulumi.getter(name="synthesizeSpeechConfigs")
    def synthesize_speech_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfigArgs']]]]:
        """
        (Output)
        Configuration of how the agent response should be synthesized, mapping from
        the language code to SynthesizeSpeechConfig.
        If the configuration for the specified language code is not found, the
        configuration for the root language code will be used. For example, if the
        map contains "en-us" and "en", and the specified language code is "en-gb",
        then "en" configuration will be used.
        Note: Language code is case-insensitive.
        Structure is documented below.
        """
        return pulumi.get(self, "synthesize_speech_configs")

    @synthesize_speech_configs.setter
    def synthesize_speech_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfigArgs']]]]):
        pulumi.set(self, "synthesize_speech_configs", value)


if not MYPY:
    class AppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfigArgsDict(TypedDict):
        gcs_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Ambient noise as a mono-channel, 16kHz WAV file stored in [Cloud
        Storage](https://cloud.google.com/storage).
        Note: Please make sure the CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com` has
        `storage.objects.get` permission to the Cloud Storage object.
        """
        prebuilt_ambient_sound: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Name of the prebuilt ambient sound.
        Valid values are: - "coffee_shop" - "keyboard" - "keypad" - "hum"
        -"office_1" - "office_2" - "office_3"
        -"room_1" - "room_2" - "room_3"
        -"room_4" - "room_5" - "air_conditioner"
        """
        volume_gain_db: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Output)
        Volume gain (in dB) of the normal native volume supported by
        ambient noise, in the range [-96.0, 16.0]. If unset, or set to a value of
        0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
        will play at approximately half the amplitude of the normal native signal
        amplitude. A value of +6.0 (dB) will play at approximately twice the
        amplitude of the normal native signal amplitude. We strongly recommend not
        to exceed +10 (dB) as there's usually no effective increase in loudness for
        any value greater than that.
        """
elif False:
    AppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppAudioProcessingConfigAmbientSoundConfigArgs:
    def __init__(__self__, *,
                 gcs_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 prebuilt_ambient_sound: Optional[pulumi.Input[_builtins.str]] = None,
                 volume_gain_db: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] gcs_uri: (Output)
               Ambient noise as a mono-channel, 16kHz WAV file stored in [Cloud
               Storage](https://cloud.google.com/storage).
               Note: Please make sure the CES service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com` has
               `storage.objects.get` permission to the Cloud Storage object.
        :param pulumi.Input[_builtins.str] prebuilt_ambient_sound: (Output)
               Name of the prebuilt ambient sound.
               Valid values are: - "coffee_shop" - "keyboard" - "keypad" - "hum"
               -"office_1" - "office_2" - "office_3"
               -"room_1" - "room_2" - "room_3"
               -"room_4" - "room_5" - "air_conditioner"
        :param pulumi.Input[_builtins.float] volume_gain_db: (Output)
               Volume gain (in dB) of the normal native volume supported by
               ambient noise, in the range [-96.0, 16.0]. If unset, or set to a value of
               0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
               will play at approximately half the amplitude of the normal native signal
               amplitude. A value of +6.0 (dB) will play at approximately twice the
               amplitude of the normal native signal amplitude. We strongly recommend not
               to exceed +10 (dB) as there's usually no effective increase in loudness for
               any value greater than that.
        """
        if gcs_uri is not None:
            pulumi.set(__self__, "gcs_uri", gcs_uri)
        if prebuilt_ambient_sound is not None:
            pulumi.set(__self__, "prebuilt_ambient_sound", prebuilt_ambient_sound)
        if volume_gain_db is not None:
            pulumi.set(__self__, "volume_gain_db", volume_gain_db)

    @_builtins.property
    @pulumi.getter(name="gcsUri")
    def gcs_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Ambient noise as a mono-channel, 16kHz WAV file stored in [Cloud
        Storage](https://cloud.google.com/storage).
        Note: Please make sure the CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com` has
        `storage.objects.get` permission to the Cloud Storage object.
        """
        return pulumi.get(self, "gcs_uri")

    @gcs_uri.setter
    def gcs_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gcs_uri", value)

    @_builtins.property
    @pulumi.getter(name="prebuiltAmbientSound")
    def prebuilt_ambient_sound(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Name of the prebuilt ambient sound.
        Valid values are: - "coffee_shop" - "keyboard" - "keypad" - "hum"
        -"office_1" - "office_2" - "office_3"
        -"room_1" - "room_2" - "room_3"
        -"room_4" - "room_5" - "air_conditioner"
        """
        return pulumi.get(self, "prebuilt_ambient_sound")

    @prebuilt_ambient_sound.setter
    def prebuilt_ambient_sound(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prebuilt_ambient_sound", value)

    @_builtins.property
    @pulumi.getter(name="volumeGainDb")
    def volume_gain_db(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Output)
        Volume gain (in dB) of the normal native volume supported by
        ambient noise, in the range [-96.0, 16.0]. If unset, or set to a value of
        0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
        will play at approximately half the amplitude of the normal native signal
        amplitude. A value of +6.0 (dB) will play at approximately twice the
        amplitude of the normal native signal amplitude. We strongly recommend not
        to exceed +10 (dB) as there's usually no effective increase in loudness for
        any value greater than that.
        """
        return pulumi.get(self, "volume_gain_db")

    @volume_gain_db.setter
    def volume_gain_db(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "volume_gain_db", value)


if not MYPY:
    class AppVersionSnapshotAppAudioProcessingConfigBargeInConfigArgsDict(TypedDict):
        barge_in_awareness: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        If enabled, the agent will adapt its next response based on the assumption
        that the user hasn't heard the full preceding agent message.
        This should not be used in scenarios where agent responses are displayed
        visually.
        """
elif False:
    AppVersionSnapshotAppAudioProcessingConfigBargeInConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppAudioProcessingConfigBargeInConfigArgs:
    def __init__(__self__, *,
                 barge_in_awareness: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] barge_in_awareness: (Output)
               If enabled, the agent will adapt its next response based on the assumption
               that the user hasn't heard the full preceding agent message.
               This should not be used in scenarios where agent responses are displayed
               visually.
        """
        if barge_in_awareness is not None:
            pulumi.set(__self__, "barge_in_awareness", barge_in_awareness)

    @_builtins.property
    @pulumi.getter(name="bargeInAwareness")
    def barge_in_awareness(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        If enabled, the agent will adapt its next response based on the assumption
        that the user hasn't heard the full preceding agent message.
        This should not be used in scenarios where agent responses are displayed
        visually.
        """
        return pulumi.get(self, "barge_in_awareness")

    @barge_in_awareness.setter
    def barge_in_awareness(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "barge_in_awareness", value)


if not MYPY:
    class AppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfigArgsDict(TypedDict):
        language_code: pulumi.Input[_builtins.str]
        """
        (Required) The identifier for this object. Format specified above.
        """
        speaking_rate: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Output)
        The speaking rate/speed in the range [0.25, 2.0]. 1.0 is the normal native
        speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is
        half as fast. Values outside of the range [0.25, 2.0] will return an error.
        """
        voice: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the voice. If not set, the service will choose a
        voice based on the other parameters such as language_code.
        For the list of available voices, please refer to Supported voices and
        languages from Cloud Text-to-Speech.
        """
elif False:
    AppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppAudioProcessingConfigSynthesizeSpeechConfigArgs:
    def __init__(__self__, *,
                 language_code: pulumi.Input[_builtins.str],
                 speaking_rate: Optional[pulumi.Input[_builtins.float]] = None,
                 voice: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] language_code: (Required) The identifier for this object. Format specified above.
        :param pulumi.Input[_builtins.float] speaking_rate: (Output)
               The speaking rate/speed in the range [0.25, 2.0]. 1.0 is the normal native
               speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is
               half as fast. Values outside of the range [0.25, 2.0] will return an error.
        :param pulumi.Input[_builtins.str] voice: (Output)
               The name of the voice. If not set, the service will choose a
               voice based on the other parameters such as language_code.
               For the list of available voices, please refer to Supported voices and
               languages from Cloud Text-to-Speech.
        """
        pulumi.set(__self__, "language_code", language_code)
        if speaking_rate is not None:
            pulumi.set(__self__, "speaking_rate", speaking_rate)
        if voice is not None:
            pulumi.set(__self__, "voice", voice)

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> pulumi.Input[_builtins.str]:
        """
        (Required) The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "language_code", value)

    @_builtins.property
    @pulumi.getter(name="speakingRate")
    def speaking_rate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Output)
        The speaking rate/speed in the range [0.25, 2.0]. 1.0 is the normal native
        speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is
        half as fast. Values outside of the range [0.25, 2.0] will return an error.
        """
        return pulumi.get(self, "speaking_rate")

    @speaking_rate.setter
    def speaking_rate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "speaking_rate", value)

    @_builtins.property
    @pulumi.getter
    def voice(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the voice. If not set, the service will choose a
        voice based on the other parameters such as language_code.
        For the list of available voices, please refer to Supported voices and
        languages from Cloud Text-to-Speech.
        """
        return pulumi.get(self, "voice")

    @voice.setter
    def voice(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "voice", value)


if not MYPY:
    class AppVersionSnapshotAppClientCertificateSettingArgsDict(TypedDict):
        passphrase: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The passphrase to decrypt the private key.
        Should be left unset if the private key is not encrypted.
        """
        private_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the SecretManager secret version resource
        storing the private key encoded in PEM format.
        Format: projects/{project}/secrets/{secret}/versions/{version}
        """
        tls_certificate: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The TLS certificate encoded in PEM format.
        This string must include the begin header and end footer lines.
        """
elif False:
    AppVersionSnapshotAppClientCertificateSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppClientCertificateSettingArgs:
    def __init__(__self__, *,
                 passphrase: Optional[pulumi.Input[_builtins.str]] = None,
                 private_key: Optional[pulumi.Input[_builtins.str]] = None,
                 tls_certificate: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] passphrase: (Output)
               The passphrase to decrypt the private key.
               Should be left unset if the private key is not encrypted.
        :param pulumi.Input[_builtins.str] private_key: (Output)
               The name of the SecretManager secret version resource
               storing the private key encoded in PEM format.
               Format: projects/{project}/secrets/{secret}/versions/{version}
        :param pulumi.Input[_builtins.str] tls_certificate: (Output)
               The TLS certificate encoded in PEM format.
               This string must include the begin header and end footer lines.
        """
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)
        if tls_certificate is not None:
            pulumi.set(__self__, "tls_certificate", tls_certificate)

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The passphrase to decrypt the private key.
        Should be left unset if the private key is not encrypted.
        """
        return pulumi.get(self, "passphrase")

    @passphrase.setter
    def passphrase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "passphrase", value)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the SecretManager secret version resource
        storing the private key encoded in PEM format.
        Format: projects/{project}/secrets/{secret}/versions/{version}
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="tlsCertificate")
    def tls_certificate(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The TLS certificate encoded in PEM format.
        This string must include the begin header and end footer lines.
        """
        return pulumi.get(self, "tls_certificate")

    @tls_certificate.setter
    def tls_certificate(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tls_certificate", value)


if not MYPY:
    class AppVersionSnapshotAppDataStoreSettingArgsDict(TypedDict):
        engines: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDataStoreSettingEngineArgsDict']]]]
        """
        (Output)
        The engines for the app.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotAppDataStoreSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppDataStoreSettingArgs:
    def __init__(__self__, *,
                 engines: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDataStoreSettingEngineArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDataStoreSettingEngineArgs']]] engines: (Output)
               The engines for the app.
               Structure is documented below.
        """
        if engines is not None:
            pulumi.set(__self__, "engines", engines)

    @_builtins.property
    @pulumi.getter
    def engines(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDataStoreSettingEngineArgs']]]]:
        """
        (Output)
        The engines for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "engines")

    @engines.setter
    def engines(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDataStoreSettingEngineArgs']]]]):
        pulumi.set(self, "engines", value)


if not MYPY:
    class AppVersionSnapshotAppDataStoreSettingEngineArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR
        """
elif False:
    AppVersionSnapshotAppDataStoreSettingEngineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppDataStoreSettingEngineArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param pulumi.Input[_builtins.str] type: (Output)
               The type of the data store. This field is readonly and populated by the
               server.
               Possible values:
               PUBLIC_WEB
               UNSTRUCTURED
               FAQ
               CONNECTOR
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AppVersionSnapshotAppDefaultChannelProfileArgsDict(TypedDict):
        channel_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The type of the channel profile.
        Possible values:
        UNKNOWN
        WEB_UI
        API
        TWILIO
        GOOGLE_TELEPHONY_PLATFORM
        CONTACT_CENTER_AS_A_SERVICE
        """
        disable_barge_in_control: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether to disable user barge-in in the conversation.
        - true: User interruptions are disabled while the agent is speaking.
        - false: The agent retains automatic control over when the user can interrupt.
        """
        disable_dtmf: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether to disable DTMF (dual-tone multi-frequency).
        """
        persona_properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDefaultChannelProfilePersonaPropertyArgsDict']]]]
        """
        (Output)
        Represents the persona property of a channel.
        Structure is documented below.
        """
        profile_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The unique identifier of the channel profile.
        """
        web_widget_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDefaultChannelProfileWebWidgetConfigArgsDict']]]]
        """
        (Output)
        Message for configuration for the web widget.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotAppDefaultChannelProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppDefaultChannelProfileArgs:
    def __init__(__self__, *,
                 channel_type: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_barge_in_control: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_dtmf: Optional[pulumi.Input[_builtins.bool]] = None,
                 persona_properties: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDefaultChannelProfilePersonaPropertyArgs']]]] = None,
                 profile_id: Optional[pulumi.Input[_builtins.str]] = None,
                 web_widget_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDefaultChannelProfileWebWidgetConfigArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] channel_type: (Output)
               The type of the channel profile.
               Possible values:
               UNKNOWN
               WEB_UI
               API
               TWILIO
               GOOGLE_TELEPHONY_PLATFORM
               CONTACT_CENTER_AS_A_SERVICE
        :param pulumi.Input[_builtins.bool] disable_barge_in_control: (Output)
               Whether to disable user barge-in in the conversation.
               - true: User interruptions are disabled while the agent is speaking.
               - false: The agent retains automatic control over when the user can interrupt.
        :param pulumi.Input[_builtins.bool] disable_dtmf: (Output)
               Whether to disable DTMF (dual-tone multi-frequency).
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDefaultChannelProfilePersonaPropertyArgs']]] persona_properties: (Output)
               Represents the persona property of a channel.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] profile_id: (Output)
               The unique identifier of the channel profile.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDefaultChannelProfileWebWidgetConfigArgs']]] web_widget_configs: (Output)
               Message for configuration for the web widget.
               Structure is documented below.
        """
        if channel_type is not None:
            pulumi.set(__self__, "channel_type", channel_type)
        if disable_barge_in_control is not None:
            pulumi.set(__self__, "disable_barge_in_control", disable_barge_in_control)
        if disable_dtmf is not None:
            pulumi.set(__self__, "disable_dtmf", disable_dtmf)
        if persona_properties is not None:
            pulumi.set(__self__, "persona_properties", persona_properties)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if web_widget_configs is not None:
            pulumi.set(__self__, "web_widget_configs", web_widget_configs)

    @_builtins.property
    @pulumi.getter(name="channelType")
    def channel_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The type of the channel profile.
        Possible values:
        UNKNOWN
        WEB_UI
        API
        TWILIO
        GOOGLE_TELEPHONY_PLATFORM
        CONTACT_CENTER_AS_A_SERVICE
        """
        return pulumi.get(self, "channel_type")

    @channel_type.setter
    def channel_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel_type", value)

    @_builtins.property
    @pulumi.getter(name="disableBargeInControl")
    def disable_barge_in_control(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether to disable user barge-in in the conversation.
        - true: User interruptions are disabled while the agent is speaking.
        - false: The agent retains automatic control over when the user can interrupt.
        """
        return pulumi.get(self, "disable_barge_in_control")

    @disable_barge_in_control.setter
    def disable_barge_in_control(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_barge_in_control", value)

    @_builtins.property
    @pulumi.getter(name="disableDtmf")
    def disable_dtmf(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether to disable DTMF (dual-tone multi-frequency).
        """
        return pulumi.get(self, "disable_dtmf")

    @disable_dtmf.setter
    def disable_dtmf(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_dtmf", value)

    @_builtins.property
    @pulumi.getter(name="personaProperties")
    def persona_properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDefaultChannelProfilePersonaPropertyArgs']]]]:
        """
        (Output)
        Represents the persona property of a channel.
        Structure is documented below.
        """
        return pulumi.get(self, "persona_properties")

    @persona_properties.setter
    def persona_properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDefaultChannelProfilePersonaPropertyArgs']]]]):
        pulumi.set(self, "persona_properties", value)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The unique identifier of the channel profile.
        """
        return pulumi.get(self, "profile_id")

    @profile_id.setter
    def profile_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile_id", value)

    @_builtins.property
    @pulumi.getter(name="webWidgetConfigs")
    def web_widget_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDefaultChannelProfileWebWidgetConfigArgs']]]]:
        """
        (Output)
        Message for configuration for the web widget.
        Structure is documented below.
        """
        return pulumi.get(self, "web_widget_configs")

    @web_widget_configs.setter
    def web_widget_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppDefaultChannelProfileWebWidgetConfigArgs']]]]):
        pulumi.set(self, "web_widget_configs", value)


if not MYPY:
    class AppVersionSnapshotAppDefaultChannelProfilePersonaPropertyArgsDict(TypedDict):
        persona: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The persona of the channel.
        Possible values:
        UNKNOWN
        CONCISE
        CHATTY
        """
elif False:
    AppVersionSnapshotAppDefaultChannelProfilePersonaPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppDefaultChannelProfilePersonaPropertyArgs:
    def __init__(__self__, *,
                 persona: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] persona: (Output)
               The persona of the channel.
               Possible values:
               UNKNOWN
               CONCISE
               CHATTY
        """
        if persona is not None:
            pulumi.set(__self__, "persona", persona)

    @_builtins.property
    @pulumi.getter
    def persona(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The persona of the channel.
        Possible values:
        UNKNOWN
        CONCISE
        CHATTY
        """
        return pulumi.get(self, "persona")

    @persona.setter
    def persona(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "persona", value)


if not MYPY:
    class AppVersionSnapshotAppDefaultChannelProfileWebWidgetConfigArgsDict(TypedDict):
        modality: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The modality of the web widget.
        Possible values:
        UNKNOWN_MODALITY
        CHAT_AND_VOICE
        VOICE_ONLY
        CHAT_ONLY
        """
        theme: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The theme of the web widget.
        Possible values:
        UNKNOWN_THEME
        LIGHT
        DARK
        """
        web_widget_title: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The title of the web widget.
        """
elif False:
    AppVersionSnapshotAppDefaultChannelProfileWebWidgetConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppDefaultChannelProfileWebWidgetConfigArgs:
    def __init__(__self__, *,
                 modality: Optional[pulumi.Input[_builtins.str]] = None,
                 theme: Optional[pulumi.Input[_builtins.str]] = None,
                 web_widget_title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] modality: (Output)
               The modality of the web widget.
               Possible values:
               UNKNOWN_MODALITY
               CHAT_AND_VOICE
               VOICE_ONLY
               CHAT_ONLY
        :param pulumi.Input[_builtins.str] theme: (Output)
               The theme of the web widget.
               Possible values:
               UNKNOWN_THEME
               LIGHT
               DARK
        :param pulumi.Input[_builtins.str] web_widget_title: (Output)
               The title of the web widget.
        """
        if modality is not None:
            pulumi.set(__self__, "modality", modality)
        if theme is not None:
            pulumi.set(__self__, "theme", theme)
        if web_widget_title is not None:
            pulumi.set(__self__, "web_widget_title", web_widget_title)

    @_builtins.property
    @pulumi.getter
    def modality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The modality of the web widget.
        Possible values:
        UNKNOWN_MODALITY
        CHAT_AND_VOICE
        VOICE_ONLY
        CHAT_ONLY
        """
        return pulumi.get(self, "modality")

    @modality.setter
    def modality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "modality", value)

    @_builtins.property
    @pulumi.getter
    def theme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The theme of the web widget.
        Possible values:
        UNKNOWN_THEME
        LIGHT
        DARK
        """
        return pulumi.get(self, "theme")

    @theme.setter
    def theme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "theme", value)

    @_builtins.property
    @pulumi.getter(name="webWidgetTitle")
    def web_widget_title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The title of the web widget.
        """
        return pulumi.get(self, "web_widget_title")

    @web_widget_title.setter
    def web_widget_title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_widget_title", value)


if not MYPY:
    class AppVersionSnapshotAppEvaluationMetricsThresholdArgsDict(TypedDict):
        golden_evaluation_metrics_thresholds: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdArgsDict']]]]
        """
        (Output)
        Settings for golden evaluations.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotAppEvaluationMetricsThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppEvaluationMetricsThresholdArgs:
    def __init__(__self__, *,
                 golden_evaluation_metrics_thresholds: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdArgs']]] golden_evaluation_metrics_thresholds: (Output)
               Settings for golden evaluations.
               Structure is documented below.
        """
        if golden_evaluation_metrics_thresholds is not None:
            pulumi.set(__self__, "golden_evaluation_metrics_thresholds", golden_evaluation_metrics_thresholds)

    @_builtins.property
    @pulumi.getter(name="goldenEvaluationMetricsThresholds")
    def golden_evaluation_metrics_thresholds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdArgs']]]]:
        """
        (Output)
        Settings for golden evaluations.
        Structure is documented below.
        """
        return pulumi.get(self, "golden_evaluation_metrics_thresholds")

    @golden_evaluation_metrics_thresholds.setter
    def golden_evaluation_metrics_thresholds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdArgs']]]]):
        pulumi.set(self, "golden_evaluation_metrics_thresholds", value)


if not MYPY:
    class AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdArgsDict(TypedDict):
        expectation_level_metrics_thresholds: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdExpectationLevelMetricsThresholdArgsDict']]]]
        """
        (Output)
        Expectation level metrics thresholds.
        Structure is documented below.
        """
        turn_level_metrics_thresholds: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdTurnLevelMetricsThresholdArgsDict']]]]
        """
        (Output)
        Turn level metrics thresholds.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdArgs:
    def __init__(__self__, *,
                 expectation_level_metrics_thresholds: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdExpectationLevelMetricsThresholdArgs']]]] = None,
                 turn_level_metrics_thresholds: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdTurnLevelMetricsThresholdArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdExpectationLevelMetricsThresholdArgs']]] expectation_level_metrics_thresholds: (Output)
               Expectation level metrics thresholds.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdTurnLevelMetricsThresholdArgs']]] turn_level_metrics_thresholds: (Output)
               Turn level metrics thresholds.
               Structure is documented below.
        """
        if expectation_level_metrics_thresholds is not None:
            pulumi.set(__self__, "expectation_level_metrics_thresholds", expectation_level_metrics_thresholds)
        if turn_level_metrics_thresholds is not None:
            pulumi.set(__self__, "turn_level_metrics_thresholds", turn_level_metrics_thresholds)

    @_builtins.property
    @pulumi.getter(name="expectationLevelMetricsThresholds")
    def expectation_level_metrics_thresholds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdExpectationLevelMetricsThresholdArgs']]]]:
        """
        (Output)
        Expectation level metrics thresholds.
        Structure is documented below.
        """
        return pulumi.get(self, "expectation_level_metrics_thresholds")

    @expectation_level_metrics_thresholds.setter
    def expectation_level_metrics_thresholds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdExpectationLevelMetricsThresholdArgs']]]]):
        pulumi.set(self, "expectation_level_metrics_thresholds", value)

    @_builtins.property
    @pulumi.getter(name="turnLevelMetricsThresholds")
    def turn_level_metrics_thresholds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdTurnLevelMetricsThresholdArgs']]]]:
        """
        (Output)
        Turn level metrics thresholds.
        Structure is documented below.
        """
        return pulumi.get(self, "turn_level_metrics_thresholds")

    @turn_level_metrics_thresholds.setter
    def turn_level_metrics_thresholds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdTurnLevelMetricsThresholdArgs']]]]):
        pulumi.set(self, "turn_level_metrics_thresholds", value)


if not MYPY:
    class AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdExpectationLevelMetricsThresholdArgsDict(TypedDict):
        tool_invocation_parameter_correctness_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Output)
        The success threshold for individual tool invocation parameter
        correctness. Must be a float between 0 and 1. Default is 1.0.
        """
elif False:
    AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdExpectationLevelMetricsThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdExpectationLevelMetricsThresholdArgs:
    def __init__(__self__, *,
                 tool_invocation_parameter_correctness_threshold: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] tool_invocation_parameter_correctness_threshold: (Output)
               The success threshold for individual tool invocation parameter
               correctness. Must be a float between 0 and 1. Default is 1.0.
        """
        if tool_invocation_parameter_correctness_threshold is not None:
            pulumi.set(__self__, "tool_invocation_parameter_correctness_threshold", tool_invocation_parameter_correctness_threshold)

    @_builtins.property
    @pulumi.getter(name="toolInvocationParameterCorrectnessThreshold")
    def tool_invocation_parameter_correctness_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Output)
        The success threshold for individual tool invocation parameter
        correctness. Must be a float between 0 and 1. Default is 1.0.
        """
        return pulumi.get(self, "tool_invocation_parameter_correctness_threshold")

    @tool_invocation_parameter_correctness_threshold.setter
    def tool_invocation_parameter_correctness_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "tool_invocation_parameter_correctness_threshold", value)


if not MYPY:
    class AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdTurnLevelMetricsThresholdArgsDict(TypedDict):
        overall_tool_invocation_correctness_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Output)
        The success threshold for overall tool invocation correctness. Must be
        a float between 0 and 1. Default is 1.0.
        """
        semantic_similarity_success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Output)
        The success threshold for semantic similarity. Must be an integer
        between 0 and 4. Default is >= 3.
        """
elif False:
    AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdTurnLevelMetricsThresholdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppEvaluationMetricsThresholdGoldenEvaluationMetricsThresholdTurnLevelMetricsThresholdArgs:
    def __init__(__self__, *,
                 overall_tool_invocation_correctness_threshold: Optional[pulumi.Input[_builtins.float]] = None,
                 semantic_similarity_success_threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.float] overall_tool_invocation_correctness_threshold: (Output)
               The success threshold for overall tool invocation correctness. Must be
               a float between 0 and 1. Default is 1.0.
        :param pulumi.Input[_builtins.int] semantic_similarity_success_threshold: (Output)
               The success threshold for semantic similarity. Must be an integer
               between 0 and 4. Default is >= 3.
        """
        if overall_tool_invocation_correctness_threshold is not None:
            pulumi.set(__self__, "overall_tool_invocation_correctness_threshold", overall_tool_invocation_correctness_threshold)
        if semantic_similarity_success_threshold is not None:
            pulumi.set(__self__, "semantic_similarity_success_threshold", semantic_similarity_success_threshold)

    @_builtins.property
    @pulumi.getter(name="overallToolInvocationCorrectnessThreshold")
    def overall_tool_invocation_correctness_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Output)
        The success threshold for overall tool invocation correctness. Must be
        a float between 0 and 1. Default is 1.0.
        """
        return pulumi.get(self, "overall_tool_invocation_correctness_threshold")

    @overall_tool_invocation_correctness_threshold.setter
    def overall_tool_invocation_correctness_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "overall_tool_invocation_correctness_threshold", value)

    @_builtins.property
    @pulumi.getter(name="semanticSimilaritySuccessThreshold")
    def semantic_similarity_success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Output)
        The success threshold for semantic similarity. Must be an integer
        between 0 and 4. Default is >= 3.
        """
        return pulumi.get(self, "semantic_similarity_success_threshold")

    @semantic_similarity_success_threshold.setter
    def semantic_similarity_success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "semantic_similarity_success_threshold", value)


if not MYPY:
    class AppVersionSnapshotAppLanguageSettingArgsDict(TypedDict):
        default_language_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The default language code of the app.
        """
        enable_multilingual_support: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Enables multilingual support. If true, agents in the app will use pre-built
        instructions to improve handling of multilingual input.
        """
        fallback_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The action to perform when an agent receives input in an unsupported
        language.
        This can be a predefined action or a custom tool call.
        Valid values are:
        - A tool's full resource name, which triggers a specific tool execution.
        - A predefined system action, such as "escalate" or "exit", which triggers
        an EndSession signal with corresponding metadata
        to terminate the conversation.
        """
        supported_language_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        List of languages codes supported by the app, in addition to the
        `default_language_code`.
        """
elif False:
    AppVersionSnapshotAppLanguageSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppLanguageSettingArgs:
    def __init__(__self__, *,
                 default_language_code: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_multilingual_support: Optional[pulumi.Input[_builtins.bool]] = None,
                 fallback_action: Optional[pulumi.Input[_builtins.str]] = None,
                 supported_language_codes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] default_language_code: (Output)
               The default language code of the app.
        :param pulumi.Input[_builtins.bool] enable_multilingual_support: (Output)
               Enables multilingual support. If true, agents in the app will use pre-built
               instructions to improve handling of multilingual input.
        :param pulumi.Input[_builtins.str] fallback_action: (Output)
               The action to perform when an agent receives input in an unsupported
               language.
               This can be a predefined action or a custom tool call.
               Valid values are:
               - A tool's full resource name, which triggers a specific tool execution.
               - A predefined system action, such as "escalate" or "exit", which triggers
               an EndSession signal with corresponding metadata
               to terminate the conversation.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] supported_language_codes: (Output)
               List of languages codes supported by the app, in addition to the
               `default_language_code`.
        """
        if default_language_code is not None:
            pulumi.set(__self__, "default_language_code", default_language_code)
        if enable_multilingual_support is not None:
            pulumi.set(__self__, "enable_multilingual_support", enable_multilingual_support)
        if fallback_action is not None:
            pulumi.set(__self__, "fallback_action", fallback_action)
        if supported_language_codes is not None:
            pulumi.set(__self__, "supported_language_codes", supported_language_codes)

    @_builtins.property
    @pulumi.getter(name="defaultLanguageCode")
    def default_language_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The default language code of the app.
        """
        return pulumi.get(self, "default_language_code")

    @default_language_code.setter
    def default_language_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_language_code", value)

    @_builtins.property
    @pulumi.getter(name="enableMultilingualSupport")
    def enable_multilingual_support(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Enables multilingual support. If true, agents in the app will use pre-built
        instructions to improve handling of multilingual input.
        """
        return pulumi.get(self, "enable_multilingual_support")

    @enable_multilingual_support.setter
    def enable_multilingual_support(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_multilingual_support", value)

    @_builtins.property
    @pulumi.getter(name="fallbackAction")
    def fallback_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The action to perform when an agent receives input in an unsupported
        language.
        This can be a predefined action or a custom tool call.
        Valid values are:
        - A tool's full resource name, which triggers a specific tool execution.
        - A predefined system action, such as "escalate" or "exit", which triggers
        an EndSession signal with corresponding metadata
        to terminate the conversation.
        """
        return pulumi.get(self, "fallback_action")

    @fallback_action.setter
    def fallback_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_action", value)

    @_builtins.property
    @pulumi.getter(name="supportedLanguageCodes")
    def supported_language_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        List of languages codes supported by the app, in addition to the
        `default_language_code`.
        """
        return pulumi.get(self, "supported_language_codes")

    @supported_language_codes.setter
    def supported_language_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "supported_language_codes", value)


if not MYPY:
    class AppVersionSnapshotAppLoggingSettingArgsDict(TypedDict):
        audio_recording_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingAudioRecordingConfigArgsDict']]]]
        """
        (Output)
        Configuration for how the audio interactions should be recorded.
        Structure is documented below.
        """
        bigquery_export_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingBigqueryExportSettingArgsDict']]]]
        """
        (Output)
        Settings to describe the BigQuery export behaviors for the app.
        Structure is documented below.
        """
        cloud_logging_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingCloudLoggingSettingArgsDict']]]]
        """
        (Output)
        Settings to describe the Cloud Logging behaviors for the app.
        Structure is documented below.
        """
        conversation_logging_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingConversationLoggingSettingArgsDict']]]]
        """
        (Output)
        Settings to describe the conversation logging behaviors for the app.
        Structure is documented below.
        """
        redaction_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingRedactionConfigArgsDict']]]]
        """
        (Output)
        Configuration to instruct how sensitive data should be handled.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotAppLoggingSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppLoggingSettingArgs:
    def __init__(__self__, *,
                 audio_recording_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingAudioRecordingConfigArgs']]]] = None,
                 bigquery_export_settings: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingBigqueryExportSettingArgs']]]] = None,
                 cloud_logging_settings: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingCloudLoggingSettingArgs']]]] = None,
                 conversation_logging_settings: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingConversationLoggingSettingArgs']]]] = None,
                 redaction_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingRedactionConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingAudioRecordingConfigArgs']]] audio_recording_configs: (Output)
               Configuration for how the audio interactions should be recorded.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingBigqueryExportSettingArgs']]] bigquery_export_settings: (Output)
               Settings to describe the BigQuery export behaviors for the app.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingCloudLoggingSettingArgs']]] cloud_logging_settings: (Output)
               Settings to describe the Cloud Logging behaviors for the app.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingConversationLoggingSettingArgs']]] conversation_logging_settings: (Output)
               Settings to describe the conversation logging behaviors for the app.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingRedactionConfigArgs']]] redaction_configs: (Output)
               Configuration to instruct how sensitive data should be handled.
               Structure is documented below.
        """
        if audio_recording_configs is not None:
            pulumi.set(__self__, "audio_recording_configs", audio_recording_configs)
        if bigquery_export_settings is not None:
            pulumi.set(__self__, "bigquery_export_settings", bigquery_export_settings)
        if cloud_logging_settings is not None:
            pulumi.set(__self__, "cloud_logging_settings", cloud_logging_settings)
        if conversation_logging_settings is not None:
            pulumi.set(__self__, "conversation_logging_settings", conversation_logging_settings)
        if redaction_configs is not None:
            pulumi.set(__self__, "redaction_configs", redaction_configs)

    @_builtins.property
    @pulumi.getter(name="audioRecordingConfigs")
    def audio_recording_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingAudioRecordingConfigArgs']]]]:
        """
        (Output)
        Configuration for how the audio interactions should be recorded.
        Structure is documented below.
        """
        return pulumi.get(self, "audio_recording_configs")

    @audio_recording_configs.setter
    def audio_recording_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingAudioRecordingConfigArgs']]]]):
        pulumi.set(self, "audio_recording_configs", value)

    @_builtins.property
    @pulumi.getter(name="bigqueryExportSettings")
    def bigquery_export_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingBigqueryExportSettingArgs']]]]:
        """
        (Output)
        Settings to describe the BigQuery export behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "bigquery_export_settings")

    @bigquery_export_settings.setter
    def bigquery_export_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingBigqueryExportSettingArgs']]]]):
        pulumi.set(self, "bigquery_export_settings", value)

    @_builtins.property
    @pulumi.getter(name="cloudLoggingSettings")
    def cloud_logging_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingCloudLoggingSettingArgs']]]]:
        """
        (Output)
        Settings to describe the Cloud Logging behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_logging_settings")

    @cloud_logging_settings.setter
    def cloud_logging_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingCloudLoggingSettingArgs']]]]):
        pulumi.set(self, "cloud_logging_settings", value)

    @_builtins.property
    @pulumi.getter(name="conversationLoggingSettings")
    def conversation_logging_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingConversationLoggingSettingArgs']]]]:
        """
        (Output)
        Settings to describe the conversation logging behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_logging_settings")

    @conversation_logging_settings.setter
    def conversation_logging_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingConversationLoggingSettingArgs']]]]):
        pulumi.set(self, "conversation_logging_settings", value)

    @_builtins.property
    @pulumi.getter(name="redactionConfigs")
    def redaction_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingRedactionConfigArgs']]]]:
        """
        (Output)
        Configuration to instruct how sensitive data should be handled.
        Structure is documented below.
        """
        return pulumi.get(self, "redaction_configs")

    @redaction_configs.setter
    def redaction_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppLoggingSettingRedactionConfigArgs']]]]):
        pulumi.set(self, "redaction_configs", value)


if not MYPY:
    class AppVersionSnapshotAppLoggingSettingAudioRecordingConfigArgsDict(TypedDict):
        gcs_bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The [Cloud Storage](https://cloud.google.com/storage) bucket to store the
        session audio recordings. The URI must start with "gs://".
        Note: If the Cloud Storage bucket is in a different project from the app,
        you should grant `storage.objects.create` permission to the CES service
        agent `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        gcs_path_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The Cloud Storage path prefix for audio recordings.
        This prefix can include the following placeholders, which will be
        dynamically substituted at serving time:
        - $project:   project ID
        - $location:  app location
        - $app:       app ID
        - $date:      session date in YYYY-MM-DD format
        - $session:   session ID
        If the path prefix is not specified, the default prefix
        `$project/$location/$app/$date/$session/` will be used.
        """
elif False:
    AppVersionSnapshotAppLoggingSettingAudioRecordingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppLoggingSettingAudioRecordingConfigArgs:
    def __init__(__self__, *,
                 gcs_bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 gcs_path_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] gcs_bucket: (Output)
               The [Cloud Storage](https://cloud.google.com/storage) bucket to store the
               session audio recordings. The URI must start with "gs://".
               Note: If the Cloud Storage bucket is in a different project from the app,
               you should grant `storage.objects.create` permission to the CES service
               agent `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param pulumi.Input[_builtins.str] gcs_path_prefix: (Output)
               The Cloud Storage path prefix for audio recordings.
               This prefix can include the following placeholders, which will be
               dynamically substituted at serving time:
               - $project:   project ID
               - $location:  app location
               - $app:       app ID
               - $date:      session date in YYYY-MM-DD format
               - $session:   session ID
               If the path prefix is not specified, the default prefix
               `$project/$location/$app/$date/$session/` will be used.
        """
        if gcs_bucket is not None:
            pulumi.set(__self__, "gcs_bucket", gcs_bucket)
        if gcs_path_prefix is not None:
            pulumi.set(__self__, "gcs_path_prefix", gcs_path_prefix)

    @_builtins.property
    @pulumi.getter(name="gcsBucket")
    def gcs_bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The [Cloud Storage](https://cloud.google.com/storage) bucket to store the
        session audio recordings. The URI must start with "gs://".
        Note: If the Cloud Storage bucket is in a different project from the app,
        you should grant `storage.objects.create` permission to the CES service
        agent `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "gcs_bucket")

    @gcs_bucket.setter
    def gcs_bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gcs_bucket", value)

    @_builtins.property
    @pulumi.getter(name="gcsPathPrefix")
    def gcs_path_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The Cloud Storage path prefix for audio recordings.
        This prefix can include the following placeholders, which will be
        dynamically substituted at serving time:
        - $project:   project ID
        - $location:  app location
        - $app:       app ID
        - $date:      session date in YYYY-MM-DD format
        - $session:   session ID
        If the path prefix is not specified, the default prefix
        `$project/$location/$app/$date/$session/` will be used.
        """
        return pulumi.get(self, "gcs_path_prefix")

    @gcs_path_prefix.setter
    def gcs_path_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gcs_path_prefix", value)


if not MYPY:
    class AppVersionSnapshotAppLoggingSettingBigqueryExportSettingArgsDict(TypedDict):
        dataset: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The BigQuery dataset to export the data to.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the guardrail is enabled.
        """
        project: NotRequired[pulumi.Input[_builtins.str]]
        """
        The ID of the project in which the resource belongs.
        If it is not provided, the provider project is used.
        """
elif False:
    AppVersionSnapshotAppLoggingSettingBigqueryExportSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppLoggingSettingBigqueryExportSettingArgs:
    def __init__(__self__, *,
                 dataset: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 project: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dataset: (Output)
               The BigQuery dataset to export the data to.
        :param pulumi.Input[_builtins.bool] enabled: (Output)
               Whether the guardrail is enabled.
        :param pulumi.Input[_builtins.str] project: The ID of the project in which the resource belongs.
               If it is not provided, the provider project is used.
        """
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if project is not None:
            pulumi.set(__self__, "project", project)

    @_builtins.property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The BigQuery dataset to export the data to.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dataset", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the guardrail is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The ID of the project in which the resource belongs.
        If it is not provided, the provider project is used.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project", value)


if not MYPY:
    class AppVersionSnapshotAppLoggingSettingCloudLoggingSettingArgsDict(TypedDict):
        enable_cloud_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether to enable Cloud Logging for the sessions.
        """
elif False:
    AppVersionSnapshotAppLoggingSettingCloudLoggingSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppLoggingSettingCloudLoggingSettingArgs:
    def __init__(__self__, *,
                 enable_cloud_logging: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_cloud_logging: (Output)
               Whether to enable Cloud Logging for the sessions.
        """
        if enable_cloud_logging is not None:
            pulumi.set(__self__, "enable_cloud_logging", enable_cloud_logging)

    @_builtins.property
    @pulumi.getter(name="enableCloudLogging")
    def enable_cloud_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether to enable Cloud Logging for the sessions.
        """
        return pulumi.get(self, "enable_cloud_logging")

    @enable_cloud_logging.setter
    def enable_cloud_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_cloud_logging", value)


if not MYPY:
    class AppVersionSnapshotAppLoggingSettingConversationLoggingSettingArgsDict(TypedDict):
        disable_conversation_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether to disable conversation logging for the sessions.
        """
elif False:
    AppVersionSnapshotAppLoggingSettingConversationLoggingSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppLoggingSettingConversationLoggingSettingArgs:
    def __init__(__self__, *,
                 disable_conversation_logging: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] disable_conversation_logging: (Output)
               Whether to disable conversation logging for the sessions.
        """
        if disable_conversation_logging is not None:
            pulumi.set(__self__, "disable_conversation_logging", disable_conversation_logging)

    @_builtins.property
    @pulumi.getter(name="disableConversationLogging")
    def disable_conversation_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether to disable conversation logging for the sessions.
        """
        return pulumi.get(self, "disable_conversation_logging")

    @disable_conversation_logging.setter
    def disable_conversation_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_conversation_logging", value)


if not MYPY:
    class AppVersionSnapshotAppLoggingSettingRedactionConfigArgsDict(TypedDict):
        deidentify_template: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        [DLP](https://cloud.google.com/dlp/docs) deidentify template name to
        instruct on how to de-identify content.
        Format:
        `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
        """
        enable_redaction: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        If true, redaction will be applied in various logging scenarios, including
        conversation history, Cloud Logging and audio recording.
        """
        inspect_template: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        [DLP](https://cloud.google.com/dlp/docs) inspect template name to configure
        detection of sensitive data types.
        Format:
        `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
        """
elif False:
    AppVersionSnapshotAppLoggingSettingRedactionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppLoggingSettingRedactionConfigArgs:
    def __init__(__self__, *,
                 deidentify_template: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_redaction: Optional[pulumi.Input[_builtins.bool]] = None,
                 inspect_template: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] deidentify_template: (Output)
               [DLP](https://cloud.google.com/dlp/docs) deidentify template name to
               instruct on how to de-identify content.
               Format:
               `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
        :param pulumi.Input[_builtins.bool] enable_redaction: (Output)
               If true, redaction will be applied in various logging scenarios, including
               conversation history, Cloud Logging and audio recording.
        :param pulumi.Input[_builtins.str] inspect_template: (Output)
               [DLP](https://cloud.google.com/dlp/docs) inspect template name to configure
               detection of sensitive data types.
               Format:
               `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
        """
        if deidentify_template is not None:
            pulumi.set(__self__, "deidentify_template", deidentify_template)
        if enable_redaction is not None:
            pulumi.set(__self__, "enable_redaction", enable_redaction)
        if inspect_template is not None:
            pulumi.set(__self__, "inspect_template", inspect_template)

    @_builtins.property
    @pulumi.getter(name="deidentifyTemplate")
    def deidentify_template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        [DLP](https://cloud.google.com/dlp/docs) deidentify template name to
        instruct on how to de-identify content.
        Format:
        `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
        """
        return pulumi.get(self, "deidentify_template")

    @deidentify_template.setter
    def deidentify_template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deidentify_template", value)

    @_builtins.property
    @pulumi.getter(name="enableRedaction")
    def enable_redaction(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        If true, redaction will be applied in various logging scenarios, including
        conversation history, Cloud Logging and audio recording.
        """
        return pulumi.get(self, "enable_redaction")

    @enable_redaction.setter
    def enable_redaction(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_redaction", value)

    @_builtins.property
    @pulumi.getter(name="inspectTemplate")
    def inspect_template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        [DLP](https://cloud.google.com/dlp/docs) inspect template name to configure
        detection of sensitive data types.
        Format:
        `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
        """
        return pulumi.get(self, "inspect_template")

    @inspect_template.setter
    def inspect_template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inspect_template", value)


if not MYPY:
    class AppVersionSnapshotAppModelSettingArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Output)
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
elif False:
    AppVersionSnapshotAppModelSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppModelSettingArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] model: (Output)
               The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param pulumi.Input[_builtins.float] temperature: (Output)
               If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Output)
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)


if not MYPY:
    class AppVersionSnapshotAppTimeZoneSettingArgsDict(TypedDict):
        time_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The time zone of the app from the time zone database, e.g., America/Los_Angeles, Europe/Paris.
        """
elif False:
    AppVersionSnapshotAppTimeZoneSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppTimeZoneSettingArgs:
    def __init__(__self__, *,
                 time_zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] time_zone: (Output)
               The time zone of the app from the time zone database, e.g., America/Los_Angeles, Europe/Paris.
        """
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The time zone of the app from the time zone database, e.g., America/Los_Angeles, Europe/Paris.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class AppVersionSnapshotAppVariableDeclarationArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        schemas: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppVariableDeclarationSchemaArgsDict']]]]
        """
        (Output)
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotAppVariableDeclarationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppVariableDeclarationArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 schemas: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppVariableDeclarationSchemaArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.str] name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppVariableDeclarationSchemaArgs']]] schemas: (Output)
               Represents a select subset of an OpenAPI 3.0 schema object.
               Structure is documented below.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if schemas is not None:
            pulumi.set(__self__, "schemas", schemas)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def schemas(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppVariableDeclarationSchemaArgs']]]]:
        """
        (Output)
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        return pulumi.get(self, "schemas")

    @schemas.setter
    def schemas(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotAppVariableDeclarationSchemaArgs']]]]):
        pulumi.set(self, "schemas", value)


if not MYPY:
    class AppVersionSnapshotAppVariableDeclarationSchemaArgsDict(TypedDict):
        additional_properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        any_of: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        default: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        defs: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        enums: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        items: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Schema of the elements of Type.ARRAY.
        """
        nullable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Indicates if the value may be null.
        """
        prefix_items: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Properties of Type.OBJECT.
        """
        ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        requireds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        Required properties of Type.OBJECT.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR
        """
        unique_items: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
elif False:
    AppVersionSnapshotAppVariableDeclarationSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotAppVariableDeclarationSchemaArgs:
    def __init__(__self__, *,
                 additional_properties: Optional[pulumi.Input[_builtins.str]] = None,
                 any_of: Optional[pulumi.Input[_builtins.str]] = None,
                 default: Optional[pulumi.Input[_builtins.str]] = None,
                 defs: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enums: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 items: Optional[pulumi.Input[_builtins.str]] = None,
                 nullable: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix_items: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[_builtins.str]] = None,
                 ref: Optional[pulumi.Input[_builtins.str]] = None,
                 requireds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 unique_items: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] additional_properties: (Output)
               Optional. Defines the schema for additional properties allowed in an object.
               The value must be a valid JSON string representing the Schema object.
               (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        :param pulumi.Input[_builtins.str] any_of: (Output)
               Optional. The instance value should be valid against at least one of the schemas in this list.
        :param pulumi.Input[_builtins.str] default: (Output)
               Optional. Default value of the data. Represents a dynamically typed value
               which can be either null, a number, a string, a boolean, a struct,
               or a list of values. The provided default value must be compatible
               with the defined 'type' and other schema constraints.
        :param pulumi.Input[_builtins.str] defs: (Output)
               A map of definitions for use by ref. Only allowed at the root of the schema.
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enums: (Output)
               Possible values of the element of primitive type with enum format.
               Examples:
               1. We can define direction as :
               {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
               2. We can define apartment number as :
               {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        :param pulumi.Input[_builtins.str] items: (Output)
               Schema of the elements of Type.ARRAY.
        :param pulumi.Input[_builtins.bool] nullable: (Output)
               Indicates if the value may be null.
        :param pulumi.Input[_builtins.str] prefix_items: (Output)
               Optional. Schemas of initial elements of Type.ARRAY.
        :param pulumi.Input[_builtins.str] properties: (Output)
               Properties of Type.OBJECT.
        :param pulumi.Input[_builtins.str] ref: (Output)
               Allows indirect references between schema nodes. The value should be a
               valid reference to a child of the root `defs`.
               For example, the following schema defines a reference to a schema node
               named "Pet":
               type: object
               properties:
               pet:
               ref: #/defs/Pet
               defs:
               Pet:
               type: object
               properties:
               name:
               type: string
               The value of the "pet" property is a reference to the schema node
               named "Pet".
               See details in
               https://json-schema.org/understanding-json-schema/structuring.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] requireds: (Output)
               Required properties of Type.OBJECT.
        :param pulumi.Input[_builtins.str] type: (Output)
               The type of the data store. This field is readonly and populated by the
               server.
               Possible values:
               PUBLIC_WEB
               UNSTRUCTURED
               FAQ
               CONNECTOR
        :param pulumi.Input[_builtins.bool] unique_items: (Output)
               Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if any_of is not None:
            pulumi.set(__self__, "any_of", any_of)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if defs is not None:
            pulumi.set(__self__, "defs", defs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enums is not None:
            pulumi.set(__self__, "enums", enums)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if prefix_items is not None:
            pulumi.set(__self__, "prefix_items", prefix_items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if requireds is not None:
            pulumi.set(__self__, "requireds", requireds)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)

    @_builtins.property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_properties", value)

    @_builtins.property
    @pulumi.getter(name="anyOf")
    def any_of(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        return pulumi.get(self, "any_of")

    @any_of.setter
    def any_of(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "any_of", value)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def defs(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        return pulumi.get(self, "defs")

    @defs.setter
    def defs(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "defs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def enums(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        return pulumi.get(self, "enums")

    @enums.setter
    def enums(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enums", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Schema of the elements of Type.ARRAY.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Indicates if the value may be null.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "nullable", value)

    @_builtins.property
    @pulumi.getter(name="prefixItems")
    def prefix_items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        return pulumi.get(self, "prefix_items")

    @prefix_items.setter
    def prefix_items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_items", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Properties of Type.OBJECT.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ref", value)

    @_builtins.property
    @pulumi.getter
    def requireds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        Required properties of Type.OBJECT.
        """
        return pulumi.get(self, "requireds")

    @requireds.setter
    def requireds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "requireds", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        return pulumi.get(self, "unique_items")

    @unique_items.setter
    def unique_items(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unique_items", value)


if not MYPY:
    class AppVersionSnapshotExampleArgsDict(TypedDict):
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Timestamp when the toolset was created.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The display name of the app version.
        """
        entry_agent: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The agent that initially handles the conversation. If not specified, the
        example represents a conversation that is handled by the root agent.
        Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        etag: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        ETag used to ensure the object hasn't changed during a read-modify-write
        operation. If the etag is empty, the update will overwrite any concurrent
        changes.
        """
        invalid: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        The example may become invalid if referencing resources are deleted.
        Invalid examples will not be used as few-shot examples.
        """
        messages: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageArgsDict']]]]
        """
        (Output)
        The collection of messages that make up the conversation.
        Structure is documented below.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        update_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Timestamp when the toolset was last updated.
        """
elif False:
    AppVersionSnapshotExampleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotExampleArgs:
    def __init__(__self__, *,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 entry_agent: Optional[pulumi.Input[_builtins.str]] = None,
                 etag: Optional[pulumi.Input[_builtins.str]] = None,
                 invalid: Optional[pulumi.Input[_builtins.bool]] = None,
                 messages: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 update_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create_time: (Output)
               Timestamp when the toolset was created.
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.str] display_name: The display name of the app version.
        :param pulumi.Input[_builtins.str] entry_agent: (Output)
               The agent that initially handles the conversation. If not specified, the
               example represents a conversation that is handled by the root agent.
               Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        :param pulumi.Input[_builtins.str] etag: (Output)
               ETag used to ensure the object hasn't changed during a read-modify-write
               operation. If the etag is empty, the update will overwrite any concurrent
               changes.
        :param pulumi.Input[_builtins.bool] invalid: (Output)
               The example may become invalid if referencing resources are deleted.
               Invalid examples will not be used as few-shot examples.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageArgs']]] messages: (Output)
               The collection of messages that make up the conversation.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param pulumi.Input[_builtins.str] update_time: (Output)
               Timestamp when the toolset was last updated.
        """
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if entry_agent is not None:
            pulumi.set(__self__, "entry_agent", entry_agent)
        if etag is not None:
            pulumi.set(__self__, "etag", etag)
        if invalid is not None:
            pulumi.set(__self__, "invalid", invalid)
        if messages is not None:
            pulumi.set(__self__, "messages", messages)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Timestamp when the toolset was created.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="entryAgent")
    def entry_agent(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The agent that initially handles the conversation. If not specified, the
        example represents a conversation that is handled by the root agent.
        Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        return pulumi.get(self, "entry_agent")

    @entry_agent.setter
    def entry_agent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "entry_agent", value)

    @_builtins.property
    @pulumi.getter
    def etag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        ETag used to ensure the object hasn't changed during a read-modify-write
        operation. If the etag is empty, the update will overwrite any concurrent
        changes.
        """
        return pulumi.get(self, "etag")

    @etag.setter
    def etag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "etag", value)

    @_builtins.property
    @pulumi.getter
    def invalid(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        The example may become invalid if referencing resources are deleted.
        Invalid examples will not be used as few-shot examples.
        """
        return pulumi.get(self, "invalid")

    @invalid.setter
    def invalid(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "invalid", value)

    @_builtins.property
    @pulumi.getter
    def messages(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageArgs']]]]:
        """
        (Output)
        The collection of messages that make up the conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "messages")

    @messages.setter
    def messages(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageArgs']]]]):
        pulumi.set(self, "messages", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Timestamp when the toolset was last updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class AppVersionSnapshotExampleMessageArgsDict(TypedDict):
        chunks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkArgsDict']]]]
        """
        (Output)
        Content of the message as a series of chunks.
        Structure is documented below.
        """
        role: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The role within the conversation, e.g., user, agent.
        """
elif False:
    AppVersionSnapshotExampleMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotExampleMessageArgs:
    def __init__(__self__, *,
                 chunks: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkArgs']]]] = None,
                 role: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkArgs']]] chunks: (Output)
               Content of the message as a series of chunks.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] role: (Output)
               The role within the conversation, e.g., user, agent.
        """
        if chunks is not None:
            pulumi.set(__self__, "chunks", chunks)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def chunks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkArgs']]]]:
        """
        (Output)
        Content of the message as a series of chunks.
        Structure is documented below.
        """
        return pulumi.get(self, "chunks")

    @chunks.setter
    def chunks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkArgs']]]]):
        pulumi.set(self, "chunks", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The role within the conversation, e.g., user, agent.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class AppVersionSnapshotExampleMessageChunkArgsDict(TypedDict):
        agent_transfers: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkAgentTransferArgsDict']]]]
        """
        (Output)
        Represents an event indicating the transfer of a conversation to a different
        agent.
        Structure is documented below.
        """
        images: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkImageArgsDict']]]]
        """
        (Output)
        Represents an image input or output in the conversation.
        Structure is documented below.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Text for the agent to respond with.
        """
        tool_calls: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolCallArgsDict']]]]
        """
        (Output)
        Request for the client or the agent to execute the specified tool.
        Structure is documented below.
        """
        tool_responses: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolResponseArgsDict']]]]
        """
        (Output)
        The execution result of a specific tool from the client or the agent.
        Structure is documented below.
        """
        updated_variables: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        A struct represents variables that were updated in the conversation,
        keyed by variable names.
        """
elif False:
    AppVersionSnapshotExampleMessageChunkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotExampleMessageChunkArgs:
    def __init__(__self__, *,
                 agent_transfers: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkAgentTransferArgs']]]] = None,
                 images: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkImageArgs']]]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None,
                 tool_calls: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolCallArgs']]]] = None,
                 tool_responses: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolResponseArgs']]]] = None,
                 updated_variables: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkAgentTransferArgs']]] agent_transfers: (Output)
               Represents an event indicating the transfer of a conversation to a different
               agent.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkImageArgs']]] images: (Output)
               Represents an image input or output in the conversation.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] text: (Output)
               Text for the agent to respond with.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolCallArgs']]] tool_calls: (Output)
               Request for the client or the agent to execute the specified tool.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolResponseArgs']]] tool_responses: (Output)
               The execution result of a specific tool from the client or the agent.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] updated_variables: (Output)
               A struct represents variables that were updated in the conversation,
               keyed by variable names.
        """
        if agent_transfers is not None:
            pulumi.set(__self__, "agent_transfers", agent_transfers)
        if images is not None:
            pulumi.set(__self__, "images", images)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if tool_calls is not None:
            pulumi.set(__self__, "tool_calls", tool_calls)
        if tool_responses is not None:
            pulumi.set(__self__, "tool_responses", tool_responses)
        if updated_variables is not None:
            pulumi.set(__self__, "updated_variables", updated_variables)

    @_builtins.property
    @pulumi.getter(name="agentTransfers")
    def agent_transfers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkAgentTransferArgs']]]]:
        """
        (Output)
        Represents an event indicating the transfer of a conversation to a different
        agent.
        Structure is documented below.
        """
        return pulumi.get(self, "agent_transfers")

    @agent_transfers.setter
    def agent_transfers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkAgentTransferArgs']]]]):
        pulumi.set(self, "agent_transfers", value)

    @_builtins.property
    @pulumi.getter
    def images(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkImageArgs']]]]:
        """
        (Output)
        Represents an image input or output in the conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "images")

    @images.setter
    def images(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkImageArgs']]]]):
        pulumi.set(self, "images", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Text for the agent to respond with.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter(name="toolCalls")
    def tool_calls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolCallArgs']]]]:
        """
        (Output)
        Request for the client or the agent to execute the specified tool.
        Structure is documented below.
        """
        return pulumi.get(self, "tool_calls")

    @tool_calls.setter
    def tool_calls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolCallArgs']]]]):
        pulumi.set(self, "tool_calls", value)

    @_builtins.property
    @pulumi.getter(name="toolResponses")
    def tool_responses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolResponseArgs']]]]:
        """
        (Output)
        The execution result of a specific tool from the client or the agent.
        Structure is documented below.
        """
        return pulumi.get(self, "tool_responses")

    @tool_responses.setter
    def tool_responses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolResponseArgs']]]]):
        pulumi.set(self, "tool_responses", value)

    @_builtins.property
    @pulumi.getter(name="updatedVariables")
    def updated_variables(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        A struct represents variables that were updated in the conversation,
        keyed by variable names.
        """
        return pulumi.get(self, "updated_variables")

    @updated_variables.setter
    def updated_variables(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_variables", value)


if not MYPY:
    class AppVersionSnapshotExampleMessageChunkAgentTransferArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The display name of the app version.
        """
        target_agent: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The agent to which the conversation is being transferred. The agent will
        handle the conversation from this point forward.
        Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
elif False:
    AppVersionSnapshotExampleMessageChunkAgentTransferArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotExampleMessageChunkAgentTransferArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 target_agent: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: The display name of the app version.
        :param pulumi.Input[_builtins.str] target_agent: (Output)
               The agent to which the conversation is being transferred. The agent will
               handle the conversation from this point forward.
               Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if target_agent is not None:
            pulumi.set(__self__, "target_agent", target_agent)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="targetAgent")
    def target_agent(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The agent to which the conversation is being transferred. The agent will
        handle the conversation from this point forward.
        Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        return pulumi.get(self, "target_agent")

    @target_agent.setter
    def target_agent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_agent", value)


if not MYPY:
    class AppVersionSnapshotExampleMessageChunkImageArgsDict(TypedDict):
        data: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Raw bytes of the image.
        """
        mime_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The IANA standard MIME type of the source data.
        Supported image types includes:
        * image/png
        * image/jpeg
        * image/webp
        """
elif False:
    AppVersionSnapshotExampleMessageChunkImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotExampleMessageChunkImageArgs:
    def __init__(__self__, *,
                 data: Optional[pulumi.Input[_builtins.str]] = None,
                 mime_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] data: (Output)
               Raw bytes of the image.
        :param pulumi.Input[_builtins.str] mime_type: (Output)
               The IANA standard MIME type of the source data.
               Supported image types includes:
               * image/png
               * image/jpeg
               * image/webp
        """
        if data is not None:
            pulumi.set(__self__, "data", data)
        if mime_type is not None:
            pulumi.set(__self__, "mime_type", mime_type)

    @_builtins.property
    @pulumi.getter
    def data(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Raw bytes of the image.
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data", value)

    @_builtins.property
    @pulumi.getter(name="mimeType")
    def mime_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The IANA standard MIME type of the source data.
        Supported image types includes:
        * image/png
        * image/jpeg
        * image/webp
        """
        return pulumi.get(self, "mime_type")

    @mime_type.setter
    def mime_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "mime_type", value)


if not MYPY:
    class AppVersionSnapshotExampleMessageChunkToolCallArgsDict(TypedDict):
        args: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The input parameters and values for the tool in JSON object format.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The display name of the app version.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The matching ID of the tool call the response is for.
        """
        tool: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the tool to execute.
        Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        """
        toolset_tools: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolCallToolsetToolArgsDict']]]]
        """
        (Output)
        A tool that is created from a toolset.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotExampleMessageChunkToolCallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotExampleMessageChunkToolCallArgs:
    def __init__(__self__, *,
                 args: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 tool: Optional[pulumi.Input[_builtins.str]] = None,
                 toolset_tools: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolCallToolsetToolArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] args: (Output)
               The input parameters and values for the tool in JSON object format.
        :param pulumi.Input[_builtins.str] display_name: The display name of the app version.
        :param pulumi.Input[_builtins.str] id: (Output)
               The matching ID of the tool call the response is for.
        :param pulumi.Input[_builtins.str] tool: (Output)
               The name of the tool to execute.
               Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolCallToolsetToolArgs']]] toolset_tools: (Output)
               A tool that is created from a toolset.
               Structure is documented below.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if tool is not None:
            pulumi.set(__self__, "tool", tool)
        if toolset_tools is not None:
            pulumi.set(__self__, "toolset_tools", toolset_tools)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The input parameters and values for the tool in JSON object format.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The matching ID of the tool call the response is for.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def tool(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the tool to execute.
        Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        """
        return pulumi.get(self, "tool")

    @tool.setter
    def tool(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tool", value)

    @_builtins.property
    @pulumi.getter(name="toolsetTools")
    def toolset_tools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolCallToolsetToolArgs']]]]:
        """
        (Output)
        A tool that is created from a toolset.
        Structure is documented below.
        """
        return pulumi.get(self, "toolset_tools")

    @toolset_tools.setter
    def toolset_tools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolCallToolsetToolArgs']]]]):
        pulumi.set(self, "toolset_tools", value)


if not MYPY:
    class AppVersionSnapshotExampleMessageChunkToolCallToolsetToolArgsDict(TypedDict):
        tool_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The tool ID to filter the tools to retrieve the schema for.
        """
        toolset: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The resource name of the Toolset from which this tool is derived.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
elif False:
    AppVersionSnapshotExampleMessageChunkToolCallToolsetToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotExampleMessageChunkToolCallToolsetToolArgs:
    def __init__(__self__, *,
                 tool_id: Optional[pulumi.Input[_builtins.str]] = None,
                 toolset: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] tool_id: (Output)
               The tool ID to filter the tools to retrieve the schema for.
        :param pulumi.Input[_builtins.str] toolset: (Output)
               The resource name of the Toolset from which this tool is derived.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        if tool_id is not None:
            pulumi.set(__self__, "tool_id", tool_id)
        if toolset is not None:
            pulumi.set(__self__, "toolset", toolset)

    @_builtins.property
    @pulumi.getter(name="toolId")
    def tool_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The tool ID to filter the tools to retrieve the schema for.
        """
        return pulumi.get(self, "tool_id")

    @tool_id.setter
    def tool_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tool_id", value)

    @_builtins.property
    @pulumi.getter
    def toolset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The resource name of the Toolset from which this tool is derived.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "toolset")

    @toolset.setter
    def toolset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "toolset", value)


if not MYPY:
    class AppVersionSnapshotExampleMessageChunkToolResponseArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The display name of the app version.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The matching ID of the tool call the response is for.
        """
        response: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        tool: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the tool to execute.
        Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        """
        toolset_tools: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolResponseToolsetToolArgsDict']]]]
        """
        (Output)
        A tool that is created from a toolset.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotExampleMessageChunkToolResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotExampleMessageChunkToolResponseArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 response: Optional[pulumi.Input[_builtins.str]] = None,
                 tool: Optional[pulumi.Input[_builtins.str]] = None,
                 toolset_tools: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolResponseToolsetToolArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] display_name: The display name of the app version.
        :param pulumi.Input[_builtins.str] id: (Output)
               The matching ID of the tool call the response is for.
        :param pulumi.Input[_builtins.str] response: (Output)
               Represents a select subset of an OpenAPI 3.0 schema object.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] tool: (Output)
               The name of the tool to execute.
               Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolResponseToolsetToolArgs']]] toolset_tools: (Output)
               A tool that is created from a toolset.
               Structure is documented below.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if response is not None:
            pulumi.set(__self__, "response", response)
        if tool is not None:
            pulumi.set(__self__, "tool", tool)
        if toolset_tools is not None:
            pulumi.set(__self__, "toolset_tools", toolset_tools)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The matching ID of the tool call the response is for.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "response", value)

    @_builtins.property
    @pulumi.getter
    def tool(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the tool to execute.
        Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        """
        return pulumi.get(self, "tool")

    @tool.setter
    def tool(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tool", value)

    @_builtins.property
    @pulumi.getter(name="toolsetTools")
    def toolset_tools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolResponseToolsetToolArgs']]]]:
        """
        (Output)
        A tool that is created from a toolset.
        Structure is documented below.
        """
        return pulumi.get(self, "toolset_tools")

    @toolset_tools.setter
    def toolset_tools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotExampleMessageChunkToolResponseToolsetToolArgs']]]]):
        pulumi.set(self, "toolset_tools", value)


if not MYPY:
    class AppVersionSnapshotExampleMessageChunkToolResponseToolsetToolArgsDict(TypedDict):
        tool_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The tool ID to filter the tools to retrieve the schema for.
        """
        toolset: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The resource name of the Toolset from which this tool is derived.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
elif False:
    AppVersionSnapshotExampleMessageChunkToolResponseToolsetToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotExampleMessageChunkToolResponseToolsetToolArgs:
    def __init__(__self__, *,
                 tool_id: Optional[pulumi.Input[_builtins.str]] = None,
                 toolset: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] tool_id: (Output)
               The tool ID to filter the tools to retrieve the schema for.
        :param pulumi.Input[_builtins.str] toolset: (Output)
               The resource name of the Toolset from which this tool is derived.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        if tool_id is not None:
            pulumi.set(__self__, "tool_id", tool_id)
        if toolset is not None:
            pulumi.set(__self__, "toolset", toolset)

    @_builtins.property
    @pulumi.getter(name="toolId")
    def tool_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The tool ID to filter the tools to retrieve the schema for.
        """
        return pulumi.get(self, "tool_id")

    @tool_id.setter
    def tool_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tool_id", value)

    @_builtins.property
    @pulumi.getter
    def toolset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The resource name of the Toolset from which this tool is derived.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "toolset")

    @toolset.setter
    def toolset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "toolset", value)


if not MYPY:
    class AppVersionSnapshotGuardrailArgsDict(TypedDict):
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionArgsDict']]]]
        """
        (Output)
        Action that is taken when a certain precondition is met.
        Structure is documented below.
        """
        code_callbacks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackArgsDict']]]]
        """
        (Output)
        Guardrail that blocks the conversation based on the code callbacks
        provided.
        Structure is documented below.
        """
        content_filters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailContentFilterArgsDict']]]]
        """
        (Output)
        Guardrail that bans certain content from being used in the conversation.
        Structure is documented below.
        """
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Timestamp when the toolset was created.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The display name of the app version.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether the guardrail is enabled.
        """
        etag: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        ETag used to ensure the object hasn't changed during a read-modify-write
        operation. If the etag is empty, the update will overwrite any concurrent
        changes.
        """
        llm_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPolicyArgsDict']]]]
        """
        (Output)
        Guardrail that blocks the conversation if the LLM response is considered
        violating the policy based on the LLM classification.
        Structure is documented below.
        """
        llm_prompt_securities: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityArgsDict']]]]
        """
        (Output)
        Guardrail that blocks the conversation if the input is considered unsafe
        based on the LLM classification.
        Structure is documented below.
        """
        model_safeties: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailModelSafetyArgsDict']]]]
        """
        (Output)
        Model safety settings overrides. When this is set, it will override the
        default settings and trigger the guardrail if the response is considered
        unsafe.
        Structure is documented below.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        update_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Timestamp when the toolset was last updated.
        """
elif False:
    AppVersionSnapshotGuardrailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailArgs:
    def __init__(__self__, *,
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionArgs']]]] = None,
                 code_callbacks: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackArgs']]]] = None,
                 content_filters: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailContentFilterArgs']]]] = None,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 etag: Optional[pulumi.Input[_builtins.str]] = None,
                 llm_policies: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPolicyArgs']]]] = None,
                 llm_prompt_securities: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityArgs']]]] = None,
                 model_safeties: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailModelSafetyArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 update_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionArgs']]] actions: (Output)
               Action that is taken when a certain precondition is met.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackArgs']]] code_callbacks: (Output)
               Guardrail that blocks the conversation based on the code callbacks
               provided.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailContentFilterArgs']]] content_filters: (Output)
               Guardrail that bans certain content from being used in the conversation.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] create_time: (Output)
               Timestamp when the toolset was created.
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.str] display_name: The display name of the app version.
        :param pulumi.Input[_builtins.bool] enabled: (Output)
               Whether the guardrail is enabled.
        :param pulumi.Input[_builtins.str] etag: (Output)
               ETag used to ensure the object hasn't changed during a read-modify-write
               operation. If the etag is empty, the update will overwrite any concurrent
               changes.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPolicyArgs']]] llm_policies: (Output)
               Guardrail that blocks the conversation if the LLM response is considered
               violating the policy based on the LLM classification.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityArgs']]] llm_prompt_securities: (Output)
               Guardrail that blocks the conversation if the input is considered unsafe
               based on the LLM classification.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailModelSafetyArgs']]] model_safeties: (Output)
               Model safety settings overrides. When this is set, it will override the
               default settings and trigger the guardrail if the response is considered
               unsafe.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param pulumi.Input[_builtins.str] update_time: (Output)
               Timestamp when the toolset was last updated.
        """
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if code_callbacks is not None:
            pulumi.set(__self__, "code_callbacks", code_callbacks)
        if content_filters is not None:
            pulumi.set(__self__, "content_filters", content_filters)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if etag is not None:
            pulumi.set(__self__, "etag", etag)
        if llm_policies is not None:
            pulumi.set(__self__, "llm_policies", llm_policies)
        if llm_prompt_securities is not None:
            pulumi.set(__self__, "llm_prompt_securities", llm_prompt_securities)
        if model_safeties is not None:
            pulumi.set(__self__, "model_safeties", model_safeties)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionArgs']]]]:
        """
        (Output)
        Action that is taken when a certain precondition is met.
        Structure is documented below.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionArgs']]]]):
        pulumi.set(self, "actions", value)

    @_builtins.property
    @pulumi.getter(name="codeCallbacks")
    def code_callbacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackArgs']]]]:
        """
        (Output)
        Guardrail that blocks the conversation based on the code callbacks
        provided.
        Structure is documented below.
        """
        return pulumi.get(self, "code_callbacks")

    @code_callbacks.setter
    def code_callbacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackArgs']]]]):
        pulumi.set(self, "code_callbacks", value)

    @_builtins.property
    @pulumi.getter(name="contentFilters")
    def content_filters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailContentFilterArgs']]]]:
        """
        (Output)
        Guardrail that bans certain content from being used in the conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "content_filters")

    @content_filters.setter
    def content_filters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailContentFilterArgs']]]]):
        pulumi.set(self, "content_filters", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Timestamp when the toolset was created.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether the guardrail is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def etag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        ETag used to ensure the object hasn't changed during a read-modify-write
        operation. If the etag is empty, the update will overwrite any concurrent
        changes.
        """
        return pulumi.get(self, "etag")

    @etag.setter
    def etag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "etag", value)

    @_builtins.property
    @pulumi.getter(name="llmPolicies")
    def llm_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPolicyArgs']]]]:
        """
        (Output)
        Guardrail that blocks the conversation if the LLM response is considered
        violating the policy based on the LLM classification.
        Structure is documented below.
        """
        return pulumi.get(self, "llm_policies")

    @llm_policies.setter
    def llm_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPolicyArgs']]]]):
        pulumi.set(self, "llm_policies", value)

    @_builtins.property
    @pulumi.getter(name="llmPromptSecurities")
    def llm_prompt_securities(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityArgs']]]]:
        """
        (Output)
        Guardrail that blocks the conversation if the input is considered unsafe
        based on the LLM classification.
        Structure is documented below.
        """
        return pulumi.get(self, "llm_prompt_securities")

    @llm_prompt_securities.setter
    def llm_prompt_securities(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityArgs']]]]):
        pulumi.set(self, "llm_prompt_securities", value)

    @_builtins.property
    @pulumi.getter(name="modelSafeties")
    def model_safeties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailModelSafetyArgs']]]]:
        """
        (Output)
        Model safety settings overrides. When this is set, it will override the
        default settings and trigger the guardrail if the response is considered
        unsafe.
        Structure is documented below.
        """
        return pulumi.get(self, "model_safeties")

    @model_safeties.setter
    def model_safeties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailModelSafetyArgs']]]]):
        pulumi.set(self, "model_safeties", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Timestamp when the toolset was last updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class AppVersionSnapshotGuardrailActionArgsDict(TypedDict):
        generative_answers: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionGenerativeAnswerArgsDict']]]]
        """
        (Output)
        The agent will immediately respond with a generative answer.
        Structure is documented below.
        """
        respond_immediatelies: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionRespondImmediatelyArgsDict']]]]
        """
        (Output)
        The agent will immediately respond with a preconfigured response.
        Structure is documented below.
        """
        transfer_agents: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionTransferAgentArgsDict']]]]
        """
        (Output)
        The agent will transfer the conversation to a different agent.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotGuardrailActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailActionArgs:
    def __init__(__self__, *,
                 generative_answers: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionGenerativeAnswerArgs']]]] = None,
                 respond_immediatelies: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionRespondImmediatelyArgs']]]] = None,
                 transfer_agents: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionTransferAgentArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionGenerativeAnswerArgs']]] generative_answers: (Output)
               The agent will immediately respond with a generative answer.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionRespondImmediatelyArgs']]] respond_immediatelies: (Output)
               The agent will immediately respond with a preconfigured response.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionTransferAgentArgs']]] transfer_agents: (Output)
               The agent will transfer the conversation to a different agent.
               Structure is documented below.
        """
        if generative_answers is not None:
            pulumi.set(__self__, "generative_answers", generative_answers)
        if respond_immediatelies is not None:
            pulumi.set(__self__, "respond_immediatelies", respond_immediatelies)
        if transfer_agents is not None:
            pulumi.set(__self__, "transfer_agents", transfer_agents)

    @_builtins.property
    @pulumi.getter(name="generativeAnswers")
    def generative_answers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionGenerativeAnswerArgs']]]]:
        """
        (Output)
        The agent will immediately respond with a generative answer.
        Structure is documented below.
        """
        return pulumi.get(self, "generative_answers")

    @generative_answers.setter
    def generative_answers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionGenerativeAnswerArgs']]]]):
        pulumi.set(self, "generative_answers", value)

    @_builtins.property
    @pulumi.getter(name="respondImmediatelies")
    def respond_immediatelies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionRespondImmediatelyArgs']]]]:
        """
        (Output)
        The agent will immediately respond with a preconfigured response.
        Structure is documented below.
        """
        return pulumi.get(self, "respond_immediatelies")

    @respond_immediatelies.setter
    def respond_immediatelies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionRespondImmediatelyArgs']]]]):
        pulumi.set(self, "respond_immediatelies", value)

    @_builtins.property
    @pulumi.getter(name="transferAgents")
    def transfer_agents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionTransferAgentArgs']]]]:
        """
        (Output)
        The agent will transfer the conversation to a different agent.
        Structure is documented below.
        """
        return pulumi.get(self, "transfer_agents")

    @transfer_agents.setter
    def transfer_agents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionTransferAgentArgs']]]]):
        pulumi.set(self, "transfer_agents", value)


if not MYPY:
    class AppVersionSnapshotGuardrailActionGenerativeAnswerArgsDict(TypedDict):
        prompt: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The prompt definition. If not set, default prompt will be used.
        """
elif False:
    AppVersionSnapshotGuardrailActionGenerativeAnswerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailActionGenerativeAnswerArgs:
    def __init__(__self__, *,
                 prompt: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] prompt: (Output)
               The prompt definition. If not set, default prompt will be used.
        """
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The prompt definition. If not set, default prompt will be used.
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prompt", value)


if not MYPY:
    class AppVersionSnapshotGuardrailActionRespondImmediatelyArgsDict(TypedDict):
        responses: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionRespondImmediatelyResponseArgsDict']]]]
        """
        (Output)
        The canned responses for the agent to choose from. The response is chosen
        randomly.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotGuardrailActionRespondImmediatelyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailActionRespondImmediatelyArgs:
    def __init__(__self__, *,
                 responses: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionRespondImmediatelyResponseArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionRespondImmediatelyResponseArgs']]] responses: (Output)
               The canned responses for the agent to choose from. The response is chosen
               randomly.
               Structure is documented below.
        """
        if responses is not None:
            pulumi.set(__self__, "responses", responses)

    @_builtins.property
    @pulumi.getter
    def responses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionRespondImmediatelyResponseArgs']]]]:
        """
        (Output)
        The canned responses for the agent to choose from. The response is chosen
        randomly.
        Structure is documented below.
        """
        return pulumi.get(self, "responses")

    @responses.setter
    def responses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailActionRespondImmediatelyResponseArgs']]]]):
        pulumi.set(self, "responses", value)


if not MYPY:
    class AppVersionSnapshotGuardrailActionRespondImmediatelyResponseArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether summarization is disabled.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Text for the agent to respond with.
        """
elif False:
    AppVersionSnapshotGuardrailActionRespondImmediatelyResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailActionRespondImmediatelyResponseArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] disabled: (Output)
               Whether summarization is disabled.
        :param pulumi.Input[_builtins.str] text: (Output)
               Text for the agent to respond with.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if text is not None:
            pulumi.set(__self__, "text", text)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Text for the agent to respond with.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)


if not MYPY:
    class AppVersionSnapshotGuardrailActionTransferAgentArgsDict(TypedDict):
        agent: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the agent to transfer the conversation to. The agent must be
        in the same app as the current agent.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
elif False:
    AppVersionSnapshotGuardrailActionTransferAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailActionTransferAgentArgs:
    def __init__(__self__, *,
                 agent: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] agent: (Output)
               The name of the agent to transfer the conversation to. The agent must be
               in the same app as the current agent.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        if agent is not None:
            pulumi.set(__self__, "agent", agent)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the agent to transfer the conversation to. The agent must be
        in the same app as the current agent.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "agent", value)


if not MYPY:
    class AppVersionSnapshotGuardrailCodeCallbackArgsDict(TypedDict):
        after_agent_callbacks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackAfterAgentCallbackArgsDict']]]]
        """
        (Output)
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        after_model_callbacks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackAfterModelCallbackArgsDict']]]]
        """
        (Output)
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        before_agent_callbacks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackBeforeAgentCallbackArgsDict']]]]
        """
        (Output)
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        before_model_callbacks: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackBeforeModelCallbackArgsDict']]]]
        """
        (Output)
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotGuardrailCodeCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailCodeCallbackArgs:
    def __init__(__self__, *,
                 after_agent_callbacks: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackAfterAgentCallbackArgs']]]] = None,
                 after_model_callbacks: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackAfterModelCallbackArgs']]]] = None,
                 before_agent_callbacks: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackBeforeAgentCallbackArgs']]]] = None,
                 before_model_callbacks: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackBeforeModelCallbackArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackAfterAgentCallbackArgs']]] after_agent_callbacks: (Output)
               A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackAfterModelCallbackArgs']]] after_model_callbacks: (Output)
               A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackBeforeAgentCallbackArgs']]] before_agent_callbacks: (Output)
               A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackBeforeModelCallbackArgs']]] before_model_callbacks: (Output)
               A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        """
        if after_agent_callbacks is not None:
            pulumi.set(__self__, "after_agent_callbacks", after_agent_callbacks)
        if after_model_callbacks is not None:
            pulumi.set(__self__, "after_model_callbacks", after_model_callbacks)
        if before_agent_callbacks is not None:
            pulumi.set(__self__, "before_agent_callbacks", before_agent_callbacks)
        if before_model_callbacks is not None:
            pulumi.set(__self__, "before_model_callbacks", before_model_callbacks)

    @_builtins.property
    @pulumi.getter(name="afterAgentCallbacks")
    def after_agent_callbacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackAfterAgentCallbackArgs']]]]:
        """
        (Output)
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "after_agent_callbacks")

    @after_agent_callbacks.setter
    def after_agent_callbacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackAfterAgentCallbackArgs']]]]):
        pulumi.set(self, "after_agent_callbacks", value)

    @_builtins.property
    @pulumi.getter(name="afterModelCallbacks")
    def after_model_callbacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackAfterModelCallbackArgs']]]]:
        """
        (Output)
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "after_model_callbacks")

    @after_model_callbacks.setter
    def after_model_callbacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackAfterModelCallbackArgs']]]]):
        pulumi.set(self, "after_model_callbacks", value)

    @_builtins.property
    @pulumi.getter(name="beforeAgentCallbacks")
    def before_agent_callbacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackBeforeAgentCallbackArgs']]]]:
        """
        (Output)
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "before_agent_callbacks")

    @before_agent_callbacks.setter
    def before_agent_callbacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackBeforeAgentCallbackArgs']]]]):
        pulumi.set(self, "before_agent_callbacks", value)

    @_builtins.property
    @pulumi.getter(name="beforeModelCallbacks")
    def before_model_callbacks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackBeforeModelCallbackArgs']]]]:
        """
        (Output)
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "before_model_callbacks")

    @before_model_callbacks.setter
    def before_model_callbacks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailCodeCallbackBeforeModelCallbackArgs']]]]):
        pulumi.set(self, "before_model_callbacks", value)


if not MYPY:
    class AppVersionSnapshotGuardrailCodeCallbackAfterAgentCallbackArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether summarization is disabled.
        """
        python_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The Python code to execute for the tool.
        """
elif False:
    AppVersionSnapshotGuardrailCodeCallbackAfterAgentCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailCodeCallbackAfterAgentCallbackArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 python_code: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.bool] disabled: (Output)
               Whether summarization is disabled.
        :param pulumi.Input[_builtins.str] python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "python_code", value)


if not MYPY:
    class AppVersionSnapshotGuardrailCodeCallbackAfterModelCallbackArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether summarization is disabled.
        """
        python_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The Python code to execute for the tool.
        """
elif False:
    AppVersionSnapshotGuardrailCodeCallbackAfterModelCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailCodeCallbackAfterModelCallbackArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 python_code: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.bool] disabled: (Output)
               Whether summarization is disabled.
        :param pulumi.Input[_builtins.str] python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "python_code", value)


if not MYPY:
    class AppVersionSnapshotGuardrailCodeCallbackBeforeAgentCallbackArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether summarization is disabled.
        """
        python_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The Python code to execute for the tool.
        """
elif False:
    AppVersionSnapshotGuardrailCodeCallbackBeforeAgentCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailCodeCallbackBeforeAgentCallbackArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 python_code: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.bool] disabled: (Output)
               Whether summarization is disabled.
        :param pulumi.Input[_builtins.str] python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "python_code", value)


if not MYPY:
    class AppVersionSnapshotGuardrailCodeCallbackBeforeModelCallbackArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether summarization is disabled.
        """
        python_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The Python code to execute for the tool.
        """
elif False:
    AppVersionSnapshotGuardrailCodeCallbackBeforeModelCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailCodeCallbackBeforeModelCallbackArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 python_code: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.bool] disabled: (Output)
               Whether summarization is disabled.
        :param pulumi.Input[_builtins.str] python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "python_code", value)


if not MYPY:
    class AppVersionSnapshotGuardrailContentFilterArgsDict(TypedDict):
        banned_contents: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        List of banned phrases. Applies to both user inputs and agent responses.
        """
        banned_contents_in_agent_responses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        List of banned phrases. Applies only to agent responses.
        """
        banned_contents_in_user_inputs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        List of banned phrases. Applies only to user inputs.
        """
        disregard_diacritics: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        If true, diacritics are ignored during matching.
        """
        match_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Match type for the content filter.
        Possible values:
        SIMPLE_STRING_MATCH
        WORD_BOUNDARY_STRING_MATCH
        REGEXP_MATCH
        """
elif False:
    AppVersionSnapshotGuardrailContentFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailContentFilterArgs:
    def __init__(__self__, *,
                 banned_contents: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 banned_contents_in_agent_responses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 banned_contents_in_user_inputs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 disregard_diacritics: Optional[pulumi.Input[_builtins.bool]] = None,
                 match_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] banned_contents: (Output)
               List of banned phrases. Applies to both user inputs and agent responses.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] banned_contents_in_agent_responses: (Output)
               List of banned phrases. Applies only to agent responses.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] banned_contents_in_user_inputs: (Output)
               List of banned phrases. Applies only to user inputs.
        :param pulumi.Input[_builtins.bool] disregard_diacritics: (Output)
               If true, diacritics are ignored during matching.
        :param pulumi.Input[_builtins.str] match_type: (Output)
               Match type for the content filter.
               Possible values:
               SIMPLE_STRING_MATCH
               WORD_BOUNDARY_STRING_MATCH
               REGEXP_MATCH
        """
        if banned_contents is not None:
            pulumi.set(__self__, "banned_contents", banned_contents)
        if banned_contents_in_agent_responses is not None:
            pulumi.set(__self__, "banned_contents_in_agent_responses", banned_contents_in_agent_responses)
        if banned_contents_in_user_inputs is not None:
            pulumi.set(__self__, "banned_contents_in_user_inputs", banned_contents_in_user_inputs)
        if disregard_diacritics is not None:
            pulumi.set(__self__, "disregard_diacritics", disregard_diacritics)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)

    @_builtins.property
    @pulumi.getter(name="bannedContents")
    def banned_contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        List of banned phrases. Applies to both user inputs and agent responses.
        """
        return pulumi.get(self, "banned_contents")

    @banned_contents.setter
    def banned_contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "banned_contents", value)

    @_builtins.property
    @pulumi.getter(name="bannedContentsInAgentResponses")
    def banned_contents_in_agent_responses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        List of banned phrases. Applies only to agent responses.
        """
        return pulumi.get(self, "banned_contents_in_agent_responses")

    @banned_contents_in_agent_responses.setter
    def banned_contents_in_agent_responses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "banned_contents_in_agent_responses", value)

    @_builtins.property
    @pulumi.getter(name="bannedContentsInUserInputs")
    def banned_contents_in_user_inputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        List of banned phrases. Applies only to user inputs.
        """
        return pulumi.get(self, "banned_contents_in_user_inputs")

    @banned_contents_in_user_inputs.setter
    def banned_contents_in_user_inputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "banned_contents_in_user_inputs", value)

    @_builtins.property
    @pulumi.getter(name="disregardDiacritics")
    def disregard_diacritics(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        If true, diacritics are ignored during matching.
        """
        return pulumi.get(self, "disregard_diacritics")

    @disregard_diacritics.setter
    def disregard_diacritics(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disregard_diacritics", value)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Match type for the content filter.
        Possible values:
        SIMPLE_STRING_MATCH
        WORD_BOUNDARY_STRING_MATCH
        REGEXP_MATCH
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "match_type", value)


if not MYPY:
    class AppVersionSnapshotGuardrailLlmPolicyArgsDict(TypedDict):
        fail_open: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        If an error occurs during the policy check, fail open and do not trigger
        the guardrail.
        """
        max_conversation_messages: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Output)
        When checking this policy, consider the last 'n' messages in the
        conversation.
        When not set a default value of 10 will be used.
        """
        model_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPolicyModelSettingArgsDict']]]]
        """
        (Output)
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        policy_scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Defines when to apply the policy check during the conversation. If set to
        `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
        When applying the policy to the agent response, additional latency will
        be introduced before the agent can respond.
        Possible values:
        USER_QUERY
        AGENT_RESPONSE
        USER_QUERY_AND_AGENT_RESPONSE
        """
        prompt: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The prompt definition. If not set, default prompt will be used.
        """
elif False:
    AppVersionSnapshotGuardrailLlmPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailLlmPolicyArgs:
    def __init__(__self__, *,
                 fail_open: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_conversation_messages: Optional[pulumi.Input[_builtins.int]] = None,
                 model_settings: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPolicyModelSettingArgs']]]] = None,
                 policy_scope: Optional[pulumi.Input[_builtins.str]] = None,
                 prompt: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] fail_open: (Output)
               If an error occurs during the policy check, fail open and do not trigger
               the guardrail.
        :param pulumi.Input[_builtins.int] max_conversation_messages: (Output)
               When checking this policy, consider the last 'n' messages in the
               conversation.
               When not set a default value of 10 will be used.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPolicyModelSettingArgs']]] model_settings: (Output)
               Model settings contains various configurations for the LLM model.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] policy_scope: (Output)
               Defines when to apply the policy check during the conversation. If set to
               `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
               When applying the policy to the agent response, additional latency will
               be introduced before the agent can respond.
               Possible values:
               USER_QUERY
               AGENT_RESPONSE
               USER_QUERY_AND_AGENT_RESPONSE
        :param pulumi.Input[_builtins.str] prompt: (Output)
               The prompt definition. If not set, default prompt will be used.
        """
        if fail_open is not None:
            pulumi.set(__self__, "fail_open", fail_open)
        if max_conversation_messages is not None:
            pulumi.set(__self__, "max_conversation_messages", max_conversation_messages)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)
        if policy_scope is not None:
            pulumi.set(__self__, "policy_scope", policy_scope)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        If an error occurs during the policy check, fail open and do not trigger
        the guardrail.
        """
        return pulumi.get(self, "fail_open")

    @fail_open.setter
    def fail_open(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "fail_open", value)

    @_builtins.property
    @pulumi.getter(name="maxConversationMessages")
    def max_conversation_messages(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Output)
        When checking this policy, consider the last 'n' messages in the
        conversation.
        When not set a default value of 10 will be used.
        """
        return pulumi.get(self, "max_conversation_messages")

    @max_conversation_messages.setter
    def max_conversation_messages(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_conversation_messages", value)

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPolicyModelSettingArgs']]]]:
        """
        (Output)
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @model_settings.setter
    def model_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPolicyModelSettingArgs']]]]):
        pulumi.set(self, "model_settings", value)

    @_builtins.property
    @pulumi.getter(name="policyScope")
    def policy_scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Defines when to apply the policy check during the conversation. If set to
        `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
        When applying the policy to the agent response, additional latency will
        be introduced before the agent can respond.
        Possible values:
        USER_QUERY
        AGENT_RESPONSE
        USER_QUERY_AND_AGENT_RESPONSE
        """
        return pulumi.get(self, "policy_scope")

    @policy_scope.setter
    def policy_scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy_scope", value)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The prompt definition. If not set, default prompt will be used.
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prompt", value)


if not MYPY:
    class AppVersionSnapshotGuardrailLlmPolicyModelSettingArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Output)
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
elif False:
    AppVersionSnapshotGuardrailLlmPolicyModelSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailLlmPolicyModelSettingArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] model: (Output)
               The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param pulumi.Input[_builtins.float] temperature: (Output)
               If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Output)
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)


if not MYPY:
    class AppVersionSnapshotGuardrailLlmPromptSecurityArgsDict(TypedDict):
        custom_policies: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyArgsDict']]]]
        """
        (Output)
        Guardrail that blocks the conversation if the LLM response is considered
        violating the policy based on the LLM classification.
        Structure is documented below.
        """
        default_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityDefaultSettingArgsDict']]]]
        """
        (Output)
        Configuration for default system security settings.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotGuardrailLlmPromptSecurityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailLlmPromptSecurityArgs:
    def __init__(__self__, *,
                 custom_policies: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyArgs']]]] = None,
                 default_settings: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityDefaultSettingArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyArgs']]] custom_policies: (Output)
               Guardrail that blocks the conversation if the LLM response is considered
               violating the policy based on the LLM classification.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityDefaultSettingArgs']]] default_settings: (Output)
               Configuration for default system security settings.
               Structure is documented below.
        """
        if custom_policies is not None:
            pulumi.set(__self__, "custom_policies", custom_policies)
        if default_settings is not None:
            pulumi.set(__self__, "default_settings", default_settings)

    @_builtins.property
    @pulumi.getter(name="customPolicies")
    def custom_policies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyArgs']]]]:
        """
        (Output)
        Guardrail that blocks the conversation if the LLM response is considered
        violating the policy based on the LLM classification.
        Structure is documented below.
        """
        return pulumi.get(self, "custom_policies")

    @custom_policies.setter
    def custom_policies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyArgs']]]]):
        pulumi.set(self, "custom_policies", value)

    @_builtins.property
    @pulumi.getter(name="defaultSettings")
    def default_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityDefaultSettingArgs']]]]:
        """
        (Output)
        Configuration for default system security settings.
        Structure is documented below.
        """
        return pulumi.get(self, "default_settings")

    @default_settings.setter
    def default_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityDefaultSettingArgs']]]]):
        pulumi.set(self, "default_settings", value)


if not MYPY:
    class AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyArgsDict(TypedDict):
        fail_open: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        If an error occurs during the policy check, fail open and do not trigger
        the guardrail.
        """
        max_conversation_messages: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Output)
        When checking this policy, consider the last 'n' messages in the
        conversation.
        When not set a default value of 10 will be used.
        """
        model_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyModelSettingArgsDict']]]]
        """
        (Output)
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        policy_scope: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Defines when to apply the policy check during the conversation. If set to
        `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
        When applying the policy to the agent response, additional latency will
        be introduced before the agent can respond.
        Possible values:
        USER_QUERY
        AGENT_RESPONSE
        USER_QUERY_AND_AGENT_RESPONSE
        """
        prompt: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The prompt definition. If not set, default prompt will be used.
        """
elif False:
    AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyArgs:
    def __init__(__self__, *,
                 fail_open: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_conversation_messages: Optional[pulumi.Input[_builtins.int]] = None,
                 model_settings: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyModelSettingArgs']]]] = None,
                 policy_scope: Optional[pulumi.Input[_builtins.str]] = None,
                 prompt: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] fail_open: (Output)
               If an error occurs during the policy check, fail open and do not trigger
               the guardrail.
        :param pulumi.Input[_builtins.int] max_conversation_messages: (Output)
               When checking this policy, consider the last 'n' messages in the
               conversation.
               When not set a default value of 10 will be used.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyModelSettingArgs']]] model_settings: (Output)
               Model settings contains various configurations for the LLM model.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] policy_scope: (Output)
               Defines when to apply the policy check during the conversation. If set to
               `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
               When applying the policy to the agent response, additional latency will
               be introduced before the agent can respond.
               Possible values:
               USER_QUERY
               AGENT_RESPONSE
               USER_QUERY_AND_AGENT_RESPONSE
        :param pulumi.Input[_builtins.str] prompt: (Output)
               The prompt definition. If not set, default prompt will be used.
        """
        if fail_open is not None:
            pulumi.set(__self__, "fail_open", fail_open)
        if max_conversation_messages is not None:
            pulumi.set(__self__, "max_conversation_messages", max_conversation_messages)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)
        if policy_scope is not None:
            pulumi.set(__self__, "policy_scope", policy_scope)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        If an error occurs during the policy check, fail open and do not trigger
        the guardrail.
        """
        return pulumi.get(self, "fail_open")

    @fail_open.setter
    def fail_open(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "fail_open", value)

    @_builtins.property
    @pulumi.getter(name="maxConversationMessages")
    def max_conversation_messages(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Output)
        When checking this policy, consider the last 'n' messages in the
        conversation.
        When not set a default value of 10 will be used.
        """
        return pulumi.get(self, "max_conversation_messages")

    @max_conversation_messages.setter
    def max_conversation_messages(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_conversation_messages", value)

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyModelSettingArgs']]]]:
        """
        (Output)
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @model_settings.setter
    def model_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyModelSettingArgs']]]]):
        pulumi.set(self, "model_settings", value)

    @_builtins.property
    @pulumi.getter(name="policyScope")
    def policy_scope(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Defines when to apply the policy check during the conversation. If set to
        `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
        When applying the policy to the agent response, additional latency will
        be introduced before the agent can respond.
        Possible values:
        USER_QUERY
        AGENT_RESPONSE
        USER_QUERY_AND_AGENT_RESPONSE
        """
        return pulumi.get(self, "policy_scope")

    @policy_scope.setter
    def policy_scope(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "policy_scope", value)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The prompt definition. If not set, default prompt will be used.
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prompt", value)


if not MYPY:
    class AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyModelSettingArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Output)
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
elif False:
    AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyModelSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailLlmPromptSecurityCustomPolicyModelSettingArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] model: (Output)
               The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param pulumi.Input[_builtins.float] temperature: (Output)
               If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Output)
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)


if not MYPY:
    class AppVersionSnapshotGuardrailLlmPromptSecurityDefaultSettingArgsDict(TypedDict):
        default_prompt_template: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The default prompt template used by the system.
        This field is for display purposes to show the user what prompt
        the system uses by default. It is OUTPUT_ONLY.
        """
elif False:
    AppVersionSnapshotGuardrailLlmPromptSecurityDefaultSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailLlmPromptSecurityDefaultSettingArgs:
    def __init__(__self__, *,
                 default_prompt_template: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] default_prompt_template: (Output)
               The default prompt template used by the system.
               This field is for display purposes to show the user what prompt
               the system uses by default. It is OUTPUT_ONLY.
        """
        if default_prompt_template is not None:
            pulumi.set(__self__, "default_prompt_template", default_prompt_template)

    @_builtins.property
    @pulumi.getter(name="defaultPromptTemplate")
    def default_prompt_template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The default prompt template used by the system.
        This field is for display purposes to show the user what prompt
        the system uses by default. It is OUTPUT_ONLY.
        """
        return pulumi.get(self, "default_prompt_template")

    @default_prompt_template.setter
    def default_prompt_template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_prompt_template", value)


if not MYPY:
    class AppVersionSnapshotGuardrailModelSafetyArgsDict(TypedDict):
        safety_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailModelSafetySafetySettingArgsDict']]]]
        """
        (Output)
        List of safety settings.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotGuardrailModelSafetyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailModelSafetyArgs:
    def __init__(__self__, *,
                 safety_settings: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailModelSafetySafetySettingArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailModelSafetySafetySettingArgs']]] safety_settings: (Output)
               List of safety settings.
               Structure is documented below.
        """
        if safety_settings is not None:
            pulumi.set(__self__, "safety_settings", safety_settings)

    @_builtins.property
    @pulumi.getter(name="safetySettings")
    def safety_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailModelSafetySafetySettingArgs']]]]:
        """
        (Output)
        List of safety settings.
        Structure is documented below.
        """
        return pulumi.get(self, "safety_settings")

    @safety_settings.setter
    def safety_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotGuardrailModelSafetySafetySettingArgs']]]]):
        pulumi.set(self, "safety_settings", value)


if not MYPY:
    class AppVersionSnapshotGuardrailModelSafetySafetySettingArgsDict(TypedDict):
        category: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The harm category.
        Possible values:
        HARM_CATEGORY_HATE_SPEECH
        HARM_CATEGORY_DANGEROUS_CONTENT
        HARM_CATEGORY_HARASSMENT
        HARM_CATEGORY_SEXUALLY_EXPLICIT
        """
        threshold: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The harm block threshold.
        Possible values:
        BLOCK_LOW_AND_ABOVE
        BLOCK_MEDIUM_AND_ABOVE
        BLOCK_ONLY_HIGH
        BLOCK_NONE
        OFF
        """
elif False:
    AppVersionSnapshotGuardrailModelSafetySafetySettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotGuardrailModelSafetySafetySettingArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[_builtins.str]] = None,
                 threshold: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] category: (Output)
               The harm category.
               Possible values:
               HARM_CATEGORY_HATE_SPEECH
               HARM_CATEGORY_DANGEROUS_CONTENT
               HARM_CATEGORY_HARASSMENT
               HARM_CATEGORY_SEXUALLY_EXPLICIT
        :param pulumi.Input[_builtins.str] threshold: (Output)
               The harm block threshold.
               Possible values:
               BLOCK_LOW_AND_ABOVE
               BLOCK_MEDIUM_AND_ABOVE
               BLOCK_ONLY_HIGH
               BLOCK_NONE
               OFF
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if threshold is not None:
            pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The harm category.
        Possible values:
        HARM_CATEGORY_HATE_SPEECH
        HARM_CATEGORY_DANGEROUS_CONTENT
        HARM_CATEGORY_HARASSMENT
        HARM_CATEGORY_SEXUALLY_EXPLICIT
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The harm block threshold.
        Possible values:
        BLOCK_LOW_AND_ABOVE
        BLOCK_MEDIUM_AND_ABOVE
        BLOCK_ONLY_HIGH
        BLOCK_NONE
        OFF
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class AppVersionSnapshotToolArgsDict(TypedDict):
        client_functions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolClientFunctionArgsDict']]]]
        """
        (Output)
        Represents a client-side function that the agent can invoke. When the
        tool is chosen by the agent, control is handed off to the client.
        The client is responsible for executing the function and returning the result
        as a ToolResponse to continue the interaction with the agent.
        Structure is documented below.
        """
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Timestamp when the toolset was created.
        """
        data_store_tools: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolArgsDict']]]]
        """
        (Output)
        Tool to retrieve from Vertex AI Search datastore or engine for grounding.
        Accepts either a datastore or an engine, but not both.
        See Vertex AI Search:
        https://cloud.google.com/generative-ai-app-builder/docs/enterprise-search-introduction.
        Structure is documented below.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The display name of the app version.
        """
        etag: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        ETag used to ensure the object hasn't changed during a read-modify-write
        operation. If the etag is empty, the update will overwrite any concurrent
        changes.
        """
        execution_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Possible values:
        SYNCHRONOUS
        ASYNCHRONOUS
        """
        generated_summary: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        If the tool is generated by the LLM assistant, this field contains a
        descriptive summary of the generation.
        """
        google_search_tools: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolGoogleSearchToolArgsDict']]]]
        """
        (Output)
        Represents a tool to perform Google web searches for grounding.
        See
        https://cloud.google.com/vertex-ai/generative-ai/docs/grounding/grounding-with-google-search.
        Structure is documented below.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        open_api_tools: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolArgsDict']]]]
        """
        (Output)
        A remote API tool defined by an OpenAPI schema.
        Structure is documented below.
        """
        python_functions: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolPythonFunctionArgsDict']]]]
        """
        (Output)
        A Python function tool.
        Structure is documented below.
        """
        system_tools: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolSystemToolArgsDict']]]]
        """
        (Output)
        The system tool.
        Structure is documented below.
        """
        update_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Timestamp when the toolset was last updated.
        """
elif False:
    AppVersionSnapshotToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolArgs:
    def __init__(__self__, *,
                 client_functions: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolClientFunctionArgs']]]] = None,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 data_store_tools: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolArgs']]]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 etag: Optional[pulumi.Input[_builtins.str]] = None,
                 execution_type: Optional[pulumi.Input[_builtins.str]] = None,
                 generated_summary: Optional[pulumi.Input[_builtins.str]] = None,
                 google_search_tools: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolGoogleSearchToolArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 open_api_tools: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolArgs']]]] = None,
                 python_functions: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolPythonFunctionArgs']]]] = None,
                 system_tools: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolSystemToolArgs']]]] = None,
                 update_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolClientFunctionArgs']]] client_functions: (Output)
               Represents a client-side function that the agent can invoke. When the
               tool is chosen by the agent, control is handed off to the client.
               The client is responsible for executing the function and returning the result
               as a ToolResponse to continue the interaction with the agent.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] create_time: (Output)
               Timestamp when the toolset was created.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolArgs']]] data_store_tools: (Output)
               Tool to retrieve from Vertex AI Search datastore or engine for grounding.
               Accepts either a datastore or an engine, but not both.
               See Vertex AI Search:
               https://cloud.google.com/generative-ai-app-builder/docs/enterprise-search-introduction.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] display_name: The display name of the app version.
        :param pulumi.Input[_builtins.str] etag: (Output)
               ETag used to ensure the object hasn't changed during a read-modify-write
               operation. If the etag is empty, the update will overwrite any concurrent
               changes.
        :param pulumi.Input[_builtins.str] execution_type: (Output)
               Possible values:
               SYNCHRONOUS
               ASYNCHRONOUS
        :param pulumi.Input[_builtins.str] generated_summary: (Output)
               If the tool is generated by the LLM assistant, this field contains a
               descriptive summary of the generation.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolGoogleSearchToolArgs']]] google_search_tools: (Output)
               Represents a tool to perform Google web searches for grounding.
               See
               https://cloud.google.com/vertex-ai/generative-ai/docs/grounding/grounding-with-google-search.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolArgs']]] open_api_tools: (Output)
               A remote API tool defined by an OpenAPI schema.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolPythonFunctionArgs']]] python_functions: (Output)
               A Python function tool.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolSystemToolArgs']]] system_tools: (Output)
               The system tool.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] update_time: (Output)
               Timestamp when the toolset was last updated.
        """
        if client_functions is not None:
            pulumi.set(__self__, "client_functions", client_functions)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if data_store_tools is not None:
            pulumi.set(__self__, "data_store_tools", data_store_tools)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if etag is not None:
            pulumi.set(__self__, "etag", etag)
        if execution_type is not None:
            pulumi.set(__self__, "execution_type", execution_type)
        if generated_summary is not None:
            pulumi.set(__self__, "generated_summary", generated_summary)
        if google_search_tools is not None:
            pulumi.set(__self__, "google_search_tools", google_search_tools)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if open_api_tools is not None:
            pulumi.set(__self__, "open_api_tools", open_api_tools)
        if python_functions is not None:
            pulumi.set(__self__, "python_functions", python_functions)
        if system_tools is not None:
            pulumi.set(__self__, "system_tools", system_tools)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="clientFunctions")
    def client_functions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolClientFunctionArgs']]]]:
        """
        (Output)
        Represents a client-side function that the agent can invoke. When the
        tool is chosen by the agent, control is handed off to the client.
        The client is responsible for executing the function and returning the result
        as a ToolResponse to continue the interaction with the agent.
        Structure is documented below.
        """
        return pulumi.get(self, "client_functions")

    @client_functions.setter
    def client_functions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolClientFunctionArgs']]]]):
        pulumi.set(self, "client_functions", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Timestamp when the toolset was created.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter(name="dataStoreTools")
    def data_store_tools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolArgs']]]]:
        """
        (Output)
        Tool to retrieve from Vertex AI Search datastore or engine for grounding.
        Accepts either a datastore or an engine, but not both.
        See Vertex AI Search:
        https://cloud.google.com/generative-ai-app-builder/docs/enterprise-search-introduction.
        Structure is documented below.
        """
        return pulumi.get(self, "data_store_tools")

    @data_store_tools.setter
    def data_store_tools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolArgs']]]]):
        pulumi.set(self, "data_store_tools", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def etag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        ETag used to ensure the object hasn't changed during a read-modify-write
        operation. If the etag is empty, the update will overwrite any concurrent
        changes.
        """
        return pulumi.get(self, "etag")

    @etag.setter
    def etag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "etag", value)

    @_builtins.property
    @pulumi.getter(name="executionType")
    def execution_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Possible values:
        SYNCHRONOUS
        ASYNCHRONOUS
        """
        return pulumi.get(self, "execution_type")

    @execution_type.setter
    def execution_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "execution_type", value)

    @_builtins.property
    @pulumi.getter(name="generatedSummary")
    def generated_summary(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        If the tool is generated by the LLM assistant, this field contains a
        descriptive summary of the generation.
        """
        return pulumi.get(self, "generated_summary")

    @generated_summary.setter
    def generated_summary(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "generated_summary", value)

    @_builtins.property
    @pulumi.getter(name="googleSearchTools")
    def google_search_tools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolGoogleSearchToolArgs']]]]:
        """
        (Output)
        Represents a tool to perform Google web searches for grounding.
        See
        https://cloud.google.com/vertex-ai/generative-ai/docs/grounding/grounding-with-google-search.
        Structure is documented below.
        """
        return pulumi.get(self, "google_search_tools")

    @google_search_tools.setter
    def google_search_tools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolGoogleSearchToolArgs']]]]):
        pulumi.set(self, "google_search_tools", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="openApiTools")
    def open_api_tools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolArgs']]]]:
        """
        (Output)
        A remote API tool defined by an OpenAPI schema.
        Structure is documented below.
        """
        return pulumi.get(self, "open_api_tools")

    @open_api_tools.setter
    def open_api_tools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolArgs']]]]):
        pulumi.set(self, "open_api_tools", value)

    @_builtins.property
    @pulumi.getter(name="pythonFunctions")
    def python_functions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolPythonFunctionArgs']]]]:
        """
        (Output)
        A Python function tool.
        Structure is documented below.
        """
        return pulumi.get(self, "python_functions")

    @python_functions.setter
    def python_functions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolPythonFunctionArgs']]]]):
        pulumi.set(self, "python_functions", value)

    @_builtins.property
    @pulumi.getter(name="systemTools")
    def system_tools(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolSystemToolArgs']]]]:
        """
        (Output)
        The system tool.
        Structure is documented below.
        """
        return pulumi.get(self, "system_tools")

    @system_tools.setter
    def system_tools(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolSystemToolArgs']]]]):
        pulumi.set(self, "system_tools", value)

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Timestamp when the toolset was last updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class AppVersionSnapshotToolClientFunctionArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        parameters: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolClientFunctionParameterArgsDict']]]]
        """
        (Output)
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        responses: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolClientFunctionResponseArgsDict']]]]
        """
        (Output)
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotToolClientFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolClientFunctionArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 parameters: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolClientFunctionParameterArgs']]]] = None,
                 responses: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolClientFunctionResponseArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.str] name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolClientFunctionParameterArgs']]] parameters: (Output)
               Represents a select subset of an OpenAPI 3.0 schema object.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolClientFunctionResponseArgs']]] responses: (Output)
               Represents a select subset of an OpenAPI 3.0 schema object.
               Structure is documented below.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if responses is not None:
            pulumi.set(__self__, "responses", responses)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolClientFunctionParameterArgs']]]]:
        """
        (Output)
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolClientFunctionParameterArgs']]]]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter
    def responses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolClientFunctionResponseArgs']]]]:
        """
        (Output)
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        return pulumi.get(self, "responses")

    @responses.setter
    def responses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolClientFunctionResponseArgs']]]]):
        pulumi.set(self, "responses", value)


if not MYPY:
    class AppVersionSnapshotToolClientFunctionParameterArgsDict(TypedDict):
        additional_properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        any_of: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        default: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        defs: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        enums: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        items: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Schema of the elements of Type.ARRAY.
        """
        nullable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Indicates if the value may be null.
        """
        prefix_items: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Properties of Type.OBJECT.
        """
        ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        requireds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        Required properties of Type.OBJECT.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR
        """
        unique_items: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
elif False:
    AppVersionSnapshotToolClientFunctionParameterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolClientFunctionParameterArgs:
    def __init__(__self__, *,
                 additional_properties: Optional[pulumi.Input[_builtins.str]] = None,
                 any_of: Optional[pulumi.Input[_builtins.str]] = None,
                 default: Optional[pulumi.Input[_builtins.str]] = None,
                 defs: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enums: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 items: Optional[pulumi.Input[_builtins.str]] = None,
                 nullable: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix_items: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[_builtins.str]] = None,
                 ref: Optional[pulumi.Input[_builtins.str]] = None,
                 requireds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 unique_items: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] additional_properties: (Output)
               Optional. Defines the schema for additional properties allowed in an object.
               The value must be a valid JSON string representing the Schema object.
               (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        :param pulumi.Input[_builtins.str] any_of: (Output)
               Optional. The instance value should be valid against at least one of the schemas in this list.
        :param pulumi.Input[_builtins.str] default: (Output)
               Optional. Default value of the data. Represents a dynamically typed value
               which can be either null, a number, a string, a boolean, a struct,
               or a list of values. The provided default value must be compatible
               with the defined 'type' and other schema constraints.
        :param pulumi.Input[_builtins.str] defs: (Output)
               A map of definitions for use by ref. Only allowed at the root of the schema.
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enums: (Output)
               Possible values of the element of primitive type with enum format.
               Examples:
               1. We can define direction as :
               {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
               2. We can define apartment number as :
               {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        :param pulumi.Input[_builtins.str] items: (Output)
               Schema of the elements of Type.ARRAY.
        :param pulumi.Input[_builtins.bool] nullable: (Output)
               Indicates if the value may be null.
        :param pulumi.Input[_builtins.str] prefix_items: (Output)
               Optional. Schemas of initial elements of Type.ARRAY.
        :param pulumi.Input[_builtins.str] properties: (Output)
               Properties of Type.OBJECT.
        :param pulumi.Input[_builtins.str] ref: (Output)
               Allows indirect references between schema nodes. The value should be a
               valid reference to a child of the root `defs`.
               For example, the following schema defines a reference to a schema node
               named "Pet":
               type: object
               properties:
               pet:
               ref: #/defs/Pet
               defs:
               Pet:
               type: object
               properties:
               name:
               type: string
               The value of the "pet" property is a reference to the schema node
               named "Pet".
               See details in
               https://json-schema.org/understanding-json-schema/structuring.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] requireds: (Output)
               Required properties of Type.OBJECT.
        :param pulumi.Input[_builtins.str] type: (Output)
               The type of the data store. This field is readonly and populated by the
               server.
               Possible values:
               PUBLIC_WEB
               UNSTRUCTURED
               FAQ
               CONNECTOR
        :param pulumi.Input[_builtins.bool] unique_items: (Output)
               Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if any_of is not None:
            pulumi.set(__self__, "any_of", any_of)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if defs is not None:
            pulumi.set(__self__, "defs", defs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enums is not None:
            pulumi.set(__self__, "enums", enums)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if prefix_items is not None:
            pulumi.set(__self__, "prefix_items", prefix_items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if requireds is not None:
            pulumi.set(__self__, "requireds", requireds)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)

    @_builtins.property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_properties", value)

    @_builtins.property
    @pulumi.getter(name="anyOf")
    def any_of(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        return pulumi.get(self, "any_of")

    @any_of.setter
    def any_of(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "any_of", value)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def defs(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        return pulumi.get(self, "defs")

    @defs.setter
    def defs(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "defs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def enums(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        return pulumi.get(self, "enums")

    @enums.setter
    def enums(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enums", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Schema of the elements of Type.ARRAY.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Indicates if the value may be null.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "nullable", value)

    @_builtins.property
    @pulumi.getter(name="prefixItems")
    def prefix_items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        return pulumi.get(self, "prefix_items")

    @prefix_items.setter
    def prefix_items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_items", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Properties of Type.OBJECT.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ref", value)

    @_builtins.property
    @pulumi.getter
    def requireds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        Required properties of Type.OBJECT.
        """
        return pulumi.get(self, "requireds")

    @requireds.setter
    def requireds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "requireds", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        return pulumi.get(self, "unique_items")

    @unique_items.setter
    def unique_items(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unique_items", value)


if not MYPY:
    class AppVersionSnapshotToolClientFunctionResponseArgsDict(TypedDict):
        additional_properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        any_of: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        default: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        defs: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        enums: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        items: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Schema of the elements of Type.ARRAY.
        """
        nullable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Indicates if the value may be null.
        """
        prefix_items: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Properties of Type.OBJECT.
        """
        ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        requireds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        Required properties of Type.OBJECT.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR
        """
        unique_items: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
elif False:
    AppVersionSnapshotToolClientFunctionResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolClientFunctionResponseArgs:
    def __init__(__self__, *,
                 additional_properties: Optional[pulumi.Input[_builtins.str]] = None,
                 any_of: Optional[pulumi.Input[_builtins.str]] = None,
                 default: Optional[pulumi.Input[_builtins.str]] = None,
                 defs: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enums: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 items: Optional[pulumi.Input[_builtins.str]] = None,
                 nullable: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix_items: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[_builtins.str]] = None,
                 ref: Optional[pulumi.Input[_builtins.str]] = None,
                 requireds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None,
                 unique_items: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] additional_properties: (Output)
               Optional. Defines the schema for additional properties allowed in an object.
               The value must be a valid JSON string representing the Schema object.
               (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        :param pulumi.Input[_builtins.str] any_of: (Output)
               Optional. The instance value should be valid against at least one of the schemas in this list.
        :param pulumi.Input[_builtins.str] default: (Output)
               Optional. Default value of the data. Represents a dynamically typed value
               which can be either null, a number, a string, a boolean, a struct,
               or a list of values. The provided default value must be compatible
               with the defined 'type' and other schema constraints.
        :param pulumi.Input[_builtins.str] defs: (Output)
               A map of definitions for use by ref. Only allowed at the root of the schema.
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enums: (Output)
               Possible values of the element of primitive type with enum format.
               Examples:
               1. We can define direction as :
               {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
               2. We can define apartment number as :
               {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        :param pulumi.Input[_builtins.str] items: (Output)
               Schema of the elements of Type.ARRAY.
        :param pulumi.Input[_builtins.bool] nullable: (Output)
               Indicates if the value may be null.
        :param pulumi.Input[_builtins.str] prefix_items: (Output)
               Optional. Schemas of initial elements of Type.ARRAY.
        :param pulumi.Input[_builtins.str] properties: (Output)
               Properties of Type.OBJECT.
        :param pulumi.Input[_builtins.str] ref: (Output)
               Allows indirect references between schema nodes. The value should be a
               valid reference to a child of the root `defs`.
               For example, the following schema defines a reference to a schema node
               named "Pet":
               type: object
               properties:
               pet:
               ref: #/defs/Pet
               defs:
               Pet:
               type: object
               properties:
               name:
               type: string
               The value of the "pet" property is a reference to the schema node
               named "Pet".
               See details in
               https://json-schema.org/understanding-json-schema/structuring.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] requireds: (Output)
               Required properties of Type.OBJECT.
        :param pulumi.Input[_builtins.str] type: (Output)
               The type of the data store. This field is readonly and populated by the
               server.
               Possible values:
               PUBLIC_WEB
               UNSTRUCTURED
               FAQ
               CONNECTOR
        :param pulumi.Input[_builtins.bool] unique_items: (Output)
               Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if any_of is not None:
            pulumi.set(__self__, "any_of", any_of)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if defs is not None:
            pulumi.set(__self__, "defs", defs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enums is not None:
            pulumi.set(__self__, "enums", enums)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if prefix_items is not None:
            pulumi.set(__self__, "prefix_items", prefix_items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if requireds is not None:
            pulumi.set(__self__, "requireds", requireds)
        if type is not None:
            pulumi.set(__self__, "type", type)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)

    @_builtins.property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_properties", value)

    @_builtins.property
    @pulumi.getter(name="anyOf")
    def any_of(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        return pulumi.get(self, "any_of")

    @any_of.setter
    def any_of(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "any_of", value)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def defs(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        return pulumi.get(self, "defs")

    @defs.setter
    def defs(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "defs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def enums(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        return pulumi.get(self, "enums")

    @enums.setter
    def enums(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enums", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Schema of the elements of Type.ARRAY.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Indicates if the value may be null.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "nullable", value)

    @_builtins.property
    @pulumi.getter(name="prefixItems")
    def prefix_items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        return pulumi.get(self, "prefix_items")

    @prefix_items.setter
    def prefix_items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_items", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Properties of Type.OBJECT.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ref", value)

    @_builtins.property
    @pulumi.getter
    def requireds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        Required properties of Type.OBJECT.
        """
        return pulumi.get(self, "requireds")

    @requireds.setter
    def requireds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "requireds", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        return pulumi.get(self, "unique_items")

    @unique_items.setter
    def unique_items(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unique_items", value)


if not MYPY:
    class AppVersionSnapshotToolDataStoreToolArgsDict(TypedDict):
        boost_specs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecArgsDict']]]]
        """
        (Output)
        Boost specification to boost certain documents.
        Structure is documented below.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        engine_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceArgsDict']]]]
        """
        (Output)
        Configuration for searching within an Engine, potentially targeting
        specific DataStores.
        Structure is documented below.
        """
        max_results: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Output)
        Number of search results to return per query.
        The default value is 10. The maximum allowed value is 10.
        """
        modality_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigArgsDict']]]]
        """
        (Output)
        The modality configs for the data store.
        Structure is documented below.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
elif False:
    AppVersionSnapshotToolDataStoreToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolDataStoreToolArgs:
    def __init__(__self__, *,
                 boost_specs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 engine_sources: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceArgs']]]] = None,
                 max_results: Optional[pulumi.Input[_builtins.int]] = None,
                 modality_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigArgs']]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecArgs']]] boost_specs: (Output)
               Boost specification to boost certain documents.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceArgs']]] engine_sources: (Output)
               Configuration for searching within an Engine, potentially targeting
               specific DataStores.
               Structure is documented below.
        :param pulumi.Input[_builtins.int] max_results: (Output)
               Number of search results to return per query.
               The default value is 10. The maximum allowed value is 10.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigArgs']]] modality_configs: (Output)
               The modality configs for the data store.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        if boost_specs is not None:
            pulumi.set(__self__, "boost_specs", boost_specs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if engine_sources is not None:
            pulumi.set(__self__, "engine_sources", engine_sources)
        if max_results is not None:
            pulumi.set(__self__, "max_results", max_results)
        if modality_configs is not None:
            pulumi.set(__self__, "modality_configs", modality_configs)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="boostSpecs")
    def boost_specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecArgs']]]]:
        """
        (Output)
        Boost specification to boost certain documents.
        Structure is documented below.
        """
        return pulumi.get(self, "boost_specs")

    @boost_specs.setter
    def boost_specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecArgs']]]]):
        pulumi.set(self, "boost_specs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="engineSources")
    def engine_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceArgs']]]]:
        """
        (Output)
        Configuration for searching within an Engine, potentially targeting
        specific DataStores.
        Structure is documented below.
        """
        return pulumi.get(self, "engine_sources")

    @engine_sources.setter
    def engine_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceArgs']]]]):
        pulumi.set(self, "engine_sources", value)

    @_builtins.property
    @pulumi.getter(name="maxResults")
    def max_results(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Output)
        Number of search results to return per query.
        The default value is 10. The maximum allowed value is 10.
        """
        return pulumi.get(self, "max_results")

    @max_results.setter
    def max_results(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_results", value)

    @_builtins.property
    @pulumi.getter(name="modalityConfigs")
    def modality_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigArgs']]]]:
        """
        (Output)
        The modality configs for the data store.
        Structure is documented below.
        """
        return pulumi.get(self, "modality_configs")

    @modality_configs.setter
    def modality_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigArgs']]]]):
        pulumi.set(self, "modality_configs", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AppVersionSnapshotToolDataStoreToolBoostSpecArgsDict(TypedDict):
        data_stores: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        The Data Store where the boosting configuration is applied. Full resource
        name of DataStore, such as
        projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}.
        """
        specs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecArgsDict']]]]
        """
        (Output)
        A list of boosting specifications.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotToolDataStoreToolBoostSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolDataStoreToolBoostSpecArgs:
    def __init__(__self__, *,
                 data_stores: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 specs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] data_stores: (Output)
               The Data Store where the boosting configuration is applied. Full resource
               name of DataStore, such as
               projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecArgs']]] specs: (Output)
               A list of boosting specifications.
               Structure is documented below.
        """
        if data_stores is not None:
            pulumi.set(__self__, "data_stores", data_stores)
        if specs is not None:
            pulumi.set(__self__, "specs", specs)

    @_builtins.property
    @pulumi.getter(name="dataStores")
    def data_stores(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        The Data Store where the boosting configuration is applied. Full resource
        name of DataStore, such as
        projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}.
        """
        return pulumi.get(self, "data_stores")

    @data_stores.setter
    def data_stores(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "data_stores", value)

    @_builtins.property
    @pulumi.getter
    def specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecArgs']]]]:
        """
        (Output)
        A list of boosting specifications.
        Structure is documented below.
        """
        return pulumi.get(self, "specs")

    @specs.setter
    def specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecArgs']]]]):
        pulumi.set(self, "specs", value)


if not MYPY:
    class AppVersionSnapshotToolDataStoreToolBoostSpecSpecArgsDict(TypedDict):
        condition_boost_specs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecArgsDict']]]]
        """
        (Output)
        A list of boosting specifications.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotToolDataStoreToolBoostSpecSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolDataStoreToolBoostSpecSpecArgs:
    def __init__(__self__, *,
                 condition_boost_specs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs']]] condition_boost_specs: (Output)
               A list of boosting specifications.
               Structure is documented below.
        """
        if condition_boost_specs is not None:
            pulumi.set(__self__, "condition_boost_specs", condition_boost_specs)

    @_builtins.property
    @pulumi.getter(name="conditionBoostSpecs")
    def condition_boost_specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs']]]]:
        """
        (Output)
        A list of boosting specifications.
        Structure is documented below.
        """
        return pulumi.get(self, "condition_boost_specs")

    @condition_boost_specs.setter
    def condition_boost_specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs']]]]):
        pulumi.set(self, "condition_boost_specs", value)


if not MYPY:
    class AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecArgsDict(TypedDict):
        boost: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Output)
        Strength of the boost, which should be in [-1, 1]. Negative boost means
        demotion. Default is 0.0.
        Setting to 1.0 gives the suggestions a big promotion. However, it does
        not necessarily mean that the top result will be a boosted suggestion.
        Setting to -1.0 gives the suggestions a big demotion. However, other
        suggestions that are relevant might still be shown.
        Setting to 0.0 means no boost applied. The boosting condition is
        ignored.
        """
        boost_control_specs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgsDict']]]]
        """
        (Output)
        Specification for custom ranking based on customer specified attribute
        value. It provides more controls for customized ranking than the simple
        (condition, boost) combination above.
        Structure is documented below.
        """
        condition: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        An expression which specifies a boost condition. The syntax is the same
        as filter expression syntax. Currently, the only supported condition is
        a list of BCP-47 lang codes.
        Example: To boost suggestions in languages en or fr:
        (lang_code: ANY("en", "fr"))
        """
elif False:
    AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs:
    def __init__(__self__, *,
                 boost: Optional[pulumi.Input[_builtins.float]] = None,
                 boost_control_specs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs']]]] = None,
                 condition: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.float] boost: (Output)
               Strength of the boost, which should be in [-1, 1]. Negative boost means
               demotion. Default is 0.0.
               Setting to 1.0 gives the suggestions a big promotion. However, it does
               not necessarily mean that the top result will be a boosted suggestion.
               Setting to -1.0 gives the suggestions a big demotion. However, other
               suggestions that are relevant might still be shown.
               Setting to 0.0 means no boost applied. The boosting condition is
               ignored.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs']]] boost_control_specs: (Output)
               Specification for custom ranking based on customer specified attribute
               value. It provides more controls for customized ranking than the simple
               (condition, boost) combination above.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] condition: (Output)
               An expression which specifies a boost condition. The syntax is the same
               as filter expression syntax. Currently, the only supported condition is
               a list of BCP-47 lang codes.
               Example: To boost suggestions in languages en or fr:
               (lang_code: ANY("en", "fr"))
        """
        if boost is not None:
            pulumi.set(__self__, "boost", boost)
        if boost_control_specs is not None:
            pulumi.set(__self__, "boost_control_specs", boost_control_specs)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @_builtins.property
    @pulumi.getter
    def boost(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Output)
        Strength of the boost, which should be in [-1, 1]. Negative boost means
        demotion. Default is 0.0.
        Setting to 1.0 gives the suggestions a big promotion. However, it does
        not necessarily mean that the top result will be a boosted suggestion.
        Setting to -1.0 gives the suggestions a big demotion. However, other
        suggestions that are relevant might still be shown.
        Setting to 0.0 means no boost applied. The boosting condition is
        ignored.
        """
        return pulumi.get(self, "boost")

    @boost.setter
    def boost(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "boost", value)

    @_builtins.property
    @pulumi.getter(name="boostControlSpecs")
    def boost_control_specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs']]]]:
        """
        (Output)
        Specification for custom ranking based on customer specified attribute
        value. It provides more controls for customized ranking than the simple
        (condition, boost) combination above.
        Structure is documented below.
        """
        return pulumi.get(self, "boost_control_specs")

    @boost_control_specs.setter
    def boost_control_specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs']]]]):
        pulumi.set(self, "boost_control_specs", value)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        An expression which specifies a boost condition. The syntax is the same
        as filter expression syntax. Currently, the only supported condition is
        a list of BCP-47 lang codes.
        Example: To boost suggestions in languages en or fr:
        (lang_code: ANY("en", "fr"))
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "condition", value)


if not MYPY:
    class AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgsDict(TypedDict):
        attribute_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The attribute type to be used to determine the boost amount. The
        attribute value can be derived from the field value of the specified
        field_name. In the case of numerical it is straightforward i.e.
        attribute_value = numerical_field_value. In the case of freshness
        however, attribute_value = (time.now() - datetime_field_value).
        Possible values:
        NUMERICAL
        FRESHNESS
        """
        control_points: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgsDict']]]]
        """
        (Output)
        The control points used to define the curve. The monotonic function
        (defined through the interpolation_type above) passes through the
        control points listed here.
        Structure is documented below.
        """
        field_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the field whose value will be used to determine the
        boost amount.
        """
        interpolation_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The interpolation type to be applied to connect the control points
        listed below.
        Possible values:
        LINEAR
        """
elif False:
    AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs:
    def __init__(__self__, *,
                 attribute_type: Optional[pulumi.Input[_builtins.str]] = None,
                 control_points: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs']]]] = None,
                 field_name: Optional[pulumi.Input[_builtins.str]] = None,
                 interpolation_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] attribute_type: (Output)
               The attribute type to be used to determine the boost amount. The
               attribute value can be derived from the field value of the specified
               field_name. In the case of numerical it is straightforward i.e.
               attribute_value = numerical_field_value. In the case of freshness
               however, attribute_value = (time.now() - datetime_field_value).
               Possible values:
               NUMERICAL
               FRESHNESS
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs']]] control_points: (Output)
               The control points used to define the curve. The monotonic function
               (defined through the interpolation_type above) passes through the
               control points listed here.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] field_name: (Output)
               The name of the field whose value will be used to determine the
               boost amount.
        :param pulumi.Input[_builtins.str] interpolation_type: (Output)
               The interpolation type to be applied to connect the control points
               listed below.
               Possible values:
               LINEAR
        """
        if attribute_type is not None:
            pulumi.set(__self__, "attribute_type", attribute_type)
        if control_points is not None:
            pulumi.set(__self__, "control_points", control_points)
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)
        if interpolation_type is not None:
            pulumi.set(__self__, "interpolation_type", interpolation_type)

    @_builtins.property
    @pulumi.getter(name="attributeType")
    def attribute_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The attribute type to be used to determine the boost amount. The
        attribute value can be derived from the field value of the specified
        field_name. In the case of numerical it is straightforward i.e.
        attribute_value = numerical_field_value. In the case of freshness
        however, attribute_value = (time.now() - datetime_field_value).
        Possible values:
        NUMERICAL
        FRESHNESS
        """
        return pulumi.get(self, "attribute_type")

    @attribute_type.setter
    def attribute_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_type", value)

    @_builtins.property
    @pulumi.getter(name="controlPoints")
    def control_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs']]]]:
        """
        (Output)
        The control points used to define the curve. The monotonic function
        (defined through the interpolation_type above) passes through the
        control points listed here.
        Structure is documented below.
        """
        return pulumi.get(self, "control_points")

    @control_points.setter
    def control_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs']]]]):
        pulumi.set(self, "control_points", value)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the field whose value will be used to determine the
        boost amount.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter(name="interpolationType")
    def interpolation_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The interpolation type to be applied to connect the control points
        listed below.
        Possible values:
        LINEAR
        """
        return pulumi.get(self, "interpolation_type")

    @interpolation_type.setter
    def interpolation_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interpolation_type", value)


if not MYPY:
    class AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgsDict(TypedDict):
        attribute_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Can be one of:
        1. The numerical field value.
        2. The duration spec for freshness:
        The value must be formatted as an XSD `dayTimeDuration` value (a
        restricted subset of an ISO 8601 duration value). The pattern for
        this is: `nDnM]`.
        """
        boost_amount: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Output)
        The value between -1 to 1 by which to boost the score if the
        attribute_value evaluates to the value specified above.
        """
elif False:
    AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs:
    def __init__(__self__, *,
                 attribute_value: Optional[pulumi.Input[_builtins.str]] = None,
                 boost_amount: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] attribute_value: (Output)
               Can be one of:
               1. The numerical field value.
               2. The duration spec for freshness:
               The value must be formatted as an XSD `dayTimeDuration` value (a
               restricted subset of an ISO 8601 duration value). The pattern for
               this is: `nDnM]`.
        :param pulumi.Input[_builtins.float] boost_amount: (Output)
               The value between -1 to 1 by which to boost the score if the
               attribute_value evaluates to the value specified above.
        """
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if boost_amount is not None:
            pulumi.set(__self__, "boost_amount", boost_amount)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Can be one of:
        1. The numerical field value.
        2. The duration spec for freshness:
        The value must be formatted as an XSD `dayTimeDuration` value (a
        restricted subset of an ISO 8601 duration value). The pattern for
        this is: `nDnM]`.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="boostAmount")
    def boost_amount(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Output)
        The value between -1 to 1 by which to boost the score if the
        attribute_value evaluates to the value specified above.
        """
        return pulumi.get(self, "boost_amount")

    @boost_amount.setter
    def boost_amount(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "boost_amount", value)


if not MYPY:
    class AppVersionSnapshotToolDataStoreToolEngineSourceArgsDict(TypedDict):
        data_store_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceArgsDict']]]]
        """
        (Output)
        Use to target specific DataStores within the Engine.
        If empty, the search applies to all DataStores associated with the
        Engine.
        Structure is documented below.
        """
        engine: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Full resource name of the Engine.
        Format:
        `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
        """
        filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Filter specification for the DataStore.
        See:
        https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
elif False:
    AppVersionSnapshotToolDataStoreToolEngineSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolDataStoreToolEngineSourceArgs:
    def __init__(__self__, *,
                 data_store_sources: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceArgs']]]] = None,
                 engine: Optional[pulumi.Input[_builtins.str]] = None,
                 filter: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceArgs']]] data_store_sources: (Output)
               Use to target specific DataStores within the Engine.
               If empty, the search applies to all DataStores associated with the
               Engine.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] engine: (Output)
               Full resource name of the Engine.
               Format:
               `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
        :param pulumi.Input[_builtins.str] filter: (Output)
               Filter specification for the DataStore.
               See:
               https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        if data_store_sources is not None:
            pulumi.set(__self__, "data_store_sources", data_store_sources)
        if engine is not None:
            pulumi.set(__self__, "engine", engine)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)

    @_builtins.property
    @pulumi.getter(name="dataStoreSources")
    def data_store_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceArgs']]]]:
        """
        (Output)
        Use to target specific DataStores within the Engine.
        If empty, the search applies to all DataStores associated with the
        Engine.
        Structure is documented below.
        """
        return pulumi.get(self, "data_store_sources")

    @data_store_sources.setter
    def data_store_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceArgs']]]]):
        pulumi.set(self, "data_store_sources", value)

    @_builtins.property
    @pulumi.getter
    def engine(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Full resource name of the Engine.
        Format:
        `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
        """
        return pulumi.get(self, "engine")

    @engine.setter
    def engine(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "engine", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Filter specification for the DataStore.
        See:
        https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter", value)


if not MYPY:
    class AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceArgsDict(TypedDict):
        data_stores: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgsDict']]]]
        """
        (Output)
        A DataStore resource in Vertex AI Search.
        Structure is documented below.
        """
        filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Filter specification for the DataStore.
        See:
        https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
elif False:
    AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceArgs:
    def __init__(__self__, *,
                 data_stores: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs']]]] = None,
                 filter: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs']]] data_stores: (Output)
               A DataStore resource in Vertex AI Search.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] filter: (Output)
               Filter specification for the DataStore.
               See:
               https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        if data_stores is not None:
            pulumi.set(__self__, "data_stores", data_stores)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)

    @_builtins.property
    @pulumi.getter(name="dataStores")
    def data_stores(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs']]]]:
        """
        (Output)
        A DataStore resource in Vertex AI Search.
        Structure is documented below.
        """
        return pulumi.get(self, "data_stores")

    @data_stores.setter
    def data_stores(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs']]]]):
        pulumi.set(self, "data_stores", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Filter specification for the DataStore.
        See:
        https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter", value)


if not MYPY:
    class AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgsDict(TypedDict):
        connector_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgsDict']]]]
        """
        (Output)
        The connector config for the data store connection.
        Structure is documented below.
        """
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Timestamp when the toolset was created.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The display name of the app version.
        """
        document_processing_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The document processing mode for the data store connection.
        Only set for PUBLIC_WEB and UNSTRUCTURED data stores.
        Possible values:
        DOCUMENTS
        CHUNKS
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR
        """
elif False:
    AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs:
    def __init__(__self__, *,
                 connector_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs']]]] = None,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 document_processing_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs']]] connector_configs: (Output)
               The connector config for the data store connection.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] create_time: (Output)
               Timestamp when the toolset was created.
        :param pulumi.Input[_builtins.str] display_name: The display name of the app version.
        :param pulumi.Input[_builtins.str] document_processing_mode: (Output)
               The document processing mode for the data store connection.
               Only set for PUBLIC_WEB and UNSTRUCTURED data stores.
               Possible values:
               DOCUMENTS
               CHUNKS
        :param pulumi.Input[_builtins.str] name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param pulumi.Input[_builtins.str] type: (Output)
               The type of the data store. This field is readonly and populated by the
               server.
               Possible values:
               PUBLIC_WEB
               UNSTRUCTURED
               FAQ
               CONNECTOR
        """
        if connector_configs is not None:
            pulumi.set(__self__, "connector_configs", connector_configs)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if document_processing_mode is not None:
            pulumi.set(__self__, "document_processing_mode", document_processing_mode)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="connectorConfigs")
    def connector_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs']]]]:
        """
        (Output)
        The connector config for the data store connection.
        Structure is documented below.
        """
        return pulumi.get(self, "connector_configs")

    @connector_configs.setter
    def connector_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs']]]]):
        pulumi.set(self, "connector_configs", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Timestamp when the toolset was created.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="documentProcessingMode")
    def document_processing_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The document processing mode for the data store connection.
        Only set for PUBLIC_WEB and UNSTRUCTURED data stores.
        Possible values:
        DOCUMENTS
        CHUNKS
        """
        return pulumi.get(self, "document_processing_mode")

    @document_processing_mode.setter
    def document_processing_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "document_processing_mode", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgsDict(TypedDict):
        collection: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Resource name of the collection the data store belongs to.
        """
        collection_display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Display name of the collection the data store belongs to.
        """
        data_source: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the data source.
        Example: `salesforce`, `jira`, `confluence`, `bigquery`.
        """
elif False:
    AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs:
    def __init__(__self__, *,
                 collection: Optional[pulumi.Input[_builtins.str]] = None,
                 collection_display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 data_source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] collection: (Output)
               Resource name of the collection the data store belongs to.
        :param pulumi.Input[_builtins.str] collection_display_name: (Output)
               Display name of the collection the data store belongs to.
        :param pulumi.Input[_builtins.str] data_source: (Output)
               The name of the data source.
               Example: `salesforce`, `jira`, `confluence`, `bigquery`.
        """
        if collection is not None:
            pulumi.set(__self__, "collection", collection)
        if collection_display_name is not None:
            pulumi.set(__self__, "collection_display_name", collection_display_name)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @_builtins.property
    @pulumi.getter
    def collection(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Resource name of the collection the data store belongs to.
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "collection", value)

    @_builtins.property
    @pulumi.getter(name="collectionDisplayName")
    def collection_display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Display name of the collection the data store belongs to.
        """
        return pulumi.get(self, "collection_display_name")

    @collection_display_name.setter
    def collection_display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "collection_display_name", value)

    @_builtins.property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the data source.
        Example: `salesforce`, `jira`, `confluence`, `bigquery`.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_source", value)


if not MYPY:
    class AppVersionSnapshotToolDataStoreToolModalityConfigArgsDict(TypedDict):
        grounding_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigGroundingConfigArgsDict']]]]
        """
        (Output)
        Grounding configuration.
        Structure is documented below.
        """
        modality_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The modality type.
        Possible values:
        TEXT
        AUDIO
        """
        rewriter_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigArgsDict']]]]
        """
        (Output)
        Rewriter configuration.
        Structure is documented below.
        """
        summarization_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigArgsDict']]]]
        """
        (Output)
        Summarization configuration.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotToolDataStoreToolModalityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolDataStoreToolModalityConfigArgs:
    def __init__(__self__, *,
                 grounding_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigGroundingConfigArgs']]]] = None,
                 modality_type: Optional[pulumi.Input[_builtins.str]] = None,
                 rewriter_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigArgs']]]] = None,
                 summarization_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigGroundingConfigArgs']]] grounding_configs: (Output)
               Grounding configuration.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] modality_type: (Output)
               The modality type.
               Possible values:
               TEXT
               AUDIO
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigArgs']]] rewriter_configs: (Output)
               Rewriter configuration.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigArgs']]] summarization_configs: (Output)
               Summarization configuration.
               Structure is documented below.
        """
        if grounding_configs is not None:
            pulumi.set(__self__, "grounding_configs", grounding_configs)
        if modality_type is not None:
            pulumi.set(__self__, "modality_type", modality_type)
        if rewriter_configs is not None:
            pulumi.set(__self__, "rewriter_configs", rewriter_configs)
        if summarization_configs is not None:
            pulumi.set(__self__, "summarization_configs", summarization_configs)

    @_builtins.property
    @pulumi.getter(name="groundingConfigs")
    def grounding_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigGroundingConfigArgs']]]]:
        """
        (Output)
        Grounding configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "grounding_configs")

    @grounding_configs.setter
    def grounding_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigGroundingConfigArgs']]]]):
        pulumi.set(self, "grounding_configs", value)

    @_builtins.property
    @pulumi.getter(name="modalityType")
    def modality_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The modality type.
        Possible values:
        TEXT
        AUDIO
        """
        return pulumi.get(self, "modality_type")

    @modality_type.setter
    def modality_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "modality_type", value)

    @_builtins.property
    @pulumi.getter(name="rewriterConfigs")
    def rewriter_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigArgs']]]]:
        """
        (Output)
        Rewriter configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "rewriter_configs")

    @rewriter_configs.setter
    def rewriter_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigArgs']]]]):
        pulumi.set(self, "rewriter_configs", value)

    @_builtins.property
    @pulumi.getter(name="summarizationConfigs")
    def summarization_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigArgs']]]]:
        """
        (Output)
        Summarization configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "summarization_configs")

    @summarization_configs.setter
    def summarization_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigArgs']]]]):
        pulumi.set(self, "summarization_configs", value)


if not MYPY:
    class AppVersionSnapshotToolDataStoreToolModalityConfigGroundingConfigArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether summarization is disabled.
        """
        grounding_level: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Output)
        The groundedness threshold of the answer based on the retrieved sources.
        The value has a configurable range of [1, 5]. The level is used to
        threshold the groundedness of the answer, meaning that all responses with
        a groundedness score below the threshold will fall back to returning
        relevant snippets only.
        For example, a level of 3 means that the groundedness score must be
        3 or higher for the response to be returned.
        """
elif False:
    AppVersionSnapshotToolDataStoreToolModalityConfigGroundingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolDataStoreToolModalityConfigGroundingConfigArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 grounding_level: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.bool] disabled: (Output)
               Whether summarization is disabled.
        :param pulumi.Input[_builtins.float] grounding_level: (Output)
               The groundedness threshold of the answer based on the retrieved sources.
               The value has a configurable range of [1, 5]. The level is used to
               threshold the groundedness of the answer, meaning that all responses with
               a groundedness score below the threshold will fall back to returning
               relevant snippets only.
               For example, a level of 3 means that the groundedness score must be
               3 or higher for the response to be returned.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if grounding_level is not None:
            pulumi.set(__self__, "grounding_level", grounding_level)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="groundingLevel")
    def grounding_level(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Output)
        The groundedness threshold of the answer based on the retrieved sources.
        The value has a configurable range of [1, 5]. The level is used to
        threshold the groundedness of the answer, meaning that all responses with
        a groundedness score below the threshold will fall back to returning
        relevant snippets only.
        For example, a level of 3 means that the groundedness score must be
        3 or higher for the response to be returned.
        """
        return pulumi.get(self, "grounding_level")

    @grounding_level.setter
    def grounding_level(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "grounding_level", value)


if not MYPY:
    class AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether summarization is disabled.
        """
        model_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigModelSettingArgsDict']]]]
        """
        (Output)
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        prompt: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The prompt definition. If not set, default prompt will be used.
        """
elif False:
    AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 model_settings: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigModelSettingArgs']]]] = None,
                 prompt: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] disabled: (Output)
               Whether summarization is disabled.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigModelSettingArgs']]] model_settings: (Output)
               Model settings contains various configurations for the LLM model.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] prompt: (Output)
               The prompt definition. If not set, default prompt will be used.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigModelSettingArgs']]]]:
        """
        (Output)
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @model_settings.setter
    def model_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigModelSettingArgs']]]]):
        pulumi.set(self, "model_settings", value)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The prompt definition. If not set, default prompt will be used.
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prompt", value)


if not MYPY:
    class AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigModelSettingArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Output)
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
elif False:
    AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigModelSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolDataStoreToolModalityConfigRewriterConfigModelSettingArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] model: (Output)
               The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param pulumi.Input[_builtins.float] temperature: (Output)
               If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Output)
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)


if not MYPY:
    class AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        Whether summarization is disabled.
        """
        model_settings: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigModelSettingArgsDict']]]]
        """
        (Output)
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        prompt: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The prompt definition. If not set, default prompt will be used.
        """
elif False:
    AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 model_settings: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigModelSettingArgs']]]] = None,
                 prompt: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] disabled: (Output)
               Whether summarization is disabled.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigModelSettingArgs']]] model_settings: (Output)
               Model settings contains various configurations for the LLM model.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] prompt: (Output)
               The prompt definition. If not set, default prompt will be used.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigModelSettingArgs']]]]:
        """
        (Output)
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @model_settings.setter
    def model_settings(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigModelSettingArgs']]]]):
        pulumi.set(self, "model_settings", value)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The prompt definition. If not set, default prompt will be used.
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prompt", value)


if not MYPY:
    class AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigModelSettingArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        (Output)
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
elif False:
    AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigModelSettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolDataStoreToolModalityConfigSummarizationConfigModelSettingArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] model: (Output)
               The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param pulumi.Input[_builtins.float] temperature: (Output)
               If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        (Output)
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)


if not MYPY:
    class AppVersionSnapshotToolGoogleSearchToolArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        exclude_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        List of domains to be excluded from the search results.
        Example: "example.com".
        A maximum of 2000 domains can be excluded.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
elif False:
    AppVersionSnapshotToolGoogleSearchToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolGoogleSearchToolArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 exclude_domains: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_domains: (Output)
               List of domains to be excluded from the search results.
               Example: "example.com".
               A maximum of 2000 domains can be excluded.
        :param pulumi.Input[_builtins.str] name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exclude_domains is not None:
            pulumi.set(__self__, "exclude_domains", exclude_domains)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="excludeDomains")
    def exclude_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        List of domains to be excluded from the search results.
        Example: "example.com".
        A maximum of 2000 domains can be excluded.
        """
        return pulumi.get(self, "exclude_domains")

    @exclude_domains.setter
    def exclude_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_domains", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AppVersionSnapshotToolOpenApiToolArgsDict(TypedDict):
        api_authentications: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationArgsDict']]]]
        """
        (Output)
        Authentication information required for API calls.
        Structure is documented below.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        ignore_unknown_fields: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        If true, the agent will ignore unknown fields in the API response for all
        operations defined in the OpenAPI schema.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        open_api_schema: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The OpenAPI schema of the toolset.
        """
        service_directory_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolServiceDirectoryConfigArgsDict']]]]
        """
        (Output)
        Configuration for tools using Service Directory.
        Structure is documented below.
        """
        tls_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolTlsConfigArgsDict']]]]
        """
        (Output)
        The TLS configuration.
        Structure is documented below.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The server URL of the Open API schema.
        This field is only set in toolsets in the environment dependencies
        during the export process if the schema contains a server url.
        During the import process, if this url is present in the environment dependencies
        and the schema has the $env_var placeholder,
        it will replace the placeholder in the schema.
        """
elif False:
    AppVersionSnapshotToolOpenApiToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolOpenApiToolArgs:
    def __init__(__self__, *,
                 api_authentications: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 ignore_unknown_fields: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 open_api_schema: Optional[pulumi.Input[_builtins.str]] = None,
                 service_directory_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolServiceDirectoryConfigArgs']]]] = None,
                 tls_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolTlsConfigArgs']]]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationArgs']]] api_authentications: (Output)
               Authentication information required for API calls.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.bool] ignore_unknown_fields: (Output)
               If true, the agent will ignore unknown fields in the API response for all
               operations defined in the OpenAPI schema.
        :param pulumi.Input[_builtins.str] name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param pulumi.Input[_builtins.str] open_api_schema: (Output)
               The OpenAPI schema of the toolset.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolServiceDirectoryConfigArgs']]] service_directory_configs: (Output)
               Configuration for tools using Service Directory.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolTlsConfigArgs']]] tls_configs: (Output)
               The TLS configuration.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] url: (Output)
               The server URL of the Open API schema.
               This field is only set in toolsets in the environment dependencies
               during the export process if the schema contains a server url.
               During the import process, if this url is present in the environment dependencies
               and the schema has the $env_var placeholder,
               it will replace the placeholder in the schema.
        """
        if api_authentications is not None:
            pulumi.set(__self__, "api_authentications", api_authentications)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ignore_unknown_fields is not None:
            pulumi.set(__self__, "ignore_unknown_fields", ignore_unknown_fields)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if open_api_schema is not None:
            pulumi.set(__self__, "open_api_schema", open_api_schema)
        if service_directory_configs is not None:
            pulumi.set(__self__, "service_directory_configs", service_directory_configs)
        if tls_configs is not None:
            pulumi.set(__self__, "tls_configs", tls_configs)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="apiAuthentications")
    def api_authentications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationArgs']]]]:
        """
        (Output)
        Authentication information required for API calls.
        Structure is documented below.
        """
        return pulumi.get(self, "api_authentications")

    @api_authentications.setter
    def api_authentications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationArgs']]]]):
        pulumi.set(self, "api_authentications", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="ignoreUnknownFields")
    def ignore_unknown_fields(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        If true, the agent will ignore unknown fields in the API response for all
        operations defined in the OpenAPI schema.
        """
        return pulumi.get(self, "ignore_unknown_fields")

    @ignore_unknown_fields.setter
    def ignore_unknown_fields(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_unknown_fields", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="openApiSchema")
    def open_api_schema(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The OpenAPI schema of the toolset.
        """
        return pulumi.get(self, "open_api_schema")

    @open_api_schema.setter
    def open_api_schema(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "open_api_schema", value)

    @_builtins.property
    @pulumi.getter(name="serviceDirectoryConfigs")
    def service_directory_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolServiceDirectoryConfigArgs']]]]:
        """
        (Output)
        Configuration for tools using Service Directory.
        Structure is documented below.
        """
        return pulumi.get(self, "service_directory_configs")

    @service_directory_configs.setter
    def service_directory_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolServiceDirectoryConfigArgs']]]]):
        pulumi.set(self, "service_directory_configs", value)

    @_builtins.property
    @pulumi.getter(name="tlsConfigs")
    def tls_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolTlsConfigArgs']]]]:
        """
        (Output)
        The TLS configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "tls_configs")

    @tls_configs.setter
    def tls_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolTlsConfigArgs']]]]):
        pulumi.set(self, "tls_configs", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The server URL of the Open API schema.
        This field is only set in toolsets in the environment dependencies
        during the export process if the schema contains a server url.
        During the import process, if this url is present in the environment dependencies
        and the schema has the $env_var placeholder,
        it will replace the placeholder in the schema.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class AppVersionSnapshotToolOpenApiToolApiAuthenticationArgsDict(TypedDict):
        api_key_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationApiKeyConfigArgsDict']]]]
        """
        (Output)
        Configurations for authentication with API key.
        Structure is documented below.
        """
        oauth_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationOauthConfigArgsDict']]]]
        """
        (Output)
        Configurations for authentication with OAuth.
        Structure is documented below.
        """
        service_account_auth_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgsDict']]]]
        """
        (Output)
        Configurations for authentication using a custom service account.
        Structure is documented below.
        """
        service_agent_id_token_auth_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict']]]]
        """
        (Output)
        Configurations for authentication with [ID
        token](https://cloud.google.com/docs/authentication/token-types#id) generated
        from service agent.
        """
elif False:
    AppVersionSnapshotToolOpenApiToolApiAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolOpenApiToolApiAuthenticationArgs:
    def __init__(__self__, *,
                 api_key_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationApiKeyConfigArgs']]]] = None,
                 oauth_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationOauthConfigArgs']]]] = None,
                 service_account_auth_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs']]]] = None,
                 service_agent_id_token_auth_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationApiKeyConfigArgs']]] api_key_configs: (Output)
               Configurations for authentication with API key.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationOauthConfigArgs']]] oauth_configs: (Output)
               Configurations for authentication with OAuth.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs']]] service_account_auth_configs: (Output)
               Configurations for authentication using a custom service account.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]] service_agent_id_token_auth_configs: (Output)
               Configurations for authentication with [ID
               token](https://cloud.google.com/docs/authentication/token-types#id) generated
               from service agent.
        """
        if api_key_configs is not None:
            pulumi.set(__self__, "api_key_configs", api_key_configs)
        if oauth_configs is not None:
            pulumi.set(__self__, "oauth_configs", oauth_configs)
        if service_account_auth_configs is not None:
            pulumi.set(__self__, "service_account_auth_configs", service_account_auth_configs)
        if service_agent_id_token_auth_configs is not None:
            pulumi.set(__self__, "service_agent_id_token_auth_configs", service_agent_id_token_auth_configs)

    @_builtins.property
    @pulumi.getter(name="apiKeyConfigs")
    def api_key_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationApiKeyConfigArgs']]]]:
        """
        (Output)
        Configurations for authentication with API key.
        Structure is documented below.
        """
        return pulumi.get(self, "api_key_configs")

    @api_key_configs.setter
    def api_key_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationApiKeyConfigArgs']]]]):
        pulumi.set(self, "api_key_configs", value)

    @_builtins.property
    @pulumi.getter(name="oauthConfigs")
    def oauth_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationOauthConfigArgs']]]]:
        """
        (Output)
        Configurations for authentication with OAuth.
        Structure is documented below.
        """
        return pulumi.get(self, "oauth_configs")

    @oauth_configs.setter
    def oauth_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationOauthConfigArgs']]]]):
        pulumi.set(self, "oauth_configs", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccountAuthConfigs")
    def service_account_auth_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs']]]]:
        """
        (Output)
        Configurations for authentication using a custom service account.
        Structure is documented below.
        """
        return pulumi.get(self, "service_account_auth_configs")

    @service_account_auth_configs.setter
    def service_account_auth_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs']]]]):
        pulumi.set(self, "service_account_auth_configs", value)

    @_builtins.property
    @pulumi.getter(name="serviceAgentIdTokenAuthConfigs")
    def service_agent_id_token_auth_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]]]:
        """
        (Output)
        Configurations for authentication with [ID
        token](https://cloud.google.com/docs/authentication/token-types#id) generated
        from service agent.
        """
        return pulumi.get(self, "service_agent_id_token_auth_configs")

    @service_agent_id_token_auth_configs.setter
    def service_agent_id_token_auth_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]]]):
        pulumi.set(self, "service_agent_id_token_auth_configs", value)


if not MYPY:
    class AppVersionSnapshotToolOpenApiToolApiAuthenticationApiKeyConfigArgsDict(TypedDict):
        api_key_secret_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the SecretManager secret version resource storing the API key.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        key_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        request_location: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Key location in the request.
        Possible values:
        HEADER
        QUERY_STRING
        """
elif False:
    AppVersionSnapshotToolOpenApiToolApiAuthenticationApiKeyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolOpenApiToolApiAuthenticationApiKeyConfigArgs:
    def __init__(__self__, *,
                 api_key_secret_version: Optional[pulumi.Input[_builtins.str]] = None,
                 key_name: Optional[pulumi.Input[_builtins.str]] = None,
                 request_location: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key_secret_version: (Output)
               The name of the SecretManager secret version resource storing the API key.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param pulumi.Input[_builtins.str] key_name: (Output)
               The parameter name or the header name of the API key.
               E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        :param pulumi.Input[_builtins.str] request_location: (Output)
               Key location in the request.
               Possible values:
               HEADER
               QUERY_STRING
        """
        if api_key_secret_version is not None:
            pulumi.set(__self__, "api_key_secret_version", api_key_secret_version)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if request_location is not None:
            pulumi.set(__self__, "request_location", request_location)

    @_builtins.property
    @pulumi.getter(name="apiKeySecretVersion")
    def api_key_secret_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the SecretManager secret version resource storing the API key.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "api_key_secret_version")

    @api_key_secret_version.setter
    def api_key_secret_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_key_secret_version", value)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter(name="requestLocation")
    def request_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Key location in the request.
        Possible values:
        HEADER
        QUERY_STRING
        """
        return pulumi.get(self, "request_location")

    @request_location.setter
    def request_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request_location", value)


if not MYPY:
    class AppVersionSnapshotToolOpenApiToolApiAuthenticationOauthConfigArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The client ID from the OAuth provider.
        """
        client_secret_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the SecretManager secret version resource storing the
        client secret.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        oauth_grant_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        OAuth grant types.
        Possible values:
        CLIENT_CREDENTIAL
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        The OAuth scopes to grant.
        """
        token_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The token endpoint in the OAuth provider to exchange for an access token.
        """
elif False:
    AppVersionSnapshotToolOpenApiToolApiAuthenticationOauthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolOpenApiToolApiAuthenticationOauthConfigArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret_version: Optional[pulumi.Input[_builtins.str]] = None,
                 oauth_grant_type: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id: (Output)
               The client ID from the OAuth provider.
        :param pulumi.Input[_builtins.str] client_secret_version: (Output)
               The name of the SecretManager secret version resource storing the
               client secret.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param pulumi.Input[_builtins.str] oauth_grant_type: (Output)
               OAuth grant types.
               Possible values:
               CLIENT_CREDENTIAL
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: (Output)
               The OAuth scopes to grant.
        :param pulumi.Input[_builtins.str] token_endpoint: (Output)
               The token endpoint in the OAuth provider to exchange for an access token.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_version is not None:
            pulumi.set(__self__, "client_secret_version", client_secret_version)
        if oauth_grant_type is not None:
            pulumi.set(__self__, "oauth_grant_type", oauth_grant_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The client ID from the OAuth provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretVersion")
    def client_secret_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the SecretManager secret version resource storing the
        client secret.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "client_secret_version")

    @client_secret_version.setter
    def client_secret_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret_version", value)

    @_builtins.property
    @pulumi.getter(name="oauthGrantType")
    def oauth_grant_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        OAuth grant types.
        Possible values:
        CLIENT_CREDENTIAL
        """
        return pulumi.get(self, "oauth_grant_type")

    @oauth_grant_type.setter
    def oauth_grant_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oauth_grant_type", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        The OAuth scopes to grant.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The token endpoint in the OAuth provider to exchange for an access token.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_endpoint", value)


if not MYPY:
    class AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgsDict(TypedDict):
        service_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The email address of the service account used for authenticatation. CES
        uses this service account to exchange an access token and the access token
        is then sent in the `Authorization` header of the request.
        The service account must have the
        `roles/iam.serviceAccountTokenCreator` role granted to the
        CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
elif False:
    AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs:
    def __init__(__self__, *,
                 service_account: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] service_account: (Output)
               The email address of the service account used for authenticatation. CES
               uses this service account to exchange an access token and the access token
               is then sent in the `Authorization` header of the request.
               The service account must have the
               `roles/iam.serviceAccountTokenCreator` role granted to the
               CES service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The email address of the service account used for authenticatation. CES
        uses this service account to exchange an access token and the access token
        is then sent in the `Authorization` header of the request.
        The service account must have the
        `roles/iam.serviceAccountTokenCreator` role granted to the
        CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_account", value)


if not MYPY:
    class AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict(TypedDict):
        pass
elif False:
    AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AppVersionSnapshotToolOpenApiToolServiceDirectoryConfigArgsDict(TypedDict):
        service: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of [Service
        Directory](https://cloud.google.com/service-directory) service.
        Format:
        `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
        Location of the service directory must be the same as the location of the
        app.
        """
elif False:
    AppVersionSnapshotToolOpenApiToolServiceDirectoryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolOpenApiToolServiceDirectoryConfigArgs:
    def __init__(__self__, *,
                 service: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] service: (Output)
               The name of [Service
               Directory](https://cloud.google.com/service-directory) service.
               Format:
               `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
               Location of the service directory must be the same as the location of the
               app.
        """
        if service is not None:
            pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of [Service
        Directory](https://cloud.google.com/service-directory) service.
        Format:
        `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
        Location of the service directory must be the same as the location of the
        app.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service", value)


if not MYPY:
    class AppVersionSnapshotToolOpenApiToolTlsConfigArgsDict(TypedDict):
        ca_certs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolTlsConfigCaCertArgsDict']]]]
        """
        (Output)
        Specifies a list of allowed custom CA certificates for HTTPS
        verification.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotToolOpenApiToolTlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolOpenApiToolTlsConfigArgs:
    def __init__(__self__, *,
                 ca_certs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolTlsConfigCaCertArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolTlsConfigCaCertArgs']]] ca_certs: (Output)
               Specifies a list of allowed custom CA certificates for HTTPS
               verification.
               Structure is documented below.
        """
        if ca_certs is not None:
            pulumi.set(__self__, "ca_certs", ca_certs)

    @_builtins.property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolTlsConfigCaCertArgs']]]]:
        """
        (Output)
        Specifies a list of allowed custom CA certificates for HTTPS
        verification.
        Structure is documented below.
        """
        return pulumi.get(self, "ca_certs")

    @ca_certs.setter
    def ca_certs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolOpenApiToolTlsConfigCaCertArgs']]]]):
        pulumi.set(self, "ca_certs", value)


if not MYPY:
    class AppVersionSnapshotToolOpenApiToolTlsConfigCaCertArgsDict(TypedDict):
        cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, CES will use Google's default trust
        store to verify certificates. N.B. Make sure the HTTPS server
        certificates are signed with "subject alt name". For instance a
        certificate can be self-signed using the following command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The display name of the app version.
        """
elif False:
    AppVersionSnapshotToolOpenApiToolTlsConfigCaCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolOpenApiToolTlsConfigCaCertArgs:
    def __init__(__self__, *,
                 cert: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cert: (Output)
               The allowed custom CA certificates (in DER format) for
               HTTPS verification. This overrides the default SSL trust store. If this
               is empty or unspecified, CES will use Google's default trust
               store to verify certificates. N.B. Make sure the HTTPS server
               certificates are signed with "subject alt name". For instance a
               certificate can be self-signed using the following command,
               openssl x509 -req -days 200 -in example.com.csr \\
               -signkey example.com.key \\
               -out example.com.crt \\
               -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        :param pulumi.Input[_builtins.str] display_name: The display name of the app version.
        """
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, CES will use Google's default trust
        store to verify certificates. N.B. Make sure the HTTPS server
        certificates are signed with "subject alt name". For instance a
        certificate can be self-signed using the following command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        """
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cert", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class AppVersionSnapshotToolPythonFunctionArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        python_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The Python code to execute for the tool.
        """
elif False:
    AppVersionSnapshotToolPythonFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolPythonFunctionArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 python_code: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.str] name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param pulumi.Input[_builtins.str] python_code: (Output)
               The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "python_code", value)


if not MYPY:
    class AppVersionSnapshotToolSystemToolArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
elif False:
    AppVersionSnapshotToolSystemToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolSystemToolArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.str] name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class AppVersionSnapshotToolsetArgsDict(TypedDict):
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Timestamp when the toolset was created.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the app version.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The display name of the app version.
        """
        etag: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        ETag used to ensure the object hasn't changed during a read-modify-write
        operation. If the etag is empty, the update will overwrite any concurrent
        changes.
        """
        execution_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Possible values:
        SYNCHRONOUS
        ASYNCHRONOUS
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        open_api_toolsets: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetArgsDict']]]]
        """
        (Output)
        A toolset that contains a list of tools that are defined by an OpenAPI
        schema.
        Structure is documented below.
        """
        update_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Timestamp when the toolset was last updated.
        """
elif False:
    AppVersionSnapshotToolsetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolsetArgs:
    def __init__(__self__, *,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 etag: Optional[pulumi.Input[_builtins.str]] = None,
                 execution_type: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 open_api_toolsets: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetArgs']]]] = None,
                 update_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create_time: (Output)
               Timestamp when the toolset was created.
        :param pulumi.Input[_builtins.str] description: The description of the app version.
        :param pulumi.Input[_builtins.str] display_name: The display name of the app version.
        :param pulumi.Input[_builtins.str] etag: (Output)
               ETag used to ensure the object hasn't changed during a read-modify-write
               operation. If the etag is empty, the update will overwrite any concurrent
               changes.
        :param pulumi.Input[_builtins.str] execution_type: (Output)
               Possible values:
               SYNCHRONOUS
               ASYNCHRONOUS
        :param pulumi.Input[_builtins.str] name: (Output)
               Identifier. The unique identifier of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetArgs']]] open_api_toolsets: (Output)
               A toolset that contains a list of tools that are defined by an OpenAPI
               schema.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] update_time: (Output)
               Timestamp when the toolset was last updated.
        """
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if etag is not None:
            pulumi.set(__self__, "etag", etag)
        if execution_type is not None:
            pulumi.set(__self__, "execution_type", execution_type)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if open_api_toolsets is not None:
            pulumi.set(__self__, "open_api_toolsets", open_api_toolsets)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Timestamp when the toolset was created.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the app version.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def etag(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        ETag used to ensure the object hasn't changed during a read-modify-write
        operation. If the etag is empty, the update will overwrite any concurrent
        changes.
        """
        return pulumi.get(self, "etag")

    @etag.setter
    def etag(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "etag", value)

    @_builtins.property
    @pulumi.getter(name="executionType")
    def execution_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Possible values:
        SYNCHRONOUS
        ASYNCHRONOUS
        """
        return pulumi.get(self, "execution_type")

    @execution_type.setter
    def execution_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "execution_type", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Identifier. The unique identifier of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="openApiToolsets")
    def open_api_toolsets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetArgs']]]]:
        """
        (Output)
        A toolset that contains a list of tools that are defined by an OpenAPI
        schema.
        Structure is documented below.
        """
        return pulumi.get(self, "open_api_toolsets")

    @open_api_toolsets.setter
    def open_api_toolsets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetArgs']]]]):
        pulumi.set(self, "open_api_toolsets", value)

    @_builtins.property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Timestamp when the toolset was last updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class AppVersionSnapshotToolsetOpenApiToolsetArgsDict(TypedDict):
        api_authentications: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationArgsDict']]]]
        """
        (Output)
        Authentication information required for API calls.
        Structure is documented below.
        """
        ignore_unknown_fields: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        If true, the agent will ignore unknown fields in the API response for all
        operations defined in the OpenAPI schema.
        """
        open_api_schema: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The OpenAPI schema of the toolset.
        """
        service_directory_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetServiceDirectoryConfigArgsDict']]]]
        """
        (Output)
        Configuration for tools using Service Directory.
        Structure is documented below.
        """
        tls_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetTlsConfigArgsDict']]]]
        """
        (Output)
        The TLS configuration.
        Structure is documented below.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The server URL of the Open API schema.
        This field is only set in toolsets in the environment dependencies
        during the export process if the schema contains a server url.
        During the import process, if this url is present in the environment dependencies
        and the schema has the $env_var placeholder,
        it will replace the placeholder in the schema.
        """
elif False:
    AppVersionSnapshotToolsetOpenApiToolsetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolsetOpenApiToolsetArgs:
    def __init__(__self__, *,
                 api_authentications: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationArgs']]]] = None,
                 ignore_unknown_fields: Optional[pulumi.Input[_builtins.bool]] = None,
                 open_api_schema: Optional[pulumi.Input[_builtins.str]] = None,
                 service_directory_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetServiceDirectoryConfigArgs']]]] = None,
                 tls_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetTlsConfigArgs']]]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationArgs']]] api_authentications: (Output)
               Authentication information required for API calls.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] ignore_unknown_fields: (Output)
               If true, the agent will ignore unknown fields in the API response for all
               operations defined in the OpenAPI schema.
        :param pulumi.Input[_builtins.str] open_api_schema: (Output)
               The OpenAPI schema of the toolset.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetServiceDirectoryConfigArgs']]] service_directory_configs: (Output)
               Configuration for tools using Service Directory.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetTlsConfigArgs']]] tls_configs: (Output)
               The TLS configuration.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] url: (Output)
               The server URL of the Open API schema.
               This field is only set in toolsets in the environment dependencies
               during the export process if the schema contains a server url.
               During the import process, if this url is present in the environment dependencies
               and the schema has the $env_var placeholder,
               it will replace the placeholder in the schema.
        """
        if api_authentications is not None:
            pulumi.set(__self__, "api_authentications", api_authentications)
        if ignore_unknown_fields is not None:
            pulumi.set(__self__, "ignore_unknown_fields", ignore_unknown_fields)
        if open_api_schema is not None:
            pulumi.set(__self__, "open_api_schema", open_api_schema)
        if service_directory_configs is not None:
            pulumi.set(__self__, "service_directory_configs", service_directory_configs)
        if tls_configs is not None:
            pulumi.set(__self__, "tls_configs", tls_configs)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="apiAuthentications")
    def api_authentications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationArgs']]]]:
        """
        (Output)
        Authentication information required for API calls.
        Structure is documented below.
        """
        return pulumi.get(self, "api_authentications")

    @api_authentications.setter
    def api_authentications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationArgs']]]]):
        pulumi.set(self, "api_authentications", value)

    @_builtins.property
    @pulumi.getter(name="ignoreUnknownFields")
    def ignore_unknown_fields(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        If true, the agent will ignore unknown fields in the API response for all
        operations defined in the OpenAPI schema.
        """
        return pulumi.get(self, "ignore_unknown_fields")

    @ignore_unknown_fields.setter
    def ignore_unknown_fields(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_unknown_fields", value)

    @_builtins.property
    @pulumi.getter(name="openApiSchema")
    def open_api_schema(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The OpenAPI schema of the toolset.
        """
        return pulumi.get(self, "open_api_schema")

    @open_api_schema.setter
    def open_api_schema(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "open_api_schema", value)

    @_builtins.property
    @pulumi.getter(name="serviceDirectoryConfigs")
    def service_directory_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetServiceDirectoryConfigArgs']]]]:
        """
        (Output)
        Configuration for tools using Service Directory.
        Structure is documented below.
        """
        return pulumi.get(self, "service_directory_configs")

    @service_directory_configs.setter
    def service_directory_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetServiceDirectoryConfigArgs']]]]):
        pulumi.set(self, "service_directory_configs", value)

    @_builtins.property
    @pulumi.getter(name="tlsConfigs")
    def tls_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetTlsConfigArgs']]]]:
        """
        (Output)
        The TLS configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "tls_configs")

    @tls_configs.setter
    def tls_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetTlsConfigArgs']]]]):
        pulumi.set(self, "tls_configs", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The server URL of the Open API schema.
        This field is only set in toolsets in the environment dependencies
        during the export process if the schema contains a server url.
        During the import process, if this url is present in the environment dependencies
        and the schema has the $env_var placeholder,
        it will replace the placeholder in the schema.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationArgsDict(TypedDict):
        api_key_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgsDict']]]]
        """
        (Output)
        Configurations for authentication with API key.
        Structure is documented below.
        """
        bearer_token_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgsDict']]]]
        """
        (Output)
        Configurations for authentication with a bearer token.
        Structure is documented below.
        """
        oauth_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationOauthConfigArgsDict']]]]
        """
        (Output)
        Configurations for authentication with OAuth.
        Structure is documented below.
        """
        service_account_auth_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgsDict']]]]
        """
        (Output)
        Configurations for authentication using a custom service account.
        Structure is documented below.
        """
        service_agent_id_token_auth_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict']]]]
        """
        (Output)
        Configurations for authentication with [ID
        token](https://cloud.google.com/docs/authentication/token-types#id) generated
        from service agent.
        """
elif False:
    AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationArgs:
    def __init__(__self__, *,
                 api_key_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs']]]] = None,
                 bearer_token_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs']]]] = None,
                 oauth_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs']]]] = None,
                 service_account_auth_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs']]]] = None,
                 service_agent_id_token_auth_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs']]] api_key_configs: (Output)
               Configurations for authentication with API key.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs']]] bearer_token_configs: (Output)
               Configurations for authentication with a bearer token.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs']]] oauth_configs: (Output)
               Configurations for authentication with OAuth.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs']]] service_account_auth_configs: (Output)
               Configurations for authentication using a custom service account.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]] service_agent_id_token_auth_configs: (Output)
               Configurations for authentication with [ID
               token](https://cloud.google.com/docs/authentication/token-types#id) generated
               from service agent.
        """
        if api_key_configs is not None:
            pulumi.set(__self__, "api_key_configs", api_key_configs)
        if bearer_token_configs is not None:
            pulumi.set(__self__, "bearer_token_configs", bearer_token_configs)
        if oauth_configs is not None:
            pulumi.set(__self__, "oauth_configs", oauth_configs)
        if service_account_auth_configs is not None:
            pulumi.set(__self__, "service_account_auth_configs", service_account_auth_configs)
        if service_agent_id_token_auth_configs is not None:
            pulumi.set(__self__, "service_agent_id_token_auth_configs", service_agent_id_token_auth_configs)

    @_builtins.property
    @pulumi.getter(name="apiKeyConfigs")
    def api_key_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs']]]]:
        """
        (Output)
        Configurations for authentication with API key.
        Structure is documented below.
        """
        return pulumi.get(self, "api_key_configs")

    @api_key_configs.setter
    def api_key_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs']]]]):
        pulumi.set(self, "api_key_configs", value)

    @_builtins.property
    @pulumi.getter(name="bearerTokenConfigs")
    def bearer_token_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs']]]]:
        """
        (Output)
        Configurations for authentication with a bearer token.
        Structure is documented below.
        """
        return pulumi.get(self, "bearer_token_configs")

    @bearer_token_configs.setter
    def bearer_token_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs']]]]):
        pulumi.set(self, "bearer_token_configs", value)

    @_builtins.property
    @pulumi.getter(name="oauthConfigs")
    def oauth_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs']]]]:
        """
        (Output)
        Configurations for authentication with OAuth.
        Structure is documented below.
        """
        return pulumi.get(self, "oauth_configs")

    @oauth_configs.setter
    def oauth_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs']]]]):
        pulumi.set(self, "oauth_configs", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccountAuthConfigs")
    def service_account_auth_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs']]]]:
        """
        (Output)
        Configurations for authentication using a custom service account.
        Structure is documented below.
        """
        return pulumi.get(self, "service_account_auth_configs")

    @service_account_auth_configs.setter
    def service_account_auth_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs']]]]):
        pulumi.set(self, "service_account_auth_configs", value)

    @_builtins.property
    @pulumi.getter(name="serviceAgentIdTokenAuthConfigs")
    def service_agent_id_token_auth_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]]]:
        """
        (Output)
        Configurations for authentication with [ID
        token](https://cloud.google.com/docs/authentication/token-types#id) generated
        from service agent.
        """
        return pulumi.get(self, "service_agent_id_token_auth_configs")

    @service_agent_id_token_auth_configs.setter
    def service_agent_id_token_auth_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]]]):
        pulumi.set(self, "service_agent_id_token_auth_configs", value)


if not MYPY:
    class AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgsDict(TypedDict):
        api_key_secret_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the SecretManager secret version resource storing the API key.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        key_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        request_location: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Key location in the request.
        Possible values:
        HEADER
        QUERY_STRING
        """
elif False:
    AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs:
    def __init__(__self__, *,
                 api_key_secret_version: Optional[pulumi.Input[_builtins.str]] = None,
                 key_name: Optional[pulumi.Input[_builtins.str]] = None,
                 request_location: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key_secret_version: (Output)
               The name of the SecretManager secret version resource storing the API key.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param pulumi.Input[_builtins.str] key_name: (Output)
               The parameter name or the header name of the API key.
               E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        :param pulumi.Input[_builtins.str] request_location: (Output)
               Key location in the request.
               Possible values:
               HEADER
               QUERY_STRING
        """
        if api_key_secret_version is not None:
            pulumi.set(__self__, "api_key_secret_version", api_key_secret_version)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if request_location is not None:
            pulumi.set(__self__, "request_location", request_location)

    @_builtins.property
    @pulumi.getter(name="apiKeySecretVersion")
    def api_key_secret_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the SecretManager secret version resource storing the API key.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "api_key_secret_version")

    @api_key_secret_version.setter
    def api_key_secret_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_key_secret_version", value)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter(name="requestLocation")
    def request_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Key location in the request.
        Possible values:
        HEADER
        QUERY_STRING
        """
        return pulumi.get(self, "request_location")

    @request_location.setter
    def request_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request_location", value)


if not MYPY:
    class AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgsDict(TypedDict):
        token: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        """
elif False:
    AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs:
    def __init__(__self__, *,
                 token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] token: (Output)
        """
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)


if not MYPY:
    class AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationOauthConfigArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The client ID from the OAuth provider.
        """
        client_secret_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the SecretManager secret version resource storing the
        client secret.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        oauth_grant_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        OAuth grant types.
        Possible values:
        CLIENT_CREDENTIAL
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        The OAuth scopes to grant.
        """
        token_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The token endpoint in the OAuth provider to exchange for an access token.
        """
elif False:
    AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationOauthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret_version: Optional[pulumi.Input[_builtins.str]] = None,
                 oauth_grant_type: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id: (Output)
               The client ID from the OAuth provider.
        :param pulumi.Input[_builtins.str] client_secret_version: (Output)
               The name of the SecretManager secret version resource storing the
               client secret.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param pulumi.Input[_builtins.str] oauth_grant_type: (Output)
               OAuth grant types.
               Possible values:
               CLIENT_CREDENTIAL
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: (Output)
               The OAuth scopes to grant.
        :param pulumi.Input[_builtins.str] token_endpoint: (Output)
               The token endpoint in the OAuth provider to exchange for an access token.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_version is not None:
            pulumi.set(__self__, "client_secret_version", client_secret_version)
        if oauth_grant_type is not None:
            pulumi.set(__self__, "oauth_grant_type", oauth_grant_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The client ID from the OAuth provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretVersion")
    def client_secret_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the SecretManager secret version resource storing the
        client secret.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "client_secret_version")

    @client_secret_version.setter
    def client_secret_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret_version", value)

    @_builtins.property
    @pulumi.getter(name="oauthGrantType")
    def oauth_grant_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        OAuth grant types.
        Possible values:
        CLIENT_CREDENTIAL
        """
        return pulumi.get(self, "oauth_grant_type")

    @oauth_grant_type.setter
    def oauth_grant_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oauth_grant_type", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        The OAuth scopes to grant.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The token endpoint in the OAuth provider to exchange for an access token.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_endpoint", value)


if not MYPY:
    class AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgsDict(TypedDict):
        service_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The email address of the service account used for authenticatation. CES
        uses this service account to exchange an access token and the access token
        is then sent in the `Authorization` header of the request.
        The service account must have the
        `roles/iam.serviceAccountTokenCreator` role granted to the
        CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
elif False:
    AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs:
    def __init__(__self__, *,
                 service_account: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] service_account: (Output)
               The email address of the service account used for authenticatation. CES
               uses this service account to exchange an access token and the access token
               is then sent in the `Authorization` header of the request.
               The service account must have the
               `roles/iam.serviceAccountTokenCreator` role granted to the
               CES service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The email address of the service account used for authenticatation. CES
        uses this service account to exchange an access token and the access token
        is then sent in the `Authorization` header of the request.
        The service account must have the
        `roles/iam.serviceAccountTokenCreator` role granted to the
        CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_account", value)


if not MYPY:
    class AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict(TypedDict):
        pass
elif False:
    AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AppVersionSnapshotToolsetOpenApiToolsetServiceDirectoryConfigArgsDict(TypedDict):
        service: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of [Service
        Directory](https://cloud.google.com/service-directory) service.
        Format:
        `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
        Location of the service directory must be the same as the location of the
        app.
        """
elif False:
    AppVersionSnapshotToolsetOpenApiToolsetServiceDirectoryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolsetOpenApiToolsetServiceDirectoryConfigArgs:
    def __init__(__self__, *,
                 service: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] service: (Output)
               The name of [Service
               Directory](https://cloud.google.com/service-directory) service.
               Format:
               `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
               Location of the service directory must be the same as the location of the
               app.
        """
        if service is not None:
            pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of [Service
        Directory](https://cloud.google.com/service-directory) service.
        Format:
        `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
        Location of the service directory must be the same as the location of the
        app.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service", value)


if not MYPY:
    class AppVersionSnapshotToolsetOpenApiToolsetTlsConfigArgsDict(TypedDict):
        ca_certs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetTlsConfigCaCertArgsDict']]]]
        """
        (Output)
        Specifies a list of allowed custom CA certificates for HTTPS
        verification.
        Structure is documented below.
        """
elif False:
    AppVersionSnapshotToolsetOpenApiToolsetTlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolsetOpenApiToolsetTlsConfigArgs:
    def __init__(__self__, *,
                 ca_certs: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetTlsConfigCaCertArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetTlsConfigCaCertArgs']]] ca_certs: (Output)
               Specifies a list of allowed custom CA certificates for HTTPS
               verification.
               Structure is documented below.
        """
        if ca_certs is not None:
            pulumi.set(__self__, "ca_certs", ca_certs)

    @_builtins.property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetTlsConfigCaCertArgs']]]]:
        """
        (Output)
        Specifies a list of allowed custom CA certificates for HTTPS
        verification.
        Structure is documented below.
        """
        return pulumi.get(self, "ca_certs")

    @ca_certs.setter
    def ca_certs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppVersionSnapshotToolsetOpenApiToolsetTlsConfigCaCertArgs']]]]):
        pulumi.set(self, "ca_certs", value)


if not MYPY:
    class AppVersionSnapshotToolsetOpenApiToolsetTlsConfigCaCertArgsDict(TypedDict):
        cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, CES will use Google's default trust
        store to verify certificates. N.B. Make sure the HTTPS server
        certificates are signed with "subject alt name". For instance a
        certificate can be self-signed using the following command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The display name of the app version.
        """
elif False:
    AppVersionSnapshotToolsetOpenApiToolsetTlsConfigCaCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVersionSnapshotToolsetOpenApiToolsetTlsConfigCaCertArgs:
    def __init__(__self__, *,
                 cert: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cert: (Output)
               The allowed custom CA certificates (in DER format) for
               HTTPS verification. This overrides the default SSL trust store. If this
               is empty or unspecified, CES will use Google's default trust
               store to verify certificates. N.B. Make sure the HTTPS server
               certificates are signed with "subject alt name". For instance a
               certificate can be self-signed using the following command,
               openssl x509 -req -days 200 -in example.com.csr \\
               -signkey example.com.key \\
               -out example.com.crt \\
               -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        :param pulumi.Input[_builtins.str] display_name: The display name of the app version.
        """
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, CES will use Google's default trust
        store to verify certificates. N.B. Make sure the HTTPS server
        certificates are signed with "subject alt name". For instance a
        certificate can be self-signed using the following command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        """
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cert", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The display name of the app version.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class DeploymentChannelProfileArgsDict(TypedDict):
        channel_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the channel profile.
        Possible values:
        UNKNOWN
        WEB_UI
        API
        TWILIO
        GOOGLE_TELEPHONY_PLATFORM
        CONTACT_CENTER_AS_A_SERVICE
        """
        disable_barge_in_control: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable user barge-in control in the conversation.
        - **true**: User interruptions are disabled while the agent is speaking.
        - **false**: The agent retains automatic control over when the user can
        interrupt.
        """
        disable_dtmf: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable DTMF (dual-tone multi-frequency).
        """
        persona_property: NotRequired[pulumi.Input['DeploymentChannelProfilePersonaPropertyArgsDict']]
        """
        Represents the persona property of a channel.
        Structure is documented below.
        """
        profile_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier of the channel profile.
        """
        web_widget_config: NotRequired[pulumi.Input['DeploymentChannelProfileWebWidgetConfigArgsDict']]
        """
        Message for configuration for the web widget.
        Structure is documented below.
        """
elif False:
    DeploymentChannelProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentChannelProfileArgs:
    def __init__(__self__, *,
                 channel_type: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_barge_in_control: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_dtmf: Optional[pulumi.Input[_builtins.bool]] = None,
                 persona_property: Optional[pulumi.Input['DeploymentChannelProfilePersonaPropertyArgs']] = None,
                 profile_id: Optional[pulumi.Input[_builtins.str]] = None,
                 web_widget_config: Optional[pulumi.Input['DeploymentChannelProfileWebWidgetConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] channel_type: The type of the channel profile.
               Possible values:
               UNKNOWN
               WEB_UI
               API
               TWILIO
               GOOGLE_TELEPHONY_PLATFORM
               CONTACT_CENTER_AS_A_SERVICE
        :param pulumi.Input[_builtins.bool] disable_barge_in_control: Whether to disable user barge-in control in the conversation.
               - **true**: User interruptions are disabled while the agent is speaking.
               - **false**: The agent retains automatic control over when the user can
               interrupt.
        :param pulumi.Input[_builtins.bool] disable_dtmf: Whether to disable DTMF (dual-tone multi-frequency).
        :param pulumi.Input['DeploymentChannelProfilePersonaPropertyArgs'] persona_property: Represents the persona property of a channel.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] profile_id: The unique identifier of the channel profile.
        :param pulumi.Input['DeploymentChannelProfileWebWidgetConfigArgs'] web_widget_config: Message for configuration for the web widget.
               Structure is documented below.
        """
        if channel_type is not None:
            pulumi.set(__self__, "channel_type", channel_type)
        if disable_barge_in_control is not None:
            pulumi.set(__self__, "disable_barge_in_control", disable_barge_in_control)
        if disable_dtmf is not None:
            pulumi.set(__self__, "disable_dtmf", disable_dtmf)
        if persona_property is not None:
            pulumi.set(__self__, "persona_property", persona_property)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if web_widget_config is not None:
            pulumi.set(__self__, "web_widget_config", web_widget_config)

    @_builtins.property
    @pulumi.getter(name="channelType")
    def channel_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the channel profile.
        Possible values:
        UNKNOWN
        WEB_UI
        API
        TWILIO
        GOOGLE_TELEPHONY_PLATFORM
        CONTACT_CENTER_AS_A_SERVICE
        """
        return pulumi.get(self, "channel_type")

    @channel_type.setter
    def channel_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel_type", value)

    @_builtins.property
    @pulumi.getter(name="disableBargeInControl")
    def disable_barge_in_control(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable user barge-in control in the conversation.
        - **true**: User interruptions are disabled while the agent is speaking.
        - **false**: The agent retains automatic control over when the user can
        interrupt.
        """
        return pulumi.get(self, "disable_barge_in_control")

    @disable_barge_in_control.setter
    def disable_barge_in_control(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_barge_in_control", value)

    @_builtins.property
    @pulumi.getter(name="disableDtmf")
    def disable_dtmf(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable DTMF (dual-tone multi-frequency).
        """
        return pulumi.get(self, "disable_dtmf")

    @disable_dtmf.setter
    def disable_dtmf(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_dtmf", value)

    @_builtins.property
    @pulumi.getter(name="personaProperty")
    def persona_property(self) -> Optional[pulumi.Input['DeploymentChannelProfilePersonaPropertyArgs']]:
        """
        Represents the persona property of a channel.
        Structure is documented below.
        """
        return pulumi.get(self, "persona_property")

    @persona_property.setter
    def persona_property(self, value: Optional[pulumi.Input['DeploymentChannelProfilePersonaPropertyArgs']]):
        pulumi.set(self, "persona_property", value)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier of the channel profile.
        """
        return pulumi.get(self, "profile_id")

    @profile_id.setter
    def profile_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile_id", value)

    @_builtins.property
    @pulumi.getter(name="webWidgetConfig")
    def web_widget_config(self) -> Optional[pulumi.Input['DeploymentChannelProfileWebWidgetConfigArgs']]:
        """
        Message for configuration for the web widget.
        Structure is documented below.
        """
        return pulumi.get(self, "web_widget_config")

    @web_widget_config.setter
    def web_widget_config(self, value: Optional[pulumi.Input['DeploymentChannelProfileWebWidgetConfigArgs']]):
        pulumi.set(self, "web_widget_config", value)


if not MYPY:
    class DeploymentChannelProfilePersonaPropertyArgsDict(TypedDict):
        persona: NotRequired[pulumi.Input[_builtins.str]]
        """
        The persona of the channel.
        Possible values:
        UNKNOWN
        CONCISE
        CHATTY
        """
elif False:
    DeploymentChannelProfilePersonaPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentChannelProfilePersonaPropertyArgs:
    def __init__(__self__, *,
                 persona: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] persona: The persona of the channel.
               Possible values:
               UNKNOWN
               CONCISE
               CHATTY
        """
        if persona is not None:
            pulumi.set(__self__, "persona", persona)

    @_builtins.property
    @pulumi.getter
    def persona(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The persona of the channel.
        Possible values:
        UNKNOWN
        CONCISE
        CHATTY
        """
        return pulumi.get(self, "persona")

    @persona.setter
    def persona(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "persona", value)


if not MYPY:
    class DeploymentChannelProfileWebWidgetConfigArgsDict(TypedDict):
        modality: NotRequired[pulumi.Input[_builtins.str]]
        """
        The modality of the web widget.
        Possible values:
        UNKNOWN_MODALITY
        CHAT_AND_VOICE
        VOICE_ONLY
        CHAT_ONLY
        """
        theme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The theme of the web widget.
        Possible values:
        UNKNOWN_THEME
        LIGHT
        DARK
        """
        web_widget_title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The title of the web widget.
        """
elif False:
    DeploymentChannelProfileWebWidgetConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentChannelProfileWebWidgetConfigArgs:
    def __init__(__self__, *,
                 modality: Optional[pulumi.Input[_builtins.str]] = None,
                 theme: Optional[pulumi.Input[_builtins.str]] = None,
                 web_widget_title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] modality: The modality of the web widget.
               Possible values:
               UNKNOWN_MODALITY
               CHAT_AND_VOICE
               VOICE_ONLY
               CHAT_ONLY
        :param pulumi.Input[_builtins.str] theme: The theme of the web widget.
               Possible values:
               UNKNOWN_THEME
               LIGHT
               DARK
        :param pulumi.Input[_builtins.str] web_widget_title: The title of the web widget.
        """
        if modality is not None:
            pulumi.set(__self__, "modality", modality)
        if theme is not None:
            pulumi.set(__self__, "theme", theme)
        if web_widget_title is not None:
            pulumi.set(__self__, "web_widget_title", web_widget_title)

    @_builtins.property
    @pulumi.getter
    def modality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The modality of the web widget.
        Possible values:
        UNKNOWN_MODALITY
        CHAT_AND_VOICE
        VOICE_ONLY
        CHAT_ONLY
        """
        return pulumi.get(self, "modality")

    @modality.setter
    def modality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "modality", value)

    @_builtins.property
    @pulumi.getter
    def theme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The theme of the web widget.
        Possible values:
        UNKNOWN_THEME
        LIGHT
        DARK
        """
        return pulumi.get(self, "theme")

    @theme.setter
    def theme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "theme", value)

    @_builtins.property
    @pulumi.getter(name="webWidgetTitle")
    def web_widget_title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The title of the web widget.
        """
        return pulumi.get(self, "web_widget_title")

    @web_widget_title.setter
    def web_widget_title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_widget_title", value)


if not MYPY:
    class ExampleMessageArgsDict(TypedDict):
        chunks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExampleMessageChunkArgsDict']]]]
        """
        Content of the message as a series of chunks.
        Structure is documented below.
        """
        role: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role within the conversation, e.g., user, agent.
        """
elif False:
    ExampleMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExampleMessageArgs:
    def __init__(__self__, *,
                 chunks: Optional[pulumi.Input[Sequence[pulumi.Input['ExampleMessageChunkArgs']]]] = None,
                 role: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ExampleMessageChunkArgs']]] chunks: Content of the message as a series of chunks.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] role: The role within the conversation, e.g., user, agent.
        """
        if chunks is not None:
            pulumi.set(__self__, "chunks", chunks)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def chunks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExampleMessageChunkArgs']]]]:
        """
        Content of the message as a series of chunks.
        Structure is documented below.
        """
        return pulumi.get(self, "chunks")

    @chunks.setter
    def chunks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExampleMessageChunkArgs']]]]):
        pulumi.set(self, "chunks", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role within the conversation, e.g., user, agent.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class ExampleMessageChunkArgsDict(TypedDict):
        agent_transfer: NotRequired[pulumi.Input['ExampleMessageChunkAgentTransferArgsDict']]
        """
        Represents an event indicating the transfer of a conversation to a different
        agent.
        Structure is documented below.
        """
        image: NotRequired[pulumi.Input['ExampleMessageChunkImageArgsDict']]
        """
        Represents an image input or output in the conversation.
        Structure is documented below.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        Text data.
        """
        tool_call: NotRequired[pulumi.Input['ExampleMessageChunkToolCallArgsDict']]
        """
        Request for the client or the agent to execute the specified tool.
        Structure is documented below.
        """
        tool_response: NotRequired[pulumi.Input['ExampleMessageChunkToolResponseArgsDict']]
        """
        The execution result of a specific tool from the client or the agent.
        Structure is documented below.
        """
        updated_variables: NotRequired[pulumi.Input[_builtins.str]]
        """
        A struct represents variables that were updated in the conversation,
        keyed by variable names.
        """
elif False:
    ExampleMessageChunkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExampleMessageChunkArgs:
    def __init__(__self__, *,
                 agent_transfer: Optional[pulumi.Input['ExampleMessageChunkAgentTransferArgs']] = None,
                 image: Optional[pulumi.Input['ExampleMessageChunkImageArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None,
                 tool_call: Optional[pulumi.Input['ExampleMessageChunkToolCallArgs']] = None,
                 tool_response: Optional[pulumi.Input['ExampleMessageChunkToolResponseArgs']] = None,
                 updated_variables: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ExampleMessageChunkAgentTransferArgs'] agent_transfer: Represents an event indicating the transfer of a conversation to a different
               agent.
               Structure is documented below.
        :param pulumi.Input['ExampleMessageChunkImageArgs'] image: Represents an image input or output in the conversation.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] text: Text data.
        :param pulumi.Input['ExampleMessageChunkToolCallArgs'] tool_call: Request for the client or the agent to execute the specified tool.
               Structure is documented below.
        :param pulumi.Input['ExampleMessageChunkToolResponseArgs'] tool_response: The execution result of a specific tool from the client or the agent.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] updated_variables: A struct represents variables that were updated in the conversation,
               keyed by variable names.
        """
        if agent_transfer is not None:
            pulumi.set(__self__, "agent_transfer", agent_transfer)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if tool_call is not None:
            pulumi.set(__self__, "tool_call", tool_call)
        if tool_response is not None:
            pulumi.set(__self__, "tool_response", tool_response)
        if updated_variables is not None:
            pulumi.set(__self__, "updated_variables", updated_variables)

    @_builtins.property
    @pulumi.getter(name="agentTransfer")
    def agent_transfer(self) -> Optional[pulumi.Input['ExampleMessageChunkAgentTransferArgs']]:
        """
        Represents an event indicating the transfer of a conversation to a different
        agent.
        Structure is documented below.
        """
        return pulumi.get(self, "agent_transfer")

    @agent_transfer.setter
    def agent_transfer(self, value: Optional[pulumi.Input['ExampleMessageChunkAgentTransferArgs']]):
        pulumi.set(self, "agent_transfer", value)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['ExampleMessageChunkImageArgs']]:
        """
        Represents an image input or output in the conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['ExampleMessageChunkImageArgs']]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Text data.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter(name="toolCall")
    def tool_call(self) -> Optional[pulumi.Input['ExampleMessageChunkToolCallArgs']]:
        """
        Request for the client or the agent to execute the specified tool.
        Structure is documented below.
        """
        return pulumi.get(self, "tool_call")

    @tool_call.setter
    def tool_call(self, value: Optional[pulumi.Input['ExampleMessageChunkToolCallArgs']]):
        pulumi.set(self, "tool_call", value)

    @_builtins.property
    @pulumi.getter(name="toolResponse")
    def tool_response(self) -> Optional[pulumi.Input['ExampleMessageChunkToolResponseArgs']]:
        """
        The execution result of a specific tool from the client or the agent.
        Structure is documented below.
        """
        return pulumi.get(self, "tool_response")

    @tool_response.setter
    def tool_response(self, value: Optional[pulumi.Input['ExampleMessageChunkToolResponseArgs']]):
        pulumi.set(self, "tool_response", value)

    @_builtins.property
    @pulumi.getter(name="updatedVariables")
    def updated_variables(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A struct represents variables that were updated in the conversation,
        keyed by variable names.
        """
        return pulumi.get(self, "updated_variables")

    @updated_variables.setter
    def updated_variables(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_variables", value)


if not MYPY:
    class ExampleMessageChunkAgentTransferArgsDict(TypedDict):
        target_agent: pulumi.Input[_builtins.str]
        """
        The agent to which the conversation is being transferred. The agent will
        handle the conversation from this point forward.
        Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Display name of the agent.
        """
elif False:
    ExampleMessageChunkAgentTransferArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExampleMessageChunkAgentTransferArgs:
    def __init__(__self__, *,
                 target_agent: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] target_agent: The agent to which the conversation is being transferred. The agent will
               handle the conversation from this point forward.
               Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        :param pulumi.Input[_builtins.str] display_name: (Output)
               Display name of the agent.
        """
        pulumi.set(__self__, "target_agent", target_agent)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter(name="targetAgent")
    def target_agent(self) -> pulumi.Input[_builtins.str]:
        """
        The agent to which the conversation is being transferred. The agent will
        handle the conversation from this point forward.
        Format: `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        return pulumi.get(self, "target_agent")

    @target_agent.setter
    def target_agent(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_agent", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Display name of the agent.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ExampleMessageChunkImageArgsDict(TypedDict):
        data: pulumi.Input[_builtins.str]
        """
        Raw bytes of the image.
        """
        mime_type: pulumi.Input[_builtins.str]
        """
        The IANA standard MIME type of the source data.
        Supported image types includes:
        * image/png
        * image/jpeg
        * image/webp
        """
elif False:
    ExampleMessageChunkImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExampleMessageChunkImageArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[_builtins.str],
                 mime_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] data: Raw bytes of the image.
        :param pulumi.Input[_builtins.str] mime_type: The IANA standard MIME type of the source data.
               Supported image types includes:
               * image/png
               * image/jpeg
               * image/webp
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "mime_type", mime_type)

    @_builtins.property
    @pulumi.getter
    def data(self) -> pulumi.Input[_builtins.str]:
        """
        Raw bytes of the image.
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data", value)

    @_builtins.property
    @pulumi.getter(name="mimeType")
    def mime_type(self) -> pulumi.Input[_builtins.str]:
        """
        The IANA standard MIME type of the source data.
        Supported image types includes:
        * image/png
        * image/jpeg
        * image/webp
        """
        return pulumi.get(self, "mime_type")

    @mime_type.setter
    def mime_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mime_type", value)


if not MYPY:
    class ExampleMessageChunkToolCallArgsDict(TypedDict):
        args: NotRequired[pulumi.Input[_builtins.str]]
        """
        The input parameters and values for the tool in JSON object format.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Display name of the tool.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier of the tool call. If populated, the client should
        return the execution result with the matching ID in
        ToolResponse.
        """
        tool: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the tool to execute.
        Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        """
        toolset_tool: NotRequired[pulumi.Input['ExampleMessageChunkToolCallToolsetToolArgsDict']]
        """
        A tool that is created from a toolset.
        Structure is documented below.
        """
elif False:
    ExampleMessageChunkToolCallArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExampleMessageChunkToolCallArgs:
    def __init__(__self__, *,
                 args: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 tool: Optional[pulumi.Input[_builtins.str]] = None,
                 toolset_tool: Optional[pulumi.Input['ExampleMessageChunkToolCallToolsetToolArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] args: The input parameters and values for the tool in JSON object format.
        :param pulumi.Input[_builtins.str] display_name: (Output)
               Display name of the tool.
        :param pulumi.Input[_builtins.str] id: The unique identifier of the tool call. If populated, the client should
               return the execution result with the matching ID in
               ToolResponse.
        :param pulumi.Input[_builtins.str] tool: The name of the tool to execute.
               Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        :param pulumi.Input['ExampleMessageChunkToolCallToolsetToolArgs'] toolset_tool: A tool that is created from a toolset.
               Structure is documented below.
        """
        if args is not None:
            pulumi.set(__self__, "args", args)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if tool is not None:
            pulumi.set(__self__, "tool", tool)
        if toolset_tool is not None:
            pulumi.set(__self__, "toolset_tool", toolset_tool)

    @_builtins.property
    @pulumi.getter
    def args(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The input parameters and values for the tool in JSON object format.
        """
        return pulumi.get(self, "args")

    @args.setter
    def args(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "args", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Display name of the tool.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier of the tool call. If populated, the client should
        return the execution result with the matching ID in
        ToolResponse.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def tool(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the tool to execute.
        Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        """
        return pulumi.get(self, "tool")

    @tool.setter
    def tool(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tool", value)

    @_builtins.property
    @pulumi.getter(name="toolsetTool")
    def toolset_tool(self) -> Optional[pulumi.Input['ExampleMessageChunkToolCallToolsetToolArgs']]:
        """
        A tool that is created from a toolset.
        Structure is documented below.
        """
        return pulumi.get(self, "toolset_tool")

    @toolset_tool.setter
    def toolset_tool(self, value: Optional[pulumi.Input['ExampleMessageChunkToolCallToolsetToolArgs']]):
        pulumi.set(self, "toolset_tool", value)


if not MYPY:
    class ExampleMessageChunkToolCallToolsetToolArgsDict(TypedDict):
        toolset: pulumi.Input[_builtins.str]
        """
        The resource name of the Toolset from which this tool is derived.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        tool_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tool ID to filter the tools to retrieve the schema for.
        """
elif False:
    ExampleMessageChunkToolCallToolsetToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExampleMessageChunkToolCallToolsetToolArgs:
    def __init__(__self__, *,
                 toolset: pulumi.Input[_builtins.str],
                 tool_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] toolset: The resource name of the Toolset from which this tool is derived.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param pulumi.Input[_builtins.str] tool_id: The tool ID to filter the tools to retrieve the schema for.
        """
        pulumi.set(__self__, "toolset", toolset)
        if tool_id is not None:
            pulumi.set(__self__, "tool_id", tool_id)

    @_builtins.property
    @pulumi.getter
    def toolset(self) -> pulumi.Input[_builtins.str]:
        """
        The resource name of the Toolset from which this tool is derived.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "toolset")

    @toolset.setter
    def toolset(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "toolset", value)

    @_builtins.property
    @pulumi.getter(name="toolId")
    def tool_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tool ID to filter the tools to retrieve the schema for.
        """
        return pulumi.get(self, "tool_id")

    @tool_id.setter
    def tool_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tool_id", value)


if not MYPY:
    class ExampleMessageChunkToolResponseArgsDict(TypedDict):
        response: pulumi.Input[_builtins.str]
        """
        The tool execution result in JSON object format.
        Use "output" key to specify tool response and "error" key to specify
        error details (if any). If "output" and "error" keys are not specified,
        then whole "response" is treated as tool execution result.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Display name of the tool.
        """
        id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The matching ID of the tool call the response is for.
        """
        tool: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the tool to execute.
        Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        """
        toolset_tool: NotRequired[pulumi.Input['ExampleMessageChunkToolResponseToolsetToolArgsDict']]
        """
        A tool that is created from a toolset.
        Structure is documented below.
        """
elif False:
    ExampleMessageChunkToolResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExampleMessageChunkToolResponseArgs:
    def __init__(__self__, *,
                 response: pulumi.Input[_builtins.str],
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 id: Optional[pulumi.Input[_builtins.str]] = None,
                 tool: Optional[pulumi.Input[_builtins.str]] = None,
                 toolset_tool: Optional[pulumi.Input['ExampleMessageChunkToolResponseToolsetToolArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] response: The tool execution result in JSON object format.
               Use "output" key to specify tool response and "error" key to specify
               error details (if any). If "output" and "error" keys are not specified,
               then whole "response" is treated as tool execution result.
        :param pulumi.Input[_builtins.str] display_name: (Output)
               Display name of the tool.
        :param pulumi.Input[_builtins.str] id: The matching ID of the tool call the response is for.
        :param pulumi.Input[_builtins.str] tool: The name of the tool to execute.
               Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        :param pulumi.Input['ExampleMessageChunkToolResponseToolsetToolArgs'] toolset_tool: A tool that is created from a toolset.
               Structure is documented below.
        """
        pulumi.set(__self__, "response", response)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if id is not None:
            pulumi.set(__self__, "id", id)
        if tool is not None:
            pulumi.set(__self__, "tool", tool)
        if toolset_tool is not None:
            pulumi.set(__self__, "toolset_tool", toolset_tool)

    @_builtins.property
    @pulumi.getter
    def response(self) -> pulumi.Input[_builtins.str]:
        """
        The tool execution result in JSON object format.
        Use "output" key to specify tool response and "error" key to specify
        error details (if any). If "output" and "error" keys are not specified,
        then whole "response" is treated as tool execution result.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "response", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Display name of the tool.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter
    def id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The matching ID of the tool call the response is for.
        """
        return pulumi.get(self, "id")

    @id.setter
    def id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "id", value)

    @_builtins.property
    @pulumi.getter
    def tool(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the tool to execute.
        Format: `projects/{project}/locations/{location}/apps/{app}/tools/{tool}`
        """
        return pulumi.get(self, "tool")

    @tool.setter
    def tool(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tool", value)

    @_builtins.property
    @pulumi.getter(name="toolsetTool")
    def toolset_tool(self) -> Optional[pulumi.Input['ExampleMessageChunkToolResponseToolsetToolArgs']]:
        """
        A tool that is created from a toolset.
        Structure is documented below.
        """
        return pulumi.get(self, "toolset_tool")

    @toolset_tool.setter
    def toolset_tool(self, value: Optional[pulumi.Input['ExampleMessageChunkToolResponseToolsetToolArgs']]):
        pulumi.set(self, "toolset_tool", value)


if not MYPY:
    class ExampleMessageChunkToolResponseToolsetToolArgsDict(TypedDict):
        toolset: pulumi.Input[_builtins.str]
        """
        The resource name of the Toolset from which this tool is derived.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        tool_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tool ID to filter the tools to retrieve the schema for.
        """
elif False:
    ExampleMessageChunkToolResponseToolsetToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExampleMessageChunkToolResponseToolsetToolArgs:
    def __init__(__self__, *,
                 toolset: pulumi.Input[_builtins.str],
                 tool_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] toolset: The resource name of the Toolset from which this tool is derived.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param pulumi.Input[_builtins.str] tool_id: The tool ID to filter the tools to retrieve the schema for.
        """
        pulumi.set(__self__, "toolset", toolset)
        if tool_id is not None:
            pulumi.set(__self__, "tool_id", tool_id)

    @_builtins.property
    @pulumi.getter
    def toolset(self) -> pulumi.Input[_builtins.str]:
        """
        The resource name of the Toolset from which this tool is derived.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "toolset")

    @toolset.setter
    def toolset(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "toolset", value)

    @_builtins.property
    @pulumi.getter(name="toolId")
    def tool_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tool ID to filter the tools to retrieve the schema for.
        """
        return pulumi.get(self, "tool_id")

    @tool_id.setter
    def tool_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "tool_id", value)


if not MYPY:
    class GuardrailActionArgsDict(TypedDict):
        generative_answer: NotRequired[pulumi.Input['GuardrailActionGenerativeAnswerArgsDict']]
        """
        The agent will immediately respond with a generative answer.
        Structure is documented below.
        """
        respond_immediately: NotRequired[pulumi.Input['GuardrailActionRespondImmediatelyArgsDict']]
        """
        The agent will immediately respond with a preconfigured response.
        Structure is documented below.
        """
        transfer_agent: NotRequired[pulumi.Input['GuardrailActionTransferAgentArgsDict']]
        """
        The agent will transfer the conversation to a different agent.
        Structure is documented below.
        """
elif False:
    GuardrailActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailActionArgs:
    def __init__(__self__, *,
                 generative_answer: Optional[pulumi.Input['GuardrailActionGenerativeAnswerArgs']] = None,
                 respond_immediately: Optional[pulumi.Input['GuardrailActionRespondImmediatelyArgs']] = None,
                 transfer_agent: Optional[pulumi.Input['GuardrailActionTransferAgentArgs']] = None):
        """
        :param pulumi.Input['GuardrailActionGenerativeAnswerArgs'] generative_answer: The agent will immediately respond with a generative answer.
               Structure is documented below.
        :param pulumi.Input['GuardrailActionRespondImmediatelyArgs'] respond_immediately: The agent will immediately respond with a preconfigured response.
               Structure is documented below.
        :param pulumi.Input['GuardrailActionTransferAgentArgs'] transfer_agent: The agent will transfer the conversation to a different agent.
               Structure is documented below.
        """
        if generative_answer is not None:
            pulumi.set(__self__, "generative_answer", generative_answer)
        if respond_immediately is not None:
            pulumi.set(__self__, "respond_immediately", respond_immediately)
        if transfer_agent is not None:
            pulumi.set(__self__, "transfer_agent", transfer_agent)

    @_builtins.property
    @pulumi.getter(name="generativeAnswer")
    def generative_answer(self) -> Optional[pulumi.Input['GuardrailActionGenerativeAnswerArgs']]:
        """
        The agent will immediately respond with a generative answer.
        Structure is documented below.
        """
        return pulumi.get(self, "generative_answer")

    @generative_answer.setter
    def generative_answer(self, value: Optional[pulumi.Input['GuardrailActionGenerativeAnswerArgs']]):
        pulumi.set(self, "generative_answer", value)

    @_builtins.property
    @pulumi.getter(name="respondImmediately")
    def respond_immediately(self) -> Optional[pulumi.Input['GuardrailActionRespondImmediatelyArgs']]:
        """
        The agent will immediately respond with a preconfigured response.
        Structure is documented below.
        """
        return pulumi.get(self, "respond_immediately")

    @respond_immediately.setter
    def respond_immediately(self, value: Optional[pulumi.Input['GuardrailActionRespondImmediatelyArgs']]):
        pulumi.set(self, "respond_immediately", value)

    @_builtins.property
    @pulumi.getter(name="transferAgent")
    def transfer_agent(self) -> Optional[pulumi.Input['GuardrailActionTransferAgentArgs']]:
        """
        The agent will transfer the conversation to a different agent.
        Structure is documented below.
        """
        return pulumi.get(self, "transfer_agent")

    @transfer_agent.setter
    def transfer_agent(self, value: Optional[pulumi.Input['GuardrailActionTransferAgentArgs']]):
        pulumi.set(self, "transfer_agent", value)


if not MYPY:
    class GuardrailActionGenerativeAnswerArgsDict(TypedDict):
        prompt: pulumi.Input[_builtins.str]
        """
        The prompt to use for the generative answer.
        """
elif False:
    GuardrailActionGenerativeAnswerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailActionGenerativeAnswerArgs:
    def __init__(__self__, *,
                 prompt: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] prompt: The prompt to use for the generative answer.
        """
        pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> pulumi.Input[_builtins.str]:
        """
        The prompt to use for the generative answer.
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prompt", value)


if not MYPY:
    class GuardrailActionRespondImmediatelyArgsDict(TypedDict):
        responses: pulumi.Input[Sequence[pulumi.Input['GuardrailActionRespondImmediatelyResponseArgsDict']]]
        """
        The canned responses for the agent to choose from. The response is chosen
        randomly.
        Structure is documented below.
        """
elif False:
    GuardrailActionRespondImmediatelyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailActionRespondImmediatelyArgs:
    def __init__(__self__, *,
                 responses: pulumi.Input[Sequence[pulumi.Input['GuardrailActionRespondImmediatelyResponseArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailActionRespondImmediatelyResponseArgs']]] responses: The canned responses for the agent to choose from. The response is chosen
               randomly.
               Structure is documented below.
        """
        pulumi.set(__self__, "responses", responses)

    @_builtins.property
    @pulumi.getter
    def responses(self) -> pulumi.Input[Sequence[pulumi.Input['GuardrailActionRespondImmediatelyResponseArgs']]]:
        """
        The canned responses for the agent to choose from. The response is chosen
        randomly.
        Structure is documented below.
        """
        return pulumi.get(self, "responses")

    @responses.setter
    def responses(self, value: pulumi.Input[Sequence[pulumi.Input['GuardrailActionRespondImmediatelyResponseArgs']]]):
        pulumi.set(self, "responses", value)


if not MYPY:
    class GuardrailActionRespondImmediatelyResponseArgsDict(TypedDict):
        text: pulumi.Input[_builtins.str]
        """
        Text for the agent to respond with.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the response is disabled. Disabled responses are not used by the
        agent.
        """
elif False:
    GuardrailActionRespondImmediatelyResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailActionRespondImmediatelyResponseArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[_builtins.str],
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] text: Text for the agent to respond with.
        :param pulumi.Input[_builtins.bool] disabled: Whether the response is disabled. Disabled responses are not used by the
               agent.
        """
        pulumi.set(__self__, "text", text)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        """
        Text for the agent to respond with.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the response is disabled. Disabled responses are not used by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class GuardrailActionTransferAgentArgsDict(TypedDict):
        agent: pulumi.Input[_builtins.str]
        """
        The name of the agent to transfer the conversation to. The agent must be
        in the same app as the current agent.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
elif False:
    GuardrailActionTransferAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailActionTransferAgentArgs:
    def __init__(__self__, *,
                 agent: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] agent: The name of the agent to transfer the conversation to. The agent must be
               in the same app as the current agent.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        pulumi.set(__self__, "agent", agent)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the agent to transfer the conversation to. The agent must be
        in the same app as the current agent.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agent", value)


if not MYPY:
    class GuardrailCodeCallbackArgsDict(TypedDict):
        after_agent_callback: NotRequired[pulumi.Input['GuardrailCodeCallbackAfterAgentCallbackArgsDict']]
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        after_model_callback: NotRequired[pulumi.Input['GuardrailCodeCallbackAfterModelCallbackArgsDict']]
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        before_agent_callback: NotRequired[pulumi.Input['GuardrailCodeCallbackBeforeAgentCallbackArgsDict']]
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        before_model_callback: NotRequired[pulumi.Input['GuardrailCodeCallbackBeforeModelCallbackArgsDict']]
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
elif False:
    GuardrailCodeCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailCodeCallbackArgs:
    def __init__(__self__, *,
                 after_agent_callback: Optional[pulumi.Input['GuardrailCodeCallbackAfterAgentCallbackArgs']] = None,
                 after_model_callback: Optional[pulumi.Input['GuardrailCodeCallbackAfterModelCallbackArgs']] = None,
                 before_agent_callback: Optional[pulumi.Input['GuardrailCodeCallbackBeforeAgentCallbackArgs']] = None,
                 before_model_callback: Optional[pulumi.Input['GuardrailCodeCallbackBeforeModelCallbackArgs']] = None):
        """
        :param pulumi.Input['GuardrailCodeCallbackAfterAgentCallbackArgs'] after_agent_callback: A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        :param pulumi.Input['GuardrailCodeCallbackAfterModelCallbackArgs'] after_model_callback: A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        :param pulumi.Input['GuardrailCodeCallbackBeforeAgentCallbackArgs'] before_agent_callback: A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        :param pulumi.Input['GuardrailCodeCallbackBeforeModelCallbackArgs'] before_model_callback: A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        """
        if after_agent_callback is not None:
            pulumi.set(__self__, "after_agent_callback", after_agent_callback)
        if after_model_callback is not None:
            pulumi.set(__self__, "after_model_callback", after_model_callback)
        if before_agent_callback is not None:
            pulumi.set(__self__, "before_agent_callback", before_agent_callback)
        if before_model_callback is not None:
            pulumi.set(__self__, "before_model_callback", before_model_callback)

    @_builtins.property
    @pulumi.getter(name="afterAgentCallback")
    def after_agent_callback(self) -> Optional[pulumi.Input['GuardrailCodeCallbackAfterAgentCallbackArgs']]:
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "after_agent_callback")

    @after_agent_callback.setter
    def after_agent_callback(self, value: Optional[pulumi.Input['GuardrailCodeCallbackAfterAgentCallbackArgs']]):
        pulumi.set(self, "after_agent_callback", value)

    @_builtins.property
    @pulumi.getter(name="afterModelCallback")
    def after_model_callback(self) -> Optional[pulumi.Input['GuardrailCodeCallbackAfterModelCallbackArgs']]:
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "after_model_callback")

    @after_model_callback.setter
    def after_model_callback(self, value: Optional[pulumi.Input['GuardrailCodeCallbackAfterModelCallbackArgs']]):
        pulumi.set(self, "after_model_callback", value)

    @_builtins.property
    @pulumi.getter(name="beforeAgentCallback")
    def before_agent_callback(self) -> Optional[pulumi.Input['GuardrailCodeCallbackBeforeAgentCallbackArgs']]:
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "before_agent_callback")

    @before_agent_callback.setter
    def before_agent_callback(self, value: Optional[pulumi.Input['GuardrailCodeCallbackBeforeAgentCallbackArgs']]):
        pulumi.set(self, "before_agent_callback", value)

    @_builtins.property
    @pulumi.getter(name="beforeModelCallback")
    def before_model_callback(self) -> Optional[pulumi.Input['GuardrailCodeCallbackBeforeModelCallbackArgs']]:
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "before_model_callback")

    @before_model_callback.setter
    def before_model_callback(self, value: Optional[pulumi.Input['GuardrailCodeCallbackBeforeModelCallbackArgs']]):
        pulumi.set(self, "before_model_callback", value)


if not MYPY:
    class GuardrailCodeCallbackAfterAgentCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    GuardrailCodeCallbackAfterAgentCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailCodeCallbackAfterAgentCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class GuardrailCodeCallbackAfterModelCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    GuardrailCodeCallbackAfterModelCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailCodeCallbackAfterModelCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class GuardrailCodeCallbackBeforeAgentCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    GuardrailCodeCallbackBeforeAgentCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailCodeCallbackBeforeAgentCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class GuardrailCodeCallbackBeforeModelCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    GuardrailCodeCallbackBeforeModelCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailCodeCallbackBeforeModelCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class GuardrailContentFilterArgsDict(TypedDict):
        match_type: pulumi.Input[_builtins.str]
        """
        Match type for the content filter.
        Possible values:
        SIMPLE_STRING_MATCH
        WORD_BOUNDARY_STRING_MATCH
        REGEXP_MATCH
        """
        banned_contents: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of banned phrases. Applies to both user inputs and agent responses.
        """
        banned_contents_in_agent_responses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of banned phrases. Applies only to agent responses.
        """
        banned_contents_in_user_inputs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of banned phrases. Applies only to user inputs.
        """
        disregard_diacritics: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, diacritics are ignored during matching.
        """
elif False:
    GuardrailContentFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContentFilterArgs:
    def __init__(__self__, *,
                 match_type: pulumi.Input[_builtins.str],
                 banned_contents: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 banned_contents_in_agent_responses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 banned_contents_in_user_inputs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 disregard_diacritics: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] match_type: Match type for the content filter.
               Possible values:
               SIMPLE_STRING_MATCH
               WORD_BOUNDARY_STRING_MATCH
               REGEXP_MATCH
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] banned_contents: List of banned phrases. Applies to both user inputs and agent responses.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] banned_contents_in_agent_responses: List of banned phrases. Applies only to agent responses.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] banned_contents_in_user_inputs: List of banned phrases. Applies only to user inputs.
        :param pulumi.Input[_builtins.bool] disregard_diacritics: If true, diacritics are ignored during matching.
        """
        pulumi.set(__self__, "match_type", match_type)
        if banned_contents is not None:
            pulumi.set(__self__, "banned_contents", banned_contents)
        if banned_contents_in_agent_responses is not None:
            pulumi.set(__self__, "banned_contents_in_agent_responses", banned_contents_in_agent_responses)
        if banned_contents_in_user_inputs is not None:
            pulumi.set(__self__, "banned_contents_in_user_inputs", banned_contents_in_user_inputs)
        if disregard_diacritics is not None:
            pulumi.set(__self__, "disregard_diacritics", disregard_diacritics)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[_builtins.str]:
        """
        Match type for the content filter.
        Possible values:
        SIMPLE_STRING_MATCH
        WORD_BOUNDARY_STRING_MATCH
        REGEXP_MATCH
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter(name="bannedContents")
    def banned_contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of banned phrases. Applies to both user inputs and agent responses.
        """
        return pulumi.get(self, "banned_contents")

    @banned_contents.setter
    def banned_contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "banned_contents", value)

    @_builtins.property
    @pulumi.getter(name="bannedContentsInAgentResponses")
    def banned_contents_in_agent_responses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of banned phrases. Applies only to agent responses.
        """
        return pulumi.get(self, "banned_contents_in_agent_responses")

    @banned_contents_in_agent_responses.setter
    def banned_contents_in_agent_responses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "banned_contents_in_agent_responses", value)

    @_builtins.property
    @pulumi.getter(name="bannedContentsInUserInputs")
    def banned_contents_in_user_inputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of banned phrases. Applies only to user inputs.
        """
        return pulumi.get(self, "banned_contents_in_user_inputs")

    @banned_contents_in_user_inputs.setter
    def banned_contents_in_user_inputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "banned_contents_in_user_inputs", value)

    @_builtins.property
    @pulumi.getter(name="disregardDiacritics")
    def disregard_diacritics(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, diacritics are ignored during matching.
        """
        return pulumi.get(self, "disregard_diacritics")

    @disregard_diacritics.setter
    def disregard_diacritics(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disregard_diacritics", value)


if not MYPY:
    class GuardrailLlmPolicyArgsDict(TypedDict):
        policy_scope: pulumi.Input[_builtins.str]
        """
        Defines when to apply the policy check during the conversation. If set to
        `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
        When applying the policy to the agent response, additional latency will
        be introduced before the agent can respond.
        Possible values:
        USER_QUERY
        AGENT_RESPONSE
        USER_QUERY_AND_AGENT_RESPONSE
        Possible values are: `USER_QUERY`, `AGENT_RESPONSE`, `USER_QUERY_AND_AGENT_RESPONSE`.
        """
        prompt: pulumi.Input[_builtins.str]
        """
        Policy prompt.
        """
        allow_short_utterance: NotRequired[pulumi.Input[_builtins.bool]]
        """
        By default, the LLM policy check is bypassed for short utterances.
        Enabling this setting applies the policy check to all utterances,
        including those that would normally be skipped.
        """
        fail_open: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If an error occurs during the policy check, fail open and do not trigger
        the guardrail.
        """
        max_conversation_messages: NotRequired[pulumi.Input[_builtins.int]]
        """
        When checking this policy, consider the last 'n' messages in the
        conversation.
        When not set a default value of 10 will be used.
        """
        model_settings: NotRequired[pulumi.Input['GuardrailLlmPolicyModelSettingsArgsDict']]
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
elif False:
    GuardrailLlmPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailLlmPolicyArgs:
    def __init__(__self__, *,
                 policy_scope: pulumi.Input[_builtins.str],
                 prompt: pulumi.Input[_builtins.str],
                 allow_short_utterance: Optional[pulumi.Input[_builtins.bool]] = None,
                 fail_open: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_conversation_messages: Optional[pulumi.Input[_builtins.int]] = None,
                 model_settings: Optional[pulumi.Input['GuardrailLlmPolicyModelSettingsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] policy_scope: Defines when to apply the policy check during the conversation. If set to
               `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
               When applying the policy to the agent response, additional latency will
               be introduced before the agent can respond.
               Possible values:
               USER_QUERY
               AGENT_RESPONSE
               USER_QUERY_AND_AGENT_RESPONSE
               Possible values are: `USER_QUERY`, `AGENT_RESPONSE`, `USER_QUERY_AND_AGENT_RESPONSE`.
        :param pulumi.Input[_builtins.str] prompt: Policy prompt.
        :param pulumi.Input[_builtins.bool] allow_short_utterance: By default, the LLM policy check is bypassed for short utterances.
               Enabling this setting applies the policy check to all utterances,
               including those that would normally be skipped.
        :param pulumi.Input[_builtins.bool] fail_open: If an error occurs during the policy check, fail open and do not trigger
               the guardrail.
        :param pulumi.Input[_builtins.int] max_conversation_messages: When checking this policy, consider the last 'n' messages in the
               conversation.
               When not set a default value of 10 will be used.
        :param pulumi.Input['GuardrailLlmPolicyModelSettingsArgs'] model_settings: Model settings contains various configurations for the LLM model.
               Structure is documented below.
        """
        pulumi.set(__self__, "policy_scope", policy_scope)
        pulumi.set(__self__, "prompt", prompt)
        if allow_short_utterance is not None:
            pulumi.set(__self__, "allow_short_utterance", allow_short_utterance)
        if fail_open is not None:
            pulumi.set(__self__, "fail_open", fail_open)
        if max_conversation_messages is not None:
            pulumi.set(__self__, "max_conversation_messages", max_conversation_messages)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)

    @_builtins.property
    @pulumi.getter(name="policyScope")
    def policy_scope(self) -> pulumi.Input[_builtins.str]:
        """
        Defines when to apply the policy check during the conversation. If set to
        `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
        When applying the policy to the agent response, additional latency will
        be introduced before the agent can respond.
        Possible values:
        USER_QUERY
        AGENT_RESPONSE
        USER_QUERY_AND_AGENT_RESPONSE
        Possible values are: `USER_QUERY`, `AGENT_RESPONSE`, `USER_QUERY_AND_AGENT_RESPONSE`.
        """
        return pulumi.get(self, "policy_scope")

    @policy_scope.setter
    def policy_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "policy_scope", value)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> pulumi.Input[_builtins.str]:
        """
        Policy prompt.
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prompt", value)

    @_builtins.property
    @pulumi.getter(name="allowShortUtterance")
    def allow_short_utterance(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        By default, the LLM policy check is bypassed for short utterances.
        Enabling this setting applies the policy check to all utterances,
        including those that would normally be skipped.
        """
        return pulumi.get(self, "allow_short_utterance")

    @allow_short_utterance.setter
    def allow_short_utterance(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_short_utterance", value)

    @_builtins.property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If an error occurs during the policy check, fail open and do not trigger
        the guardrail.
        """
        return pulumi.get(self, "fail_open")

    @fail_open.setter
    def fail_open(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "fail_open", value)

    @_builtins.property
    @pulumi.getter(name="maxConversationMessages")
    def max_conversation_messages(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        When checking this policy, consider the last 'n' messages in the
        conversation.
        When not set a default value of 10 will be used.
        """
        return pulumi.get(self, "max_conversation_messages")

    @max_conversation_messages.setter
    def max_conversation_messages(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_conversation_messages", value)

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional[pulumi.Input['GuardrailLlmPolicyModelSettingsArgs']]:
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @model_settings.setter
    def model_settings(self, value: Optional[pulumi.Input['GuardrailLlmPolicyModelSettingsArgs']]):
        pulumi.set(self, "model_settings", value)


if not MYPY:
    class GuardrailLlmPolicyModelSettingsArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
elif False:
    GuardrailLlmPolicyModelSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailLlmPolicyModelSettingsArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] model: The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param pulumi.Input[_builtins.float] temperature: If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)


if not MYPY:
    class GuardrailLlmPromptSecurityArgsDict(TypedDict):
        custom_policy: NotRequired[pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyArgsDict']]
        """
        Guardrail that blocks the conversation if the LLM response is considered
        violating the policy based on the LLM classification.
        Structure is documented below.
        """
        default_settings: NotRequired[pulumi.Input['GuardrailLlmPromptSecurityDefaultSettingsArgsDict']]
        """
        Configuration for default system security settings.
        Structure is documented below.
        """
elif False:
    GuardrailLlmPromptSecurityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailLlmPromptSecurityArgs:
    def __init__(__self__, *,
                 custom_policy: Optional[pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyArgs']] = None,
                 default_settings: Optional[pulumi.Input['GuardrailLlmPromptSecurityDefaultSettingsArgs']] = None):
        """
        :param pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyArgs'] custom_policy: Guardrail that blocks the conversation if the LLM response is considered
               violating the policy based on the LLM classification.
               Structure is documented below.
        :param pulumi.Input['GuardrailLlmPromptSecurityDefaultSettingsArgs'] default_settings: Configuration for default system security settings.
               Structure is documented below.
        """
        if custom_policy is not None:
            pulumi.set(__self__, "custom_policy", custom_policy)
        if default_settings is not None:
            pulumi.set(__self__, "default_settings", default_settings)

    @_builtins.property
    @pulumi.getter(name="customPolicy")
    def custom_policy(self) -> Optional[pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyArgs']]:
        """
        Guardrail that blocks the conversation if the LLM response is considered
        violating the policy based on the LLM classification.
        Structure is documented below.
        """
        return pulumi.get(self, "custom_policy")

    @custom_policy.setter
    def custom_policy(self, value: Optional[pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyArgs']]):
        pulumi.set(self, "custom_policy", value)

    @_builtins.property
    @pulumi.getter(name="defaultSettings")
    def default_settings(self) -> Optional[pulumi.Input['GuardrailLlmPromptSecurityDefaultSettingsArgs']]:
        """
        Configuration for default system security settings.
        Structure is documented below.
        """
        return pulumi.get(self, "default_settings")

    @default_settings.setter
    def default_settings(self, value: Optional[pulumi.Input['GuardrailLlmPromptSecurityDefaultSettingsArgs']]):
        pulumi.set(self, "default_settings", value)


if not MYPY:
    class GuardrailLlmPromptSecurityCustomPolicyArgsDict(TypedDict):
        policy_scope: pulumi.Input[_builtins.str]
        """
        Defines when to apply the policy check during the conversation. If set to
        `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
        When applying the policy to the agent response, additional latency will
        be introduced before the agent can respond.
        Possible values:
        USER_QUERY
        AGENT_RESPONSE
        USER_QUERY_AND_AGENT_RESPONSE
        """
        prompt: pulumi.Input[_builtins.str]
        """
        Policy prompt.
        """
        allow_short_utterance: NotRequired[pulumi.Input[_builtins.bool]]
        """
        By default, the LLM policy check is bypassed for short utterances.
        Enabling this setting applies the policy check to all utterances,
        including those that would normally be skipped.
        """
        fail_open: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If an error occurs during the policy check, fail open and do not trigger
        the guardrail.
        """
        max_conversation_messages: NotRequired[pulumi.Input[_builtins.int]]
        """
        When checking this policy, consider the last 'n' messages in the
        conversation.
        When not set a default value of 10 will be used.
        """
        model_settings: NotRequired[pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgsDict']]
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
elif False:
    GuardrailLlmPromptSecurityCustomPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailLlmPromptSecurityCustomPolicyArgs:
    def __init__(__self__, *,
                 policy_scope: pulumi.Input[_builtins.str],
                 prompt: pulumi.Input[_builtins.str],
                 allow_short_utterance: Optional[pulumi.Input[_builtins.bool]] = None,
                 fail_open: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_conversation_messages: Optional[pulumi.Input[_builtins.int]] = None,
                 model_settings: Optional[pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] policy_scope: Defines when to apply the policy check during the conversation. If set to
               `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
               When applying the policy to the agent response, additional latency will
               be introduced before the agent can respond.
               Possible values:
               USER_QUERY
               AGENT_RESPONSE
               USER_QUERY_AND_AGENT_RESPONSE
        :param pulumi.Input[_builtins.str] prompt: Policy prompt.
        :param pulumi.Input[_builtins.bool] allow_short_utterance: By default, the LLM policy check is bypassed for short utterances.
               Enabling this setting applies the policy check to all utterances,
               including those that would normally be skipped.
        :param pulumi.Input[_builtins.bool] fail_open: If an error occurs during the policy check, fail open and do not trigger
               the guardrail.
        :param pulumi.Input[_builtins.int] max_conversation_messages: When checking this policy, consider the last 'n' messages in the
               conversation.
               When not set a default value of 10 will be used.
        :param pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgs'] model_settings: Model settings contains various configurations for the LLM model.
               Structure is documented below.
        """
        pulumi.set(__self__, "policy_scope", policy_scope)
        pulumi.set(__self__, "prompt", prompt)
        if allow_short_utterance is not None:
            pulumi.set(__self__, "allow_short_utterance", allow_short_utterance)
        if fail_open is not None:
            pulumi.set(__self__, "fail_open", fail_open)
        if max_conversation_messages is not None:
            pulumi.set(__self__, "max_conversation_messages", max_conversation_messages)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)

    @_builtins.property
    @pulumi.getter(name="policyScope")
    def policy_scope(self) -> pulumi.Input[_builtins.str]:
        """
        Defines when to apply the policy check during the conversation. If set to
        `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
        When applying the policy to the agent response, additional latency will
        be introduced before the agent can respond.
        Possible values:
        USER_QUERY
        AGENT_RESPONSE
        USER_QUERY_AND_AGENT_RESPONSE
        """
        return pulumi.get(self, "policy_scope")

    @policy_scope.setter
    def policy_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "policy_scope", value)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> pulumi.Input[_builtins.str]:
        """
        Policy prompt.
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prompt", value)

    @_builtins.property
    @pulumi.getter(name="allowShortUtterance")
    def allow_short_utterance(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        By default, the LLM policy check is bypassed for short utterances.
        Enabling this setting applies the policy check to all utterances,
        including those that would normally be skipped.
        """
        return pulumi.get(self, "allow_short_utterance")

    @allow_short_utterance.setter
    def allow_short_utterance(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_short_utterance", value)

    @_builtins.property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If an error occurs during the policy check, fail open and do not trigger
        the guardrail.
        """
        return pulumi.get(self, "fail_open")

    @fail_open.setter
    def fail_open(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "fail_open", value)

    @_builtins.property
    @pulumi.getter(name="maxConversationMessages")
    def max_conversation_messages(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        When checking this policy, consider the last 'n' messages in the
        conversation.
        When not set a default value of 10 will be used.
        """
        return pulumi.get(self, "max_conversation_messages")

    @max_conversation_messages.setter
    def max_conversation_messages(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_conversation_messages", value)

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional[pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgs']]:
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @model_settings.setter
    def model_settings(self, value: Optional[pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgs']]):
        pulumi.set(self, "model_settings", value)


if not MYPY:
    class GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
elif False:
    GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] model: The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param pulumi.Input[_builtins.float] temperature: If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)


if not MYPY:
    class GuardrailLlmPromptSecurityDefaultSettingsArgsDict(TypedDict):
        default_prompt_template: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The default prompt template used by the system.
        This field is for display purposes to show the user what prompt
        the system uses by default. It is OUTPUT_ONLY.
        """
elif False:
    GuardrailLlmPromptSecurityDefaultSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailLlmPromptSecurityDefaultSettingsArgs:
    def __init__(__self__, *,
                 default_prompt_template: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] default_prompt_template: (Output)
               The default prompt template used by the system.
               This field is for display purposes to show the user what prompt
               the system uses by default. It is OUTPUT_ONLY.
        """
        if default_prompt_template is not None:
            pulumi.set(__self__, "default_prompt_template", default_prompt_template)

    @_builtins.property
    @pulumi.getter(name="defaultPromptTemplate")
    def default_prompt_template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The default prompt template used by the system.
        This field is for display purposes to show the user what prompt
        the system uses by default. It is OUTPUT_ONLY.
        """
        return pulumi.get(self, "default_prompt_template")

    @default_prompt_template.setter
    def default_prompt_template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_prompt_template", value)


if not MYPY:
    class GuardrailModelSafetyArgsDict(TypedDict):
        safety_settings: pulumi.Input[Sequence[pulumi.Input['GuardrailModelSafetySafetySettingArgsDict']]]
        """
        List of safety settings.
        Structure is documented below.
        """
elif False:
    GuardrailModelSafetyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailModelSafetyArgs:
    def __init__(__self__, *,
                 safety_settings: pulumi.Input[Sequence[pulumi.Input['GuardrailModelSafetySafetySettingArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailModelSafetySafetySettingArgs']]] safety_settings: List of safety settings.
               Structure is documented below.
        """
        pulumi.set(__self__, "safety_settings", safety_settings)

    @_builtins.property
    @pulumi.getter(name="safetySettings")
    def safety_settings(self) -> pulumi.Input[Sequence[pulumi.Input['GuardrailModelSafetySafetySettingArgs']]]:
        """
        List of safety settings.
        Structure is documented below.
        """
        return pulumi.get(self, "safety_settings")

    @safety_settings.setter
    def safety_settings(self, value: pulumi.Input[Sequence[pulumi.Input['GuardrailModelSafetySafetySettingArgs']]]):
        pulumi.set(self, "safety_settings", value)


if not MYPY:
    class GuardrailModelSafetySafetySettingArgsDict(TypedDict):
        category: pulumi.Input[_builtins.str]
        """
        The harm category.
        Possible values:
        HARM_CATEGORY_HATE_SPEECH
        HARM_CATEGORY_DANGEROUS_CONTENT
        HARM_CATEGORY_HARASSMENT
        HARM_CATEGORY_SEXUALLY_EXPLICIT
        Possible values are: `HARM_CATEGORY_HATE_SPEECH`, `HARM_CATEGORY_DANGEROUS_CONTENT`, `HARM_CATEGORY_HARASSMENT`, `HARM_CATEGORY_SEXUALLY_EXPLICIT`.
        """
        threshold: pulumi.Input[_builtins.str]
        """
        The harm block threshold.
        Possible values:
        BLOCK_LOW_AND_ABOVE
        BLOCK_MEDIUM_AND_ABOVE
        BLOCK_ONLY_HIGH
        BLOCK_NONE
        OFF
        Possible values are: `BLOCK_LOW_AND_ABOVE`, `BLOCK_MEDIUM_AND_ABOVE`, `BLOCK_ONLY_HIGH`, `BLOCK_NONE`, `OFF`.
        """
elif False:
    GuardrailModelSafetySafetySettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailModelSafetySafetySettingArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[_builtins.str],
                 threshold: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] category: The harm category.
               Possible values:
               HARM_CATEGORY_HATE_SPEECH
               HARM_CATEGORY_DANGEROUS_CONTENT
               HARM_CATEGORY_HARASSMENT
               HARM_CATEGORY_SEXUALLY_EXPLICIT
               Possible values are: `HARM_CATEGORY_HATE_SPEECH`, `HARM_CATEGORY_DANGEROUS_CONTENT`, `HARM_CATEGORY_HARASSMENT`, `HARM_CATEGORY_SEXUALLY_EXPLICIT`.
        :param pulumi.Input[_builtins.str] threshold: The harm block threshold.
               Possible values:
               BLOCK_LOW_AND_ABOVE
               BLOCK_MEDIUM_AND_ABOVE
               BLOCK_ONLY_HIGH
               BLOCK_NONE
               OFF
               Possible values are: `BLOCK_LOW_AND_ABOVE`, `BLOCK_MEDIUM_AND_ABOVE`, `BLOCK_ONLY_HIGH`, `BLOCK_NONE`, `OFF`.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def category(self) -> pulumi.Input[_builtins.str]:
        """
        The harm category.
        Possible values:
        HARM_CATEGORY_HATE_SPEECH
        HARM_CATEGORY_DANGEROUS_CONTENT
        HARM_CATEGORY_HARASSMENT
        HARM_CATEGORY_SEXUALLY_EXPLICIT
        Possible values are: `HARM_CATEGORY_HATE_SPEECH`, `HARM_CATEGORY_DANGEROUS_CONTENT`, `HARM_CATEGORY_HARASSMENT`, `HARM_CATEGORY_SEXUALLY_EXPLICIT`.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[_builtins.str]:
        """
        The harm block threshold.
        Possible values:
        BLOCK_LOW_AND_ABOVE
        BLOCK_MEDIUM_AND_ABOVE
        BLOCK_ONLY_HIGH
        BLOCK_NONE
        OFF
        Possible values are: `BLOCK_LOW_AND_ABOVE`, `BLOCK_MEDIUM_AND_ABOVE`, `BLOCK_ONLY_HIGH`, `BLOCK_NONE`, `OFF`.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class ToolClientFunctionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The function name.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The function description.
        """
        parameters: NotRequired[pulumi.Input['ToolClientFunctionParametersArgsDict']]
        """
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        response: NotRequired[pulumi.Input['ToolClientFunctionResponseArgsDict']]
        """
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
elif False:
    ToolClientFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolClientFunctionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 parameters: Optional[pulumi.Input['ToolClientFunctionParametersArgs']] = None,
                 response: Optional[pulumi.Input['ToolClientFunctionResponseArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: The function name.
        :param pulumi.Input[_builtins.str] description: The function description.
        :param pulumi.Input['ToolClientFunctionParametersArgs'] parameters: Represents a select subset of an OpenAPI 3.0 schema object.
               Structure is documented below.
        :param pulumi.Input['ToolClientFunctionResponseArgs'] response: Represents a select subset of an OpenAPI 3.0 schema object.
               Structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The function name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The function description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input['ToolClientFunctionParametersArgs']]:
        """
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input['ToolClientFunctionParametersArgs']]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['ToolClientFunctionResponseArgs']]:
        """
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['ToolClientFunctionResponseArgs']]):
        pulumi.set(self, "response", value)


if not MYPY:
    class ToolClientFunctionParametersArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of the data.
        Possible values:
        STRING
        INTEGER
        NUMBER
        BOOLEAN
        OBJECT
        ARRAY
        """
        additional_properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        any_of: NotRequired[pulumi.Input[_builtins.str]]
        """
        The instance value should be valid against at least one of the schemas in this list.
        """
        default: NotRequired[pulumi.Input[_builtins.str]]
        """
        Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        defs: NotRequired[pulumi.Input[_builtins.str]]
        """
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the data.
        """
        enums: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        items: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema of the elements of Type.ARRAY.
        """
        max_items: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of the elements for Type.ARRAY. (int64 format)
        """
        maximum: NotRequired[pulumi.Input[_builtins.float]]
        """
        Maximum value for Type.INTEGER and Type.NUMBER.
        """
        min_items: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum number of the elements for Type.ARRAY. (int64 format)
        """
        minimum: NotRequired[pulumi.Input[_builtins.float]]
        """
        Minimum value for Type.INTEGER and Type.NUMBER.
        """
        nullable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the value may be null.
        """
        prefix_items: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schemas of initial elements of Type.ARRAY.
        """
        properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        Properties of Type.OBJECT.
        """
        ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        requireds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Required properties of Type.OBJECT.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The title of the schema.
        """
        unique_items: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
elif False:
    ToolClientFunctionParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolClientFunctionParametersArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 additional_properties: Optional[pulumi.Input[_builtins.str]] = None,
                 any_of: Optional[pulumi.Input[_builtins.str]] = None,
                 default: Optional[pulumi.Input[_builtins.str]] = None,
                 defs: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enums: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 items: Optional[pulumi.Input[_builtins.str]] = None,
                 max_items: Optional[pulumi.Input[_builtins.int]] = None,
                 maximum: Optional[pulumi.Input[_builtins.float]] = None,
                 min_items: Optional[pulumi.Input[_builtins.int]] = None,
                 minimum: Optional[pulumi.Input[_builtins.float]] = None,
                 nullable: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix_items: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[_builtins.str]] = None,
                 ref: Optional[pulumi.Input[_builtins.str]] = None,
                 requireds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None,
                 unique_items: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of the data.
               Possible values:
               STRING
               INTEGER
               NUMBER
               BOOLEAN
               OBJECT
               ARRAY
        :param pulumi.Input[_builtins.str] additional_properties: Defines the schema for additional properties allowed in an object.
               The value must be a valid JSON string representing the Schema object.
               (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        :param pulumi.Input[_builtins.str] any_of: The instance value should be valid against at least one of the schemas in this list.
        :param pulumi.Input[_builtins.str] default: Default value of the data. Represents a dynamically typed value
               which can be either null, a number, a string, a boolean, a struct,
               or a list of values. The provided default value must be compatible
               with the defined 'type' and other schema constraints.
        :param pulumi.Input[_builtins.str] defs: A map of definitions for use by ref. Only allowed at the root of the schema.
        :param pulumi.Input[_builtins.str] description: The description of the data.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enums: Possible values of the element of primitive type with enum format.
               Examples:
               1. We can define direction as :
               {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
               2. We can define apartment number as :
               {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        :param pulumi.Input[_builtins.str] items: Schema of the elements of Type.ARRAY.
        :param pulumi.Input[_builtins.int] max_items: Maximum number of the elements for Type.ARRAY. (int64 format)
        :param pulumi.Input[_builtins.float] maximum: Maximum value for Type.INTEGER and Type.NUMBER.
        :param pulumi.Input[_builtins.int] min_items: Minimum number of the elements for Type.ARRAY. (int64 format)
        :param pulumi.Input[_builtins.float] minimum: Minimum value for Type.INTEGER and Type.NUMBER.
        :param pulumi.Input[_builtins.bool] nullable: Indicates if the value may be null.
        :param pulumi.Input[_builtins.str] prefix_items: Schemas of initial elements of Type.ARRAY.
        :param pulumi.Input[_builtins.str] properties: Properties of Type.OBJECT.
        :param pulumi.Input[_builtins.str] ref: Allows indirect references between schema nodes. The value should be a
               valid reference to a child of the root `defs`.
               For example, the following schema defines a reference to a schema node
               named "Pet":
               type: object
               properties:
               pet:
               ref: #/defs/Pet
               defs:
               Pet:
               type: object
               properties:
               name:
               type: string
               The value of the "pet" property is a reference to the schema node
               named "Pet".
               See details in
               https://json-schema.org/understanding-json-schema/structuring.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] requireds: Required properties of Type.OBJECT.
        :param pulumi.Input[_builtins.str] title: The title of the schema.
        :param pulumi.Input[_builtins.bool] unique_items: Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        pulumi.set(__self__, "type", type)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if any_of is not None:
            pulumi.set(__self__, "any_of", any_of)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if defs is not None:
            pulumi.set(__self__, "defs", defs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enums is not None:
            pulumi.set(__self__, "enums", enums)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if max_items is not None:
            pulumi.set(__self__, "max_items", max_items)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_items is not None:
            pulumi.set(__self__, "min_items", min_items)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if prefix_items is not None:
            pulumi.set(__self__, "prefix_items", prefix_items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if requireds is not None:
            pulumi.set(__self__, "requireds", requireds)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the data.
        Possible values:
        STRING
        INTEGER
        NUMBER
        BOOLEAN
        OBJECT
        ARRAY
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_properties", value)

    @_builtins.property
    @pulumi.getter(name="anyOf")
    def any_of(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The instance value should be valid against at least one of the schemas in this list.
        """
        return pulumi.get(self, "any_of")

    @any_of.setter
    def any_of(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "any_of", value)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def defs(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        return pulumi.get(self, "defs")

    @defs.setter
    def defs(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "defs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the data.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def enums(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        return pulumi.get(self, "enums")

    @enums.setter
    def enums(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enums", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema of the elements of Type.ARRAY.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter(name="maxItems")
    def max_items(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of the elements for Type.ARRAY. (int64 format)
        """
        return pulumi.get(self, "max_items")

    @max_items.setter
    def max_items(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_items", value)

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Maximum value for Type.INTEGER and Type.NUMBER.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "maximum", value)

    @_builtins.property
    @pulumi.getter(name="minItems")
    def min_items(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum number of the elements for Type.ARRAY. (int64 format)
        """
        return pulumi.get(self, "min_items")

    @min_items.setter
    def min_items(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_items", value)

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Minimum value for Type.INTEGER and Type.NUMBER.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "minimum", value)

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the value may be null.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "nullable", value)

    @_builtins.property
    @pulumi.getter(name="prefixItems")
    def prefix_items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schemas of initial elements of Type.ARRAY.
        """
        return pulumi.get(self, "prefix_items")

    @prefix_items.setter
    def prefix_items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_items", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Properties of Type.OBJECT.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ref", value)

    @_builtins.property
    @pulumi.getter
    def requireds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Required properties of Type.OBJECT.
        """
        return pulumi.get(self, "requireds")

    @requireds.setter
    def requireds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "requireds", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The title of the schema.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        return pulumi.get(self, "unique_items")

    @unique_items.setter
    def unique_items(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unique_items", value)


if not MYPY:
    class ToolClientFunctionResponseArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of the data.
        Possible values:
        STRING
        INTEGER
        NUMBER
        BOOLEAN
        OBJECT
        ARRAY
        """
        additional_properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        any_of: NotRequired[pulumi.Input[_builtins.str]]
        """
        The instance value should be valid against at least one of the schemas in this list.
        """
        default: NotRequired[pulumi.Input[_builtins.str]]
        """
        Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        defs: NotRequired[pulumi.Input[_builtins.str]]
        """
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the data.
        """
        enums: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        items: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema of the elements of Type.ARRAY.
        """
        max_items: NotRequired[pulumi.Input[_builtins.int]]
        """
        Maximum number of the elements for Type.ARRAY. (int64 format)
        """
        maximum: NotRequired[pulumi.Input[_builtins.float]]
        """
        Maximum value for Type.INTEGER and Type.NUMBER.
        """
        min_items: NotRequired[pulumi.Input[_builtins.int]]
        """
        Minimum number of the elements for Type.ARRAY. (int64 format)
        """
        minimum: NotRequired[pulumi.Input[_builtins.float]]
        """
        Minimum value for Type.INTEGER and Type.NUMBER.
        """
        nullable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the value may be null.
        """
        prefix_items: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schemas of initial elements of Type.ARRAY.
        """
        properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        Properties of Type.OBJECT.
        """
        ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        requireds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Required properties of Type.OBJECT.
        """
        title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The title of the schema.
        """
        unique_items: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
elif False:
    ToolClientFunctionResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolClientFunctionResponseArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 additional_properties: Optional[pulumi.Input[_builtins.str]] = None,
                 any_of: Optional[pulumi.Input[_builtins.str]] = None,
                 default: Optional[pulumi.Input[_builtins.str]] = None,
                 defs: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enums: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 items: Optional[pulumi.Input[_builtins.str]] = None,
                 max_items: Optional[pulumi.Input[_builtins.int]] = None,
                 maximum: Optional[pulumi.Input[_builtins.float]] = None,
                 min_items: Optional[pulumi.Input[_builtins.int]] = None,
                 minimum: Optional[pulumi.Input[_builtins.float]] = None,
                 nullable: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix_items: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[_builtins.str]] = None,
                 ref: Optional[pulumi.Input[_builtins.str]] = None,
                 requireds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 title: Optional[pulumi.Input[_builtins.str]] = None,
                 unique_items: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of the data.
               Possible values:
               STRING
               INTEGER
               NUMBER
               BOOLEAN
               OBJECT
               ARRAY
        :param pulumi.Input[_builtins.str] additional_properties: Defines the schema for additional properties allowed in an object.
               The value must be a valid JSON string representing the Schema object.
               (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        :param pulumi.Input[_builtins.str] any_of: The instance value should be valid against at least one of the schemas in this list.
        :param pulumi.Input[_builtins.str] default: Default value of the data. Represents a dynamically typed value
               which can be either null, a number, a string, a boolean, a struct,
               or a list of values. The provided default value must be compatible
               with the defined 'type' and other schema constraints.
        :param pulumi.Input[_builtins.str] defs: A map of definitions for use by ref. Only allowed at the root of the schema.
        :param pulumi.Input[_builtins.str] description: The description of the data.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enums: Possible values of the element of primitive type with enum format.
               Examples:
               1. We can define direction as :
               {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
               2. We can define apartment number as :
               {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        :param pulumi.Input[_builtins.str] items: Schema of the elements of Type.ARRAY.
        :param pulumi.Input[_builtins.int] max_items: Maximum number of the elements for Type.ARRAY. (int64 format)
        :param pulumi.Input[_builtins.float] maximum: Maximum value for Type.INTEGER and Type.NUMBER.
        :param pulumi.Input[_builtins.int] min_items: Minimum number of the elements for Type.ARRAY. (int64 format)
        :param pulumi.Input[_builtins.float] minimum: Minimum value for Type.INTEGER and Type.NUMBER.
        :param pulumi.Input[_builtins.bool] nullable: Indicates if the value may be null.
        :param pulumi.Input[_builtins.str] prefix_items: Schemas of initial elements of Type.ARRAY.
        :param pulumi.Input[_builtins.str] properties: Properties of Type.OBJECT.
        :param pulumi.Input[_builtins.str] ref: Allows indirect references between schema nodes. The value should be a
               valid reference to a child of the root `defs`.
               For example, the following schema defines a reference to a schema node
               named "Pet":
               type: object
               properties:
               pet:
               ref: #/defs/Pet
               defs:
               Pet:
               type: object
               properties:
               name:
               type: string
               The value of the "pet" property is a reference to the schema node
               named "Pet".
               See details in
               https://json-schema.org/understanding-json-schema/structuring.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] requireds: Required properties of Type.OBJECT.
        :param pulumi.Input[_builtins.str] title: The title of the schema.
        :param pulumi.Input[_builtins.bool] unique_items: Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        pulumi.set(__self__, "type", type)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if any_of is not None:
            pulumi.set(__self__, "any_of", any_of)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if defs is not None:
            pulumi.set(__self__, "defs", defs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enums is not None:
            pulumi.set(__self__, "enums", enums)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if max_items is not None:
            pulumi.set(__self__, "max_items", max_items)
        if maximum is not None:
            pulumi.set(__self__, "maximum", maximum)
        if min_items is not None:
            pulumi.set(__self__, "min_items", min_items)
        if minimum is not None:
            pulumi.set(__self__, "minimum", minimum)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if prefix_items is not None:
            pulumi.set(__self__, "prefix_items", prefix_items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if requireds is not None:
            pulumi.set(__self__, "requireds", requireds)
        if title is not None:
            pulumi.set(__self__, "title", title)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the data.
        Possible values:
        STRING
        INTEGER
        NUMBER
        BOOLEAN
        OBJECT
        ARRAY
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_properties", value)

    @_builtins.property
    @pulumi.getter(name="anyOf")
    def any_of(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The instance value should be valid against at least one of the schemas in this list.
        """
        return pulumi.get(self, "any_of")

    @any_of.setter
    def any_of(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "any_of", value)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def defs(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        return pulumi.get(self, "defs")

    @defs.setter
    def defs(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "defs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the data.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def enums(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        return pulumi.get(self, "enums")

    @enums.setter
    def enums(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enums", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema of the elements of Type.ARRAY.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter(name="maxItems")
    def max_items(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Maximum number of the elements for Type.ARRAY. (int64 format)
        """
        return pulumi.get(self, "max_items")

    @max_items.setter
    def max_items(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_items", value)

    @_builtins.property
    @pulumi.getter
    def maximum(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Maximum value for Type.INTEGER and Type.NUMBER.
        """
        return pulumi.get(self, "maximum")

    @maximum.setter
    def maximum(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "maximum", value)

    @_builtins.property
    @pulumi.getter(name="minItems")
    def min_items(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Minimum number of the elements for Type.ARRAY. (int64 format)
        """
        return pulumi.get(self, "min_items")

    @min_items.setter
    def min_items(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "min_items", value)

    @_builtins.property
    @pulumi.getter
    def minimum(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Minimum value for Type.INTEGER and Type.NUMBER.
        """
        return pulumi.get(self, "minimum")

    @minimum.setter
    def minimum(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "minimum", value)

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the value may be null.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "nullable", value)

    @_builtins.property
    @pulumi.getter(name="prefixItems")
    def prefix_items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schemas of initial elements of Type.ARRAY.
        """
        return pulumi.get(self, "prefix_items")

    @prefix_items.setter
    def prefix_items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_items", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Properties of Type.OBJECT.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ref", value)

    @_builtins.property
    @pulumi.getter
    def requireds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Required properties of Type.OBJECT.
        """
        return pulumi.get(self, "requireds")

    @requireds.setter
    def requireds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "requireds", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The title of the schema.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        return pulumi.get(self, "unique_items")

    @unique_items.setter
    def unique_items(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unique_items", value)


if not MYPY:
    class ToolDataStoreToolArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The data store tool name.
        """
        boost_specs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecArgsDict']]]]
        """
        Boost specification to boost certain documents.
        Structure is documented below.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tool description.
        """
        engine_source: NotRequired[pulumi.Input['ToolDataStoreToolEngineSourceArgsDict']]
        """
        Configuration for searching within an Engine, potentially targeting
        specific DataStores.
        Structure is documented below.
        """
        max_results: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of search results to return per query.
        The default value is 10. The maximum allowed value is 10.
        """
        modality_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolModalityConfigArgsDict']]]]
        """
        The modality configs for the data store.
        Structure is documented below.
        """
elif False:
    ToolDataStoreToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 boost_specs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 engine_source: Optional[pulumi.Input['ToolDataStoreToolEngineSourceArgs']] = None,
                 max_results: Optional[pulumi.Input[_builtins.int]] = None,
                 modality_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolModalityConfigArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The data store tool name.
        :param pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecArgs']]] boost_specs: Boost specification to boost certain documents.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] description: The tool description.
        :param pulumi.Input['ToolDataStoreToolEngineSourceArgs'] engine_source: Configuration for searching within an Engine, potentially targeting
               specific DataStores.
               Structure is documented below.
        :param pulumi.Input[_builtins.int] max_results: Number of search results to return per query.
               The default value is 10. The maximum allowed value is 10.
        :param pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolModalityConfigArgs']]] modality_configs: The modality configs for the data store.
               Structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        if boost_specs is not None:
            pulumi.set(__self__, "boost_specs", boost_specs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if engine_source is not None:
            pulumi.set(__self__, "engine_source", engine_source)
        if max_results is not None:
            pulumi.set(__self__, "max_results", max_results)
        if modality_configs is not None:
            pulumi.set(__self__, "modality_configs", modality_configs)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The data store tool name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="boostSpecs")
    def boost_specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecArgs']]]]:
        """
        Boost specification to boost certain documents.
        Structure is documented below.
        """
        return pulumi.get(self, "boost_specs")

    @boost_specs.setter
    def boost_specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecArgs']]]]):
        pulumi.set(self, "boost_specs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tool description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="engineSource")
    def engine_source(self) -> Optional[pulumi.Input['ToolDataStoreToolEngineSourceArgs']]:
        """
        Configuration for searching within an Engine, potentially targeting
        specific DataStores.
        Structure is documented below.
        """
        return pulumi.get(self, "engine_source")

    @engine_source.setter
    def engine_source(self, value: Optional[pulumi.Input['ToolDataStoreToolEngineSourceArgs']]):
        pulumi.set(self, "engine_source", value)

    @_builtins.property
    @pulumi.getter(name="maxResults")
    def max_results(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of search results to return per query.
        The default value is 10. The maximum allowed value is 10.
        """
        return pulumi.get(self, "max_results")

    @max_results.setter
    def max_results(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_results", value)

    @_builtins.property
    @pulumi.getter(name="modalityConfigs")
    def modality_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolModalityConfigArgs']]]]:
        """
        The modality configs for the data store.
        Structure is documented below.
        """
        return pulumi.get(self, "modality_configs")

    @modality_configs.setter
    def modality_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolModalityConfigArgs']]]]):
        pulumi.set(self, "modality_configs", value)


if not MYPY:
    class ToolDataStoreToolBoostSpecArgsDict(TypedDict):
        data_stores: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The Data Store where the boosting configuration is applied. Full resource
        name of DataStore, such as
        projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}.
        """
        specs: pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecArgsDict']]]
        """
        A list of boosting specifications.
        Structure is documented below.
        """
elif False:
    ToolDataStoreToolBoostSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolBoostSpecArgs:
    def __init__(__self__, *,
                 data_stores: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 specs: pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] data_stores: The Data Store where the boosting configuration is applied. Full resource
               name of DataStore, such as
               projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}.
        :param pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecArgs']]] specs: A list of boosting specifications.
               Structure is documented below.
        """
        pulumi.set(__self__, "data_stores", data_stores)
        pulumi.set(__self__, "specs", specs)

    @_builtins.property
    @pulumi.getter(name="dataStores")
    def data_stores(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The Data Store where the boosting configuration is applied. Full resource
        name of DataStore, such as
        projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}.
        """
        return pulumi.get(self, "data_stores")

    @data_stores.setter
    def data_stores(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "data_stores", value)

    @_builtins.property
    @pulumi.getter
    def specs(self) -> pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecArgs']]]:
        """
        A list of boosting specifications.
        Structure is documented below.
        """
        return pulumi.get(self, "specs")

    @specs.setter
    def specs(self, value: pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecArgs']]]):
        pulumi.set(self, "specs", value)


if not MYPY:
    class ToolDataStoreToolBoostSpecSpecArgsDict(TypedDict):
        condition_boost_specs: pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgsDict']]]
        """
        A list of boosting specifications.
        Structure is documented below.
        """
elif False:
    ToolDataStoreToolBoostSpecSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolBoostSpecSpecArgs:
    def __init__(__self__, *,
                 condition_boost_specs: pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs']]] condition_boost_specs: A list of boosting specifications.
               Structure is documented below.
        """
        pulumi.set(__self__, "condition_boost_specs", condition_boost_specs)

    @_builtins.property
    @pulumi.getter(name="conditionBoostSpecs")
    def condition_boost_specs(self) -> pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs']]]:
        """
        A list of boosting specifications.
        Structure is documented below.
        """
        return pulumi.get(self, "condition_boost_specs")

    @condition_boost_specs.setter
    def condition_boost_specs(self, value: pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs']]]):
        pulumi.set(self, "condition_boost_specs", value)


if not MYPY:
    class ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgsDict(TypedDict):
        condition: pulumi.Input[_builtins.str]
        """
        An expression which specifies a boost condition. The syntax is the same
        as filter expression syntax. Currently, the only supported condition is
        a list of BCP-47 lang codes.
        Example: To boost suggestions in languages en or fr:
        (lang_code: ANY("en", "fr"))
        """
        boost: NotRequired[pulumi.Input[_builtins.float]]
        """
        Strength of the boost, which should be in [-1, 1]. Negative boost means
        demotion. Default is 0.0.
        Setting to 1.0 gives the suggestions a big promotion. However, it does
        not necessarily mean that the top result will be a boosted suggestion.
        Setting to -1.0 gives the suggestions a big demotion. However, other
        suggestions that are relevant might still be shown.
        Setting to 0.0 means no boost applied. The boosting condition is
        ignored.
        """
        boost_control_spec: NotRequired[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgsDict']]
        """
        Specification for custom ranking based on customer specified attribute
        value. It provides more controls for customized ranking than the simple
        (condition, boost) combination above.
        Structure is documented below.
        """
elif False:
    ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[_builtins.str],
                 boost: Optional[pulumi.Input[_builtins.float]] = None,
                 boost_control_spec: Optional[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] condition: An expression which specifies a boost condition. The syntax is the same
               as filter expression syntax. Currently, the only supported condition is
               a list of BCP-47 lang codes.
               Example: To boost suggestions in languages en or fr:
               (lang_code: ANY("en", "fr"))
        :param pulumi.Input[_builtins.float] boost: Strength of the boost, which should be in [-1, 1]. Negative boost means
               demotion. Default is 0.0.
               Setting to 1.0 gives the suggestions a big promotion. However, it does
               not necessarily mean that the top result will be a boosted suggestion.
               Setting to -1.0 gives the suggestions a big demotion. However, other
               suggestions that are relevant might still be shown.
               Setting to 0.0 means no boost applied. The boosting condition is
               ignored.
        :param pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs'] boost_control_spec: Specification for custom ranking based on customer specified attribute
               value. It provides more controls for customized ranking than the simple
               (condition, boost) combination above.
               Structure is documented below.
        """
        pulumi.set(__self__, "condition", condition)
        if boost is not None:
            pulumi.set(__self__, "boost", boost)
        if boost_control_spec is not None:
            pulumi.set(__self__, "boost_control_spec", boost_control_spec)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input[_builtins.str]:
        """
        An expression which specifies a boost condition. The syntax is the same
        as filter expression syntax. Currently, the only supported condition is
        a list of BCP-47 lang codes.
        Example: To boost suggestions in languages en or fr:
        (lang_code: ANY("en", "fr"))
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter
    def boost(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Strength of the boost, which should be in [-1, 1]. Negative boost means
        demotion. Default is 0.0.
        Setting to 1.0 gives the suggestions a big promotion. However, it does
        not necessarily mean that the top result will be a boosted suggestion.
        Setting to -1.0 gives the suggestions a big demotion. However, other
        suggestions that are relevant might still be shown.
        Setting to 0.0 means no boost applied. The boosting condition is
        ignored.
        """
        return pulumi.get(self, "boost")

    @boost.setter
    def boost(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "boost", value)

    @_builtins.property
    @pulumi.getter(name="boostControlSpec")
    def boost_control_spec(self) -> Optional[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs']]:
        """
        Specification for custom ranking based on customer specified attribute
        value. It provides more controls for customized ranking than the simple
        (condition, boost) combination above.
        Structure is documented below.
        """
        return pulumi.get(self, "boost_control_spec")

    @boost_control_spec.setter
    def boost_control_spec(self, value: Optional[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs']]):
        pulumi.set(self, "boost_control_spec", value)


if not MYPY:
    class ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgsDict(TypedDict):
        attribute_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The attribute type to be used to determine the boost amount. The
        attribute value can be derived from the field value of the specified
        field_name. In the case of numerical it is straightforward i.e.
        attribute_value = numerical_field_value. In the case of freshness
        however, attribute_value = (time.now() - datetime_field_value).
        Possible values:
        NUMERICAL
        FRESHNESS
        """
        control_points: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgsDict']]]]
        """
        The control points used to define the curve. The monotonic function
        (defined through the interpolation_type above) passes through the
        control points listed here.
        Structure is documented below.
        """
        field_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the field whose value will be used to determine the
        boost amount.
        """
        interpolation_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The interpolation type to be applied to connect the control points
        listed below.
        Possible values:
        LINEAR
        """
elif False:
    ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs:
    def __init__(__self__, *,
                 attribute_type: Optional[pulumi.Input[_builtins.str]] = None,
                 control_points: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs']]]] = None,
                 field_name: Optional[pulumi.Input[_builtins.str]] = None,
                 interpolation_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] attribute_type: The attribute type to be used to determine the boost amount. The
               attribute value can be derived from the field value of the specified
               field_name. In the case of numerical it is straightforward i.e.
               attribute_value = numerical_field_value. In the case of freshness
               however, attribute_value = (time.now() - datetime_field_value).
               Possible values:
               NUMERICAL
               FRESHNESS
        :param pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs']]] control_points: The control points used to define the curve. The monotonic function
               (defined through the interpolation_type above) passes through the
               control points listed here.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] field_name: The name of the field whose value will be used to determine the
               boost amount.
        :param pulumi.Input[_builtins.str] interpolation_type: The interpolation type to be applied to connect the control points
               listed below.
               Possible values:
               LINEAR
        """
        if attribute_type is not None:
            pulumi.set(__self__, "attribute_type", attribute_type)
        if control_points is not None:
            pulumi.set(__self__, "control_points", control_points)
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)
        if interpolation_type is not None:
            pulumi.set(__self__, "interpolation_type", interpolation_type)

    @_builtins.property
    @pulumi.getter(name="attributeType")
    def attribute_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The attribute type to be used to determine the boost amount. The
        attribute value can be derived from the field value of the specified
        field_name. In the case of numerical it is straightforward i.e.
        attribute_value = numerical_field_value. In the case of freshness
        however, attribute_value = (time.now() - datetime_field_value).
        Possible values:
        NUMERICAL
        FRESHNESS
        """
        return pulumi.get(self, "attribute_type")

    @attribute_type.setter
    def attribute_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_type", value)

    @_builtins.property
    @pulumi.getter(name="controlPoints")
    def control_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs']]]]:
        """
        The control points used to define the curve. The monotonic function
        (defined through the interpolation_type above) passes through the
        control points listed here.
        Structure is documented below.
        """
        return pulumi.get(self, "control_points")

    @control_points.setter
    def control_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs']]]]):
        pulumi.set(self, "control_points", value)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the field whose value will be used to determine the
        boost amount.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter(name="interpolationType")
    def interpolation_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The interpolation type to be applied to connect the control points
        listed below.
        Possible values:
        LINEAR
        """
        return pulumi.get(self, "interpolation_type")

    @interpolation_type.setter
    def interpolation_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interpolation_type", value)


if not MYPY:
    class ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgsDict(TypedDict):
        attribute_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Can be one of:
        1. The numerical field value.
        2. The duration spec for freshness:
        The value must be formatted as an XSD `dayTimeDuration` value (a
        restricted subset of an ISO 8601 duration value). The pattern for
        this is: `nDnM]`.
        """
        boost_amount: NotRequired[pulumi.Input[_builtins.float]]
        """
        The value between -1 to 1 by which to boost the score if the
        attribute_value evaluates to the value specified above.
        """
elif False:
    ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs:
    def __init__(__self__, *,
                 attribute_value: Optional[pulumi.Input[_builtins.str]] = None,
                 boost_amount: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] attribute_value: Can be one of:
               1. The numerical field value.
               2. The duration spec for freshness:
               The value must be formatted as an XSD `dayTimeDuration` value (a
               restricted subset of an ISO 8601 duration value). The pattern for
               this is: `nDnM]`.
        :param pulumi.Input[_builtins.float] boost_amount: The value between -1 to 1 by which to boost the score if the
               attribute_value evaluates to the value specified above.
        """
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if boost_amount is not None:
            pulumi.set(__self__, "boost_amount", boost_amount)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Can be one of:
        1. The numerical field value.
        2. The duration spec for freshness:
        The value must be formatted as an XSD `dayTimeDuration` value (a
        restricted subset of an ISO 8601 duration value). The pattern for
        this is: `nDnM]`.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="boostAmount")
    def boost_amount(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The value between -1 to 1 by which to boost the score if the
        attribute_value evaluates to the value specified above.
        """
        return pulumi.get(self, "boost_amount")

    @boost_amount.setter
    def boost_amount(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "boost_amount", value)


if not MYPY:
    class ToolDataStoreToolEngineSourceArgsDict(TypedDict):
        engine: pulumi.Input[_builtins.str]
        """
        Full resource name of the Engine.
        Format:
        `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
        """
        data_store_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceArgsDict']]]]
        """
        Use to target specific DataStores within the Engine.
        If empty, the search applies to all DataStores associated with the
        Engine.
        Structure is documented below.
        """
        filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the search across the Engine. Not relevant and not
        used if 'data_store_sources' is provided.
        See:
        https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
elif False:
    ToolDataStoreToolEngineSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolEngineSourceArgs:
    def __init__(__self__, *,
                 engine: pulumi.Input[_builtins.str],
                 data_store_sources: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceArgs']]]] = None,
                 filter: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] engine: Full resource name of the Engine.
               Format:
               `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
        :param pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceArgs']]] data_store_sources: Use to target specific DataStores within the Engine.
               If empty, the search applies to all DataStores associated with the
               Engine.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] filter: A filter applied to the search across the Engine. Not relevant and not
               used if 'data_store_sources' is provided.
               See:
               https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        pulumi.set(__self__, "engine", engine)
        if data_store_sources is not None:
            pulumi.set(__self__, "data_store_sources", data_store_sources)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)

    @_builtins.property
    @pulumi.getter
    def engine(self) -> pulumi.Input[_builtins.str]:
        """
        Full resource name of the Engine.
        Format:
        `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
        """
        return pulumi.get(self, "engine")

    @engine.setter
    def engine(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "engine", value)

    @_builtins.property
    @pulumi.getter(name="dataStoreSources")
    def data_store_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceArgs']]]]:
        """
        Use to target specific DataStores within the Engine.
        If empty, the search applies to all DataStores associated with the
        Engine.
        Structure is documented below.
        """
        return pulumi.get(self, "data_store_sources")

    @data_store_sources.setter
    def data_store_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceArgs']]]]):
        pulumi.set(self, "data_store_sources", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the search across the Engine. Not relevant and not
        used if 'data_store_sources' is provided.
        See:
        https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter", value)


if not MYPY:
    class ToolDataStoreToolEngineSourceDataStoreSourceArgsDict(TypedDict):
        data_store: NotRequired[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgsDict']]
        """
        A DataStore resource in Vertex AI Search.
        Structure is documented below.
        """
        filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Filter specification for the DataStore.
        See:
        https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
elif False:
    ToolDataStoreToolEngineSourceDataStoreSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolEngineSourceDataStoreSourceArgs:
    def __init__(__self__, *,
                 data_store: Optional[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs']] = None,
                 filter: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs'] data_store: A DataStore resource in Vertex AI Search.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] filter: Filter specification for the DataStore.
               See:
               https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        if data_store is not None:
            pulumi.set(__self__, "data_store", data_store)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)

    @_builtins.property
    @pulumi.getter(name="dataStore")
    def data_store(self) -> Optional[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs']]:
        """
        A DataStore resource in Vertex AI Search.
        Structure is documented below.
        """
        return pulumi.get(self, "data_store")

    @data_store.setter
    def data_store(self, value: Optional[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs']]):
        pulumi.set(self, "data_store", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Filter specification for the DataStore.
        See:
        https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter", value)


if not MYPY:
    class ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Full resource name of the DataStore.
        Format:
        `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
        """
        connector_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgsDict']]]]
        """
        (Output)
        The connector config for the data store connection.
        Structure is documented below.
        """
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Timestamp when the data store was created.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The display name of the data store.
        """
        document_processing_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The document processing mode for the data store connection.
        Only set for PUBLIC_WEB and UNSTRUCTURED data stores.
        Possible values:
        DOCUMENTS
        CHUNKS
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR


        <a name="nested_data_store_tool_engine_source_data_store_sources_data_store_sources_data_store_connector_config"></a>The `connector_config` block contains:
        """
elif False:
    ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 connector_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs']]]] = None,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 document_processing_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Full resource name of the DataStore.
               Format:
               `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
        :param pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs']]] connector_configs: (Output)
               The connector config for the data store connection.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] create_time: (Output)
               Timestamp when the data store was created.
        :param pulumi.Input[_builtins.str] display_name: (Output)
               The display name of the data store.
        :param pulumi.Input[_builtins.str] document_processing_mode: (Output)
               The document processing mode for the data store connection.
               Only set for PUBLIC_WEB and UNSTRUCTURED data stores.
               Possible values:
               DOCUMENTS
               CHUNKS
        :param pulumi.Input[_builtins.str] type: (Output)
               The type of the data store. This field is readonly and populated by the
               server.
               Possible values:
               PUBLIC_WEB
               UNSTRUCTURED
               FAQ
               CONNECTOR
               
               
               <a name="nested_data_store_tool_engine_source_data_store_sources_data_store_sources_data_store_connector_config"></a>The `connector_config` block contains:
        """
        pulumi.set(__self__, "name", name)
        if connector_configs is not None:
            pulumi.set(__self__, "connector_configs", connector_configs)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if document_processing_mode is not None:
            pulumi.set(__self__, "document_processing_mode", document_processing_mode)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Full resource name of the DataStore.
        Format:
        `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="connectorConfigs")
    def connector_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs']]]]:
        """
        (Output)
        The connector config for the data store connection.
        Structure is documented below.
        """
        return pulumi.get(self, "connector_configs")

    @connector_configs.setter
    def connector_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs']]]]):
        pulumi.set(self, "connector_configs", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Timestamp when the data store was created.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The display name of the data store.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="documentProcessingMode")
    def document_processing_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The document processing mode for the data store connection.
        Only set for PUBLIC_WEB and UNSTRUCTURED data stores.
        Possible values:
        DOCUMENTS
        CHUNKS
        """
        return pulumi.get(self, "document_processing_mode")

    @document_processing_mode.setter
    def document_processing_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "document_processing_mode", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR


        <a name="nested_data_store_tool_engine_source_data_store_sources_data_store_sources_data_store_connector_config"></a>The `connector_config` block contains:
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgsDict(TypedDict):
        collection: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource name of the collection the data store belongs to.
        """
        collection_display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name of the collection the data store belongs to.
        """
        data_source: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the data source.
        Example: 'salesforce', 'jira', 'confluence', 'bigquery'.
        """
elif False:
    ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs:
    def __init__(__self__, *,
                 collection: Optional[pulumi.Input[_builtins.str]] = None,
                 collection_display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 data_source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] collection: Resource name of the collection the data store belongs to.
        :param pulumi.Input[_builtins.str] collection_display_name: Display name of the collection the data store belongs to.
        :param pulumi.Input[_builtins.str] data_source: The name of the data source.
               Example: 'salesforce', 'jira', 'confluence', 'bigquery'.
        """
        if collection is not None:
            pulumi.set(__self__, "collection", collection)
        if collection_display_name is not None:
            pulumi.set(__self__, "collection_display_name", collection_display_name)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @_builtins.property
    @pulumi.getter
    def collection(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource name of the collection the data store belongs to.
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "collection", value)

    @_builtins.property
    @pulumi.getter(name="collectionDisplayName")
    def collection_display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name of the collection the data store belongs to.
        """
        return pulumi.get(self, "collection_display_name")

    @collection_display_name.setter
    def collection_display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "collection_display_name", value)

    @_builtins.property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the data source.
        Example: 'salesforce', 'jira', 'confluence', 'bigquery'.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_source", value)


if not MYPY:
    class ToolDataStoreToolModalityConfigArgsDict(TypedDict):
        modality_type: pulumi.Input[_builtins.str]
        """
        The modality type.
        Possible values:
        TEXT
        AUDIO
        """
        grounding_config: NotRequired[pulumi.Input['ToolDataStoreToolModalityConfigGroundingConfigArgsDict']]
        """
        Grounding configuration.
        Structure is documented below.
        """
        rewriter_config: NotRequired[pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigArgsDict']]
        """
        Rewriter configuration.
        Structure is documented below.
        """
        summarization_config: NotRequired[pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigArgsDict']]
        """
        Summarization configuration.
        Structure is documented below.
        """
elif False:
    ToolDataStoreToolModalityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolModalityConfigArgs:
    def __init__(__self__, *,
                 modality_type: pulumi.Input[_builtins.str],
                 grounding_config: Optional[pulumi.Input['ToolDataStoreToolModalityConfigGroundingConfigArgs']] = None,
                 rewriter_config: Optional[pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigArgs']] = None,
                 summarization_config: Optional[pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] modality_type: The modality type.
               Possible values:
               TEXT
               AUDIO
        :param pulumi.Input['ToolDataStoreToolModalityConfigGroundingConfigArgs'] grounding_config: Grounding configuration.
               Structure is documented below.
        :param pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigArgs'] rewriter_config: Rewriter configuration.
               Structure is documented below.
        :param pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigArgs'] summarization_config: Summarization configuration.
               Structure is documented below.
        """
        pulumi.set(__self__, "modality_type", modality_type)
        if grounding_config is not None:
            pulumi.set(__self__, "grounding_config", grounding_config)
        if rewriter_config is not None:
            pulumi.set(__self__, "rewriter_config", rewriter_config)
        if summarization_config is not None:
            pulumi.set(__self__, "summarization_config", summarization_config)

    @_builtins.property
    @pulumi.getter(name="modalityType")
    def modality_type(self) -> pulumi.Input[_builtins.str]:
        """
        The modality type.
        Possible values:
        TEXT
        AUDIO
        """
        return pulumi.get(self, "modality_type")

    @modality_type.setter
    def modality_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "modality_type", value)

    @_builtins.property
    @pulumi.getter(name="groundingConfig")
    def grounding_config(self) -> Optional[pulumi.Input['ToolDataStoreToolModalityConfigGroundingConfigArgs']]:
        """
        Grounding configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "grounding_config")

    @grounding_config.setter
    def grounding_config(self, value: Optional[pulumi.Input['ToolDataStoreToolModalityConfigGroundingConfigArgs']]):
        pulumi.set(self, "grounding_config", value)

    @_builtins.property
    @pulumi.getter(name="rewriterConfig")
    def rewriter_config(self) -> Optional[pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigArgs']]:
        """
        Rewriter configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "rewriter_config")

    @rewriter_config.setter
    def rewriter_config(self, value: Optional[pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigArgs']]):
        pulumi.set(self, "rewriter_config", value)

    @_builtins.property
    @pulumi.getter(name="summarizationConfig")
    def summarization_config(self) -> Optional[pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigArgs']]:
        """
        Summarization configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "summarization_config")

    @summarization_config.setter
    def summarization_config(self, value: Optional[pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigArgs']]):
        pulumi.set(self, "summarization_config", value)


if not MYPY:
    class ToolDataStoreToolModalityConfigGroundingConfigArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether grounding is disabled.
        """
        grounding_level: NotRequired[pulumi.Input[_builtins.float]]
        """
        The groundedness threshold of the answer based on the retrieved sources.
        The value has a configurable range of [1, 5]. The level is used to
        threshold the groundedness of the answer, meaning that all responses with
        a groundedness score below the threshold will fall back to returning
        relevant snippets only.
        For example, a level of 3 means that the groundedness score must be
        3 or higher for the response to be returned.
        """
elif False:
    ToolDataStoreToolModalityConfigGroundingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolModalityConfigGroundingConfigArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 grounding_level: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.bool] disabled: Whether grounding is disabled.
        :param pulumi.Input[_builtins.float] grounding_level: The groundedness threshold of the answer based on the retrieved sources.
               The value has a configurable range of [1, 5]. The level is used to
               threshold the groundedness of the answer, meaning that all responses with
               a groundedness score below the threshold will fall back to returning
               relevant snippets only.
               For example, a level of 3 means that the groundedness score must be
               3 or higher for the response to be returned.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if grounding_level is not None:
            pulumi.set(__self__, "grounding_level", grounding_level)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether grounding is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="groundingLevel")
    def grounding_level(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The groundedness threshold of the answer based on the retrieved sources.
        The value has a configurable range of [1, 5]. The level is used to
        threshold the groundedness of the answer, meaning that all responses with
        a groundedness score below the threshold will fall back to returning
        relevant snippets only.
        For example, a level of 3 means that the groundedness score must be
        3 or higher for the response to be returned.
        """
        return pulumi.get(self, "grounding_level")

    @grounding_level.setter
    def grounding_level(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "grounding_level", value)


if not MYPY:
    class ToolDataStoreToolModalityConfigRewriterConfigArgsDict(TypedDict):
        model_settings: pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgsDict']
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the rewriter is disabled.
        """
        prompt: NotRequired[pulumi.Input[_builtins.str]]
        """
        The prompt definition. If not set, default prompt will be used.
        """
elif False:
    ToolDataStoreToolModalityConfigRewriterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolModalityConfigRewriterConfigArgs:
    def __init__(__self__, *,
                 model_settings: pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgs'],
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 prompt: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgs'] model_settings: Model settings contains various configurations for the LLM model.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] disabled: Whether the rewriter is disabled.
        :param pulumi.Input[_builtins.str] prompt: The prompt definition. If not set, default prompt will be used.
        """
        pulumi.set(__self__, "model_settings", model_settings)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgs']:
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @model_settings.setter
    def model_settings(self, value: pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgs']):
        pulumi.set(self, "model_settings", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the rewriter is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The prompt definition. If not set, default prompt will be used.
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prompt", value)


if not MYPY:
    class ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
elif False:
    ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] model: The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param pulumi.Input[_builtins.float] temperature: If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)


if not MYPY:
    class ToolDataStoreToolModalityConfigSummarizationConfigArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether summarization is disabled.
        """
        model_settings: NotRequired[pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgsDict']]
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        prompt: NotRequired[pulumi.Input[_builtins.str]]
        """
        The prompt definition. If not set, default prompt will be used.
        """
elif False:
    ToolDataStoreToolModalityConfigSummarizationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolModalityConfigSummarizationConfigArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 model_settings: Optional[pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgs']] = None,
                 prompt: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] disabled: Whether summarization is disabled.
        :param pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgs'] model_settings: Model settings contains various configurations for the LLM model.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] prompt: The prompt definition. If not set, default prompt will be used.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional[pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgs']]:
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @model_settings.setter
    def model_settings(self, value: Optional[pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgs']]):
        pulumi.set(self, "model_settings", value)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The prompt definition. If not set, default prompt will be used.
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prompt", value)


if not MYPY:
    class ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
elif False:
    ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] model: The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param pulumi.Input[_builtins.float] temperature: If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)


if not MYPY:
    class ToolGoogleSearchToolArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the tool.
        """
        context_urls: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Content will be fetched directly from these URLs for context and grounding.
        More details: https://cloud.google.com/vertex-ai/generative-ai/docs/url-context.
        Example: "https://example.com/path.html". A maximum of 20 URLs are allowed.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the tool's purpose.
        """
        exclude_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of domains to be excluded from the search results.
        Example: "example.com".
        A maximum of 2000 domains can be excluded.
        """
        preferred_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Specifies domain names to guide the search.
        The model will be instructed to prioritize these domains
        when formulating queries for google search.
        This is a best-effort hint and these domains may or may
        not be exclusively reflected in the final search results.
        Example: "example.com", "another.site".
        A maximum of 20 domains can be specified.
        """
elif False:
    ToolGoogleSearchToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolGoogleSearchToolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 context_urls: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 exclude_domains: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 preferred_domains: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the tool.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] context_urls: Content will be fetched directly from these URLs for context and grounding.
               More details: https://cloud.google.com/vertex-ai/generative-ai/docs/url-context.
               Example: "https://example.com/path.html". A maximum of 20 URLs are allowed.
        :param pulumi.Input[_builtins.str] description: Description of the tool's purpose.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_domains: List of domains to be excluded from the search results.
               Example: "example.com".
               A maximum of 2000 domains can be excluded.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] preferred_domains: Specifies domain names to guide the search.
               The model will be instructed to prioritize these domains
               when formulating queries for google search.
               This is a best-effort hint and these domains may or may
               not be exclusively reflected in the final search results.
               Example: "example.com", "another.site".
               A maximum of 20 domains can be specified.
        """
        pulumi.set(__self__, "name", name)
        if context_urls is not None:
            pulumi.set(__self__, "context_urls", context_urls)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exclude_domains is not None:
            pulumi.set(__self__, "exclude_domains", exclude_domains)
        if preferred_domains is not None:
            pulumi.set(__self__, "preferred_domains", preferred_domains)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the tool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="contextUrls")
    def context_urls(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Content will be fetched directly from these URLs for context and grounding.
        More details: https://cloud.google.com/vertex-ai/generative-ai/docs/url-context.
        Example: "https://example.com/path.html". A maximum of 20 URLs are allowed.
        """
        return pulumi.get(self, "context_urls")

    @context_urls.setter
    def context_urls(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "context_urls", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the tool's purpose.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="excludeDomains")
    def exclude_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of domains to be excluded from the search results.
        Example: "example.com".
        A maximum of 2000 domains can be excluded.
        """
        return pulumi.get(self, "exclude_domains")

    @exclude_domains.setter
    def exclude_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_domains", value)

    @_builtins.property
    @pulumi.getter(name="preferredDomains")
    def preferred_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Specifies domain names to guide the search.
        The model will be instructed to prioritize these domains
        when formulating queries for google search.
        This is a best-effort hint and these domains may or may
        not be exclusively reflected in the final search results.
        Example: "example.com", "another.site".
        A maximum of 20 domains can be specified.
        """
        return pulumi.get(self, "preferred_domains")

    @preferred_domains.setter
    def preferred_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "preferred_domains", value)


if not MYPY:
    class ToolOpenApiToolArgsDict(TypedDict):
        api_authentications: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationArgsDict']]]]
        """
        (Output)
        Authentication information required for API calls.
        Structure is documented below.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The description of the system tool.
        """
        ignore_unknown_fields: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        If true, the agent will ignore unknown fields in the API response.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the system tool.
        """
        open_api_schema: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The OpenAPI schema in JSON or YAML format.
        """
        service_directory_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolServiceDirectoryConfigArgsDict']]]]
        """
        (Output)
        Configuration for tools using Service Directory.
        Structure is documented below.
        """
        tls_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigArgsDict']]]]
        """
        (Output)
        The TLS configuration.
        Structure is documented below.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The server URL of the Open API schema. This field is only set in tools in the
        environment dependencies during the export process if the schema contains a
        server url. During the import process, if this url is present in the environment
        dependencies and the schema has the $env_var placeholder, it will replace the
        placeholder in the schema.
        """
elif False:
    ToolOpenApiToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolOpenApiToolArgs:
    def __init__(__self__, *,
                 api_authentications: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 ignore_unknown_fields: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 open_api_schema: Optional[pulumi.Input[_builtins.str]] = None,
                 service_directory_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolServiceDirectoryConfigArgs']]]] = None,
                 tls_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigArgs']]]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationArgs']]] api_authentications: (Output)
               Authentication information required for API calls.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] description: (Output)
               The description of the system tool.
        :param pulumi.Input[_builtins.bool] ignore_unknown_fields: (Output)
               If true, the agent will ignore unknown fields in the API response.
        :param pulumi.Input[_builtins.str] name: (Output)
               The name of the system tool.
        :param pulumi.Input[_builtins.str] open_api_schema: (Output)
               The OpenAPI schema in JSON or YAML format.
        :param pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolServiceDirectoryConfigArgs']]] service_directory_configs: (Output)
               Configuration for tools using Service Directory.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigArgs']]] tls_configs: (Output)
               The TLS configuration.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] url: (Output)
               The server URL of the Open API schema. This field is only set in tools in the
               environment dependencies during the export process if the schema contains a
               server url. During the import process, if this url is present in the environment
               dependencies and the schema has the $env_var placeholder, it will replace the
               placeholder in the schema.
        """
        if api_authentications is not None:
            pulumi.set(__self__, "api_authentications", api_authentications)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ignore_unknown_fields is not None:
            pulumi.set(__self__, "ignore_unknown_fields", ignore_unknown_fields)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if open_api_schema is not None:
            pulumi.set(__self__, "open_api_schema", open_api_schema)
        if service_directory_configs is not None:
            pulumi.set(__self__, "service_directory_configs", service_directory_configs)
        if tls_configs is not None:
            pulumi.set(__self__, "tls_configs", tls_configs)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="apiAuthentications")
    def api_authentications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationArgs']]]]:
        """
        (Output)
        Authentication information required for API calls.
        Structure is documented below.
        """
        return pulumi.get(self, "api_authentications")

    @api_authentications.setter
    def api_authentications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationArgs']]]]):
        pulumi.set(self, "api_authentications", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The description of the system tool.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="ignoreUnknownFields")
    def ignore_unknown_fields(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        If true, the agent will ignore unknown fields in the API response.
        """
        return pulumi.get(self, "ignore_unknown_fields")

    @ignore_unknown_fields.setter
    def ignore_unknown_fields(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_unknown_fields", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the system tool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="openApiSchema")
    def open_api_schema(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The OpenAPI schema in JSON or YAML format.
        """
        return pulumi.get(self, "open_api_schema")

    @open_api_schema.setter
    def open_api_schema(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "open_api_schema", value)

    @_builtins.property
    @pulumi.getter(name="serviceDirectoryConfigs")
    def service_directory_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolServiceDirectoryConfigArgs']]]]:
        """
        (Output)
        Configuration for tools using Service Directory.
        Structure is documented below.
        """
        return pulumi.get(self, "service_directory_configs")

    @service_directory_configs.setter
    def service_directory_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolServiceDirectoryConfigArgs']]]]):
        pulumi.set(self, "service_directory_configs", value)

    @_builtins.property
    @pulumi.getter(name="tlsConfigs")
    def tls_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigArgs']]]]:
        """
        (Output)
        The TLS configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "tls_configs")

    @tls_configs.setter
    def tls_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigArgs']]]]):
        pulumi.set(self, "tls_configs", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The server URL of the Open API schema. This field is only set in tools in the
        environment dependencies during the export process if the schema contains a
        server url. During the import process, if this url is present in the environment
        dependencies and the schema has the $env_var placeholder, it will replace the
        placeholder in the schema.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ToolOpenApiToolApiAuthenticationArgsDict(TypedDict):
        api_key_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationApiKeyConfigArgsDict']]]]
        """
        (Output)
        Configurations for authentication with API key.
        Structure is documented below.
        """
        bearer_token_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationBearerTokenConfigArgsDict']]]]
        """
        (Output)
        Configurations for authentication with a bearer token.
        Structure is documented below.
        """
        oauth_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationOauthConfigArgsDict']]]]
        """
        (Output)
        Configurations for authentication with OAuth.
        Structure is documented below.
        """
        service_account_auth_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgsDict']]]]
        """
        (Output)
        Configurations for authentication using a custom service account.
        Structure is documented below.
        """
        service_agent_id_token_auth_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict']]]]
        """
        (Output)
        Configurations for authentication with [ID
        token](https://cloud.google.com/docs/authentication/token-types#id) generated
        from service agent.
        """
elif False:
    ToolOpenApiToolApiAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolOpenApiToolApiAuthenticationArgs:
    def __init__(__self__, *,
                 api_key_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationApiKeyConfigArgs']]]] = None,
                 bearer_token_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationBearerTokenConfigArgs']]]] = None,
                 oauth_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationOauthConfigArgs']]]] = None,
                 service_account_auth_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs']]]] = None,
                 service_agent_id_token_auth_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationApiKeyConfigArgs']]] api_key_configs: (Output)
               Configurations for authentication with API key.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationBearerTokenConfigArgs']]] bearer_token_configs: (Output)
               Configurations for authentication with a bearer token.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationOauthConfigArgs']]] oauth_configs: (Output)
               Configurations for authentication with OAuth.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs']]] service_account_auth_configs: (Output)
               Configurations for authentication using a custom service account.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]] service_agent_id_token_auth_configs: (Output)
               Configurations for authentication with [ID
               token](https://cloud.google.com/docs/authentication/token-types#id) generated
               from service agent.
        """
        if api_key_configs is not None:
            pulumi.set(__self__, "api_key_configs", api_key_configs)
        if bearer_token_configs is not None:
            pulumi.set(__self__, "bearer_token_configs", bearer_token_configs)
        if oauth_configs is not None:
            pulumi.set(__self__, "oauth_configs", oauth_configs)
        if service_account_auth_configs is not None:
            pulumi.set(__self__, "service_account_auth_configs", service_account_auth_configs)
        if service_agent_id_token_auth_configs is not None:
            pulumi.set(__self__, "service_agent_id_token_auth_configs", service_agent_id_token_auth_configs)

    @_builtins.property
    @pulumi.getter(name="apiKeyConfigs")
    def api_key_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationApiKeyConfigArgs']]]]:
        """
        (Output)
        Configurations for authentication with API key.
        Structure is documented below.
        """
        return pulumi.get(self, "api_key_configs")

    @api_key_configs.setter
    def api_key_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationApiKeyConfigArgs']]]]):
        pulumi.set(self, "api_key_configs", value)

    @_builtins.property
    @pulumi.getter(name="bearerTokenConfigs")
    def bearer_token_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationBearerTokenConfigArgs']]]]:
        """
        (Output)
        Configurations for authentication with a bearer token.
        Structure is documented below.
        """
        return pulumi.get(self, "bearer_token_configs")

    @bearer_token_configs.setter
    def bearer_token_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationBearerTokenConfigArgs']]]]):
        pulumi.set(self, "bearer_token_configs", value)

    @_builtins.property
    @pulumi.getter(name="oauthConfigs")
    def oauth_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationOauthConfigArgs']]]]:
        """
        (Output)
        Configurations for authentication with OAuth.
        Structure is documented below.
        """
        return pulumi.get(self, "oauth_configs")

    @oauth_configs.setter
    def oauth_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationOauthConfigArgs']]]]):
        pulumi.set(self, "oauth_configs", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccountAuthConfigs")
    def service_account_auth_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs']]]]:
        """
        (Output)
        Configurations for authentication using a custom service account.
        Structure is documented below.
        """
        return pulumi.get(self, "service_account_auth_configs")

    @service_account_auth_configs.setter
    def service_account_auth_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs']]]]):
        pulumi.set(self, "service_account_auth_configs", value)

    @_builtins.property
    @pulumi.getter(name="serviceAgentIdTokenAuthConfigs")
    def service_agent_id_token_auth_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]]]:
        """
        (Output)
        Configurations for authentication with [ID
        token](https://cloud.google.com/docs/authentication/token-types#id) generated
        from service agent.
        """
        return pulumi.get(self, "service_agent_id_token_auth_configs")

    @service_agent_id_token_auth_configs.setter
    def service_agent_id_token_auth_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]]]):
        pulumi.set(self, "service_agent_id_token_auth_configs", value)


if not MYPY:
    class ToolOpenApiToolApiAuthenticationApiKeyConfigArgsDict(TypedDict):
        api_key_secret_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the SecretManager secret version resource storing the API key.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        key_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        request_location: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Key location in the request.
        Possible values:
        HEADER
        QUERY_STRING
        """
elif False:
    ToolOpenApiToolApiAuthenticationApiKeyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolOpenApiToolApiAuthenticationApiKeyConfigArgs:
    def __init__(__self__, *,
                 api_key_secret_version: Optional[pulumi.Input[_builtins.str]] = None,
                 key_name: Optional[pulumi.Input[_builtins.str]] = None,
                 request_location: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key_secret_version: (Output)
               The name of the SecretManager secret version resource storing the API key.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        :param pulumi.Input[_builtins.str] key_name: (Output)
               The parameter name or the header name of the API key.
               E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        :param pulumi.Input[_builtins.str] request_location: (Output)
               Key location in the request.
               Possible values:
               HEADER
               QUERY_STRING
        """
        if api_key_secret_version is not None:
            pulumi.set(__self__, "api_key_secret_version", api_key_secret_version)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if request_location is not None:
            pulumi.set(__self__, "request_location", request_location)

    @_builtins.property
    @pulumi.getter(name="apiKeySecretVersion")
    def api_key_secret_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the SecretManager secret version resource storing the API key.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "api_key_secret_version")

    @api_key_secret_version.setter
    def api_key_secret_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_key_secret_version", value)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter(name="requestLocation")
    def request_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Key location in the request.
        Possible values:
        HEADER
        QUERY_STRING
        """
        return pulumi.get(self, "request_location")

    @request_location.setter
    def request_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request_location", value)


if not MYPY:
    class ToolOpenApiToolApiAuthenticationBearerTokenConfigArgsDict(TypedDict):
        token: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The bearer token. Must be in the format $context.variables.<name_of_variable>.
        """
elif False:
    ToolOpenApiToolApiAuthenticationBearerTokenConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolOpenApiToolApiAuthenticationBearerTokenConfigArgs:
    def __init__(__self__, *,
                 token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] token: (Output)
               The bearer token. Must be in the format $context.variables.<name_of_variable>.
        """
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The bearer token. Must be in the format $context.variables.<name_of_variable>.
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ToolOpenApiToolApiAuthenticationOauthConfigArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The client ID from the OAuth provider.
        """
        client_secret_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the SecretManager secret version resource storing the
        client secret.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        oauth_grant_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        OAuth grant types.
        Possible values:
        CLIENT_CREDENTIAL
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        The OAuth scopes to grant.
        """
        token_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The token endpoint in the OAuth provider to exchange for an access token.
        """
elif False:
    ToolOpenApiToolApiAuthenticationOauthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolOpenApiToolApiAuthenticationOauthConfigArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret_version: Optional[pulumi.Input[_builtins.str]] = None,
                 oauth_grant_type: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id: (Output)
               The client ID from the OAuth provider.
        :param pulumi.Input[_builtins.str] client_secret_version: (Output)
               The name of the SecretManager secret version resource storing the
               client secret.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        :param pulumi.Input[_builtins.str] oauth_grant_type: (Output)
               OAuth grant types.
               Possible values:
               CLIENT_CREDENTIAL
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: (Output)
               The OAuth scopes to grant.
        :param pulumi.Input[_builtins.str] token_endpoint: (Output)
               The token endpoint in the OAuth provider to exchange for an access token.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_version is not None:
            pulumi.set(__self__, "client_secret_version", client_secret_version)
        if oauth_grant_type is not None:
            pulumi.set(__self__, "oauth_grant_type", oauth_grant_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The client ID from the OAuth provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretVersion")
    def client_secret_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the SecretManager secret version resource storing the
        client secret.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "client_secret_version")

    @client_secret_version.setter
    def client_secret_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret_version", value)

    @_builtins.property
    @pulumi.getter(name="oauthGrantType")
    def oauth_grant_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        OAuth grant types.
        Possible values:
        CLIENT_CREDENTIAL
        """
        return pulumi.get(self, "oauth_grant_type")

    @oauth_grant_type.setter
    def oauth_grant_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oauth_grant_type", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        The OAuth scopes to grant.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The token endpoint in the OAuth provider to exchange for an access token.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_endpoint", value)


if not MYPY:
    class ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgsDict(TypedDict):
        service_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The email address of the service account used for authenticatation. CES
        uses this service account to exchange an access token and the access token
        is then sent in the `Authorization` header of the request.
        The service account must have the
        `roles/iam.serviceAccountTokenCreator` role granted to the
        CES service agent
        `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        """
elif False:
    ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs:
    def __init__(__self__, *,
                 service_account: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] service_account: (Output)
               The email address of the service account used for authenticatation. CES
               uses this service account to exchange an access token and the access token
               is then sent in the `Authorization` header of the request.
               The service account must have the
               `roles/iam.serviceAccountTokenCreator` role granted to the
               CES service agent
               `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The email address of the service account used for authenticatation. CES
        uses this service account to exchange an access token and the access token
        is then sent in the `Authorization` header of the request.
        The service account must have the
        `roles/iam.serviceAccountTokenCreator` role granted to the
        CES service agent
        `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_account", value)


if not MYPY:
    class ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict(TypedDict):
        pass
elif False:
    ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ToolOpenApiToolServiceDirectoryConfigArgsDict(TypedDict):
        service: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of [Service
        Directory](https://cloud.google.com/service-directory) service.
        Format:
        `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
        Location of the service directory must be the same as the location of the
        app.
        """
elif False:
    ToolOpenApiToolServiceDirectoryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolOpenApiToolServiceDirectoryConfigArgs:
    def __init__(__self__, *,
                 service: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] service: (Output)
               The name of [Service
               Directory](https://cloud.google.com/service-directory) service.
               Format:
               `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
               Location of the service directory must be the same as the location of the
               app.
        """
        if service is not None:
            pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of [Service
        Directory](https://cloud.google.com/service-directory) service.
        Format:
        `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
        Location of the service directory must be the same as the location of the
        app.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service", value)


if not MYPY:
    class ToolOpenApiToolTlsConfigArgsDict(TypedDict):
        ca_certs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigCaCertArgsDict']]]]
        """
        (Output)
        Specifies a list of allowed custom CA certificates for HTTPS
        verification.
        Structure is documented below.
        """
elif False:
    ToolOpenApiToolTlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolOpenApiToolTlsConfigArgs:
    def __init__(__self__, *,
                 ca_certs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigCaCertArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigCaCertArgs']]] ca_certs: (Output)
               Specifies a list of allowed custom CA certificates for HTTPS
               verification.
               Structure is documented below.
        """
        if ca_certs is not None:
            pulumi.set(__self__, "ca_certs", ca_certs)

    @_builtins.property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigCaCertArgs']]]]:
        """
        (Output)
        Specifies a list of allowed custom CA certificates for HTTPS
        verification.
        Structure is documented below.
        """
        return pulumi.get(self, "ca_certs")

    @ca_certs.setter
    def ca_certs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigCaCertArgs']]]]):
        pulumi.set(self, "ca_certs", value)


if not MYPY:
    class ToolOpenApiToolTlsConfigCaCertArgsDict(TypedDict):
        cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, CES will use Google's default trust
        store to verify certificates. N.B. Make sure the HTTPS server
        certificates are signed with "subject alt name". For instance a
        certificate can be self-signed using the following command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        A base64-encoded string.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the allowed custom CA certificates. This
        can be used to disambiguate the custom CA certificates.
        """
elif False:
    ToolOpenApiToolTlsConfigCaCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolOpenApiToolTlsConfigCaCertArgs:
    def __init__(__self__, *,
                 cert: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cert: (Output)
               The allowed custom CA certificates (in DER format) for
               HTTPS verification. This overrides the default SSL trust store. If this
               is empty or unspecified, CES will use Google's default trust
               store to verify certificates. N.B. Make sure the HTTPS server
               certificates are signed with "subject alt name". For instance a
               certificate can be self-signed using the following command,
               openssl x509 -req -days 200 -in example.com.csr \\
               -signkey example.com.key \\
               -out example.com.crt \\
               -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
               A base64-encoded string.
        :param pulumi.Input[_builtins.str] display_name: (Output)
               The name of the allowed custom CA certificates. This
               can be used to disambiguate the custom CA certificates.
        """
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, CES will use Google's default trust
        store to verify certificates. N.B. Make sure the HTTPS server
        certificates are signed with "subject alt name". For instance a
        certificate can be self-signed using the following command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        A base64-encoded string.
        """
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cert", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the allowed custom CA certificates. This
        can be used to disambiguate the custom CA certificates.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ToolPythonFunctionArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The description of the Python function, parsed from the python code's
        docstring.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Python function to execute. Must match a Python function
        name defined in the python code. Case sensitive. If the name is not
        provided, the first function defined in the python code will be used.
        """
        python_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Python code to execute for the tool.
        """
elif False:
    ToolPythonFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolPythonFunctionArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 python_code: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: (Output)
               The description of the Python function, parsed from the python code's
               docstring.
        :param pulumi.Input[_builtins.str] name: The name of the Python function to execute. Must match a Python function
               name defined in the python code. Case sensitive. If the name is not
               provided, the first function defined in the python code will be used.
        :param pulumi.Input[_builtins.str] python_code: The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The description of the Python function, parsed from the python code's
        docstring.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Python function to execute. Must match a Python function
        name defined in the python code. Case sensitive. If the name is not
        provided, the first function defined in the python code will be used.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "python_code", value)


if not MYPY:
    class ToolSystemToolArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The description of the system tool.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the system tool.
        """
elif False:
    ToolSystemToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolSystemToolArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: (Output)
               The description of the system tool.
        :param pulumi.Input[_builtins.str] name: (Output)
               The name of the system tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The description of the system tool.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the system tool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ToolsetOpenApiToolsetArgsDict(TypedDict):
        open_api_schema: pulumi.Input[_builtins.str]
        """
        The OpenAPI schema of the toolset.
        """
        api_authentication: NotRequired[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationArgsDict']]
        """
        Authentication information required for API calls.
        Structure is documented below.
        """
        ignore_unknown_fields: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the agent will ignore unknown fields in the API response for all
        operations defined in the OpenAPI schema.
        """
        service_directory_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetServiceDirectoryConfigArgsDict']]
        """
        Configuration for tools using Service Directory.
        Structure is documented below.
        """
        tls_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetTlsConfigArgsDict']]
        """
        The TLS configuration.
        Structure is documented below.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The server URL of the Open API schema.
        This field is only set in toolsets in the environment dependencies
        during the export process if the schema contains a server url.
        During the import process, if this url is present in the environment dependencies
        and the schema has the $env_var placeholder,
        it will replace the placeholder in the schema.
        """
elif False:
    ToolsetOpenApiToolsetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetArgs:
    def __init__(__self__, *,
                 open_api_schema: pulumi.Input[_builtins.str],
                 api_authentication: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationArgs']] = None,
                 ignore_unknown_fields: Optional[pulumi.Input[_builtins.bool]] = None,
                 service_directory_config: Optional[pulumi.Input['ToolsetOpenApiToolsetServiceDirectoryConfigArgs']] = None,
                 tls_config: Optional[pulumi.Input['ToolsetOpenApiToolsetTlsConfigArgs']] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] open_api_schema: The OpenAPI schema of the toolset.
        :param pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationArgs'] api_authentication: Authentication information required for API calls.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] ignore_unknown_fields: If true, the agent will ignore unknown fields in the API response for all
               operations defined in the OpenAPI schema.
        :param pulumi.Input['ToolsetOpenApiToolsetServiceDirectoryConfigArgs'] service_directory_config: Configuration for tools using Service Directory.
               Structure is documented below.
        :param pulumi.Input['ToolsetOpenApiToolsetTlsConfigArgs'] tls_config: The TLS configuration.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] url: (Output)
               The server URL of the Open API schema.
               This field is only set in toolsets in the environment dependencies
               during the export process if the schema contains a server url.
               During the import process, if this url is present in the environment dependencies
               and the schema has the $env_var placeholder,
               it will replace the placeholder in the schema.
        """
        pulumi.set(__self__, "open_api_schema", open_api_schema)
        if api_authentication is not None:
            pulumi.set(__self__, "api_authentication", api_authentication)
        if ignore_unknown_fields is not None:
            pulumi.set(__self__, "ignore_unknown_fields", ignore_unknown_fields)
        if service_directory_config is not None:
            pulumi.set(__self__, "service_directory_config", service_directory_config)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="openApiSchema")
    def open_api_schema(self) -> pulumi.Input[_builtins.str]:
        """
        The OpenAPI schema of the toolset.
        """
        return pulumi.get(self, "open_api_schema")

    @open_api_schema.setter
    def open_api_schema(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "open_api_schema", value)

    @_builtins.property
    @pulumi.getter(name="apiAuthentication")
    def api_authentication(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationArgs']]:
        """
        Authentication information required for API calls.
        Structure is documented below.
        """
        return pulumi.get(self, "api_authentication")

    @api_authentication.setter
    def api_authentication(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationArgs']]):
        pulumi.set(self, "api_authentication", value)

    @_builtins.property
    @pulumi.getter(name="ignoreUnknownFields")
    def ignore_unknown_fields(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the agent will ignore unknown fields in the API response for all
        operations defined in the OpenAPI schema.
        """
        return pulumi.get(self, "ignore_unknown_fields")

    @ignore_unknown_fields.setter
    def ignore_unknown_fields(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_unknown_fields", value)

    @_builtins.property
    @pulumi.getter(name="serviceDirectoryConfig")
    def service_directory_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetServiceDirectoryConfigArgs']]:
        """
        Configuration for tools using Service Directory.
        Structure is documented below.
        """
        return pulumi.get(self, "service_directory_config")

    @service_directory_config.setter
    def service_directory_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetServiceDirectoryConfigArgs']]):
        pulumi.set(self, "service_directory_config", value)

    @_builtins.property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetTlsConfigArgs']]:
        """
        The TLS configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "tls_config")

    @tls_config.setter
    def tls_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetTlsConfigArgs']]):
        pulumi.set(self, "tls_config", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The server URL of the Open API schema.
        This field is only set in toolsets in the environment dependencies
        during the export process if the schema contains a server url.
        During the import process, if this url is present in the environment dependencies
        and the schema has the $env_var placeholder,
        it will replace the placeholder in the schema.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ToolsetOpenApiToolsetApiAuthenticationArgsDict(TypedDict):
        api_key_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgsDict']]
        """
        Configurations for authentication with API key.
        Structure is documented below.
        """
        bearer_token_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgsDict']]
        """
        Configurations for authentication with a bearer token.
        Structure is documented below.
        """
        oauth_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgsDict']]
        """
        Configurations for authentication with OAuth.
        Structure is documented below.
        """
        service_account_auth_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgsDict']]
        """
        Configurations for authentication using a custom service account.
        Structure is documented below.
        """
        service_agent_id_token_auth_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict']]
        """
        Configurations for authentication with [ID
        token](https://cloud.google.com/docs/authentication/token-types#id) generated
        from service agent.
        """
elif False:
    ToolsetOpenApiToolsetApiAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetApiAuthenticationArgs:
    def __init__(__self__, *,
                 api_key_config: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs']] = None,
                 bearer_token_config: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs']] = None,
                 oauth_config: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs']] = None,
                 service_account_auth_config: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs']] = None,
                 service_agent_id_token_auth_config: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs']] = None):
        """
        :param pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs'] api_key_config: Configurations for authentication with API key.
               Structure is documented below.
        :param pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs'] bearer_token_config: Configurations for authentication with a bearer token.
               Structure is documented below.
        :param pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs'] oauth_config: Configurations for authentication with OAuth.
               Structure is documented below.
        :param pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs'] service_account_auth_config: Configurations for authentication using a custom service account.
               Structure is documented below.
        :param pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs'] service_agent_id_token_auth_config: Configurations for authentication with [ID
               token](https://cloud.google.com/docs/authentication/token-types#id) generated
               from service agent.
        """
        if api_key_config is not None:
            pulumi.set(__self__, "api_key_config", api_key_config)
        if bearer_token_config is not None:
            pulumi.set(__self__, "bearer_token_config", bearer_token_config)
        if oauth_config is not None:
            pulumi.set(__self__, "oauth_config", oauth_config)
        if service_account_auth_config is not None:
            pulumi.set(__self__, "service_account_auth_config", service_account_auth_config)
        if service_agent_id_token_auth_config is not None:
            pulumi.set(__self__, "service_agent_id_token_auth_config", service_agent_id_token_auth_config)

    @_builtins.property
    @pulumi.getter(name="apiKeyConfig")
    def api_key_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs']]:
        """
        Configurations for authentication with API key.
        Structure is documented below.
        """
        return pulumi.get(self, "api_key_config")

    @api_key_config.setter
    def api_key_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs']]):
        pulumi.set(self, "api_key_config", value)

    @_builtins.property
    @pulumi.getter(name="bearerTokenConfig")
    def bearer_token_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs']]:
        """
        Configurations for authentication with a bearer token.
        Structure is documented below.
        """
        return pulumi.get(self, "bearer_token_config")

    @bearer_token_config.setter
    def bearer_token_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs']]):
        pulumi.set(self, "bearer_token_config", value)

    @_builtins.property
    @pulumi.getter(name="oauthConfig")
    def oauth_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs']]:
        """
        Configurations for authentication with OAuth.
        Structure is documented below.
        """
        return pulumi.get(self, "oauth_config")

    @oauth_config.setter
    def oauth_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs']]):
        pulumi.set(self, "oauth_config", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccountAuthConfig")
    def service_account_auth_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs']]:
        """
        Configurations for authentication using a custom service account.
        Structure is documented below.
        """
        return pulumi.get(self, "service_account_auth_config")

    @service_account_auth_config.setter
    def service_account_auth_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs']]):
        pulumi.set(self, "service_account_auth_config", value)

    @_builtins.property
    @pulumi.getter(name="serviceAgentIdTokenAuthConfig")
    def service_agent_id_token_auth_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]:
        """
        Configurations for authentication with [ID
        token](https://cloud.google.com/docs/authentication/token-types#id) generated
        from service agent.
        """
        return pulumi.get(self, "service_agent_id_token_auth_config")

    @service_agent_id_token_auth_config.setter
    def service_agent_id_token_auth_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]):
        pulumi.set(self, "service_agent_id_token_auth_config", value)


if not MYPY:
    class ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgsDict(TypedDict):
        api_key_secret_version: pulumi.Input[_builtins.str]
        """
        The name of the SecretManager secret version resource storing the API key.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        key_name: pulumi.Input[_builtins.str]
        """
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        request_location: pulumi.Input[_builtins.str]
        """
        Key location in the request.
        Possible values:
        HEADER
        QUERY_STRING
        """
elif False:
    ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs:
    def __init__(__self__, *,
                 api_key_secret_version: pulumi.Input[_builtins.str],
                 key_name: pulumi.Input[_builtins.str],
                 request_location: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] api_key_secret_version: The name of the SecretManager secret version resource storing the API key.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param pulumi.Input[_builtins.str] key_name: The parameter name or the header name of the API key.
               E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        :param pulumi.Input[_builtins.str] request_location: Key location in the request.
               Possible values:
               HEADER
               QUERY_STRING
        """
        pulumi.set(__self__, "api_key_secret_version", api_key_secret_version)
        pulumi.set(__self__, "key_name", key_name)
        pulumi.set(__self__, "request_location", request_location)

    @_builtins.property
    @pulumi.getter(name="apiKeySecretVersion")
    def api_key_secret_version(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SecretManager secret version resource storing the API key.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "api_key_secret_version")

    @api_key_secret_version.setter
    def api_key_secret_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key_secret_version", value)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> pulumi.Input[_builtins.str]:
        """
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter(name="requestLocation")
    def request_location(self) -> pulumi.Input[_builtins.str]:
        """
        Key location in the request.
        Possible values:
        HEADER
        QUERY_STRING
        """
        return pulumi.get(self, "request_location")

    @request_location.setter
    def request_location(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "request_location", value)


if not MYPY:
    class ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgsDict(TypedDict):
        token: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional)
        """
elif False:
    ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs:
    def __init__(__self__, *,
                 token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] token: (Optional)
        """
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional)
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgsDict(TypedDict):
        client_id: pulumi.Input[_builtins.str]
        """
        The client ID from the OAuth provider.
        """
        client_secret_version: pulumi.Input[_builtins.str]
        """
        The name of the SecretManager secret version resource storing the
        client secret.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        oauth_grant_type: pulumi.Input[_builtins.str]
        """
        OAuth grant types.
        Possible values:
        CLIENT_CREDENTIAL
        """
        token_endpoint: pulumi.Input[_builtins.str]
        """
        The token endpoint in the OAuth provider to exchange for an access token.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The OAuth scopes to grant.
        """
elif False:
    ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[_builtins.str],
                 client_secret_version: pulumi.Input[_builtins.str],
                 oauth_grant_type: pulumi.Input[_builtins.str],
                 token_endpoint: pulumi.Input[_builtins.str],
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id: The client ID from the OAuth provider.
        :param pulumi.Input[_builtins.str] client_secret_version: The name of the SecretManager secret version resource storing the
               client secret.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param pulumi.Input[_builtins.str] oauth_grant_type: OAuth grant types.
               Possible values:
               CLIENT_CREDENTIAL
        :param pulumi.Input[_builtins.str] token_endpoint: The token endpoint in the OAuth provider to exchange for an access token.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: The OAuth scopes to grant.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_version", client_secret_version)
        pulumi.set(__self__, "oauth_grant_type", oauth_grant_type)
        pulumi.set(__self__, "token_endpoint", token_endpoint)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        """
        The client ID from the OAuth provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretVersion")
    def client_secret_version(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SecretManager secret version resource storing the
        client secret.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "client_secret_version")

    @client_secret_version.setter
    def client_secret_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_secret_version", value)

    @_builtins.property
    @pulumi.getter(name="oauthGrantType")
    def oauth_grant_type(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth grant types.
        Possible values:
        CLIENT_CREDENTIAL
        """
        return pulumi.get(self, "oauth_grant_type")

    @oauth_grant_type.setter
    def oauth_grant_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oauth_grant_type", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The token endpoint in the OAuth provider to exchange for an access token.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The OAuth scopes to grant.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)


if not MYPY:
    class ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgsDict(TypedDict):
        service_account: pulumi.Input[_builtins.str]
        """
        The email address of the service account used for authenticatation. CES
        uses this service account to exchange an access token and the access token
        is then sent in the `Authorization` header of the request.
        The service account must have the
        `roles/iam.serviceAccountTokenCreator` role granted to the
        CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
elif False:
    ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs:
    def __init__(__self__, *,
                 service_account: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] service_account: The email address of the service account used for authenticatation. CES
               uses this service account to exchange an access token and the access token
               is then sent in the `Authorization` header of the request.
               The service account must have the
               `roles/iam.serviceAccountTokenCreator` role granted to the
               CES service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        pulumi.set(__self__, "service_account", service_account)

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> pulumi.Input[_builtins.str]:
        """
        The email address of the service account used for authenticatation. CES
        uses this service account to exchange an access token and the access token
        is then sent in the `Authorization` header of the request.
        The service account must have the
        `roles/iam.serviceAccountTokenCreator` role granted to the
        CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_account", value)


if not MYPY:
    class ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict(TypedDict):
        pass
elif False:
    ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ToolsetOpenApiToolsetServiceDirectoryConfigArgsDict(TypedDict):
        service: pulumi.Input[_builtins.str]
        """
        The name of [Service
        Directory](https://cloud.google.com/service-directory) service.
        Format:
        `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
        Location of the service directory must be the same as the location of the
        app.
        """
elif False:
    ToolsetOpenApiToolsetServiceDirectoryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetServiceDirectoryConfigArgs:
    def __init__(__self__, *,
                 service: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] service: The name of [Service
               Directory](https://cloud.google.com/service-directory) service.
               Format:
               `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
               Location of the service directory must be the same as the location of the
               app.
        """
        pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def service(self) -> pulumi.Input[_builtins.str]:
        """
        The name of [Service
        Directory](https://cloud.google.com/service-directory) service.
        Format:
        `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
        Location of the service directory must be the same as the location of the
        app.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service", value)


if not MYPY:
    class ToolsetOpenApiToolsetTlsConfigArgsDict(TypedDict):
        ca_certs: pulumi.Input[Sequence[pulumi.Input['ToolsetOpenApiToolsetTlsConfigCaCertArgsDict']]]
        """
        Specifies a list of allowed custom CA certificates for HTTPS
        verification.
        Structure is documented below.
        """
elif False:
    ToolsetOpenApiToolsetTlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetTlsConfigArgs:
    def __init__(__self__, *,
                 ca_certs: pulumi.Input[Sequence[pulumi.Input['ToolsetOpenApiToolsetTlsConfigCaCertArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ToolsetOpenApiToolsetTlsConfigCaCertArgs']]] ca_certs: Specifies a list of allowed custom CA certificates for HTTPS
               verification.
               Structure is documented below.
        """
        pulumi.set(__self__, "ca_certs", ca_certs)

    @_builtins.property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> pulumi.Input[Sequence[pulumi.Input['ToolsetOpenApiToolsetTlsConfigCaCertArgs']]]:
        """
        Specifies a list of allowed custom CA certificates for HTTPS
        verification.
        Structure is documented below.
        """
        return pulumi.get(self, "ca_certs")

    @ca_certs.setter
    def ca_certs(self, value: pulumi.Input[Sequence[pulumi.Input['ToolsetOpenApiToolsetTlsConfigCaCertArgs']]]):
        pulumi.set(self, "ca_certs", value)


if not MYPY:
    class ToolsetOpenApiToolsetTlsConfigCaCertArgsDict(TypedDict):
        cert: pulumi.Input[_builtins.str]
        """
        The allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, CES will use Google's default trust
        store to verify certificates. N.B. Make sure the HTTPS server
        certificates are signed with "subject alt name". For instance a
        certificate can be self-signed using the following command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        """
        display_name: pulumi.Input[_builtins.str]
        """
        The name of the allowed custom CA certificates. This
        can be used to disambiguate the custom CA certificates.
        """
elif False:
    ToolsetOpenApiToolsetTlsConfigCaCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetTlsConfigCaCertArgs:
    def __init__(__self__, *,
                 cert: pulumi.Input[_builtins.str],
                 display_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] cert: The allowed custom CA certificates (in DER format) for
               HTTPS verification. This overrides the default SSL trust store. If this
               is empty or unspecified, CES will use Google's default trust
               store to verify certificates. N.B. Make sure the HTTPS server
               certificates are signed with "subject alt name". For instance a
               certificate can be self-signed using the following command,
               openssl x509 -req -days 200 -in example.com.csr \\
               -signkey example.com.key \\
               -out example.com.crt \\
               -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        :param pulumi.Input[_builtins.str] display_name: The name of the allowed custom CA certificates. This
               can be used to disambiguate the custom CA certificates.
        """
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> pulumi.Input[_builtins.str]:
        """
        The allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, CES will use Google's default trust
        store to verify certificates. N.B. Make sure the HTTPS server
        certificates are signed with "subject alt name". For instance a
        certificate can be self-signed using the following command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        """
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cert", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the allowed custom CA certificates. This
        can be used to disambiguate the custom CA certificates.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)


