# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AppAudioProcessingConfigArgs',
    'AppAudioProcessingConfigArgsDict',
    'AppAudioProcessingConfigAmbientSoundConfigArgs',
    'AppAudioProcessingConfigAmbientSoundConfigArgsDict',
    'AppAudioProcessingConfigBargeInConfigArgs',
    'AppAudioProcessingConfigBargeInConfigArgsDict',
    'AppAudioProcessingConfigSynthesizeSpeechConfigArgs',
    'AppAudioProcessingConfigSynthesizeSpeechConfigArgsDict',
    'AppDataStoreSettingsArgs',
    'AppDataStoreSettingsArgsDict',
    'AppDataStoreSettingsEngineArgs',
    'AppDataStoreSettingsEngineArgsDict',
    'AppDefaultChannelProfileArgs',
    'AppDefaultChannelProfileArgsDict',
    'AppDefaultChannelProfilePersonaPropertyArgs',
    'AppDefaultChannelProfilePersonaPropertyArgsDict',
    'AppDefaultChannelProfileWebWidgetConfigArgs',
    'AppDefaultChannelProfileWebWidgetConfigArgsDict',
    'AppEvaluationMetricsThresholdsArgs',
    'AppEvaluationMetricsThresholdsArgsDict',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgs',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgsDict',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgs',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgsDict',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgs',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgsDict',
    'AppLanguageSettingsArgs',
    'AppLanguageSettingsArgsDict',
    'AppLoggingSettingsArgs',
    'AppLoggingSettingsArgsDict',
    'AppLoggingSettingsAudioRecordingConfigArgs',
    'AppLoggingSettingsAudioRecordingConfigArgsDict',
    'AppLoggingSettingsBigqueryExportSettingsArgs',
    'AppLoggingSettingsBigqueryExportSettingsArgsDict',
    'AppLoggingSettingsCloudLoggingSettingsArgs',
    'AppLoggingSettingsCloudLoggingSettingsArgsDict',
    'AppLoggingSettingsConversationLoggingSettingsArgs',
    'AppLoggingSettingsConversationLoggingSettingsArgsDict',
    'AppLoggingSettingsRedactionConfigArgs',
    'AppLoggingSettingsRedactionConfigArgsDict',
    'AppModelSettingsArgs',
    'AppModelSettingsArgsDict',
    'AppTimeZoneSettingsArgs',
    'AppTimeZoneSettingsArgsDict',
    'AppVariableDeclarationArgs',
    'AppVariableDeclarationArgsDict',
    'AppVariableDeclarationSchemaArgs',
    'AppVariableDeclarationSchemaArgsDict',
    'DeploymentChannelProfileArgs',
    'DeploymentChannelProfileArgsDict',
    'DeploymentChannelProfilePersonaPropertyArgs',
    'DeploymentChannelProfilePersonaPropertyArgsDict',
    'DeploymentChannelProfileWebWidgetConfigArgs',
    'DeploymentChannelProfileWebWidgetConfigArgsDict',
    'ExampleMessageArgs',
    'ExampleMessageArgsDict',
    'ExampleMessageChunkArgs',
    'ExampleMessageChunkArgsDict',
    'ExampleMessageChunkImageArgs',
    'ExampleMessageChunkImageArgsDict',
    'ToolsetOpenApiToolsetArgs',
    'ToolsetOpenApiToolsetArgsDict',
    'ToolsetOpenApiToolsetApiAuthenticationArgs',
    'ToolsetOpenApiToolsetApiAuthenticationArgsDict',
    'ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs',
    'ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgsDict',
    'ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs',
    'ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgsDict',
    'ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs',
    'ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgsDict',
    'ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs',
    'ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict',
    'ToolsetOpenApiToolsetServiceDirectoryConfigArgs',
    'ToolsetOpenApiToolsetServiceDirectoryConfigArgsDict',
    'ToolsetOpenApiToolsetTlsConfigArgs',
    'ToolsetOpenApiToolsetTlsConfigArgsDict',
    'ToolsetOpenApiToolsetTlsConfigCaCertArgs',
    'ToolsetOpenApiToolsetTlsConfigCaCertArgsDict',
]

MYPY = False

if not MYPY:
    class AppAudioProcessingConfigArgsDict(TypedDict):
        ambient_sound_config: NotRequired[pulumi.Input['AppAudioProcessingConfigAmbientSoundConfigArgsDict']]
        """
        Configuration for the ambient sound to be played with the synthesized agent
        response, to enhance the naturalness of the conversation.
        Structure is documented below.
        """
        barge_in_config: NotRequired[pulumi.Input['AppAudioProcessingConfigBargeInConfigArgsDict']]
        """
        Configuration for how the user barge-in activities should be handled.
        Structure is documented below.
        """
        inactivity_timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        The duration of user inactivity (no speech or interaction) before the agent
        prompts the user for reengagement. If not set, the agent will not prompt
        the user for reengagement.
        """
        synthesize_speech_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppAudioProcessingConfigSynthesizeSpeechConfigArgsDict']]]]
        """
        Configuration of how the agent response should be synthesized, mapping from
        the language code to SynthesizeSpeechConfig.
        If the configuration for the specified language code is not found, the
        configuration for the root language code will be used. For example, if the
        map contains "en-us" and "en", and the specified language code is "en-gb",
        then "en" configuration will be used.
        Note: Language code is case-insensitive.
        Structure is documented below.
        """
elif False:
    AppAudioProcessingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppAudioProcessingConfigArgs:
    def __init__(__self__, *,
                 ambient_sound_config: Optional[pulumi.Input['AppAudioProcessingConfigAmbientSoundConfigArgs']] = None,
                 barge_in_config: Optional[pulumi.Input['AppAudioProcessingConfigBargeInConfigArgs']] = None,
                 inactivity_timeout: Optional[pulumi.Input[_builtins.str]] = None,
                 synthesize_speech_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppAudioProcessingConfigSynthesizeSpeechConfigArgs']]]] = None):
        """
        :param pulumi.Input['AppAudioProcessingConfigAmbientSoundConfigArgs'] ambient_sound_config: Configuration for the ambient sound to be played with the synthesized agent
               response, to enhance the naturalness of the conversation.
               Structure is documented below.
        :param pulumi.Input['AppAudioProcessingConfigBargeInConfigArgs'] barge_in_config: Configuration for how the user barge-in activities should be handled.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] inactivity_timeout: The duration of user inactivity (no speech or interaction) before the agent
               prompts the user for reengagement. If not set, the agent will not prompt
               the user for reengagement.
        :param pulumi.Input[Sequence[pulumi.Input['AppAudioProcessingConfigSynthesizeSpeechConfigArgs']]] synthesize_speech_configs: Configuration of how the agent response should be synthesized, mapping from
               the language code to SynthesizeSpeechConfig.
               If the configuration for the specified language code is not found, the
               configuration for the root language code will be used. For example, if the
               map contains "en-us" and "en", and the specified language code is "en-gb",
               then "en" configuration will be used.
               Note: Language code is case-insensitive.
               Structure is documented below.
        """
        if ambient_sound_config is not None:
            pulumi.set(__self__, "ambient_sound_config", ambient_sound_config)
        if barge_in_config is not None:
            pulumi.set(__self__, "barge_in_config", barge_in_config)
        if inactivity_timeout is not None:
            pulumi.set(__self__, "inactivity_timeout", inactivity_timeout)
        if synthesize_speech_configs is not None:
            pulumi.set(__self__, "synthesize_speech_configs", synthesize_speech_configs)

    @_builtins.property
    @pulumi.getter(name="ambientSoundConfig")
    def ambient_sound_config(self) -> Optional[pulumi.Input['AppAudioProcessingConfigAmbientSoundConfigArgs']]:
        """
        Configuration for the ambient sound to be played with the synthesized agent
        response, to enhance the naturalness of the conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "ambient_sound_config")

    @ambient_sound_config.setter
    def ambient_sound_config(self, value: Optional[pulumi.Input['AppAudioProcessingConfigAmbientSoundConfigArgs']]):
        pulumi.set(self, "ambient_sound_config", value)

    @_builtins.property
    @pulumi.getter(name="bargeInConfig")
    def barge_in_config(self) -> Optional[pulumi.Input['AppAudioProcessingConfigBargeInConfigArgs']]:
        """
        Configuration for how the user barge-in activities should be handled.
        Structure is documented below.
        """
        return pulumi.get(self, "barge_in_config")

    @barge_in_config.setter
    def barge_in_config(self, value: Optional[pulumi.Input['AppAudioProcessingConfigBargeInConfigArgs']]):
        pulumi.set(self, "barge_in_config", value)

    @_builtins.property
    @pulumi.getter(name="inactivityTimeout")
    def inactivity_timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The duration of user inactivity (no speech or interaction) before the agent
        prompts the user for reengagement. If not set, the agent will not prompt
        the user for reengagement.
        """
        return pulumi.get(self, "inactivity_timeout")

    @inactivity_timeout.setter
    def inactivity_timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inactivity_timeout", value)

    @_builtins.property
    @pulumi.getter(name="synthesizeSpeechConfigs")
    def synthesize_speech_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppAudioProcessingConfigSynthesizeSpeechConfigArgs']]]]:
        """
        Configuration of how the agent response should be synthesized, mapping from
        the language code to SynthesizeSpeechConfig.
        If the configuration for the specified language code is not found, the
        configuration for the root language code will be used. For example, if the
        map contains "en-us" and "en", and the specified language code is "en-gb",
        then "en" configuration will be used.
        Note: Language code is case-insensitive.
        Structure is documented below.
        """
        return pulumi.get(self, "synthesize_speech_configs")

    @synthesize_speech_configs.setter
    def synthesize_speech_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppAudioProcessingConfigSynthesizeSpeechConfigArgs']]]]):
        pulumi.set(self, "synthesize_speech_configs", value)


if not MYPY:
    class AppAudioProcessingConfigAmbientSoundConfigArgsDict(TypedDict):
        gcs_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ambient noise as a mono-channel, 16kHz WAV file stored in [Cloud
        Storage](https://cloud.google.com/storage).
        Note: Please make sure the CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com` has
        `storage.objects.get` permission to the Cloud Storage object.
        """
        prebuilt_ambient_sound: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the prebuilt ambient sound.
        Valid values are: - "coffee_shop" - "keyboard" - "keypad" - "hum"
        -"office_1" - "office_2" - "office_3"
        -"room_1" - "room_2" - "room_3"
        -"room_4" - "room_5" - "air_conditioner"
        """
        volume_gain_db: NotRequired[pulumi.Input[_builtins.float]]
        """
        Volume gain (in dB) of the normal native volume supported by
        ambient noise, in the range [-96.0, 16.0]. If unset, or set to a value of
        0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
        will play at approximately half the amplitude of the normal native signal
        amplitude. A value of +6.0 (dB) will play at approximately twice the
        amplitude of the normal native signal amplitude. We strongly recommend not
        to exceed +10 (dB) as there's usually no effective increase in loudness for
        any value greater than that.
        """
elif False:
    AppAudioProcessingConfigAmbientSoundConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppAudioProcessingConfigAmbientSoundConfigArgs:
    def __init__(__self__, *,
                 gcs_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 prebuilt_ambient_sound: Optional[pulumi.Input[_builtins.str]] = None,
                 volume_gain_db: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] gcs_uri: Ambient noise as a mono-channel, 16kHz WAV file stored in [Cloud
               Storage](https://cloud.google.com/storage).
               Note: Please make sure the CES service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com` has
               `storage.objects.get` permission to the Cloud Storage object.
        :param pulumi.Input[_builtins.str] prebuilt_ambient_sound: Name of the prebuilt ambient sound.
               Valid values are: - "coffee_shop" - "keyboard" - "keypad" - "hum"
               -"office_1" - "office_2" - "office_3"
               -"room_1" - "room_2" - "room_3"
               -"room_4" - "room_5" - "air_conditioner"
        :param pulumi.Input[_builtins.float] volume_gain_db: Volume gain (in dB) of the normal native volume supported by
               ambient noise, in the range [-96.0, 16.0]. If unset, or set to a value of
               0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
               will play at approximately half the amplitude of the normal native signal
               amplitude. A value of +6.0 (dB) will play at approximately twice the
               amplitude of the normal native signal amplitude. We strongly recommend not
               to exceed +10 (dB) as there's usually no effective increase in loudness for
               any value greater than that.
        """
        if gcs_uri is not None:
            pulumi.set(__self__, "gcs_uri", gcs_uri)
        if prebuilt_ambient_sound is not None:
            pulumi.set(__self__, "prebuilt_ambient_sound", prebuilt_ambient_sound)
        if volume_gain_db is not None:
            pulumi.set(__self__, "volume_gain_db", volume_gain_db)

    @_builtins.property
    @pulumi.getter(name="gcsUri")
    def gcs_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ambient noise as a mono-channel, 16kHz WAV file stored in [Cloud
        Storage](https://cloud.google.com/storage).
        Note: Please make sure the CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com` has
        `storage.objects.get` permission to the Cloud Storage object.
        """
        return pulumi.get(self, "gcs_uri")

    @gcs_uri.setter
    def gcs_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gcs_uri", value)

    @_builtins.property
    @pulumi.getter(name="prebuiltAmbientSound")
    def prebuilt_ambient_sound(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the prebuilt ambient sound.
        Valid values are: - "coffee_shop" - "keyboard" - "keypad" - "hum"
        -"office_1" - "office_2" - "office_3"
        -"room_1" - "room_2" - "room_3"
        -"room_4" - "room_5" - "air_conditioner"
        """
        return pulumi.get(self, "prebuilt_ambient_sound")

    @prebuilt_ambient_sound.setter
    def prebuilt_ambient_sound(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prebuilt_ambient_sound", value)

    @_builtins.property
    @pulumi.getter(name="volumeGainDb")
    def volume_gain_db(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Volume gain (in dB) of the normal native volume supported by
        ambient noise, in the range [-96.0, 16.0]. If unset, or set to a value of
        0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
        will play at approximately half the amplitude of the normal native signal
        amplitude. A value of +6.0 (dB) will play at approximately twice the
        amplitude of the normal native signal amplitude. We strongly recommend not
        to exceed +10 (dB) as there's usually no effective increase in loudness for
        any value greater than that.
        """
        return pulumi.get(self, "volume_gain_db")

    @volume_gain_db.setter
    def volume_gain_db(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "volume_gain_db", value)


if not MYPY:
    class AppAudioProcessingConfigBargeInConfigArgsDict(TypedDict):
        barge_in_awareness: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If enabled, the agent will adapt its next response based on the assumption
        that the user hasn't heard the full preceding agent message.
        This should not be used in scenarios where agent responses are displayed
        visually.
        """
elif False:
    AppAudioProcessingConfigBargeInConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppAudioProcessingConfigBargeInConfigArgs:
    def __init__(__self__, *,
                 barge_in_awareness: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] barge_in_awareness: If enabled, the agent will adapt its next response based on the assumption
               that the user hasn't heard the full preceding agent message.
               This should not be used in scenarios where agent responses are displayed
               visually.
        """
        if barge_in_awareness is not None:
            pulumi.set(__self__, "barge_in_awareness", barge_in_awareness)

    @_builtins.property
    @pulumi.getter(name="bargeInAwareness")
    def barge_in_awareness(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If enabled, the agent will adapt its next response based on the assumption
        that the user hasn't heard the full preceding agent message.
        This should not be used in scenarios where agent responses are displayed
        visually.
        """
        return pulumi.get(self, "barge_in_awareness")

    @barge_in_awareness.setter
    def barge_in_awareness(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "barge_in_awareness", value)


if not MYPY:
    class AppAudioProcessingConfigSynthesizeSpeechConfigArgsDict(TypedDict):
        language_code: pulumi.Input[_builtins.str]
        """
        The identifier for this object. Format specified above.
        """
        speaking_rate: NotRequired[pulumi.Input[_builtins.float]]
        """
        The speaking rate/speed in the range [0.25, 2.0]. 1.0 is the normal native
        speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is
        half as fast. Values outside of the range [0.25, 2.0] will return an error.
        """
        voice: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the voice. If not set, the service will choose a
        voice based on the other parameters such as language_code.
        For the list of available voices, please refer to Supported voices and
        languages from Cloud Text-to-Speech.
        """
elif False:
    AppAudioProcessingConfigSynthesizeSpeechConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppAudioProcessingConfigSynthesizeSpeechConfigArgs:
    def __init__(__self__, *,
                 language_code: pulumi.Input[_builtins.str],
                 speaking_rate: Optional[pulumi.Input[_builtins.float]] = None,
                 voice: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] language_code: The identifier for this object. Format specified above.
        :param pulumi.Input[_builtins.float] speaking_rate: The speaking rate/speed in the range [0.25, 2.0]. 1.0 is the normal native
               speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is
               half as fast. Values outside of the range [0.25, 2.0] will return an error.
        :param pulumi.Input[_builtins.str] voice: The name of the voice. If not set, the service will choose a
               voice based on the other parameters such as language_code.
               For the list of available voices, please refer to Supported voices and
               languages from Cloud Text-to-Speech.
        """
        pulumi.set(__self__, "language_code", language_code)
        if speaking_rate is not None:
            pulumi.set(__self__, "speaking_rate", speaking_rate)
        if voice is not None:
            pulumi.set(__self__, "voice", voice)

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "language_code", value)

    @_builtins.property
    @pulumi.getter(name="speakingRate")
    def speaking_rate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The speaking rate/speed in the range [0.25, 2.0]. 1.0 is the normal native
        speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is
        half as fast. Values outside of the range [0.25, 2.0] will return an error.
        """
        return pulumi.get(self, "speaking_rate")

    @speaking_rate.setter
    def speaking_rate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "speaking_rate", value)

    @_builtins.property
    @pulumi.getter
    def voice(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the voice. If not set, the service will choose a
        voice based on the other parameters such as language_code.
        For the list of available voices, please refer to Supported voices and
        languages from Cloud Text-to-Speech.
        """
        return pulumi.get(self, "voice")

    @voice.setter
    def voice(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "voice", value)


if not MYPY:
    class AppDataStoreSettingsArgsDict(TypedDict):
        engines: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppDataStoreSettingsEngineArgsDict']]]]
        """
        (Output)
        The engines for the app.
        Structure is documented below.


        <a name="nested_data_store_settings_engines"></a>The `engines` block contains:
        """
elif False:
    AppDataStoreSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppDataStoreSettingsArgs:
    def __init__(__self__, *,
                 engines: Optional[pulumi.Input[Sequence[pulumi.Input['AppDataStoreSettingsEngineArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppDataStoreSettingsEngineArgs']]] engines: (Output)
               The engines for the app.
               Structure is documented below.
               
               
               <a name="nested_data_store_settings_engines"></a>The `engines` block contains:
        """
        if engines is not None:
            pulumi.set(__self__, "engines", engines)

    @_builtins.property
    @pulumi.getter
    def engines(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppDataStoreSettingsEngineArgs']]]]:
        """
        (Output)
        The engines for the app.
        Structure is documented below.


        <a name="nested_data_store_settings_engines"></a>The `engines` block contains:
        """
        return pulumi.get(self, "engines")

    @engines.setter
    def engines(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppDataStoreSettingsEngineArgs']]]]):
        pulumi.set(self, "engines", value)


if not MYPY:
    class AppDataStoreSettingsEngineArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier. The unique identifier of the app.
        Format: `projects/{project}/locations/{location}/apps/{app}`
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the engine.
        Possible values:
        ENGINE_TYPE_SEARCH
        ENGINE_TYPE_CHAT
        """
elif False:
    AppDataStoreSettingsEngineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppDataStoreSettingsEngineArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Identifier. The unique identifier of the app.
               Format: `projects/{project}/locations/{location}/apps/{app}`
        :param pulumi.Input[_builtins.str] type: The type of the engine.
               Possible values:
               ENGINE_TYPE_SEARCH
               ENGINE_TYPE_CHAT
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier. The unique identifier of the app.
        Format: `projects/{project}/locations/{location}/apps/{app}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the engine.
        Possible values:
        ENGINE_TYPE_SEARCH
        ENGINE_TYPE_CHAT
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AppDefaultChannelProfileArgsDict(TypedDict):
        channel_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the channel profile.
        Possible values:
        UNKNOWN
        WEB_UI
        API
        TWILIO
        GOOGLE_TELEPHONY_PLATFORM
        CONTACT_CENTER_AS_A_SERVICE
        """
        disable_barge_in_control: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable user barge-in in the conversation.
        - true: User interruptions are disabled while the agent is speaking.
        - false: The agent retains automatic control over when the user can interrupt.
        """
        disable_dtmf: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable DTMF (dual-tone multi-frequency).
        """
        persona_property: NotRequired[pulumi.Input['AppDefaultChannelProfilePersonaPropertyArgsDict']]
        """
        Represents the persona property of a channel.
        Structure is documented below.
        """
        profile_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier of the channel profile.
        """
        web_widget_config: NotRequired[pulumi.Input['AppDefaultChannelProfileWebWidgetConfigArgsDict']]
        """
        Message for configuration for the web widget.
        Structure is documented below.
        """
elif False:
    AppDefaultChannelProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppDefaultChannelProfileArgs:
    def __init__(__self__, *,
                 channel_type: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_barge_in_control: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_dtmf: Optional[pulumi.Input[_builtins.bool]] = None,
                 persona_property: Optional[pulumi.Input['AppDefaultChannelProfilePersonaPropertyArgs']] = None,
                 profile_id: Optional[pulumi.Input[_builtins.str]] = None,
                 web_widget_config: Optional[pulumi.Input['AppDefaultChannelProfileWebWidgetConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] channel_type: The type of the channel profile.
               Possible values:
               UNKNOWN
               WEB_UI
               API
               TWILIO
               GOOGLE_TELEPHONY_PLATFORM
               CONTACT_CENTER_AS_A_SERVICE
        :param pulumi.Input[_builtins.bool] disable_barge_in_control: Whether to disable user barge-in in the conversation.
               - true: User interruptions are disabled while the agent is speaking.
               - false: The agent retains automatic control over when the user can interrupt.
        :param pulumi.Input[_builtins.bool] disable_dtmf: Whether to disable DTMF (dual-tone multi-frequency).
        :param pulumi.Input['AppDefaultChannelProfilePersonaPropertyArgs'] persona_property: Represents the persona property of a channel.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] profile_id: The unique identifier of the channel profile.
        :param pulumi.Input['AppDefaultChannelProfileWebWidgetConfigArgs'] web_widget_config: Message for configuration for the web widget.
               Structure is documented below.
        """
        if channel_type is not None:
            pulumi.set(__self__, "channel_type", channel_type)
        if disable_barge_in_control is not None:
            pulumi.set(__self__, "disable_barge_in_control", disable_barge_in_control)
        if disable_dtmf is not None:
            pulumi.set(__self__, "disable_dtmf", disable_dtmf)
        if persona_property is not None:
            pulumi.set(__self__, "persona_property", persona_property)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if web_widget_config is not None:
            pulumi.set(__self__, "web_widget_config", web_widget_config)

    @_builtins.property
    @pulumi.getter(name="channelType")
    def channel_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the channel profile.
        Possible values:
        UNKNOWN
        WEB_UI
        API
        TWILIO
        GOOGLE_TELEPHONY_PLATFORM
        CONTACT_CENTER_AS_A_SERVICE
        """
        return pulumi.get(self, "channel_type")

    @channel_type.setter
    def channel_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel_type", value)

    @_builtins.property
    @pulumi.getter(name="disableBargeInControl")
    def disable_barge_in_control(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable user barge-in in the conversation.
        - true: User interruptions are disabled while the agent is speaking.
        - false: The agent retains automatic control over when the user can interrupt.
        """
        return pulumi.get(self, "disable_barge_in_control")

    @disable_barge_in_control.setter
    def disable_barge_in_control(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_barge_in_control", value)

    @_builtins.property
    @pulumi.getter(name="disableDtmf")
    def disable_dtmf(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable DTMF (dual-tone multi-frequency).
        """
        return pulumi.get(self, "disable_dtmf")

    @disable_dtmf.setter
    def disable_dtmf(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_dtmf", value)

    @_builtins.property
    @pulumi.getter(name="personaProperty")
    def persona_property(self) -> Optional[pulumi.Input['AppDefaultChannelProfilePersonaPropertyArgs']]:
        """
        Represents the persona property of a channel.
        Structure is documented below.
        """
        return pulumi.get(self, "persona_property")

    @persona_property.setter
    def persona_property(self, value: Optional[pulumi.Input['AppDefaultChannelProfilePersonaPropertyArgs']]):
        pulumi.set(self, "persona_property", value)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier of the channel profile.
        """
        return pulumi.get(self, "profile_id")

    @profile_id.setter
    def profile_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile_id", value)

    @_builtins.property
    @pulumi.getter(name="webWidgetConfig")
    def web_widget_config(self) -> Optional[pulumi.Input['AppDefaultChannelProfileWebWidgetConfigArgs']]:
        """
        Message for configuration for the web widget.
        Structure is documented below.
        """
        return pulumi.get(self, "web_widget_config")

    @web_widget_config.setter
    def web_widget_config(self, value: Optional[pulumi.Input['AppDefaultChannelProfileWebWidgetConfigArgs']]):
        pulumi.set(self, "web_widget_config", value)


if not MYPY:
    class AppDefaultChannelProfilePersonaPropertyArgsDict(TypedDict):
        persona: NotRequired[pulumi.Input[_builtins.str]]
        """
        The persona of the channel.
        Possible values:
        UNKNOWN
        CONCISE
        CHATTY
        """
elif False:
    AppDefaultChannelProfilePersonaPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppDefaultChannelProfilePersonaPropertyArgs:
    def __init__(__self__, *,
                 persona: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] persona: The persona of the channel.
               Possible values:
               UNKNOWN
               CONCISE
               CHATTY
        """
        if persona is not None:
            pulumi.set(__self__, "persona", persona)

    @_builtins.property
    @pulumi.getter
    def persona(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The persona of the channel.
        Possible values:
        UNKNOWN
        CONCISE
        CHATTY
        """
        return pulumi.get(self, "persona")

    @persona.setter
    def persona(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "persona", value)


if not MYPY:
    class AppDefaultChannelProfileWebWidgetConfigArgsDict(TypedDict):
        modality: NotRequired[pulumi.Input[_builtins.str]]
        """
        The modality of the web widget.
        Possible values:
        UNKNOWN_MODALITY
        CHAT_AND_VOICE
        VOICE_ONLY
        CHAT_ONLY
        """
        theme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The theme of the web widget.
        Possible values:
        UNKNOWN_THEME
        LIGHT
        DARK
        """
        web_widget_title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The title of the web widget.
        """
elif False:
    AppDefaultChannelProfileWebWidgetConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppDefaultChannelProfileWebWidgetConfigArgs:
    def __init__(__self__, *,
                 modality: Optional[pulumi.Input[_builtins.str]] = None,
                 theme: Optional[pulumi.Input[_builtins.str]] = None,
                 web_widget_title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] modality: The modality of the web widget.
               Possible values:
               UNKNOWN_MODALITY
               CHAT_AND_VOICE
               VOICE_ONLY
               CHAT_ONLY
        :param pulumi.Input[_builtins.str] theme: The theme of the web widget.
               Possible values:
               UNKNOWN_THEME
               LIGHT
               DARK
        :param pulumi.Input[_builtins.str] web_widget_title: The title of the web widget.
        """
        if modality is not None:
            pulumi.set(__self__, "modality", modality)
        if theme is not None:
            pulumi.set(__self__, "theme", theme)
        if web_widget_title is not None:
            pulumi.set(__self__, "web_widget_title", web_widget_title)

    @_builtins.property
    @pulumi.getter
    def modality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The modality of the web widget.
        Possible values:
        UNKNOWN_MODALITY
        CHAT_AND_VOICE
        VOICE_ONLY
        CHAT_ONLY
        """
        return pulumi.get(self, "modality")

    @modality.setter
    def modality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "modality", value)

    @_builtins.property
    @pulumi.getter
    def theme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The theme of the web widget.
        Possible values:
        UNKNOWN_THEME
        LIGHT
        DARK
        """
        return pulumi.get(self, "theme")

    @theme.setter
    def theme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "theme", value)

    @_builtins.property
    @pulumi.getter(name="webWidgetTitle")
    def web_widget_title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The title of the web widget.
        """
        return pulumi.get(self, "web_widget_title")

    @web_widget_title.setter
    def web_widget_title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_widget_title", value)


if not MYPY:
    class AppEvaluationMetricsThresholdsArgsDict(TypedDict):
        golden_evaluation_metrics_thresholds: NotRequired[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgsDict']]
        """
        Settings for golden evaluations.
        Structure is documented below.
        """
elif False:
    AppEvaluationMetricsThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppEvaluationMetricsThresholdsArgs:
    def __init__(__self__, *,
                 golden_evaluation_metrics_thresholds: Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgs']] = None):
        """
        :param pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgs'] golden_evaluation_metrics_thresholds: Settings for golden evaluations.
               Structure is documented below.
        """
        if golden_evaluation_metrics_thresholds is not None:
            pulumi.set(__self__, "golden_evaluation_metrics_thresholds", golden_evaluation_metrics_thresholds)

    @_builtins.property
    @pulumi.getter(name="goldenEvaluationMetricsThresholds")
    def golden_evaluation_metrics_thresholds(self) -> Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgs']]:
        """
        Settings for golden evaluations.
        Structure is documented below.
        """
        return pulumi.get(self, "golden_evaluation_metrics_thresholds")

    @golden_evaluation_metrics_thresholds.setter
    def golden_evaluation_metrics_thresholds(self, value: Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgs']]):
        pulumi.set(self, "golden_evaluation_metrics_thresholds", value)


if not MYPY:
    class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgsDict(TypedDict):
        expectation_level_metrics_thresholds: NotRequired[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgsDict']]
        """
        Expectation level metrics thresholds.
        Structure is documented below.
        """
        turn_level_metrics_thresholds: NotRequired[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgsDict']]
        """
        Turn level metrics thresholds.
        Structure is documented below.
        """
elif False:
    AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgs:
    def __init__(__self__, *,
                 expectation_level_metrics_thresholds: Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgs']] = None,
                 turn_level_metrics_thresholds: Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgs']] = None):
        """
        :param pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgs'] expectation_level_metrics_thresholds: Expectation level metrics thresholds.
               Structure is documented below.
        :param pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgs'] turn_level_metrics_thresholds: Turn level metrics thresholds.
               Structure is documented below.
        """
        if expectation_level_metrics_thresholds is not None:
            pulumi.set(__self__, "expectation_level_metrics_thresholds", expectation_level_metrics_thresholds)
        if turn_level_metrics_thresholds is not None:
            pulumi.set(__self__, "turn_level_metrics_thresholds", turn_level_metrics_thresholds)

    @_builtins.property
    @pulumi.getter(name="expectationLevelMetricsThresholds")
    def expectation_level_metrics_thresholds(self) -> Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgs']]:
        """
        Expectation level metrics thresholds.
        Structure is documented below.
        """
        return pulumi.get(self, "expectation_level_metrics_thresholds")

    @expectation_level_metrics_thresholds.setter
    def expectation_level_metrics_thresholds(self, value: Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgs']]):
        pulumi.set(self, "expectation_level_metrics_thresholds", value)

    @_builtins.property
    @pulumi.getter(name="turnLevelMetricsThresholds")
    def turn_level_metrics_thresholds(self) -> Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgs']]:
        """
        Turn level metrics thresholds.
        Structure is documented below.
        """
        return pulumi.get(self, "turn_level_metrics_thresholds")

    @turn_level_metrics_thresholds.setter
    def turn_level_metrics_thresholds(self, value: Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgs']]):
        pulumi.set(self, "turn_level_metrics_thresholds", value)


if not MYPY:
    class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgsDict(TypedDict):
        tool_invocation_parameter_correctness_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        The success threshold for individual tool invocation parameter
        correctness. Must be a float between 0 and 1. Default is 1.0.
        """
elif False:
    AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgs:
    def __init__(__self__, *,
                 tool_invocation_parameter_correctness_threshold: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] tool_invocation_parameter_correctness_threshold: The success threshold for individual tool invocation parameter
               correctness. Must be a float between 0 and 1. Default is 1.0.
        """
        if tool_invocation_parameter_correctness_threshold is not None:
            pulumi.set(__self__, "tool_invocation_parameter_correctness_threshold", tool_invocation_parameter_correctness_threshold)

    @_builtins.property
    @pulumi.getter(name="toolInvocationParameterCorrectnessThreshold")
    def tool_invocation_parameter_correctness_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The success threshold for individual tool invocation parameter
        correctness. Must be a float between 0 and 1. Default is 1.0.
        """
        return pulumi.get(self, "tool_invocation_parameter_correctness_threshold")

    @tool_invocation_parameter_correctness_threshold.setter
    def tool_invocation_parameter_correctness_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "tool_invocation_parameter_correctness_threshold", value)


if not MYPY:
    class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgsDict(TypedDict):
        overall_tool_invocation_correctness_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        The success threshold for overall tool invocation correctness. Must be
        a float between 0 and 1. Default is 1.0.
        """
        semantic_similarity_success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The success threshold for semantic similarity. Must be an integer
        between 0 and 4. Default is >= 3.
        """
elif False:
    AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgs:
    def __init__(__self__, *,
                 overall_tool_invocation_correctness_threshold: Optional[pulumi.Input[_builtins.float]] = None,
                 semantic_similarity_success_threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.float] overall_tool_invocation_correctness_threshold: The success threshold for overall tool invocation correctness. Must be
               a float between 0 and 1. Default is 1.0.
        :param pulumi.Input[_builtins.int] semantic_similarity_success_threshold: The success threshold for semantic similarity. Must be an integer
               between 0 and 4. Default is >= 3.
        """
        if overall_tool_invocation_correctness_threshold is not None:
            pulumi.set(__self__, "overall_tool_invocation_correctness_threshold", overall_tool_invocation_correctness_threshold)
        if semantic_similarity_success_threshold is not None:
            pulumi.set(__self__, "semantic_similarity_success_threshold", semantic_similarity_success_threshold)

    @_builtins.property
    @pulumi.getter(name="overallToolInvocationCorrectnessThreshold")
    def overall_tool_invocation_correctness_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The success threshold for overall tool invocation correctness. Must be
        a float between 0 and 1. Default is 1.0.
        """
        return pulumi.get(self, "overall_tool_invocation_correctness_threshold")

    @overall_tool_invocation_correctness_threshold.setter
    def overall_tool_invocation_correctness_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "overall_tool_invocation_correctness_threshold", value)

    @_builtins.property
    @pulumi.getter(name="semanticSimilaritySuccessThreshold")
    def semantic_similarity_success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The success threshold for semantic similarity. Must be an integer
        between 0 and 4. Default is >= 3.
        """
        return pulumi.get(self, "semantic_similarity_success_threshold")

    @semantic_similarity_success_threshold.setter
    def semantic_similarity_success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "semantic_similarity_success_threshold", value)


if not MYPY:
    class AppLanguageSettingsArgsDict(TypedDict):
        default_language_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default language code of the app.
        """
        enable_multilingual_support: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables multilingual support. If true, agents in the app will use pre-built
        instructions to improve handling of multilingual input.
        """
        fallback_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        The action to perform when an agent receives input in an unsupported
        language.
        This can be a predefined action or a custom tool call.
        Valid values are:
        - A tool's full resource name, which triggers a specific tool execution.
        - A predefined system action, such as "escalate" or "exit", which triggers
        an EndSession signal with corresponding metadata
        to terminate the conversation.
        """
        supported_language_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of languages codes supported by the app, in addition to the
        `default_language_code`.
        """
elif False:
    AppLanguageSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLanguageSettingsArgs:
    def __init__(__self__, *,
                 default_language_code: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_multilingual_support: Optional[pulumi.Input[_builtins.bool]] = None,
                 fallback_action: Optional[pulumi.Input[_builtins.str]] = None,
                 supported_language_codes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] default_language_code: The default language code of the app.
        :param pulumi.Input[_builtins.bool] enable_multilingual_support: Enables multilingual support. If true, agents in the app will use pre-built
               instructions to improve handling of multilingual input.
        :param pulumi.Input[_builtins.str] fallback_action: The action to perform when an agent receives input in an unsupported
               language.
               This can be a predefined action or a custom tool call.
               Valid values are:
               - A tool's full resource name, which triggers a specific tool execution.
               - A predefined system action, such as "escalate" or "exit", which triggers
               an EndSession signal with corresponding metadata
               to terminate the conversation.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] supported_language_codes: List of languages codes supported by the app, in addition to the
               `default_language_code`.
        """
        if default_language_code is not None:
            pulumi.set(__self__, "default_language_code", default_language_code)
        if enable_multilingual_support is not None:
            pulumi.set(__self__, "enable_multilingual_support", enable_multilingual_support)
        if fallback_action is not None:
            pulumi.set(__self__, "fallback_action", fallback_action)
        if supported_language_codes is not None:
            pulumi.set(__self__, "supported_language_codes", supported_language_codes)

    @_builtins.property
    @pulumi.getter(name="defaultLanguageCode")
    def default_language_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default language code of the app.
        """
        return pulumi.get(self, "default_language_code")

    @default_language_code.setter
    def default_language_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_language_code", value)

    @_builtins.property
    @pulumi.getter(name="enableMultilingualSupport")
    def enable_multilingual_support(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables multilingual support. If true, agents in the app will use pre-built
        instructions to improve handling of multilingual input.
        """
        return pulumi.get(self, "enable_multilingual_support")

    @enable_multilingual_support.setter
    def enable_multilingual_support(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_multilingual_support", value)

    @_builtins.property
    @pulumi.getter(name="fallbackAction")
    def fallback_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The action to perform when an agent receives input in an unsupported
        language.
        This can be a predefined action or a custom tool call.
        Valid values are:
        - A tool's full resource name, which triggers a specific tool execution.
        - A predefined system action, such as "escalate" or "exit", which triggers
        an EndSession signal with corresponding metadata
        to terminate the conversation.
        """
        return pulumi.get(self, "fallback_action")

    @fallback_action.setter
    def fallback_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_action", value)

    @_builtins.property
    @pulumi.getter(name="supportedLanguageCodes")
    def supported_language_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of languages codes supported by the app, in addition to the
        `default_language_code`.
        """
        return pulumi.get(self, "supported_language_codes")

    @supported_language_codes.setter
    def supported_language_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "supported_language_codes", value)


if not MYPY:
    class AppLoggingSettingsArgsDict(TypedDict):
        audio_recording_config: NotRequired[pulumi.Input['AppLoggingSettingsAudioRecordingConfigArgsDict']]
        """
        Configuration for how the audio interactions should be recorded.
        Structure is documented below.
        """
        bigquery_export_settings: NotRequired[pulumi.Input['AppLoggingSettingsBigqueryExportSettingsArgsDict']]
        """
        Settings to describe the BigQuery export behaviors for the app.
        Structure is documented below.
        """
        cloud_logging_settings: NotRequired[pulumi.Input['AppLoggingSettingsCloudLoggingSettingsArgsDict']]
        """
        Settings to describe the Cloud Logging behaviors for the app.
        Structure is documented below.
        """
        conversation_logging_settings: NotRequired[pulumi.Input['AppLoggingSettingsConversationLoggingSettingsArgsDict']]
        """
        Settings to describe the conversation logging behaviors for the app.
        Structure is documented below.
        """
        redaction_config: NotRequired[pulumi.Input['AppLoggingSettingsRedactionConfigArgsDict']]
        """
        Configuration to instruct how sensitive data should be handled.
        Structure is documented below.
        """
elif False:
    AppLoggingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLoggingSettingsArgs:
    def __init__(__self__, *,
                 audio_recording_config: Optional[pulumi.Input['AppLoggingSettingsAudioRecordingConfigArgs']] = None,
                 bigquery_export_settings: Optional[pulumi.Input['AppLoggingSettingsBigqueryExportSettingsArgs']] = None,
                 cloud_logging_settings: Optional[pulumi.Input['AppLoggingSettingsCloudLoggingSettingsArgs']] = None,
                 conversation_logging_settings: Optional[pulumi.Input['AppLoggingSettingsConversationLoggingSettingsArgs']] = None,
                 redaction_config: Optional[pulumi.Input['AppLoggingSettingsRedactionConfigArgs']] = None):
        """
        :param pulumi.Input['AppLoggingSettingsAudioRecordingConfigArgs'] audio_recording_config: Configuration for how the audio interactions should be recorded.
               Structure is documented below.
        :param pulumi.Input['AppLoggingSettingsBigqueryExportSettingsArgs'] bigquery_export_settings: Settings to describe the BigQuery export behaviors for the app.
               Structure is documented below.
        :param pulumi.Input['AppLoggingSettingsCloudLoggingSettingsArgs'] cloud_logging_settings: Settings to describe the Cloud Logging behaviors for the app.
               Structure is documented below.
        :param pulumi.Input['AppLoggingSettingsConversationLoggingSettingsArgs'] conversation_logging_settings: Settings to describe the conversation logging behaviors for the app.
               Structure is documented below.
        :param pulumi.Input['AppLoggingSettingsRedactionConfigArgs'] redaction_config: Configuration to instruct how sensitive data should be handled.
               Structure is documented below.
        """
        if audio_recording_config is not None:
            pulumi.set(__self__, "audio_recording_config", audio_recording_config)
        if bigquery_export_settings is not None:
            pulumi.set(__self__, "bigquery_export_settings", bigquery_export_settings)
        if cloud_logging_settings is not None:
            pulumi.set(__self__, "cloud_logging_settings", cloud_logging_settings)
        if conversation_logging_settings is not None:
            pulumi.set(__self__, "conversation_logging_settings", conversation_logging_settings)
        if redaction_config is not None:
            pulumi.set(__self__, "redaction_config", redaction_config)

    @_builtins.property
    @pulumi.getter(name="audioRecordingConfig")
    def audio_recording_config(self) -> Optional[pulumi.Input['AppLoggingSettingsAudioRecordingConfigArgs']]:
        """
        Configuration for how the audio interactions should be recorded.
        Structure is documented below.
        """
        return pulumi.get(self, "audio_recording_config")

    @audio_recording_config.setter
    def audio_recording_config(self, value: Optional[pulumi.Input['AppLoggingSettingsAudioRecordingConfigArgs']]):
        pulumi.set(self, "audio_recording_config", value)

    @_builtins.property
    @pulumi.getter(name="bigqueryExportSettings")
    def bigquery_export_settings(self) -> Optional[pulumi.Input['AppLoggingSettingsBigqueryExportSettingsArgs']]:
        """
        Settings to describe the BigQuery export behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "bigquery_export_settings")

    @bigquery_export_settings.setter
    def bigquery_export_settings(self, value: Optional[pulumi.Input['AppLoggingSettingsBigqueryExportSettingsArgs']]):
        pulumi.set(self, "bigquery_export_settings", value)

    @_builtins.property
    @pulumi.getter(name="cloudLoggingSettings")
    def cloud_logging_settings(self) -> Optional[pulumi.Input['AppLoggingSettingsCloudLoggingSettingsArgs']]:
        """
        Settings to describe the Cloud Logging behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_logging_settings")

    @cloud_logging_settings.setter
    def cloud_logging_settings(self, value: Optional[pulumi.Input['AppLoggingSettingsCloudLoggingSettingsArgs']]):
        pulumi.set(self, "cloud_logging_settings", value)

    @_builtins.property
    @pulumi.getter(name="conversationLoggingSettings")
    def conversation_logging_settings(self) -> Optional[pulumi.Input['AppLoggingSettingsConversationLoggingSettingsArgs']]:
        """
        Settings to describe the conversation logging behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_logging_settings")

    @conversation_logging_settings.setter
    def conversation_logging_settings(self, value: Optional[pulumi.Input['AppLoggingSettingsConversationLoggingSettingsArgs']]):
        pulumi.set(self, "conversation_logging_settings", value)

    @_builtins.property
    @pulumi.getter(name="redactionConfig")
    def redaction_config(self) -> Optional[pulumi.Input['AppLoggingSettingsRedactionConfigArgs']]:
        """
        Configuration to instruct how sensitive data should be handled.
        Structure is documented below.
        """
        return pulumi.get(self, "redaction_config")

    @redaction_config.setter
    def redaction_config(self, value: Optional[pulumi.Input['AppLoggingSettingsRedactionConfigArgs']]):
        pulumi.set(self, "redaction_config", value)


if not MYPY:
    class AppLoggingSettingsAudioRecordingConfigArgsDict(TypedDict):
        gcs_bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [Cloud Storage](https://cloud.google.com/storage) bucket to store the
        session audio recordings. The URI must start with "gs://".
        Note: If the Cloud Storage bucket is in a different project from the app,
        you should grant `storage.objects.create` permission to the CES service
        agent `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        gcs_path_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Cloud Storage path prefix for audio recordings.
        This prefix can include the following placeholders, which will be
        dynamically substituted at serving time:
        - $project:   project ID
        - $location:  app location
        - $app:       app ID
        - $date:      session date in YYYY-MM-DD format
        - $session:   session ID
        If the path prefix is not specified, the default prefix
        `$project/$location/$app/$date/$session/` will be used.
        """
elif False:
    AppLoggingSettingsAudioRecordingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLoggingSettingsAudioRecordingConfigArgs:
    def __init__(__self__, *,
                 gcs_bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 gcs_path_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] gcs_bucket: The [Cloud Storage](https://cloud.google.com/storage) bucket to store the
               session audio recordings. The URI must start with "gs://".
               Note: If the Cloud Storage bucket is in a different project from the app,
               you should grant `storage.objects.create` permission to the CES service
               agent `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param pulumi.Input[_builtins.str] gcs_path_prefix: The Cloud Storage path prefix for audio recordings.
               This prefix can include the following placeholders, which will be
               dynamically substituted at serving time:
               - $project:   project ID
               - $location:  app location
               - $app:       app ID
               - $date:      session date in YYYY-MM-DD format
               - $session:   session ID
               If the path prefix is not specified, the default prefix
               `$project/$location/$app/$date/$session/` will be used.
        """
        if gcs_bucket is not None:
            pulumi.set(__self__, "gcs_bucket", gcs_bucket)
        if gcs_path_prefix is not None:
            pulumi.set(__self__, "gcs_path_prefix", gcs_path_prefix)

    @_builtins.property
    @pulumi.getter(name="gcsBucket")
    def gcs_bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [Cloud Storage](https://cloud.google.com/storage) bucket to store the
        session audio recordings. The URI must start with "gs://".
        Note: If the Cloud Storage bucket is in a different project from the app,
        you should grant `storage.objects.create` permission to the CES service
        agent `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "gcs_bucket")

    @gcs_bucket.setter
    def gcs_bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gcs_bucket", value)

    @_builtins.property
    @pulumi.getter(name="gcsPathPrefix")
    def gcs_path_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Cloud Storage path prefix for audio recordings.
        This prefix can include the following placeholders, which will be
        dynamically substituted at serving time:
        - $project:   project ID
        - $location:  app location
        - $app:       app ID
        - $date:      session date in YYYY-MM-DD format
        - $session:   session ID
        If the path prefix is not specified, the default prefix
        `$project/$location/$app/$date/$session/` will be used.
        """
        return pulumi.get(self, "gcs_path_prefix")

    @gcs_path_prefix.setter
    def gcs_path_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gcs_path_prefix", value)


if not MYPY:
    class AppLoggingSettingsBigqueryExportSettingsArgsDict(TypedDict):
        dataset: NotRequired[pulumi.Input[_builtins.str]]
        """
        The BigQuery dataset to export the data to.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the BigQuery export is enabled.
        """
        project: NotRequired[pulumi.Input[_builtins.str]]
        """
        The project ID of the BigQuery dataset to export the data to.
        Note: If the BigQuery dataset is in a different project from the app, you should grant
        roles/bigquery.admin role to the CES service agent service-<PROJECT-
        NUMBER>@gcp-sa-ces.iam.gserviceaccount.com.
        """
elif False:
    AppLoggingSettingsBigqueryExportSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLoggingSettingsBigqueryExportSettingsArgs:
    def __init__(__self__, *,
                 dataset: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 project: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dataset: The BigQuery dataset to export the data to.
        :param pulumi.Input[_builtins.bool] enabled: Indicates whether the BigQuery export is enabled.
        :param pulumi.Input[_builtins.str] project: The project ID of the BigQuery dataset to export the data to.
               Note: If the BigQuery dataset is in a different project from the app, you should grant
               roles/bigquery.admin role to the CES service agent service-<PROJECT-
               NUMBER>@gcp-sa-ces.iam.gserviceaccount.com.
        """
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if project is not None:
            pulumi.set(__self__, "project", project)

    @_builtins.property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The BigQuery dataset to export the data to.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dataset", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the BigQuery export is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The project ID of the BigQuery dataset to export the data to.
        Note: If the BigQuery dataset is in a different project from the app, you should grant
        roles/bigquery.admin role to the CES service agent service-<PROJECT-
        NUMBER>@gcp-sa-ces.iam.gserviceaccount.com.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project", value)


if not MYPY:
    class AppLoggingSettingsCloudLoggingSettingsArgsDict(TypedDict):
        enable_cloud_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable Cloud Logging for the sessions.
        """
elif False:
    AppLoggingSettingsCloudLoggingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLoggingSettingsCloudLoggingSettingsArgs:
    def __init__(__self__, *,
                 enable_cloud_logging: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_cloud_logging: Whether to enable Cloud Logging for the sessions.
        """
        if enable_cloud_logging is not None:
            pulumi.set(__self__, "enable_cloud_logging", enable_cloud_logging)

    @_builtins.property
    @pulumi.getter(name="enableCloudLogging")
    def enable_cloud_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable Cloud Logging for the sessions.
        """
        return pulumi.get(self, "enable_cloud_logging")

    @enable_cloud_logging.setter
    def enable_cloud_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_cloud_logging", value)


if not MYPY:
    class AppLoggingSettingsConversationLoggingSettingsArgsDict(TypedDict):
        disable_conversation_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable conversation logging for the sessions.
        """
elif False:
    AppLoggingSettingsConversationLoggingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLoggingSettingsConversationLoggingSettingsArgs:
    def __init__(__self__, *,
                 disable_conversation_logging: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] disable_conversation_logging: Whether to disable conversation logging for the sessions.
        """
        if disable_conversation_logging is not None:
            pulumi.set(__self__, "disable_conversation_logging", disable_conversation_logging)

    @_builtins.property
    @pulumi.getter(name="disableConversationLogging")
    def disable_conversation_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable conversation logging for the sessions.
        """
        return pulumi.get(self, "disable_conversation_logging")

    @disable_conversation_logging.setter
    def disable_conversation_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_conversation_logging", value)


if not MYPY:
    class AppLoggingSettingsRedactionConfigArgsDict(TypedDict):
        deidentify_template: NotRequired[pulumi.Input[_builtins.str]]
        """
        [DLP](https://cloud.google.com/dlp/docs) deidentify template name to
        instruct on how to de-identify content.
        Format:
        `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
        """
        enable_redaction: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, redaction will be applied in various logging scenarios, including
        conversation history, Cloud Logging and audio recording.
        """
        inspect_template: NotRequired[pulumi.Input[_builtins.str]]
        """
        [DLP](https://cloud.google.com/dlp/docs) inspect template name to configure
        detection of sensitive data types.
        Format:
        `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
        """
elif False:
    AppLoggingSettingsRedactionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLoggingSettingsRedactionConfigArgs:
    def __init__(__self__, *,
                 deidentify_template: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_redaction: Optional[pulumi.Input[_builtins.bool]] = None,
                 inspect_template: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] deidentify_template: [DLP](https://cloud.google.com/dlp/docs) deidentify template name to
               instruct on how to de-identify content.
               Format:
               `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
        :param pulumi.Input[_builtins.bool] enable_redaction: If true, redaction will be applied in various logging scenarios, including
               conversation history, Cloud Logging and audio recording.
        :param pulumi.Input[_builtins.str] inspect_template: [DLP](https://cloud.google.com/dlp/docs) inspect template name to configure
               detection of sensitive data types.
               Format:
               `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
        """
        if deidentify_template is not None:
            pulumi.set(__self__, "deidentify_template", deidentify_template)
        if enable_redaction is not None:
            pulumi.set(__self__, "enable_redaction", enable_redaction)
        if inspect_template is not None:
            pulumi.set(__self__, "inspect_template", inspect_template)

    @_builtins.property
    @pulumi.getter(name="deidentifyTemplate")
    def deidentify_template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        [DLP](https://cloud.google.com/dlp/docs) deidentify template name to
        instruct on how to de-identify content.
        Format:
        `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
        """
        return pulumi.get(self, "deidentify_template")

    @deidentify_template.setter
    def deidentify_template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deidentify_template", value)

    @_builtins.property
    @pulumi.getter(name="enableRedaction")
    def enable_redaction(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, redaction will be applied in various logging scenarios, including
        conversation history, Cloud Logging and audio recording.
        """
        return pulumi.get(self, "enable_redaction")

    @enable_redaction.setter
    def enable_redaction(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_redaction", value)

    @_builtins.property
    @pulumi.getter(name="inspectTemplate")
    def inspect_template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        [DLP](https://cloud.google.com/dlp/docs) inspect template name to configure
        detection of sensitive data types.
        Format:
        `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
        """
        return pulumi.get(self, "inspect_template")

    @inspect_template.setter
    def inspect_template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inspect_template", value)


if not MYPY:
    class AppModelSettingsArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
elif False:
    AppModelSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppModelSettingsArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] model: The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param pulumi.Input[_builtins.float] temperature: If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)


if not MYPY:
    class AppTimeZoneSettingsArgsDict(TypedDict):
        time_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time zone of the app from the time zone database, e.g., America/Los_Angeles, Europe/Paris.
        """
elif False:
    AppTimeZoneSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppTimeZoneSettingsArgs:
    def __init__(__self__, *,
                 time_zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] time_zone: The time zone of the app from the time zone database, e.g., America/Los_Angeles, Europe/Paris.
        """
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time zone of the app from the time zone database, e.g., America/Los_Angeles, Europe/Paris.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class AppVariableDeclarationArgsDict(TypedDict):
        description: pulumi.Input[_builtins.str]
        """
        The description of the variable.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the variable. The name must start with a letter or underscore
        and contain only letters, numbers, or underscores.
        """
        schema: pulumi.Input['AppVariableDeclarationSchemaArgsDict']
        """
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
elif False:
    AppVariableDeclarationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVariableDeclarationArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 schema: pulumi.Input['AppVariableDeclarationSchemaArgs']):
        """
        :param pulumi.Input[_builtins.str] description: The description of the variable.
        :param pulumi.Input[_builtins.str] name: The name of the variable. The name must start with a letter or underscore
               and contain only letters, numbers, or underscores.
        :param pulumi.Input['AppVariableDeclarationSchemaArgs'] schema: Represents a select subset of an OpenAPI 3.0 schema object.
               Structure is documented below.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema", schema)

    @_builtins.property
    @pulumi.getter
    def description(self) -> pulumi.Input[_builtins.str]:
        """
        The description of the variable.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the variable. The name must start with a letter or underscore
        and contain only letters, numbers, or underscores.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> pulumi.Input['AppVariableDeclarationSchemaArgs']:
        """
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input['AppVariableDeclarationSchemaArgs']):
        pulumi.set(self, "schema", value)


if not MYPY:
    class AppVariableDeclarationSchemaArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of the data.
        Possible values:
        STRING
        INTEGER
        NUMBER
        BOOLEAN
        OBJECT
        ARRAY
        """
        additional_properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        any_of: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        default: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        defs: NotRequired[pulumi.Input[_builtins.str]]
        """
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the data.
        """
        enums: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        items: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema of the elements of Type.ARRAY.
        """
        nullable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the value may be null.
        """
        prefix_items: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        Properties of Type.OBJECT.
        """
        ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        requireds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Required properties of Type.OBJECT.
        """
        unique_items: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
elif False:
    AppVariableDeclarationSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVariableDeclarationSchemaArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 additional_properties: Optional[pulumi.Input[_builtins.str]] = None,
                 any_of: Optional[pulumi.Input[_builtins.str]] = None,
                 default: Optional[pulumi.Input[_builtins.str]] = None,
                 defs: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enums: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 items: Optional[pulumi.Input[_builtins.str]] = None,
                 nullable: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix_items: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[_builtins.str]] = None,
                 ref: Optional[pulumi.Input[_builtins.str]] = None,
                 requireds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 unique_items: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of the data.
               Possible values:
               STRING
               INTEGER
               NUMBER
               BOOLEAN
               OBJECT
               ARRAY
        :param pulumi.Input[_builtins.str] additional_properties: Optional. Defines the schema for additional properties allowed in an object.
               The value must be a valid JSON string representing the Schema object.
               (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        :param pulumi.Input[_builtins.str] any_of: Optional. The instance value should be valid against at least one of the schemas in this list.
        :param pulumi.Input[_builtins.str] default: Optional. Default value of the data. Represents a dynamically typed value
               which can be either null, a number, a string, a boolean, a struct,
               or a list of values. The provided default value must be compatible
               with the defined 'type' and other schema constraints.
        :param pulumi.Input[_builtins.str] defs: A map of definitions for use by ref. Only allowed at the root of the schema.
        :param pulumi.Input[_builtins.str] description: The description of the data.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enums: Possible values of the element of primitive type with enum format.
               Examples:
               1. We can define direction as :
               {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
               2. We can define apartment number as :
               {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        :param pulumi.Input[_builtins.str] items: Schema of the elements of Type.ARRAY.
        :param pulumi.Input[_builtins.bool] nullable: Indicates if the value may be null.
        :param pulumi.Input[_builtins.str] prefix_items: Optional. Schemas of initial elements of Type.ARRAY.
        :param pulumi.Input[_builtins.str] properties: Properties of Type.OBJECT.
        :param pulumi.Input[_builtins.str] ref: Allows indirect references between schema nodes. The value should be a
               valid reference to a child of the root `defs`.
               For example, the following schema defines a reference to a schema node
               named "Pet":
               type: object
               properties:
               pet:
               ref: #/defs/Pet
               defs:
               Pet:
               type: object
               properties:
               name:
               type: string
               The value of the "pet" property is a reference to the schema node
               named "Pet".
               See details in
               https://json-schema.org/understanding-json-schema/structuring.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] requireds: Required properties of Type.OBJECT.
        :param pulumi.Input[_builtins.bool] unique_items: Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        pulumi.set(__self__, "type", type)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if any_of is not None:
            pulumi.set(__self__, "any_of", any_of)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if defs is not None:
            pulumi.set(__self__, "defs", defs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enums is not None:
            pulumi.set(__self__, "enums", enums)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if prefix_items is not None:
            pulumi.set(__self__, "prefix_items", prefix_items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if requireds is not None:
            pulumi.set(__self__, "requireds", requireds)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the data.
        Possible values:
        STRING
        INTEGER
        NUMBER
        BOOLEAN
        OBJECT
        ARRAY
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_properties", value)

    @_builtins.property
    @pulumi.getter(name="anyOf")
    def any_of(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        return pulumi.get(self, "any_of")

    @any_of.setter
    def any_of(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "any_of", value)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def defs(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        return pulumi.get(self, "defs")

    @defs.setter
    def defs(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "defs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the data.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def enums(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        return pulumi.get(self, "enums")

    @enums.setter
    def enums(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enums", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema of the elements of Type.ARRAY.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the value may be null.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "nullable", value)

    @_builtins.property
    @pulumi.getter(name="prefixItems")
    def prefix_items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        return pulumi.get(self, "prefix_items")

    @prefix_items.setter
    def prefix_items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_items", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Properties of Type.OBJECT.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ref", value)

    @_builtins.property
    @pulumi.getter
    def requireds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Required properties of Type.OBJECT.
        """
        return pulumi.get(self, "requireds")

    @requireds.setter
    def requireds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "requireds", value)

    @_builtins.property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        return pulumi.get(self, "unique_items")

    @unique_items.setter
    def unique_items(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unique_items", value)


if not MYPY:
    class DeploymentChannelProfileArgsDict(TypedDict):
        channel_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the channel profile.
        Possible values:
        UNKNOWN
        WEB_UI
        API
        TWILIO
        GOOGLE_TELEPHONY_PLATFORM
        CONTACT_CENTER_AS_A_SERVICE
        """
        disable_barge_in_control: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable user barge-in control in the conversation.
        - **true**: User interruptions are disabled while the agent is speaking.
        - **false**: The agent retains automatic control over when the user can
        interrupt.
        """
        disable_dtmf: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable DTMF (dual-tone multi-frequency).
        """
        persona_property: NotRequired[pulumi.Input['DeploymentChannelProfilePersonaPropertyArgsDict']]
        """
        Represents the persona property of a channel.
        Structure is documented below.
        """
        profile_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier of the channel profile.
        """
        web_widget_config: NotRequired[pulumi.Input['DeploymentChannelProfileWebWidgetConfigArgsDict']]
        """
        Message for configuration for the web widget.
        Structure is documented below.
        """
elif False:
    DeploymentChannelProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentChannelProfileArgs:
    def __init__(__self__, *,
                 channel_type: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_barge_in_control: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_dtmf: Optional[pulumi.Input[_builtins.bool]] = None,
                 persona_property: Optional[pulumi.Input['DeploymentChannelProfilePersonaPropertyArgs']] = None,
                 profile_id: Optional[pulumi.Input[_builtins.str]] = None,
                 web_widget_config: Optional[pulumi.Input['DeploymentChannelProfileWebWidgetConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] channel_type: The type of the channel profile.
               Possible values:
               UNKNOWN
               WEB_UI
               API
               TWILIO
               GOOGLE_TELEPHONY_PLATFORM
               CONTACT_CENTER_AS_A_SERVICE
        :param pulumi.Input[_builtins.bool] disable_barge_in_control: Whether to disable user barge-in control in the conversation.
               - **true**: User interruptions are disabled while the agent is speaking.
               - **false**: The agent retains automatic control over when the user can
               interrupt.
        :param pulumi.Input[_builtins.bool] disable_dtmf: Whether to disable DTMF (dual-tone multi-frequency).
        :param pulumi.Input['DeploymentChannelProfilePersonaPropertyArgs'] persona_property: Represents the persona property of a channel.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] profile_id: The unique identifier of the channel profile.
        :param pulumi.Input['DeploymentChannelProfileWebWidgetConfigArgs'] web_widget_config: Message for configuration for the web widget.
               Structure is documented below.
        """
        if channel_type is not None:
            pulumi.set(__self__, "channel_type", channel_type)
        if disable_barge_in_control is not None:
            pulumi.set(__self__, "disable_barge_in_control", disable_barge_in_control)
        if disable_dtmf is not None:
            pulumi.set(__self__, "disable_dtmf", disable_dtmf)
        if persona_property is not None:
            pulumi.set(__self__, "persona_property", persona_property)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if web_widget_config is not None:
            pulumi.set(__self__, "web_widget_config", web_widget_config)

    @_builtins.property
    @pulumi.getter(name="channelType")
    def channel_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the channel profile.
        Possible values:
        UNKNOWN
        WEB_UI
        API
        TWILIO
        GOOGLE_TELEPHONY_PLATFORM
        CONTACT_CENTER_AS_A_SERVICE
        """
        return pulumi.get(self, "channel_type")

    @channel_type.setter
    def channel_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel_type", value)

    @_builtins.property
    @pulumi.getter(name="disableBargeInControl")
    def disable_barge_in_control(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable user barge-in control in the conversation.
        - **true**: User interruptions are disabled while the agent is speaking.
        - **false**: The agent retains automatic control over when the user can
        interrupt.
        """
        return pulumi.get(self, "disable_barge_in_control")

    @disable_barge_in_control.setter
    def disable_barge_in_control(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_barge_in_control", value)

    @_builtins.property
    @pulumi.getter(name="disableDtmf")
    def disable_dtmf(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable DTMF (dual-tone multi-frequency).
        """
        return pulumi.get(self, "disable_dtmf")

    @disable_dtmf.setter
    def disable_dtmf(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_dtmf", value)

    @_builtins.property
    @pulumi.getter(name="personaProperty")
    def persona_property(self) -> Optional[pulumi.Input['DeploymentChannelProfilePersonaPropertyArgs']]:
        """
        Represents the persona property of a channel.
        Structure is documented below.
        """
        return pulumi.get(self, "persona_property")

    @persona_property.setter
    def persona_property(self, value: Optional[pulumi.Input['DeploymentChannelProfilePersonaPropertyArgs']]):
        pulumi.set(self, "persona_property", value)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier of the channel profile.
        """
        return pulumi.get(self, "profile_id")

    @profile_id.setter
    def profile_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile_id", value)

    @_builtins.property
    @pulumi.getter(name="webWidgetConfig")
    def web_widget_config(self) -> Optional[pulumi.Input['DeploymentChannelProfileWebWidgetConfigArgs']]:
        """
        Message for configuration for the web widget.
        Structure is documented below.
        """
        return pulumi.get(self, "web_widget_config")

    @web_widget_config.setter
    def web_widget_config(self, value: Optional[pulumi.Input['DeploymentChannelProfileWebWidgetConfigArgs']]):
        pulumi.set(self, "web_widget_config", value)


if not MYPY:
    class DeploymentChannelProfilePersonaPropertyArgsDict(TypedDict):
        persona: NotRequired[pulumi.Input[_builtins.str]]
        """
        The persona of the channel.
        Possible values:
        UNKNOWN
        CONCISE
        CHATTY
        """
elif False:
    DeploymentChannelProfilePersonaPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentChannelProfilePersonaPropertyArgs:
    def __init__(__self__, *,
                 persona: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] persona: The persona of the channel.
               Possible values:
               UNKNOWN
               CONCISE
               CHATTY
        """
        if persona is not None:
            pulumi.set(__self__, "persona", persona)

    @_builtins.property
    @pulumi.getter
    def persona(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The persona of the channel.
        Possible values:
        UNKNOWN
        CONCISE
        CHATTY
        """
        return pulumi.get(self, "persona")

    @persona.setter
    def persona(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "persona", value)


if not MYPY:
    class DeploymentChannelProfileWebWidgetConfigArgsDict(TypedDict):
        modality: NotRequired[pulumi.Input[_builtins.str]]
        """
        The modality of the web widget.
        Possible values:
        UNKNOWN_MODALITY
        CHAT_AND_VOICE
        VOICE_ONLY
        CHAT_ONLY
        """
        theme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The theme of the web widget.
        Possible values:
        UNKNOWN_THEME
        LIGHT
        DARK
        """
        web_widget_title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The title of the web widget.
        """
elif False:
    DeploymentChannelProfileWebWidgetConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentChannelProfileWebWidgetConfigArgs:
    def __init__(__self__, *,
                 modality: Optional[pulumi.Input[_builtins.str]] = None,
                 theme: Optional[pulumi.Input[_builtins.str]] = None,
                 web_widget_title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] modality: The modality of the web widget.
               Possible values:
               UNKNOWN_MODALITY
               CHAT_AND_VOICE
               VOICE_ONLY
               CHAT_ONLY
        :param pulumi.Input[_builtins.str] theme: The theme of the web widget.
               Possible values:
               UNKNOWN_THEME
               LIGHT
               DARK
        :param pulumi.Input[_builtins.str] web_widget_title: The title of the web widget.
        """
        if modality is not None:
            pulumi.set(__self__, "modality", modality)
        if theme is not None:
            pulumi.set(__self__, "theme", theme)
        if web_widget_title is not None:
            pulumi.set(__self__, "web_widget_title", web_widget_title)

    @_builtins.property
    @pulumi.getter
    def modality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The modality of the web widget.
        Possible values:
        UNKNOWN_MODALITY
        CHAT_AND_VOICE
        VOICE_ONLY
        CHAT_ONLY
        """
        return pulumi.get(self, "modality")

    @modality.setter
    def modality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "modality", value)

    @_builtins.property
    @pulumi.getter
    def theme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The theme of the web widget.
        Possible values:
        UNKNOWN_THEME
        LIGHT
        DARK
        """
        return pulumi.get(self, "theme")

    @theme.setter
    def theme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "theme", value)

    @_builtins.property
    @pulumi.getter(name="webWidgetTitle")
    def web_widget_title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The title of the web widget.
        """
        return pulumi.get(self, "web_widget_title")

    @web_widget_title.setter
    def web_widget_title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_widget_title", value)


if not MYPY:
    class ExampleMessageArgsDict(TypedDict):
        chunks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExampleMessageChunkArgsDict']]]]
        """
        Content of the message as a series of chunks.
        Structure is documented below.
        """
        role: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role within the conversation, e.g., user, agent.
        """
elif False:
    ExampleMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExampleMessageArgs:
    def __init__(__self__, *,
                 chunks: Optional[pulumi.Input[Sequence[pulumi.Input['ExampleMessageChunkArgs']]]] = None,
                 role: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ExampleMessageChunkArgs']]] chunks: Content of the message as a series of chunks.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] role: The role within the conversation, e.g., user, agent.
        """
        if chunks is not None:
            pulumi.set(__self__, "chunks", chunks)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def chunks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExampleMessageChunkArgs']]]]:
        """
        Content of the message as a series of chunks.
        Structure is documented below.
        """
        return pulumi.get(self, "chunks")

    @chunks.setter
    def chunks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExampleMessageChunkArgs']]]]):
        pulumi.set(self, "chunks", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role within the conversation, e.g., user, agent.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class ExampleMessageChunkArgsDict(TypedDict):
        image: NotRequired[pulumi.Input['ExampleMessageChunkImageArgsDict']]
        """
        Represents an image input or output in the conversation.
        Structure is documented below.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        Text data.
        """
        updated_variables: NotRequired[pulumi.Input[_builtins.str]]
        """
        A struct represents variables that were updated in the conversation,
        keyed by variable names.
        """
elif False:
    ExampleMessageChunkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExampleMessageChunkArgs:
    def __init__(__self__, *,
                 image: Optional[pulumi.Input['ExampleMessageChunkImageArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_variables: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ExampleMessageChunkImageArgs'] image: Represents an image input or output in the conversation.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] text: Text data.
        :param pulumi.Input[_builtins.str] updated_variables: A struct represents variables that were updated in the conversation,
               keyed by variable names.
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if updated_variables is not None:
            pulumi.set(__self__, "updated_variables", updated_variables)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['ExampleMessageChunkImageArgs']]:
        """
        Represents an image input or output in the conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['ExampleMessageChunkImageArgs']]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Text data.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter(name="updatedVariables")
    def updated_variables(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A struct represents variables that were updated in the conversation,
        keyed by variable names.
        """
        return pulumi.get(self, "updated_variables")

    @updated_variables.setter
    def updated_variables(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_variables", value)


if not MYPY:
    class ExampleMessageChunkImageArgsDict(TypedDict):
        data: pulumi.Input[_builtins.str]
        """
        Raw bytes of the image.
        """
        mime_type: pulumi.Input[_builtins.str]
        """
        The IANA standard MIME type of the source data.
        Supported image types includes:
        * image/png
        * image/jpeg
        * image/webp
        """
elif False:
    ExampleMessageChunkImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExampleMessageChunkImageArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[_builtins.str],
                 mime_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] data: Raw bytes of the image.
        :param pulumi.Input[_builtins.str] mime_type: The IANA standard MIME type of the source data.
               Supported image types includes:
               * image/png
               * image/jpeg
               * image/webp
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "mime_type", mime_type)

    @_builtins.property
    @pulumi.getter
    def data(self) -> pulumi.Input[_builtins.str]:
        """
        Raw bytes of the image.
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data", value)

    @_builtins.property
    @pulumi.getter(name="mimeType")
    def mime_type(self) -> pulumi.Input[_builtins.str]:
        """
        The IANA standard MIME type of the source data.
        Supported image types includes:
        * image/png
        * image/jpeg
        * image/webp
        """
        return pulumi.get(self, "mime_type")

    @mime_type.setter
    def mime_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mime_type", value)


if not MYPY:
    class ToolsetOpenApiToolsetArgsDict(TypedDict):
        open_api_schema: pulumi.Input[_builtins.str]
        """
        The OpenAPI schema of the toolset.
        """
        api_authentication: NotRequired[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationArgsDict']]
        """
        Authentication information required for API calls.
        Structure is documented below.
        """
        ignore_unknown_fields: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the agent will ignore unknown fields in the API response for all
        operations defined in the OpenAPI schema.
        """
        service_directory_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetServiceDirectoryConfigArgsDict']]
        """
        Configuration for tools using Service Directory.
        Structure is documented below.
        """
        tls_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetTlsConfigArgsDict']]
        """
        The TLS configuration.
        Structure is documented below.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The server URL of the Open API schema.
        This field is only set in toolsets in the environment dependencies
        during the export process if the schema contains a server url.
        During the import process, if this url is present in the environment dependencies
        and the schema has the $env_var placeholder,
        it will replace the placeholder in the schema.
        """
elif False:
    ToolsetOpenApiToolsetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetArgs:
    def __init__(__self__, *,
                 open_api_schema: pulumi.Input[_builtins.str],
                 api_authentication: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationArgs']] = None,
                 ignore_unknown_fields: Optional[pulumi.Input[_builtins.bool]] = None,
                 service_directory_config: Optional[pulumi.Input['ToolsetOpenApiToolsetServiceDirectoryConfigArgs']] = None,
                 tls_config: Optional[pulumi.Input['ToolsetOpenApiToolsetTlsConfigArgs']] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] open_api_schema: The OpenAPI schema of the toolset.
        :param pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationArgs'] api_authentication: Authentication information required for API calls.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] ignore_unknown_fields: If true, the agent will ignore unknown fields in the API response for all
               operations defined in the OpenAPI schema.
        :param pulumi.Input['ToolsetOpenApiToolsetServiceDirectoryConfigArgs'] service_directory_config: Configuration for tools using Service Directory.
               Structure is documented below.
        :param pulumi.Input['ToolsetOpenApiToolsetTlsConfigArgs'] tls_config: The TLS configuration.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] url: (Output)
               The server URL of the Open API schema.
               This field is only set in toolsets in the environment dependencies
               during the export process if the schema contains a server url.
               During the import process, if this url is present in the environment dependencies
               and the schema has the $env_var placeholder,
               it will replace the placeholder in the schema.
        """
        pulumi.set(__self__, "open_api_schema", open_api_schema)
        if api_authentication is not None:
            pulumi.set(__self__, "api_authentication", api_authentication)
        if ignore_unknown_fields is not None:
            pulumi.set(__self__, "ignore_unknown_fields", ignore_unknown_fields)
        if service_directory_config is not None:
            pulumi.set(__self__, "service_directory_config", service_directory_config)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="openApiSchema")
    def open_api_schema(self) -> pulumi.Input[_builtins.str]:
        """
        The OpenAPI schema of the toolset.
        """
        return pulumi.get(self, "open_api_schema")

    @open_api_schema.setter
    def open_api_schema(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "open_api_schema", value)

    @_builtins.property
    @pulumi.getter(name="apiAuthentication")
    def api_authentication(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationArgs']]:
        """
        Authentication information required for API calls.
        Structure is documented below.
        """
        return pulumi.get(self, "api_authentication")

    @api_authentication.setter
    def api_authentication(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationArgs']]):
        pulumi.set(self, "api_authentication", value)

    @_builtins.property
    @pulumi.getter(name="ignoreUnknownFields")
    def ignore_unknown_fields(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the agent will ignore unknown fields in the API response for all
        operations defined in the OpenAPI schema.
        """
        return pulumi.get(self, "ignore_unknown_fields")

    @ignore_unknown_fields.setter
    def ignore_unknown_fields(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_unknown_fields", value)

    @_builtins.property
    @pulumi.getter(name="serviceDirectoryConfig")
    def service_directory_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetServiceDirectoryConfigArgs']]:
        """
        Configuration for tools using Service Directory.
        Structure is documented below.
        """
        return pulumi.get(self, "service_directory_config")

    @service_directory_config.setter
    def service_directory_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetServiceDirectoryConfigArgs']]):
        pulumi.set(self, "service_directory_config", value)

    @_builtins.property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetTlsConfigArgs']]:
        """
        The TLS configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "tls_config")

    @tls_config.setter
    def tls_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetTlsConfigArgs']]):
        pulumi.set(self, "tls_config", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The server URL of the Open API schema.
        This field is only set in toolsets in the environment dependencies
        during the export process if the schema contains a server url.
        During the import process, if this url is present in the environment dependencies
        and the schema has the $env_var placeholder,
        it will replace the placeholder in the schema.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ToolsetOpenApiToolsetApiAuthenticationArgsDict(TypedDict):
        api_key_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgsDict']]
        """
        Configurations for authentication with API key.
        Structure is documented below.
        """
        oauth_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgsDict']]
        """
        Configurations for authentication with OAuth.
        Structure is documented below.
        """
        service_account_auth_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgsDict']]
        """
        Configurations for authentication using a custom service account.
        Structure is documented below.
        """
        service_agent_id_token_auth_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict']]
        """
        Configurations for authentication with [ID
        token](https://cloud.google.com/docs/authentication/token-types#id) generated
        from service agent.
        """
elif False:
    ToolsetOpenApiToolsetApiAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetApiAuthenticationArgs:
    def __init__(__self__, *,
                 api_key_config: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs']] = None,
                 oauth_config: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs']] = None,
                 service_account_auth_config: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs']] = None,
                 service_agent_id_token_auth_config: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs']] = None):
        """
        :param pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs'] api_key_config: Configurations for authentication with API key.
               Structure is documented below.
        :param pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs'] oauth_config: Configurations for authentication with OAuth.
               Structure is documented below.
        :param pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs'] service_account_auth_config: Configurations for authentication using a custom service account.
               Structure is documented below.
        :param pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs'] service_agent_id_token_auth_config: Configurations for authentication with [ID
               token](https://cloud.google.com/docs/authentication/token-types#id) generated
               from service agent.
        """
        if api_key_config is not None:
            pulumi.set(__self__, "api_key_config", api_key_config)
        if oauth_config is not None:
            pulumi.set(__self__, "oauth_config", oauth_config)
        if service_account_auth_config is not None:
            pulumi.set(__self__, "service_account_auth_config", service_account_auth_config)
        if service_agent_id_token_auth_config is not None:
            pulumi.set(__self__, "service_agent_id_token_auth_config", service_agent_id_token_auth_config)

    @_builtins.property
    @pulumi.getter(name="apiKeyConfig")
    def api_key_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs']]:
        """
        Configurations for authentication with API key.
        Structure is documented below.
        """
        return pulumi.get(self, "api_key_config")

    @api_key_config.setter
    def api_key_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs']]):
        pulumi.set(self, "api_key_config", value)

    @_builtins.property
    @pulumi.getter(name="oauthConfig")
    def oauth_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs']]:
        """
        Configurations for authentication with OAuth.
        Structure is documented below.
        """
        return pulumi.get(self, "oauth_config")

    @oauth_config.setter
    def oauth_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs']]):
        pulumi.set(self, "oauth_config", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccountAuthConfig")
    def service_account_auth_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs']]:
        """
        Configurations for authentication using a custom service account.
        Structure is documented below.
        """
        return pulumi.get(self, "service_account_auth_config")

    @service_account_auth_config.setter
    def service_account_auth_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs']]):
        pulumi.set(self, "service_account_auth_config", value)

    @_builtins.property
    @pulumi.getter(name="serviceAgentIdTokenAuthConfig")
    def service_agent_id_token_auth_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]:
        """
        Configurations for authentication with [ID
        token](https://cloud.google.com/docs/authentication/token-types#id) generated
        from service agent.
        """
        return pulumi.get(self, "service_agent_id_token_auth_config")

    @service_agent_id_token_auth_config.setter
    def service_agent_id_token_auth_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]):
        pulumi.set(self, "service_agent_id_token_auth_config", value)


if not MYPY:
    class ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgsDict(TypedDict):
        api_key_secret_version: pulumi.Input[_builtins.str]
        """
        The name of the SecretManager secret version resource storing the API key.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        key_name: pulumi.Input[_builtins.str]
        """
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        request_location: pulumi.Input[_builtins.str]
        """
        Key location in the request.
        Possible values:
        HEADER
        QUERY_STRING
        """
elif False:
    ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs:
    def __init__(__self__, *,
                 api_key_secret_version: pulumi.Input[_builtins.str],
                 key_name: pulumi.Input[_builtins.str],
                 request_location: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] api_key_secret_version: The name of the SecretManager secret version resource storing the API key.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param pulumi.Input[_builtins.str] key_name: The parameter name or the header name of the API key.
               E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        :param pulumi.Input[_builtins.str] request_location: Key location in the request.
               Possible values:
               HEADER
               QUERY_STRING
        """
        pulumi.set(__self__, "api_key_secret_version", api_key_secret_version)
        pulumi.set(__self__, "key_name", key_name)
        pulumi.set(__self__, "request_location", request_location)

    @_builtins.property
    @pulumi.getter(name="apiKeySecretVersion")
    def api_key_secret_version(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SecretManager secret version resource storing the API key.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "api_key_secret_version")

    @api_key_secret_version.setter
    def api_key_secret_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key_secret_version", value)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> pulumi.Input[_builtins.str]:
        """
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter(name="requestLocation")
    def request_location(self) -> pulumi.Input[_builtins.str]:
        """
        Key location in the request.
        Possible values:
        HEADER
        QUERY_STRING
        """
        return pulumi.get(self, "request_location")

    @request_location.setter
    def request_location(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "request_location", value)


if not MYPY:
    class ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgsDict(TypedDict):
        client_id: pulumi.Input[_builtins.str]
        """
        The client ID from the OAuth provider.
        """
        client_secret_version: pulumi.Input[_builtins.str]
        """
        The name of the SecretManager secret version resource storing the
        client secret.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        oauth_grant_type: pulumi.Input[_builtins.str]
        """
        OAuth grant types.
        Possible values:
        CLIENT_CREDENTIAL
        """
        token_endpoint: pulumi.Input[_builtins.str]
        """
        The token endpoint in the OAuth provider to exchange for an access token.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The OAuth scopes to grant.
        """
elif False:
    ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[_builtins.str],
                 client_secret_version: pulumi.Input[_builtins.str],
                 oauth_grant_type: pulumi.Input[_builtins.str],
                 token_endpoint: pulumi.Input[_builtins.str],
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id: The client ID from the OAuth provider.
        :param pulumi.Input[_builtins.str] client_secret_version: The name of the SecretManager secret version resource storing the
               client secret.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param pulumi.Input[_builtins.str] oauth_grant_type: OAuth grant types.
               Possible values:
               CLIENT_CREDENTIAL
        :param pulumi.Input[_builtins.str] token_endpoint: The token endpoint in the OAuth provider to exchange for an access token.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: The OAuth scopes to grant.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_version", client_secret_version)
        pulumi.set(__self__, "oauth_grant_type", oauth_grant_type)
        pulumi.set(__self__, "token_endpoint", token_endpoint)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        """
        The client ID from the OAuth provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretVersion")
    def client_secret_version(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SecretManager secret version resource storing the
        client secret.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "client_secret_version")

    @client_secret_version.setter
    def client_secret_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_secret_version", value)

    @_builtins.property
    @pulumi.getter(name="oauthGrantType")
    def oauth_grant_type(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth grant types.
        Possible values:
        CLIENT_CREDENTIAL
        """
        return pulumi.get(self, "oauth_grant_type")

    @oauth_grant_type.setter
    def oauth_grant_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oauth_grant_type", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The token endpoint in the OAuth provider to exchange for an access token.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The OAuth scopes to grant.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)


if not MYPY:
    class ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgsDict(TypedDict):
        service_account: pulumi.Input[_builtins.str]
        """
        The email address of the service account used for authenticatation. CES
        uses this service account to exchange an access token and the access token
        is then sent in the `Authorization` header of the request.
        The service account must have the
        `roles/iam.serviceAccountTokenCreator` role granted to the
        CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
elif False:
    ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs:
    def __init__(__self__, *,
                 service_account: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] service_account: The email address of the service account used for authenticatation. CES
               uses this service account to exchange an access token and the access token
               is then sent in the `Authorization` header of the request.
               The service account must have the
               `roles/iam.serviceAccountTokenCreator` role granted to the
               CES service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        pulumi.set(__self__, "service_account", service_account)

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> pulumi.Input[_builtins.str]:
        """
        The email address of the service account used for authenticatation. CES
        uses this service account to exchange an access token and the access token
        is then sent in the `Authorization` header of the request.
        The service account must have the
        `roles/iam.serviceAccountTokenCreator` role granted to the
        CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_account", value)


if not MYPY:
    class ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict(TypedDict):
        pass
elif False:
    ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ToolsetOpenApiToolsetServiceDirectoryConfigArgsDict(TypedDict):
        service: pulumi.Input[_builtins.str]
        """
        The name of [Service
        Directory](https://cloud.google.com/service-directory) service.
        Format:
        `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
        Location of the service directory must be the same as the location of the
        app.
        """
elif False:
    ToolsetOpenApiToolsetServiceDirectoryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetServiceDirectoryConfigArgs:
    def __init__(__self__, *,
                 service: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] service: The name of [Service
               Directory](https://cloud.google.com/service-directory) service.
               Format:
               `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
               Location of the service directory must be the same as the location of the
               app.
        """
        pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def service(self) -> pulumi.Input[_builtins.str]:
        """
        The name of [Service
        Directory](https://cloud.google.com/service-directory) service.
        Format:
        `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
        Location of the service directory must be the same as the location of the
        app.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service", value)


if not MYPY:
    class ToolsetOpenApiToolsetTlsConfigArgsDict(TypedDict):
        ca_certs: pulumi.Input[Sequence[pulumi.Input['ToolsetOpenApiToolsetTlsConfigCaCertArgsDict']]]
        """
        Specifies a list of allowed custom CA certificates for HTTPS
        verification.
        Structure is documented below.
        """
elif False:
    ToolsetOpenApiToolsetTlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetTlsConfigArgs:
    def __init__(__self__, *,
                 ca_certs: pulumi.Input[Sequence[pulumi.Input['ToolsetOpenApiToolsetTlsConfigCaCertArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ToolsetOpenApiToolsetTlsConfigCaCertArgs']]] ca_certs: Specifies a list of allowed custom CA certificates for HTTPS
               verification.
               Structure is documented below.
        """
        pulumi.set(__self__, "ca_certs", ca_certs)

    @_builtins.property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> pulumi.Input[Sequence[pulumi.Input['ToolsetOpenApiToolsetTlsConfigCaCertArgs']]]:
        """
        Specifies a list of allowed custom CA certificates for HTTPS
        verification.
        Structure is documented below.
        """
        return pulumi.get(self, "ca_certs")

    @ca_certs.setter
    def ca_certs(self, value: pulumi.Input[Sequence[pulumi.Input['ToolsetOpenApiToolsetTlsConfigCaCertArgs']]]):
        pulumi.set(self, "ca_certs", value)


if not MYPY:
    class ToolsetOpenApiToolsetTlsConfigCaCertArgsDict(TypedDict):
        cert: pulumi.Input[_builtins.str]
        """
        The allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, CES will use Google's default trust
        store to verify certificates. N.B. Make sure the HTTPS server
        certificates are signed with "subject alt name". For instance a
        certificate can be self-signed using the following command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        """
        display_name: pulumi.Input[_builtins.str]
        """
        The name of the allowed custom CA certificates. This
        can be used to disambiguate the custom CA certificates.
        """
elif False:
    ToolsetOpenApiToolsetTlsConfigCaCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetTlsConfigCaCertArgs:
    def __init__(__self__, *,
                 cert: pulumi.Input[_builtins.str],
                 display_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] cert: The allowed custom CA certificates (in DER format) for
               HTTPS verification. This overrides the default SSL trust store. If this
               is empty or unspecified, CES will use Google's default trust
               store to verify certificates. N.B. Make sure the HTTPS server
               certificates are signed with "subject alt name". For instance a
               certificate can be self-signed using the following command,
               openssl x509 -req -days 200 -in example.com.csr \\
               -signkey example.com.key \\
               -out example.com.crt \\
               -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        :param pulumi.Input[_builtins.str] display_name: The name of the allowed custom CA certificates. This
               can be used to disambiguate the custom CA certificates.
        """
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> pulumi.Input[_builtins.str]:
        """
        The allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, CES will use Google's default trust
        store to verify certificates. N.B. Make sure the HTTPS server
        certificates are signed with "subject alt name". For instance a
        certificate can be self-signed using the following command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        """
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cert", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the allowed custom CA certificates. This
        can be used to disambiguate the custom CA certificates.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)


