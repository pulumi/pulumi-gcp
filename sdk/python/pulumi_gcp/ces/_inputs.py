# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AgentAfterAgentCallbackArgs',
    'AgentAfterAgentCallbackArgsDict',
    'AgentAfterModelCallbackArgs',
    'AgentAfterModelCallbackArgsDict',
    'AgentAfterToolCallbackArgs',
    'AgentAfterToolCallbackArgsDict',
    'AgentBeforeAgentCallbackArgs',
    'AgentBeforeAgentCallbackArgsDict',
    'AgentBeforeModelCallbackArgs',
    'AgentBeforeModelCallbackArgsDict',
    'AgentBeforeToolCallbackArgs',
    'AgentBeforeToolCallbackArgsDict',
    'AgentLlmAgentArgs',
    'AgentLlmAgentArgsDict',
    'AgentModelSettingsArgs',
    'AgentModelSettingsArgsDict',
    'AgentRemoteDialogflowAgentArgs',
    'AgentRemoteDialogflowAgentArgsDict',
    'AgentToolsetArgs',
    'AgentToolsetArgsDict',
    'AppAudioProcessingConfigArgs',
    'AppAudioProcessingConfigArgsDict',
    'AppAudioProcessingConfigAmbientSoundConfigArgs',
    'AppAudioProcessingConfigAmbientSoundConfigArgsDict',
    'AppAudioProcessingConfigBargeInConfigArgs',
    'AppAudioProcessingConfigBargeInConfigArgsDict',
    'AppAudioProcessingConfigSynthesizeSpeechConfigArgs',
    'AppAudioProcessingConfigSynthesizeSpeechConfigArgsDict',
    'AppClientCertificateSettingsArgs',
    'AppClientCertificateSettingsArgsDict',
    'AppDataStoreSettingsArgs',
    'AppDataStoreSettingsArgsDict',
    'AppDataStoreSettingsEngineArgs',
    'AppDataStoreSettingsEngineArgsDict',
    'AppDefaultChannelProfileArgs',
    'AppDefaultChannelProfileArgsDict',
    'AppDefaultChannelProfilePersonaPropertyArgs',
    'AppDefaultChannelProfilePersonaPropertyArgsDict',
    'AppDefaultChannelProfileWebWidgetConfigArgs',
    'AppDefaultChannelProfileWebWidgetConfigArgsDict',
    'AppEvaluationMetricsThresholdsArgs',
    'AppEvaluationMetricsThresholdsArgsDict',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgs',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgsDict',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgs',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgsDict',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgs',
    'AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgsDict',
    'AppLanguageSettingsArgs',
    'AppLanguageSettingsArgsDict',
    'AppLoggingSettingsArgs',
    'AppLoggingSettingsArgsDict',
    'AppLoggingSettingsAudioRecordingConfigArgs',
    'AppLoggingSettingsAudioRecordingConfigArgsDict',
    'AppLoggingSettingsBigqueryExportSettingsArgs',
    'AppLoggingSettingsBigqueryExportSettingsArgsDict',
    'AppLoggingSettingsCloudLoggingSettingsArgs',
    'AppLoggingSettingsCloudLoggingSettingsArgsDict',
    'AppLoggingSettingsConversationLoggingSettingsArgs',
    'AppLoggingSettingsConversationLoggingSettingsArgsDict',
    'AppLoggingSettingsRedactionConfigArgs',
    'AppLoggingSettingsRedactionConfigArgsDict',
    'AppModelSettingsArgs',
    'AppModelSettingsArgsDict',
    'AppTimeZoneSettingsArgs',
    'AppTimeZoneSettingsArgsDict',
    'AppVariableDeclarationArgs',
    'AppVariableDeclarationArgsDict',
    'AppVariableDeclarationSchemaArgs',
    'AppVariableDeclarationSchemaArgsDict',
    'DeploymentChannelProfileArgs',
    'DeploymentChannelProfileArgsDict',
    'DeploymentChannelProfilePersonaPropertyArgs',
    'DeploymentChannelProfilePersonaPropertyArgsDict',
    'DeploymentChannelProfileWebWidgetConfigArgs',
    'DeploymentChannelProfileWebWidgetConfigArgsDict',
    'ExampleMessageArgs',
    'ExampleMessageArgsDict',
    'ExampleMessageChunkArgs',
    'ExampleMessageChunkArgsDict',
    'ExampleMessageChunkImageArgs',
    'ExampleMessageChunkImageArgsDict',
    'GuardrailActionArgs',
    'GuardrailActionArgsDict',
    'GuardrailActionGenerativeAnswerArgs',
    'GuardrailActionGenerativeAnswerArgsDict',
    'GuardrailActionRespondImmediatelyArgs',
    'GuardrailActionRespondImmediatelyArgsDict',
    'GuardrailActionRespondImmediatelyResponseArgs',
    'GuardrailActionRespondImmediatelyResponseArgsDict',
    'GuardrailActionTransferAgentArgs',
    'GuardrailActionTransferAgentArgsDict',
    'GuardrailCodeCallbackArgs',
    'GuardrailCodeCallbackArgsDict',
    'GuardrailCodeCallbackAfterAgentCallbackArgs',
    'GuardrailCodeCallbackAfterAgentCallbackArgsDict',
    'GuardrailCodeCallbackAfterModelCallbackArgs',
    'GuardrailCodeCallbackAfterModelCallbackArgsDict',
    'GuardrailCodeCallbackBeforeAgentCallbackArgs',
    'GuardrailCodeCallbackBeforeAgentCallbackArgsDict',
    'GuardrailCodeCallbackBeforeModelCallbackArgs',
    'GuardrailCodeCallbackBeforeModelCallbackArgsDict',
    'GuardrailContentFilterArgs',
    'GuardrailContentFilterArgsDict',
    'GuardrailLlmPolicyArgs',
    'GuardrailLlmPolicyArgsDict',
    'GuardrailLlmPolicyModelSettingsArgs',
    'GuardrailLlmPolicyModelSettingsArgsDict',
    'GuardrailLlmPromptSecurityArgs',
    'GuardrailLlmPromptSecurityArgsDict',
    'GuardrailLlmPromptSecurityCustomPolicyArgs',
    'GuardrailLlmPromptSecurityCustomPolicyArgsDict',
    'GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgs',
    'GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgsDict',
    'GuardrailLlmPromptSecurityDefaultSettingsArgs',
    'GuardrailLlmPromptSecurityDefaultSettingsArgsDict',
    'GuardrailModelSafetyArgs',
    'GuardrailModelSafetyArgsDict',
    'GuardrailModelSafetySafetySettingArgs',
    'GuardrailModelSafetySafetySettingArgsDict',
    'ToolClientFunctionArgs',
    'ToolClientFunctionArgsDict',
    'ToolClientFunctionParametersArgs',
    'ToolClientFunctionParametersArgsDict',
    'ToolClientFunctionResponseArgs',
    'ToolClientFunctionResponseArgsDict',
    'ToolDataStoreToolArgs',
    'ToolDataStoreToolArgsDict',
    'ToolDataStoreToolBoostSpecArgs',
    'ToolDataStoreToolBoostSpecArgsDict',
    'ToolDataStoreToolBoostSpecSpecArgs',
    'ToolDataStoreToolBoostSpecSpecArgsDict',
    'ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs',
    'ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgsDict',
    'ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs',
    'ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgsDict',
    'ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs',
    'ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgsDict',
    'ToolDataStoreToolEngineSourceArgs',
    'ToolDataStoreToolEngineSourceArgsDict',
    'ToolDataStoreToolEngineSourceDataStoreSourceArgs',
    'ToolDataStoreToolEngineSourceDataStoreSourceArgsDict',
    'ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs',
    'ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgsDict',
    'ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs',
    'ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgsDict',
    'ToolDataStoreToolModalityConfigArgs',
    'ToolDataStoreToolModalityConfigArgsDict',
    'ToolDataStoreToolModalityConfigGroundingConfigArgs',
    'ToolDataStoreToolModalityConfigGroundingConfigArgsDict',
    'ToolDataStoreToolModalityConfigRewriterConfigArgs',
    'ToolDataStoreToolModalityConfigRewriterConfigArgsDict',
    'ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgs',
    'ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgsDict',
    'ToolDataStoreToolModalityConfigSummarizationConfigArgs',
    'ToolDataStoreToolModalityConfigSummarizationConfigArgsDict',
    'ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgs',
    'ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgsDict',
    'ToolGoogleSearchToolArgs',
    'ToolGoogleSearchToolArgsDict',
    'ToolOpenApiToolArgs',
    'ToolOpenApiToolArgsDict',
    'ToolOpenApiToolApiAuthenticationArgs',
    'ToolOpenApiToolApiAuthenticationArgsDict',
    'ToolOpenApiToolApiAuthenticationApiKeyConfigArgs',
    'ToolOpenApiToolApiAuthenticationApiKeyConfigArgsDict',
    'ToolOpenApiToolApiAuthenticationOauthConfigArgs',
    'ToolOpenApiToolApiAuthenticationOauthConfigArgsDict',
    'ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs',
    'ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgsDict',
    'ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs',
    'ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict',
    'ToolOpenApiToolServiceDirectoryConfigArgs',
    'ToolOpenApiToolServiceDirectoryConfigArgsDict',
    'ToolOpenApiToolTlsConfigArgs',
    'ToolOpenApiToolTlsConfigArgsDict',
    'ToolOpenApiToolTlsConfigCaCertArgs',
    'ToolOpenApiToolTlsConfigCaCertArgsDict',
    'ToolPythonFunctionArgs',
    'ToolPythonFunctionArgsDict',
    'ToolSystemToolArgs',
    'ToolSystemToolArgsDict',
    'ToolsetOpenApiToolsetArgs',
    'ToolsetOpenApiToolsetArgsDict',
    'ToolsetOpenApiToolsetApiAuthenticationArgs',
    'ToolsetOpenApiToolsetApiAuthenticationArgsDict',
    'ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs',
    'ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgsDict',
    'ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs',
    'ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgsDict',
    'ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs',
    'ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgsDict',
    'ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs',
    'ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgsDict',
    'ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs',
    'ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict',
    'ToolsetOpenApiToolsetServiceDirectoryConfigArgs',
    'ToolsetOpenApiToolsetServiceDirectoryConfigArgsDict',
    'ToolsetOpenApiToolsetTlsConfigArgs',
    'ToolsetOpenApiToolsetTlsConfigArgsDict',
    'ToolsetOpenApiToolsetTlsConfigCaCertArgs',
    'ToolsetOpenApiToolsetTlsConfigCaCertArgsDict',
]

MYPY = False

if not MYPY:
    class AgentAfterAgentCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    AgentAfterAgentCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAfterAgentCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AgentAfterModelCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    AgentAfterModelCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAfterModelCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AgentAfterToolCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    AgentAfterToolCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentAfterToolCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AgentBeforeAgentCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    AgentBeforeAgentCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentBeforeAgentCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AgentBeforeModelCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    AgentBeforeModelCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentBeforeModelCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AgentBeforeToolCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    AgentBeforeToolCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentBeforeToolCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class AgentLlmAgentArgsDict(TypedDict):
        pass
elif False:
    AgentLlmAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentLlmAgentArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class AgentModelSettingsArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
elif False:
    AgentModelSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentModelSettingsArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] model: The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param pulumi.Input[_builtins.float] temperature: If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)


if not MYPY:
    class AgentRemoteDialogflowAgentArgsDict(TypedDict):
        agent: pulumi.Input[_builtins.str]
        """
        The
        [Dialogflow](https://cloud.google.com/dialogflow/cx/docs/concept/console-conversational-agents
        agent resource name.
        Format: `projects/{project}/locations/{location}/agents/{agent}`
        """
        flow_id: pulumi.Input[_builtins.str]
        """
        The flow ID of the flow in the Dialogflow agent.
        """
        environment_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The environment ID of the Dialogflow agent be used for the agent
        execution. If not specified, the draft environment will be used.
        """
        input_variable_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The mapping of the app variables names to the Dialogflow session
        parameters names to be sent to the Dialogflow agent as input.
        """
        output_variable_mapping: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        The mapping of the Dialogflow session parameters names to the app
        variables names to be sent back to the CES agent after the Dialogflow
        agent execution ends.
        """
elif False:
    AgentRemoteDialogflowAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentRemoteDialogflowAgentArgs:
    def __init__(__self__, *,
                 agent: pulumi.Input[_builtins.str],
                 flow_id: pulumi.Input[_builtins.str],
                 environment_id: Optional[pulumi.Input[_builtins.str]] = None,
                 input_variable_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 output_variable_mapping: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] agent: The
               [Dialogflow](https://cloud.google.com/dialogflow/cx/docs/concept/console-conversational-agents
               agent resource name.
               Format: `projects/{project}/locations/{location}/agents/{agent}`
        :param pulumi.Input[_builtins.str] flow_id: The flow ID of the flow in the Dialogflow agent.
        :param pulumi.Input[_builtins.str] environment_id: The environment ID of the Dialogflow agent be used for the agent
               execution. If not specified, the draft environment will be used.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] input_variable_mapping: The mapping of the app variables names to the Dialogflow session
               parameters names to be sent to the Dialogflow agent as input.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] output_variable_mapping: The mapping of the Dialogflow session parameters names to the app
               variables names to be sent back to the CES agent after the Dialogflow
               agent execution ends.
        """
        pulumi.set(__self__, "agent", agent)
        pulumi.set(__self__, "flow_id", flow_id)
        if environment_id is not None:
            pulumi.set(__self__, "environment_id", environment_id)
        if input_variable_mapping is not None:
            pulumi.set(__self__, "input_variable_mapping", input_variable_mapping)
        if output_variable_mapping is not None:
            pulumi.set(__self__, "output_variable_mapping", output_variable_mapping)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> pulumi.Input[_builtins.str]:
        """
        The
        [Dialogflow](https://cloud.google.com/dialogflow/cx/docs/concept/console-conversational-agents
        agent resource name.
        Format: `projects/{project}/locations/{location}/agents/{agent}`
        """
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agent", value)

    @_builtins.property
    @pulumi.getter(name="flowId")
    def flow_id(self) -> pulumi.Input[_builtins.str]:
        """
        The flow ID of the flow in the Dialogflow agent.
        """
        return pulumi.get(self, "flow_id")

    @flow_id.setter
    def flow_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "flow_id", value)

    @_builtins.property
    @pulumi.getter(name="environmentId")
    def environment_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The environment ID of the Dialogflow agent be used for the agent
        execution. If not specified, the draft environment will be used.
        """
        return pulumi.get(self, "environment_id")

    @environment_id.setter
    def environment_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "environment_id", value)

    @_builtins.property
    @pulumi.getter(name="inputVariableMapping")
    def input_variable_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The mapping of the app variables names to the Dialogflow session
        parameters names to be sent to the Dialogflow agent as input.
        """
        return pulumi.get(self, "input_variable_mapping")

    @input_variable_mapping.setter
    def input_variable_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "input_variable_mapping", value)

    @_builtins.property
    @pulumi.getter(name="outputVariableMapping")
    def output_variable_mapping(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        The mapping of the Dialogflow session parameters names to the app
        variables names to be sent back to the CES agent after the Dialogflow
        agent execution ends.
        """
        return pulumi.get(self, "output_variable_mapping")

    @output_variable_mapping.setter
    def output_variable_mapping(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "output_variable_mapping", value)


if not MYPY:
    class AgentToolsetArgsDict(TypedDict):
        toolset: pulumi.Input[_builtins.str]
        """
        The resource name of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        tool_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The tools IDs to filter the toolset.
        """
elif False:
    AgentToolsetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AgentToolsetArgs:
    def __init__(__self__, *,
                 toolset: pulumi.Input[_builtins.str],
                 tool_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] toolset: The resource name of the toolset.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tool_ids: The tools IDs to filter the toolset.
        """
        pulumi.set(__self__, "toolset", toolset)
        if tool_ids is not None:
            pulumi.set(__self__, "tool_ids", tool_ids)

    @_builtins.property
    @pulumi.getter
    def toolset(self) -> pulumi.Input[_builtins.str]:
        """
        The resource name of the toolset.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/toolsets/{toolset}`
        """
        return pulumi.get(self, "toolset")

    @toolset.setter
    def toolset(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "toolset", value)

    @_builtins.property
    @pulumi.getter(name="toolIds")
    def tool_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The tools IDs to filter the toolset.
        """
        return pulumi.get(self, "tool_ids")

    @tool_ids.setter
    def tool_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "tool_ids", value)


if not MYPY:
    class AppAudioProcessingConfigArgsDict(TypedDict):
        ambient_sound_config: NotRequired[pulumi.Input['AppAudioProcessingConfigAmbientSoundConfigArgsDict']]
        """
        Configuration for the ambient sound to be played with the synthesized agent
        response, to enhance the naturalness of the conversation.
        Structure is documented below.
        """
        barge_in_config: NotRequired[pulumi.Input['AppAudioProcessingConfigBargeInConfigArgsDict']]
        """
        Configuration for how the user barge-in activities should be handled.
        Structure is documented below.
        """
        inactivity_timeout: NotRequired[pulumi.Input[_builtins.str]]
        """
        The duration of user inactivity (no speech or interaction) before the agent
        prompts the user for reengagement. If not set, the agent will not prompt
        the user for reengagement.
        """
        synthesize_speech_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppAudioProcessingConfigSynthesizeSpeechConfigArgsDict']]]]
        """
        Configuration of how the agent response should be synthesized, mapping from
        the language code to SynthesizeSpeechConfig.
        If the configuration for the specified language code is not found, the
        configuration for the root language code will be used. For example, if the
        map contains "en-us" and "en", and the specified language code is "en-gb",
        then "en" configuration will be used.
        Note: Language code is case-insensitive.
        Structure is documented below.
        """
elif False:
    AppAudioProcessingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppAudioProcessingConfigArgs:
    def __init__(__self__, *,
                 ambient_sound_config: Optional[pulumi.Input['AppAudioProcessingConfigAmbientSoundConfigArgs']] = None,
                 barge_in_config: Optional[pulumi.Input['AppAudioProcessingConfigBargeInConfigArgs']] = None,
                 inactivity_timeout: Optional[pulumi.Input[_builtins.str]] = None,
                 synthesize_speech_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AppAudioProcessingConfigSynthesizeSpeechConfigArgs']]]] = None):
        """
        :param pulumi.Input['AppAudioProcessingConfigAmbientSoundConfigArgs'] ambient_sound_config: Configuration for the ambient sound to be played with the synthesized agent
               response, to enhance the naturalness of the conversation.
               Structure is documented below.
        :param pulumi.Input['AppAudioProcessingConfigBargeInConfigArgs'] barge_in_config: Configuration for how the user barge-in activities should be handled.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] inactivity_timeout: The duration of user inactivity (no speech or interaction) before the agent
               prompts the user for reengagement. If not set, the agent will not prompt
               the user for reengagement.
        :param pulumi.Input[Sequence[pulumi.Input['AppAudioProcessingConfigSynthesizeSpeechConfigArgs']]] synthesize_speech_configs: Configuration of how the agent response should be synthesized, mapping from
               the language code to SynthesizeSpeechConfig.
               If the configuration for the specified language code is not found, the
               configuration for the root language code will be used. For example, if the
               map contains "en-us" and "en", and the specified language code is "en-gb",
               then "en" configuration will be used.
               Note: Language code is case-insensitive.
               Structure is documented below.
        """
        if ambient_sound_config is not None:
            pulumi.set(__self__, "ambient_sound_config", ambient_sound_config)
        if barge_in_config is not None:
            pulumi.set(__self__, "barge_in_config", barge_in_config)
        if inactivity_timeout is not None:
            pulumi.set(__self__, "inactivity_timeout", inactivity_timeout)
        if synthesize_speech_configs is not None:
            pulumi.set(__self__, "synthesize_speech_configs", synthesize_speech_configs)

    @_builtins.property
    @pulumi.getter(name="ambientSoundConfig")
    def ambient_sound_config(self) -> Optional[pulumi.Input['AppAudioProcessingConfigAmbientSoundConfigArgs']]:
        """
        Configuration for the ambient sound to be played with the synthesized agent
        response, to enhance the naturalness of the conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "ambient_sound_config")

    @ambient_sound_config.setter
    def ambient_sound_config(self, value: Optional[pulumi.Input['AppAudioProcessingConfigAmbientSoundConfigArgs']]):
        pulumi.set(self, "ambient_sound_config", value)

    @_builtins.property
    @pulumi.getter(name="bargeInConfig")
    def barge_in_config(self) -> Optional[pulumi.Input['AppAudioProcessingConfigBargeInConfigArgs']]:
        """
        Configuration for how the user barge-in activities should be handled.
        Structure is documented below.
        """
        return pulumi.get(self, "barge_in_config")

    @barge_in_config.setter
    def barge_in_config(self, value: Optional[pulumi.Input['AppAudioProcessingConfigBargeInConfigArgs']]):
        pulumi.set(self, "barge_in_config", value)

    @_builtins.property
    @pulumi.getter(name="inactivityTimeout")
    def inactivity_timeout(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The duration of user inactivity (no speech or interaction) before the agent
        prompts the user for reengagement. If not set, the agent will not prompt
        the user for reengagement.
        """
        return pulumi.get(self, "inactivity_timeout")

    @inactivity_timeout.setter
    def inactivity_timeout(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inactivity_timeout", value)

    @_builtins.property
    @pulumi.getter(name="synthesizeSpeechConfigs")
    def synthesize_speech_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppAudioProcessingConfigSynthesizeSpeechConfigArgs']]]]:
        """
        Configuration of how the agent response should be synthesized, mapping from
        the language code to SynthesizeSpeechConfig.
        If the configuration for the specified language code is not found, the
        configuration for the root language code will be used. For example, if the
        map contains "en-us" and "en", and the specified language code is "en-gb",
        then "en" configuration will be used.
        Note: Language code is case-insensitive.
        Structure is documented below.
        """
        return pulumi.get(self, "synthesize_speech_configs")

    @synthesize_speech_configs.setter
    def synthesize_speech_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppAudioProcessingConfigSynthesizeSpeechConfigArgs']]]]):
        pulumi.set(self, "synthesize_speech_configs", value)


if not MYPY:
    class AppAudioProcessingConfigAmbientSoundConfigArgsDict(TypedDict):
        gcs_uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ambient noise as a mono-channel, 16kHz WAV file stored in [Cloud
        Storage](https://cloud.google.com/storage).
        Note: Please make sure the CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com` has
        `storage.objects.get` permission to the Cloud Storage object.
        """
        prebuilt_ambient_sound: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the prebuilt ambient sound.
        Valid values are: - "coffee_shop" - "keyboard" - "keypad" - "hum"
        -"office_1" - "office_2" - "office_3"
        -"room_1" - "room_2" - "room_3"
        -"room_4" - "room_5" - "air_conditioner"
        """
        volume_gain_db: NotRequired[pulumi.Input[_builtins.float]]
        """
        Volume gain (in dB) of the normal native volume supported by
        ambient noise, in the range [-96.0, 16.0]. If unset, or set to a value of
        0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
        will play at approximately half the amplitude of the normal native signal
        amplitude. A value of +6.0 (dB) will play at approximately twice the
        amplitude of the normal native signal amplitude. We strongly recommend not
        to exceed +10 (dB) as there's usually no effective increase in loudness for
        any value greater than that.
        """
elif False:
    AppAudioProcessingConfigAmbientSoundConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppAudioProcessingConfigAmbientSoundConfigArgs:
    def __init__(__self__, *,
                 gcs_uri: Optional[pulumi.Input[_builtins.str]] = None,
                 prebuilt_ambient_sound: Optional[pulumi.Input[_builtins.str]] = None,
                 volume_gain_db: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] gcs_uri: Ambient noise as a mono-channel, 16kHz WAV file stored in [Cloud
               Storage](https://cloud.google.com/storage).
               Note: Please make sure the CES service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com` has
               `storage.objects.get` permission to the Cloud Storage object.
        :param pulumi.Input[_builtins.str] prebuilt_ambient_sound: Name of the prebuilt ambient sound.
               Valid values are: - "coffee_shop" - "keyboard" - "keypad" - "hum"
               -"office_1" - "office_2" - "office_3"
               -"room_1" - "room_2" - "room_3"
               -"room_4" - "room_5" - "air_conditioner"
        :param pulumi.Input[_builtins.float] volume_gain_db: Volume gain (in dB) of the normal native volume supported by
               ambient noise, in the range [-96.0, 16.0]. If unset, or set to a value of
               0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
               will play at approximately half the amplitude of the normal native signal
               amplitude. A value of +6.0 (dB) will play at approximately twice the
               amplitude of the normal native signal amplitude. We strongly recommend not
               to exceed +10 (dB) as there's usually no effective increase in loudness for
               any value greater than that.
        """
        if gcs_uri is not None:
            pulumi.set(__self__, "gcs_uri", gcs_uri)
        if prebuilt_ambient_sound is not None:
            pulumi.set(__self__, "prebuilt_ambient_sound", prebuilt_ambient_sound)
        if volume_gain_db is not None:
            pulumi.set(__self__, "volume_gain_db", volume_gain_db)

    @_builtins.property
    @pulumi.getter(name="gcsUri")
    def gcs_uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ambient noise as a mono-channel, 16kHz WAV file stored in [Cloud
        Storage](https://cloud.google.com/storage).
        Note: Please make sure the CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com` has
        `storage.objects.get` permission to the Cloud Storage object.
        """
        return pulumi.get(self, "gcs_uri")

    @gcs_uri.setter
    def gcs_uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gcs_uri", value)

    @_builtins.property
    @pulumi.getter(name="prebuiltAmbientSound")
    def prebuilt_ambient_sound(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the prebuilt ambient sound.
        Valid values are: - "coffee_shop" - "keyboard" - "keypad" - "hum"
        -"office_1" - "office_2" - "office_3"
        -"room_1" - "room_2" - "room_3"
        -"room_4" - "room_5" - "air_conditioner"
        """
        return pulumi.get(self, "prebuilt_ambient_sound")

    @prebuilt_ambient_sound.setter
    def prebuilt_ambient_sound(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prebuilt_ambient_sound", value)

    @_builtins.property
    @pulumi.getter(name="volumeGainDb")
    def volume_gain_db(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Volume gain (in dB) of the normal native volume supported by
        ambient noise, in the range [-96.0, 16.0]. If unset, or set to a value of
        0.0 (dB), will play at normal native signal amplitude. A value of -6.0 (dB)
        will play at approximately half the amplitude of the normal native signal
        amplitude. A value of +6.0 (dB) will play at approximately twice the
        amplitude of the normal native signal amplitude. We strongly recommend not
        to exceed +10 (dB) as there's usually no effective increase in loudness for
        any value greater than that.
        """
        return pulumi.get(self, "volume_gain_db")

    @volume_gain_db.setter
    def volume_gain_db(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "volume_gain_db", value)


if not MYPY:
    class AppAudioProcessingConfigBargeInConfigArgsDict(TypedDict):
        barge_in_awareness: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If enabled, the agent will adapt its next response based on the assumption
        that the user hasn't heard the full preceding agent message.
        This should not be used in scenarios where agent responses are displayed
        visually.
        """
elif False:
    AppAudioProcessingConfigBargeInConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppAudioProcessingConfigBargeInConfigArgs:
    def __init__(__self__, *,
                 barge_in_awareness: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] barge_in_awareness: If enabled, the agent will adapt its next response based on the assumption
               that the user hasn't heard the full preceding agent message.
               This should not be used in scenarios where agent responses are displayed
               visually.
        """
        if barge_in_awareness is not None:
            pulumi.set(__self__, "barge_in_awareness", barge_in_awareness)

    @_builtins.property
    @pulumi.getter(name="bargeInAwareness")
    def barge_in_awareness(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If enabled, the agent will adapt its next response based on the assumption
        that the user hasn't heard the full preceding agent message.
        This should not be used in scenarios where agent responses are displayed
        visually.
        """
        return pulumi.get(self, "barge_in_awareness")

    @barge_in_awareness.setter
    def barge_in_awareness(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "barge_in_awareness", value)


if not MYPY:
    class AppAudioProcessingConfigSynthesizeSpeechConfigArgsDict(TypedDict):
        language_code: pulumi.Input[_builtins.str]
        """
        The identifier for this object. Format specified above.
        """
        speaking_rate: NotRequired[pulumi.Input[_builtins.float]]
        """
        The speaking rate/speed in the range [0.25, 2.0]. 1.0 is the normal native
        speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is
        half as fast. Values outside of the range [0.25, 2.0] will return an error.
        """
        voice: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the voice. If not set, the service will choose a
        voice based on the other parameters such as language_code.
        For the list of available voices, please refer to Supported voices and
        languages from Cloud Text-to-Speech.
        """
elif False:
    AppAudioProcessingConfigSynthesizeSpeechConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppAudioProcessingConfigSynthesizeSpeechConfigArgs:
    def __init__(__self__, *,
                 language_code: pulumi.Input[_builtins.str],
                 speaking_rate: Optional[pulumi.Input[_builtins.float]] = None,
                 voice: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] language_code: The identifier for this object. Format specified above.
        :param pulumi.Input[_builtins.float] speaking_rate: The speaking rate/speed in the range [0.25, 2.0]. 1.0 is the normal native
               speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is
               half as fast. Values outside of the range [0.25, 2.0] will return an error.
        :param pulumi.Input[_builtins.str] voice: The name of the voice. If not set, the service will choose a
               voice based on the other parameters such as language_code.
               For the list of available voices, please refer to Supported voices and
               languages from Cloud Text-to-Speech.
        """
        pulumi.set(__self__, "language_code", language_code)
        if speaking_rate is not None:
            pulumi.set(__self__, "speaking_rate", speaking_rate)
        if voice is not None:
            pulumi.set(__self__, "voice", voice)

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "language_code")

    @language_code.setter
    def language_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "language_code", value)

    @_builtins.property
    @pulumi.getter(name="speakingRate")
    def speaking_rate(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The speaking rate/speed in the range [0.25, 2.0]. 1.0 is the normal native
        speed supported by the specific voice. 2.0 is twice as fast, and 0.5 is
        half as fast. Values outside of the range [0.25, 2.0] will return an error.
        """
        return pulumi.get(self, "speaking_rate")

    @speaking_rate.setter
    def speaking_rate(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "speaking_rate", value)

    @_builtins.property
    @pulumi.getter
    def voice(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the voice. If not set, the service will choose a
        voice based on the other parameters such as language_code.
        For the list of available voices, please refer to Supported voices and
        languages from Cloud Text-to-Speech.
        """
        return pulumi.get(self, "voice")

    @voice.setter
    def voice(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "voice", value)


if not MYPY:
    class AppClientCertificateSettingsArgsDict(TypedDict):
        private_key: pulumi.Input[_builtins.str]
        """
        The name of the SecretManager secret version resource
        storing the private key encoded in PEM format.
        Format: projects/{project}/secrets/{secret}/versions/{version}
        """
        tls_certificate: pulumi.Input[_builtins.str]
        """
        The TLS certificate encoded in PEM format.
        This string must include the begin header and end footer lines.
        """
        passphrase: NotRequired[pulumi.Input[_builtins.str]]
        """
        The passphrase to decrypt the private key.
        Should be left unset if the private key is not encrypted.
        """
elif False:
    AppClientCertificateSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppClientCertificateSettingsArgs:
    def __init__(__self__, *,
                 private_key: pulumi.Input[_builtins.str],
                 tls_certificate: pulumi.Input[_builtins.str],
                 passphrase: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] private_key: The name of the SecretManager secret version resource
               storing the private key encoded in PEM format.
               Format: projects/{project}/secrets/{secret}/versions/{version}
        :param pulumi.Input[_builtins.str] tls_certificate: The TLS certificate encoded in PEM format.
               This string must include the begin header and end footer lines.
        :param pulumi.Input[_builtins.str] passphrase: The passphrase to decrypt the private key.
               Should be left unset if the private key is not encrypted.
        """
        pulumi.set(__self__, "private_key", private_key)
        pulumi.set(__self__, "tls_certificate", tls_certificate)
        if passphrase is not None:
            pulumi.set(__self__, "passphrase", passphrase)

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SecretManager secret version resource
        storing the private key encoded in PEM format.
        Format: projects/{project}/secrets/{secret}/versions/{version}
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "private_key", value)

    @_builtins.property
    @pulumi.getter(name="tlsCertificate")
    def tls_certificate(self) -> pulumi.Input[_builtins.str]:
        """
        The TLS certificate encoded in PEM format.
        This string must include the begin header and end footer lines.
        """
        return pulumi.get(self, "tls_certificate")

    @tls_certificate.setter
    def tls_certificate(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "tls_certificate", value)

    @_builtins.property
    @pulumi.getter
    def passphrase(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The passphrase to decrypt the private key.
        Should be left unset if the private key is not encrypted.
        """
        return pulumi.get(self, "passphrase")

    @passphrase.setter
    def passphrase(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "passphrase", value)


if not MYPY:
    class AppDataStoreSettingsArgsDict(TypedDict):
        engines: NotRequired[pulumi.Input[Sequence[pulumi.Input['AppDataStoreSettingsEngineArgsDict']]]]
        """
        (Output)
        The engines for the app.
        Structure is documented below.


        <a name="nested_data_store_settings_engines"></a>The `engines` block contains:
        """
elif False:
    AppDataStoreSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppDataStoreSettingsArgs:
    def __init__(__self__, *,
                 engines: Optional[pulumi.Input[Sequence[pulumi.Input['AppDataStoreSettingsEngineArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AppDataStoreSettingsEngineArgs']]] engines: (Output)
               The engines for the app.
               Structure is documented below.
               
               
               <a name="nested_data_store_settings_engines"></a>The `engines` block contains:
        """
        if engines is not None:
            pulumi.set(__self__, "engines", engines)

    @_builtins.property
    @pulumi.getter
    def engines(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AppDataStoreSettingsEngineArgs']]]]:
        """
        (Output)
        The engines for the app.
        Structure is documented below.


        <a name="nested_data_store_settings_engines"></a>The `engines` block contains:
        """
        return pulumi.get(self, "engines")

    @engines.setter
    def engines(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AppDataStoreSettingsEngineArgs']]]]):
        pulumi.set(self, "engines", value)


if not MYPY:
    class AppDataStoreSettingsEngineArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Identifier. The unique identifier of the app.
        Format: `projects/{project}/locations/{location}/apps/{app}`
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the engine.
        Possible values:
        ENGINE_TYPE_SEARCH
        ENGINE_TYPE_CHAT
        """
elif False:
    AppDataStoreSettingsEngineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppDataStoreSettingsEngineArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Identifier. The unique identifier of the app.
               Format: `projects/{project}/locations/{location}/apps/{app}`
        :param pulumi.Input[_builtins.str] type: The type of the engine.
               Possible values:
               ENGINE_TYPE_SEARCH
               ENGINE_TYPE_CHAT
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Identifier. The unique identifier of the app.
        Format: `projects/{project}/locations/{location}/apps/{app}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the engine.
        Possible values:
        ENGINE_TYPE_SEARCH
        ENGINE_TYPE_CHAT
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class AppDefaultChannelProfileArgsDict(TypedDict):
        channel_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the channel profile.
        Possible values:
        UNKNOWN
        WEB_UI
        API
        TWILIO
        GOOGLE_TELEPHONY_PLATFORM
        CONTACT_CENTER_AS_A_SERVICE
        """
        disable_barge_in_control: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable user barge-in in the conversation.
        - true: User interruptions are disabled while the agent is speaking.
        - false: The agent retains automatic control over when the user can interrupt.
        """
        disable_dtmf: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable DTMF (dual-tone multi-frequency).
        """
        persona_property: NotRequired[pulumi.Input['AppDefaultChannelProfilePersonaPropertyArgsDict']]
        """
        Represents the persona property of a channel.
        Structure is documented below.
        """
        profile_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier of the channel profile.
        """
        web_widget_config: NotRequired[pulumi.Input['AppDefaultChannelProfileWebWidgetConfigArgsDict']]
        """
        Message for configuration for the web widget.
        Structure is documented below.
        """
elif False:
    AppDefaultChannelProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppDefaultChannelProfileArgs:
    def __init__(__self__, *,
                 channel_type: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_barge_in_control: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_dtmf: Optional[pulumi.Input[_builtins.bool]] = None,
                 persona_property: Optional[pulumi.Input['AppDefaultChannelProfilePersonaPropertyArgs']] = None,
                 profile_id: Optional[pulumi.Input[_builtins.str]] = None,
                 web_widget_config: Optional[pulumi.Input['AppDefaultChannelProfileWebWidgetConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] channel_type: The type of the channel profile.
               Possible values:
               UNKNOWN
               WEB_UI
               API
               TWILIO
               GOOGLE_TELEPHONY_PLATFORM
               CONTACT_CENTER_AS_A_SERVICE
        :param pulumi.Input[_builtins.bool] disable_barge_in_control: Whether to disable user barge-in in the conversation.
               - true: User interruptions are disabled while the agent is speaking.
               - false: The agent retains automatic control over when the user can interrupt.
        :param pulumi.Input[_builtins.bool] disable_dtmf: Whether to disable DTMF (dual-tone multi-frequency).
        :param pulumi.Input['AppDefaultChannelProfilePersonaPropertyArgs'] persona_property: Represents the persona property of a channel.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] profile_id: The unique identifier of the channel profile.
        :param pulumi.Input['AppDefaultChannelProfileWebWidgetConfigArgs'] web_widget_config: Message for configuration for the web widget.
               Structure is documented below.
        """
        if channel_type is not None:
            pulumi.set(__self__, "channel_type", channel_type)
        if disable_barge_in_control is not None:
            pulumi.set(__self__, "disable_barge_in_control", disable_barge_in_control)
        if disable_dtmf is not None:
            pulumi.set(__self__, "disable_dtmf", disable_dtmf)
        if persona_property is not None:
            pulumi.set(__self__, "persona_property", persona_property)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if web_widget_config is not None:
            pulumi.set(__self__, "web_widget_config", web_widget_config)

    @_builtins.property
    @pulumi.getter(name="channelType")
    def channel_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the channel profile.
        Possible values:
        UNKNOWN
        WEB_UI
        API
        TWILIO
        GOOGLE_TELEPHONY_PLATFORM
        CONTACT_CENTER_AS_A_SERVICE
        """
        return pulumi.get(self, "channel_type")

    @channel_type.setter
    def channel_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel_type", value)

    @_builtins.property
    @pulumi.getter(name="disableBargeInControl")
    def disable_barge_in_control(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable user barge-in in the conversation.
        - true: User interruptions are disabled while the agent is speaking.
        - false: The agent retains automatic control over when the user can interrupt.
        """
        return pulumi.get(self, "disable_barge_in_control")

    @disable_barge_in_control.setter
    def disable_barge_in_control(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_barge_in_control", value)

    @_builtins.property
    @pulumi.getter(name="disableDtmf")
    def disable_dtmf(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable DTMF (dual-tone multi-frequency).
        """
        return pulumi.get(self, "disable_dtmf")

    @disable_dtmf.setter
    def disable_dtmf(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_dtmf", value)

    @_builtins.property
    @pulumi.getter(name="personaProperty")
    def persona_property(self) -> Optional[pulumi.Input['AppDefaultChannelProfilePersonaPropertyArgs']]:
        """
        Represents the persona property of a channel.
        Structure is documented below.
        """
        return pulumi.get(self, "persona_property")

    @persona_property.setter
    def persona_property(self, value: Optional[pulumi.Input['AppDefaultChannelProfilePersonaPropertyArgs']]):
        pulumi.set(self, "persona_property", value)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier of the channel profile.
        """
        return pulumi.get(self, "profile_id")

    @profile_id.setter
    def profile_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile_id", value)

    @_builtins.property
    @pulumi.getter(name="webWidgetConfig")
    def web_widget_config(self) -> Optional[pulumi.Input['AppDefaultChannelProfileWebWidgetConfigArgs']]:
        """
        Message for configuration for the web widget.
        Structure is documented below.
        """
        return pulumi.get(self, "web_widget_config")

    @web_widget_config.setter
    def web_widget_config(self, value: Optional[pulumi.Input['AppDefaultChannelProfileWebWidgetConfigArgs']]):
        pulumi.set(self, "web_widget_config", value)


if not MYPY:
    class AppDefaultChannelProfilePersonaPropertyArgsDict(TypedDict):
        persona: NotRequired[pulumi.Input[_builtins.str]]
        """
        The persona of the channel.
        Possible values:
        UNKNOWN
        CONCISE
        CHATTY
        """
elif False:
    AppDefaultChannelProfilePersonaPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppDefaultChannelProfilePersonaPropertyArgs:
    def __init__(__self__, *,
                 persona: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] persona: The persona of the channel.
               Possible values:
               UNKNOWN
               CONCISE
               CHATTY
        """
        if persona is not None:
            pulumi.set(__self__, "persona", persona)

    @_builtins.property
    @pulumi.getter
    def persona(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The persona of the channel.
        Possible values:
        UNKNOWN
        CONCISE
        CHATTY
        """
        return pulumi.get(self, "persona")

    @persona.setter
    def persona(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "persona", value)


if not MYPY:
    class AppDefaultChannelProfileWebWidgetConfigArgsDict(TypedDict):
        modality: NotRequired[pulumi.Input[_builtins.str]]
        """
        The modality of the web widget.
        Possible values:
        UNKNOWN_MODALITY
        CHAT_AND_VOICE
        VOICE_ONLY
        CHAT_ONLY
        """
        theme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The theme of the web widget.
        Possible values:
        UNKNOWN_THEME
        LIGHT
        DARK
        """
        web_widget_title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The title of the web widget.
        """
elif False:
    AppDefaultChannelProfileWebWidgetConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppDefaultChannelProfileWebWidgetConfigArgs:
    def __init__(__self__, *,
                 modality: Optional[pulumi.Input[_builtins.str]] = None,
                 theme: Optional[pulumi.Input[_builtins.str]] = None,
                 web_widget_title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] modality: The modality of the web widget.
               Possible values:
               UNKNOWN_MODALITY
               CHAT_AND_VOICE
               VOICE_ONLY
               CHAT_ONLY
        :param pulumi.Input[_builtins.str] theme: The theme of the web widget.
               Possible values:
               UNKNOWN_THEME
               LIGHT
               DARK
        :param pulumi.Input[_builtins.str] web_widget_title: The title of the web widget.
        """
        if modality is not None:
            pulumi.set(__self__, "modality", modality)
        if theme is not None:
            pulumi.set(__self__, "theme", theme)
        if web_widget_title is not None:
            pulumi.set(__self__, "web_widget_title", web_widget_title)

    @_builtins.property
    @pulumi.getter
    def modality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The modality of the web widget.
        Possible values:
        UNKNOWN_MODALITY
        CHAT_AND_VOICE
        VOICE_ONLY
        CHAT_ONLY
        """
        return pulumi.get(self, "modality")

    @modality.setter
    def modality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "modality", value)

    @_builtins.property
    @pulumi.getter
    def theme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The theme of the web widget.
        Possible values:
        UNKNOWN_THEME
        LIGHT
        DARK
        """
        return pulumi.get(self, "theme")

    @theme.setter
    def theme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "theme", value)

    @_builtins.property
    @pulumi.getter(name="webWidgetTitle")
    def web_widget_title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The title of the web widget.
        """
        return pulumi.get(self, "web_widget_title")

    @web_widget_title.setter
    def web_widget_title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_widget_title", value)


if not MYPY:
    class AppEvaluationMetricsThresholdsArgsDict(TypedDict):
        golden_evaluation_metrics_thresholds: NotRequired[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgsDict']]
        """
        Settings for golden evaluations.
        Structure is documented below.
        """
elif False:
    AppEvaluationMetricsThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppEvaluationMetricsThresholdsArgs:
    def __init__(__self__, *,
                 golden_evaluation_metrics_thresholds: Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgs']] = None):
        """
        :param pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgs'] golden_evaluation_metrics_thresholds: Settings for golden evaluations.
               Structure is documented below.
        """
        if golden_evaluation_metrics_thresholds is not None:
            pulumi.set(__self__, "golden_evaluation_metrics_thresholds", golden_evaluation_metrics_thresholds)

    @_builtins.property
    @pulumi.getter(name="goldenEvaluationMetricsThresholds")
    def golden_evaluation_metrics_thresholds(self) -> Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgs']]:
        """
        Settings for golden evaluations.
        Structure is documented below.
        """
        return pulumi.get(self, "golden_evaluation_metrics_thresholds")

    @golden_evaluation_metrics_thresholds.setter
    def golden_evaluation_metrics_thresholds(self, value: Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgs']]):
        pulumi.set(self, "golden_evaluation_metrics_thresholds", value)


if not MYPY:
    class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgsDict(TypedDict):
        expectation_level_metrics_thresholds: NotRequired[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgsDict']]
        """
        Expectation level metrics thresholds.
        Structure is documented below.
        """
        turn_level_metrics_thresholds: NotRequired[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgsDict']]
        """
        Turn level metrics thresholds.
        Structure is documented below.
        """
elif False:
    AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsArgs:
    def __init__(__self__, *,
                 expectation_level_metrics_thresholds: Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgs']] = None,
                 turn_level_metrics_thresholds: Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgs']] = None):
        """
        :param pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgs'] expectation_level_metrics_thresholds: Expectation level metrics thresholds.
               Structure is documented below.
        :param pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgs'] turn_level_metrics_thresholds: Turn level metrics thresholds.
               Structure is documented below.
        """
        if expectation_level_metrics_thresholds is not None:
            pulumi.set(__self__, "expectation_level_metrics_thresholds", expectation_level_metrics_thresholds)
        if turn_level_metrics_thresholds is not None:
            pulumi.set(__self__, "turn_level_metrics_thresholds", turn_level_metrics_thresholds)

    @_builtins.property
    @pulumi.getter(name="expectationLevelMetricsThresholds")
    def expectation_level_metrics_thresholds(self) -> Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgs']]:
        """
        Expectation level metrics thresholds.
        Structure is documented below.
        """
        return pulumi.get(self, "expectation_level_metrics_thresholds")

    @expectation_level_metrics_thresholds.setter
    def expectation_level_metrics_thresholds(self, value: Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgs']]):
        pulumi.set(self, "expectation_level_metrics_thresholds", value)

    @_builtins.property
    @pulumi.getter(name="turnLevelMetricsThresholds")
    def turn_level_metrics_thresholds(self) -> Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgs']]:
        """
        Turn level metrics thresholds.
        Structure is documented below.
        """
        return pulumi.get(self, "turn_level_metrics_thresholds")

    @turn_level_metrics_thresholds.setter
    def turn_level_metrics_thresholds(self, value: Optional[pulumi.Input['AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgs']]):
        pulumi.set(self, "turn_level_metrics_thresholds", value)


if not MYPY:
    class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgsDict(TypedDict):
        tool_invocation_parameter_correctness_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        The success threshold for individual tool invocation parameter
        correctness. Must be a float between 0 and 1. Default is 1.0.
        """
elif False:
    AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsExpectationLevelMetricsThresholdsArgs:
    def __init__(__self__, *,
                 tool_invocation_parameter_correctness_threshold: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.float] tool_invocation_parameter_correctness_threshold: The success threshold for individual tool invocation parameter
               correctness. Must be a float between 0 and 1. Default is 1.0.
        """
        if tool_invocation_parameter_correctness_threshold is not None:
            pulumi.set(__self__, "tool_invocation_parameter_correctness_threshold", tool_invocation_parameter_correctness_threshold)

    @_builtins.property
    @pulumi.getter(name="toolInvocationParameterCorrectnessThreshold")
    def tool_invocation_parameter_correctness_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The success threshold for individual tool invocation parameter
        correctness. Must be a float between 0 and 1. Default is 1.0.
        """
        return pulumi.get(self, "tool_invocation_parameter_correctness_threshold")

    @tool_invocation_parameter_correctness_threshold.setter
    def tool_invocation_parameter_correctness_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "tool_invocation_parameter_correctness_threshold", value)


if not MYPY:
    class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgsDict(TypedDict):
        overall_tool_invocation_correctness_threshold: NotRequired[pulumi.Input[_builtins.float]]
        """
        The success threshold for overall tool invocation correctness. Must be
        a float between 0 and 1. Default is 1.0.
        """
        semantic_similarity_success_threshold: NotRequired[pulumi.Input[_builtins.int]]
        """
        The success threshold for semantic similarity. Must be an integer
        between 0 and 4. Default is >= 3.
        """
elif False:
    AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppEvaluationMetricsThresholdsGoldenEvaluationMetricsThresholdsTurnLevelMetricsThresholdsArgs:
    def __init__(__self__, *,
                 overall_tool_invocation_correctness_threshold: Optional[pulumi.Input[_builtins.float]] = None,
                 semantic_similarity_success_threshold: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.float] overall_tool_invocation_correctness_threshold: The success threshold for overall tool invocation correctness. Must be
               a float between 0 and 1. Default is 1.0.
        :param pulumi.Input[_builtins.int] semantic_similarity_success_threshold: The success threshold for semantic similarity. Must be an integer
               between 0 and 4. Default is >= 3.
        """
        if overall_tool_invocation_correctness_threshold is not None:
            pulumi.set(__self__, "overall_tool_invocation_correctness_threshold", overall_tool_invocation_correctness_threshold)
        if semantic_similarity_success_threshold is not None:
            pulumi.set(__self__, "semantic_similarity_success_threshold", semantic_similarity_success_threshold)

    @_builtins.property
    @pulumi.getter(name="overallToolInvocationCorrectnessThreshold")
    def overall_tool_invocation_correctness_threshold(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The success threshold for overall tool invocation correctness. Must be
        a float between 0 and 1. Default is 1.0.
        """
        return pulumi.get(self, "overall_tool_invocation_correctness_threshold")

    @overall_tool_invocation_correctness_threshold.setter
    def overall_tool_invocation_correctness_threshold(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "overall_tool_invocation_correctness_threshold", value)

    @_builtins.property
    @pulumi.getter(name="semanticSimilaritySuccessThreshold")
    def semantic_similarity_success_threshold(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The success threshold for semantic similarity. Must be an integer
        between 0 and 4. Default is >= 3.
        """
        return pulumi.get(self, "semantic_similarity_success_threshold")

    @semantic_similarity_success_threshold.setter
    def semantic_similarity_success_threshold(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "semantic_similarity_success_threshold", value)


if not MYPY:
    class AppLanguageSettingsArgsDict(TypedDict):
        default_language_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        The default language code of the app.
        """
        enable_multilingual_support: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables multilingual support. If true, agents in the app will use pre-built
        instructions to improve handling of multilingual input.
        """
        fallback_action: NotRequired[pulumi.Input[_builtins.str]]
        """
        The action to perform when an agent receives input in an unsupported
        language.
        This can be a predefined action or a custom tool call.
        Valid values are:
        - A tool's full resource name, which triggers a specific tool execution.
        - A predefined system action, such as "escalate" or "exit", which triggers
        an EndSession signal with corresponding metadata
        to terminate the conversation.
        """
        supported_language_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of languages codes supported by the app, in addition to the
        `default_language_code`.
        """
elif False:
    AppLanguageSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLanguageSettingsArgs:
    def __init__(__self__, *,
                 default_language_code: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_multilingual_support: Optional[pulumi.Input[_builtins.bool]] = None,
                 fallback_action: Optional[pulumi.Input[_builtins.str]] = None,
                 supported_language_codes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] default_language_code: The default language code of the app.
        :param pulumi.Input[_builtins.bool] enable_multilingual_support: Enables multilingual support. If true, agents in the app will use pre-built
               instructions to improve handling of multilingual input.
        :param pulumi.Input[_builtins.str] fallback_action: The action to perform when an agent receives input in an unsupported
               language.
               This can be a predefined action or a custom tool call.
               Valid values are:
               - A tool's full resource name, which triggers a specific tool execution.
               - A predefined system action, such as "escalate" or "exit", which triggers
               an EndSession signal with corresponding metadata
               to terminate the conversation.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] supported_language_codes: List of languages codes supported by the app, in addition to the
               `default_language_code`.
        """
        if default_language_code is not None:
            pulumi.set(__self__, "default_language_code", default_language_code)
        if enable_multilingual_support is not None:
            pulumi.set(__self__, "enable_multilingual_support", enable_multilingual_support)
        if fallback_action is not None:
            pulumi.set(__self__, "fallback_action", fallback_action)
        if supported_language_codes is not None:
            pulumi.set(__self__, "supported_language_codes", supported_language_codes)

    @_builtins.property
    @pulumi.getter(name="defaultLanguageCode")
    def default_language_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The default language code of the app.
        """
        return pulumi.get(self, "default_language_code")

    @default_language_code.setter
    def default_language_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_language_code", value)

    @_builtins.property
    @pulumi.getter(name="enableMultilingualSupport")
    def enable_multilingual_support(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables multilingual support. If true, agents in the app will use pre-built
        instructions to improve handling of multilingual input.
        """
        return pulumi.get(self, "enable_multilingual_support")

    @enable_multilingual_support.setter
    def enable_multilingual_support(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_multilingual_support", value)

    @_builtins.property
    @pulumi.getter(name="fallbackAction")
    def fallback_action(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The action to perform when an agent receives input in an unsupported
        language.
        This can be a predefined action or a custom tool call.
        Valid values are:
        - A tool's full resource name, which triggers a specific tool execution.
        - A predefined system action, such as "escalate" or "exit", which triggers
        an EndSession signal with corresponding metadata
        to terminate the conversation.
        """
        return pulumi.get(self, "fallback_action")

    @fallback_action.setter
    def fallback_action(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "fallback_action", value)

    @_builtins.property
    @pulumi.getter(name="supportedLanguageCodes")
    def supported_language_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of languages codes supported by the app, in addition to the
        `default_language_code`.
        """
        return pulumi.get(self, "supported_language_codes")

    @supported_language_codes.setter
    def supported_language_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "supported_language_codes", value)


if not MYPY:
    class AppLoggingSettingsArgsDict(TypedDict):
        audio_recording_config: NotRequired[pulumi.Input['AppLoggingSettingsAudioRecordingConfigArgsDict']]
        """
        Configuration for how the audio interactions should be recorded.
        Structure is documented below.
        """
        bigquery_export_settings: NotRequired[pulumi.Input['AppLoggingSettingsBigqueryExportSettingsArgsDict']]
        """
        Settings to describe the BigQuery export behaviors for the app.
        Structure is documented below.
        """
        cloud_logging_settings: NotRequired[pulumi.Input['AppLoggingSettingsCloudLoggingSettingsArgsDict']]
        """
        Settings to describe the Cloud Logging behaviors for the app.
        Structure is documented below.
        """
        conversation_logging_settings: NotRequired[pulumi.Input['AppLoggingSettingsConversationLoggingSettingsArgsDict']]
        """
        Settings to describe the conversation logging behaviors for the app.
        Structure is documented below.
        """
        redaction_config: NotRequired[pulumi.Input['AppLoggingSettingsRedactionConfigArgsDict']]
        """
        Configuration to instruct how sensitive data should be handled.
        Structure is documented below.
        """
elif False:
    AppLoggingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLoggingSettingsArgs:
    def __init__(__self__, *,
                 audio_recording_config: Optional[pulumi.Input['AppLoggingSettingsAudioRecordingConfigArgs']] = None,
                 bigquery_export_settings: Optional[pulumi.Input['AppLoggingSettingsBigqueryExportSettingsArgs']] = None,
                 cloud_logging_settings: Optional[pulumi.Input['AppLoggingSettingsCloudLoggingSettingsArgs']] = None,
                 conversation_logging_settings: Optional[pulumi.Input['AppLoggingSettingsConversationLoggingSettingsArgs']] = None,
                 redaction_config: Optional[pulumi.Input['AppLoggingSettingsRedactionConfigArgs']] = None):
        """
        :param pulumi.Input['AppLoggingSettingsAudioRecordingConfigArgs'] audio_recording_config: Configuration for how the audio interactions should be recorded.
               Structure is documented below.
        :param pulumi.Input['AppLoggingSettingsBigqueryExportSettingsArgs'] bigquery_export_settings: Settings to describe the BigQuery export behaviors for the app.
               Structure is documented below.
        :param pulumi.Input['AppLoggingSettingsCloudLoggingSettingsArgs'] cloud_logging_settings: Settings to describe the Cloud Logging behaviors for the app.
               Structure is documented below.
        :param pulumi.Input['AppLoggingSettingsConversationLoggingSettingsArgs'] conversation_logging_settings: Settings to describe the conversation logging behaviors for the app.
               Structure is documented below.
        :param pulumi.Input['AppLoggingSettingsRedactionConfigArgs'] redaction_config: Configuration to instruct how sensitive data should be handled.
               Structure is documented below.
        """
        if audio_recording_config is not None:
            pulumi.set(__self__, "audio_recording_config", audio_recording_config)
        if bigquery_export_settings is not None:
            pulumi.set(__self__, "bigquery_export_settings", bigquery_export_settings)
        if cloud_logging_settings is not None:
            pulumi.set(__self__, "cloud_logging_settings", cloud_logging_settings)
        if conversation_logging_settings is not None:
            pulumi.set(__self__, "conversation_logging_settings", conversation_logging_settings)
        if redaction_config is not None:
            pulumi.set(__self__, "redaction_config", redaction_config)

    @_builtins.property
    @pulumi.getter(name="audioRecordingConfig")
    def audio_recording_config(self) -> Optional[pulumi.Input['AppLoggingSettingsAudioRecordingConfigArgs']]:
        """
        Configuration for how the audio interactions should be recorded.
        Structure is documented below.
        """
        return pulumi.get(self, "audio_recording_config")

    @audio_recording_config.setter
    def audio_recording_config(self, value: Optional[pulumi.Input['AppLoggingSettingsAudioRecordingConfigArgs']]):
        pulumi.set(self, "audio_recording_config", value)

    @_builtins.property
    @pulumi.getter(name="bigqueryExportSettings")
    def bigquery_export_settings(self) -> Optional[pulumi.Input['AppLoggingSettingsBigqueryExportSettingsArgs']]:
        """
        Settings to describe the BigQuery export behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "bigquery_export_settings")

    @bigquery_export_settings.setter
    def bigquery_export_settings(self, value: Optional[pulumi.Input['AppLoggingSettingsBigqueryExportSettingsArgs']]):
        pulumi.set(self, "bigquery_export_settings", value)

    @_builtins.property
    @pulumi.getter(name="cloudLoggingSettings")
    def cloud_logging_settings(self) -> Optional[pulumi.Input['AppLoggingSettingsCloudLoggingSettingsArgs']]:
        """
        Settings to describe the Cloud Logging behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_logging_settings")

    @cloud_logging_settings.setter
    def cloud_logging_settings(self, value: Optional[pulumi.Input['AppLoggingSettingsCloudLoggingSettingsArgs']]):
        pulumi.set(self, "cloud_logging_settings", value)

    @_builtins.property
    @pulumi.getter(name="conversationLoggingSettings")
    def conversation_logging_settings(self) -> Optional[pulumi.Input['AppLoggingSettingsConversationLoggingSettingsArgs']]:
        """
        Settings to describe the conversation logging behaviors for the app.
        Structure is documented below.
        """
        return pulumi.get(self, "conversation_logging_settings")

    @conversation_logging_settings.setter
    def conversation_logging_settings(self, value: Optional[pulumi.Input['AppLoggingSettingsConversationLoggingSettingsArgs']]):
        pulumi.set(self, "conversation_logging_settings", value)

    @_builtins.property
    @pulumi.getter(name="redactionConfig")
    def redaction_config(self) -> Optional[pulumi.Input['AppLoggingSettingsRedactionConfigArgs']]:
        """
        Configuration to instruct how sensitive data should be handled.
        Structure is documented below.
        """
        return pulumi.get(self, "redaction_config")

    @redaction_config.setter
    def redaction_config(self, value: Optional[pulumi.Input['AppLoggingSettingsRedactionConfigArgs']]):
        pulumi.set(self, "redaction_config", value)


if not MYPY:
    class AppLoggingSettingsAudioRecordingConfigArgsDict(TypedDict):
        gcs_bucket: NotRequired[pulumi.Input[_builtins.str]]
        """
        The [Cloud Storage](https://cloud.google.com/storage) bucket to store the
        session audio recordings. The URI must start with "gs://".
        Note: If the Cloud Storage bucket is in a different project from the app,
        you should grant `storage.objects.create` permission to the CES service
        agent `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        gcs_path_prefix: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Cloud Storage path prefix for audio recordings.
        This prefix can include the following placeholders, which will be
        dynamically substituted at serving time:
        - $project:   project ID
        - $location:  app location
        - $app:       app ID
        - $date:      session date in YYYY-MM-DD format
        - $session:   session ID
        If the path prefix is not specified, the default prefix
        `$project/$location/$app/$date/$session/` will be used.
        """
elif False:
    AppLoggingSettingsAudioRecordingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLoggingSettingsAudioRecordingConfigArgs:
    def __init__(__self__, *,
                 gcs_bucket: Optional[pulumi.Input[_builtins.str]] = None,
                 gcs_path_prefix: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] gcs_bucket: The [Cloud Storage](https://cloud.google.com/storage) bucket to store the
               session audio recordings. The URI must start with "gs://".
               Note: If the Cloud Storage bucket is in a different project from the app,
               you should grant `storage.objects.create` permission to the CES service
               agent `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param pulumi.Input[_builtins.str] gcs_path_prefix: The Cloud Storage path prefix for audio recordings.
               This prefix can include the following placeholders, which will be
               dynamically substituted at serving time:
               - $project:   project ID
               - $location:  app location
               - $app:       app ID
               - $date:      session date in YYYY-MM-DD format
               - $session:   session ID
               If the path prefix is not specified, the default prefix
               `$project/$location/$app/$date/$session/` will be used.
        """
        if gcs_bucket is not None:
            pulumi.set(__self__, "gcs_bucket", gcs_bucket)
        if gcs_path_prefix is not None:
            pulumi.set(__self__, "gcs_path_prefix", gcs_path_prefix)

    @_builtins.property
    @pulumi.getter(name="gcsBucket")
    def gcs_bucket(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The [Cloud Storage](https://cloud.google.com/storage) bucket to store the
        session audio recordings. The URI must start with "gs://".
        Note: If the Cloud Storage bucket is in a different project from the app,
        you should grant `storage.objects.create` permission to the CES service
        agent `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "gcs_bucket")

    @gcs_bucket.setter
    def gcs_bucket(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gcs_bucket", value)

    @_builtins.property
    @pulumi.getter(name="gcsPathPrefix")
    def gcs_path_prefix(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Cloud Storage path prefix for audio recordings.
        This prefix can include the following placeholders, which will be
        dynamically substituted at serving time:
        - $project:   project ID
        - $location:  app location
        - $app:       app ID
        - $date:      session date in YYYY-MM-DD format
        - $session:   session ID
        If the path prefix is not specified, the default prefix
        `$project/$location/$app/$date/$session/` will be used.
        """
        return pulumi.get(self, "gcs_path_prefix")

    @gcs_path_prefix.setter
    def gcs_path_prefix(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gcs_path_prefix", value)


if not MYPY:
    class AppLoggingSettingsBigqueryExportSettingsArgsDict(TypedDict):
        dataset: NotRequired[pulumi.Input[_builtins.str]]
        """
        The BigQuery dataset to export the data to.
        """
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the BigQuery export is enabled.
        """
        project: NotRequired[pulumi.Input[_builtins.str]]
        """
        The project ID of the BigQuery dataset to export the data to.
        Note: If the BigQuery dataset is in a different project from the app, you should grant
        roles/bigquery.admin role to the CES service agent service-<PROJECT-
        NUMBER>@gcp-sa-ces.iam.gserviceaccount.com.
        """
elif False:
    AppLoggingSettingsBigqueryExportSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLoggingSettingsBigqueryExportSettingsArgs:
    def __init__(__self__, *,
                 dataset: Optional[pulumi.Input[_builtins.str]] = None,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 project: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dataset: The BigQuery dataset to export the data to.
        :param pulumi.Input[_builtins.bool] enabled: Indicates whether the BigQuery export is enabled.
        :param pulumi.Input[_builtins.str] project: The project ID of the BigQuery dataset to export the data to.
               Note: If the BigQuery dataset is in a different project from the app, you should grant
               roles/bigquery.admin role to the CES service agent service-<PROJECT-
               NUMBER>@gcp-sa-ces.iam.gserviceaccount.com.
        """
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if project is not None:
            pulumi.set(__self__, "project", project)

    @_builtins.property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The BigQuery dataset to export the data to.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dataset", value)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the BigQuery export is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The project ID of the BigQuery dataset to export the data to.
        Note: If the BigQuery dataset is in a different project from the app, you should grant
        roles/bigquery.admin role to the CES service agent service-<PROJECT-
        NUMBER>@gcp-sa-ces.iam.gserviceaccount.com.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project", value)


if not MYPY:
    class AppLoggingSettingsCloudLoggingSettingsArgsDict(TypedDict):
        enable_cloud_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to enable Cloud Logging for the sessions.
        """
elif False:
    AppLoggingSettingsCloudLoggingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLoggingSettingsCloudLoggingSettingsArgs:
    def __init__(__self__, *,
                 enable_cloud_logging: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_cloud_logging: Whether to enable Cloud Logging for the sessions.
        """
        if enable_cloud_logging is not None:
            pulumi.set(__self__, "enable_cloud_logging", enable_cloud_logging)

    @_builtins.property
    @pulumi.getter(name="enableCloudLogging")
    def enable_cloud_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to enable Cloud Logging for the sessions.
        """
        return pulumi.get(self, "enable_cloud_logging")

    @enable_cloud_logging.setter
    def enable_cloud_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_cloud_logging", value)


if not MYPY:
    class AppLoggingSettingsConversationLoggingSettingsArgsDict(TypedDict):
        disable_conversation_logging: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable conversation logging for the sessions.
        """
elif False:
    AppLoggingSettingsConversationLoggingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLoggingSettingsConversationLoggingSettingsArgs:
    def __init__(__self__, *,
                 disable_conversation_logging: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] disable_conversation_logging: Whether to disable conversation logging for the sessions.
        """
        if disable_conversation_logging is not None:
            pulumi.set(__self__, "disable_conversation_logging", disable_conversation_logging)

    @_builtins.property
    @pulumi.getter(name="disableConversationLogging")
    def disable_conversation_logging(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable conversation logging for the sessions.
        """
        return pulumi.get(self, "disable_conversation_logging")

    @disable_conversation_logging.setter
    def disable_conversation_logging(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_conversation_logging", value)


if not MYPY:
    class AppLoggingSettingsRedactionConfigArgsDict(TypedDict):
        deidentify_template: NotRequired[pulumi.Input[_builtins.str]]
        """
        [DLP](https://cloud.google.com/dlp/docs) deidentify template name to
        instruct on how to de-identify content.
        Format:
        `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
        """
        enable_redaction: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, redaction will be applied in various logging scenarios, including
        conversation history, Cloud Logging and audio recording.
        """
        inspect_template: NotRequired[pulumi.Input[_builtins.str]]
        """
        [DLP](https://cloud.google.com/dlp/docs) inspect template name to configure
        detection of sensitive data types.
        Format:
        `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
        """
elif False:
    AppLoggingSettingsRedactionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppLoggingSettingsRedactionConfigArgs:
    def __init__(__self__, *,
                 deidentify_template: Optional[pulumi.Input[_builtins.str]] = None,
                 enable_redaction: Optional[pulumi.Input[_builtins.bool]] = None,
                 inspect_template: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] deidentify_template: [DLP](https://cloud.google.com/dlp/docs) deidentify template name to
               instruct on how to de-identify content.
               Format:
               `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
        :param pulumi.Input[_builtins.bool] enable_redaction: If true, redaction will be applied in various logging scenarios, including
               conversation history, Cloud Logging and audio recording.
        :param pulumi.Input[_builtins.str] inspect_template: [DLP](https://cloud.google.com/dlp/docs) inspect template name to configure
               detection of sensitive data types.
               Format:
               `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
        """
        if deidentify_template is not None:
            pulumi.set(__self__, "deidentify_template", deidentify_template)
        if enable_redaction is not None:
            pulumi.set(__self__, "enable_redaction", enable_redaction)
        if inspect_template is not None:
            pulumi.set(__self__, "inspect_template", inspect_template)

    @_builtins.property
    @pulumi.getter(name="deidentifyTemplate")
    def deidentify_template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        [DLP](https://cloud.google.com/dlp/docs) deidentify template name to
        instruct on how to de-identify content.
        Format:
        `projects/{project}/locations/{location}/deidentifyTemplates/{deidentify_template}`
        """
        return pulumi.get(self, "deidentify_template")

    @deidentify_template.setter
    def deidentify_template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deidentify_template", value)

    @_builtins.property
    @pulumi.getter(name="enableRedaction")
    def enable_redaction(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, redaction will be applied in various logging scenarios, including
        conversation history, Cloud Logging and audio recording.
        """
        return pulumi.get(self, "enable_redaction")

    @enable_redaction.setter
    def enable_redaction(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_redaction", value)

    @_builtins.property
    @pulumi.getter(name="inspectTemplate")
    def inspect_template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        [DLP](https://cloud.google.com/dlp/docs) inspect template name to configure
        detection of sensitive data types.
        Format:
        `projects/{project}/locations/{location}/inspectTemplates/{inspect_template}`
        """
        return pulumi.get(self, "inspect_template")

    @inspect_template.setter
    def inspect_template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "inspect_template", value)


if not MYPY:
    class AppModelSettingsArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
elif False:
    AppModelSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppModelSettingsArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] model: The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param pulumi.Input[_builtins.float] temperature: If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)


if not MYPY:
    class AppTimeZoneSettingsArgsDict(TypedDict):
        time_zone: NotRequired[pulumi.Input[_builtins.str]]
        """
        The time zone of the app from the time zone database, e.g., America/Los_Angeles, Europe/Paris.
        """
elif False:
    AppTimeZoneSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppTimeZoneSettingsArgs:
    def __init__(__self__, *,
                 time_zone: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] time_zone: The time zone of the app from the time zone database, e.g., America/Los_Angeles, Europe/Paris.
        """
        if time_zone is not None:
            pulumi.set(__self__, "time_zone", time_zone)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The time zone of the app from the time zone database, e.g., America/Los_Angeles, Europe/Paris.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_zone", value)


if not MYPY:
    class AppVariableDeclarationArgsDict(TypedDict):
        description: pulumi.Input[_builtins.str]
        """
        The description of the variable.
        """
        name: pulumi.Input[_builtins.str]
        """
        The name of the variable. The name must start with a letter or underscore
        and contain only letters, numbers, or underscores.
        """
        schema: pulumi.Input['AppVariableDeclarationSchemaArgsDict']
        """
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
elif False:
    AppVariableDeclarationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVariableDeclarationArgs:
    def __init__(__self__, *,
                 description: pulumi.Input[_builtins.str],
                 name: pulumi.Input[_builtins.str],
                 schema: pulumi.Input['AppVariableDeclarationSchemaArgs']):
        """
        :param pulumi.Input[_builtins.str] description: The description of the variable.
        :param pulumi.Input[_builtins.str] name: The name of the variable. The name must start with a letter or underscore
               and contain only letters, numbers, or underscores.
        :param pulumi.Input['AppVariableDeclarationSchemaArgs'] schema: Represents a select subset of an OpenAPI 3.0 schema object.
               Structure is documented below.
        """
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schema", schema)

    @_builtins.property
    @pulumi.getter
    def description(self) -> pulumi.Input[_builtins.str]:
        """
        The description of the variable.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the variable. The name must start with a letter or underscore
        and contain only letters, numbers, or underscores.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> pulumi.Input['AppVariableDeclarationSchemaArgs']:
        """
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input['AppVariableDeclarationSchemaArgs']):
        pulumi.set(self, "schema", value)


if not MYPY:
    class AppVariableDeclarationSchemaArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of the data.
        Possible values:
        STRING
        INTEGER
        NUMBER
        BOOLEAN
        OBJECT
        ARRAY
        """
        additional_properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        any_of: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        default: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        defs: NotRequired[pulumi.Input[_builtins.str]]
        """
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the data.
        """
        enums: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        items: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema of the elements of Type.ARRAY.
        """
        nullable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the value may be null.
        """
        prefix_items: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        Properties of Type.OBJECT.
        """
        ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        requireds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Required properties of Type.OBJECT.
        """
        unique_items: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
elif False:
    AppVariableDeclarationSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppVariableDeclarationSchemaArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 additional_properties: Optional[pulumi.Input[_builtins.str]] = None,
                 any_of: Optional[pulumi.Input[_builtins.str]] = None,
                 default: Optional[pulumi.Input[_builtins.str]] = None,
                 defs: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enums: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 items: Optional[pulumi.Input[_builtins.str]] = None,
                 nullable: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix_items: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[_builtins.str]] = None,
                 ref: Optional[pulumi.Input[_builtins.str]] = None,
                 requireds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 unique_items: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of the data.
               Possible values:
               STRING
               INTEGER
               NUMBER
               BOOLEAN
               OBJECT
               ARRAY
        :param pulumi.Input[_builtins.str] additional_properties: Optional. Defines the schema for additional properties allowed in an object.
               The value must be a valid JSON string representing the Schema object.
               (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        :param pulumi.Input[_builtins.str] any_of: Optional. The instance value should be valid against at least one of the schemas in this list.
        :param pulumi.Input[_builtins.str] default: Optional. Default value of the data. Represents a dynamically typed value
               which can be either null, a number, a string, a boolean, a struct,
               or a list of values. The provided default value must be compatible
               with the defined 'type' and other schema constraints.
        :param pulumi.Input[_builtins.str] defs: A map of definitions for use by ref. Only allowed at the root of the schema.
        :param pulumi.Input[_builtins.str] description: The description of the data.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enums: Possible values of the element of primitive type with enum format.
               Examples:
               1. We can define direction as :
               {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
               2. We can define apartment number as :
               {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        :param pulumi.Input[_builtins.str] items: Schema of the elements of Type.ARRAY.
        :param pulumi.Input[_builtins.bool] nullable: Indicates if the value may be null.
        :param pulumi.Input[_builtins.str] prefix_items: Optional. Schemas of initial elements of Type.ARRAY.
        :param pulumi.Input[_builtins.str] properties: Properties of Type.OBJECT.
        :param pulumi.Input[_builtins.str] ref: Allows indirect references between schema nodes. The value should be a
               valid reference to a child of the root `defs`.
               For example, the following schema defines a reference to a schema node
               named "Pet":
               type: object
               properties:
               pet:
               ref: #/defs/Pet
               defs:
               Pet:
               type: object
               properties:
               name:
               type: string
               The value of the "pet" property is a reference to the schema node
               named "Pet".
               See details in
               https://json-schema.org/understanding-json-schema/structuring.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] requireds: Required properties of Type.OBJECT.
        :param pulumi.Input[_builtins.bool] unique_items: Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        pulumi.set(__self__, "type", type)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if any_of is not None:
            pulumi.set(__self__, "any_of", any_of)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if defs is not None:
            pulumi.set(__self__, "defs", defs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enums is not None:
            pulumi.set(__self__, "enums", enums)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if prefix_items is not None:
            pulumi.set(__self__, "prefix_items", prefix_items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if requireds is not None:
            pulumi.set(__self__, "requireds", requireds)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the data.
        Possible values:
        STRING
        INTEGER
        NUMBER
        BOOLEAN
        OBJECT
        ARRAY
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_properties", value)

    @_builtins.property
    @pulumi.getter(name="anyOf")
    def any_of(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        return pulumi.get(self, "any_of")

    @any_of.setter
    def any_of(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "any_of", value)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def defs(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        return pulumi.get(self, "defs")

    @defs.setter
    def defs(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "defs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the data.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def enums(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        return pulumi.get(self, "enums")

    @enums.setter
    def enums(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enums", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema of the elements of Type.ARRAY.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the value may be null.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "nullable", value)

    @_builtins.property
    @pulumi.getter(name="prefixItems")
    def prefix_items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        return pulumi.get(self, "prefix_items")

    @prefix_items.setter
    def prefix_items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_items", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Properties of Type.OBJECT.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ref", value)

    @_builtins.property
    @pulumi.getter
    def requireds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Required properties of Type.OBJECT.
        """
        return pulumi.get(self, "requireds")

    @requireds.setter
    def requireds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "requireds", value)

    @_builtins.property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        return pulumi.get(self, "unique_items")

    @unique_items.setter
    def unique_items(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unique_items", value)


if not MYPY:
    class DeploymentChannelProfileArgsDict(TypedDict):
        channel_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of the channel profile.
        Possible values:
        UNKNOWN
        WEB_UI
        API
        TWILIO
        GOOGLE_TELEPHONY_PLATFORM
        CONTACT_CENTER_AS_A_SERVICE
        """
        disable_barge_in_control: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable user barge-in control in the conversation.
        - **true**: User interruptions are disabled while the agent is speaking.
        - **false**: The agent retains automatic control over when the user can
        interrupt.
        """
        disable_dtmf: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to disable DTMF (dual-tone multi-frequency).
        """
        persona_property: NotRequired[pulumi.Input['DeploymentChannelProfilePersonaPropertyArgsDict']]
        """
        Represents the persona property of a channel.
        Structure is documented below.
        """
        profile_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The unique identifier of the channel profile.
        """
        web_widget_config: NotRequired[pulumi.Input['DeploymentChannelProfileWebWidgetConfigArgsDict']]
        """
        Message for configuration for the web widget.
        Structure is documented below.
        """
elif False:
    DeploymentChannelProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentChannelProfileArgs:
    def __init__(__self__, *,
                 channel_type: Optional[pulumi.Input[_builtins.str]] = None,
                 disable_barge_in_control: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_dtmf: Optional[pulumi.Input[_builtins.bool]] = None,
                 persona_property: Optional[pulumi.Input['DeploymentChannelProfilePersonaPropertyArgs']] = None,
                 profile_id: Optional[pulumi.Input[_builtins.str]] = None,
                 web_widget_config: Optional[pulumi.Input['DeploymentChannelProfileWebWidgetConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] channel_type: The type of the channel profile.
               Possible values:
               UNKNOWN
               WEB_UI
               API
               TWILIO
               GOOGLE_TELEPHONY_PLATFORM
               CONTACT_CENTER_AS_A_SERVICE
        :param pulumi.Input[_builtins.bool] disable_barge_in_control: Whether to disable user barge-in control in the conversation.
               - **true**: User interruptions are disabled while the agent is speaking.
               - **false**: The agent retains automatic control over when the user can
               interrupt.
        :param pulumi.Input[_builtins.bool] disable_dtmf: Whether to disable DTMF (dual-tone multi-frequency).
        :param pulumi.Input['DeploymentChannelProfilePersonaPropertyArgs'] persona_property: Represents the persona property of a channel.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] profile_id: The unique identifier of the channel profile.
        :param pulumi.Input['DeploymentChannelProfileWebWidgetConfigArgs'] web_widget_config: Message for configuration for the web widget.
               Structure is documented below.
        """
        if channel_type is not None:
            pulumi.set(__self__, "channel_type", channel_type)
        if disable_barge_in_control is not None:
            pulumi.set(__self__, "disable_barge_in_control", disable_barge_in_control)
        if disable_dtmf is not None:
            pulumi.set(__self__, "disable_dtmf", disable_dtmf)
        if persona_property is not None:
            pulumi.set(__self__, "persona_property", persona_property)
        if profile_id is not None:
            pulumi.set(__self__, "profile_id", profile_id)
        if web_widget_config is not None:
            pulumi.set(__self__, "web_widget_config", web_widget_config)

    @_builtins.property
    @pulumi.getter(name="channelType")
    def channel_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of the channel profile.
        Possible values:
        UNKNOWN
        WEB_UI
        API
        TWILIO
        GOOGLE_TELEPHONY_PLATFORM
        CONTACT_CENTER_AS_A_SERVICE
        """
        return pulumi.get(self, "channel_type")

    @channel_type.setter
    def channel_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "channel_type", value)

    @_builtins.property
    @pulumi.getter(name="disableBargeInControl")
    def disable_barge_in_control(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable user barge-in control in the conversation.
        - **true**: User interruptions are disabled while the agent is speaking.
        - **false**: The agent retains automatic control over when the user can
        interrupt.
        """
        return pulumi.get(self, "disable_barge_in_control")

    @disable_barge_in_control.setter
    def disable_barge_in_control(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_barge_in_control", value)

    @_builtins.property
    @pulumi.getter(name="disableDtmf")
    def disable_dtmf(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to disable DTMF (dual-tone multi-frequency).
        """
        return pulumi.get(self, "disable_dtmf")

    @disable_dtmf.setter
    def disable_dtmf(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_dtmf", value)

    @_builtins.property
    @pulumi.getter(name="personaProperty")
    def persona_property(self) -> Optional[pulumi.Input['DeploymentChannelProfilePersonaPropertyArgs']]:
        """
        Represents the persona property of a channel.
        Structure is documented below.
        """
        return pulumi.get(self, "persona_property")

    @persona_property.setter
    def persona_property(self, value: Optional[pulumi.Input['DeploymentChannelProfilePersonaPropertyArgs']]):
        pulumi.set(self, "persona_property", value)

    @_builtins.property
    @pulumi.getter(name="profileId")
    def profile_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The unique identifier of the channel profile.
        """
        return pulumi.get(self, "profile_id")

    @profile_id.setter
    def profile_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "profile_id", value)

    @_builtins.property
    @pulumi.getter(name="webWidgetConfig")
    def web_widget_config(self) -> Optional[pulumi.Input['DeploymentChannelProfileWebWidgetConfigArgs']]:
        """
        Message for configuration for the web widget.
        Structure is documented below.
        """
        return pulumi.get(self, "web_widget_config")

    @web_widget_config.setter
    def web_widget_config(self, value: Optional[pulumi.Input['DeploymentChannelProfileWebWidgetConfigArgs']]):
        pulumi.set(self, "web_widget_config", value)


if not MYPY:
    class DeploymentChannelProfilePersonaPropertyArgsDict(TypedDict):
        persona: NotRequired[pulumi.Input[_builtins.str]]
        """
        The persona of the channel.
        Possible values:
        UNKNOWN
        CONCISE
        CHATTY
        """
elif False:
    DeploymentChannelProfilePersonaPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentChannelProfilePersonaPropertyArgs:
    def __init__(__self__, *,
                 persona: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] persona: The persona of the channel.
               Possible values:
               UNKNOWN
               CONCISE
               CHATTY
        """
        if persona is not None:
            pulumi.set(__self__, "persona", persona)

    @_builtins.property
    @pulumi.getter
    def persona(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The persona of the channel.
        Possible values:
        UNKNOWN
        CONCISE
        CHATTY
        """
        return pulumi.get(self, "persona")

    @persona.setter
    def persona(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "persona", value)


if not MYPY:
    class DeploymentChannelProfileWebWidgetConfigArgsDict(TypedDict):
        modality: NotRequired[pulumi.Input[_builtins.str]]
        """
        The modality of the web widget.
        Possible values:
        UNKNOWN_MODALITY
        CHAT_AND_VOICE
        VOICE_ONLY
        CHAT_ONLY
        """
        theme: NotRequired[pulumi.Input[_builtins.str]]
        """
        The theme of the web widget.
        Possible values:
        UNKNOWN_THEME
        LIGHT
        DARK
        """
        web_widget_title: NotRequired[pulumi.Input[_builtins.str]]
        """
        The title of the web widget.
        """
elif False:
    DeploymentChannelProfileWebWidgetConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeploymentChannelProfileWebWidgetConfigArgs:
    def __init__(__self__, *,
                 modality: Optional[pulumi.Input[_builtins.str]] = None,
                 theme: Optional[pulumi.Input[_builtins.str]] = None,
                 web_widget_title: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] modality: The modality of the web widget.
               Possible values:
               UNKNOWN_MODALITY
               CHAT_AND_VOICE
               VOICE_ONLY
               CHAT_ONLY
        :param pulumi.Input[_builtins.str] theme: The theme of the web widget.
               Possible values:
               UNKNOWN_THEME
               LIGHT
               DARK
        :param pulumi.Input[_builtins.str] web_widget_title: The title of the web widget.
        """
        if modality is not None:
            pulumi.set(__self__, "modality", modality)
        if theme is not None:
            pulumi.set(__self__, "theme", theme)
        if web_widget_title is not None:
            pulumi.set(__self__, "web_widget_title", web_widget_title)

    @_builtins.property
    @pulumi.getter
    def modality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The modality of the web widget.
        Possible values:
        UNKNOWN_MODALITY
        CHAT_AND_VOICE
        VOICE_ONLY
        CHAT_ONLY
        """
        return pulumi.get(self, "modality")

    @modality.setter
    def modality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "modality", value)

    @_builtins.property
    @pulumi.getter
    def theme(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The theme of the web widget.
        Possible values:
        UNKNOWN_THEME
        LIGHT
        DARK
        """
        return pulumi.get(self, "theme")

    @theme.setter
    def theme(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "theme", value)

    @_builtins.property
    @pulumi.getter(name="webWidgetTitle")
    def web_widget_title(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The title of the web widget.
        """
        return pulumi.get(self, "web_widget_title")

    @web_widget_title.setter
    def web_widget_title(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "web_widget_title", value)


if not MYPY:
    class ExampleMessageArgsDict(TypedDict):
        chunks: NotRequired[pulumi.Input[Sequence[pulumi.Input['ExampleMessageChunkArgsDict']]]]
        """
        Content of the message as a series of chunks.
        Structure is documented below.
        """
        role: NotRequired[pulumi.Input[_builtins.str]]
        """
        The role within the conversation, e.g., user, agent.
        """
elif False:
    ExampleMessageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExampleMessageArgs:
    def __init__(__self__, *,
                 chunks: Optional[pulumi.Input[Sequence[pulumi.Input['ExampleMessageChunkArgs']]]] = None,
                 role: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ExampleMessageChunkArgs']]] chunks: Content of the message as a series of chunks.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] role: The role within the conversation, e.g., user, agent.
        """
        if chunks is not None:
            pulumi.set(__self__, "chunks", chunks)
        if role is not None:
            pulumi.set(__self__, "role", role)

    @_builtins.property
    @pulumi.getter
    def chunks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ExampleMessageChunkArgs']]]]:
        """
        Content of the message as a series of chunks.
        Structure is documented below.
        """
        return pulumi.get(self, "chunks")

    @chunks.setter
    def chunks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ExampleMessageChunkArgs']]]]):
        pulumi.set(self, "chunks", value)

    @_builtins.property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The role within the conversation, e.g., user, agent.
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "role", value)


if not MYPY:
    class ExampleMessageChunkArgsDict(TypedDict):
        image: NotRequired[pulumi.Input['ExampleMessageChunkImageArgsDict']]
        """
        Represents an image input or output in the conversation.
        Structure is documented below.
        """
        text: NotRequired[pulumi.Input[_builtins.str]]
        """
        Text data.
        """
        updated_variables: NotRequired[pulumi.Input[_builtins.str]]
        """
        A struct represents variables that were updated in the conversation,
        keyed by variable names.
        """
elif False:
    ExampleMessageChunkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExampleMessageChunkArgs:
    def __init__(__self__, *,
                 image: Optional[pulumi.Input['ExampleMessageChunkImageArgs']] = None,
                 text: Optional[pulumi.Input[_builtins.str]] = None,
                 updated_variables: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ExampleMessageChunkImageArgs'] image: Represents an image input or output in the conversation.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] text: Text data.
        :param pulumi.Input[_builtins.str] updated_variables: A struct represents variables that were updated in the conversation,
               keyed by variable names.
        """
        if image is not None:
            pulumi.set(__self__, "image", image)
        if text is not None:
            pulumi.set(__self__, "text", text)
        if updated_variables is not None:
            pulumi.set(__self__, "updated_variables", updated_variables)

    @_builtins.property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input['ExampleMessageChunkImageArgs']]:
        """
        Represents an image input or output in the conversation.
        Structure is documented below.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input['ExampleMessageChunkImageArgs']]):
        pulumi.set(self, "image", value)

    @_builtins.property
    @pulumi.getter
    def text(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Text data.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter(name="updatedVariables")
    def updated_variables(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A struct represents variables that were updated in the conversation,
        keyed by variable names.
        """
        return pulumi.get(self, "updated_variables")

    @updated_variables.setter
    def updated_variables(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "updated_variables", value)


if not MYPY:
    class ExampleMessageChunkImageArgsDict(TypedDict):
        data: pulumi.Input[_builtins.str]
        """
        Raw bytes of the image.
        """
        mime_type: pulumi.Input[_builtins.str]
        """
        The IANA standard MIME type of the source data.
        Supported image types includes:
        * image/png
        * image/jpeg
        * image/webp
        """
elif False:
    ExampleMessageChunkImageArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExampleMessageChunkImageArgs:
    def __init__(__self__, *,
                 data: pulumi.Input[_builtins.str],
                 mime_type: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] data: Raw bytes of the image.
        :param pulumi.Input[_builtins.str] mime_type: The IANA standard MIME type of the source data.
               Supported image types includes:
               * image/png
               * image/jpeg
               * image/webp
        """
        pulumi.set(__self__, "data", data)
        pulumi.set(__self__, "mime_type", mime_type)

    @_builtins.property
    @pulumi.getter
    def data(self) -> pulumi.Input[_builtins.str]:
        """
        Raw bytes of the image.
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "data", value)

    @_builtins.property
    @pulumi.getter(name="mimeType")
    def mime_type(self) -> pulumi.Input[_builtins.str]:
        """
        The IANA standard MIME type of the source data.
        Supported image types includes:
        * image/png
        * image/jpeg
        * image/webp
        """
        return pulumi.get(self, "mime_type")

    @mime_type.setter
    def mime_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mime_type", value)


if not MYPY:
    class GuardrailActionArgsDict(TypedDict):
        generative_answer: NotRequired[pulumi.Input['GuardrailActionGenerativeAnswerArgsDict']]
        """
        The agent will immediately respond with a generative answer.
        Structure is documented below.
        """
        respond_immediately: NotRequired[pulumi.Input['GuardrailActionRespondImmediatelyArgsDict']]
        """
        The agent will immediately respond with a preconfigured response.
        Structure is documented below.
        """
        transfer_agent: NotRequired[pulumi.Input['GuardrailActionTransferAgentArgsDict']]
        """
        The agent will transfer the conversation to a different agent.
        Structure is documented below.
        """
elif False:
    GuardrailActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailActionArgs:
    def __init__(__self__, *,
                 generative_answer: Optional[pulumi.Input['GuardrailActionGenerativeAnswerArgs']] = None,
                 respond_immediately: Optional[pulumi.Input['GuardrailActionRespondImmediatelyArgs']] = None,
                 transfer_agent: Optional[pulumi.Input['GuardrailActionTransferAgentArgs']] = None):
        """
        :param pulumi.Input['GuardrailActionGenerativeAnswerArgs'] generative_answer: The agent will immediately respond with a generative answer.
               Structure is documented below.
        :param pulumi.Input['GuardrailActionRespondImmediatelyArgs'] respond_immediately: The agent will immediately respond with a preconfigured response.
               Structure is documented below.
        :param pulumi.Input['GuardrailActionTransferAgentArgs'] transfer_agent: The agent will transfer the conversation to a different agent.
               Structure is documented below.
        """
        if generative_answer is not None:
            pulumi.set(__self__, "generative_answer", generative_answer)
        if respond_immediately is not None:
            pulumi.set(__self__, "respond_immediately", respond_immediately)
        if transfer_agent is not None:
            pulumi.set(__self__, "transfer_agent", transfer_agent)

    @_builtins.property
    @pulumi.getter(name="generativeAnswer")
    def generative_answer(self) -> Optional[pulumi.Input['GuardrailActionGenerativeAnswerArgs']]:
        """
        The agent will immediately respond with a generative answer.
        Structure is documented below.
        """
        return pulumi.get(self, "generative_answer")

    @generative_answer.setter
    def generative_answer(self, value: Optional[pulumi.Input['GuardrailActionGenerativeAnswerArgs']]):
        pulumi.set(self, "generative_answer", value)

    @_builtins.property
    @pulumi.getter(name="respondImmediately")
    def respond_immediately(self) -> Optional[pulumi.Input['GuardrailActionRespondImmediatelyArgs']]:
        """
        The agent will immediately respond with a preconfigured response.
        Structure is documented below.
        """
        return pulumi.get(self, "respond_immediately")

    @respond_immediately.setter
    def respond_immediately(self, value: Optional[pulumi.Input['GuardrailActionRespondImmediatelyArgs']]):
        pulumi.set(self, "respond_immediately", value)

    @_builtins.property
    @pulumi.getter(name="transferAgent")
    def transfer_agent(self) -> Optional[pulumi.Input['GuardrailActionTransferAgentArgs']]:
        """
        The agent will transfer the conversation to a different agent.
        Structure is documented below.
        """
        return pulumi.get(self, "transfer_agent")

    @transfer_agent.setter
    def transfer_agent(self, value: Optional[pulumi.Input['GuardrailActionTransferAgentArgs']]):
        pulumi.set(self, "transfer_agent", value)


if not MYPY:
    class GuardrailActionGenerativeAnswerArgsDict(TypedDict):
        prompt: pulumi.Input[_builtins.str]
        """
        The prompt to use for the generative answer.
        """
elif False:
    GuardrailActionGenerativeAnswerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailActionGenerativeAnswerArgs:
    def __init__(__self__, *,
                 prompt: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] prompt: The prompt to use for the generative answer.
        """
        pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> pulumi.Input[_builtins.str]:
        """
        The prompt to use for the generative answer.
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prompt", value)


if not MYPY:
    class GuardrailActionRespondImmediatelyArgsDict(TypedDict):
        responses: pulumi.Input[Sequence[pulumi.Input['GuardrailActionRespondImmediatelyResponseArgsDict']]]
        """
        The canned responses for the agent to choose from. The response is chosen
        randomly.
        Structure is documented below.
        """
elif False:
    GuardrailActionRespondImmediatelyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailActionRespondImmediatelyArgs:
    def __init__(__self__, *,
                 responses: pulumi.Input[Sequence[pulumi.Input['GuardrailActionRespondImmediatelyResponseArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailActionRespondImmediatelyResponseArgs']]] responses: The canned responses for the agent to choose from. The response is chosen
               randomly.
               Structure is documented below.
        """
        pulumi.set(__self__, "responses", responses)

    @_builtins.property
    @pulumi.getter
    def responses(self) -> pulumi.Input[Sequence[pulumi.Input['GuardrailActionRespondImmediatelyResponseArgs']]]:
        """
        The canned responses for the agent to choose from. The response is chosen
        randomly.
        Structure is documented below.
        """
        return pulumi.get(self, "responses")

    @responses.setter
    def responses(self, value: pulumi.Input[Sequence[pulumi.Input['GuardrailActionRespondImmediatelyResponseArgs']]]):
        pulumi.set(self, "responses", value)


if not MYPY:
    class GuardrailActionRespondImmediatelyResponseArgsDict(TypedDict):
        text: pulumi.Input[_builtins.str]
        """
        Text for the agent to respond with.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the response is disabled. Disabled responses are not used by the
        agent.
        """
elif False:
    GuardrailActionRespondImmediatelyResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailActionRespondImmediatelyResponseArgs:
    def __init__(__self__, *,
                 text: pulumi.Input[_builtins.str],
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] text: Text for the agent to respond with.
        :param pulumi.Input[_builtins.bool] disabled: Whether the response is disabled. Disabled responses are not used by the
               agent.
        """
        pulumi.set(__self__, "text", text)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter
    def text(self) -> pulumi.Input[_builtins.str]:
        """
        Text for the agent to respond with.
        """
        return pulumi.get(self, "text")

    @text.setter
    def text(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "text", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the response is disabled. Disabled responses are not used by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class GuardrailActionTransferAgentArgsDict(TypedDict):
        agent: pulumi.Input[_builtins.str]
        """
        The name of the agent to transfer the conversation to. The agent must be
        in the same app as the current agent.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
elif False:
    GuardrailActionTransferAgentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailActionTransferAgentArgs:
    def __init__(__self__, *,
                 agent: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] agent: The name of the agent to transfer the conversation to. The agent must be
               in the same app as the current agent.
               Format:
               `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        pulumi.set(__self__, "agent", agent)

    @_builtins.property
    @pulumi.getter
    def agent(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the agent to transfer the conversation to. The agent must be
        in the same app as the current agent.
        Format:
        `projects/{project}/locations/{location}/apps/{app}/agents/{agent}`
        """
        return pulumi.get(self, "agent")

    @agent.setter
    def agent(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "agent", value)


if not MYPY:
    class GuardrailCodeCallbackArgsDict(TypedDict):
        after_agent_callback: NotRequired[pulumi.Input['GuardrailCodeCallbackAfterAgentCallbackArgsDict']]
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        after_model_callback: NotRequired[pulumi.Input['GuardrailCodeCallbackAfterModelCallbackArgsDict']]
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        before_agent_callback: NotRequired[pulumi.Input['GuardrailCodeCallbackBeforeAgentCallbackArgsDict']]
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        before_model_callback: NotRequired[pulumi.Input['GuardrailCodeCallbackBeforeModelCallbackArgsDict']]
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
elif False:
    GuardrailCodeCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailCodeCallbackArgs:
    def __init__(__self__, *,
                 after_agent_callback: Optional[pulumi.Input['GuardrailCodeCallbackAfterAgentCallbackArgs']] = None,
                 after_model_callback: Optional[pulumi.Input['GuardrailCodeCallbackAfterModelCallbackArgs']] = None,
                 before_agent_callback: Optional[pulumi.Input['GuardrailCodeCallbackBeforeAgentCallbackArgs']] = None,
                 before_model_callback: Optional[pulumi.Input['GuardrailCodeCallbackBeforeModelCallbackArgs']] = None):
        """
        :param pulumi.Input['GuardrailCodeCallbackAfterAgentCallbackArgs'] after_agent_callback: A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        :param pulumi.Input['GuardrailCodeCallbackAfterModelCallbackArgs'] after_model_callback: A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        :param pulumi.Input['GuardrailCodeCallbackBeforeAgentCallbackArgs'] before_agent_callback: A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        :param pulumi.Input['GuardrailCodeCallbackBeforeModelCallbackArgs'] before_model_callback: A callback defines the custom logic to be executed at various stages of
               agent interaction.
               Structure is documented below.
        """
        if after_agent_callback is not None:
            pulumi.set(__self__, "after_agent_callback", after_agent_callback)
        if after_model_callback is not None:
            pulumi.set(__self__, "after_model_callback", after_model_callback)
        if before_agent_callback is not None:
            pulumi.set(__self__, "before_agent_callback", before_agent_callback)
        if before_model_callback is not None:
            pulumi.set(__self__, "before_model_callback", before_model_callback)

    @_builtins.property
    @pulumi.getter(name="afterAgentCallback")
    def after_agent_callback(self) -> Optional[pulumi.Input['GuardrailCodeCallbackAfterAgentCallbackArgs']]:
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "after_agent_callback")

    @after_agent_callback.setter
    def after_agent_callback(self, value: Optional[pulumi.Input['GuardrailCodeCallbackAfterAgentCallbackArgs']]):
        pulumi.set(self, "after_agent_callback", value)

    @_builtins.property
    @pulumi.getter(name="afterModelCallback")
    def after_model_callback(self) -> Optional[pulumi.Input['GuardrailCodeCallbackAfterModelCallbackArgs']]:
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "after_model_callback")

    @after_model_callback.setter
    def after_model_callback(self, value: Optional[pulumi.Input['GuardrailCodeCallbackAfterModelCallbackArgs']]):
        pulumi.set(self, "after_model_callback", value)

    @_builtins.property
    @pulumi.getter(name="beforeAgentCallback")
    def before_agent_callback(self) -> Optional[pulumi.Input['GuardrailCodeCallbackBeforeAgentCallbackArgs']]:
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "before_agent_callback")

    @before_agent_callback.setter
    def before_agent_callback(self, value: Optional[pulumi.Input['GuardrailCodeCallbackBeforeAgentCallbackArgs']]):
        pulumi.set(self, "before_agent_callback", value)

    @_builtins.property
    @pulumi.getter(name="beforeModelCallback")
    def before_model_callback(self) -> Optional[pulumi.Input['GuardrailCodeCallbackBeforeModelCallbackArgs']]:
        """
        A callback defines the custom logic to be executed at various stages of
        agent interaction.
        Structure is documented below.
        """
        return pulumi.get(self, "before_model_callback")

    @before_model_callback.setter
    def before_model_callback(self, value: Optional[pulumi.Input['GuardrailCodeCallbackBeforeModelCallbackArgs']]):
        pulumi.set(self, "before_model_callback", value)


if not MYPY:
    class GuardrailCodeCallbackAfterAgentCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    GuardrailCodeCallbackAfterAgentCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailCodeCallbackAfterAgentCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class GuardrailCodeCallbackAfterModelCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    GuardrailCodeCallbackAfterModelCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailCodeCallbackAfterModelCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class GuardrailCodeCallbackBeforeAgentCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    GuardrailCodeCallbackBeforeAgentCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailCodeCallbackBeforeAgentCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class GuardrailCodeCallbackBeforeModelCallbackArgsDict(TypedDict):
        python_code: pulumi.Input[_builtins.str]
        """
        The python code to execute for the callback.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable description of the callback.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
elif False:
    GuardrailCodeCallbackBeforeModelCallbackArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailCodeCallbackBeforeModelCallbackArgs:
    def __init__(__self__, *,
                 python_code: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] python_code: The python code to execute for the callback.
        :param pulumi.Input[_builtins.str] description: Human-readable description of the callback.
        :param pulumi.Input[_builtins.bool] disabled: Whether the callback is disabled. Disabled callbacks are ignored by the
               agent.
        """
        pulumi.set(__self__, "python_code", python_code)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> pulumi.Input[_builtins.str]:
        """
        The python code to execute for the callback.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "python_code", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable description of the callback.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the callback is disabled. Disabled callbacks are ignored by the
        agent.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)


if not MYPY:
    class GuardrailContentFilterArgsDict(TypedDict):
        match_type: pulumi.Input[_builtins.str]
        """
        Match type for the content filter.
        Possible values:
        SIMPLE_STRING_MATCH
        WORD_BOUNDARY_STRING_MATCH
        REGEXP_MATCH
        """
        banned_contents: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of banned phrases. Applies to both user inputs and agent responses.
        """
        banned_contents_in_agent_responses: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of banned phrases. Applies only to agent responses.
        """
        banned_contents_in_user_inputs: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of banned phrases. Applies only to user inputs.
        """
        disregard_diacritics: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, diacritics are ignored during matching.
        """
elif False:
    GuardrailContentFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailContentFilterArgs:
    def __init__(__self__, *,
                 match_type: pulumi.Input[_builtins.str],
                 banned_contents: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 banned_contents_in_agent_responses: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 banned_contents_in_user_inputs: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 disregard_diacritics: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] match_type: Match type for the content filter.
               Possible values:
               SIMPLE_STRING_MATCH
               WORD_BOUNDARY_STRING_MATCH
               REGEXP_MATCH
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] banned_contents: List of banned phrases. Applies to both user inputs and agent responses.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] banned_contents_in_agent_responses: List of banned phrases. Applies only to agent responses.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] banned_contents_in_user_inputs: List of banned phrases. Applies only to user inputs.
        :param pulumi.Input[_builtins.bool] disregard_diacritics: If true, diacritics are ignored during matching.
        """
        pulumi.set(__self__, "match_type", match_type)
        if banned_contents is not None:
            pulumi.set(__self__, "banned_contents", banned_contents)
        if banned_contents_in_agent_responses is not None:
            pulumi.set(__self__, "banned_contents_in_agent_responses", banned_contents_in_agent_responses)
        if banned_contents_in_user_inputs is not None:
            pulumi.set(__self__, "banned_contents_in_user_inputs", banned_contents_in_user_inputs)
        if disregard_diacritics is not None:
            pulumi.set(__self__, "disregard_diacritics", disregard_diacritics)

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> pulumi.Input[_builtins.str]:
        """
        Match type for the content filter.
        Possible values:
        SIMPLE_STRING_MATCH
        WORD_BOUNDARY_STRING_MATCH
        REGEXP_MATCH
        """
        return pulumi.get(self, "match_type")

    @match_type.setter
    def match_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "match_type", value)

    @_builtins.property
    @pulumi.getter(name="bannedContents")
    def banned_contents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of banned phrases. Applies to both user inputs and agent responses.
        """
        return pulumi.get(self, "banned_contents")

    @banned_contents.setter
    def banned_contents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "banned_contents", value)

    @_builtins.property
    @pulumi.getter(name="bannedContentsInAgentResponses")
    def banned_contents_in_agent_responses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of banned phrases. Applies only to agent responses.
        """
        return pulumi.get(self, "banned_contents_in_agent_responses")

    @banned_contents_in_agent_responses.setter
    def banned_contents_in_agent_responses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "banned_contents_in_agent_responses", value)

    @_builtins.property
    @pulumi.getter(name="bannedContentsInUserInputs")
    def banned_contents_in_user_inputs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of banned phrases. Applies only to user inputs.
        """
        return pulumi.get(self, "banned_contents_in_user_inputs")

    @banned_contents_in_user_inputs.setter
    def banned_contents_in_user_inputs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "banned_contents_in_user_inputs", value)

    @_builtins.property
    @pulumi.getter(name="disregardDiacritics")
    def disregard_diacritics(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, diacritics are ignored during matching.
        """
        return pulumi.get(self, "disregard_diacritics")

    @disregard_diacritics.setter
    def disregard_diacritics(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disregard_diacritics", value)


if not MYPY:
    class GuardrailLlmPolicyArgsDict(TypedDict):
        policy_scope: pulumi.Input[_builtins.str]
        """
        Defines when to apply the policy check during the conversation. If set to
        `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
        When applying the policy to the agent response, additional latency will
        be introduced before the agent can respond.
        Possible values:
        USER_QUERY
        AGENT_RESPONSE
        USER_QUERY_AND_AGENT_RESPONSE
        Possible values are: `USER_QUERY`, `AGENT_RESPONSE`, `USER_QUERY_AND_AGENT_RESPONSE`.
        """
        prompt: pulumi.Input[_builtins.str]
        """
        Policy prompt.
        """
        allow_short_utterance: NotRequired[pulumi.Input[_builtins.bool]]
        """
        By default, the LLM policy check is bypassed for short utterances.
        Enabling this setting applies the policy check to all utterances,
        including those that would normally be skipped.
        """
        fail_open: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If an error occurs during the policy check, fail open and do not trigger
        the guardrail.
        """
        max_conversation_messages: NotRequired[pulumi.Input[_builtins.int]]
        """
        When checking this policy, consider the last 'n' messages in the
        conversation.
        When not set a default value of 10 will be used.
        """
        model_settings: NotRequired[pulumi.Input['GuardrailLlmPolicyModelSettingsArgsDict']]
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
elif False:
    GuardrailLlmPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailLlmPolicyArgs:
    def __init__(__self__, *,
                 policy_scope: pulumi.Input[_builtins.str],
                 prompt: pulumi.Input[_builtins.str],
                 allow_short_utterance: Optional[pulumi.Input[_builtins.bool]] = None,
                 fail_open: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_conversation_messages: Optional[pulumi.Input[_builtins.int]] = None,
                 model_settings: Optional[pulumi.Input['GuardrailLlmPolicyModelSettingsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] policy_scope: Defines when to apply the policy check during the conversation. If set to
               `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
               When applying the policy to the agent response, additional latency will
               be introduced before the agent can respond.
               Possible values:
               USER_QUERY
               AGENT_RESPONSE
               USER_QUERY_AND_AGENT_RESPONSE
               Possible values are: `USER_QUERY`, `AGENT_RESPONSE`, `USER_QUERY_AND_AGENT_RESPONSE`.
        :param pulumi.Input[_builtins.str] prompt: Policy prompt.
        :param pulumi.Input[_builtins.bool] allow_short_utterance: By default, the LLM policy check is bypassed for short utterances.
               Enabling this setting applies the policy check to all utterances,
               including those that would normally be skipped.
        :param pulumi.Input[_builtins.bool] fail_open: If an error occurs during the policy check, fail open and do not trigger
               the guardrail.
        :param pulumi.Input[_builtins.int] max_conversation_messages: When checking this policy, consider the last 'n' messages in the
               conversation.
               When not set a default value of 10 will be used.
        :param pulumi.Input['GuardrailLlmPolicyModelSettingsArgs'] model_settings: Model settings contains various configurations for the LLM model.
               Structure is documented below.
        """
        pulumi.set(__self__, "policy_scope", policy_scope)
        pulumi.set(__self__, "prompt", prompt)
        if allow_short_utterance is not None:
            pulumi.set(__self__, "allow_short_utterance", allow_short_utterance)
        if fail_open is not None:
            pulumi.set(__self__, "fail_open", fail_open)
        if max_conversation_messages is not None:
            pulumi.set(__self__, "max_conversation_messages", max_conversation_messages)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)

    @_builtins.property
    @pulumi.getter(name="policyScope")
    def policy_scope(self) -> pulumi.Input[_builtins.str]:
        """
        Defines when to apply the policy check during the conversation. If set to
        `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
        When applying the policy to the agent response, additional latency will
        be introduced before the agent can respond.
        Possible values:
        USER_QUERY
        AGENT_RESPONSE
        USER_QUERY_AND_AGENT_RESPONSE
        Possible values are: `USER_QUERY`, `AGENT_RESPONSE`, `USER_QUERY_AND_AGENT_RESPONSE`.
        """
        return pulumi.get(self, "policy_scope")

    @policy_scope.setter
    def policy_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "policy_scope", value)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> pulumi.Input[_builtins.str]:
        """
        Policy prompt.
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prompt", value)

    @_builtins.property
    @pulumi.getter(name="allowShortUtterance")
    def allow_short_utterance(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        By default, the LLM policy check is bypassed for short utterances.
        Enabling this setting applies the policy check to all utterances,
        including those that would normally be skipped.
        """
        return pulumi.get(self, "allow_short_utterance")

    @allow_short_utterance.setter
    def allow_short_utterance(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_short_utterance", value)

    @_builtins.property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If an error occurs during the policy check, fail open and do not trigger
        the guardrail.
        """
        return pulumi.get(self, "fail_open")

    @fail_open.setter
    def fail_open(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "fail_open", value)

    @_builtins.property
    @pulumi.getter(name="maxConversationMessages")
    def max_conversation_messages(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        When checking this policy, consider the last 'n' messages in the
        conversation.
        When not set a default value of 10 will be used.
        """
        return pulumi.get(self, "max_conversation_messages")

    @max_conversation_messages.setter
    def max_conversation_messages(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_conversation_messages", value)

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional[pulumi.Input['GuardrailLlmPolicyModelSettingsArgs']]:
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @model_settings.setter
    def model_settings(self, value: Optional[pulumi.Input['GuardrailLlmPolicyModelSettingsArgs']]):
        pulumi.set(self, "model_settings", value)


if not MYPY:
    class GuardrailLlmPolicyModelSettingsArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
elif False:
    GuardrailLlmPolicyModelSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailLlmPolicyModelSettingsArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] model: The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param pulumi.Input[_builtins.float] temperature: If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)


if not MYPY:
    class GuardrailLlmPromptSecurityArgsDict(TypedDict):
        custom_policy: NotRequired[pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyArgsDict']]
        """
        Guardrail that blocks the conversation if the LLM response is considered
        violating the policy based on the LLM classification.
        Structure is documented below.
        """
        default_settings: NotRequired[pulumi.Input['GuardrailLlmPromptSecurityDefaultSettingsArgsDict']]
        """
        Configuration for default system security settings.
        Structure is documented below.
        """
elif False:
    GuardrailLlmPromptSecurityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailLlmPromptSecurityArgs:
    def __init__(__self__, *,
                 custom_policy: Optional[pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyArgs']] = None,
                 default_settings: Optional[pulumi.Input['GuardrailLlmPromptSecurityDefaultSettingsArgs']] = None):
        """
        :param pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyArgs'] custom_policy: Guardrail that blocks the conversation if the LLM response is considered
               violating the policy based on the LLM classification.
               Structure is documented below.
        :param pulumi.Input['GuardrailLlmPromptSecurityDefaultSettingsArgs'] default_settings: Configuration for default system security settings.
               Structure is documented below.
        """
        if custom_policy is not None:
            pulumi.set(__self__, "custom_policy", custom_policy)
        if default_settings is not None:
            pulumi.set(__self__, "default_settings", default_settings)

    @_builtins.property
    @pulumi.getter(name="customPolicy")
    def custom_policy(self) -> Optional[pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyArgs']]:
        """
        Guardrail that blocks the conversation if the LLM response is considered
        violating the policy based on the LLM classification.
        Structure is documented below.
        """
        return pulumi.get(self, "custom_policy")

    @custom_policy.setter
    def custom_policy(self, value: Optional[pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyArgs']]):
        pulumi.set(self, "custom_policy", value)

    @_builtins.property
    @pulumi.getter(name="defaultSettings")
    def default_settings(self) -> Optional[pulumi.Input['GuardrailLlmPromptSecurityDefaultSettingsArgs']]:
        """
        Configuration for default system security settings.
        Structure is documented below.
        """
        return pulumi.get(self, "default_settings")

    @default_settings.setter
    def default_settings(self, value: Optional[pulumi.Input['GuardrailLlmPromptSecurityDefaultSettingsArgs']]):
        pulumi.set(self, "default_settings", value)


if not MYPY:
    class GuardrailLlmPromptSecurityCustomPolicyArgsDict(TypedDict):
        policy_scope: pulumi.Input[_builtins.str]
        """
        Defines when to apply the policy check during the conversation. If set to
        `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
        When applying the policy to the agent response, additional latency will
        be introduced before the agent can respond.
        Possible values:
        USER_QUERY
        AGENT_RESPONSE
        USER_QUERY_AND_AGENT_RESPONSE
        """
        prompt: pulumi.Input[_builtins.str]
        """
        Policy prompt.
        """
        allow_short_utterance: NotRequired[pulumi.Input[_builtins.bool]]
        """
        By default, the LLM policy check is bypassed for short utterances.
        Enabling this setting applies the policy check to all utterances,
        including those that would normally be skipped.
        """
        fail_open: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If an error occurs during the policy check, fail open and do not trigger
        the guardrail.
        """
        max_conversation_messages: NotRequired[pulumi.Input[_builtins.int]]
        """
        When checking this policy, consider the last 'n' messages in the
        conversation.
        When not set a default value of 10 will be used.
        """
        model_settings: NotRequired[pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgsDict']]
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
elif False:
    GuardrailLlmPromptSecurityCustomPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailLlmPromptSecurityCustomPolicyArgs:
    def __init__(__self__, *,
                 policy_scope: pulumi.Input[_builtins.str],
                 prompt: pulumi.Input[_builtins.str],
                 allow_short_utterance: Optional[pulumi.Input[_builtins.bool]] = None,
                 fail_open: Optional[pulumi.Input[_builtins.bool]] = None,
                 max_conversation_messages: Optional[pulumi.Input[_builtins.int]] = None,
                 model_settings: Optional[pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] policy_scope: Defines when to apply the policy check during the conversation. If set to
               `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
               When applying the policy to the agent response, additional latency will
               be introduced before the agent can respond.
               Possible values:
               USER_QUERY
               AGENT_RESPONSE
               USER_QUERY_AND_AGENT_RESPONSE
        :param pulumi.Input[_builtins.str] prompt: Policy prompt.
        :param pulumi.Input[_builtins.bool] allow_short_utterance: By default, the LLM policy check is bypassed for short utterances.
               Enabling this setting applies the policy check to all utterances,
               including those that would normally be skipped.
        :param pulumi.Input[_builtins.bool] fail_open: If an error occurs during the policy check, fail open and do not trigger
               the guardrail.
        :param pulumi.Input[_builtins.int] max_conversation_messages: When checking this policy, consider the last 'n' messages in the
               conversation.
               When not set a default value of 10 will be used.
        :param pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgs'] model_settings: Model settings contains various configurations for the LLM model.
               Structure is documented below.
        """
        pulumi.set(__self__, "policy_scope", policy_scope)
        pulumi.set(__self__, "prompt", prompt)
        if allow_short_utterance is not None:
            pulumi.set(__self__, "allow_short_utterance", allow_short_utterance)
        if fail_open is not None:
            pulumi.set(__self__, "fail_open", fail_open)
        if max_conversation_messages is not None:
            pulumi.set(__self__, "max_conversation_messages", max_conversation_messages)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)

    @_builtins.property
    @pulumi.getter(name="policyScope")
    def policy_scope(self) -> pulumi.Input[_builtins.str]:
        """
        Defines when to apply the policy check during the conversation. If set to
        `POLICY_SCOPE_UNSPECIFIED`, the policy will be applied to the user input.
        When applying the policy to the agent response, additional latency will
        be introduced before the agent can respond.
        Possible values:
        USER_QUERY
        AGENT_RESPONSE
        USER_QUERY_AND_AGENT_RESPONSE
        """
        return pulumi.get(self, "policy_scope")

    @policy_scope.setter
    def policy_scope(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "policy_scope", value)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> pulumi.Input[_builtins.str]:
        """
        Policy prompt.
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "prompt", value)

    @_builtins.property
    @pulumi.getter(name="allowShortUtterance")
    def allow_short_utterance(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        By default, the LLM policy check is bypassed for short utterances.
        Enabling this setting applies the policy check to all utterances,
        including those that would normally be skipped.
        """
        return pulumi.get(self, "allow_short_utterance")

    @allow_short_utterance.setter
    def allow_short_utterance(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_short_utterance", value)

    @_builtins.property
    @pulumi.getter(name="failOpen")
    def fail_open(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If an error occurs during the policy check, fail open and do not trigger
        the guardrail.
        """
        return pulumi.get(self, "fail_open")

    @fail_open.setter
    def fail_open(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "fail_open", value)

    @_builtins.property
    @pulumi.getter(name="maxConversationMessages")
    def max_conversation_messages(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        When checking this policy, consider the last 'n' messages in the
        conversation.
        When not set a default value of 10 will be used.
        """
        return pulumi.get(self, "max_conversation_messages")

    @max_conversation_messages.setter
    def max_conversation_messages(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_conversation_messages", value)

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional[pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgs']]:
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @model_settings.setter
    def model_settings(self, value: Optional[pulumi.Input['GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgs']]):
        pulumi.set(self, "model_settings", value)


if not MYPY:
    class GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
elif False:
    GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailLlmPromptSecurityCustomPolicyModelSettingsArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] model: The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param pulumi.Input[_builtins.float] temperature: If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)


if not MYPY:
    class GuardrailLlmPromptSecurityDefaultSettingsArgsDict(TypedDict):
        default_prompt_template: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The default prompt template used by the system.
        This field is for display purposes to show the user what prompt
        the system uses by default. It is OUTPUT_ONLY.
        """
elif False:
    GuardrailLlmPromptSecurityDefaultSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailLlmPromptSecurityDefaultSettingsArgs:
    def __init__(__self__, *,
                 default_prompt_template: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] default_prompt_template: (Output)
               The default prompt template used by the system.
               This field is for display purposes to show the user what prompt
               the system uses by default. It is OUTPUT_ONLY.
        """
        if default_prompt_template is not None:
            pulumi.set(__self__, "default_prompt_template", default_prompt_template)

    @_builtins.property
    @pulumi.getter(name="defaultPromptTemplate")
    def default_prompt_template(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The default prompt template used by the system.
        This field is for display purposes to show the user what prompt
        the system uses by default. It is OUTPUT_ONLY.
        """
        return pulumi.get(self, "default_prompt_template")

    @default_prompt_template.setter
    def default_prompt_template(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default_prompt_template", value)


if not MYPY:
    class GuardrailModelSafetyArgsDict(TypedDict):
        safety_settings: pulumi.Input[Sequence[pulumi.Input['GuardrailModelSafetySafetySettingArgsDict']]]
        """
        List of safety settings.
        Structure is documented below.
        """
elif False:
    GuardrailModelSafetyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailModelSafetyArgs:
    def __init__(__self__, *,
                 safety_settings: pulumi.Input[Sequence[pulumi.Input['GuardrailModelSafetySafetySettingArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['GuardrailModelSafetySafetySettingArgs']]] safety_settings: List of safety settings.
               Structure is documented below.
        """
        pulumi.set(__self__, "safety_settings", safety_settings)

    @_builtins.property
    @pulumi.getter(name="safetySettings")
    def safety_settings(self) -> pulumi.Input[Sequence[pulumi.Input['GuardrailModelSafetySafetySettingArgs']]]:
        """
        List of safety settings.
        Structure is documented below.
        """
        return pulumi.get(self, "safety_settings")

    @safety_settings.setter
    def safety_settings(self, value: pulumi.Input[Sequence[pulumi.Input['GuardrailModelSafetySafetySettingArgs']]]):
        pulumi.set(self, "safety_settings", value)


if not MYPY:
    class GuardrailModelSafetySafetySettingArgsDict(TypedDict):
        category: pulumi.Input[_builtins.str]
        """
        The harm category.
        Possible values:
        HARM_CATEGORY_HATE_SPEECH
        HARM_CATEGORY_DANGEROUS_CONTENT
        HARM_CATEGORY_HARASSMENT
        HARM_CATEGORY_SEXUALLY_EXPLICIT
        Possible values are: `HARM_CATEGORY_HATE_SPEECH`, `HARM_CATEGORY_DANGEROUS_CONTENT`, `HARM_CATEGORY_HARASSMENT`, `HARM_CATEGORY_SEXUALLY_EXPLICIT`.
        """
        threshold: pulumi.Input[_builtins.str]
        """
        The harm block threshold.
        Possible values:
        BLOCK_LOW_AND_ABOVE
        BLOCK_MEDIUM_AND_ABOVE
        BLOCK_ONLY_HIGH
        BLOCK_NONE
        OFF
        Possible values are: `BLOCK_LOW_AND_ABOVE`, `BLOCK_MEDIUM_AND_ABOVE`, `BLOCK_ONLY_HIGH`, `BLOCK_NONE`, `OFF`.
        """
elif False:
    GuardrailModelSafetySafetySettingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GuardrailModelSafetySafetySettingArgs:
    def __init__(__self__, *,
                 category: pulumi.Input[_builtins.str],
                 threshold: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] category: The harm category.
               Possible values:
               HARM_CATEGORY_HATE_SPEECH
               HARM_CATEGORY_DANGEROUS_CONTENT
               HARM_CATEGORY_HARASSMENT
               HARM_CATEGORY_SEXUALLY_EXPLICIT
               Possible values are: `HARM_CATEGORY_HATE_SPEECH`, `HARM_CATEGORY_DANGEROUS_CONTENT`, `HARM_CATEGORY_HARASSMENT`, `HARM_CATEGORY_SEXUALLY_EXPLICIT`.
        :param pulumi.Input[_builtins.str] threshold: The harm block threshold.
               Possible values:
               BLOCK_LOW_AND_ABOVE
               BLOCK_MEDIUM_AND_ABOVE
               BLOCK_ONLY_HIGH
               BLOCK_NONE
               OFF
               Possible values are: `BLOCK_LOW_AND_ABOVE`, `BLOCK_MEDIUM_AND_ABOVE`, `BLOCK_ONLY_HIGH`, `BLOCK_NONE`, `OFF`.
        """
        pulumi.set(__self__, "category", category)
        pulumi.set(__self__, "threshold", threshold)

    @_builtins.property
    @pulumi.getter
    def category(self) -> pulumi.Input[_builtins.str]:
        """
        The harm category.
        Possible values:
        HARM_CATEGORY_HATE_SPEECH
        HARM_CATEGORY_DANGEROUS_CONTENT
        HARM_CATEGORY_HARASSMENT
        HARM_CATEGORY_SEXUALLY_EXPLICIT
        Possible values are: `HARM_CATEGORY_HATE_SPEECH`, `HARM_CATEGORY_DANGEROUS_CONTENT`, `HARM_CATEGORY_HARASSMENT`, `HARM_CATEGORY_SEXUALLY_EXPLICIT`.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "category", value)

    @_builtins.property
    @pulumi.getter
    def threshold(self) -> pulumi.Input[_builtins.str]:
        """
        The harm block threshold.
        Possible values:
        BLOCK_LOW_AND_ABOVE
        BLOCK_MEDIUM_AND_ABOVE
        BLOCK_ONLY_HIGH
        BLOCK_NONE
        OFF
        Possible values are: `BLOCK_LOW_AND_ABOVE`, `BLOCK_MEDIUM_AND_ABOVE`, `BLOCK_ONLY_HIGH`, `BLOCK_NONE`, `OFF`.
        """
        return pulumi.get(self, "threshold")

    @threshold.setter
    def threshold(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "threshold", value)


if not MYPY:
    class ToolClientFunctionArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The function name.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The function description.
        """
        parameters: NotRequired[pulumi.Input['ToolClientFunctionParametersArgsDict']]
        """
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        response: NotRequired[pulumi.Input['ToolClientFunctionResponseArgsDict']]
        """
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
elif False:
    ToolClientFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolClientFunctionArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 parameters: Optional[pulumi.Input['ToolClientFunctionParametersArgs']] = None,
                 response: Optional[pulumi.Input['ToolClientFunctionResponseArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] name: The function name.
        :param pulumi.Input[_builtins.str] description: The function description.
        :param pulumi.Input['ToolClientFunctionParametersArgs'] parameters: Represents a select subset of an OpenAPI 3.0 schema object.
               Structure is documented below.
        :param pulumi.Input['ToolClientFunctionResponseArgs'] response: Represents a select subset of an OpenAPI 3.0 schema object.
               Structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if response is not None:
            pulumi.set(__self__, "response", response)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The function name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The function description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input['ToolClientFunctionParametersArgs']]:
        """
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input['ToolClientFunctionParametersArgs']]):
        pulumi.set(self, "parameters", value)

    @_builtins.property
    @pulumi.getter
    def response(self) -> Optional[pulumi.Input['ToolClientFunctionResponseArgs']]:
        """
        Represents a select subset of an OpenAPI 3.0 schema object.
        Structure is documented below.
        """
        return pulumi.get(self, "response")

    @response.setter
    def response(self, value: Optional[pulumi.Input['ToolClientFunctionResponseArgs']]):
        pulumi.set(self, "response", value)


if not MYPY:
    class ToolClientFunctionParametersArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of the data.
        Possible values:
        STRING
        INTEGER
        NUMBER
        BOOLEAN
        OBJECT
        ARRAY
        """
        additional_properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        any_of: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        default: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        defs: NotRequired[pulumi.Input[_builtins.str]]
        """
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the data.
        """
        enums: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        items: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema of the elements of Type.ARRAY.
        """
        nullable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the value may be null.
        """
        prefix_items: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        Properties of Type.OBJECT.
        """
        ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        requireds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Required properties of Type.OBJECT.
        """
        unique_items: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
elif False:
    ToolClientFunctionParametersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolClientFunctionParametersArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 additional_properties: Optional[pulumi.Input[_builtins.str]] = None,
                 any_of: Optional[pulumi.Input[_builtins.str]] = None,
                 default: Optional[pulumi.Input[_builtins.str]] = None,
                 defs: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enums: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 items: Optional[pulumi.Input[_builtins.str]] = None,
                 nullable: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix_items: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[_builtins.str]] = None,
                 ref: Optional[pulumi.Input[_builtins.str]] = None,
                 requireds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 unique_items: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of the data.
               Possible values:
               STRING
               INTEGER
               NUMBER
               BOOLEAN
               OBJECT
               ARRAY
        :param pulumi.Input[_builtins.str] additional_properties: Optional. Defines the schema for additional properties allowed in an object.
               The value must be a valid JSON string representing the Schema object.
               (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        :param pulumi.Input[_builtins.str] any_of: Optional. The instance value should be valid against at least one of the schemas in this list.
        :param pulumi.Input[_builtins.str] default: Optional. Default value of the data. Represents a dynamically typed value
               which can be either null, a number, a string, a boolean, a struct,
               or a list of values. The provided default value must be compatible
               with the defined 'type' and other schema constraints.
        :param pulumi.Input[_builtins.str] defs: A map of definitions for use by ref. Only allowed at the root of the schema.
        :param pulumi.Input[_builtins.str] description: The description of the data.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enums: Possible values of the element of primitive type with enum format.
               Examples:
               1. We can define direction as :
               {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
               2. We can define apartment number as :
               {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        :param pulumi.Input[_builtins.str] items: Schema of the elements of Type.ARRAY.
        :param pulumi.Input[_builtins.bool] nullable: Indicates if the value may be null.
        :param pulumi.Input[_builtins.str] prefix_items: Optional. Schemas of initial elements of Type.ARRAY.
        :param pulumi.Input[_builtins.str] properties: Properties of Type.OBJECT.
        :param pulumi.Input[_builtins.str] ref: Allows indirect references between schema nodes. The value should be a
               valid reference to a child of the root `defs`.
               For example, the following schema defines a reference to a schema node
               named "Pet":
               type: object
               properties:
               pet:
               ref: #/defs/Pet
               defs:
               Pet:
               type: object
               properties:
               name:
               type: string
               The value of the "pet" property is a reference to the schema node
               named "Pet".
               See details in
               https://json-schema.org/understanding-json-schema/structuring.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] requireds: Required properties of Type.OBJECT.
        :param pulumi.Input[_builtins.bool] unique_items: Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        pulumi.set(__self__, "type", type)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if any_of is not None:
            pulumi.set(__self__, "any_of", any_of)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if defs is not None:
            pulumi.set(__self__, "defs", defs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enums is not None:
            pulumi.set(__self__, "enums", enums)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if prefix_items is not None:
            pulumi.set(__self__, "prefix_items", prefix_items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if requireds is not None:
            pulumi.set(__self__, "requireds", requireds)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the data.
        Possible values:
        STRING
        INTEGER
        NUMBER
        BOOLEAN
        OBJECT
        ARRAY
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_properties", value)

    @_builtins.property
    @pulumi.getter(name="anyOf")
    def any_of(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        return pulumi.get(self, "any_of")

    @any_of.setter
    def any_of(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "any_of", value)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def defs(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        return pulumi.get(self, "defs")

    @defs.setter
    def defs(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "defs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the data.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def enums(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        return pulumi.get(self, "enums")

    @enums.setter
    def enums(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enums", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema of the elements of Type.ARRAY.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the value may be null.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "nullable", value)

    @_builtins.property
    @pulumi.getter(name="prefixItems")
    def prefix_items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        return pulumi.get(self, "prefix_items")

    @prefix_items.setter
    def prefix_items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_items", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Properties of Type.OBJECT.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ref", value)

    @_builtins.property
    @pulumi.getter
    def requireds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Required properties of Type.OBJECT.
        """
        return pulumi.get(self, "requireds")

    @requireds.setter
    def requireds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "requireds", value)

    @_builtins.property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        return pulumi.get(self, "unique_items")

    @unique_items.setter
    def unique_items(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unique_items", value)


if not MYPY:
    class ToolClientFunctionResponseArgsDict(TypedDict):
        type: pulumi.Input[_builtins.str]
        """
        The type of the data.
        Possible values:
        STRING
        INTEGER
        NUMBER
        BOOLEAN
        OBJECT
        ARRAY
        """
        additional_properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        any_of: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        default: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        defs: NotRequired[pulumi.Input[_builtins.str]]
        """
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The description of the data.
        """
        enums: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        items: NotRequired[pulumi.Input[_builtins.str]]
        """
        Schema of the elements of Type.ARRAY.
        """
        nullable: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates if the value may be null.
        """
        prefix_items: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        properties: NotRequired[pulumi.Input[_builtins.str]]
        """
        Properties of Type.OBJECT.
        """
        ref: NotRequired[pulumi.Input[_builtins.str]]
        """
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        requireds: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Required properties of Type.OBJECT.
        """
        unique_items: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
elif False:
    ToolClientFunctionResponseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolClientFunctionResponseArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[_builtins.str],
                 additional_properties: Optional[pulumi.Input[_builtins.str]] = None,
                 any_of: Optional[pulumi.Input[_builtins.str]] = None,
                 default: Optional[pulumi.Input[_builtins.str]] = None,
                 defs: Optional[pulumi.Input[_builtins.str]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 enums: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 items: Optional[pulumi.Input[_builtins.str]] = None,
                 nullable: Optional[pulumi.Input[_builtins.bool]] = None,
                 prefix_items: Optional[pulumi.Input[_builtins.str]] = None,
                 properties: Optional[pulumi.Input[_builtins.str]] = None,
                 ref: Optional[pulumi.Input[_builtins.str]] = None,
                 requireds: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 unique_items: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] type: The type of the data.
               Possible values:
               STRING
               INTEGER
               NUMBER
               BOOLEAN
               OBJECT
               ARRAY
        :param pulumi.Input[_builtins.str] additional_properties: Optional. Defines the schema for additional properties allowed in an object.
               The value must be a valid JSON string representing the Schema object.
               (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        :param pulumi.Input[_builtins.str] any_of: Optional. The instance value should be valid against at least one of the schemas in this list.
        :param pulumi.Input[_builtins.str] default: Optional. Default value of the data. Represents a dynamically typed value
               which can be either null, a number, a string, a boolean, a struct,
               or a list of values. The provided default value must be compatible
               with the defined 'type' and other schema constraints.
        :param pulumi.Input[_builtins.str] defs: A map of definitions for use by ref. Only allowed at the root of the schema.
        :param pulumi.Input[_builtins.str] description: The description of the data.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] enums: Possible values of the element of primitive type with enum format.
               Examples:
               1. We can define direction as :
               {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
               2. We can define apartment number as :
               {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        :param pulumi.Input[_builtins.str] items: Schema of the elements of Type.ARRAY.
        :param pulumi.Input[_builtins.bool] nullable: Indicates if the value may be null.
        :param pulumi.Input[_builtins.str] prefix_items: Optional. Schemas of initial elements of Type.ARRAY.
        :param pulumi.Input[_builtins.str] properties: Properties of Type.OBJECT.
        :param pulumi.Input[_builtins.str] ref: Allows indirect references between schema nodes. The value should be a
               valid reference to a child of the root `defs`.
               For example, the following schema defines a reference to a schema node
               named "Pet":
               type: object
               properties:
               pet:
               ref: #/defs/Pet
               defs:
               Pet:
               type: object
               properties:
               name:
               type: string
               The value of the "pet" property is a reference to the schema node
               named "Pet".
               See details in
               https://json-schema.org/understanding-json-schema/structuring.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] requireds: Required properties of Type.OBJECT.
        :param pulumi.Input[_builtins.bool] unique_items: Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        pulumi.set(__self__, "type", type)
        if additional_properties is not None:
            pulumi.set(__self__, "additional_properties", additional_properties)
        if any_of is not None:
            pulumi.set(__self__, "any_of", any_of)
        if default is not None:
            pulumi.set(__self__, "default", default)
        if defs is not None:
            pulumi.set(__self__, "defs", defs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if enums is not None:
            pulumi.set(__self__, "enums", enums)
        if items is not None:
            pulumi.set(__self__, "items", items)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if prefix_items is not None:
            pulumi.set(__self__, "prefix_items", prefix_items)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if ref is not None:
            pulumi.set(__self__, "ref", ref)
        if requireds is not None:
            pulumi.set(__self__, "requireds", requireds)
        if unique_items is not None:
            pulumi.set(__self__, "unique_items", unique_items)

    @_builtins.property
    @pulumi.getter
    def type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of the data.
        Possible values:
        STRING
        INTEGER
        NUMBER
        BOOLEAN
        OBJECT
        ARRAY
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "type", value)

    @_builtins.property
    @pulumi.getter(name="additionalProperties")
    def additional_properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Defines the schema for additional properties allowed in an object.
        The value must be a valid JSON string representing the Schema object.
        (Note: OpenAPI also allows a boolean, this definition expects a Schema JSON).
        """
        return pulumi.get(self, "additional_properties")

    @additional_properties.setter
    def additional_properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "additional_properties", value)

    @_builtins.property
    @pulumi.getter(name="anyOf")
    def any_of(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. The instance value should be valid against at least one of the schemas in this list.
        """
        return pulumi.get(self, "any_of")

    @any_of.setter
    def any_of(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "any_of", value)

    @_builtins.property
    @pulumi.getter
    def default(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Default value of the data. Represents a dynamically typed value
        which can be either null, a number, a string, a boolean, a struct,
        or a list of values. The provided default value must be compatible
        with the defined 'type' and other schema constraints.
        """
        return pulumi.get(self, "default")

    @default.setter
    def default(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "default", value)

    @_builtins.property
    @pulumi.getter
    def defs(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A map of definitions for use by ref. Only allowed at the root of the schema.
        """
        return pulumi.get(self, "defs")

    @defs.setter
    def defs(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "defs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The description of the data.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def enums(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Possible values of the element of primitive type with enum format.
        Examples:
        1. We can define direction as :
        {type:STRING, format:enum, enum:["EAST", NORTH", "SOUTH", "WEST"]}
        2. We can define apartment number as :
        {type:INTEGER, format:enum, enum:["101", "201", "301"]}
        """
        return pulumi.get(self, "enums")

    @enums.setter
    def enums(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "enums", value)

    @_builtins.property
    @pulumi.getter
    def items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Schema of the elements of Type.ARRAY.
        """
        return pulumi.get(self, "items")

    @items.setter
    def items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "items", value)

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates if the value may be null.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "nullable", value)

    @_builtins.property
    @pulumi.getter(name="prefixItems")
    def prefix_items(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Schemas of initial elements of Type.ARRAY.
        """
        return pulumi.get(self, "prefix_items")

    @prefix_items.setter
    def prefix_items(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prefix_items", value)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Properties of Type.OBJECT.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "properties", value)

    @_builtins.property
    @pulumi.getter
    def ref(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Allows indirect references between schema nodes. The value should be a
        valid reference to a child of the root `defs`.
        For example, the following schema defines a reference to a schema node
        named "Pet":
        type: object
        properties:
        pet:
        ref: #/defs/Pet
        defs:
        Pet:
        type: object
        properties:
        name:
        type: string
        The value of the "pet" property is a reference to the schema node
        named "Pet".
        See details in
        https://json-schema.org/understanding-json-schema/structuring.
        """
        return pulumi.get(self, "ref")

    @ref.setter
    def ref(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ref", value)

    @_builtins.property
    @pulumi.getter
    def requireds(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Required properties of Type.OBJECT.
        """
        return pulumi.get(self, "requireds")

    @requireds.setter
    def requireds(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "requireds", value)

    @_builtins.property
    @pulumi.getter(name="uniqueItems")
    def unique_items(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicate the items in the array must be unique. Only applies to TYPE.ARRAY.
        """
        return pulumi.get(self, "unique_items")

    @unique_items.setter
    def unique_items(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "unique_items", value)


if not MYPY:
    class ToolDataStoreToolArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The data store tool name.
        """
        boost_specs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecArgsDict']]]]
        """
        Boost specification to boost certain documents.
        Structure is documented below.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        The tool description.
        """
        engine_source: NotRequired[pulumi.Input['ToolDataStoreToolEngineSourceArgsDict']]
        """
        Configuration for searching within an Engine, potentially targeting
        specific DataStores.
        Structure is documented below.
        """
        max_results: NotRequired[pulumi.Input[_builtins.int]]
        """
        Number of search results to return per query.
        The default value is 10. The maximum allowed value is 10.
        """
        modality_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolModalityConfigArgsDict']]]]
        """
        The modality configs for the data store.
        Structure is documented below.
        """
elif False:
    ToolDataStoreToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 boost_specs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 engine_source: Optional[pulumi.Input['ToolDataStoreToolEngineSourceArgs']] = None,
                 max_results: Optional[pulumi.Input[_builtins.int]] = None,
                 modality_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolModalityConfigArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The data store tool name.
        :param pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecArgs']]] boost_specs: Boost specification to boost certain documents.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] description: The tool description.
        :param pulumi.Input['ToolDataStoreToolEngineSourceArgs'] engine_source: Configuration for searching within an Engine, potentially targeting
               specific DataStores.
               Structure is documented below.
        :param pulumi.Input[_builtins.int] max_results: Number of search results to return per query.
               The default value is 10. The maximum allowed value is 10.
        :param pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolModalityConfigArgs']]] modality_configs: The modality configs for the data store.
               Structure is documented below.
        """
        pulumi.set(__self__, "name", name)
        if boost_specs is not None:
            pulumi.set(__self__, "boost_specs", boost_specs)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if engine_source is not None:
            pulumi.set(__self__, "engine_source", engine_source)
        if max_results is not None:
            pulumi.set(__self__, "max_results", max_results)
        if modality_configs is not None:
            pulumi.set(__self__, "modality_configs", modality_configs)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The data store tool name.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="boostSpecs")
    def boost_specs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecArgs']]]]:
        """
        Boost specification to boost certain documents.
        Structure is documented below.
        """
        return pulumi.get(self, "boost_specs")

    @boost_specs.setter
    def boost_specs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecArgs']]]]):
        pulumi.set(self, "boost_specs", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The tool description.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="engineSource")
    def engine_source(self) -> Optional[pulumi.Input['ToolDataStoreToolEngineSourceArgs']]:
        """
        Configuration for searching within an Engine, potentially targeting
        specific DataStores.
        Structure is documented below.
        """
        return pulumi.get(self, "engine_source")

    @engine_source.setter
    def engine_source(self, value: Optional[pulumi.Input['ToolDataStoreToolEngineSourceArgs']]):
        pulumi.set(self, "engine_source", value)

    @_builtins.property
    @pulumi.getter(name="maxResults")
    def max_results(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Number of search results to return per query.
        The default value is 10. The maximum allowed value is 10.
        """
        return pulumi.get(self, "max_results")

    @max_results.setter
    def max_results(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "max_results", value)

    @_builtins.property
    @pulumi.getter(name="modalityConfigs")
    def modality_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolModalityConfigArgs']]]]:
        """
        The modality configs for the data store.
        Structure is documented below.
        """
        return pulumi.get(self, "modality_configs")

    @modality_configs.setter
    def modality_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolModalityConfigArgs']]]]):
        pulumi.set(self, "modality_configs", value)


if not MYPY:
    class ToolDataStoreToolBoostSpecArgsDict(TypedDict):
        data_stores: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The Data Store where the boosting configuration is applied. Full resource
        name of DataStore, such as
        projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}.
        """
        specs: pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecArgsDict']]]
        """
        A list of boosting specifications.
        Structure is documented below.
        """
elif False:
    ToolDataStoreToolBoostSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolBoostSpecArgs:
    def __init__(__self__, *,
                 data_stores: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 specs: pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] data_stores: The Data Store where the boosting configuration is applied. Full resource
               name of DataStore, such as
               projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}.
        :param pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecArgs']]] specs: A list of boosting specifications.
               Structure is documented below.
        """
        pulumi.set(__self__, "data_stores", data_stores)
        pulumi.set(__self__, "specs", specs)

    @_builtins.property
    @pulumi.getter(name="dataStores")
    def data_stores(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The Data Store where the boosting configuration is applied. Full resource
        name of DataStore, such as
        projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}.
        """
        return pulumi.get(self, "data_stores")

    @data_stores.setter
    def data_stores(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "data_stores", value)

    @_builtins.property
    @pulumi.getter
    def specs(self) -> pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecArgs']]]:
        """
        A list of boosting specifications.
        Structure is documented below.
        """
        return pulumi.get(self, "specs")

    @specs.setter
    def specs(self, value: pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecArgs']]]):
        pulumi.set(self, "specs", value)


if not MYPY:
    class ToolDataStoreToolBoostSpecSpecArgsDict(TypedDict):
        condition_boost_specs: pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgsDict']]]
        """
        A list of boosting specifications.
        Structure is documented below.
        """
elif False:
    ToolDataStoreToolBoostSpecSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolBoostSpecSpecArgs:
    def __init__(__self__, *,
                 condition_boost_specs: pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs']]] condition_boost_specs: A list of boosting specifications.
               Structure is documented below.
        """
        pulumi.set(__self__, "condition_boost_specs", condition_boost_specs)

    @_builtins.property
    @pulumi.getter(name="conditionBoostSpecs")
    def condition_boost_specs(self) -> pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs']]]:
        """
        A list of boosting specifications.
        Structure is documented below.
        """
        return pulumi.get(self, "condition_boost_specs")

    @condition_boost_specs.setter
    def condition_boost_specs(self, value: pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs']]]):
        pulumi.set(self, "condition_boost_specs", value)


if not MYPY:
    class ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgsDict(TypedDict):
        condition: pulumi.Input[_builtins.str]
        """
        An expression which specifies a boost condition. The syntax is the same
        as filter expression syntax. Currently, the only supported condition is
        a list of BCP-47 lang codes.
        Example: To boost suggestions in languages en or fr:
        (lang_code: ANY("en", "fr"))
        """
        boost: NotRequired[pulumi.Input[_builtins.float]]
        """
        Strength of the boost, which should be in [-1, 1]. Negative boost means
        demotion. Default is 0.0.
        Setting to 1.0 gives the suggestions a big promotion. However, it does
        not necessarily mean that the top result will be a boosted suggestion.
        Setting to -1.0 gives the suggestions a big demotion. However, other
        suggestions that are relevant might still be shown.
        Setting to 0.0 means no boost applied. The boosting condition is
        ignored.
        """
        boost_control_spec: NotRequired[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgsDict']]
        """
        Specification for custom ranking based on customer specified attribute
        value. It provides more controls for customized ranking than the simple
        (condition, boost) combination above.
        Structure is documented below.
        """
elif False:
    ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolBoostSpecSpecConditionBoostSpecArgs:
    def __init__(__self__, *,
                 condition: pulumi.Input[_builtins.str],
                 boost: Optional[pulumi.Input[_builtins.float]] = None,
                 boost_control_spec: Optional[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] condition: An expression which specifies a boost condition. The syntax is the same
               as filter expression syntax. Currently, the only supported condition is
               a list of BCP-47 lang codes.
               Example: To boost suggestions in languages en or fr:
               (lang_code: ANY("en", "fr"))
        :param pulumi.Input[_builtins.float] boost: Strength of the boost, which should be in [-1, 1]. Negative boost means
               demotion. Default is 0.0.
               Setting to 1.0 gives the suggestions a big promotion. However, it does
               not necessarily mean that the top result will be a boosted suggestion.
               Setting to -1.0 gives the suggestions a big demotion. However, other
               suggestions that are relevant might still be shown.
               Setting to 0.0 means no boost applied. The boosting condition is
               ignored.
        :param pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs'] boost_control_spec: Specification for custom ranking based on customer specified attribute
               value. It provides more controls for customized ranking than the simple
               (condition, boost) combination above.
               Structure is documented below.
        """
        pulumi.set(__self__, "condition", condition)
        if boost is not None:
            pulumi.set(__self__, "boost", boost)
        if boost_control_spec is not None:
            pulumi.set(__self__, "boost_control_spec", boost_control_spec)

    @_builtins.property
    @pulumi.getter
    def condition(self) -> pulumi.Input[_builtins.str]:
        """
        An expression which specifies a boost condition. The syntax is the same
        as filter expression syntax. Currently, the only supported condition is
        a list of BCP-47 lang codes.
        Example: To boost suggestions in languages en or fr:
        (lang_code: ANY("en", "fr"))
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "condition", value)

    @_builtins.property
    @pulumi.getter
    def boost(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        Strength of the boost, which should be in [-1, 1]. Negative boost means
        demotion. Default is 0.0.
        Setting to 1.0 gives the suggestions a big promotion. However, it does
        not necessarily mean that the top result will be a boosted suggestion.
        Setting to -1.0 gives the suggestions a big demotion. However, other
        suggestions that are relevant might still be shown.
        Setting to 0.0 means no boost applied. The boosting condition is
        ignored.
        """
        return pulumi.get(self, "boost")

    @boost.setter
    def boost(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "boost", value)

    @_builtins.property
    @pulumi.getter(name="boostControlSpec")
    def boost_control_spec(self) -> Optional[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs']]:
        """
        Specification for custom ranking based on customer specified attribute
        value. It provides more controls for customized ranking than the simple
        (condition, boost) combination above.
        Structure is documented below.
        """
        return pulumi.get(self, "boost_control_spec")

    @boost_control_spec.setter
    def boost_control_spec(self, value: Optional[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs']]):
        pulumi.set(self, "boost_control_spec", value)


if not MYPY:
    class ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgsDict(TypedDict):
        attribute_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The attribute type to be used to determine the boost amount. The
        attribute value can be derived from the field value of the specified
        field_name. In the case of numerical it is straightforward i.e.
        attribute_value = numerical_field_value. In the case of freshness
        however, attribute_value = (time.now() - datetime_field_value).
        Possible values:
        NUMERICAL
        FRESHNESS
        """
        control_points: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgsDict']]]]
        """
        The control points used to define the curve. The monotonic function
        (defined through the interpolation_type above) passes through the
        control points listed here.
        Structure is documented below.
        """
        field_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the field whose value will be used to determine the
        boost amount.
        """
        interpolation_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The interpolation type to be applied to connect the control points
        listed below.
        Possible values:
        LINEAR
        """
elif False:
    ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecArgs:
    def __init__(__self__, *,
                 attribute_type: Optional[pulumi.Input[_builtins.str]] = None,
                 control_points: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs']]]] = None,
                 field_name: Optional[pulumi.Input[_builtins.str]] = None,
                 interpolation_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] attribute_type: The attribute type to be used to determine the boost amount. The
               attribute value can be derived from the field value of the specified
               field_name. In the case of numerical it is straightforward i.e.
               attribute_value = numerical_field_value. In the case of freshness
               however, attribute_value = (time.now() - datetime_field_value).
               Possible values:
               NUMERICAL
               FRESHNESS
        :param pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs']]] control_points: The control points used to define the curve. The monotonic function
               (defined through the interpolation_type above) passes through the
               control points listed here.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] field_name: The name of the field whose value will be used to determine the
               boost amount.
        :param pulumi.Input[_builtins.str] interpolation_type: The interpolation type to be applied to connect the control points
               listed below.
               Possible values:
               LINEAR
        """
        if attribute_type is not None:
            pulumi.set(__self__, "attribute_type", attribute_type)
        if control_points is not None:
            pulumi.set(__self__, "control_points", control_points)
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)
        if interpolation_type is not None:
            pulumi.set(__self__, "interpolation_type", interpolation_type)

    @_builtins.property
    @pulumi.getter(name="attributeType")
    def attribute_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The attribute type to be used to determine the boost amount. The
        attribute value can be derived from the field value of the specified
        field_name. In the case of numerical it is straightforward i.e.
        attribute_value = numerical_field_value. In the case of freshness
        however, attribute_value = (time.now() - datetime_field_value).
        Possible values:
        NUMERICAL
        FRESHNESS
        """
        return pulumi.get(self, "attribute_type")

    @attribute_type.setter
    def attribute_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_type", value)

    @_builtins.property
    @pulumi.getter(name="controlPoints")
    def control_points(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs']]]]:
        """
        The control points used to define the curve. The monotonic function
        (defined through the interpolation_type above) passes through the
        control points listed here.
        Structure is documented below.
        """
        return pulumi.get(self, "control_points")

    @control_points.setter
    def control_points(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs']]]]):
        pulumi.set(self, "control_points", value)

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the field whose value will be used to determine the
        boost amount.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "field_name", value)

    @_builtins.property
    @pulumi.getter(name="interpolationType")
    def interpolation_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The interpolation type to be applied to connect the control points
        listed below.
        Possible values:
        LINEAR
        """
        return pulumi.get(self, "interpolation_type")

    @interpolation_type.setter
    def interpolation_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interpolation_type", value)


if not MYPY:
    class ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgsDict(TypedDict):
        attribute_value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Can be one of:
        1. The numerical field value.
        2. The duration spec for freshness:
        The value must be formatted as an XSD `dayTimeDuration` value (a
        restricted subset of an ISO 8601 duration value). The pattern for
        this is: `nDnM]`.
        """
        boost_amount: NotRequired[pulumi.Input[_builtins.float]]
        """
        The value between -1 to 1 by which to boost the score if the
        attribute_value evaluates to the value specified above.
        """
elif False:
    ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolBoostSpecSpecConditionBoostSpecBoostControlSpecControlPointArgs:
    def __init__(__self__, *,
                 attribute_value: Optional[pulumi.Input[_builtins.str]] = None,
                 boost_amount: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] attribute_value: Can be one of:
               1. The numerical field value.
               2. The duration spec for freshness:
               The value must be formatted as an XSD `dayTimeDuration` value (a
               restricted subset of an ISO 8601 duration value). The pattern for
               this is: `nDnM]`.
        :param pulumi.Input[_builtins.float] boost_amount: The value between -1 to 1 by which to boost the score if the
               attribute_value evaluates to the value specified above.
        """
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if boost_amount is not None:
            pulumi.set(__self__, "boost_amount", boost_amount)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Can be one of:
        1. The numerical field value.
        2. The duration spec for freshness:
        The value must be formatted as an XSD `dayTimeDuration` value (a
        restricted subset of an ISO 8601 duration value). The pattern for
        this is: `nDnM]`.
        """
        return pulumi.get(self, "attribute_value")

    @attribute_value.setter
    def attribute_value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "attribute_value", value)

    @_builtins.property
    @pulumi.getter(name="boostAmount")
    def boost_amount(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The value between -1 to 1 by which to boost the score if the
        attribute_value evaluates to the value specified above.
        """
        return pulumi.get(self, "boost_amount")

    @boost_amount.setter
    def boost_amount(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "boost_amount", value)


if not MYPY:
    class ToolDataStoreToolEngineSourceArgsDict(TypedDict):
        engine: pulumi.Input[_builtins.str]
        """
        Full resource name of the Engine.
        Format:
        `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
        """
        data_store_sources: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceArgsDict']]]]
        """
        Use to target specific DataStores within the Engine.
        If empty, the search applies to all DataStores associated with the
        Engine.
        Structure is documented below.
        """
        filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        A filter applied to the search across the Engine. Not relevant and not
        used if 'data_store_sources' is provided.
        See:
        https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
elif False:
    ToolDataStoreToolEngineSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolEngineSourceArgs:
    def __init__(__self__, *,
                 engine: pulumi.Input[_builtins.str],
                 data_store_sources: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceArgs']]]] = None,
                 filter: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] engine: Full resource name of the Engine.
               Format:
               `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
        :param pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceArgs']]] data_store_sources: Use to target specific DataStores within the Engine.
               If empty, the search applies to all DataStores associated with the
               Engine.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] filter: A filter applied to the search across the Engine. Not relevant and not
               used if 'data_store_sources' is provided.
               See:
               https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        pulumi.set(__self__, "engine", engine)
        if data_store_sources is not None:
            pulumi.set(__self__, "data_store_sources", data_store_sources)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)

    @_builtins.property
    @pulumi.getter
    def engine(self) -> pulumi.Input[_builtins.str]:
        """
        Full resource name of the Engine.
        Format:
        `projects/{project}/locations/{location}/collections/{collection}/engines/{engine}`
        """
        return pulumi.get(self, "engine")

    @engine.setter
    def engine(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "engine", value)

    @_builtins.property
    @pulumi.getter(name="dataStoreSources")
    def data_store_sources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceArgs']]]]:
        """
        Use to target specific DataStores within the Engine.
        If empty, the search applies to all DataStores associated with the
        Engine.
        Structure is documented below.
        """
        return pulumi.get(self, "data_store_sources")

    @data_store_sources.setter
    def data_store_sources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceArgs']]]]):
        pulumi.set(self, "data_store_sources", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A filter applied to the search across the Engine. Not relevant and not
        used if 'data_store_sources' is provided.
        See:
        https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter", value)


if not MYPY:
    class ToolDataStoreToolEngineSourceDataStoreSourceArgsDict(TypedDict):
        data_store: NotRequired[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgsDict']]
        """
        A DataStore resource in Vertex AI Search.
        Structure is documented below.
        """
        filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Filter specification for the DataStore.
        See:
        https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
elif False:
    ToolDataStoreToolEngineSourceDataStoreSourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolEngineSourceDataStoreSourceArgs:
    def __init__(__self__, *,
                 data_store: Optional[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs']] = None,
                 filter: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs'] data_store: A DataStore resource in Vertex AI Search.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] filter: Filter specification for the DataStore.
               See:
               https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        if data_store is not None:
            pulumi.set(__self__, "data_store", data_store)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)

    @_builtins.property
    @pulumi.getter(name="dataStore")
    def data_store(self) -> Optional[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs']]:
        """
        A DataStore resource in Vertex AI Search.
        Structure is documented below.
        """
        return pulumi.get(self, "data_store")

    @data_store.setter
    def data_store(self, value: Optional[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs']]):
        pulumi.set(self, "data_store", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Filter specification for the DataStore.
        See:
        https://cloud.google.com/generative-ai-app-builder/docs/filter-search-metadata
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter", value)


if not MYPY:
    class ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        Full resource name of the DataStore.
        Format:
        `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
        """
        connector_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgsDict']]]]
        """
        (Output)
        The connector config for the data store connection.
        Structure is documented below.
        """
        create_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Timestamp when the data store was created.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The display name of the data store.
        """
        document_processing_mode: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The document processing mode for the data store connection.
        Only set for PUBLIC_WEB and UNSTRUCTURED data stores.
        Possible values:
        DOCUMENTS
        CHUNKS
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR


        <a name="nested_data_store_tool_engine_source_data_store_sources_data_store_sources_data_store_connector_config"></a>The `connector_config` block contains:
        """
elif False:
    ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolEngineSourceDataStoreSourceDataStoreArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 connector_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs']]]] = None,
                 create_time: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 document_processing_mode: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Full resource name of the DataStore.
               Format:
               `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
        :param pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs']]] connector_configs: (Output)
               The connector config for the data store connection.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] create_time: (Output)
               Timestamp when the data store was created.
        :param pulumi.Input[_builtins.str] display_name: (Output)
               The display name of the data store.
        :param pulumi.Input[_builtins.str] document_processing_mode: (Output)
               The document processing mode for the data store connection.
               Only set for PUBLIC_WEB and UNSTRUCTURED data stores.
               Possible values:
               DOCUMENTS
               CHUNKS
        :param pulumi.Input[_builtins.str] type: (Output)
               The type of the data store. This field is readonly and populated by the
               server.
               Possible values:
               PUBLIC_WEB
               UNSTRUCTURED
               FAQ
               CONNECTOR
               
               
               <a name="nested_data_store_tool_engine_source_data_store_sources_data_store_sources_data_store_connector_config"></a>The `connector_config` block contains:
        """
        pulumi.set(__self__, "name", name)
        if connector_configs is not None:
            pulumi.set(__self__, "connector_configs", connector_configs)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if document_processing_mode is not None:
            pulumi.set(__self__, "document_processing_mode", document_processing_mode)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        Full resource name of the DataStore.
        Format:
        `projects/{project}/locations/{location}/collections/{collection}/dataStores/{dataStore}`
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="connectorConfigs")
    def connector_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs']]]]:
        """
        (Output)
        The connector config for the data store connection.
        Structure is documented below.
        """
        return pulumi.get(self, "connector_configs")

    @connector_configs.setter
    def connector_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs']]]]):
        pulumi.set(self, "connector_configs", value)

    @_builtins.property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Timestamp when the data store was created.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create_time", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The display name of the data store.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)

    @_builtins.property
    @pulumi.getter(name="documentProcessingMode")
    def document_processing_mode(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The document processing mode for the data store connection.
        Only set for PUBLIC_WEB and UNSTRUCTURED data stores.
        Possible values:
        DOCUMENTS
        CHUNKS
        """
        return pulumi.get(self, "document_processing_mode")

    @document_processing_mode.setter
    def document_processing_mode(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "document_processing_mode", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The type of the data store. This field is readonly and populated by the
        server.
        Possible values:
        PUBLIC_WEB
        UNSTRUCTURED
        FAQ
        CONNECTOR


        <a name="nested_data_store_tool_engine_source_data_store_sources_data_store_sources_data_store_connector_config"></a>The `connector_config` block contains:
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgsDict(TypedDict):
        collection: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource name of the collection the data store belongs to.
        """
        collection_display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Display name of the collection the data store belongs to.
        """
        data_source: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the data source.
        Example: 'salesforce', 'jira', 'confluence', 'bigquery'.
        """
elif False:
    ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolEngineSourceDataStoreSourceDataStoreConnectorConfigArgs:
    def __init__(__self__, *,
                 collection: Optional[pulumi.Input[_builtins.str]] = None,
                 collection_display_name: Optional[pulumi.Input[_builtins.str]] = None,
                 data_source: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] collection: Resource name of the collection the data store belongs to.
        :param pulumi.Input[_builtins.str] collection_display_name: Display name of the collection the data store belongs to.
        :param pulumi.Input[_builtins.str] data_source: The name of the data source.
               Example: 'salesforce', 'jira', 'confluence', 'bigquery'.
        """
        if collection is not None:
            pulumi.set(__self__, "collection", collection)
        if collection_display_name is not None:
            pulumi.set(__self__, "collection_display_name", collection_display_name)
        if data_source is not None:
            pulumi.set(__self__, "data_source", data_source)

    @_builtins.property
    @pulumi.getter
    def collection(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource name of the collection the data store belongs to.
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "collection", value)

    @_builtins.property
    @pulumi.getter(name="collectionDisplayName")
    def collection_display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Display name of the collection the data store belongs to.
        """
        return pulumi.get(self, "collection_display_name")

    @collection_display_name.setter
    def collection_display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "collection_display_name", value)

    @_builtins.property
    @pulumi.getter(name="dataSource")
    def data_source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the data source.
        Example: 'salesforce', 'jira', 'confluence', 'bigquery'.
        """
        return pulumi.get(self, "data_source")

    @data_source.setter
    def data_source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "data_source", value)


if not MYPY:
    class ToolDataStoreToolModalityConfigArgsDict(TypedDict):
        modality_type: pulumi.Input[_builtins.str]
        """
        The modality type.
        Possible values:
        TEXT
        AUDIO
        """
        grounding_config: NotRequired[pulumi.Input['ToolDataStoreToolModalityConfigGroundingConfigArgsDict']]
        """
        Grounding configuration.
        Structure is documented below.
        """
        rewriter_config: NotRequired[pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigArgsDict']]
        """
        Rewriter configuration.
        Structure is documented below.
        """
        summarization_config: NotRequired[pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigArgsDict']]
        """
        Summarization configuration.
        Structure is documented below.
        """
elif False:
    ToolDataStoreToolModalityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolModalityConfigArgs:
    def __init__(__self__, *,
                 modality_type: pulumi.Input[_builtins.str],
                 grounding_config: Optional[pulumi.Input['ToolDataStoreToolModalityConfigGroundingConfigArgs']] = None,
                 rewriter_config: Optional[pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigArgs']] = None,
                 summarization_config: Optional[pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] modality_type: The modality type.
               Possible values:
               TEXT
               AUDIO
        :param pulumi.Input['ToolDataStoreToolModalityConfigGroundingConfigArgs'] grounding_config: Grounding configuration.
               Structure is documented below.
        :param pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigArgs'] rewriter_config: Rewriter configuration.
               Structure is documented below.
        :param pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigArgs'] summarization_config: Summarization configuration.
               Structure is documented below.
        """
        pulumi.set(__self__, "modality_type", modality_type)
        if grounding_config is not None:
            pulumi.set(__self__, "grounding_config", grounding_config)
        if rewriter_config is not None:
            pulumi.set(__self__, "rewriter_config", rewriter_config)
        if summarization_config is not None:
            pulumi.set(__self__, "summarization_config", summarization_config)

    @_builtins.property
    @pulumi.getter(name="modalityType")
    def modality_type(self) -> pulumi.Input[_builtins.str]:
        """
        The modality type.
        Possible values:
        TEXT
        AUDIO
        """
        return pulumi.get(self, "modality_type")

    @modality_type.setter
    def modality_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "modality_type", value)

    @_builtins.property
    @pulumi.getter(name="groundingConfig")
    def grounding_config(self) -> Optional[pulumi.Input['ToolDataStoreToolModalityConfigGroundingConfigArgs']]:
        """
        Grounding configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "grounding_config")

    @grounding_config.setter
    def grounding_config(self, value: Optional[pulumi.Input['ToolDataStoreToolModalityConfigGroundingConfigArgs']]):
        pulumi.set(self, "grounding_config", value)

    @_builtins.property
    @pulumi.getter(name="rewriterConfig")
    def rewriter_config(self) -> Optional[pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigArgs']]:
        """
        Rewriter configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "rewriter_config")

    @rewriter_config.setter
    def rewriter_config(self, value: Optional[pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigArgs']]):
        pulumi.set(self, "rewriter_config", value)

    @_builtins.property
    @pulumi.getter(name="summarizationConfig")
    def summarization_config(self) -> Optional[pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigArgs']]:
        """
        Summarization configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "summarization_config")

    @summarization_config.setter
    def summarization_config(self, value: Optional[pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigArgs']]):
        pulumi.set(self, "summarization_config", value)


if not MYPY:
    class ToolDataStoreToolModalityConfigGroundingConfigArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether grounding is disabled.
        """
        grounding_level: NotRequired[pulumi.Input[_builtins.float]]
        """
        The groundedness threshold of the answer based on the retrieved sources.
        The value has a configurable range of [1, 5]. The level is used to
        threshold the groundedness of the answer, meaning that all responses with
        a groundedness score below the threshold will fall back to returning
        relevant snippets only.
        For example, a level of 3 means that the groundedness score must be
        3 or higher for the response to be returned.
        """
elif False:
    ToolDataStoreToolModalityConfigGroundingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolModalityConfigGroundingConfigArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 grounding_level: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.bool] disabled: Whether grounding is disabled.
        :param pulumi.Input[_builtins.float] grounding_level: The groundedness threshold of the answer based on the retrieved sources.
               The value has a configurable range of [1, 5]. The level is used to
               threshold the groundedness of the answer, meaning that all responses with
               a groundedness score below the threshold will fall back to returning
               relevant snippets only.
               For example, a level of 3 means that the groundedness score must be
               3 or higher for the response to be returned.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if grounding_level is not None:
            pulumi.set(__self__, "grounding_level", grounding_level)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether grounding is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="groundingLevel")
    def grounding_level(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The groundedness threshold of the answer based on the retrieved sources.
        The value has a configurable range of [1, 5]. The level is used to
        threshold the groundedness of the answer, meaning that all responses with
        a groundedness score below the threshold will fall back to returning
        relevant snippets only.
        For example, a level of 3 means that the groundedness score must be
        3 or higher for the response to be returned.
        """
        return pulumi.get(self, "grounding_level")

    @grounding_level.setter
    def grounding_level(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "grounding_level", value)


if not MYPY:
    class ToolDataStoreToolModalityConfigRewriterConfigArgsDict(TypedDict):
        model_settings: pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgsDict']
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether the rewriter is disabled.
        """
        prompt: NotRequired[pulumi.Input[_builtins.str]]
        """
        The prompt definition. If not set, default prompt will be used.
        """
elif False:
    ToolDataStoreToolModalityConfigRewriterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolModalityConfigRewriterConfigArgs:
    def __init__(__self__, *,
                 model_settings: pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgs'],
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 prompt: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgs'] model_settings: Model settings contains various configurations for the LLM model.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] disabled: Whether the rewriter is disabled.
        :param pulumi.Input[_builtins.str] prompt: The prompt definition. If not set, default prompt will be used.
        """
        pulumi.set(__self__, "model_settings", model_settings)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgs']:
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @model_settings.setter
    def model_settings(self, value: pulumi.Input['ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgs']):
        pulumi.set(self, "model_settings", value)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether the rewriter is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The prompt definition. If not set, default prompt will be used.
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prompt", value)


if not MYPY:
    class ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
elif False:
    ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolModalityConfigRewriterConfigModelSettingsArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] model: The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param pulumi.Input[_builtins.float] temperature: If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)


if not MYPY:
    class ToolDataStoreToolModalityConfigSummarizationConfigArgsDict(TypedDict):
        disabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether summarization is disabled.
        """
        model_settings: NotRequired[pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgsDict']]
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        prompt: NotRequired[pulumi.Input[_builtins.str]]
        """
        The prompt definition. If not set, default prompt will be used.
        """
elif False:
    ToolDataStoreToolModalityConfigSummarizationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolModalityConfigSummarizationConfigArgs:
    def __init__(__self__, *,
                 disabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 model_settings: Optional[pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgs']] = None,
                 prompt: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] disabled: Whether summarization is disabled.
        :param pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgs'] model_settings: Model settings contains various configurations for the LLM model.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] prompt: The prompt definition. If not set, default prompt will be used.
        """
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if model_settings is not None:
            pulumi.set(__self__, "model_settings", model_settings)
        if prompt is not None:
            pulumi.set(__self__, "prompt", prompt)

    @_builtins.property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether summarization is disabled.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disabled", value)

    @_builtins.property
    @pulumi.getter(name="modelSettings")
    def model_settings(self) -> Optional[pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgs']]:
        """
        Model settings contains various configurations for the LLM model.
        Structure is documented below.
        """
        return pulumi.get(self, "model_settings")

    @model_settings.setter
    def model_settings(self, value: Optional[pulumi.Input['ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgs']]):
        pulumi.set(self, "model_settings", value)

    @_builtins.property
    @pulumi.getter
    def prompt(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The prompt definition. If not set, default prompt will be used.
        """
        return pulumi.get(self, "prompt")

    @prompt.setter
    def prompt(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "prompt", value)


if not MYPY:
    class ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgsDict(TypedDict):
        model: NotRequired[pulumi.Input[_builtins.str]]
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        temperature: NotRequired[pulumi.Input[_builtins.float]]
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
elif False:
    ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolDataStoreToolModalityConfigSummarizationConfigModelSettingsArgs:
    def __init__(__self__, *,
                 model: Optional[pulumi.Input[_builtins.str]] = None,
                 temperature: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] model: The LLM model that the agent should use.
               If not set, the agent will inherit the model from its parent agent.
        :param pulumi.Input[_builtins.float] temperature: If set, this temperature will be used for the LLM model. Temperature
               controls the randomness of the model's responses. Lower temperatures
               produce responses that are more predictable. Higher temperatures produce
               responses that are more creative.
        """
        if model is not None:
            pulumi.set(__self__, "model", model)
        if temperature is not None:
            pulumi.set(__self__, "temperature", temperature)

    @_builtins.property
    @pulumi.getter
    def model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The LLM model that the agent should use.
        If not set, the agent will inherit the model from its parent agent.
        """
        return pulumi.get(self, "model")

    @model.setter
    def model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "model", value)

    @_builtins.property
    @pulumi.getter
    def temperature(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        If set, this temperature will be used for the LLM model. Temperature
        controls the randomness of the model's responses. Lower temperatures
        produce responses that are more predictable. Higher temperatures produce
        responses that are more creative.
        """
        return pulumi.get(self, "temperature")

    @temperature.setter
    def temperature(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "temperature", value)


if not MYPY:
    class ToolGoogleSearchToolArgsDict(TypedDict):
        name: pulumi.Input[_builtins.str]
        """
        The name of the tool.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        Description of the tool's purpose.
        """
        exclude_domains: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of domains to be excluded from the search results.
        Example: "example.com".
        A maximum of 2000 domains can be excluded.
        """
elif False:
    ToolGoogleSearchToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolGoogleSearchToolArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 exclude_domains: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The name of the tool.
        :param pulumi.Input[_builtins.str] description: Description of the tool's purpose.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_domains: List of domains to be excluded from the search results.
               Example: "example.com".
               A maximum of 2000 domains can be excluded.
        """
        pulumi.set(__self__, "name", name)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if exclude_domains is not None:
            pulumi.set(__self__, "exclude_domains", exclude_domains)

    @_builtins.property
    @pulumi.getter
    def name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the tool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Description of the tool's purpose.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="excludeDomains")
    def exclude_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of domains to be excluded from the search results.
        Example: "example.com".
        A maximum of 2000 domains can be excluded.
        """
        return pulumi.get(self, "exclude_domains")

    @exclude_domains.setter
    def exclude_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_domains", value)


if not MYPY:
    class ToolOpenApiToolArgsDict(TypedDict):
        api_authentications: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationArgsDict']]]]
        """
        (Output)
        Authentication information required for API calls.
        Structure is documented below.
        """
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The description of the system tool.
        """
        ignore_unknown_fields: NotRequired[pulumi.Input[_builtins.bool]]
        """
        (Output)
        If true, the agent will ignore unknown fields in the API response.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the system tool.
        """
        open_api_schema: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The OpenAPI schema in JSON or YAML format.
        """
        service_directory_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolServiceDirectoryConfigArgsDict']]]]
        """
        (Output)
        Configuration for tools using Service Directory.
        Structure is documented below.
        """
        tls_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigArgsDict']]]]
        """
        (Output)
        The TLS configuration.
        Structure is documented below.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The server URL of the Open API schema. This field is only set in tools in the
        environment dependencies during the export process if the schema contains a
        server url. During the import process, if this url is present in the environment
        dependencies and the schema has the $env_var placeholder, it will replace the
        placeholder in the schema.
        """
elif False:
    ToolOpenApiToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolOpenApiToolArgs:
    def __init__(__self__, *,
                 api_authentications: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationArgs']]]] = None,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 ignore_unknown_fields: Optional[pulumi.Input[_builtins.bool]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 open_api_schema: Optional[pulumi.Input[_builtins.str]] = None,
                 service_directory_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolServiceDirectoryConfigArgs']]]] = None,
                 tls_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigArgs']]]] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationArgs']]] api_authentications: (Output)
               Authentication information required for API calls.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] description: (Output)
               The description of the system tool.
        :param pulumi.Input[_builtins.bool] ignore_unknown_fields: (Output)
               If true, the agent will ignore unknown fields in the API response.
        :param pulumi.Input[_builtins.str] name: (Output)
               The name of the system tool.
        :param pulumi.Input[_builtins.str] open_api_schema: (Output)
               The OpenAPI schema in JSON or YAML format.
        :param pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolServiceDirectoryConfigArgs']]] service_directory_configs: (Output)
               Configuration for tools using Service Directory.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigArgs']]] tls_configs: (Output)
               The TLS configuration.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] url: (Output)
               The server URL of the Open API schema. This field is only set in tools in the
               environment dependencies during the export process if the schema contains a
               server url. During the import process, if this url is present in the environment
               dependencies and the schema has the $env_var placeholder, it will replace the
               placeholder in the schema.
        """
        if api_authentications is not None:
            pulumi.set(__self__, "api_authentications", api_authentications)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if ignore_unknown_fields is not None:
            pulumi.set(__self__, "ignore_unknown_fields", ignore_unknown_fields)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if open_api_schema is not None:
            pulumi.set(__self__, "open_api_schema", open_api_schema)
        if service_directory_configs is not None:
            pulumi.set(__self__, "service_directory_configs", service_directory_configs)
        if tls_configs is not None:
            pulumi.set(__self__, "tls_configs", tls_configs)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="apiAuthentications")
    def api_authentications(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationArgs']]]]:
        """
        (Output)
        Authentication information required for API calls.
        Structure is documented below.
        """
        return pulumi.get(self, "api_authentications")

    @api_authentications.setter
    def api_authentications(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationArgs']]]]):
        pulumi.set(self, "api_authentications", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The description of the system tool.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter(name="ignoreUnknownFields")
    def ignore_unknown_fields(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        (Output)
        If true, the agent will ignore unknown fields in the API response.
        """
        return pulumi.get(self, "ignore_unknown_fields")

    @ignore_unknown_fields.setter
    def ignore_unknown_fields(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_unknown_fields", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the system tool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="openApiSchema")
    def open_api_schema(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The OpenAPI schema in JSON or YAML format.
        """
        return pulumi.get(self, "open_api_schema")

    @open_api_schema.setter
    def open_api_schema(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "open_api_schema", value)

    @_builtins.property
    @pulumi.getter(name="serviceDirectoryConfigs")
    def service_directory_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolServiceDirectoryConfigArgs']]]]:
        """
        (Output)
        Configuration for tools using Service Directory.
        Structure is documented below.
        """
        return pulumi.get(self, "service_directory_configs")

    @service_directory_configs.setter
    def service_directory_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolServiceDirectoryConfigArgs']]]]):
        pulumi.set(self, "service_directory_configs", value)

    @_builtins.property
    @pulumi.getter(name="tlsConfigs")
    def tls_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigArgs']]]]:
        """
        (Output)
        The TLS configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "tls_configs")

    @tls_configs.setter
    def tls_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigArgs']]]]):
        pulumi.set(self, "tls_configs", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The server URL of the Open API schema. This field is only set in tools in the
        environment dependencies during the export process if the schema contains a
        server url. During the import process, if this url is present in the environment
        dependencies and the schema has the $env_var placeholder, it will replace the
        placeholder in the schema.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ToolOpenApiToolApiAuthenticationArgsDict(TypedDict):
        api_key_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationApiKeyConfigArgsDict']]]]
        """
        (Output)
        Configurations for authentication with API key.
        Structure is documented below.
        """
        oauth_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationOauthConfigArgsDict']]]]
        """
        (Output)
        Configurations for authentication with OAuth.
        Structure is documented below.
        """
        service_account_auth_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgsDict']]]]
        """
        (Output)
        Configurations for authentication using a custom service account.
        Structure is documented below.
        """
        service_agent_id_token_auth_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict']]]]
        """
        (Output)
        Configurations for authentication with [ID
        token](https://cloud.google.com/docs/authentication/token-types#id) generated
        from service agent.
        """
elif False:
    ToolOpenApiToolApiAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolOpenApiToolApiAuthenticationArgs:
    def __init__(__self__, *,
                 api_key_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationApiKeyConfigArgs']]]] = None,
                 oauth_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationOauthConfigArgs']]]] = None,
                 service_account_auth_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs']]]] = None,
                 service_agent_id_token_auth_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationApiKeyConfigArgs']]] api_key_configs: (Output)
               Configurations for authentication with API key.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationOauthConfigArgs']]] oauth_configs: (Output)
               Configurations for authentication with OAuth.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs']]] service_account_auth_configs: (Output)
               Configurations for authentication using a custom service account.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]] service_agent_id_token_auth_configs: (Output)
               Configurations for authentication with [ID
               token](https://cloud.google.com/docs/authentication/token-types#id) generated
               from service agent.
        """
        if api_key_configs is not None:
            pulumi.set(__self__, "api_key_configs", api_key_configs)
        if oauth_configs is not None:
            pulumi.set(__self__, "oauth_configs", oauth_configs)
        if service_account_auth_configs is not None:
            pulumi.set(__self__, "service_account_auth_configs", service_account_auth_configs)
        if service_agent_id_token_auth_configs is not None:
            pulumi.set(__self__, "service_agent_id_token_auth_configs", service_agent_id_token_auth_configs)

    @_builtins.property
    @pulumi.getter(name="apiKeyConfigs")
    def api_key_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationApiKeyConfigArgs']]]]:
        """
        (Output)
        Configurations for authentication with API key.
        Structure is documented below.
        """
        return pulumi.get(self, "api_key_configs")

    @api_key_configs.setter
    def api_key_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationApiKeyConfigArgs']]]]):
        pulumi.set(self, "api_key_configs", value)

    @_builtins.property
    @pulumi.getter(name="oauthConfigs")
    def oauth_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationOauthConfigArgs']]]]:
        """
        (Output)
        Configurations for authentication with OAuth.
        Structure is documented below.
        """
        return pulumi.get(self, "oauth_configs")

    @oauth_configs.setter
    def oauth_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationOauthConfigArgs']]]]):
        pulumi.set(self, "oauth_configs", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccountAuthConfigs")
    def service_account_auth_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs']]]]:
        """
        (Output)
        Configurations for authentication using a custom service account.
        Structure is documented below.
        """
        return pulumi.get(self, "service_account_auth_configs")

    @service_account_auth_configs.setter
    def service_account_auth_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs']]]]):
        pulumi.set(self, "service_account_auth_configs", value)

    @_builtins.property
    @pulumi.getter(name="serviceAgentIdTokenAuthConfigs")
    def service_agent_id_token_auth_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]]]:
        """
        (Output)
        Configurations for authentication with [ID
        token](https://cloud.google.com/docs/authentication/token-types#id) generated
        from service agent.
        """
        return pulumi.get(self, "service_agent_id_token_auth_configs")

    @service_agent_id_token_auth_configs.setter
    def service_agent_id_token_auth_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]]]):
        pulumi.set(self, "service_agent_id_token_auth_configs", value)


if not MYPY:
    class ToolOpenApiToolApiAuthenticationApiKeyConfigArgsDict(TypedDict):
        api_key_secret_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the SecretManager secret version resource storing the API key.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        key_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        request_location: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Key location in the request.
        Possible values:
        HEADER
        QUERY_STRING
        """
elif False:
    ToolOpenApiToolApiAuthenticationApiKeyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolOpenApiToolApiAuthenticationApiKeyConfigArgs:
    def __init__(__self__, *,
                 api_key_secret_version: Optional[pulumi.Input[_builtins.str]] = None,
                 key_name: Optional[pulumi.Input[_builtins.str]] = None,
                 request_location: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_key_secret_version: (Output)
               The name of the SecretManager secret version resource storing the API key.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        :param pulumi.Input[_builtins.str] key_name: (Output)
               The parameter name or the header name of the API key.
               E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        :param pulumi.Input[_builtins.str] request_location: (Output)
               Key location in the request.
               Possible values:
               HEADER
               QUERY_STRING
        """
        if api_key_secret_version is not None:
            pulumi.set(__self__, "api_key_secret_version", api_key_secret_version)
        if key_name is not None:
            pulumi.set(__self__, "key_name", key_name)
        if request_location is not None:
            pulumi.set(__self__, "request_location", request_location)

    @_builtins.property
    @pulumi.getter(name="apiKeySecretVersion")
    def api_key_secret_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the SecretManager secret version resource storing the API key.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "api_key_secret_version")

    @api_key_secret_version.setter
    def api_key_secret_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_key_secret_version", value)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter(name="requestLocation")
    def request_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Key location in the request.
        Possible values:
        HEADER
        QUERY_STRING
        """
        return pulumi.get(self, "request_location")

    @request_location.setter
    def request_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "request_location", value)


if not MYPY:
    class ToolOpenApiToolApiAuthenticationOauthConfigArgsDict(TypedDict):
        client_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The client ID from the OAuth provider.
        """
        client_secret_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the SecretManager secret version resource storing the
        client secret.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        oauth_grant_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        OAuth grant types.
        Possible values:
        CLIENT_CREDENTIAL
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        The OAuth scopes to grant.
        """
        token_endpoint: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The token endpoint in the OAuth provider to exchange for an access token.
        """
elif False:
    ToolOpenApiToolApiAuthenticationOauthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolOpenApiToolApiAuthenticationOauthConfigArgs:
    def __init__(__self__, *,
                 client_id: Optional[pulumi.Input[_builtins.str]] = None,
                 client_secret_version: Optional[pulumi.Input[_builtins.str]] = None,
                 oauth_grant_type: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 token_endpoint: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id: (Output)
               The client ID from the OAuth provider.
        :param pulumi.Input[_builtins.str] client_secret_version: (Output)
               The name of the SecretManager secret version resource storing the
               client secret.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        :param pulumi.Input[_builtins.str] oauth_grant_type: (Output)
               OAuth grant types.
               Possible values:
               CLIENT_CREDENTIAL
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: (Output)
               The OAuth scopes to grant.
        :param pulumi.Input[_builtins.str] token_endpoint: (Output)
               The token endpoint in the OAuth provider to exchange for an access token.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret_version is not None:
            pulumi.set(__self__, "client_secret_version", client_secret_version)
        if oauth_grant_type is not None:
            pulumi.set(__self__, "oauth_grant_type", oauth_grant_type)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if token_endpoint is not None:
            pulumi.set(__self__, "token_endpoint", token_endpoint)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The client ID from the OAuth provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretVersion")
    def client_secret_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the SecretManager secret version resource storing the
        client secret.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "client_secret_version")

    @client_secret_version.setter
    def client_secret_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "client_secret_version", value)

    @_builtins.property
    @pulumi.getter(name="oauthGrantType")
    def oauth_grant_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        OAuth grant types.
        Possible values:
        CLIENT_CREDENTIAL
        """
        return pulumi.get(self, "oauth_grant_type")

    @oauth_grant_type.setter
    def oauth_grant_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "oauth_grant_type", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        The OAuth scopes to grant.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The token endpoint in the OAuth provider to exchange for an access token.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token_endpoint", value)


if not MYPY:
    class ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgsDict(TypedDict):
        service_account: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The email address of the service account used for authenticatation. CES
        uses this service account to exchange an access token and the access token
        is then sent in the `Authorization` header of the request.
        The service account must have the
        `roles/iam.serviceAccountTokenCreator` role granted to the
        CES service agent
        `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        """
elif False:
    ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolOpenApiToolApiAuthenticationServiceAccountAuthConfigArgs:
    def __init__(__self__, *,
                 service_account: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] service_account: (Output)
               The email address of the service account used for authenticatation. CES
               uses this service account to exchange an access token and the access token
               is then sent in the `Authorization` header of the request.
               The service account must have the
               `roles/iam.serviceAccountTokenCreator` role granted to the
               CES service agent
               `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        if service_account is not None:
            pulumi.set(__self__, "service_account", service_account)

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The email address of the service account used for authenticatation. CES
        uses this service account to exchange an access token and the access token
        is then sent in the `Authorization` header of the request.
        The service account must have the
        `roles/iam.serviceAccountTokenCreator` role granted to the
        CES service agent
        `service-<PROJECT-NUMBER>@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service_account", value)


if not MYPY:
    class ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict(TypedDict):
        pass
elif False:
    ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolOpenApiToolApiAuthenticationServiceAgentIdTokenAuthConfigArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ToolOpenApiToolServiceDirectoryConfigArgsDict(TypedDict):
        service: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of [Service
        Directory](https://cloud.google.com/service-directory) service.
        Format:
        `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
        Location of the service directory must be the same as the location of the
        app.
        """
elif False:
    ToolOpenApiToolServiceDirectoryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolOpenApiToolServiceDirectoryConfigArgs:
    def __init__(__self__, *,
                 service: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] service: (Output)
               The name of [Service
               Directory](https://cloud.google.com/service-directory) service.
               Format:
               `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
               Location of the service directory must be the same as the location of the
               app.
        """
        if service is not None:
            pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of [Service
        Directory](https://cloud.google.com/service-directory) service.
        Format:
        `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
        Location of the service directory must be the same as the location of the
        app.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service", value)


if not MYPY:
    class ToolOpenApiToolTlsConfigArgsDict(TypedDict):
        ca_certs: pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigCaCertArgsDict']]]
        """
        Specifies a list of allowed custom CA certificates for HTTPS
        verification.
        Structure is documented below.
        """
elif False:
    ToolOpenApiToolTlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolOpenApiToolTlsConfigArgs:
    def __init__(__self__, *,
                 ca_certs: pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigCaCertArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigCaCertArgs']]] ca_certs: Specifies a list of allowed custom CA certificates for HTTPS
               verification.
               Structure is documented below.
        """
        pulumi.set(__self__, "ca_certs", ca_certs)

    @_builtins.property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigCaCertArgs']]]:
        """
        Specifies a list of allowed custom CA certificates for HTTPS
        verification.
        Structure is documented below.
        """
        return pulumi.get(self, "ca_certs")

    @ca_certs.setter
    def ca_certs(self, value: pulumi.Input[Sequence[pulumi.Input['ToolOpenApiToolTlsConfigCaCertArgs']]]):
        pulumi.set(self, "ca_certs", value)


if not MYPY:
    class ToolOpenApiToolTlsConfigCaCertArgsDict(TypedDict):
        cert: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, CES will use Google's default trust
        store to verify certificates. N.B. Make sure the HTTPS server
        certificates are signed with "subject alt name". For instance a
        certificate can be self-signed using the following command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        A base64-encoded string.
        """
        display_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the allowed custom CA certificates. This
        can be used to disambiguate the custom CA certificates.
        """
elif False:
    ToolOpenApiToolTlsConfigCaCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolOpenApiToolTlsConfigCaCertArgs:
    def __init__(__self__, *,
                 cert: Optional[pulumi.Input[_builtins.str]] = None,
                 display_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] cert: (Output)
               The allowed custom CA certificates (in DER format) for
               HTTPS verification. This overrides the default SSL trust store. If this
               is empty or unspecified, CES will use Google's default trust
               store to verify certificates. N.B. Make sure the HTTPS server
               certificates are signed with "subject alt name". For instance a
               certificate can be self-signed using the following command,
               openssl x509 -req -days 200 -in example.com.csr \\
               -signkey example.com.key \\
               -out example.com.crt \\
               -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
               A base64-encoded string.
        :param pulumi.Input[_builtins.str] display_name: (Output)
               The name of the allowed custom CA certificates. This
               can be used to disambiguate the custom CA certificates.
        """
        if cert is not None:
            pulumi.set(__self__, "cert", cert)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, CES will use Google's default trust
        store to verify certificates. N.B. Make sure the HTTPS server
        certificates are signed with "subject alt name". For instance a
        certificate can be self-signed using the following command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        A base64-encoded string.
        """
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "cert", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the allowed custom CA certificates. This
        can be used to disambiguate the custom CA certificates.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class ToolPythonFunctionArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The description of the Python function, parsed from the python code's
        docstring.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the Python function to execute. Must match a Python function
        name defined in the python code. Case sensitive. If the name is not
        provided, the first function defined in the python code will be used.
        """
        python_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        The Python code to execute for the tool.
        """
elif False:
    ToolPythonFunctionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolPythonFunctionArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 python_code: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: (Output)
               The description of the Python function, parsed from the python code's
               docstring.
        :param pulumi.Input[_builtins.str] name: The name of the Python function to execute. Must match a Python function
               name defined in the python code. Case sensitive. If the name is not
               provided, the first function defined in the python code will be used.
        :param pulumi.Input[_builtins.str] python_code: The Python code to execute for the tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if python_code is not None:
            pulumi.set(__self__, "python_code", python_code)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The description of the Python function, parsed from the python code's
        docstring.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the Python function to execute. Must match a Python function
        name defined in the python code. Case sensitive. If the name is not
        provided, the first function defined in the python code will be used.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="pythonCode")
    def python_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The Python code to execute for the tool.
        """
        return pulumi.get(self, "python_code")

    @python_code.setter
    def python_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "python_code", value)


if not MYPY:
    class ToolSystemToolArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The description of the system tool.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The name of the system tool.
        """
elif False:
    ToolSystemToolArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolSystemToolArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[_builtins.str]] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] description: (Output)
               The description of the system tool.
        :param pulumi.Input[_builtins.str] name: (Output)
               The name of the system tool.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The description of the system tool.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The name of the system tool.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class ToolsetOpenApiToolsetArgsDict(TypedDict):
        open_api_schema: pulumi.Input[_builtins.str]
        """
        The OpenAPI schema of the toolset.
        """
        api_authentication: NotRequired[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationArgsDict']]
        """
        Authentication information required for API calls.
        Structure is documented below.
        """
        ignore_unknown_fields: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the agent will ignore unknown fields in the API response for all
        operations defined in the OpenAPI schema.
        """
        service_directory_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetServiceDirectoryConfigArgsDict']]
        """
        Configuration for tools using Service Directory.
        Structure is documented below.
        """
        tls_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetTlsConfigArgsDict']]
        """
        The TLS configuration.
        Structure is documented below.
        """
        url: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The server URL of the Open API schema.
        This field is only set in toolsets in the environment dependencies
        during the export process if the schema contains a server url.
        During the import process, if this url is present in the environment dependencies
        and the schema has the $env_var placeholder,
        it will replace the placeholder in the schema.
        """
elif False:
    ToolsetOpenApiToolsetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetArgs:
    def __init__(__self__, *,
                 open_api_schema: pulumi.Input[_builtins.str],
                 api_authentication: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationArgs']] = None,
                 ignore_unknown_fields: Optional[pulumi.Input[_builtins.bool]] = None,
                 service_directory_config: Optional[pulumi.Input['ToolsetOpenApiToolsetServiceDirectoryConfigArgs']] = None,
                 tls_config: Optional[pulumi.Input['ToolsetOpenApiToolsetTlsConfigArgs']] = None,
                 url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] open_api_schema: The OpenAPI schema of the toolset.
        :param pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationArgs'] api_authentication: Authentication information required for API calls.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] ignore_unknown_fields: If true, the agent will ignore unknown fields in the API response for all
               operations defined in the OpenAPI schema.
        :param pulumi.Input['ToolsetOpenApiToolsetServiceDirectoryConfigArgs'] service_directory_config: Configuration for tools using Service Directory.
               Structure is documented below.
        :param pulumi.Input['ToolsetOpenApiToolsetTlsConfigArgs'] tls_config: The TLS configuration.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] url: (Output)
               The server URL of the Open API schema.
               This field is only set in toolsets in the environment dependencies
               during the export process if the schema contains a server url.
               During the import process, if this url is present in the environment dependencies
               and the schema has the $env_var placeholder,
               it will replace the placeholder in the schema.
        """
        pulumi.set(__self__, "open_api_schema", open_api_schema)
        if api_authentication is not None:
            pulumi.set(__self__, "api_authentication", api_authentication)
        if ignore_unknown_fields is not None:
            pulumi.set(__self__, "ignore_unknown_fields", ignore_unknown_fields)
        if service_directory_config is not None:
            pulumi.set(__self__, "service_directory_config", service_directory_config)
        if tls_config is not None:
            pulumi.set(__self__, "tls_config", tls_config)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter(name="openApiSchema")
    def open_api_schema(self) -> pulumi.Input[_builtins.str]:
        """
        The OpenAPI schema of the toolset.
        """
        return pulumi.get(self, "open_api_schema")

    @open_api_schema.setter
    def open_api_schema(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "open_api_schema", value)

    @_builtins.property
    @pulumi.getter(name="apiAuthentication")
    def api_authentication(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationArgs']]:
        """
        Authentication information required for API calls.
        Structure is documented below.
        """
        return pulumi.get(self, "api_authentication")

    @api_authentication.setter
    def api_authentication(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationArgs']]):
        pulumi.set(self, "api_authentication", value)

    @_builtins.property
    @pulumi.getter(name="ignoreUnknownFields")
    def ignore_unknown_fields(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the agent will ignore unknown fields in the API response for all
        operations defined in the OpenAPI schema.
        """
        return pulumi.get(self, "ignore_unknown_fields")

    @ignore_unknown_fields.setter
    def ignore_unknown_fields(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_unknown_fields", value)

    @_builtins.property
    @pulumi.getter(name="serviceDirectoryConfig")
    def service_directory_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetServiceDirectoryConfigArgs']]:
        """
        Configuration for tools using Service Directory.
        Structure is documented below.
        """
        return pulumi.get(self, "service_directory_config")

    @service_directory_config.setter
    def service_directory_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetServiceDirectoryConfigArgs']]):
        pulumi.set(self, "service_directory_config", value)

    @_builtins.property
    @pulumi.getter(name="tlsConfig")
    def tls_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetTlsConfigArgs']]:
        """
        The TLS configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "tls_config")

    @tls_config.setter
    def tls_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetTlsConfigArgs']]):
        pulumi.set(self, "tls_config", value)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The server URL of the Open API schema.
        This field is only set in toolsets in the environment dependencies
        during the export process if the schema contains a server url.
        During the import process, if this url is present in the environment dependencies
        and the schema has the $env_var placeholder,
        it will replace the placeholder in the schema.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class ToolsetOpenApiToolsetApiAuthenticationArgsDict(TypedDict):
        api_key_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgsDict']]
        """
        Configurations for authentication with API key.
        Structure is documented below.
        """
        bearer_token_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgsDict']]
        """
        Configurations for authentication with a bearer token.
        Structure is documented below.
        """
        oauth_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgsDict']]
        """
        Configurations for authentication with OAuth.
        Structure is documented below.
        """
        service_account_auth_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgsDict']]
        """
        Configurations for authentication using a custom service account.
        Structure is documented below.
        """
        service_agent_id_token_auth_config: NotRequired[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict']]
        """
        Configurations for authentication with [ID
        token](https://cloud.google.com/docs/authentication/token-types#id) generated
        from service agent.
        """
elif False:
    ToolsetOpenApiToolsetApiAuthenticationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetApiAuthenticationArgs:
    def __init__(__self__, *,
                 api_key_config: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs']] = None,
                 bearer_token_config: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs']] = None,
                 oauth_config: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs']] = None,
                 service_account_auth_config: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs']] = None,
                 service_agent_id_token_auth_config: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs']] = None):
        """
        :param pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs'] api_key_config: Configurations for authentication with API key.
               Structure is documented below.
        :param pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs'] bearer_token_config: Configurations for authentication with a bearer token.
               Structure is documented below.
        :param pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs'] oauth_config: Configurations for authentication with OAuth.
               Structure is documented below.
        :param pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs'] service_account_auth_config: Configurations for authentication using a custom service account.
               Structure is documented below.
        :param pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs'] service_agent_id_token_auth_config: Configurations for authentication with [ID
               token](https://cloud.google.com/docs/authentication/token-types#id) generated
               from service agent.
        """
        if api_key_config is not None:
            pulumi.set(__self__, "api_key_config", api_key_config)
        if bearer_token_config is not None:
            pulumi.set(__self__, "bearer_token_config", bearer_token_config)
        if oauth_config is not None:
            pulumi.set(__self__, "oauth_config", oauth_config)
        if service_account_auth_config is not None:
            pulumi.set(__self__, "service_account_auth_config", service_account_auth_config)
        if service_agent_id_token_auth_config is not None:
            pulumi.set(__self__, "service_agent_id_token_auth_config", service_agent_id_token_auth_config)

    @_builtins.property
    @pulumi.getter(name="apiKeyConfig")
    def api_key_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs']]:
        """
        Configurations for authentication with API key.
        Structure is documented below.
        """
        return pulumi.get(self, "api_key_config")

    @api_key_config.setter
    def api_key_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs']]):
        pulumi.set(self, "api_key_config", value)

    @_builtins.property
    @pulumi.getter(name="bearerTokenConfig")
    def bearer_token_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs']]:
        """
        Configurations for authentication with a bearer token.
        Structure is documented below.
        """
        return pulumi.get(self, "bearer_token_config")

    @bearer_token_config.setter
    def bearer_token_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs']]):
        pulumi.set(self, "bearer_token_config", value)

    @_builtins.property
    @pulumi.getter(name="oauthConfig")
    def oauth_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs']]:
        """
        Configurations for authentication with OAuth.
        Structure is documented below.
        """
        return pulumi.get(self, "oauth_config")

    @oauth_config.setter
    def oauth_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs']]):
        pulumi.set(self, "oauth_config", value)

    @_builtins.property
    @pulumi.getter(name="serviceAccountAuthConfig")
    def service_account_auth_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs']]:
        """
        Configurations for authentication using a custom service account.
        Structure is documented below.
        """
        return pulumi.get(self, "service_account_auth_config")

    @service_account_auth_config.setter
    def service_account_auth_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs']]):
        pulumi.set(self, "service_account_auth_config", value)

    @_builtins.property
    @pulumi.getter(name="serviceAgentIdTokenAuthConfig")
    def service_agent_id_token_auth_config(self) -> Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]:
        """
        Configurations for authentication with [ID
        token](https://cloud.google.com/docs/authentication/token-types#id) generated
        from service agent.
        """
        return pulumi.get(self, "service_agent_id_token_auth_config")

    @service_agent_id_token_auth_config.setter
    def service_agent_id_token_auth_config(self, value: Optional[pulumi.Input['ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs']]):
        pulumi.set(self, "service_agent_id_token_auth_config", value)


if not MYPY:
    class ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgsDict(TypedDict):
        api_key_secret_version: pulumi.Input[_builtins.str]
        """
        The name of the SecretManager secret version resource storing the API key.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        key_name: pulumi.Input[_builtins.str]
        """
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        request_location: pulumi.Input[_builtins.str]
        """
        Key location in the request.
        Possible values:
        HEADER
        QUERY_STRING
        """
elif False:
    ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetApiAuthenticationApiKeyConfigArgs:
    def __init__(__self__, *,
                 api_key_secret_version: pulumi.Input[_builtins.str],
                 key_name: pulumi.Input[_builtins.str],
                 request_location: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] api_key_secret_version: The name of the SecretManager secret version resource storing the API key.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param pulumi.Input[_builtins.str] key_name: The parameter name or the header name of the API key.
               E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        :param pulumi.Input[_builtins.str] request_location: Key location in the request.
               Possible values:
               HEADER
               QUERY_STRING
        """
        pulumi.set(__self__, "api_key_secret_version", api_key_secret_version)
        pulumi.set(__self__, "key_name", key_name)
        pulumi.set(__self__, "request_location", request_location)

    @_builtins.property
    @pulumi.getter(name="apiKeySecretVersion")
    def api_key_secret_version(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SecretManager secret version resource storing the API key.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "api_key_secret_version")

    @api_key_secret_version.setter
    def api_key_secret_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "api_key_secret_version", value)

    @_builtins.property
    @pulumi.getter(name="keyName")
    def key_name(self) -> pulumi.Input[_builtins.str]:
        """
        The parameter name or the header name of the API key.
        E.g., If the API request is "https://example.com/act?X-Api-Key=", "X-Api-Key" would be the parameter name.
        """
        return pulumi.get(self, "key_name")

    @key_name.setter
    def key_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key_name", value)

    @_builtins.property
    @pulumi.getter(name="requestLocation")
    def request_location(self) -> pulumi.Input[_builtins.str]:
        """
        Key location in the request.
        Possible values:
        HEADER
        QUERY_STRING
        """
        return pulumi.get(self, "request_location")

    @request_location.setter
    def request_location(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "request_location", value)


if not MYPY:
    class ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgsDict(TypedDict):
        token: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Optional)
        """
elif False:
    ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetApiAuthenticationBearerTokenConfigArgs:
    def __init__(__self__, *,
                 token: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] token: (Optional)
        """
        if token is not None:
            pulumi.set(__self__, "token", token)

    @_builtins.property
    @pulumi.getter
    def token(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Optional)
        """
        return pulumi.get(self, "token")

    @token.setter
    def token(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "token", value)


if not MYPY:
    class ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgsDict(TypedDict):
        client_id: pulumi.Input[_builtins.str]
        """
        The client ID from the OAuth provider.
        """
        client_secret_version: pulumi.Input[_builtins.str]
        """
        The name of the SecretManager secret version resource storing the
        client secret.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        oauth_grant_type: pulumi.Input[_builtins.str]
        """
        OAuth grant types.
        Possible values:
        CLIENT_CREDENTIAL
        """
        token_endpoint: pulumi.Input[_builtins.str]
        """
        The token endpoint in the OAuth provider to exchange for an access token.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The OAuth scopes to grant.
        """
elif False:
    ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetApiAuthenticationOauthConfigArgs:
    def __init__(__self__, *,
                 client_id: pulumi.Input[_builtins.str],
                 client_secret_version: pulumi.Input[_builtins.str],
                 oauth_grant_type: pulumi.Input[_builtins.str],
                 token_endpoint: pulumi.Input[_builtins.str],
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] client_id: The client ID from the OAuth provider.
        :param pulumi.Input[_builtins.str] client_secret_version: The name of the SecretManager secret version resource storing the
               client secret.
               Format: `projects/{project}/secrets/{secret}/versions/{version}`
               Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
               service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        :param pulumi.Input[_builtins.str] oauth_grant_type: OAuth grant types.
               Possible values:
               CLIENT_CREDENTIAL
        :param pulumi.Input[_builtins.str] token_endpoint: The token endpoint in the OAuth provider to exchange for an access token.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: The OAuth scopes to grant.
        """
        pulumi.set(__self__, "client_id", client_id)
        pulumi.set(__self__, "client_secret_version", client_secret_version)
        pulumi.set(__self__, "oauth_grant_type", oauth_grant_type)
        pulumi.set(__self__, "token_endpoint", token_endpoint)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> pulumi.Input[_builtins.str]:
        """
        The client ID from the OAuth provider.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_id", value)

    @_builtins.property
    @pulumi.getter(name="clientSecretVersion")
    def client_secret_version(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the SecretManager secret version resource storing the
        client secret.
        Format: `projects/{project}/secrets/{secret}/versions/{version}`
        Note: You should grant `roles/secretmanager.secretAccessor` role to the CES
        service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "client_secret_version")

    @client_secret_version.setter
    def client_secret_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "client_secret_version", value)

    @_builtins.property
    @pulumi.getter(name="oauthGrantType")
    def oauth_grant_type(self) -> pulumi.Input[_builtins.str]:
        """
        OAuth grant types.
        Possible values:
        CLIENT_CREDENTIAL
        """
        return pulumi.get(self, "oauth_grant_type")

    @oauth_grant_type.setter
    def oauth_grant_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "oauth_grant_type", value)

    @_builtins.property
    @pulumi.getter(name="tokenEndpoint")
    def token_endpoint(self) -> pulumi.Input[_builtins.str]:
        """
        The token endpoint in the OAuth provider to exchange for an access token.
        """
        return pulumi.get(self, "token_endpoint")

    @token_endpoint.setter
    def token_endpoint(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "token_endpoint", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The OAuth scopes to grant.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)


if not MYPY:
    class ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgsDict(TypedDict):
        service_account: pulumi.Input[_builtins.str]
        """
        The email address of the service account used for authenticatation. CES
        uses this service account to exchange an access token and the access token
        is then sent in the `Authorization` header of the request.
        The service account must have the
        `roles/iam.serviceAccountTokenCreator` role granted to the
        CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
elif False:
    ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetApiAuthenticationServiceAccountAuthConfigArgs:
    def __init__(__self__, *,
                 service_account: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] service_account: The email address of the service account used for authenticatation. CES
               uses this service account to exchange an access token and the access token
               is then sent in the `Authorization` header of the request.
               The service account must have the
               `roles/iam.serviceAccountTokenCreator` role granted to the
               CES service agent
               `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        pulumi.set(__self__, "service_account", service_account)

    @_builtins.property
    @pulumi.getter(name="serviceAccount")
    def service_account(self) -> pulumi.Input[_builtins.str]:
        """
        The email address of the service account used for authenticatation. CES
        uses this service account to exchange an access token and the access token
        is then sent in the `Authorization` header of the request.
        The service account must have the
        `roles/iam.serviceAccountTokenCreator` role granted to the
        CES service agent
        `service-@gcp-sa-ces.iam.gserviceaccount.com`.
        """
        return pulumi.get(self, "service_account")

    @service_account.setter
    def service_account(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service_account", value)


if not MYPY:
    class ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict(TypedDict):
        pass
elif False:
    ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetApiAuthenticationServiceAgentIdTokenAuthConfigArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ToolsetOpenApiToolsetServiceDirectoryConfigArgsDict(TypedDict):
        service: pulumi.Input[_builtins.str]
        """
        The name of [Service
        Directory](https://cloud.google.com/service-directory) service.
        Format:
        `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
        Location of the service directory must be the same as the location of the
        app.
        """
elif False:
    ToolsetOpenApiToolsetServiceDirectoryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetServiceDirectoryConfigArgs:
    def __init__(__self__, *,
                 service: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] service: The name of [Service
               Directory](https://cloud.google.com/service-directory) service.
               Format:
               `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
               Location of the service directory must be the same as the location of the
               app.
        """
        pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter
    def service(self) -> pulumi.Input[_builtins.str]:
        """
        The name of [Service
        Directory](https://cloud.google.com/service-directory) service.
        Format:
        `projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}`.
        Location of the service directory must be the same as the location of the
        app.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "service", value)


if not MYPY:
    class ToolsetOpenApiToolsetTlsConfigArgsDict(TypedDict):
        ca_certs: pulumi.Input[Sequence[pulumi.Input['ToolsetOpenApiToolsetTlsConfigCaCertArgsDict']]]
        """
        Specifies a list of allowed custom CA certificates for HTTPS
        verification.
        Structure is documented below.
        """
elif False:
    ToolsetOpenApiToolsetTlsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetTlsConfigArgs:
    def __init__(__self__, *,
                 ca_certs: pulumi.Input[Sequence[pulumi.Input['ToolsetOpenApiToolsetTlsConfigCaCertArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ToolsetOpenApiToolsetTlsConfigCaCertArgs']]] ca_certs: Specifies a list of allowed custom CA certificates for HTTPS
               verification.
               Structure is documented below.
        """
        pulumi.set(__self__, "ca_certs", ca_certs)

    @_builtins.property
    @pulumi.getter(name="caCerts")
    def ca_certs(self) -> pulumi.Input[Sequence[pulumi.Input['ToolsetOpenApiToolsetTlsConfigCaCertArgs']]]:
        """
        Specifies a list of allowed custom CA certificates for HTTPS
        verification.
        Structure is documented below.
        """
        return pulumi.get(self, "ca_certs")

    @ca_certs.setter
    def ca_certs(self, value: pulumi.Input[Sequence[pulumi.Input['ToolsetOpenApiToolsetTlsConfigCaCertArgs']]]):
        pulumi.set(self, "ca_certs", value)


if not MYPY:
    class ToolsetOpenApiToolsetTlsConfigCaCertArgsDict(TypedDict):
        cert: pulumi.Input[_builtins.str]
        """
        The allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, CES will use Google's default trust
        store to verify certificates. N.B. Make sure the HTTPS server
        certificates are signed with "subject alt name". For instance a
        certificate can be self-signed using the following command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        """
        display_name: pulumi.Input[_builtins.str]
        """
        The name of the allowed custom CA certificates. This
        can be used to disambiguate the custom CA certificates.
        """
elif False:
    ToolsetOpenApiToolsetTlsConfigCaCertArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ToolsetOpenApiToolsetTlsConfigCaCertArgs:
    def __init__(__self__, *,
                 cert: pulumi.Input[_builtins.str],
                 display_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] cert: The allowed custom CA certificates (in DER format) for
               HTTPS verification. This overrides the default SSL trust store. If this
               is empty or unspecified, CES will use Google's default trust
               store to verify certificates. N.B. Make sure the HTTPS server
               certificates are signed with "subject alt name". For instance a
               certificate can be self-signed using the following command,
               openssl x509 -req -days 200 -in example.com.csr \\
               -signkey example.com.key \\
               -out example.com.crt \\
               -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        :param pulumi.Input[_builtins.str] display_name: The name of the allowed custom CA certificates. This
               can be used to disambiguate the custom CA certificates.
        """
        pulumi.set(__self__, "cert", cert)
        pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def cert(self) -> pulumi.Input[_builtins.str]:
        """
        The allowed custom CA certificates (in DER format) for
        HTTPS verification. This overrides the default SSL trust store. If this
        is empty or unspecified, CES will use Google's default trust
        store to verify certificates. N.B. Make sure the HTTPS server
        certificates are signed with "subject alt name". For instance a
        certificate can be self-signed using the following command,
        openssl x509 -req -days 200 -in example.com.csr \\
        -signkey example.com.key \\
        -out example.com.crt \\
        -extfile <(printf "\\nsubjectAltName='DNS:www.example.com'")
        """
        return pulumi.get(self, "cert")

    @cert.setter
    def cert(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "cert", value)

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the allowed custom CA certificates. This
        can be used to disambiguate the custom CA certificates.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "display_name", value)


