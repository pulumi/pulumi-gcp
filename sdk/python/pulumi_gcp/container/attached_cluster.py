# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs
from ._inputs import *

__all__ = ['AttachedClusterArgs', 'AttachedCluster']

@pulumi.input_type
class AttachedClusterArgs:
    def __init__(__self__, *,
                 distribution: pulumi.Input[str],
                 fleet: pulumi.Input['AttachedClusterFleetArgs'],
                 location: pulumi.Input[str],
                 oidc_config: pulumi.Input['AttachedClusterOidcConfigArgs'],
                 platform_version: pulumi.Input[str],
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 authorization: Optional[pulumi.Input['AttachedClusterAuthorizationArgs']] = None,
                 binary_authorization: Optional[pulumi.Input['AttachedClusterBinaryAuthorizationArgs']] = None,
                 deletion_policy: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 logging_config: Optional[pulumi.Input['AttachedClusterLoggingConfigArgs']] = None,
                 monitoring_config: Optional[pulumi.Input['AttachedClusterMonitoringConfigArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 project: Optional[pulumi.Input[str]] = None):
        """
        The set of arguments for constructing a AttachedCluster resource.
        :param pulumi.Input[str] distribution: The Kubernetes distribution of the underlying attached cluster. Supported values:
               "eks", "aks".
        :param pulumi.Input['AttachedClusterFleetArgs'] fleet: Fleet configuration.
               Structure is documented below.
        :param pulumi.Input[str] location: The location for the resource
        :param pulumi.Input['AttachedClusterOidcConfigArgs'] oidc_config: OIDC discovery information of the target cluster.
               Kubernetes Service Account (KSA) tokens are JWT tokens signed by the cluster
               API server. This fields indicates how GCP services
               validate KSA tokens in order to allow system workloads (such as GKE Connect
               and telemetry agents) to authenticate back to GCP.
               Both clusters with public and private issuer URLs are supported.
               Clusters with public issuers only need to specify the `issuer_url` field
               while clusters with private issuers need to provide both
               `issuer_url` and `jwks`.
               Structure is documented below.
        :param pulumi.Input[str] platform_version: The platform version for the cluster (e.g. `1.23.0-gke.1`).
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Optional. Annotations on the cluster. This field has the same
               restrictions as Kubernetes annotations. The total size of all keys and
               values combined is limited to 256k. Key can have 2 segments: prefix (optional)
               and name (required), separated by a slash (/). Prefix must be a DNS subdomain.
               Name must be 63 characters or less, begin and end with alphanumerics,
               with dashes (-), underscores (_), dots (.), and alphanumerics between.
        :param pulumi.Input['AttachedClusterAuthorizationArgs'] authorization: Configuration related to the cluster RBAC settings.
               Structure is documented below.
        :param pulumi.Input['AttachedClusterBinaryAuthorizationArgs'] binary_authorization: Binary Authorization configuration.
               Structure is documented below.
        :param pulumi.Input[str] deletion_policy: Policy to determine what flags to send on delete.
        :param pulumi.Input[str] description: A human readable description of this attached cluster. Cannot be longer
               than 255 UTF-8 encoded bytes.
        :param pulumi.Input['AttachedClusterLoggingConfigArgs'] logging_config: Logging configuration.
               Structure is documented below.
        :param pulumi.Input['AttachedClusterMonitoringConfigArgs'] monitoring_config: Monitoring configuration.
               Structure is documented below.
        :param pulumi.Input[str] name: The name of this resource.
        :param pulumi.Input[str] project: The ID of the project in which the resource belongs.
               If it is not provided, the provider project is used.
        """
        AttachedClusterArgs._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            distribution=distribution,
            fleet=fleet,
            location=location,
            oidc_config=oidc_config,
            platform_version=platform_version,
            annotations=annotations,
            authorization=authorization,
            binary_authorization=binary_authorization,
            deletion_policy=deletion_policy,
            description=description,
            logging_config=logging_config,
            monitoring_config=monitoring_config,
            name=name,
            project=project,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             distribution: pulumi.Input[str],
             fleet: pulumi.Input['AttachedClusterFleetArgs'],
             location: pulumi.Input[str],
             oidc_config: pulumi.Input['AttachedClusterOidcConfigArgs'],
             platform_version: pulumi.Input[str],
             annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             authorization: Optional[pulumi.Input['AttachedClusterAuthorizationArgs']] = None,
             binary_authorization: Optional[pulumi.Input['AttachedClusterBinaryAuthorizationArgs']] = None,
             deletion_policy: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             logging_config: Optional[pulumi.Input['AttachedClusterLoggingConfigArgs']] = None,
             monitoring_config: Optional[pulumi.Input['AttachedClusterMonitoringConfigArgs']] = None,
             name: Optional[pulumi.Input[str]] = None,
             project: Optional[pulumi.Input[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("distribution", distribution)
        _setter("fleet", fleet)
        _setter("location", location)
        _setter("oidc_config", oidc_config)
        _setter("platform_version", platform_version)
        if annotations is not None:
            _setter("annotations", annotations)
        if authorization is not None:
            _setter("authorization", authorization)
        if binary_authorization is not None:
            _setter("binary_authorization", binary_authorization)
        if deletion_policy is not None:
            _setter("deletion_policy", deletion_policy)
        if description is not None:
            _setter("description", description)
        if logging_config is not None:
            _setter("logging_config", logging_config)
        if monitoring_config is not None:
            _setter("monitoring_config", monitoring_config)
        if name is not None:
            _setter("name", name)
        if project is not None:
            _setter("project", project)

    @property
    @pulumi.getter
    def distribution(self) -> pulumi.Input[str]:
        """
        The Kubernetes distribution of the underlying attached cluster. Supported values:
        "eks", "aks".
        """
        return pulumi.get(self, "distribution")

    @distribution.setter
    def distribution(self, value: pulumi.Input[str]):
        pulumi.set(self, "distribution", value)

    @property
    @pulumi.getter
    def fleet(self) -> pulumi.Input['AttachedClusterFleetArgs']:
        """
        Fleet configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "fleet")

    @fleet.setter
    def fleet(self, value: pulumi.Input['AttachedClusterFleetArgs']):
        pulumi.set(self, "fleet", value)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[str]:
        """
        The location for the resource
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[str]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="oidcConfig")
    def oidc_config(self) -> pulumi.Input['AttachedClusterOidcConfigArgs']:
        """
        OIDC discovery information of the target cluster.
        Kubernetes Service Account (KSA) tokens are JWT tokens signed by the cluster
        API server. This fields indicates how GCP services
        validate KSA tokens in order to allow system workloads (such as GKE Connect
        and telemetry agents) to authenticate back to GCP.
        Both clusters with public and private issuer URLs are supported.
        Clusters with public issuers only need to specify the `issuer_url` field
        while clusters with private issuers need to provide both
        `issuer_url` and `jwks`.
        Structure is documented below.
        """
        return pulumi.get(self, "oidc_config")

    @oidc_config.setter
    def oidc_config(self, value: pulumi.Input['AttachedClusterOidcConfigArgs']):
        pulumi.set(self, "oidc_config", value)

    @property
    @pulumi.getter(name="platformVersion")
    def platform_version(self) -> pulumi.Input[str]:
        """
        The platform version for the cluster (e.g. `1.23.0-gke.1`).
        """
        return pulumi.get(self, "platform_version")

    @platform_version.setter
    def platform_version(self, value: pulumi.Input[str]):
        pulumi.set(self, "platform_version", value)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Optional. Annotations on the cluster. This field has the same
        restrictions as Kubernetes annotations. The total size of all keys and
        values combined is limited to 256k. Key can have 2 segments: prefix (optional)
        and name (required), separated by a slash (/). Prefix must be a DNS subdomain.
        Name must be 63 characters or less, begin and end with alphanumerics,
        with dashes (-), underscores (_), dots (.), and alphanumerics between.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input['AttachedClusterAuthorizationArgs']]:
        """
        Configuration related to the cluster RBAC settings.
        Structure is documented below.
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input['AttachedClusterAuthorizationArgs']]):
        pulumi.set(self, "authorization", value)

    @property
    @pulumi.getter(name="binaryAuthorization")
    def binary_authorization(self) -> Optional[pulumi.Input['AttachedClusterBinaryAuthorizationArgs']]:
        """
        Binary Authorization configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "binary_authorization")

    @binary_authorization.setter
    def binary_authorization(self, value: Optional[pulumi.Input['AttachedClusterBinaryAuthorizationArgs']]):
        pulumi.set(self, "binary_authorization", value)

    @property
    @pulumi.getter(name="deletionPolicy")
    def deletion_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Policy to determine what flags to send on delete.
        """
        return pulumi.get(self, "deletion_policy")

    @deletion_policy.setter
    def deletion_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deletion_policy", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A human readable description of this attached cluster. Cannot be longer
        than 255 UTF-8 encoded bytes.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter(name="loggingConfig")
    def logging_config(self) -> Optional[pulumi.Input['AttachedClusterLoggingConfigArgs']]:
        """
        Logging configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "logging_config")

    @logging_config.setter
    def logging_config(self, value: Optional[pulumi.Input['AttachedClusterLoggingConfigArgs']]):
        pulumi.set(self, "logging_config", value)

    @property
    @pulumi.getter(name="monitoringConfig")
    def monitoring_config(self) -> Optional[pulumi.Input['AttachedClusterMonitoringConfigArgs']]:
        """
        Monitoring configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "monitoring_config")

    @monitoring_config.setter
    def monitoring_config(self, value: Optional[pulumi.Input['AttachedClusterMonitoringConfigArgs']]):
        pulumi.set(self, "monitoring_config", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of this resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the project in which the resource belongs.
        If it is not provided, the provider project is used.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project", value)


@pulumi.input_type
class _AttachedClusterState:
    def __init__(__self__, *,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 authorization: Optional[pulumi.Input['AttachedClusterAuthorizationArgs']] = None,
                 binary_authorization: Optional[pulumi.Input['AttachedClusterBinaryAuthorizationArgs']] = None,
                 cluster_region: Optional[pulumi.Input[str]] = None,
                 create_time: Optional[pulumi.Input[str]] = None,
                 deletion_policy: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 distribution: Optional[pulumi.Input[str]] = None,
                 errors: Optional[pulumi.Input[Sequence[pulumi.Input['AttachedClusterErrorArgs']]]] = None,
                 fleet: Optional[pulumi.Input['AttachedClusterFleetArgs']] = None,
                 kubernetes_version: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 logging_config: Optional[pulumi.Input['AttachedClusterLoggingConfigArgs']] = None,
                 monitoring_config: Optional[pulumi.Input['AttachedClusterMonitoringConfigArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 oidc_config: Optional[pulumi.Input['AttachedClusterOidcConfigArgs']] = None,
                 platform_version: Optional[pulumi.Input[str]] = None,
                 project: Optional[pulumi.Input[str]] = None,
                 reconciling: Optional[pulumi.Input[bool]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 uid: Optional[pulumi.Input[str]] = None,
                 update_time: Optional[pulumi.Input[str]] = None,
                 workload_identity_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AttachedClusterWorkloadIdentityConfigArgs']]]] = None):
        """
        Input properties used for looking up and filtering AttachedCluster resources.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Optional. Annotations on the cluster. This field has the same
               restrictions as Kubernetes annotations. The total size of all keys and
               values combined is limited to 256k. Key can have 2 segments: prefix (optional)
               and name (required), separated by a slash (/). Prefix must be a DNS subdomain.
               Name must be 63 characters or less, begin and end with alphanumerics,
               with dashes (-), underscores (_), dots (.), and alphanumerics between.
        :param pulumi.Input['AttachedClusterAuthorizationArgs'] authorization: Configuration related to the cluster RBAC settings.
               Structure is documented below.
        :param pulumi.Input['AttachedClusterBinaryAuthorizationArgs'] binary_authorization: Binary Authorization configuration.
               Structure is documented below.
        :param pulumi.Input[str] cluster_region: Output only. The region where this cluster runs.
               For EKS clusters, this is an AWS region. For AKS clusters,
               this is an Azure region.
        :param pulumi.Input[str] create_time: Output only. The time at which this cluster was created.
        :param pulumi.Input[str] deletion_policy: Policy to determine what flags to send on delete.
        :param pulumi.Input[str] description: A human readable description of this attached cluster. Cannot be longer
               than 255 UTF-8 encoded bytes.
        :param pulumi.Input[str] distribution: The Kubernetes distribution of the underlying attached cluster. Supported values:
               "eks", "aks".
        :param pulumi.Input[Sequence[pulumi.Input['AttachedClusterErrorArgs']]] errors: A set of errors found in the cluster.
               Structure is documented below.
        :param pulumi.Input['AttachedClusterFleetArgs'] fleet: Fleet configuration.
               Structure is documented below.
        :param pulumi.Input[str] kubernetes_version: The Kubernetes version of the cluster.
        :param pulumi.Input[str] location: The location for the resource
        :param pulumi.Input['AttachedClusterLoggingConfigArgs'] logging_config: Logging configuration.
               Structure is documented below.
        :param pulumi.Input['AttachedClusterMonitoringConfigArgs'] monitoring_config: Monitoring configuration.
               Structure is documented below.
        :param pulumi.Input[str] name: The name of this resource.
        :param pulumi.Input['AttachedClusterOidcConfigArgs'] oidc_config: OIDC discovery information of the target cluster.
               Kubernetes Service Account (KSA) tokens are JWT tokens signed by the cluster
               API server. This fields indicates how GCP services
               validate KSA tokens in order to allow system workloads (such as GKE Connect
               and telemetry agents) to authenticate back to GCP.
               Both clusters with public and private issuer URLs are supported.
               Clusters with public issuers only need to specify the `issuer_url` field
               while clusters with private issuers need to provide both
               `issuer_url` and `jwks`.
               Structure is documented below.
        :param pulumi.Input[str] platform_version: The platform version for the cluster (e.g. `1.23.0-gke.1`).
        :param pulumi.Input[str] project: The ID of the project in which the resource belongs.
               If it is not provided, the provider project is used.
        :param pulumi.Input[bool] reconciling: If set, there are currently changes in flight to the cluster.
        :param pulumi.Input[str] state: The current state of the cluster. Possible values:
               STATE_UNSPECIFIED, PROVISIONING, RUNNING, RECONCILING, STOPPING, ERROR,
               DEGRADED
        :param pulumi.Input[str] uid: A globally unique identifier for the cluster.
        :param pulumi.Input[str] update_time: The time at which this cluster was last updated.
        :param pulumi.Input[Sequence[pulumi.Input['AttachedClusterWorkloadIdentityConfigArgs']]] workload_identity_configs: Workload Identity settings.
               Structure is documented below.
        """
        _AttachedClusterState._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            annotations=annotations,
            authorization=authorization,
            binary_authorization=binary_authorization,
            cluster_region=cluster_region,
            create_time=create_time,
            deletion_policy=deletion_policy,
            description=description,
            distribution=distribution,
            errors=errors,
            fleet=fleet,
            kubernetes_version=kubernetes_version,
            location=location,
            logging_config=logging_config,
            monitoring_config=monitoring_config,
            name=name,
            oidc_config=oidc_config,
            platform_version=platform_version,
            project=project,
            reconciling=reconciling,
            state=state,
            uid=uid,
            update_time=update_time,
            workload_identity_configs=workload_identity_configs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
             authorization: Optional[pulumi.Input['AttachedClusterAuthorizationArgs']] = None,
             binary_authorization: Optional[pulumi.Input['AttachedClusterBinaryAuthorizationArgs']] = None,
             cluster_region: Optional[pulumi.Input[str]] = None,
             create_time: Optional[pulumi.Input[str]] = None,
             deletion_policy: Optional[pulumi.Input[str]] = None,
             description: Optional[pulumi.Input[str]] = None,
             distribution: Optional[pulumi.Input[str]] = None,
             errors: Optional[pulumi.Input[Sequence[pulumi.Input['AttachedClusterErrorArgs']]]] = None,
             fleet: Optional[pulumi.Input['AttachedClusterFleetArgs']] = None,
             kubernetes_version: Optional[pulumi.Input[str]] = None,
             location: Optional[pulumi.Input[str]] = None,
             logging_config: Optional[pulumi.Input['AttachedClusterLoggingConfigArgs']] = None,
             monitoring_config: Optional[pulumi.Input['AttachedClusterMonitoringConfigArgs']] = None,
             name: Optional[pulumi.Input[str]] = None,
             oidc_config: Optional[pulumi.Input['AttachedClusterOidcConfigArgs']] = None,
             platform_version: Optional[pulumi.Input[str]] = None,
             project: Optional[pulumi.Input[str]] = None,
             reconciling: Optional[pulumi.Input[bool]] = None,
             state: Optional[pulumi.Input[str]] = None,
             uid: Optional[pulumi.Input[str]] = None,
             update_time: Optional[pulumi.Input[str]] = None,
             workload_identity_configs: Optional[pulumi.Input[Sequence[pulumi.Input['AttachedClusterWorkloadIdentityConfigArgs']]]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if annotations is not None:
            _setter("annotations", annotations)
        if authorization is not None:
            _setter("authorization", authorization)
        if binary_authorization is not None:
            _setter("binary_authorization", binary_authorization)
        if cluster_region is not None:
            _setter("cluster_region", cluster_region)
        if create_time is not None:
            _setter("create_time", create_time)
        if deletion_policy is not None:
            _setter("deletion_policy", deletion_policy)
        if description is not None:
            _setter("description", description)
        if distribution is not None:
            _setter("distribution", distribution)
        if errors is not None:
            _setter("errors", errors)
        if fleet is not None:
            _setter("fleet", fleet)
        if kubernetes_version is not None:
            _setter("kubernetes_version", kubernetes_version)
        if location is not None:
            _setter("location", location)
        if logging_config is not None:
            _setter("logging_config", logging_config)
        if monitoring_config is not None:
            _setter("monitoring_config", monitoring_config)
        if name is not None:
            _setter("name", name)
        if oidc_config is not None:
            _setter("oidc_config", oidc_config)
        if platform_version is not None:
            _setter("platform_version", platform_version)
        if project is not None:
            _setter("project", project)
        if reconciling is not None:
            _setter("reconciling", reconciling)
        if state is not None:
            _setter("state", state)
        if uid is not None:
            _setter("uid", uid)
        if update_time is not None:
            _setter("update_time", update_time)
        if workload_identity_configs is not None:
            _setter("workload_identity_configs", workload_identity_configs)

    @property
    @pulumi.getter
    def annotations(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Optional. Annotations on the cluster. This field has the same
        restrictions as Kubernetes annotations. The total size of all keys and
        values combined is limited to 256k. Key can have 2 segments: prefix (optional)
        and name (required), separated by a slash (/). Prefix must be a DNS subdomain.
        Name must be 63 characters or less, begin and end with alphanumerics,
        with dashes (-), underscores (_), dots (.), and alphanumerics between.
        """
        return pulumi.get(self, "annotations")

    @annotations.setter
    def annotations(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "annotations", value)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input['AttachedClusterAuthorizationArgs']]:
        """
        Configuration related to the cluster RBAC settings.
        Structure is documented below.
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input['AttachedClusterAuthorizationArgs']]):
        pulumi.set(self, "authorization", value)

    @property
    @pulumi.getter(name="binaryAuthorization")
    def binary_authorization(self) -> Optional[pulumi.Input['AttachedClusterBinaryAuthorizationArgs']]:
        """
        Binary Authorization configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "binary_authorization")

    @binary_authorization.setter
    def binary_authorization(self, value: Optional[pulumi.Input['AttachedClusterBinaryAuthorizationArgs']]):
        pulumi.set(self, "binary_authorization", value)

    @property
    @pulumi.getter(name="clusterRegion")
    def cluster_region(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. The region where this cluster runs.
        For EKS clusters, this is an AWS region. For AKS clusters,
        this is an Azure region.
        """
        return pulumi.get(self, "cluster_region")

    @cluster_region.setter
    def cluster_region(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster_region", value)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[str]]:
        """
        Output only. The time at which this cluster was created.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create_time", value)

    @property
    @pulumi.getter(name="deletionPolicy")
    def deletion_policy(self) -> Optional[pulumi.Input[str]]:
        """
        Policy to determine what flags to send on delete.
        """
        return pulumi.get(self, "deletion_policy")

    @deletion_policy.setter
    def deletion_policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deletion_policy", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A human readable description of this attached cluster. Cannot be longer
        than 255 UTF-8 encoded bytes.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def distribution(self) -> Optional[pulumi.Input[str]]:
        """
        The Kubernetes distribution of the underlying attached cluster. Supported values:
        "eks", "aks".
        """
        return pulumi.get(self, "distribution")

    @distribution.setter
    def distribution(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "distribution", value)

    @property
    @pulumi.getter
    def errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AttachedClusterErrorArgs']]]]:
        """
        A set of errors found in the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "errors")

    @errors.setter
    def errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AttachedClusterErrorArgs']]]]):
        pulumi.set(self, "errors", value)

    @property
    @pulumi.getter
    def fleet(self) -> Optional[pulumi.Input['AttachedClusterFleetArgs']]:
        """
        Fleet configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "fleet")

    @fleet.setter
    def fleet(self, value: Optional[pulumi.Input['AttachedClusterFleetArgs']]):
        pulumi.set(self, "fleet", value)

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> Optional[pulumi.Input[str]]:
        """
        The Kubernetes version of the cluster.
        """
        return pulumi.get(self, "kubernetes_version")

    @kubernetes_version.setter
    def kubernetes_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kubernetes_version", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        The location for the resource
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="loggingConfig")
    def logging_config(self) -> Optional[pulumi.Input['AttachedClusterLoggingConfigArgs']]:
        """
        Logging configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "logging_config")

    @logging_config.setter
    def logging_config(self, value: Optional[pulumi.Input['AttachedClusterLoggingConfigArgs']]):
        pulumi.set(self, "logging_config", value)

    @property
    @pulumi.getter(name="monitoringConfig")
    def monitoring_config(self) -> Optional[pulumi.Input['AttachedClusterMonitoringConfigArgs']]:
        """
        Monitoring configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "monitoring_config")

    @monitoring_config.setter
    def monitoring_config(self, value: Optional[pulumi.Input['AttachedClusterMonitoringConfigArgs']]):
        pulumi.set(self, "monitoring_config", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of this resource.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="oidcConfig")
    def oidc_config(self) -> Optional[pulumi.Input['AttachedClusterOidcConfigArgs']]:
        """
        OIDC discovery information of the target cluster.
        Kubernetes Service Account (KSA) tokens are JWT tokens signed by the cluster
        API server. This fields indicates how GCP services
        validate KSA tokens in order to allow system workloads (such as GKE Connect
        and telemetry agents) to authenticate back to GCP.
        Both clusters with public and private issuer URLs are supported.
        Clusters with public issuers only need to specify the `issuer_url` field
        while clusters with private issuers need to provide both
        `issuer_url` and `jwks`.
        Structure is documented below.
        """
        return pulumi.get(self, "oidc_config")

    @oidc_config.setter
    def oidc_config(self, value: Optional[pulumi.Input['AttachedClusterOidcConfigArgs']]):
        pulumi.set(self, "oidc_config", value)

    @property
    @pulumi.getter(name="platformVersion")
    def platform_version(self) -> Optional[pulumi.Input[str]]:
        """
        The platform version for the cluster (e.g. `1.23.0-gke.1`).
        """
        return pulumi.get(self, "platform_version")

    @platform_version.setter
    def platform_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "platform_version", value)

    @property
    @pulumi.getter
    def project(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the project in which the resource belongs.
        If it is not provided, the provider project is used.
        """
        return pulumi.get(self, "project")

    @project.setter
    def project(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project", value)

    @property
    @pulumi.getter
    def reconciling(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, there are currently changes in flight to the cluster.
        """
        return pulumi.get(self, "reconciling")

    @reconciling.setter
    def reconciling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reconciling", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        The current state of the cluster. Possible values:
        STATE_UNSPECIFIED, PROVISIONING, RUNNING, RECONCILING, STOPPING, ERROR,
        DEGRADED
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[str]]:
        """
        A globally unique identifier for the cluster.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "uid", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[str]]:
        """
        The time at which this cluster was last updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "update_time", value)

    @property
    @pulumi.getter(name="workloadIdentityConfigs")
    def workload_identity_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AttachedClusterWorkloadIdentityConfigArgs']]]]:
        """
        Workload Identity settings.
        Structure is documented below.
        """
        return pulumi.get(self, "workload_identity_configs")

    @workload_identity_configs.setter
    def workload_identity_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AttachedClusterWorkloadIdentityConfigArgs']]]]):
        pulumi.set(self, "workload_identity_configs", value)


class AttachedCluster(pulumi.CustomResource):
    @overload
    def __init__(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 authorization: Optional[pulumi.Input[pulumi.InputType['AttachedClusterAuthorizationArgs']]] = None,
                 binary_authorization: Optional[pulumi.Input[pulumi.InputType['AttachedClusterBinaryAuthorizationArgs']]] = None,
                 deletion_policy: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 distribution: Optional[pulumi.Input[str]] = None,
                 fleet: Optional[pulumi.Input[pulumi.InputType['AttachedClusterFleetArgs']]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 logging_config: Optional[pulumi.Input[pulumi.InputType['AttachedClusterLoggingConfigArgs']]] = None,
                 monitoring_config: Optional[pulumi.Input[pulumi.InputType['AttachedClusterMonitoringConfigArgs']]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 oidc_config: Optional[pulumi.Input[pulumi.InputType['AttachedClusterOidcConfigArgs']]] = None,
                 platform_version: Optional[pulumi.Input[str]] = None,
                 project: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        """
        An Anthos cluster running on customer owned infrastructure.

        To get more information about Cluster, see:

        * [API documentation](https://cloud.google.com/anthos/clusters/docs/multi-cloud/reference/rest)
        * How-to Guides
            * [API reference](https://cloud.google.com/anthos/clusters/docs/multi-cloud/reference/rest/v1/projects.locations.attachedClusters)
            * [Multicloud overview](https://cloud.google.com/anthos/clusters/docs/multi-cloud)

        ## Example Usage
        ### Container Attached Cluster Basic

        ```python
        import pulumi
        import pulumi_gcp as gcp

        project = gcp.organizations.get_project()
        versions = gcp.container.get_attached_versions(location="us-west1",
            project=project.project_id)
        primary = gcp.container.AttachedCluster("primary",
            location="us-west1",
            project=project.project_id,
            description="Test cluster",
            distribution="aks",
            oidc_config=gcp.container.AttachedClusterOidcConfigArgs(
                issuer_url="https://oidc.issuer.url",
            ),
            platform_version=versions.valid_versions[0],
            fleet=gcp.container.AttachedClusterFleetArgs(
                project=f"projects/{project.number}",
            ))
        ```
        ### Container Attached Cluster Ignore Errors

        ```python
        import pulumi
        import pulumi_gcp as gcp

        project = gcp.organizations.get_project()
        versions = gcp.container.get_attached_versions(location="us-west1",
            project=project.project_id)
        primary = gcp.container.AttachedCluster("primary",
            location="us-west1",
            project=project.project_id,
            description="Test cluster",
            distribution="aks",
            oidc_config=gcp.container.AttachedClusterOidcConfigArgs(
                issuer_url="https://oidc.issuer.url",
            ),
            platform_version=versions.valid_versions[0],
            fleet=gcp.container.AttachedClusterFleetArgs(
                project=f"projects/{project.number}",
            ),
            deletion_policy="DELETE_IGNORE_ERRORS")
        ```

        ## Import

        Cluster can be imported using any of these accepted formats

        ```sh
         $ pulumi import gcp:container/attachedCluster:AttachedCluster default projects/{{project}}/locations/{{location}}/attachedClusters/{{name}}
        ```

        ```sh
         $ pulumi import gcp:container/attachedCluster:AttachedCluster default {{project}}/{{location}}/{{name}}
        ```

        ```sh
         $ pulumi import gcp:container/attachedCluster:AttachedCluster default {{location}}/{{name}}
        ```

        :param str resource_name: The name of the resource.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Optional. Annotations on the cluster. This field has the same
               restrictions as Kubernetes annotations. The total size of all keys and
               values combined is limited to 256k. Key can have 2 segments: prefix (optional)
               and name (required), separated by a slash (/). Prefix must be a DNS subdomain.
               Name must be 63 characters or less, begin and end with alphanumerics,
               with dashes (-), underscores (_), dots (.), and alphanumerics between.
        :param pulumi.Input[pulumi.InputType['AttachedClusterAuthorizationArgs']] authorization: Configuration related to the cluster RBAC settings.
               Structure is documented below.
        :param pulumi.Input[pulumi.InputType['AttachedClusterBinaryAuthorizationArgs']] binary_authorization: Binary Authorization configuration.
               Structure is documented below.
        :param pulumi.Input[str] deletion_policy: Policy to determine what flags to send on delete.
        :param pulumi.Input[str] description: A human readable description of this attached cluster. Cannot be longer
               than 255 UTF-8 encoded bytes.
        :param pulumi.Input[str] distribution: The Kubernetes distribution of the underlying attached cluster. Supported values:
               "eks", "aks".
        :param pulumi.Input[pulumi.InputType['AttachedClusterFleetArgs']] fleet: Fleet configuration.
               Structure is documented below.
        :param pulumi.Input[str] location: The location for the resource
        :param pulumi.Input[pulumi.InputType['AttachedClusterLoggingConfigArgs']] logging_config: Logging configuration.
               Structure is documented below.
        :param pulumi.Input[pulumi.InputType['AttachedClusterMonitoringConfigArgs']] monitoring_config: Monitoring configuration.
               Structure is documented below.
        :param pulumi.Input[str] name: The name of this resource.
        :param pulumi.Input[pulumi.InputType['AttachedClusterOidcConfigArgs']] oidc_config: OIDC discovery information of the target cluster.
               Kubernetes Service Account (KSA) tokens are JWT tokens signed by the cluster
               API server. This fields indicates how GCP services
               validate KSA tokens in order to allow system workloads (such as GKE Connect
               and telemetry agents) to authenticate back to GCP.
               Both clusters with public and private issuer URLs are supported.
               Clusters with public issuers only need to specify the `issuer_url` field
               while clusters with private issuers need to provide both
               `issuer_url` and `jwks`.
               Structure is documented below.
        :param pulumi.Input[str] platform_version: The platform version for the cluster (e.g. `1.23.0-gke.1`).
        :param pulumi.Input[str] project: The ID of the project in which the resource belongs.
               If it is not provided, the provider project is used.
        """
        ...
    @overload
    def __init__(__self__,
                 resource_name: str,
                 args: AttachedClusterArgs,
                 opts: Optional[pulumi.ResourceOptions] = None):
        """
        An Anthos cluster running on customer owned infrastructure.

        To get more information about Cluster, see:

        * [API documentation](https://cloud.google.com/anthos/clusters/docs/multi-cloud/reference/rest)
        * How-to Guides
            * [API reference](https://cloud.google.com/anthos/clusters/docs/multi-cloud/reference/rest/v1/projects.locations.attachedClusters)
            * [Multicloud overview](https://cloud.google.com/anthos/clusters/docs/multi-cloud)

        ## Example Usage
        ### Container Attached Cluster Basic

        ```python
        import pulumi
        import pulumi_gcp as gcp

        project = gcp.organizations.get_project()
        versions = gcp.container.get_attached_versions(location="us-west1",
            project=project.project_id)
        primary = gcp.container.AttachedCluster("primary",
            location="us-west1",
            project=project.project_id,
            description="Test cluster",
            distribution="aks",
            oidc_config=gcp.container.AttachedClusterOidcConfigArgs(
                issuer_url="https://oidc.issuer.url",
            ),
            platform_version=versions.valid_versions[0],
            fleet=gcp.container.AttachedClusterFleetArgs(
                project=f"projects/{project.number}",
            ))
        ```
        ### Container Attached Cluster Ignore Errors

        ```python
        import pulumi
        import pulumi_gcp as gcp

        project = gcp.organizations.get_project()
        versions = gcp.container.get_attached_versions(location="us-west1",
            project=project.project_id)
        primary = gcp.container.AttachedCluster("primary",
            location="us-west1",
            project=project.project_id,
            description="Test cluster",
            distribution="aks",
            oidc_config=gcp.container.AttachedClusterOidcConfigArgs(
                issuer_url="https://oidc.issuer.url",
            ),
            platform_version=versions.valid_versions[0],
            fleet=gcp.container.AttachedClusterFleetArgs(
                project=f"projects/{project.number}",
            ),
            deletion_policy="DELETE_IGNORE_ERRORS")
        ```

        ## Import

        Cluster can be imported using any of these accepted formats

        ```sh
         $ pulumi import gcp:container/attachedCluster:AttachedCluster default projects/{{project}}/locations/{{location}}/attachedClusters/{{name}}
        ```

        ```sh
         $ pulumi import gcp:container/attachedCluster:AttachedCluster default {{project}}/{{location}}/{{name}}
        ```

        ```sh
         $ pulumi import gcp:container/attachedCluster:AttachedCluster default {{location}}/{{name}}
        ```

        :param str resource_name: The name of the resource.
        :param AttachedClusterArgs args: The arguments to use to populate this resource's properties.
        :param pulumi.ResourceOptions opts: Options for the resource.
        """
        ...
    def __init__(__self__, resource_name: str, *args, **kwargs):
        resource_args, opts = _utilities.get_resource_args_opts(AttachedClusterArgs, pulumi.ResourceOptions, *args, **kwargs)
        if resource_args is not None:
            __self__._internal_init(resource_name, opts, **resource_args.__dict__)
        else:
            kwargs = kwargs or {}
            def _setter(key, value):
                kwargs[key] = value
            AttachedClusterArgs._configure(_setter, **kwargs)
            __self__._internal_init(resource_name, *args, **kwargs)

    def _internal_init(__self__,
                 resource_name: str,
                 opts: Optional[pulumi.ResourceOptions] = None,
                 annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 authorization: Optional[pulumi.Input[pulumi.InputType['AttachedClusterAuthorizationArgs']]] = None,
                 binary_authorization: Optional[pulumi.Input[pulumi.InputType['AttachedClusterBinaryAuthorizationArgs']]] = None,
                 deletion_policy: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 distribution: Optional[pulumi.Input[str]] = None,
                 fleet: Optional[pulumi.Input[pulumi.InputType['AttachedClusterFleetArgs']]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 logging_config: Optional[pulumi.Input[pulumi.InputType['AttachedClusterLoggingConfigArgs']]] = None,
                 monitoring_config: Optional[pulumi.Input[pulumi.InputType['AttachedClusterMonitoringConfigArgs']]] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 oidc_config: Optional[pulumi.Input[pulumi.InputType['AttachedClusterOidcConfigArgs']]] = None,
                 platform_version: Optional[pulumi.Input[str]] = None,
                 project: Optional[pulumi.Input[str]] = None,
                 __props__=None):
        opts = pulumi.ResourceOptions.merge(_utilities.get_resource_opts_defaults(), opts)
        if not isinstance(opts, pulumi.ResourceOptions):
            raise TypeError('Expected resource options to be a ResourceOptions instance')
        if opts.id is None:
            if __props__ is not None:
                raise TypeError('__props__ is only valid when passed in combination with a valid opts.id to get an existing resource')
            __props__ = AttachedClusterArgs.__new__(AttachedClusterArgs)

            __props__.__dict__["annotations"] = annotations
            if authorization is not None and not isinstance(authorization, AttachedClusterAuthorizationArgs):
                authorization = authorization or {}
                def _setter(key, value):
                    authorization[key] = value
                AttachedClusterAuthorizationArgs._configure(_setter, **authorization)
            __props__.__dict__["authorization"] = authorization
            if binary_authorization is not None and not isinstance(binary_authorization, AttachedClusterBinaryAuthorizationArgs):
                binary_authorization = binary_authorization or {}
                def _setter(key, value):
                    binary_authorization[key] = value
                AttachedClusterBinaryAuthorizationArgs._configure(_setter, **binary_authorization)
            __props__.__dict__["binary_authorization"] = binary_authorization
            __props__.__dict__["deletion_policy"] = deletion_policy
            __props__.__dict__["description"] = description
            if distribution is None and not opts.urn:
                raise TypeError("Missing required property 'distribution'")
            __props__.__dict__["distribution"] = distribution
            if fleet is not None and not isinstance(fleet, AttachedClusterFleetArgs):
                fleet = fleet or {}
                def _setter(key, value):
                    fleet[key] = value
                AttachedClusterFleetArgs._configure(_setter, **fleet)
            if fleet is None and not opts.urn:
                raise TypeError("Missing required property 'fleet'")
            __props__.__dict__["fleet"] = fleet
            if location is None and not opts.urn:
                raise TypeError("Missing required property 'location'")
            __props__.__dict__["location"] = location
            if logging_config is not None and not isinstance(logging_config, AttachedClusterLoggingConfigArgs):
                logging_config = logging_config or {}
                def _setter(key, value):
                    logging_config[key] = value
                AttachedClusterLoggingConfigArgs._configure(_setter, **logging_config)
            __props__.__dict__["logging_config"] = logging_config
            if monitoring_config is not None and not isinstance(monitoring_config, AttachedClusterMonitoringConfigArgs):
                monitoring_config = monitoring_config or {}
                def _setter(key, value):
                    monitoring_config[key] = value
                AttachedClusterMonitoringConfigArgs._configure(_setter, **monitoring_config)
            __props__.__dict__["monitoring_config"] = monitoring_config
            __props__.__dict__["name"] = name
            if oidc_config is not None and not isinstance(oidc_config, AttachedClusterOidcConfigArgs):
                oidc_config = oidc_config or {}
                def _setter(key, value):
                    oidc_config[key] = value
                AttachedClusterOidcConfigArgs._configure(_setter, **oidc_config)
            if oidc_config is None and not opts.urn:
                raise TypeError("Missing required property 'oidc_config'")
            __props__.__dict__["oidc_config"] = oidc_config
            if platform_version is None and not opts.urn:
                raise TypeError("Missing required property 'platform_version'")
            __props__.__dict__["platform_version"] = platform_version
            __props__.__dict__["project"] = project
            __props__.__dict__["cluster_region"] = None
            __props__.__dict__["create_time"] = None
            __props__.__dict__["errors"] = None
            __props__.__dict__["kubernetes_version"] = None
            __props__.__dict__["reconciling"] = None
            __props__.__dict__["state"] = None
            __props__.__dict__["uid"] = None
            __props__.__dict__["update_time"] = None
            __props__.__dict__["workload_identity_configs"] = None
        super(AttachedCluster, __self__).__init__(
            'gcp:container/attachedCluster:AttachedCluster',
            resource_name,
            __props__,
            opts)

    @staticmethod
    def get(resource_name: str,
            id: pulumi.Input[str],
            opts: Optional[pulumi.ResourceOptions] = None,
            annotations: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
            authorization: Optional[pulumi.Input[pulumi.InputType['AttachedClusterAuthorizationArgs']]] = None,
            binary_authorization: Optional[pulumi.Input[pulumi.InputType['AttachedClusterBinaryAuthorizationArgs']]] = None,
            cluster_region: Optional[pulumi.Input[str]] = None,
            create_time: Optional[pulumi.Input[str]] = None,
            deletion_policy: Optional[pulumi.Input[str]] = None,
            description: Optional[pulumi.Input[str]] = None,
            distribution: Optional[pulumi.Input[str]] = None,
            errors: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['AttachedClusterErrorArgs']]]]] = None,
            fleet: Optional[pulumi.Input[pulumi.InputType['AttachedClusterFleetArgs']]] = None,
            kubernetes_version: Optional[pulumi.Input[str]] = None,
            location: Optional[pulumi.Input[str]] = None,
            logging_config: Optional[pulumi.Input[pulumi.InputType['AttachedClusterLoggingConfigArgs']]] = None,
            monitoring_config: Optional[pulumi.Input[pulumi.InputType['AttachedClusterMonitoringConfigArgs']]] = None,
            name: Optional[pulumi.Input[str]] = None,
            oidc_config: Optional[pulumi.Input[pulumi.InputType['AttachedClusterOidcConfigArgs']]] = None,
            platform_version: Optional[pulumi.Input[str]] = None,
            project: Optional[pulumi.Input[str]] = None,
            reconciling: Optional[pulumi.Input[bool]] = None,
            state: Optional[pulumi.Input[str]] = None,
            uid: Optional[pulumi.Input[str]] = None,
            update_time: Optional[pulumi.Input[str]] = None,
            workload_identity_configs: Optional[pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['AttachedClusterWorkloadIdentityConfigArgs']]]]] = None) -> 'AttachedCluster':
        """
        Get an existing AttachedCluster resource's state with the given name, id, and optional extra
        properties used to qualify the lookup.

        :param str resource_name: The unique name of the resulting resource.
        :param pulumi.Input[str] id: The unique provider ID of the resource to lookup.
        :param pulumi.ResourceOptions opts: Options for the resource.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] annotations: Optional. Annotations on the cluster. This field has the same
               restrictions as Kubernetes annotations. The total size of all keys and
               values combined is limited to 256k. Key can have 2 segments: prefix (optional)
               and name (required), separated by a slash (/). Prefix must be a DNS subdomain.
               Name must be 63 characters or less, begin and end with alphanumerics,
               with dashes (-), underscores (_), dots (.), and alphanumerics between.
        :param pulumi.Input[pulumi.InputType['AttachedClusterAuthorizationArgs']] authorization: Configuration related to the cluster RBAC settings.
               Structure is documented below.
        :param pulumi.Input[pulumi.InputType['AttachedClusterBinaryAuthorizationArgs']] binary_authorization: Binary Authorization configuration.
               Structure is documented below.
        :param pulumi.Input[str] cluster_region: Output only. The region where this cluster runs.
               For EKS clusters, this is an AWS region. For AKS clusters,
               this is an Azure region.
        :param pulumi.Input[str] create_time: Output only. The time at which this cluster was created.
        :param pulumi.Input[str] deletion_policy: Policy to determine what flags to send on delete.
        :param pulumi.Input[str] description: A human readable description of this attached cluster. Cannot be longer
               than 255 UTF-8 encoded bytes.
        :param pulumi.Input[str] distribution: The Kubernetes distribution of the underlying attached cluster. Supported values:
               "eks", "aks".
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['AttachedClusterErrorArgs']]]] errors: A set of errors found in the cluster.
               Structure is documented below.
        :param pulumi.Input[pulumi.InputType['AttachedClusterFleetArgs']] fleet: Fleet configuration.
               Structure is documented below.
        :param pulumi.Input[str] kubernetes_version: The Kubernetes version of the cluster.
        :param pulumi.Input[str] location: The location for the resource
        :param pulumi.Input[pulumi.InputType['AttachedClusterLoggingConfigArgs']] logging_config: Logging configuration.
               Structure is documented below.
        :param pulumi.Input[pulumi.InputType['AttachedClusterMonitoringConfigArgs']] monitoring_config: Monitoring configuration.
               Structure is documented below.
        :param pulumi.Input[str] name: The name of this resource.
        :param pulumi.Input[pulumi.InputType['AttachedClusterOidcConfigArgs']] oidc_config: OIDC discovery information of the target cluster.
               Kubernetes Service Account (KSA) tokens are JWT tokens signed by the cluster
               API server. This fields indicates how GCP services
               validate KSA tokens in order to allow system workloads (such as GKE Connect
               and telemetry agents) to authenticate back to GCP.
               Both clusters with public and private issuer URLs are supported.
               Clusters with public issuers only need to specify the `issuer_url` field
               while clusters with private issuers need to provide both
               `issuer_url` and `jwks`.
               Structure is documented below.
        :param pulumi.Input[str] platform_version: The platform version for the cluster (e.g. `1.23.0-gke.1`).
        :param pulumi.Input[str] project: The ID of the project in which the resource belongs.
               If it is not provided, the provider project is used.
        :param pulumi.Input[bool] reconciling: If set, there are currently changes in flight to the cluster.
        :param pulumi.Input[str] state: The current state of the cluster. Possible values:
               STATE_UNSPECIFIED, PROVISIONING, RUNNING, RECONCILING, STOPPING, ERROR,
               DEGRADED
        :param pulumi.Input[str] uid: A globally unique identifier for the cluster.
        :param pulumi.Input[str] update_time: The time at which this cluster was last updated.
        :param pulumi.Input[Sequence[pulumi.Input[pulumi.InputType['AttachedClusterWorkloadIdentityConfigArgs']]]] workload_identity_configs: Workload Identity settings.
               Structure is documented below.
        """
        opts = pulumi.ResourceOptions.merge(opts, pulumi.ResourceOptions(id=id))

        __props__ = _AttachedClusterState.__new__(_AttachedClusterState)

        __props__.__dict__["annotations"] = annotations
        __props__.__dict__["authorization"] = authorization
        __props__.__dict__["binary_authorization"] = binary_authorization
        __props__.__dict__["cluster_region"] = cluster_region
        __props__.__dict__["create_time"] = create_time
        __props__.__dict__["deletion_policy"] = deletion_policy
        __props__.__dict__["description"] = description
        __props__.__dict__["distribution"] = distribution
        __props__.__dict__["errors"] = errors
        __props__.__dict__["fleet"] = fleet
        __props__.__dict__["kubernetes_version"] = kubernetes_version
        __props__.__dict__["location"] = location
        __props__.__dict__["logging_config"] = logging_config
        __props__.__dict__["monitoring_config"] = monitoring_config
        __props__.__dict__["name"] = name
        __props__.__dict__["oidc_config"] = oidc_config
        __props__.__dict__["platform_version"] = platform_version
        __props__.__dict__["project"] = project
        __props__.__dict__["reconciling"] = reconciling
        __props__.__dict__["state"] = state
        __props__.__dict__["uid"] = uid
        __props__.__dict__["update_time"] = update_time
        __props__.__dict__["workload_identity_configs"] = workload_identity_configs
        return AttachedCluster(resource_name, opts=opts, __props__=__props__)

    @property
    @pulumi.getter
    def annotations(self) -> pulumi.Output[Optional[Mapping[str, str]]]:
        """
        Optional. Annotations on the cluster. This field has the same
        restrictions as Kubernetes annotations. The total size of all keys and
        values combined is limited to 256k. Key can have 2 segments: prefix (optional)
        and name (required), separated by a slash (/). Prefix must be a DNS subdomain.
        Name must be 63 characters or less, begin and end with alphanumerics,
        with dashes (-), underscores (_), dots (.), and alphanumerics between.
        """
        return pulumi.get(self, "annotations")

    @property
    @pulumi.getter
    def authorization(self) -> pulumi.Output[Optional['outputs.AttachedClusterAuthorization']]:
        """
        Configuration related to the cluster RBAC settings.
        Structure is documented below.
        """
        return pulumi.get(self, "authorization")

    @property
    @pulumi.getter(name="binaryAuthorization")
    def binary_authorization(self) -> pulumi.Output['outputs.AttachedClusterBinaryAuthorization']:
        """
        Binary Authorization configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "binary_authorization")

    @property
    @pulumi.getter(name="clusterRegion")
    def cluster_region(self) -> pulumi.Output[str]:
        """
        Output only. The region where this cluster runs.
        For EKS clusters, this is an AWS region. For AKS clusters,
        this is an Azure region.
        """
        return pulumi.get(self, "cluster_region")

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> pulumi.Output[str]:
        """
        Output only. The time at which this cluster was created.
        """
        return pulumi.get(self, "create_time")

    @property
    @pulumi.getter(name="deletionPolicy")
    def deletion_policy(self) -> pulumi.Output[Optional[str]]:
        """
        Policy to determine what flags to send on delete.
        """
        return pulumi.get(self, "deletion_policy")

    @property
    @pulumi.getter
    def description(self) -> pulumi.Output[Optional[str]]:
        """
        A human readable description of this attached cluster. Cannot be longer
        than 255 UTF-8 encoded bytes.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def distribution(self) -> pulumi.Output[str]:
        """
        The Kubernetes distribution of the underlying attached cluster. Supported values:
        "eks", "aks".
        """
        return pulumi.get(self, "distribution")

    @property
    @pulumi.getter
    def errors(self) -> pulumi.Output[Sequence['outputs.AttachedClusterError']]:
        """
        A set of errors found in the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "errors")

    @property
    @pulumi.getter
    def fleet(self) -> pulumi.Output['outputs.AttachedClusterFleet']:
        """
        Fleet configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "fleet")

    @property
    @pulumi.getter(name="kubernetesVersion")
    def kubernetes_version(self) -> pulumi.Output[str]:
        """
        The Kubernetes version of the cluster.
        """
        return pulumi.get(self, "kubernetes_version")

    @property
    @pulumi.getter
    def location(self) -> pulumi.Output[str]:
        """
        The location for the resource
        """
        return pulumi.get(self, "location")

    @property
    @pulumi.getter(name="loggingConfig")
    def logging_config(self) -> pulumi.Output[Optional['outputs.AttachedClusterLoggingConfig']]:
        """
        Logging configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "logging_config")

    @property
    @pulumi.getter(name="monitoringConfig")
    def monitoring_config(self) -> pulumi.Output['outputs.AttachedClusterMonitoringConfig']:
        """
        Monitoring configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "monitoring_config")

    @property
    @pulumi.getter
    def name(self) -> pulumi.Output[str]:
        """
        The name of this resource.
        """
        return pulumi.get(self, "name")

    @property
    @pulumi.getter(name="oidcConfig")
    def oidc_config(self) -> pulumi.Output['outputs.AttachedClusterOidcConfig']:
        """
        OIDC discovery information of the target cluster.
        Kubernetes Service Account (KSA) tokens are JWT tokens signed by the cluster
        API server. This fields indicates how GCP services
        validate KSA tokens in order to allow system workloads (such as GKE Connect
        and telemetry agents) to authenticate back to GCP.
        Both clusters with public and private issuer URLs are supported.
        Clusters with public issuers only need to specify the `issuer_url` field
        while clusters with private issuers need to provide both
        `issuer_url` and `jwks`.
        Structure is documented below.
        """
        return pulumi.get(self, "oidc_config")

    @property
    @pulumi.getter(name="platformVersion")
    def platform_version(self) -> pulumi.Output[str]:
        """
        The platform version for the cluster (e.g. `1.23.0-gke.1`).
        """
        return pulumi.get(self, "platform_version")

    @property
    @pulumi.getter
    def project(self) -> pulumi.Output[str]:
        """
        The ID of the project in which the resource belongs.
        If it is not provided, the provider project is used.
        """
        return pulumi.get(self, "project")

    @property
    @pulumi.getter
    def reconciling(self) -> pulumi.Output[bool]:
        """
        If set, there are currently changes in flight to the cluster.
        """
        return pulumi.get(self, "reconciling")

    @property
    @pulumi.getter
    def state(self) -> pulumi.Output[str]:
        """
        The current state of the cluster. Possible values:
        STATE_UNSPECIFIED, PROVISIONING, RUNNING, RECONCILING, STOPPING, ERROR,
        DEGRADED
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def uid(self) -> pulumi.Output[str]:
        """
        A globally unique identifier for the cluster.
        """
        return pulumi.get(self, "uid")

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> pulumi.Output[str]:
        """
        The time at which this cluster was last updated.
        """
        return pulumi.get(self, "update_time")

    @property
    @pulumi.getter(name="workloadIdentityConfigs")
    def workload_identity_configs(self) -> pulumi.Output[Sequence['outputs.AttachedClusterWorkloadIdentityConfig']]:
        """
        Workload Identity settings.
        Structure is documented below.
        """
        return pulumi.get(self, "workload_identity_configs")

