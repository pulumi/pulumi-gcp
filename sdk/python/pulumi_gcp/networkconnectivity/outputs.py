# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'HubRoutingVpc',
    'ServiceConnectionPolicyPscConfig',
    'ServiceConnectionPolicyPscConnection',
    'ServiceConnectionPolicyPscConnectionError',
    'ServiceConnectionPolicyPscConnectionErrorInfo',
    'SpokeLinkedInterconnectAttachments',
    'SpokeLinkedRouterApplianceInstances',
    'SpokeLinkedRouterApplianceInstancesInstance',
    'SpokeLinkedVpcNetwork',
    'SpokeLinkedVpnTunnels',
]

@pulumi.output_type
class HubRoutingVpc(dict):
    def __init__(__self__, *,
                 uri: Optional[str] = None):
        HubRoutingVpc._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if uri is not None:
            _setter("uri", uri)

    @property
    @pulumi.getter
    def uri(self) -> Optional[str]:
        return pulumi.get(self, "uri")


@pulumi.output_type
class ServiceConnectionPolicyPscConfig(dict):
    def __init__(__self__, *,
                 subnetworks: Sequence[str],
                 limit: Optional[str] = None):
        """
        :param Sequence[str] subnetworks: IDs of the subnetworks or fully qualified identifiers for the subnetworks
        :param str limit: Max number of PSC connections for this policy.
        """
        ServiceConnectionPolicyPscConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            subnetworks=subnetworks,
            limit=limit,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             subnetworks: Sequence[str],
             limit: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("subnetworks", subnetworks)
        if limit is not None:
            _setter("limit", limit)

    @property
    @pulumi.getter
    def subnetworks(self) -> Sequence[str]:
        """
        IDs of the subnetworks or fully qualified identifiers for the subnetworks
        """
        return pulumi.get(self, "subnetworks")

    @property
    @pulumi.getter
    def limit(self) -> Optional[str]:
        """
        Max number of PSC connections for this policy.
        """
        return pulumi.get(self, "limit")


@pulumi.output_type
class ServiceConnectionPolicyPscConnection(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "consumerAddress":
            suggest = "consumer_address"
        elif key == "consumerForwardingRule":
            suggest = "consumer_forwarding_rule"
        elif key == "consumerTargetProject":
            suggest = "consumer_target_project"
        elif key == "errorInfo":
            suggest = "error_info"
        elif key == "errorType":
            suggest = "error_type"
        elif key == "gceOperation":
            suggest = "gce_operation"
        elif key == "pscConnectionId":
            suggest = "psc_connection_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ServiceConnectionPolicyPscConnection. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ServiceConnectionPolicyPscConnection.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ServiceConnectionPolicyPscConnection.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 consumer_address: Optional[str] = None,
                 consumer_forwarding_rule: Optional[str] = None,
                 consumer_target_project: Optional[str] = None,
                 error: Optional['outputs.ServiceConnectionPolicyPscConnectionError'] = None,
                 error_info: Optional['outputs.ServiceConnectionPolicyPscConnectionErrorInfo'] = None,
                 error_type: Optional[str] = None,
                 gce_operation: Optional[str] = None,
                 psc_connection_id: Optional[str] = None,
                 state: Optional[str] = None):
        """
        :param str consumer_address: The resource reference of the consumer address.
        :param str consumer_forwarding_rule: The resource reference of the PSC Forwarding Rule within the consumer VPC.
        :param str consumer_target_project: The project where the PSC connection is created.
        :param 'ServiceConnectionPolicyPscConnectionErrorArgs' error: The most recent error during operating this connection.
               Structure is documented below.
        :param 'ServiceConnectionPolicyPscConnectionErrorInfoArgs' error_info: The error info for the latest error during operating this connection.
               Structure is documented below.
        :param str error_type: The error type indicates whether the error is consumer facing, producer
               facing or system internal.
               Possible values are: `CONNECTION_ERROR_TYPE_UNSPECIFIED`, `ERROR_INTERNAL`, `ERROR_CONSUMER_SIDE`, `ERROR_PRODUCER_SIDE`.
        :param str gce_operation: The last Compute Engine operation to setup PSC connection.
        :param str psc_connection_id: The PSC connection id of the PSC forwarding rule.
        :param str state: The state of the PSC connection.
               Possible values are: `STATE_UNSPECIFIED`, `ACTIVE`, `CREATING`, `DELETING`, `FAILED`.
        """
        ServiceConnectionPolicyPscConnection._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            consumer_address=consumer_address,
            consumer_forwarding_rule=consumer_forwarding_rule,
            consumer_target_project=consumer_target_project,
            error=error,
            error_info=error_info,
            error_type=error_type,
            gce_operation=gce_operation,
            psc_connection_id=psc_connection_id,
            state=state,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             consumer_address: Optional[str] = None,
             consumer_forwarding_rule: Optional[str] = None,
             consumer_target_project: Optional[str] = None,
             error: Optional['outputs.ServiceConnectionPolicyPscConnectionError'] = None,
             error_info: Optional['outputs.ServiceConnectionPolicyPscConnectionErrorInfo'] = None,
             error_type: Optional[str] = None,
             gce_operation: Optional[str] = None,
             psc_connection_id: Optional[str] = None,
             state: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if consumer_address is not None:
            _setter("consumer_address", consumer_address)
        if consumer_forwarding_rule is not None:
            _setter("consumer_forwarding_rule", consumer_forwarding_rule)
        if consumer_target_project is not None:
            _setter("consumer_target_project", consumer_target_project)
        if error is not None:
            _setter("error", error)
        if error_info is not None:
            _setter("error_info", error_info)
        if error_type is not None:
            _setter("error_type", error_type)
        if gce_operation is not None:
            _setter("gce_operation", gce_operation)
        if psc_connection_id is not None:
            _setter("psc_connection_id", psc_connection_id)
        if state is not None:
            _setter("state", state)

    @property
    @pulumi.getter(name="consumerAddress")
    def consumer_address(self) -> Optional[str]:
        """
        The resource reference of the consumer address.
        """
        return pulumi.get(self, "consumer_address")

    @property
    @pulumi.getter(name="consumerForwardingRule")
    def consumer_forwarding_rule(self) -> Optional[str]:
        """
        The resource reference of the PSC Forwarding Rule within the consumer VPC.
        """
        return pulumi.get(self, "consumer_forwarding_rule")

    @property
    @pulumi.getter(name="consumerTargetProject")
    def consumer_target_project(self) -> Optional[str]:
        """
        The project where the PSC connection is created.
        """
        return pulumi.get(self, "consumer_target_project")

    @property
    @pulumi.getter
    def error(self) -> Optional['outputs.ServiceConnectionPolicyPscConnectionError']:
        """
        The most recent error during operating this connection.
        Structure is documented below.
        """
        return pulumi.get(self, "error")

    @property
    @pulumi.getter(name="errorInfo")
    def error_info(self) -> Optional['outputs.ServiceConnectionPolicyPscConnectionErrorInfo']:
        """
        The error info for the latest error during operating this connection.
        Structure is documented below.
        """
        return pulumi.get(self, "error_info")

    @property
    @pulumi.getter(name="errorType")
    def error_type(self) -> Optional[str]:
        """
        The error type indicates whether the error is consumer facing, producer
        facing or system internal.
        Possible values are: `CONNECTION_ERROR_TYPE_UNSPECIFIED`, `ERROR_INTERNAL`, `ERROR_CONSUMER_SIDE`, `ERROR_PRODUCER_SIDE`.
        """
        return pulumi.get(self, "error_type")

    @property
    @pulumi.getter(name="gceOperation")
    def gce_operation(self) -> Optional[str]:
        """
        The last Compute Engine operation to setup PSC connection.
        """
        return pulumi.get(self, "gce_operation")

    @property
    @pulumi.getter(name="pscConnectionId")
    def psc_connection_id(self) -> Optional[str]:
        """
        The PSC connection id of the PSC forwarding rule.
        """
        return pulumi.get(self, "psc_connection_id")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        The state of the PSC connection.
        Possible values are: `STATE_UNSPECIFIED`, `ACTIVE`, `CREATING`, `DELETING`, `FAILED`.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class ServiceConnectionPolicyPscConnectionError(dict):
    def __init__(__self__, *,
                 code: Optional[int] = None,
                 details: Optional[Sequence[Mapping[str, Any]]] = None,
                 message: Optional[str] = None):
        """
        :param int code: The status code, which should be an enum value of [google.rpc.Code][].
        :param Sequence[Mapping[str, Any]] details: (Output)
               A list of messages that carry the error details.
        :param str message: A developer-facing error message.
        """
        ServiceConnectionPolicyPscConnectionError._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            code=code,
            details=details,
            message=message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             code: Optional[int] = None,
             details: Optional[Sequence[Mapping[str, Any]]] = None,
             message: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if code is not None:
            _setter("code", code)
        if details is not None:
            _setter("details", details)
        if message is not None:
            _setter("message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[int]:
        """
        The status code, which should be an enum value of [google.rpc.Code][].
        """
        return pulumi.get(self, "code")

    @property
    @pulumi.getter
    def details(self) -> Optional[Sequence[Mapping[str, Any]]]:
        """
        (Output)
        A list of messages that carry the error details.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        A developer-facing error message.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class ServiceConnectionPolicyPscConnectionErrorInfo(dict):
    def __init__(__self__, *,
                 domain: Optional[str] = None,
                 metadata: Optional[Mapping[str, str]] = None,
                 reason: Optional[str] = None):
        """
        :param str domain: The logical grouping to which the "reason" belongs.
        :param Mapping[str, str] metadata: Additional structured details about this error.
        :param str reason: The reason of the error.
        """
        ServiceConnectionPolicyPscConnectionErrorInfo._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            domain=domain,
            metadata=metadata,
            reason=reason,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             domain: Optional[str] = None,
             metadata: Optional[Mapping[str, str]] = None,
             reason: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if domain is not None:
            _setter("domain", domain)
        if metadata is not None:
            _setter("metadata", metadata)
        if reason is not None:
            _setter("reason", reason)

    @property
    @pulumi.getter
    def domain(self) -> Optional[str]:
        """
        The logical grouping to which the "reason" belongs.
        """
        return pulumi.get(self, "domain")

    @property
    @pulumi.getter
    def metadata(self) -> Optional[Mapping[str, str]]:
        """
        Additional structured details about this error.
        """
        return pulumi.get(self, "metadata")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        The reason of the error.
        """
        return pulumi.get(self, "reason")


@pulumi.output_type
class SpokeLinkedInterconnectAttachments(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "siteToSiteDataTransfer":
            suggest = "site_to_site_data_transfer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpokeLinkedInterconnectAttachments. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpokeLinkedInterconnectAttachments.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpokeLinkedInterconnectAttachments.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 site_to_site_data_transfer: bool,
                 uris: Sequence[str]):
        """
        :param bool site_to_site_data_transfer: A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
        :param Sequence[str] uris: The URIs of linked interconnect attachment resources
        """
        SpokeLinkedInterconnectAttachments._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            site_to_site_data_transfer=site_to_site_data_transfer,
            uris=uris,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             site_to_site_data_transfer: bool,
             uris: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("site_to_site_data_transfer", site_to_site_data_transfer)
        _setter("uris", uris)

    @property
    @pulumi.getter(name="siteToSiteDataTransfer")
    def site_to_site_data_transfer(self) -> bool:
        """
        A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
        """
        return pulumi.get(self, "site_to_site_data_transfer")

    @property
    @pulumi.getter
    def uris(self) -> Sequence[str]:
        """
        The URIs of linked interconnect attachment resources
        """
        return pulumi.get(self, "uris")


@pulumi.output_type
class SpokeLinkedRouterApplianceInstances(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "siteToSiteDataTransfer":
            suggest = "site_to_site_data_transfer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpokeLinkedRouterApplianceInstances. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpokeLinkedRouterApplianceInstances.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpokeLinkedRouterApplianceInstances.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 instances: Sequence['outputs.SpokeLinkedRouterApplianceInstancesInstance'],
                 site_to_site_data_transfer: bool):
        """
        :param Sequence['SpokeLinkedRouterApplianceInstancesInstanceArgs'] instances: The list of router appliance instances
        :param bool site_to_site_data_transfer: A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
        """
        SpokeLinkedRouterApplianceInstances._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            instances=instances,
            site_to_site_data_transfer=site_to_site_data_transfer,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             instances: Sequence['outputs.SpokeLinkedRouterApplianceInstancesInstance'],
             site_to_site_data_transfer: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("instances", instances)
        _setter("site_to_site_data_transfer", site_to_site_data_transfer)

    @property
    @pulumi.getter
    def instances(self) -> Sequence['outputs.SpokeLinkedRouterApplianceInstancesInstance']:
        """
        The list of router appliance instances
        """
        return pulumi.get(self, "instances")

    @property
    @pulumi.getter(name="siteToSiteDataTransfer")
    def site_to_site_data_transfer(self) -> bool:
        """
        A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
        """
        return pulumi.get(self, "site_to_site_data_transfer")


@pulumi.output_type
class SpokeLinkedRouterApplianceInstancesInstance(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "virtualMachine":
            suggest = "virtual_machine"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpokeLinkedRouterApplianceInstancesInstance. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpokeLinkedRouterApplianceInstancesInstance.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpokeLinkedRouterApplianceInstancesInstance.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: Optional[str] = None,
                 virtual_machine: Optional[str] = None):
        """
        :param str ip_address: The IP address on the VM to use for peering.
        :param str virtual_machine: The URI of the virtual machine resource
               
               - - -
        """
        SpokeLinkedRouterApplianceInstancesInstance._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_address=ip_address,
            virtual_machine=virtual_machine,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_address: Optional[str] = None,
             virtual_machine: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if ip_address is not None:
            _setter("ip_address", ip_address)
        if virtual_machine is not None:
            _setter("virtual_machine", virtual_machine)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[str]:
        """
        The IP address on the VM to use for peering.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="virtualMachine")
    def virtual_machine(self) -> Optional[str]:
        """
        The URI of the virtual machine resource

        - - -
        """
        return pulumi.get(self, "virtual_machine")


@pulumi.output_type
class SpokeLinkedVpcNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeExportRanges":
            suggest = "exclude_export_ranges"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpokeLinkedVpcNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpokeLinkedVpcNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpokeLinkedVpcNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: str,
                 exclude_export_ranges: Optional[Sequence[str]] = None):
        """
        :param str uri: The URI of the VPC network resource.
        :param Sequence[str] exclude_export_ranges: IP ranges encompassing the subnets to be excluded from peering.
        """
        SpokeLinkedVpcNetwork._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            exclude_export_ranges=exclude_export_ranges,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: str,
             exclude_export_ranges: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("uri", uri)
        if exclude_export_ranges is not None:
            _setter("exclude_export_ranges", exclude_export_ranges)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        The URI of the VPC network resource.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="excludeExportRanges")
    def exclude_export_ranges(self) -> Optional[Sequence[str]]:
        """
        IP ranges encompassing the subnets to be excluded from peering.
        """
        return pulumi.get(self, "exclude_export_ranges")


@pulumi.output_type
class SpokeLinkedVpnTunnels(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "siteToSiteDataTransfer":
            suggest = "site_to_site_data_transfer"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SpokeLinkedVpnTunnels. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SpokeLinkedVpnTunnels.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SpokeLinkedVpnTunnels.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 site_to_site_data_transfer: bool,
                 uris: Sequence[str]):
        """
        :param bool site_to_site_data_transfer: A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
        :param Sequence[str] uris: The URIs of linked VPN tunnel resources.
        """
        SpokeLinkedVpnTunnels._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            site_to_site_data_transfer=site_to_site_data_transfer,
            uris=uris,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             site_to_site_data_transfer: bool,
             uris: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("site_to_site_data_transfer", site_to_site_data_transfer)
        _setter("uris", uris)

    @property
    @pulumi.getter(name="siteToSiteDataTransfer")
    def site_to_site_data_transfer(self) -> bool:
        """
        A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
        """
        return pulumi.get(self, "site_to_site_data_transfer")

    @property
    @pulumi.getter
    def uris(self) -> Sequence[str]:
        """
        The URIs of linked VPN tunnel resources.
        """
        return pulumi.get(self, "uris")


