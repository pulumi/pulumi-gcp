# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'GroupAutoAcceptArgs',
    'GroupAutoAcceptArgsDict',
    'HubRoutingVpcArgs',
    'HubRoutingVpcArgsDict',
    'InternalRangeAllocationOptionsArgs',
    'InternalRangeAllocationOptionsArgsDict',
    'InternalRangeMigrationArgs',
    'InternalRangeMigrationArgsDict',
    'PolicyBasedRouteFilterArgs',
    'PolicyBasedRouteFilterArgsDict',
    'PolicyBasedRouteInterconnectAttachmentArgs',
    'PolicyBasedRouteInterconnectAttachmentArgsDict',
    'PolicyBasedRouteVirtualMachineArgs',
    'PolicyBasedRouteVirtualMachineArgsDict',
    'PolicyBasedRouteWarningArgs',
    'PolicyBasedRouteWarningArgsDict',
    'ServiceConnectionPolicyPscConfigArgs',
    'ServiceConnectionPolicyPscConfigArgsDict',
    'ServiceConnectionPolicyPscConnectionArgs',
    'ServiceConnectionPolicyPscConnectionArgsDict',
    'ServiceConnectionPolicyPscConnectionErrorArgs',
    'ServiceConnectionPolicyPscConnectionErrorArgsDict',
    'ServiceConnectionPolicyPscConnectionErrorInfoArgs',
    'ServiceConnectionPolicyPscConnectionErrorInfoArgsDict',
    'SpokeGatewayArgs',
    'SpokeGatewayArgsDict',
    'SpokeGatewayIpRangeReservationArgs',
    'SpokeGatewayIpRangeReservationArgsDict',
    'SpokeLinkedInterconnectAttachmentsArgs',
    'SpokeLinkedInterconnectAttachmentsArgsDict',
    'SpokeLinkedProducerVpcNetworkArgs',
    'SpokeLinkedProducerVpcNetworkArgsDict',
    'SpokeLinkedRouterApplianceInstancesArgs',
    'SpokeLinkedRouterApplianceInstancesArgsDict',
    'SpokeLinkedRouterApplianceInstancesInstanceArgs',
    'SpokeLinkedRouterApplianceInstancesInstanceArgsDict',
    'SpokeLinkedVpcNetworkArgs',
    'SpokeLinkedVpcNetworkArgsDict',
    'SpokeLinkedVpnTunnelsArgs',
    'SpokeLinkedVpnTunnelsArgsDict',
    'SpokeReasonArgs',
    'SpokeReasonArgsDict',
]

MYPY = False

if not MYPY:
    class GroupAutoAcceptArgsDict(TypedDict):
        auto_accept_projects: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of project ids or project numbers for which you want to enable auto-accept. The auto-accept setting is applied to spokes being created or updated in these projects.
        """
elif False:
    GroupAutoAcceptArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GroupAutoAcceptArgs:
    def __init__(__self__, *,
                 auto_accept_projects: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] auto_accept_projects: A list of project ids or project numbers for which you want to enable auto-accept. The auto-accept setting is applied to spokes being created or updated in these projects.
        """
        pulumi.set(__self__, "auto_accept_projects", auto_accept_projects)

    @_builtins.property
    @pulumi.getter(name="autoAcceptProjects")
    def auto_accept_projects(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of project ids or project numbers for which you want to enable auto-accept. The auto-accept setting is applied to spokes being created or updated in these projects.
        """
        return pulumi.get(self, "auto_accept_projects")

    @auto_accept_projects.setter
    def auto_accept_projects(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "auto_accept_projects", value)


if not MYPY:
    class HubRoutingVpcArgsDict(TypedDict):
        uri: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URI of the VPC network.
        """
elif False:
    HubRoutingVpcArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class HubRoutingVpcArgs:
    def __init__(__self__, *,
                 uri: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] uri: The URI of the VPC network.
        """
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URI of the VPC network.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class InternalRangeAllocationOptionsArgsDict(TypedDict):
        allocation_strategy: NotRequired[pulumi.Input[_builtins.str]]
        """
        Optional. Sets the strategy used to automatically find a free range of a size given by prefixLength. Can be set only when trying to create a reservation that automatically finds the free range to reserve.
        Possible values are: `RANDOM`, `FIRST_AVAILABLE`, `RANDOM_FIRST_N_AVAILABLE`, `FIRST_SMALLEST_FITTING`.
        """
        first_available_ranges_lookup_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        Must be set when allocation_strategy is RANDOM_FIRST_N_AVAILABLE, otherwise must remain unset. Defines the size of the set of free ranges from which RANDOM_FIRST_N_AVAILABLE strategy randomy selects one,
        in other words it sets the N in the RANDOM_FIRST_N_AVAILABLE.
        """
elif False:
    InternalRangeAllocationOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InternalRangeAllocationOptionsArgs:
    def __init__(__self__, *,
                 allocation_strategy: Optional[pulumi.Input[_builtins.str]] = None,
                 first_available_ranges_lookup_size: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] allocation_strategy: Optional. Sets the strategy used to automatically find a free range of a size given by prefixLength. Can be set only when trying to create a reservation that automatically finds the free range to reserve.
               Possible values are: `RANDOM`, `FIRST_AVAILABLE`, `RANDOM_FIRST_N_AVAILABLE`, `FIRST_SMALLEST_FITTING`.
        :param pulumi.Input[_builtins.int] first_available_ranges_lookup_size: Must be set when allocation_strategy is RANDOM_FIRST_N_AVAILABLE, otherwise must remain unset. Defines the size of the set of free ranges from which RANDOM_FIRST_N_AVAILABLE strategy randomy selects one,
               in other words it sets the N in the RANDOM_FIRST_N_AVAILABLE.
        """
        if allocation_strategy is not None:
            pulumi.set(__self__, "allocation_strategy", allocation_strategy)
        if first_available_ranges_lookup_size is not None:
            pulumi.set(__self__, "first_available_ranges_lookup_size", first_available_ranges_lookup_size)

    @_builtins.property
    @pulumi.getter(name="allocationStrategy")
    def allocation_strategy(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Optional. Sets the strategy used to automatically find a free range of a size given by prefixLength. Can be set only when trying to create a reservation that automatically finds the free range to reserve.
        Possible values are: `RANDOM`, `FIRST_AVAILABLE`, `RANDOM_FIRST_N_AVAILABLE`, `FIRST_SMALLEST_FITTING`.
        """
        return pulumi.get(self, "allocation_strategy")

    @allocation_strategy.setter
    def allocation_strategy(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "allocation_strategy", value)

    @_builtins.property
    @pulumi.getter(name="firstAvailableRangesLookupSize")
    def first_available_ranges_lookup_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        Must be set when allocation_strategy is RANDOM_FIRST_N_AVAILABLE, otherwise must remain unset. Defines the size of the set of free ranges from which RANDOM_FIRST_N_AVAILABLE strategy randomy selects one,
        in other words it sets the N in the RANDOM_FIRST_N_AVAILABLE.
        """
        return pulumi.get(self, "first_available_ranges_lookup_size")

    @first_available_ranges_lookup_size.setter
    def first_available_ranges_lookup_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "first_available_ranges_lookup_size", value)


if not MYPY:
    class InternalRangeMigrationArgsDict(TypedDict):
        source: pulumi.Input[_builtins.str]
        """
        Resource path as an URI of the source resource, for example a subnet.
        The project for the source resource should match the project for the
        InternalRange.
        An example /projects/{project}/regions/{region}/subnetworks/{subnet}
        """
        target: pulumi.Input[_builtins.str]
        """
        Resource path of the target resource. The target project can be
        different, as in the cases when migrating to peer networks. The resource
        may not exist yet.
        For example /projects/{project}/regions/{region}/subnetworks/{subnet}
        """
elif False:
    InternalRangeMigrationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InternalRangeMigrationArgs:
    def __init__(__self__, *,
                 source: pulumi.Input[_builtins.str],
                 target: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] source: Resource path as an URI of the source resource, for example a subnet.
               The project for the source resource should match the project for the
               InternalRange.
               An example /projects/{project}/regions/{region}/subnetworks/{subnet}
        :param pulumi.Input[_builtins.str] target: Resource path of the target resource. The target project can be
               different, as in the cases when migrating to peer networks. The resource
               may not exist yet.
               For example /projects/{project}/regions/{region}/subnetworks/{subnet}
        """
        pulumi.set(__self__, "source", source)
        pulumi.set(__self__, "target", target)

    @_builtins.property
    @pulumi.getter
    def source(self) -> pulumi.Input[_builtins.str]:
        """
        Resource path as an URI of the source resource, for example a subnet.
        The project for the source resource should match the project for the
        InternalRange.
        An example /projects/{project}/regions/{region}/subnetworks/{subnet}
        """
        return pulumi.get(self, "source")

    @source.setter
    def source(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "source", value)

    @_builtins.property
    @pulumi.getter
    def target(self) -> pulumi.Input[_builtins.str]:
        """
        Resource path of the target resource. The target project can be
        different, as in the cases when migrating to peer networks. The resource
        may not exist yet.
        For example /projects/{project}/regions/{region}/subnetworks/{subnet}
        """
        return pulumi.get(self, "target")

    @target.setter
    def target(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target", value)


if not MYPY:
    class PolicyBasedRouteFilterArgsDict(TypedDict):
        protocol_version: pulumi.Input[_builtins.str]
        """
        Internet protocol versions this policy-based route applies to.
        Possible values are: `IPV4`, `IPV6`.
        """
        dest_range: NotRequired[pulumi.Input[_builtins.str]]
        """
        The destination IP range of outgoing packets that this policy-based route applies to. Default is "0.0.0.0/0".
        """
        ip_protocol: NotRequired[pulumi.Input[_builtins.str]]
        """
        The IP protocol that this policy-based route applies to. Valid values are 'TCP', 'UDP', and 'ALL'. Default is 'ALL'.
        """
        src_range: NotRequired[pulumi.Input[_builtins.str]]
        """
        The source IP range of outgoing packets that this policy-based route applies to. Default is "0.0.0.0/0".
        """
elif False:
    PolicyBasedRouteFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyBasedRouteFilterArgs:
    def __init__(__self__, *,
                 protocol_version: pulumi.Input[_builtins.str],
                 dest_range: Optional[pulumi.Input[_builtins.str]] = None,
                 ip_protocol: Optional[pulumi.Input[_builtins.str]] = None,
                 src_range: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] protocol_version: Internet protocol versions this policy-based route applies to.
               Possible values are: `IPV4`, `IPV6`.
        :param pulumi.Input[_builtins.str] dest_range: The destination IP range of outgoing packets that this policy-based route applies to. Default is "0.0.0.0/0".
        :param pulumi.Input[_builtins.str] ip_protocol: The IP protocol that this policy-based route applies to. Valid values are 'TCP', 'UDP', and 'ALL'. Default is 'ALL'.
        :param pulumi.Input[_builtins.str] src_range: The source IP range of outgoing packets that this policy-based route applies to. Default is "0.0.0.0/0".
        """
        pulumi.set(__self__, "protocol_version", protocol_version)
        if dest_range is not None:
            pulumi.set(__self__, "dest_range", dest_range)
        if ip_protocol is not None:
            pulumi.set(__self__, "ip_protocol", ip_protocol)
        if src_range is not None:
            pulumi.set(__self__, "src_range", src_range)

    @_builtins.property
    @pulumi.getter(name="protocolVersion")
    def protocol_version(self) -> pulumi.Input[_builtins.str]:
        """
        Internet protocol versions this policy-based route applies to.
        Possible values are: `IPV4`, `IPV6`.
        """
        return pulumi.get(self, "protocol_version")

    @protocol_version.setter
    def protocol_version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "protocol_version", value)

    @_builtins.property
    @pulumi.getter(name="destRange")
    def dest_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The destination IP range of outgoing packets that this policy-based route applies to. Default is "0.0.0.0/0".
        """
        return pulumi.get(self, "dest_range")

    @dest_range.setter
    def dest_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dest_range", value)

    @_builtins.property
    @pulumi.getter(name="ipProtocol")
    def ip_protocol(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The IP protocol that this policy-based route applies to. Valid values are 'TCP', 'UDP', and 'ALL'. Default is 'ALL'.
        """
        return pulumi.get(self, "ip_protocol")

    @ip_protocol.setter
    def ip_protocol(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "ip_protocol", value)

    @_builtins.property
    @pulumi.getter(name="srcRange")
    def src_range(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The source IP range of outgoing packets that this policy-based route applies to. Default is "0.0.0.0/0".
        """
        return pulumi.get(self, "src_range")

    @src_range.setter
    def src_range(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "src_range", value)


if not MYPY:
    class PolicyBasedRouteInterconnectAttachmentArgsDict(TypedDict):
        region: pulumi.Input[_builtins.str]
        """
        Cloud region to install this policy-based route on for Interconnect attachments. Use `all` to install it on all Interconnect attachments.
        """
elif False:
    PolicyBasedRouteInterconnectAttachmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyBasedRouteInterconnectAttachmentArgs:
    def __init__(__self__, *,
                 region: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] region: Cloud region to install this policy-based route on for Interconnect attachments. Use `all` to install it on all Interconnect attachments.
        """
        pulumi.set(__self__, "region", region)

    @_builtins.property
    @pulumi.getter
    def region(self) -> pulumi.Input[_builtins.str]:
        """
        Cloud region to install this policy-based route on for Interconnect attachments. Use `all` to install it on all Interconnect attachments.
        """
        return pulumi.get(self, "region")

    @region.setter
    def region(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "region", value)


if not MYPY:
    class PolicyBasedRouteVirtualMachineArgsDict(TypedDict):
        tags: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        A list of VM instance tags that this policy-based route applies to. VM instances that have ANY of tags specified here will install this PBR.
        """
elif False:
    PolicyBasedRouteVirtualMachineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyBasedRouteVirtualMachineArgs:
    def __init__(__self__, *,
                 tags: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] tags: A list of VM instance tags that this policy-based route applies to. VM instances that have ANY of tags specified here will install this PBR.
        """
        pulumi.set(__self__, "tags", tags)

    @_builtins.property
    @pulumi.getter
    def tags(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        A list of VM instance tags that this policy-based route applies to. VM instances that have ANY of tags specified here will install this PBR.
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "tags", value)


if not MYPY:
    class PolicyBasedRouteWarningArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        A warning code, if applicable.
        """
        data: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        (Output)
        Metadata about this warning in key: value format. The key should provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement.
        """
        warning_message: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        A human-readable description of the warning code.
        """
elif False:
    PolicyBasedRouteWarningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PolicyBasedRouteWarningArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.str]] = None,
                 data: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 warning_message: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] code: (Output)
               A warning code, if applicable.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] data: (Output)
               Metadata about this warning in key: value format. The key should provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement.
        :param pulumi.Input[_builtins.str] warning_message: (Output)
               A human-readable description of the warning code.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if data is not None:
            pulumi.set(__self__, "data", data)
        if warning_message is not None:
            pulumi.set(__self__, "warning_message", warning_message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        A warning code, if applicable.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def data(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        Metadata about this warning in key: value format. The key should provides more detail on the warning being returned. For example, for warnings where there are no results in a list request for a particular zone, this key might be scope and the key value might be the zone name. Other examples might be a key indicating a deprecated resource and a suggested replacement.
        """
        return pulumi.get(self, "data")

    @data.setter
    def data(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "data", value)

    @_builtins.property
    @pulumi.getter(name="warningMessage")
    def warning_message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        A human-readable description of the warning code.
        """
        return pulumi.get(self, "warning_message")

    @warning_message.setter
    def warning_message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "warning_message", value)


if not MYPY:
    class ServiceConnectionPolicyPscConfigArgsDict(TypedDict):
        subnetworks: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        IDs of the subnetworks or fully qualified identifiers for the subnetworks
        """
        allowed_google_producers_resource_hierarchy_levels: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of Projects, Folders, or Organizations from where the Producer instance can be within. For example,
        a network administrator can provide both 'organizations/foo' and 'projects/bar' as
        allowed_google_producers_resource_hierarchy_levels. This allowlists this network to connect with any Producer
        instance within the 'foo' organization or the 'bar' project. By default,
        allowedGoogleProducersResourceHierarchyLevel is empty. The format for each
        allowedGoogleProducersResourceHierarchyLevel is / where is one of 'projects', 'folders', or 'organizations'
        and is either the ID or the number of the resource type. Format for each
        allowedGoogleProducersResourceHierarchyLevel value: 'projects/' or 'folders/' or 'organizations/' Eg.
        [projects/my-project-id, projects/567, folders/891, organizations/123]
        """
        limit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Max number of PSC connections for this policy.
        """
        producer_instance_location: NotRequired[pulumi.Input[_builtins.str]]
        """
        ProducerInstanceLocation is used to specify which authorization mechanism to use to determine which projects
        the Producer instance can be within.
        Possible values are: `PRODUCER_INSTANCE_LOCATION_UNSPECIFIED`, `CUSTOM_RESOURCE_HIERARCHY_LEVELS`.
        """
elif False:
    ServiceConnectionPolicyPscConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceConnectionPolicyPscConfigArgs:
    def __init__(__self__, *,
                 subnetworks: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 allowed_google_producers_resource_hierarchy_levels: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 limit: Optional[pulumi.Input[_builtins.str]] = None,
                 producer_instance_location: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subnetworks: IDs of the subnetworks or fully qualified identifiers for the subnetworks
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] allowed_google_producers_resource_hierarchy_levels: List of Projects, Folders, or Organizations from where the Producer instance can be within. For example,
               a network administrator can provide both 'organizations/foo' and 'projects/bar' as
               allowed_google_producers_resource_hierarchy_levels. This allowlists this network to connect with any Producer
               instance within the 'foo' organization or the 'bar' project. By default,
               allowedGoogleProducersResourceHierarchyLevel is empty. The format for each
               allowedGoogleProducersResourceHierarchyLevel is / where is one of 'projects', 'folders', or 'organizations'
               and is either the ID or the number of the resource type. Format for each
               allowedGoogleProducersResourceHierarchyLevel value: 'projects/' or 'folders/' or 'organizations/' Eg.
               [projects/my-project-id, projects/567, folders/891, organizations/123]
        :param pulumi.Input[_builtins.str] limit: Max number of PSC connections for this policy.
        :param pulumi.Input[_builtins.str] producer_instance_location: ProducerInstanceLocation is used to specify which authorization mechanism to use to determine which projects
               the Producer instance can be within.
               Possible values are: `PRODUCER_INSTANCE_LOCATION_UNSPECIFIED`, `CUSTOM_RESOURCE_HIERARCHY_LEVELS`.
        """
        pulumi.set(__self__, "subnetworks", subnetworks)
        if allowed_google_producers_resource_hierarchy_levels is not None:
            pulumi.set(__self__, "allowed_google_producers_resource_hierarchy_levels", allowed_google_producers_resource_hierarchy_levels)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if producer_instance_location is not None:
            pulumi.set(__self__, "producer_instance_location", producer_instance_location)

    @_builtins.property
    @pulumi.getter
    def subnetworks(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        IDs of the subnetworks or fully qualified identifiers for the subnetworks
        """
        return pulumi.get(self, "subnetworks")

    @subnetworks.setter
    def subnetworks(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subnetworks", value)

    @_builtins.property
    @pulumi.getter(name="allowedGoogleProducersResourceHierarchyLevels")
    def allowed_google_producers_resource_hierarchy_levels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of Projects, Folders, or Organizations from where the Producer instance can be within. For example,
        a network administrator can provide both 'organizations/foo' and 'projects/bar' as
        allowed_google_producers_resource_hierarchy_levels. This allowlists this network to connect with any Producer
        instance within the 'foo' organization or the 'bar' project. By default,
        allowedGoogleProducersResourceHierarchyLevel is empty. The format for each
        allowedGoogleProducersResourceHierarchyLevel is / where is one of 'projects', 'folders', or 'organizations'
        and is either the ID or the number of the resource type. Format for each
        allowedGoogleProducersResourceHierarchyLevel value: 'projects/' or 'folders/' or 'organizations/' Eg.
        [projects/my-project-id, projects/567, folders/891, organizations/123]
        """
        return pulumi.get(self, "allowed_google_producers_resource_hierarchy_levels")

    @allowed_google_producers_resource_hierarchy_levels.setter
    def allowed_google_producers_resource_hierarchy_levels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "allowed_google_producers_resource_hierarchy_levels", value)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Max number of PSC connections for this policy.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter(name="producerInstanceLocation")
    def producer_instance_location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        ProducerInstanceLocation is used to specify which authorization mechanism to use to determine which projects
        the Producer instance can be within.
        Possible values are: `PRODUCER_INSTANCE_LOCATION_UNSPECIFIED`, `CUSTOM_RESOURCE_HIERARCHY_LEVELS`.
        """
        return pulumi.get(self, "producer_instance_location")

    @producer_instance_location.setter
    def producer_instance_location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "producer_instance_location", value)


if not MYPY:
    class ServiceConnectionPolicyPscConnectionArgsDict(TypedDict):
        consumer_address: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource reference of the consumer address.
        """
        consumer_forwarding_rule: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource reference of the PSC Forwarding Rule within the consumer VPC.
        """
        consumer_target_project: NotRequired[pulumi.Input[_builtins.str]]
        """
        The project where the PSC connection is created.
        """
        error: NotRequired[pulumi.Input['ServiceConnectionPolicyPscConnectionErrorArgsDict']]
        """
        The most recent error during operating this connection.
        Structure is documented below.
        """
        error_info: NotRequired[pulumi.Input['ServiceConnectionPolicyPscConnectionErrorInfoArgsDict']]
        """
        The error info for the latest error during operating this connection.
        Structure is documented below.
        """
        error_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The error type indicates whether the error is consumer facing, producer
        facing or system internal.
        Possible values are: `CONNECTION_ERROR_TYPE_UNSPECIFIED`, `ERROR_INTERNAL`, `ERROR_CONSUMER_SIDE`, `ERROR_PRODUCER_SIDE`.
        """
        gce_operation: NotRequired[pulumi.Input[_builtins.str]]
        """
        The last Compute Engine operation to setup PSC connection.
        """
        psc_connection_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        The PSC connection id of the PSC forwarding rule.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The state of the PSC connection.
        Possible values are: `STATE_UNSPECIFIED`, `ACTIVE`, `CREATING`, `DELETING`, `FAILED`.
        """
elif False:
    ServiceConnectionPolicyPscConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceConnectionPolicyPscConnectionArgs:
    def __init__(__self__, *,
                 consumer_address: Optional[pulumi.Input[_builtins.str]] = None,
                 consumer_forwarding_rule: Optional[pulumi.Input[_builtins.str]] = None,
                 consumer_target_project: Optional[pulumi.Input[_builtins.str]] = None,
                 error: Optional[pulumi.Input['ServiceConnectionPolicyPscConnectionErrorArgs']] = None,
                 error_info: Optional[pulumi.Input['ServiceConnectionPolicyPscConnectionErrorInfoArgs']] = None,
                 error_type: Optional[pulumi.Input[_builtins.str]] = None,
                 gce_operation: Optional[pulumi.Input[_builtins.str]] = None,
                 psc_connection_id: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] consumer_address: The resource reference of the consumer address.
        :param pulumi.Input[_builtins.str] consumer_forwarding_rule: The resource reference of the PSC Forwarding Rule within the consumer VPC.
        :param pulumi.Input[_builtins.str] consumer_target_project: The project where the PSC connection is created.
        :param pulumi.Input['ServiceConnectionPolicyPscConnectionErrorArgs'] error: The most recent error during operating this connection.
               Structure is documented below.
        :param pulumi.Input['ServiceConnectionPolicyPscConnectionErrorInfoArgs'] error_info: The error info for the latest error during operating this connection.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] error_type: The error type indicates whether the error is consumer facing, producer
               facing or system internal.
               Possible values are: `CONNECTION_ERROR_TYPE_UNSPECIFIED`, `ERROR_INTERNAL`, `ERROR_CONSUMER_SIDE`, `ERROR_PRODUCER_SIDE`.
        :param pulumi.Input[_builtins.str] gce_operation: The last Compute Engine operation to setup PSC connection.
        :param pulumi.Input[_builtins.str] psc_connection_id: The PSC connection id of the PSC forwarding rule.
        :param pulumi.Input[_builtins.str] state: The state of the PSC connection.
               Possible values are: `STATE_UNSPECIFIED`, `ACTIVE`, `CREATING`, `DELETING`, `FAILED`.
        """
        if consumer_address is not None:
            pulumi.set(__self__, "consumer_address", consumer_address)
        if consumer_forwarding_rule is not None:
            pulumi.set(__self__, "consumer_forwarding_rule", consumer_forwarding_rule)
        if consumer_target_project is not None:
            pulumi.set(__self__, "consumer_target_project", consumer_target_project)
        if error is not None:
            pulumi.set(__self__, "error", error)
        if error_info is not None:
            pulumi.set(__self__, "error_info", error_info)
        if error_type is not None:
            pulumi.set(__self__, "error_type", error_type)
        if gce_operation is not None:
            pulumi.set(__self__, "gce_operation", gce_operation)
        if psc_connection_id is not None:
            pulumi.set(__self__, "psc_connection_id", psc_connection_id)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="consumerAddress")
    def consumer_address(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource reference of the consumer address.
        """
        return pulumi.get(self, "consumer_address")

    @consumer_address.setter
    def consumer_address(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_address", value)

    @_builtins.property
    @pulumi.getter(name="consumerForwardingRule")
    def consumer_forwarding_rule(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource reference of the PSC Forwarding Rule within the consumer VPC.
        """
        return pulumi.get(self, "consumer_forwarding_rule")

    @consumer_forwarding_rule.setter
    def consumer_forwarding_rule(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_forwarding_rule", value)

    @_builtins.property
    @pulumi.getter(name="consumerTargetProject")
    def consumer_target_project(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The project where the PSC connection is created.
        """
        return pulumi.get(self, "consumer_target_project")

    @consumer_target_project.setter
    def consumer_target_project(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_target_project", value)

    @_builtins.property
    @pulumi.getter
    def error(self) -> Optional[pulumi.Input['ServiceConnectionPolicyPscConnectionErrorArgs']]:
        """
        The most recent error during operating this connection.
        Structure is documented below.
        """
        return pulumi.get(self, "error")

    @error.setter
    def error(self, value: Optional[pulumi.Input['ServiceConnectionPolicyPscConnectionErrorArgs']]):
        pulumi.set(self, "error", value)

    @_builtins.property
    @pulumi.getter(name="errorInfo")
    def error_info(self) -> Optional[pulumi.Input['ServiceConnectionPolicyPscConnectionErrorInfoArgs']]:
        """
        The error info for the latest error during operating this connection.
        Structure is documented below.
        """
        return pulumi.get(self, "error_info")

    @error_info.setter
    def error_info(self, value: Optional[pulumi.Input['ServiceConnectionPolicyPscConnectionErrorInfoArgs']]):
        pulumi.set(self, "error_info", value)

    @_builtins.property
    @pulumi.getter(name="errorType")
    def error_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The error type indicates whether the error is consumer facing, producer
        facing or system internal.
        Possible values are: `CONNECTION_ERROR_TYPE_UNSPECIFIED`, `ERROR_INTERNAL`, `ERROR_CONSUMER_SIDE`, `ERROR_PRODUCER_SIDE`.
        """
        return pulumi.get(self, "error_type")

    @error_type.setter
    def error_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "error_type", value)

    @_builtins.property
    @pulumi.getter(name="gceOperation")
    def gce_operation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The last Compute Engine operation to setup PSC connection.
        """
        return pulumi.get(self, "gce_operation")

    @gce_operation.setter
    def gce_operation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "gce_operation", value)

    @_builtins.property
    @pulumi.getter(name="pscConnectionId")
    def psc_connection_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The PSC connection id of the PSC forwarding rule.
        """
        return pulumi.get(self, "psc_connection_id")

    @psc_connection_id.setter
    def psc_connection_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "psc_connection_id", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The state of the PSC connection.
        Possible values are: `STATE_UNSPECIFIED`, `ACTIVE`, `CREATING`, `DELETING`, `FAILED`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class ServiceConnectionPolicyPscConnectionErrorArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.int]]
        """
        The status code, which should be an enum value of [google.rpc.Code][].
        """
        details: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]
        """
        (Output)
        A list of messages that carry the error details.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        A developer-facing error message.
        """
elif False:
    ServiceConnectionPolicyPscConnectionErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceConnectionPolicyPscConnectionErrorArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.int]] = None,
                 details: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.int] code: The status code, which should be an enum value of [google.rpc.Code][].
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]] details: (Output)
               A list of messages that carry the error details.
        :param pulumi.Input[_builtins.str] message: A developer-facing error message.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The status code, which should be an enum value of [google.rpc.Code][].
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]:
        """
        (Output)
        A list of messages that carry the error details.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]]]):
        pulumi.set(self, "details", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A developer-facing error message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class ServiceConnectionPolicyPscConnectionErrorInfoArgsDict(TypedDict):
        domain: NotRequired[pulumi.Input[_builtins.str]]
        """
        The logical grouping to which the "reason" belongs.
        """
        metadata: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]
        """
        Additional structured details about this error.
        """
        reason: NotRequired[pulumi.Input[_builtins.str]]
        """
        The reason of the error.
        """
elif False:
    ServiceConnectionPolicyPscConnectionErrorInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ServiceConnectionPolicyPscConnectionErrorInfoArgs:
    def __init__(__self__, *,
                 domain: Optional[pulumi.Input[_builtins.str]] = None,
                 metadata: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]] = None,
                 reason: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] domain: The logical grouping to which the "reason" belongs.
        :param pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]] metadata: Additional structured details about this error.
        :param pulumi.Input[_builtins.str] reason: The reason of the error.
        """
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if metadata is not None:
            pulumi.set(__self__, "metadata", metadata)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The logical grouping to which the "reason" belongs.
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "domain", value)

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]:
        """
        Additional structured details about this error.
        """
        return pulumi.get(self, "metadata")

    @metadata.setter
    def metadata(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "metadata", value)

    @_builtins.property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The reason of the error.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "reason", value)


if not MYPY:
    class SpokeGatewayArgsDict(TypedDict):
        capacity: pulumi.Input[_builtins.str]
        """
        the capacity of the gateway spoke, in Gbps.
        Possible values are: `CAPACITY_1_GBPS`, `CAPACITY_10_GBPS`, `CAPACITY_100_GBPS`.
        """
        ip_range_reservations: pulumi.Input[Sequence[pulumi.Input['SpokeGatewayIpRangeReservationArgsDict']]]
        """
        A list of IP ranges that are reserved for this gateway's internal infrastructure.
        Structure is documented below.
        """
        routers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output, Beta)
        Set of Cloud Routers that are attached to this NCC-GW
        """
elif False:
    SpokeGatewayArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpokeGatewayArgs:
    def __init__(__self__, *,
                 capacity: pulumi.Input[_builtins.str],
                 ip_range_reservations: pulumi.Input[Sequence[pulumi.Input['SpokeGatewayIpRangeReservationArgs']]],
                 routers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] capacity: the capacity of the gateway spoke, in Gbps.
               Possible values are: `CAPACITY_1_GBPS`, `CAPACITY_10_GBPS`, `CAPACITY_100_GBPS`.
        :param pulumi.Input[Sequence[pulumi.Input['SpokeGatewayIpRangeReservationArgs']]] ip_range_reservations: A list of IP ranges that are reserved for this gateway's internal infrastructure.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] routers: (Output, Beta)
               Set of Cloud Routers that are attached to this NCC-GW
        """
        pulumi.set(__self__, "capacity", capacity)
        pulumi.set(__self__, "ip_range_reservations", ip_range_reservations)
        if routers is not None:
            pulumi.set(__self__, "routers", routers)

    @_builtins.property
    @pulumi.getter
    def capacity(self) -> pulumi.Input[_builtins.str]:
        """
        the capacity of the gateway spoke, in Gbps.
        Possible values are: `CAPACITY_1_GBPS`, `CAPACITY_10_GBPS`, `CAPACITY_100_GBPS`.
        """
        return pulumi.get(self, "capacity")

    @capacity.setter
    def capacity(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "capacity", value)

    @_builtins.property
    @pulumi.getter(name="ipRangeReservations")
    def ip_range_reservations(self) -> pulumi.Input[Sequence[pulumi.Input['SpokeGatewayIpRangeReservationArgs']]]:
        """
        A list of IP ranges that are reserved for this gateway's internal infrastructure.
        Structure is documented below.
        """
        return pulumi.get(self, "ip_range_reservations")

    @ip_range_reservations.setter
    def ip_range_reservations(self, value: pulumi.Input[Sequence[pulumi.Input['SpokeGatewayIpRangeReservationArgs']]]):
        pulumi.set(self, "ip_range_reservations", value)

    @_builtins.property
    @pulumi.getter
    def routers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output, Beta)
        Set of Cloud Routers that are attached to this NCC-GW
        """
        return pulumi.get(self, "routers")

    @routers.setter
    def routers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "routers", value)


if not MYPY:
    class SpokeGatewayIpRangeReservationArgsDict(TypedDict):
        ip_range: pulumi.Input[_builtins.str]
        """
        A block of IP address ranges used to allocate supporting infrastructure for this gateway—for example, 10.1.2.0/23. The IP address block must be a /23 range. This IP address block must not overlap with subnets in any spoke or peer network that the gateway can communicate with.
        """
elif False:
    SpokeGatewayIpRangeReservationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpokeGatewayIpRangeReservationArgs:
    def __init__(__self__, *,
                 ip_range: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip_range: A block of IP address ranges used to allocate supporting infrastructure for this gateway—for example, 10.1.2.0/23. The IP address block must be a /23 range. This IP address block must not overlap with subnets in any spoke or peer network that the gateway can communicate with.
        """
        pulumi.set(__self__, "ip_range", ip_range)

    @_builtins.property
    @pulumi.getter(name="ipRange")
    def ip_range(self) -> pulumi.Input[_builtins.str]:
        """
        A block of IP address ranges used to allocate supporting infrastructure for this gateway—for example, 10.1.2.0/23. The IP address block must be a /23 range. This IP address block must not overlap with subnets in any spoke or peer network that the gateway can communicate with.
        """
        return pulumi.get(self, "ip_range")

    @ip_range.setter
    def ip_range(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_range", value)


if not MYPY:
    class SpokeLinkedInterconnectAttachmentsArgsDict(TypedDict):
        site_to_site_data_transfer: pulumi.Input[_builtins.bool]
        """
        A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
        """
        uris: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The URIs of linked interconnect attachment resources
        """
        include_import_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IP ranges allowed to be included during import from hub (does not control transit connectivity).
        The only allowed value for now is "ALL_IPV4_RANGES".
        """
elif False:
    SpokeLinkedInterconnectAttachmentsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpokeLinkedInterconnectAttachmentsArgs:
    def __init__(__self__, *,
                 site_to_site_data_transfer: pulumi.Input[_builtins.bool],
                 uris: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 include_import_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] site_to_site_data_transfer: A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] uris: The URIs of linked interconnect attachment resources
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_import_ranges: IP ranges allowed to be included during import from hub (does not control transit connectivity).
               The only allowed value for now is "ALL_IPV4_RANGES".
        """
        pulumi.set(__self__, "site_to_site_data_transfer", site_to_site_data_transfer)
        pulumi.set(__self__, "uris", uris)
        if include_import_ranges is not None:
            pulumi.set(__self__, "include_import_ranges", include_import_ranges)

    @_builtins.property
    @pulumi.getter(name="siteToSiteDataTransfer")
    def site_to_site_data_transfer(self) -> pulumi.Input[_builtins.bool]:
        """
        A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
        """
        return pulumi.get(self, "site_to_site_data_transfer")

    @site_to_site_data_transfer.setter
    def site_to_site_data_transfer(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "site_to_site_data_transfer", value)

    @_builtins.property
    @pulumi.getter
    def uris(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The URIs of linked interconnect attachment resources
        """
        return pulumi.get(self, "uris")

    @uris.setter
    def uris(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "uris", value)

    @_builtins.property
    @pulumi.getter(name="includeImportRanges")
    def include_import_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IP ranges allowed to be included during import from hub (does not control transit connectivity).
        The only allowed value for now is "ALL_IPV4_RANGES".
        """
        return pulumi.get(self, "include_import_ranges")

    @include_import_ranges.setter
    def include_import_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_import_ranges", value)


if not MYPY:
    class SpokeLinkedProducerVpcNetworkArgsDict(TypedDict):
        network: pulumi.Input[_builtins.str]
        """
        The URI of the Service Consumer VPC that the Producer VPC is peered with.
        """
        peering: pulumi.Input[_builtins.str]
        """
        The name of the VPC peering between the Service Consumer VPC and the Producer VPC (defined in the Tenant project) which is added to the NCC hub. This peering must be in ACTIVE state.
        """
        exclude_export_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IP ranges encompassing the subnets to be excluded from peering.
        """
        include_export_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IP ranges allowed to be included from peering.
        """
        producer_network: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The URI of the Producer VPC.
        """
elif False:
    SpokeLinkedProducerVpcNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpokeLinkedProducerVpcNetworkArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[_builtins.str],
                 peering: pulumi.Input[_builtins.str],
                 exclude_export_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_export_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 producer_network: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] network: The URI of the Service Consumer VPC that the Producer VPC is peered with.
        :param pulumi.Input[_builtins.str] peering: The name of the VPC peering between the Service Consumer VPC and the Producer VPC (defined in the Tenant project) which is added to the NCC hub. This peering must be in ACTIVE state.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_export_ranges: IP ranges encompassing the subnets to be excluded from peering.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_export_ranges: IP ranges allowed to be included from peering.
        :param pulumi.Input[_builtins.str] producer_network: (Output)
               The URI of the Producer VPC.
        """
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "peering", peering)
        if exclude_export_ranges is not None:
            pulumi.set(__self__, "exclude_export_ranges", exclude_export_ranges)
        if include_export_ranges is not None:
            pulumi.set(__self__, "include_export_ranges", include_export_ranges)
        if producer_network is not None:
            pulumi.set(__self__, "producer_network", producer_network)

    @_builtins.property
    @pulumi.getter
    def network(self) -> pulumi.Input[_builtins.str]:
        """
        The URI of the Service Consumer VPC that the Producer VPC is peered with.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "network", value)

    @_builtins.property
    @pulumi.getter
    def peering(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the VPC peering between the Service Consumer VPC and the Producer VPC (defined in the Tenant project) which is added to the NCC hub. This peering must be in ACTIVE state.
        """
        return pulumi.get(self, "peering")

    @peering.setter
    def peering(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "peering", value)

    @_builtins.property
    @pulumi.getter(name="excludeExportRanges")
    def exclude_export_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IP ranges encompassing the subnets to be excluded from peering.
        """
        return pulumi.get(self, "exclude_export_ranges")

    @exclude_export_ranges.setter
    def exclude_export_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_export_ranges", value)

    @_builtins.property
    @pulumi.getter(name="includeExportRanges")
    def include_export_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IP ranges allowed to be included from peering.
        """
        return pulumi.get(self, "include_export_ranges")

    @include_export_ranges.setter
    def include_export_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_export_ranges", value)

    @_builtins.property
    @pulumi.getter(name="producerNetwork")
    def producer_network(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The URI of the Producer VPC.
        """
        return pulumi.get(self, "producer_network")

    @producer_network.setter
    def producer_network(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "producer_network", value)


if not MYPY:
    class SpokeLinkedRouterApplianceInstancesArgsDict(TypedDict):
        instances: pulumi.Input[Sequence[pulumi.Input['SpokeLinkedRouterApplianceInstancesInstanceArgsDict']]]
        """
        The list of router appliance instances
        Structure is documented below.
        """
        site_to_site_data_transfer: pulumi.Input[_builtins.bool]
        """
        A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
        """
        include_import_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IP ranges allowed to be included during import from hub (does not control transit connectivity).
        The only allowed value for now is "ALL_IPV4_RANGES".
        """
elif False:
    SpokeLinkedRouterApplianceInstancesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpokeLinkedRouterApplianceInstancesArgs:
    def __init__(__self__, *,
                 instances: pulumi.Input[Sequence[pulumi.Input['SpokeLinkedRouterApplianceInstancesInstanceArgs']]],
                 site_to_site_data_transfer: pulumi.Input[_builtins.bool],
                 include_import_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SpokeLinkedRouterApplianceInstancesInstanceArgs']]] instances: The list of router appliance instances
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] site_to_site_data_transfer: A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_import_ranges: IP ranges allowed to be included during import from hub (does not control transit connectivity).
               The only allowed value for now is "ALL_IPV4_RANGES".
        """
        pulumi.set(__self__, "instances", instances)
        pulumi.set(__self__, "site_to_site_data_transfer", site_to_site_data_transfer)
        if include_import_ranges is not None:
            pulumi.set(__self__, "include_import_ranges", include_import_ranges)

    @_builtins.property
    @pulumi.getter
    def instances(self) -> pulumi.Input[Sequence[pulumi.Input['SpokeLinkedRouterApplianceInstancesInstanceArgs']]]:
        """
        The list of router appliance instances
        Structure is documented below.
        """
        return pulumi.get(self, "instances")

    @instances.setter
    def instances(self, value: pulumi.Input[Sequence[pulumi.Input['SpokeLinkedRouterApplianceInstancesInstanceArgs']]]):
        pulumi.set(self, "instances", value)

    @_builtins.property
    @pulumi.getter(name="siteToSiteDataTransfer")
    def site_to_site_data_transfer(self) -> pulumi.Input[_builtins.bool]:
        """
        A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
        """
        return pulumi.get(self, "site_to_site_data_transfer")

    @site_to_site_data_transfer.setter
    def site_to_site_data_transfer(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "site_to_site_data_transfer", value)

    @_builtins.property
    @pulumi.getter(name="includeImportRanges")
    def include_import_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IP ranges allowed to be included during import from hub (does not control transit connectivity).
        The only allowed value for now is "ALL_IPV4_RANGES".
        """
        return pulumi.get(self, "include_import_ranges")

    @include_import_ranges.setter
    def include_import_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_import_ranges", value)


if not MYPY:
    class SpokeLinkedRouterApplianceInstancesInstanceArgsDict(TypedDict):
        ip_address: pulumi.Input[_builtins.str]
        """
        The IP address on the VM to use for peering.
        """
        virtual_machine: pulumi.Input[_builtins.str]
        """
        The URI of the virtual machine resource
        """
elif False:
    SpokeLinkedRouterApplianceInstancesInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpokeLinkedRouterApplianceInstancesInstanceArgs:
    def __init__(__self__, *,
                 ip_address: pulumi.Input[_builtins.str],
                 virtual_machine: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] ip_address: The IP address on the VM to use for peering.
        :param pulumi.Input[_builtins.str] virtual_machine: The URI of the virtual machine resource
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "virtual_machine", virtual_machine)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input[_builtins.str]:
        """
        The IP address on the VM to use for peering.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_address", value)

    @_builtins.property
    @pulumi.getter(name="virtualMachine")
    def virtual_machine(self) -> pulumi.Input[_builtins.str]:
        """
        The URI of the virtual machine resource
        """
        return pulumi.get(self, "virtual_machine")

    @virtual_machine.setter
    def virtual_machine(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "virtual_machine", value)


if not MYPY:
    class SpokeLinkedVpcNetworkArgsDict(TypedDict):
        uri: pulumi.Input[_builtins.str]
        """
        The URI of the VPC network resource.
        """
        exclude_export_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IP ranges encompassing the subnets to be excluded from peering.
        """
        include_export_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IP ranges allowed to be included from peering.
        """
elif False:
    SpokeLinkedVpcNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpokeLinkedVpcNetworkArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[_builtins.str],
                 exclude_export_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 include_export_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] uri: The URI of the VPC network resource.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_export_ranges: IP ranges encompassing the subnets to be excluded from peering.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_export_ranges: IP ranges allowed to be included from peering.
        """
        pulumi.set(__self__, "uri", uri)
        if exclude_export_ranges is not None:
            pulumi.set(__self__, "exclude_export_ranges", exclude_export_ranges)
        if include_export_ranges is not None:
            pulumi.set(__self__, "include_export_ranges", include_export_ranges)

    @_builtins.property
    @pulumi.getter
    def uri(self) -> pulumi.Input[_builtins.str]:
        """
        The URI of the VPC network resource.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "uri", value)

    @_builtins.property
    @pulumi.getter(name="excludeExportRanges")
    def exclude_export_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IP ranges encompassing the subnets to be excluded from peering.
        """
        return pulumi.get(self, "exclude_export_ranges")

    @exclude_export_ranges.setter
    def exclude_export_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_export_ranges", value)

    @_builtins.property
    @pulumi.getter(name="includeExportRanges")
    def include_export_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IP ranges allowed to be included from peering.
        """
        return pulumi.get(self, "include_export_ranges")

    @include_export_ranges.setter
    def include_export_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_export_ranges", value)


if not MYPY:
    class SpokeLinkedVpnTunnelsArgsDict(TypedDict):
        site_to_site_data_transfer: pulumi.Input[_builtins.bool]
        """
        A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
        """
        uris: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        The URIs of linked VPN tunnel resources.
        """
        include_import_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        IP ranges allowed to be included during import from hub (does not control transit connectivity).
        The only allowed value for now is "ALL_IPV4_RANGES".
        """
elif False:
    SpokeLinkedVpnTunnelsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpokeLinkedVpnTunnelsArgs:
    def __init__(__self__, *,
                 site_to_site_data_transfer: pulumi.Input[_builtins.bool],
                 uris: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 include_import_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] site_to_site_data_transfer: A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] uris: The URIs of linked VPN tunnel resources.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] include_import_ranges: IP ranges allowed to be included during import from hub (does not control transit connectivity).
               The only allowed value for now is "ALL_IPV4_RANGES".
        """
        pulumi.set(__self__, "site_to_site_data_transfer", site_to_site_data_transfer)
        pulumi.set(__self__, "uris", uris)
        if include_import_ranges is not None:
            pulumi.set(__self__, "include_import_ranges", include_import_ranges)

    @_builtins.property
    @pulumi.getter(name="siteToSiteDataTransfer")
    def site_to_site_data_transfer(self) -> pulumi.Input[_builtins.bool]:
        """
        A value that controls whether site-to-site data transfer is enabled for these resources. Note that data transfer is available only in supported locations.
        """
        return pulumi.get(self, "site_to_site_data_transfer")

    @site_to_site_data_transfer.setter
    def site_to_site_data_transfer(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "site_to_site_data_transfer", value)

    @_builtins.property
    @pulumi.getter
    def uris(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        The URIs of linked VPN tunnel resources.
        """
        return pulumi.get(self, "uris")

    @uris.setter
    def uris(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "uris", value)

    @_builtins.property
    @pulumi.getter(name="includeImportRanges")
    def include_import_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        IP ranges allowed to be included during import from hub (does not control transit connectivity).
        The only allowed value for now is "ALL_IPV4_RANGES".
        """
        return pulumi.get(self, "include_import_ranges")

    @include_import_ranges.setter
    def include_import_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "include_import_ranges", value)


if not MYPY:
    class SpokeReasonArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[_builtins.str]]
        """
        The code associated with this reason.
        """
        message: NotRequired[pulumi.Input[_builtins.str]]
        """
        Human-readable details about this reason.
        """
        user_details: NotRequired[pulumi.Input[_builtins.str]]
        """
        Additional information provided by the user in the RejectSpoke call.
        """
elif False:
    SpokeReasonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SpokeReasonArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[_builtins.str]] = None,
                 message: Optional[pulumi.Input[_builtins.str]] = None,
                 user_details: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] code: The code associated with this reason.
        :param pulumi.Input[_builtins.str] message: Human-readable details about this reason.
        :param pulumi.Input[_builtins.str] user_details: Additional information provided by the user in the RejectSpoke call.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if user_details is not None:
            pulumi.set(__self__, "user_details", user_details)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The code associated with this reason.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "code", value)

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Human-readable details about this reason.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "message", value)

    @_builtins.property
    @pulumi.getter(name="userDetails")
    def user_details(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Additional information provided by the user in the RejectSpoke call.
        """
        return pulumi.get(self, "user_details")

    @user_details.setter
    def user_details(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "user_details", value)


