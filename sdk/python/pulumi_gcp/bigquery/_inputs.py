# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AppProfileDataBoostIsolationReadOnlyArgs',
    'AppProfileDataBoostIsolationReadOnlyArgsDict',
    'AppProfileSingleClusterRoutingArgs',
    'AppProfileSingleClusterRoutingArgsDict',
    'AppProfileStandardIsolationArgs',
    'AppProfileStandardIsolationArgsDict',
    'BiReservationPreferredTableArgs',
    'BiReservationPreferredTableArgsDict',
    'ConnectionAwsArgs',
    'ConnectionAwsArgsDict',
    'ConnectionAwsAccessRoleArgs',
    'ConnectionAwsAccessRoleArgsDict',
    'ConnectionAzureArgs',
    'ConnectionAzureArgsDict',
    'ConnectionCloudResourceArgs',
    'ConnectionCloudResourceArgsDict',
    'ConnectionCloudSpannerArgs',
    'ConnectionCloudSpannerArgsDict',
    'ConnectionCloudSqlArgs',
    'ConnectionCloudSqlArgsDict',
    'ConnectionCloudSqlCredentialArgs',
    'ConnectionCloudSqlCredentialArgsDict',
    'ConnectionIamBindingConditionArgs',
    'ConnectionIamBindingConditionArgsDict',
    'ConnectionIamMemberConditionArgs',
    'ConnectionIamMemberConditionArgsDict',
    'ConnectionSparkArgs',
    'ConnectionSparkArgsDict',
    'ConnectionSparkMetastoreServiceConfigArgs',
    'ConnectionSparkMetastoreServiceConfigArgsDict',
    'ConnectionSparkSparkHistoryServerConfigArgs',
    'ConnectionSparkSparkHistoryServerConfigArgsDict',
    'DataTransferConfigEmailPreferencesArgs',
    'DataTransferConfigEmailPreferencesArgsDict',
    'DataTransferConfigEncryptionConfigurationArgs',
    'DataTransferConfigEncryptionConfigurationArgsDict',
    'DataTransferConfigScheduleOptionsArgs',
    'DataTransferConfigScheduleOptionsArgsDict',
    'DataTransferConfigSensitiveParamsArgs',
    'DataTransferConfigSensitiveParamsArgsDict',
    'DatasetAccessArgs',
    'DatasetAccessArgsDict',
    'DatasetAccessAuthorizedDatasetArgs',
    'DatasetAccessAuthorizedDatasetArgsDict',
    'DatasetAccessAuthorizedDatasetDatasetArgs',
    'DatasetAccessAuthorizedDatasetDatasetArgsDict',
    'DatasetAccessConditionArgs',
    'DatasetAccessConditionArgsDict',
    'DatasetAccessDatasetArgs',
    'DatasetAccessDatasetArgsDict',
    'DatasetAccessDatasetDatasetArgs',
    'DatasetAccessDatasetDatasetArgsDict',
    'DatasetAccessRoutineArgs',
    'DatasetAccessRoutineArgsDict',
    'DatasetAccessViewArgs',
    'DatasetAccessViewArgsDict',
    'DatasetDefaultEncryptionConfigurationArgs',
    'DatasetDefaultEncryptionConfigurationArgsDict',
    'DatasetExternalCatalogDatasetOptionsArgs',
    'DatasetExternalCatalogDatasetOptionsArgsDict',
    'DatasetExternalDatasetReferenceArgs',
    'DatasetExternalDatasetReferenceArgsDict',
    'DatasetIamBindingConditionArgs',
    'DatasetIamBindingConditionArgsDict',
    'DatasetIamMemberConditionArgs',
    'DatasetIamMemberConditionArgsDict',
    'IamBindingConditionArgs',
    'IamBindingConditionArgsDict',
    'IamMemberConditionArgs',
    'IamMemberConditionArgsDict',
    'JobCopyArgs',
    'JobCopyArgsDict',
    'JobCopyDestinationEncryptionConfigurationArgs',
    'JobCopyDestinationEncryptionConfigurationArgsDict',
    'JobCopyDestinationTableArgs',
    'JobCopyDestinationTableArgsDict',
    'JobCopySourceTableArgs',
    'JobCopySourceTableArgsDict',
    'JobExtractArgs',
    'JobExtractArgsDict',
    'JobExtractSourceModelArgs',
    'JobExtractSourceModelArgsDict',
    'JobExtractSourceTableArgs',
    'JobExtractSourceTableArgsDict',
    'JobLoadArgs',
    'JobLoadArgsDict',
    'JobLoadDestinationEncryptionConfigurationArgs',
    'JobLoadDestinationEncryptionConfigurationArgsDict',
    'JobLoadDestinationTableArgs',
    'JobLoadDestinationTableArgsDict',
    'JobLoadParquetOptionsArgs',
    'JobLoadParquetOptionsArgsDict',
    'JobLoadTimePartitioningArgs',
    'JobLoadTimePartitioningArgsDict',
    'JobQueryArgs',
    'JobQueryArgsDict',
    'JobQueryDefaultDatasetArgs',
    'JobQueryDefaultDatasetArgsDict',
    'JobQueryDestinationEncryptionConfigurationArgs',
    'JobQueryDestinationEncryptionConfigurationArgsDict',
    'JobQueryDestinationTableArgs',
    'JobQueryDestinationTableArgsDict',
    'JobQueryScriptOptionsArgs',
    'JobQueryScriptOptionsArgsDict',
    'JobQueryUserDefinedFunctionResourceArgs',
    'JobQueryUserDefinedFunctionResourceArgsDict',
    'JobStatusArgs',
    'JobStatusArgsDict',
    'JobStatusErrorArgs',
    'JobStatusErrorArgsDict',
    'JobStatusErrorResultArgs',
    'JobStatusErrorResultArgsDict',
    'ReservationAutoscaleArgs',
    'ReservationAutoscaleArgsDict',
    'RoutineArgumentArgs',
    'RoutineArgumentArgsDict',
    'RoutineRemoteFunctionOptionsArgs',
    'RoutineRemoteFunctionOptionsArgsDict',
    'RoutineSparkOptionsArgs',
    'RoutineSparkOptionsArgsDict',
    'TableBiglakeConfigurationArgs',
    'TableBiglakeConfigurationArgsDict',
    'TableEncryptionConfigurationArgs',
    'TableEncryptionConfigurationArgsDict',
    'TableExternalCatalogTableOptionsArgs',
    'TableExternalCatalogTableOptionsArgsDict',
    'TableExternalCatalogTableOptionsStorageDescriptorArgs',
    'TableExternalCatalogTableOptionsStorageDescriptorArgsDict',
    'TableExternalCatalogTableOptionsStorageDescriptorSerdeInfoArgs',
    'TableExternalCatalogTableOptionsStorageDescriptorSerdeInfoArgsDict',
    'TableExternalDataConfigurationArgs',
    'TableExternalDataConfigurationArgsDict',
    'TableExternalDataConfigurationAvroOptionsArgs',
    'TableExternalDataConfigurationAvroOptionsArgsDict',
    'TableExternalDataConfigurationBigtableOptionsArgs',
    'TableExternalDataConfigurationBigtableOptionsArgsDict',
    'TableExternalDataConfigurationBigtableOptionsColumnFamilyArgs',
    'TableExternalDataConfigurationBigtableOptionsColumnFamilyArgsDict',
    'TableExternalDataConfigurationBigtableOptionsColumnFamilyColumnArgs',
    'TableExternalDataConfigurationBigtableOptionsColumnFamilyColumnArgsDict',
    'TableExternalDataConfigurationCsvOptionsArgs',
    'TableExternalDataConfigurationCsvOptionsArgsDict',
    'TableExternalDataConfigurationGoogleSheetsOptionsArgs',
    'TableExternalDataConfigurationGoogleSheetsOptionsArgsDict',
    'TableExternalDataConfigurationHivePartitioningOptionsArgs',
    'TableExternalDataConfigurationHivePartitioningOptionsArgsDict',
    'TableExternalDataConfigurationJsonOptionsArgs',
    'TableExternalDataConfigurationJsonOptionsArgsDict',
    'TableExternalDataConfigurationParquetOptionsArgs',
    'TableExternalDataConfigurationParquetOptionsArgsDict',
    'TableMaterializedViewArgs',
    'TableMaterializedViewArgsDict',
    'TableRangePartitioningArgs',
    'TableRangePartitioningArgsDict',
    'TableRangePartitioningRangeArgs',
    'TableRangePartitioningRangeArgsDict',
    'TableSchemaForeignTypeInfoArgs',
    'TableSchemaForeignTypeInfoArgsDict',
    'TableTableConstraintsArgs',
    'TableTableConstraintsArgsDict',
    'TableTableConstraintsForeignKeyArgs',
    'TableTableConstraintsForeignKeyArgsDict',
    'TableTableConstraintsForeignKeyColumnReferencesArgs',
    'TableTableConstraintsForeignKeyColumnReferencesArgsDict',
    'TableTableConstraintsForeignKeyReferencedTableArgs',
    'TableTableConstraintsForeignKeyReferencedTableArgsDict',
    'TableTableConstraintsPrimaryKeyArgs',
    'TableTableConstraintsPrimaryKeyArgsDict',
    'TableTableReplicationInfoArgs',
    'TableTableReplicationInfoArgsDict',
    'TableTimePartitioningArgs',
    'TableTimePartitioningArgsDict',
    'TableViewArgs',
    'TableViewArgsDict',
]

MYPY = False

if not MYPY:
    class AppProfileDataBoostIsolationReadOnlyArgsDict(TypedDict):
        compute_billing_owner: pulumi.Input[str]
        """
        The Compute Billing Owner for this Data Boost App Profile.
        Possible values are: `HOST_PAYS`.
        """
elif False:
    AppProfileDataBoostIsolationReadOnlyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppProfileDataBoostIsolationReadOnlyArgs:
    def __init__(__self__, *,
                 compute_billing_owner: pulumi.Input[str]):
        """
        :param pulumi.Input[str] compute_billing_owner: The Compute Billing Owner for this Data Boost App Profile.
               Possible values are: `HOST_PAYS`.
        """
        pulumi.set(__self__, "compute_billing_owner", compute_billing_owner)

    @property
    @pulumi.getter(name="computeBillingOwner")
    def compute_billing_owner(self) -> pulumi.Input[str]:
        """
        The Compute Billing Owner for this Data Boost App Profile.
        Possible values are: `HOST_PAYS`.
        """
        return pulumi.get(self, "compute_billing_owner")

    @compute_billing_owner.setter
    def compute_billing_owner(self, value: pulumi.Input[str]):
        pulumi.set(self, "compute_billing_owner", value)


if not MYPY:
    class AppProfileSingleClusterRoutingArgsDict(TypedDict):
        cluster_id: pulumi.Input[str]
        """
        The cluster to which read/write requests should be routed.
        """
        allow_transactional_writes: NotRequired[pulumi.Input[bool]]
        """
        If true, CheckAndMutateRow and ReadModifyWriteRow requests are allowed by this app profile.
        It is unsafe to send these requests to the same table/row/column in multiple clusters.
        """
elif False:
    AppProfileSingleClusterRoutingArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppProfileSingleClusterRoutingArgs:
    def __init__(__self__, *,
                 cluster_id: pulumi.Input[str],
                 allow_transactional_writes: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] cluster_id: The cluster to which read/write requests should be routed.
        :param pulumi.Input[bool] allow_transactional_writes: If true, CheckAndMutateRow and ReadModifyWriteRow requests are allowed by this app profile.
               It is unsafe to send these requests to the same table/row/column in multiple clusters.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        if allow_transactional_writes is not None:
            pulumi.set(__self__, "allow_transactional_writes", allow_transactional_writes)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> pulumi.Input[str]:
        """
        The cluster to which read/write requests should be routed.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="allowTransactionalWrites")
    def allow_transactional_writes(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, CheckAndMutateRow and ReadModifyWriteRow requests are allowed by this app profile.
        It is unsafe to send these requests to the same table/row/column in multiple clusters.
        """
        return pulumi.get(self, "allow_transactional_writes")

    @allow_transactional_writes.setter
    def allow_transactional_writes(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_transactional_writes", value)


if not MYPY:
    class AppProfileStandardIsolationArgsDict(TypedDict):
        priority: pulumi.Input[str]
        """
        The priority of requests sent using this app profile.
        Possible values are: `PRIORITY_LOW`, `PRIORITY_MEDIUM`, `PRIORITY_HIGH`.
        """
elif False:
    AppProfileStandardIsolationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppProfileStandardIsolationArgs:
    def __init__(__self__, *,
                 priority: pulumi.Input[str]):
        """
        :param pulumi.Input[str] priority: The priority of requests sent using this app profile.
               Possible values are: `PRIORITY_LOW`, `PRIORITY_MEDIUM`, `PRIORITY_HIGH`.
        """
        pulumi.set(__self__, "priority", priority)

    @property
    @pulumi.getter
    def priority(self) -> pulumi.Input[str]:
        """
        The priority of requests sent using this app profile.
        Possible values are: `PRIORITY_LOW`, `PRIORITY_MEDIUM`, `PRIORITY_HIGH`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: pulumi.Input[str]):
        pulumi.set(self, "priority", value)


if not MYPY:
    class BiReservationPreferredTableArgsDict(TypedDict):
        dataset_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the dataset in the above project.
        """
        project_id: NotRequired[pulumi.Input[str]]
        """
        The assigned project ID of the project.
        """
        table_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the table in the above dataset.
        """
elif False:
    BiReservationPreferredTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BiReservationPreferredTableArgs:
    def __init__(__self__, *,
                 dataset_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 table_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dataset_id: The ID of the dataset in the above project.
        :param pulumi.Input[str] project_id: The assigned project ID of the project.
        :param pulumi.Input[str] table_id: The ID of the table in the above dataset.
        """
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if table_id is not None:
            pulumi.set(__self__, "table_id", table_id)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the dataset in the above project.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        The assigned project ID of the project.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="tableId")
    def table_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the table in the above dataset.
        """
        return pulumi.get(self, "table_id")

    @table_id.setter
    def table_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "table_id", value)


if not MYPY:
    class ConnectionAwsArgsDict(TypedDict):
        access_role: pulumi.Input['ConnectionAwsAccessRoleArgsDict']
        """
        Authentication using Google owned service account to assume into customer's AWS IAM Role.
        Structure is documented below.
        """
elif False:
    ConnectionAwsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionAwsArgs:
    def __init__(__self__, *,
                 access_role: pulumi.Input['ConnectionAwsAccessRoleArgs']):
        """
        :param pulumi.Input['ConnectionAwsAccessRoleArgs'] access_role: Authentication using Google owned service account to assume into customer's AWS IAM Role.
               Structure is documented below.
        """
        pulumi.set(__self__, "access_role", access_role)

    @property
    @pulumi.getter(name="accessRole")
    def access_role(self) -> pulumi.Input['ConnectionAwsAccessRoleArgs']:
        """
        Authentication using Google owned service account to assume into customer's AWS IAM Role.
        Structure is documented below.
        """
        return pulumi.get(self, "access_role")

    @access_role.setter
    def access_role(self, value: pulumi.Input['ConnectionAwsAccessRoleArgs']):
        pulumi.set(self, "access_role", value)


if not MYPY:
    class ConnectionAwsAccessRoleArgsDict(TypedDict):
        iam_role_id: pulumi.Input[str]
        """
        The user’s AWS IAM Role that trusts the Google-owned AWS IAM user Connection.
        """
        identity: NotRequired[pulumi.Input[str]]
        """
        (Output)
        A unique Google-owned and Google-generated identity for the Connection. This identity will be used to access the user's AWS IAM Role.
        """
elif False:
    ConnectionAwsAccessRoleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionAwsAccessRoleArgs:
    def __init__(__self__, *,
                 iam_role_id: pulumi.Input[str],
                 identity: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] iam_role_id: The user’s AWS IAM Role that trusts the Google-owned AWS IAM user Connection.
        :param pulumi.Input[str] identity: (Output)
               A unique Google-owned and Google-generated identity for the Connection. This identity will be used to access the user's AWS IAM Role.
        """
        pulumi.set(__self__, "iam_role_id", iam_role_id)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)

    @property
    @pulumi.getter(name="iamRoleId")
    def iam_role_id(self) -> pulumi.Input[str]:
        """
        The user’s AWS IAM Role that trusts the Google-owned AWS IAM user Connection.
        """
        return pulumi.get(self, "iam_role_id")

    @iam_role_id.setter
    def iam_role_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "iam_role_id", value)

    @property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        A unique Google-owned and Google-generated identity for the Connection. This identity will be used to access the user's AWS IAM Role.
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity", value)


if not MYPY:
    class ConnectionAzureArgsDict(TypedDict):
        customer_tenant_id: pulumi.Input[str]
        """
        The id of customer's directory that host the data.
        """
        application: NotRequired[pulumi.Input[str]]
        """
        (Output)
        The name of the Azure Active Directory Application.
        """
        client_id: NotRequired[pulumi.Input[str]]
        """
        (Output)
        The client id of the Azure Active Directory Application.
        """
        federated_application_client_id: NotRequired[pulumi.Input[str]]
        """
        The Azure Application (client) ID where the federated credentials will be hosted.
        """
        identity: NotRequired[pulumi.Input[str]]
        """
        (Output)
        A unique Google-owned and Google-generated identity for the Connection. This identity will be used to access the user's Azure Active Directory Application.
        """
        object_id: NotRequired[pulumi.Input[str]]
        """
        (Output)
        The object id of the Azure Active Directory Application.
        """
        redirect_uri: NotRequired[pulumi.Input[str]]
        """
        (Output)
        The URL user will be redirected to after granting consent during connection setup.
        """
elif False:
    ConnectionAzureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionAzureArgs:
    def __init__(__self__, *,
                 customer_tenant_id: pulumi.Input[str],
                 application: Optional[pulumi.Input[str]] = None,
                 client_id: Optional[pulumi.Input[str]] = None,
                 federated_application_client_id: Optional[pulumi.Input[str]] = None,
                 identity: Optional[pulumi.Input[str]] = None,
                 object_id: Optional[pulumi.Input[str]] = None,
                 redirect_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] customer_tenant_id: The id of customer's directory that host the data.
        :param pulumi.Input[str] application: (Output)
               The name of the Azure Active Directory Application.
        :param pulumi.Input[str] client_id: (Output)
               The client id of the Azure Active Directory Application.
        :param pulumi.Input[str] federated_application_client_id: The Azure Application (client) ID where the federated credentials will be hosted.
        :param pulumi.Input[str] identity: (Output)
               A unique Google-owned and Google-generated identity for the Connection. This identity will be used to access the user's Azure Active Directory Application.
        :param pulumi.Input[str] object_id: (Output)
               The object id of the Azure Active Directory Application.
        :param pulumi.Input[str] redirect_uri: (Output)
               The URL user will be redirected to after granting consent during connection setup.
        """
        pulumi.set(__self__, "customer_tenant_id", customer_tenant_id)
        if application is not None:
            pulumi.set(__self__, "application", application)
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if federated_application_client_id is not None:
            pulumi.set(__self__, "federated_application_client_id", federated_application_client_id)
        if identity is not None:
            pulumi.set(__self__, "identity", identity)
        if object_id is not None:
            pulumi.set(__self__, "object_id", object_id)
        if redirect_uri is not None:
            pulumi.set(__self__, "redirect_uri", redirect_uri)

    @property
    @pulumi.getter(name="customerTenantId")
    def customer_tenant_id(self) -> pulumi.Input[str]:
        """
        The id of customer's directory that host the data.
        """
        return pulumi.get(self, "customer_tenant_id")

    @customer_tenant_id.setter
    def customer_tenant_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "customer_tenant_id", value)

    @property
    @pulumi.getter
    def application(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The name of the Azure Active Directory Application.
        """
        return pulumi.get(self, "application")

    @application.setter
    def application(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "application", value)

    @property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The client id of the Azure Active Directory Application.
        """
        return pulumi.get(self, "client_id")

    @client_id.setter
    def client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_id", value)

    @property
    @pulumi.getter(name="federatedApplicationClientId")
    def federated_application_client_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Azure Application (client) ID where the federated credentials will be hosted.
        """
        return pulumi.get(self, "federated_application_client_id")

    @federated_application_client_id.setter
    def federated_application_client_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "federated_application_client_id", value)

    @property
    @pulumi.getter
    def identity(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        A unique Google-owned and Google-generated identity for the Connection. This identity will be used to access the user's Azure Active Directory Application.
        """
        return pulumi.get(self, "identity")

    @identity.setter
    def identity(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "identity", value)

    @property
    @pulumi.getter(name="objectId")
    def object_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The object id of the Azure Active Directory Application.
        """
        return pulumi.get(self, "object_id")

    @object_id.setter
    def object_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_id", value)

    @property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The URL user will be redirected to after granting consent during connection setup.
        """
        return pulumi.get(self, "redirect_uri")

    @redirect_uri.setter
    def redirect_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "redirect_uri", value)


if not MYPY:
    class ConnectionCloudResourceArgsDict(TypedDict):
        service_account_id: NotRequired[pulumi.Input[str]]
        """
        (Output)
        The account ID of the service created for the purpose of this connection.
        """
elif False:
    ConnectionCloudResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionCloudResourceArgs:
    def __init__(__self__, *,
                 service_account_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] service_account_id: (Output)
               The account ID of the service created for the purpose of this connection.
        """
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The account ID of the service created for the purpose of this connection.
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_id", value)


if not MYPY:
    class ConnectionCloudSpannerArgsDict(TypedDict):
        database: pulumi.Input[str]
        """
        Cloud Spanner database in the form `project/instance/database'.
        """
        database_role: NotRequired[pulumi.Input[str]]
        """
        Cloud Spanner database role for fine-grained access control. The Cloud Spanner admin should have provisioned the database role with appropriate permissions, such as `SELECT` and `INSERT`. Other users should only use roles provided by their Cloud Spanner admins. The database role name must start with a letter, and can only contain letters, numbers, and underscores. For more details, see https://cloud.google.com/spanner/docs/fgac-about.
        """
        max_parallelism: NotRequired[pulumi.Input[int]]
        """
        Allows setting max parallelism per query when executing on Spanner independent compute resources. If unspecified, default values of parallelism are chosen that are dependent on the Cloud Spanner instance configuration. `useParallelism` and `useDataBoost` must be set when setting max parallelism.
        """
        use_data_boost: NotRequired[pulumi.Input[bool]]
        """
        If set, the request will be executed via Spanner independent compute resources. `use_parallelism` must be set when using data boost.
        """
        use_parallelism: NotRequired[pulumi.Input[bool]]
        """
        If parallelism should be used when reading from Cloud Spanner.
        """
        use_serverless_analytics: NotRequired[pulumi.Input[bool]]
        """
        (Optional, Deprecated)
        If the serverless analytics service should be used to read data from Cloud Spanner. `useParallelism` must be set when using serverless analytics.

        > **Warning:** `useServerlessAnalytics` is deprecated and will be removed in a future major release. Use `useDataBoost` instead.
        """
elif False:
    ConnectionCloudSpannerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionCloudSpannerArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 database_role: Optional[pulumi.Input[str]] = None,
                 max_parallelism: Optional[pulumi.Input[int]] = None,
                 use_data_boost: Optional[pulumi.Input[bool]] = None,
                 use_parallelism: Optional[pulumi.Input[bool]] = None,
                 use_serverless_analytics: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] database: Cloud Spanner database in the form `project/instance/database'.
        :param pulumi.Input[str] database_role: Cloud Spanner database role for fine-grained access control. The Cloud Spanner admin should have provisioned the database role with appropriate permissions, such as `SELECT` and `INSERT`. Other users should only use roles provided by their Cloud Spanner admins. The database role name must start with a letter, and can only contain letters, numbers, and underscores. For more details, see https://cloud.google.com/spanner/docs/fgac-about.
        :param pulumi.Input[int] max_parallelism: Allows setting max parallelism per query when executing on Spanner independent compute resources. If unspecified, default values of parallelism are chosen that are dependent on the Cloud Spanner instance configuration. `useParallelism` and `useDataBoost` must be set when setting max parallelism.
        :param pulumi.Input[bool] use_data_boost: If set, the request will be executed via Spanner independent compute resources. `use_parallelism` must be set when using data boost.
        :param pulumi.Input[bool] use_parallelism: If parallelism should be used when reading from Cloud Spanner.
        :param pulumi.Input[bool] use_serverless_analytics: (Optional, Deprecated)
               If the serverless analytics service should be used to read data from Cloud Spanner. `useParallelism` must be set when using serverless analytics.
               
               > **Warning:** `useServerlessAnalytics` is deprecated and will be removed in a future major release. Use `useDataBoost` instead.
        """
        pulumi.set(__self__, "database", database)
        if database_role is not None:
            pulumi.set(__self__, "database_role", database_role)
        if max_parallelism is not None:
            pulumi.set(__self__, "max_parallelism", max_parallelism)
        if use_data_boost is not None:
            pulumi.set(__self__, "use_data_boost", use_data_boost)
        if use_parallelism is not None:
            pulumi.set(__self__, "use_parallelism", use_parallelism)
        if use_serverless_analytics is not None:
            warnings.warn("""`useServerlessAnalytics` is deprecated and will be removed in a future major release. Use `useDataBoost` instead.""", DeprecationWarning)
            pulumi.log.warn("""use_serverless_analytics is deprecated: `useServerlessAnalytics` is deprecated and will be removed in a future major release. Use `useDataBoost` instead.""")
        if use_serverless_analytics is not None:
            pulumi.set(__self__, "use_serverless_analytics", use_serverless_analytics)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Cloud Spanner database in the form `project/instance/database'.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="databaseRole")
    def database_role(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud Spanner database role for fine-grained access control. The Cloud Spanner admin should have provisioned the database role with appropriate permissions, such as `SELECT` and `INSERT`. Other users should only use roles provided by their Cloud Spanner admins. The database role name must start with a letter, and can only contain letters, numbers, and underscores. For more details, see https://cloud.google.com/spanner/docs/fgac-about.
        """
        return pulumi.get(self, "database_role")

    @database_role.setter
    def database_role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_role", value)

    @property
    @pulumi.getter(name="maxParallelism")
    def max_parallelism(self) -> Optional[pulumi.Input[int]]:
        """
        Allows setting max parallelism per query when executing on Spanner independent compute resources. If unspecified, default values of parallelism are chosen that are dependent on the Cloud Spanner instance configuration. `useParallelism` and `useDataBoost` must be set when setting max parallelism.
        """
        return pulumi.get(self, "max_parallelism")

    @max_parallelism.setter
    def max_parallelism(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_parallelism", value)

    @property
    @pulumi.getter(name="useDataBoost")
    def use_data_boost(self) -> Optional[pulumi.Input[bool]]:
        """
        If set, the request will be executed via Spanner independent compute resources. `use_parallelism` must be set when using data boost.
        """
        return pulumi.get(self, "use_data_boost")

    @use_data_boost.setter
    def use_data_boost(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_data_boost", value)

    @property
    @pulumi.getter(name="useParallelism")
    def use_parallelism(self) -> Optional[pulumi.Input[bool]]:
        """
        If parallelism should be used when reading from Cloud Spanner.
        """
        return pulumi.get(self, "use_parallelism")

    @use_parallelism.setter
    def use_parallelism(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_parallelism", value)

    @property
    @pulumi.getter(name="useServerlessAnalytics")
    @_utilities.deprecated("""`useServerlessAnalytics` is deprecated and will be removed in a future major release. Use `useDataBoost` instead.""")
    def use_serverless_analytics(self) -> Optional[pulumi.Input[bool]]:
        """
        (Optional, Deprecated)
        If the serverless analytics service should be used to read data from Cloud Spanner. `useParallelism` must be set when using serverless analytics.

        > **Warning:** `useServerlessAnalytics` is deprecated and will be removed in a future major release. Use `useDataBoost` instead.
        """
        return pulumi.get(self, "use_serverless_analytics")

    @use_serverless_analytics.setter
    def use_serverless_analytics(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_serverless_analytics", value)


if not MYPY:
    class ConnectionCloudSqlArgsDict(TypedDict):
        credential: pulumi.Input['ConnectionCloudSqlCredentialArgsDict']
        """
        Cloud SQL properties.
        Structure is documented below.
        """
        database: pulumi.Input[str]
        """
        Database name.
        """
        instance_id: pulumi.Input[str]
        """
        Cloud SQL instance ID in the form project:location:instance.
        """
        type: pulumi.Input[str]
        """
        Type of the Cloud SQL database.
        Possible values are: `DATABASE_TYPE_UNSPECIFIED`, `POSTGRES`, `MYSQL`.
        """
        service_account_id: NotRequired[pulumi.Input[str]]
        """
        (Output)
        When the connection is used in the context of an operation in BigQuery, this service account will serve as the identity being used for connecting to the CloudSQL instance specified in this connection.
        """
elif False:
    ConnectionCloudSqlArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionCloudSqlArgs:
    def __init__(__self__, *,
                 credential: pulumi.Input['ConnectionCloudSqlCredentialArgs'],
                 database: pulumi.Input[str],
                 instance_id: pulumi.Input[str],
                 type: pulumi.Input[str],
                 service_account_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['ConnectionCloudSqlCredentialArgs'] credential: Cloud SQL properties.
               Structure is documented below.
        :param pulumi.Input[str] database: Database name.
        :param pulumi.Input[str] instance_id: Cloud SQL instance ID in the form project:location:instance.
        :param pulumi.Input[str] type: Type of the Cloud SQL database.
               Possible values are: `DATABASE_TYPE_UNSPECIFIED`, `POSTGRES`, `MYSQL`.
        :param pulumi.Input[str] service_account_id: (Output)
               When the connection is used in the context of an operation in BigQuery, this service account will serve as the identity being used for connecting to the CloudSQL instance specified in this connection.
        """
        pulumi.set(__self__, "credential", credential)
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "instance_id", instance_id)
        pulumi.set(__self__, "type", type)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)

    @property
    @pulumi.getter
    def credential(self) -> pulumi.Input['ConnectionCloudSqlCredentialArgs']:
        """
        Cloud SQL properties.
        Structure is documented below.
        """
        return pulumi.get(self, "credential")

    @credential.setter
    def credential(self, value: pulumi.Input['ConnectionCloudSqlCredentialArgs']):
        pulumi.set(self, "credential", value)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Database name.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="instanceId")
    def instance_id(self) -> pulumi.Input[str]:
        """
        Cloud SQL instance ID in the form project:location:instance.
        """
        return pulumi.get(self, "instance_id")

    @instance_id.setter
    def instance_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance_id", value)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        Type of the Cloud SQL database.
        Possible values are: `DATABASE_TYPE_UNSPECIFIED`, `POSTGRES`, `MYSQL`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        When the connection is used in the context of an operation in BigQuery, this service account will serve as the identity being used for connecting to the CloudSQL instance specified in this connection.
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_id", value)


if not MYPY:
    class ConnectionCloudSqlCredentialArgsDict(TypedDict):
        password: pulumi.Input[str]
        """
        Password for database.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        username: pulumi.Input[str]
        """
        Username for database.
        """
elif False:
    ConnectionCloudSqlCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionCloudSqlCredentialArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] password: Password for database.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[str] username: Username for database.
        """
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Password for database.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username for database.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


if not MYPY:
    class ConnectionIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    ConnectionIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class ConnectionIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    ConnectionIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class ConnectionSparkArgsDict(TypedDict):
        metastore_service_config: NotRequired[pulumi.Input['ConnectionSparkMetastoreServiceConfigArgsDict']]
        """
        Dataproc Metastore Service configuration for the connection.
        Structure is documented below.
        """
        service_account_id: NotRequired[pulumi.Input[str]]
        """
        (Output)
        The account ID of the service created for the purpose of this connection.
        """
        spark_history_server_config: NotRequired[pulumi.Input['ConnectionSparkSparkHistoryServerConfigArgsDict']]
        """
        Spark History Server configuration for the connection.
        Structure is documented below.
        """
elif False:
    ConnectionSparkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionSparkArgs:
    def __init__(__self__, *,
                 metastore_service_config: Optional[pulumi.Input['ConnectionSparkMetastoreServiceConfigArgs']] = None,
                 service_account_id: Optional[pulumi.Input[str]] = None,
                 spark_history_server_config: Optional[pulumi.Input['ConnectionSparkSparkHistoryServerConfigArgs']] = None):
        """
        :param pulumi.Input['ConnectionSparkMetastoreServiceConfigArgs'] metastore_service_config: Dataproc Metastore Service configuration for the connection.
               Structure is documented below.
        :param pulumi.Input[str] service_account_id: (Output)
               The account ID of the service created for the purpose of this connection.
        :param pulumi.Input['ConnectionSparkSparkHistoryServerConfigArgs'] spark_history_server_config: Spark History Server configuration for the connection.
               Structure is documented below.
        """
        if metastore_service_config is not None:
            pulumi.set(__self__, "metastore_service_config", metastore_service_config)
        if service_account_id is not None:
            pulumi.set(__self__, "service_account_id", service_account_id)
        if spark_history_server_config is not None:
            pulumi.set(__self__, "spark_history_server_config", spark_history_server_config)

    @property
    @pulumi.getter(name="metastoreServiceConfig")
    def metastore_service_config(self) -> Optional[pulumi.Input['ConnectionSparkMetastoreServiceConfigArgs']]:
        """
        Dataproc Metastore Service configuration for the connection.
        Structure is documented below.
        """
        return pulumi.get(self, "metastore_service_config")

    @metastore_service_config.setter
    def metastore_service_config(self, value: Optional[pulumi.Input['ConnectionSparkMetastoreServiceConfigArgs']]):
        pulumi.set(self, "metastore_service_config", value)

    @property
    @pulumi.getter(name="serviceAccountId")
    def service_account_id(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The account ID of the service created for the purpose of this connection.
        """
        return pulumi.get(self, "service_account_id")

    @service_account_id.setter
    def service_account_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "service_account_id", value)

    @property
    @pulumi.getter(name="sparkHistoryServerConfig")
    def spark_history_server_config(self) -> Optional[pulumi.Input['ConnectionSparkSparkHistoryServerConfigArgs']]:
        """
        Spark History Server configuration for the connection.
        Structure is documented below.
        """
        return pulumi.get(self, "spark_history_server_config")

    @spark_history_server_config.setter
    def spark_history_server_config(self, value: Optional[pulumi.Input['ConnectionSparkSparkHistoryServerConfigArgs']]):
        pulumi.set(self, "spark_history_server_config", value)


if not MYPY:
    class ConnectionSparkMetastoreServiceConfigArgsDict(TypedDict):
        metastore_service: NotRequired[pulumi.Input[str]]
        """
        Resource name of an existing Dataproc Metastore service in the form of projects/[projectId]/locations/[region]/services/[serviceId].
        """
elif False:
    ConnectionSparkMetastoreServiceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionSparkMetastoreServiceConfigArgs:
    def __init__(__self__, *,
                 metastore_service: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] metastore_service: Resource name of an existing Dataproc Metastore service in the form of projects/[projectId]/locations/[region]/services/[serviceId].
        """
        if metastore_service is not None:
            pulumi.set(__self__, "metastore_service", metastore_service)

    @property
    @pulumi.getter(name="metastoreService")
    def metastore_service(self) -> Optional[pulumi.Input[str]]:
        """
        Resource name of an existing Dataproc Metastore service in the form of projects/[projectId]/locations/[region]/services/[serviceId].
        """
        return pulumi.get(self, "metastore_service")

    @metastore_service.setter
    def metastore_service(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metastore_service", value)


if not MYPY:
    class ConnectionSparkSparkHistoryServerConfigArgsDict(TypedDict):
        dataproc_cluster: NotRequired[pulumi.Input[str]]
        """
        Resource name of an existing Dataproc Cluster to act as a Spark History Server for the connection if the form of projects/[projectId]/regions/[region]/clusters/[cluster_name].
        """
elif False:
    ConnectionSparkSparkHistoryServerConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionSparkSparkHistoryServerConfigArgs:
    def __init__(__self__, *,
                 dataproc_cluster: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dataproc_cluster: Resource name of an existing Dataproc Cluster to act as a Spark History Server for the connection if the form of projects/[projectId]/regions/[region]/clusters/[cluster_name].
        """
        if dataproc_cluster is not None:
            pulumi.set(__self__, "dataproc_cluster", dataproc_cluster)

    @property
    @pulumi.getter(name="dataprocCluster")
    def dataproc_cluster(self) -> Optional[pulumi.Input[str]]:
        """
        Resource name of an existing Dataproc Cluster to act as a Spark History Server for the connection if the form of projects/[projectId]/regions/[region]/clusters/[cluster_name].
        """
        return pulumi.get(self, "dataproc_cluster")

    @dataproc_cluster.setter
    def dataproc_cluster(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataproc_cluster", value)


if not MYPY:
    class DataTransferConfigEmailPreferencesArgsDict(TypedDict):
        enable_failure_email: pulumi.Input[bool]
        """
        If true, email notifications will be sent on transfer run failures.
        """
elif False:
    DataTransferConfigEmailPreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataTransferConfigEmailPreferencesArgs:
    def __init__(__self__, *,
                 enable_failure_email: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enable_failure_email: If true, email notifications will be sent on transfer run failures.
        """
        pulumi.set(__self__, "enable_failure_email", enable_failure_email)

    @property
    @pulumi.getter(name="enableFailureEmail")
    def enable_failure_email(self) -> pulumi.Input[bool]:
        """
        If true, email notifications will be sent on transfer run failures.
        """
        return pulumi.get(self, "enable_failure_email")

    @enable_failure_email.setter
    def enable_failure_email(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enable_failure_email", value)


if not MYPY:
    class DataTransferConfigEncryptionConfigurationArgsDict(TypedDict):
        kms_key_name: pulumi.Input[str]
        """
        The name of the KMS key used for encrypting BigQuery data.
        """
elif False:
    DataTransferConfigEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataTransferConfigEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 kms_key_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] kms_key_name: The name of the KMS key used for encrypting BigQuery data.
        """
        pulumi.set(__self__, "kms_key_name", kms_key_name)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> pulumi.Input[str]:
        """
        The name of the KMS key used for encrypting BigQuery data.
        """
        return pulumi.get(self, "kms_key_name")

    @kms_key_name.setter
    def kms_key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "kms_key_name", value)


if not MYPY:
    class DataTransferConfigScheduleOptionsArgsDict(TypedDict):
        disable_auto_scheduling: NotRequired[pulumi.Input[bool]]
        """
        If true, automatic scheduling of data transfer runs for this
        configuration will be disabled. The runs can be started on ad-hoc
        basis using transferConfigs.startManualRuns API. When automatic
        scheduling is disabled, the TransferConfig.schedule field will
        be ignored.
        """
        end_time: NotRequired[pulumi.Input[str]]
        """
        Defines time to stop scheduling transfer runs. A transfer run cannot be
        scheduled at or after the end time. The end time can be changed at any
        moment. The time when a data transfer can be triggered manually is not
        limited by this option.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        Specifies time to start scheduling transfer runs. The first run will be
        scheduled at or after the start time according to a recurrence pattern
        defined in the schedule string. The start time can be changed at any
        moment. The time when a data transfer can be triggered manually is not
        limited by this option.
        """
elif False:
    DataTransferConfigScheduleOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataTransferConfigScheduleOptionsArgs:
    def __init__(__self__, *,
                 disable_auto_scheduling: Optional[pulumi.Input[bool]] = None,
                 end_time: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] disable_auto_scheduling: If true, automatic scheduling of data transfer runs for this
               configuration will be disabled. The runs can be started on ad-hoc
               basis using transferConfigs.startManualRuns API. When automatic
               scheduling is disabled, the TransferConfig.schedule field will
               be ignored.
        :param pulumi.Input[str] end_time: Defines time to stop scheduling transfer runs. A transfer run cannot be
               scheduled at or after the end time. The end time can be changed at any
               moment. The time when a data transfer can be triggered manually is not
               limited by this option.
        :param pulumi.Input[str] start_time: Specifies time to start scheduling transfer runs. The first run will be
               scheduled at or after the start time according to a recurrence pattern
               defined in the schedule string. The start time can be changed at any
               moment. The time when a data transfer can be triggered manually is not
               limited by this option.
        """
        if disable_auto_scheduling is not None:
            pulumi.set(__self__, "disable_auto_scheduling", disable_auto_scheduling)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="disableAutoScheduling")
    def disable_auto_scheduling(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, automatic scheduling of data transfer runs for this
        configuration will be disabled. The runs can be started on ad-hoc
        basis using transferConfigs.startManualRuns API. When automatic
        scheduling is disabled, the TransferConfig.schedule field will
        be ignored.
        """
        return pulumi.get(self, "disable_auto_scheduling")

    @disable_auto_scheduling.setter
    def disable_auto_scheduling(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "disable_auto_scheduling", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        Defines time to stop scheduling transfer runs. A transfer run cannot be
        scheduled at or after the end time. The end time can be changed at any
        moment. The time when a data transfer can be triggered manually is not
        limited by this option.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies time to start scheduling transfer runs. The first run will be
        scheduled at or after the start time according to a recurrence pattern
        defined in the schedule string. The start time can be changed at any
        moment. The time when a data transfer can be triggered manually is not
        limited by this option.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class DataTransferConfigSensitiveParamsArgsDict(TypedDict):
        secret_access_key: NotRequired[pulumi.Input[str]]
        """
        The Secret Access Key of the AWS account transferring data from.
        """
elif False:
    DataTransferConfigSensitiveParamsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataTransferConfigSensitiveParamsArgs:
    def __init__(__self__, *,
                 secret_access_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] secret_access_key: The Secret Access Key of the AWS account transferring data from.
        """
        if secret_access_key is not None:
            pulumi.set(__self__, "secret_access_key", secret_access_key)

    @property
    @pulumi.getter(name="secretAccessKey")
    def secret_access_key(self) -> Optional[pulumi.Input[str]]:
        """
        The Secret Access Key of the AWS account transferring data from.
        """
        return pulumi.get(self, "secret_access_key")

    @secret_access_key.setter
    def secret_access_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "secret_access_key", value)


if not MYPY:
    class DatasetAccessArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input['DatasetAccessConditionArgsDict']]
        """
        Condition for the binding. If CEL expression in this field is true, this
        access binding will be considered.
        Structure is documented below.
        """
        dataset: NotRequired[pulumi.Input['DatasetAccessDatasetArgsDict']]
        """
        Grants all resources of particular types in a particular dataset read access to the current dataset.
        Structure is documented below.
        """
        domain: NotRequired[pulumi.Input[str]]
        """
        A domain to grant access to. Any users signed in with the
        domain specified will be granted the specified access
        """
        group_by_email: NotRequired[pulumi.Input[str]]
        """
        An email address of a Google Group to grant access to.
        """
        iam_member: NotRequired[pulumi.Input[str]]
        """
        Some other type of member that appears in the IAM Policy but isn't a user,
        group, domain, or special group. For example: `allUsers`
        """
        role: NotRequired[pulumi.Input[str]]
        """
        Describes the rights granted to the user specified by the other
        member of the access object. Basic, predefined, and custom roles
        are supported. Predefined roles that have equivalent basic roles
        are swapped by the API to their basic counterparts. See
        [official docs](https://cloud.google.com/bigquery/docs/access-control).
        """
        routine: NotRequired[pulumi.Input['DatasetAccessRoutineArgsDict']]
        """
        A routine from a different dataset to grant access to. Queries
        executed against that routine will have read access to tables in
        this dataset. The role field is not required when this field is
        set. If that routine is updated by any user, access to the routine
        needs to be granted again via an update operation.
        Structure is documented below.
        """
        special_group: NotRequired[pulumi.Input[str]]
        """
        A special group to grant access to. Possible values include:
        * `projectOwners`: Owners of the enclosing project.
        * `projectReaders`: Readers of the enclosing project.
        * `projectWriters`: Writers of the enclosing project.
        * `allAuthenticatedUsers`: All authenticated BigQuery users.
        """
        user_by_email: NotRequired[pulumi.Input[str]]
        """
        An email address of a user to grant access to. For example:
        fred@example.com
        """
        view: NotRequired[pulumi.Input['DatasetAccessViewArgsDict']]
        """
        A view from a different dataset to grant access to. Queries
        executed against that view will have read access to tables in
        this dataset. The role field is not required when this field is
        set. If that view is updated by any user, access to the view
        needs to be granted again via an update operation.
        Structure is documented below.
        """
elif False:
    DatasetAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetAccessArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input['DatasetAccessConditionArgs']] = None,
                 dataset: Optional[pulumi.Input['DatasetAccessDatasetArgs']] = None,
                 domain: Optional[pulumi.Input[str]] = None,
                 group_by_email: Optional[pulumi.Input[str]] = None,
                 iam_member: Optional[pulumi.Input[str]] = None,
                 role: Optional[pulumi.Input[str]] = None,
                 routine: Optional[pulumi.Input['DatasetAccessRoutineArgs']] = None,
                 special_group: Optional[pulumi.Input[str]] = None,
                 user_by_email: Optional[pulumi.Input[str]] = None,
                 view: Optional[pulumi.Input['DatasetAccessViewArgs']] = None):
        """
        :param pulumi.Input['DatasetAccessConditionArgs'] condition: Condition for the binding. If CEL expression in this field is true, this
               access binding will be considered.
               Structure is documented below.
        :param pulumi.Input['DatasetAccessDatasetArgs'] dataset: Grants all resources of particular types in a particular dataset read access to the current dataset.
               Structure is documented below.
        :param pulumi.Input[str] domain: A domain to grant access to. Any users signed in with the
               domain specified will be granted the specified access
        :param pulumi.Input[str] group_by_email: An email address of a Google Group to grant access to.
        :param pulumi.Input[str] iam_member: Some other type of member that appears in the IAM Policy but isn't a user,
               group, domain, or special group. For example: `allUsers`
        :param pulumi.Input[str] role: Describes the rights granted to the user specified by the other
               member of the access object. Basic, predefined, and custom roles
               are supported. Predefined roles that have equivalent basic roles
               are swapped by the API to their basic counterparts. See
               [official docs](https://cloud.google.com/bigquery/docs/access-control).
        :param pulumi.Input['DatasetAccessRoutineArgs'] routine: A routine from a different dataset to grant access to. Queries
               executed against that routine will have read access to tables in
               this dataset. The role field is not required when this field is
               set. If that routine is updated by any user, access to the routine
               needs to be granted again via an update operation.
               Structure is documented below.
        :param pulumi.Input[str] special_group: A special group to grant access to. Possible values include:
               * `projectOwners`: Owners of the enclosing project.
               * `projectReaders`: Readers of the enclosing project.
               * `projectWriters`: Writers of the enclosing project.
               * `allAuthenticatedUsers`: All authenticated BigQuery users.
        :param pulumi.Input[str] user_by_email: An email address of a user to grant access to. For example:
               fred@example.com
        :param pulumi.Input['DatasetAccessViewArgs'] view: A view from a different dataset to grant access to. Queries
               executed against that view will have read access to tables in
               this dataset. The role field is not required when this field is
               set. If that view is updated by any user, access to the view
               needs to be granted again via an update operation.
               Structure is documented below.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if dataset is not None:
            pulumi.set(__self__, "dataset", dataset)
        if domain is not None:
            pulumi.set(__self__, "domain", domain)
        if group_by_email is not None:
            pulumi.set(__self__, "group_by_email", group_by_email)
        if iam_member is not None:
            pulumi.set(__self__, "iam_member", iam_member)
        if role is not None:
            pulumi.set(__self__, "role", role)
        if routine is not None:
            pulumi.set(__self__, "routine", routine)
        if special_group is not None:
            pulumi.set(__self__, "special_group", special_group)
        if user_by_email is not None:
            pulumi.set(__self__, "user_by_email", user_by_email)
        if view is not None:
            pulumi.set(__self__, "view", view)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['DatasetAccessConditionArgs']]:
        """
        Condition for the binding. If CEL expression in this field is true, this
        access binding will be considered.
        Structure is documented below.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['DatasetAccessConditionArgs']]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter
    def dataset(self) -> Optional[pulumi.Input['DatasetAccessDatasetArgs']]:
        """
        Grants all resources of particular types in a particular dataset read access to the current dataset.
        Structure is documented below.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: Optional[pulumi.Input['DatasetAccessDatasetArgs']]):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter
    def domain(self) -> Optional[pulumi.Input[str]]:
        """
        A domain to grant access to. Any users signed in with the
        domain specified will be granted the specified access
        """
        return pulumi.get(self, "domain")

    @domain.setter
    def domain(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "domain", value)

    @property
    @pulumi.getter(name="groupByEmail")
    def group_by_email(self) -> Optional[pulumi.Input[str]]:
        """
        An email address of a Google Group to grant access to.
        """
        return pulumi.get(self, "group_by_email")

    @group_by_email.setter
    def group_by_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "group_by_email", value)

    @property
    @pulumi.getter(name="iamMember")
    def iam_member(self) -> Optional[pulumi.Input[str]]:
        """
        Some other type of member that appears in the IAM Policy but isn't a user,
        group, domain, or special group. For example: `allUsers`
        """
        return pulumi.get(self, "iam_member")

    @iam_member.setter
    def iam_member(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "iam_member", value)

    @property
    @pulumi.getter
    def role(self) -> Optional[pulumi.Input[str]]:
        """
        Describes the rights granted to the user specified by the other
        member of the access object. Basic, predefined, and custom roles
        are supported. Predefined roles that have equivalent basic roles
        are swapped by the API to their basic counterparts. See
        [official docs](https://cloud.google.com/bigquery/docs/access-control).
        """
        return pulumi.get(self, "role")

    @role.setter
    def role(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "role", value)

    @property
    @pulumi.getter
    def routine(self) -> Optional[pulumi.Input['DatasetAccessRoutineArgs']]:
        """
        A routine from a different dataset to grant access to. Queries
        executed against that routine will have read access to tables in
        this dataset. The role field is not required when this field is
        set. If that routine is updated by any user, access to the routine
        needs to be granted again via an update operation.
        Structure is documented below.
        """
        return pulumi.get(self, "routine")

    @routine.setter
    def routine(self, value: Optional[pulumi.Input['DatasetAccessRoutineArgs']]):
        pulumi.set(self, "routine", value)

    @property
    @pulumi.getter(name="specialGroup")
    def special_group(self) -> Optional[pulumi.Input[str]]:
        """
        A special group to grant access to. Possible values include:
        * `projectOwners`: Owners of the enclosing project.
        * `projectReaders`: Readers of the enclosing project.
        * `projectWriters`: Writers of the enclosing project.
        * `allAuthenticatedUsers`: All authenticated BigQuery users.
        """
        return pulumi.get(self, "special_group")

    @special_group.setter
    def special_group(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "special_group", value)

    @property
    @pulumi.getter(name="userByEmail")
    def user_by_email(self) -> Optional[pulumi.Input[str]]:
        """
        An email address of a user to grant access to. For example:
        fred@example.com
        """
        return pulumi.get(self, "user_by_email")

    @user_by_email.setter
    def user_by_email(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user_by_email", value)

    @property
    @pulumi.getter
    def view(self) -> Optional[pulumi.Input['DatasetAccessViewArgs']]:
        """
        A view from a different dataset to grant access to. Queries
        executed against that view will have read access to tables in
        this dataset. The role field is not required when this field is
        set. If that view is updated by any user, access to the view
        needs to be granted again via an update operation.
        Structure is documented below.
        """
        return pulumi.get(self, "view")

    @view.setter
    def view(self, value: Optional[pulumi.Input['DatasetAccessViewArgs']]):
        pulumi.set(self, "view", value)


if not MYPY:
    class DatasetAccessAuthorizedDatasetArgsDict(TypedDict):
        dataset: pulumi.Input['DatasetAccessAuthorizedDatasetDatasetArgsDict']
        """
        The dataset this entry applies to
        Structure is documented below.
        """
        target_types: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Which resources in the dataset this entry applies to. Currently, only views are supported,
        but additional target types may be added in the future. Possible values: VIEWS
        """
elif False:
    DatasetAccessAuthorizedDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetAccessAuthorizedDatasetArgs:
    def __init__(__self__, *,
                 dataset: pulumi.Input['DatasetAccessAuthorizedDatasetDatasetArgs'],
                 target_types: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input['DatasetAccessAuthorizedDatasetDatasetArgs'] dataset: The dataset this entry applies to
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_types: Which resources in the dataset this entry applies to. Currently, only views are supported,
               but additional target types may be added in the future. Possible values: VIEWS
        """
        pulumi.set(__self__, "dataset", dataset)
        pulumi.set(__self__, "target_types", target_types)

    @property
    @pulumi.getter
    def dataset(self) -> pulumi.Input['DatasetAccessAuthorizedDatasetDatasetArgs']:
        """
        The dataset this entry applies to
        Structure is documented below.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: pulumi.Input['DatasetAccessAuthorizedDatasetDatasetArgs']):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter(name="targetTypes")
    def target_types(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Which resources in the dataset this entry applies to. Currently, only views are supported,
        but additional target types may be added in the future. Possible values: VIEWS
        """
        return pulumi.get(self, "target_types")

    @target_types.setter
    def target_types(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "target_types", value)


if not MYPY:
    class DatasetAccessAuthorizedDatasetDatasetArgsDict(TypedDict):
        dataset_id: pulumi.Input[str]
        """
        The ID of the dataset containing this table.
        """
        project_id: pulumi.Input[str]
        """
        The ID of the project containing this table.
        """
elif False:
    DatasetAccessAuthorizedDatasetDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetAccessAuthorizedDatasetDatasetArgs:
    def __init__(__self__, *,
                 dataset_id: pulumi.Input[str],
                 project_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] dataset_id: The ID of the dataset containing this table.
        :param pulumi.Input[str] project_id: The ID of the project containing this table.
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> pulumi.Input[str]:
        """
        The ID of the dataset containing this table.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The ID of the project containing this table.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class DatasetAccessConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        description: NotRequired[pulumi.Input[str]]
        """
        Description of the expression. This is a longer text which describes the expression,
        e.g. when hovered over it in a UI.
        """
        location: NotRequired[pulumi.Input[str]]
        """
        String indicating the location of the expression for error reporting, e.g. a file
        name and a position in the file.
        """
        title: NotRequired[pulumi.Input[str]]
        """
        Title for the expression, i.e. a short string describing its purpose.
        This can be used e.g. in UIs which allow to enter the expression.
        """
elif False:
    DatasetAccessConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetAccessConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 title: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] expression: Textual representation of an expression in Common Expression Language syntax.
        :param pulumi.Input[str] description: Description of the expression. This is a longer text which describes the expression,
               e.g. when hovered over it in a UI.
        :param pulumi.Input[str] location: String indicating the location of the expression for error reporting, e.g. a file
               name and a position in the file.
        :param pulumi.Input[str] title: Title for the expression, i.e. a short string describing its purpose.
               This can be used e.g. in UIs which allow to enter the expression.
        """
        pulumi.set(__self__, "expression", expression)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        Description of the expression. This is a longer text which describes the expression,
        e.g. when hovered over it in a UI.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        String indicating the location of the expression for error reporting, e.g. a file
        name and a position in the file.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def title(self) -> Optional[pulumi.Input[str]]:
        """
        Title for the expression, i.e. a short string describing its purpose.
        This can be used e.g. in UIs which allow to enter the expression.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "title", value)


if not MYPY:
    class DatasetAccessDatasetArgsDict(TypedDict):
        dataset: pulumi.Input['DatasetAccessDatasetDatasetArgsDict']
        """
        The dataset this entry applies to
        Structure is documented below.
        """
        target_types: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Which resources in the dataset this entry applies to. Currently, only views are supported,
        but additional target types may be added in the future. Possible values: VIEWS
        """
elif False:
    DatasetAccessDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetAccessDatasetArgs:
    def __init__(__self__, *,
                 dataset: pulumi.Input['DatasetAccessDatasetDatasetArgs'],
                 target_types: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input['DatasetAccessDatasetDatasetArgs'] dataset: The dataset this entry applies to
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] target_types: Which resources in the dataset this entry applies to. Currently, only views are supported,
               but additional target types may be added in the future. Possible values: VIEWS
        """
        pulumi.set(__self__, "dataset", dataset)
        pulumi.set(__self__, "target_types", target_types)

    @property
    @pulumi.getter
    def dataset(self) -> pulumi.Input['DatasetAccessDatasetDatasetArgs']:
        """
        The dataset this entry applies to
        Structure is documented below.
        """
        return pulumi.get(self, "dataset")

    @dataset.setter
    def dataset(self, value: pulumi.Input['DatasetAccessDatasetDatasetArgs']):
        pulumi.set(self, "dataset", value)

    @property
    @pulumi.getter(name="targetTypes")
    def target_types(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Which resources in the dataset this entry applies to. Currently, only views are supported,
        but additional target types may be added in the future. Possible values: VIEWS
        """
        return pulumi.get(self, "target_types")

    @target_types.setter
    def target_types(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "target_types", value)


if not MYPY:
    class DatasetAccessDatasetDatasetArgsDict(TypedDict):
        dataset_id: pulumi.Input[str]
        """
        The ID of the dataset containing this table.
        """
        project_id: pulumi.Input[str]
        """
        The ID of the project containing this table.
        """
elif False:
    DatasetAccessDatasetDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetAccessDatasetDatasetArgs:
    def __init__(__self__, *,
                 dataset_id: pulumi.Input[str],
                 project_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] dataset_id: The ID of the dataset containing this table.
        :param pulumi.Input[str] project_id: The ID of the project containing this table.
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> pulumi.Input[str]:
        """
        The ID of the dataset containing this table.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The ID of the project containing this table.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class DatasetAccessRoutineArgsDict(TypedDict):
        dataset_id: pulumi.Input[str]
        """
        The ID of the dataset containing this table.
        """
        project_id: pulumi.Input[str]
        """
        The ID of the project containing this table.
        """
        routine_id: pulumi.Input[str]
        """
        The ID of the routine. The ID must contain only letters (a-z,
        A-Z), numbers (0-9), or underscores (_). The maximum length
        is 256 characters.
        """
elif False:
    DatasetAccessRoutineArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetAccessRoutineArgs:
    def __init__(__self__, *,
                 dataset_id: pulumi.Input[str],
                 project_id: pulumi.Input[str],
                 routine_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] dataset_id: The ID of the dataset containing this table.
        :param pulumi.Input[str] project_id: The ID of the project containing this table.
        :param pulumi.Input[str] routine_id: The ID of the routine. The ID must contain only letters (a-z,
               A-Z), numbers (0-9), or underscores (_). The maximum length
               is 256 characters.
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "routine_id", routine_id)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> pulumi.Input[str]:
        """
        The ID of the dataset containing this table.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The ID of the project containing this table.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="routineId")
    def routine_id(self) -> pulumi.Input[str]:
        """
        The ID of the routine. The ID must contain only letters (a-z,
        A-Z), numbers (0-9), or underscores (_). The maximum length
        is 256 characters.
        """
        return pulumi.get(self, "routine_id")

    @routine_id.setter
    def routine_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "routine_id", value)


if not MYPY:
    class DatasetAccessViewArgsDict(TypedDict):
        dataset_id: pulumi.Input[str]
        """
        The ID of the dataset containing this table.
        """
        project_id: pulumi.Input[str]
        """
        The ID of the project containing this table.
        """
        table_id: pulumi.Input[str]
        """
        The ID of the table. The ID must contain only letters (a-z,
        A-Z), numbers (0-9), or underscores (_). The maximum length
        is 1,024 characters.
        """
elif False:
    DatasetAccessViewArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetAccessViewArgs:
    def __init__(__self__, *,
                 dataset_id: pulumi.Input[str],
                 project_id: pulumi.Input[str],
                 table_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] dataset_id: The ID of the dataset containing this table.
        :param pulumi.Input[str] project_id: The ID of the project containing this table.
        :param pulumi.Input[str] table_id: The ID of the table. The ID must contain only letters (a-z,
               A-Z), numbers (0-9), or underscores (_). The maximum length
               is 1,024 characters.
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "table_id", table_id)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> pulumi.Input[str]:
        """
        The ID of the dataset containing this table.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The ID of the project containing this table.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="tableId")
    def table_id(self) -> pulumi.Input[str]:
        """
        The ID of the table. The ID must contain only letters (a-z,
        A-Z), numbers (0-9), or underscores (_). The maximum length
        is 1,024 characters.
        """
        return pulumi.get(self, "table_id")

    @table_id.setter
    def table_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_id", value)


if not MYPY:
    class DatasetDefaultEncryptionConfigurationArgsDict(TypedDict):
        kms_key_name: pulumi.Input[str]
        """
        Describes the Cloud KMS encryption key that will be used to protect destination
        BigQuery table. The BigQuery Service Account associated with your project requires
        access to this encryption key.
        """
elif False:
    DatasetDefaultEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetDefaultEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 kms_key_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] kms_key_name: Describes the Cloud KMS encryption key that will be used to protect destination
               BigQuery table. The BigQuery Service Account associated with your project requires
               access to this encryption key.
        """
        pulumi.set(__self__, "kms_key_name", kms_key_name)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> pulumi.Input[str]:
        """
        Describes the Cloud KMS encryption key that will be used to protect destination
        BigQuery table. The BigQuery Service Account associated with your project requires
        access to this encryption key.
        """
        return pulumi.get(self, "kms_key_name")

    @kms_key_name.setter
    def kms_key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "kms_key_name", value)


if not MYPY:
    class DatasetExternalCatalogDatasetOptionsArgsDict(TypedDict):
        default_storage_location_uri: NotRequired[pulumi.Input[str]]
        """
        The storage location URI for all tables in the dataset. Equivalent to hive metastore's
        database locationUri. Maximum length of 1024 characters.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of key value pairs defining the parameters and properties of the open source schema.
        Maximum size of 2Mib.
        """
elif False:
    DatasetExternalCatalogDatasetOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetExternalCatalogDatasetOptionsArgs:
    def __init__(__self__, *,
                 default_storage_location_uri: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] default_storage_location_uri: The storage location URI for all tables in the dataset. Equivalent to hive metastore's
               database locationUri. Maximum length of 1024 characters.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of key value pairs defining the parameters and properties of the open source schema.
               Maximum size of 2Mib.
        """
        if default_storage_location_uri is not None:
            pulumi.set(__self__, "default_storage_location_uri", default_storage_location_uri)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="defaultStorageLocationUri")
    def default_storage_location_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The storage location URI for all tables in the dataset. Equivalent to hive metastore's
        database locationUri. Maximum length of 1024 characters.
        """
        return pulumi.get(self, "default_storage_location_uri")

    @default_storage_location_uri.setter
    def default_storage_location_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "default_storage_location_uri", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of key value pairs defining the parameters and properties of the open source schema.
        Maximum size of 2Mib.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class DatasetExternalDatasetReferenceArgsDict(TypedDict):
        connection: pulumi.Input[str]
        """
        The connection id that is used to access the externalSource.
        Format: projects/{projectId}/locations/{locationId}/connections/{connectionId}
        """
        external_source: pulumi.Input[str]
        """
        External source that backs this dataset.
        """
elif False:
    DatasetExternalDatasetReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetExternalDatasetReferenceArgs:
    def __init__(__self__, *,
                 connection: pulumi.Input[str],
                 external_source: pulumi.Input[str]):
        """
        :param pulumi.Input[str] connection: The connection id that is used to access the externalSource.
               Format: projects/{projectId}/locations/{locationId}/connections/{connectionId}
        :param pulumi.Input[str] external_source: External source that backs this dataset.
        """
        pulumi.set(__self__, "connection", connection)
        pulumi.set(__self__, "external_source", external_source)

    @property
    @pulumi.getter
    def connection(self) -> pulumi.Input[str]:
        """
        The connection id that is used to access the externalSource.
        Format: projects/{projectId}/locations/{locationId}/connections/{connectionId}
        """
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: pulumi.Input[str]):
        pulumi.set(self, "connection", value)

    @property
    @pulumi.getter(name="externalSource")
    def external_source(self) -> pulumi.Input[str]:
        """
        External source that backs this dataset.
        """
        return pulumi.get(self, "external_source")

    @external_source.setter
    def external_source(self, value: pulumi.Input[str]):
        pulumi.set(self, "external_source", value)


if not MYPY:
    class DatasetIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    DatasetIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class DatasetIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    DatasetIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DatasetIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class IamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    IamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class IamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[str]
        title: pulumi.Input[str]
        description: NotRequired[pulumi.Input[str]]
elif False:
    IamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class IamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[str],
                 title: pulumi.Input[str],
                 description: Optional[pulumi.Input[str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class JobCopyArgsDict(TypedDict):
        source_tables: pulumi.Input[Sequence[pulumi.Input['JobCopySourceTableArgsDict']]]
        """
        Source tables to copy.
        Structure is documented below.
        """
        create_disposition: NotRequired[pulumi.Input[str]]
        """
        Specifies whether the job is allowed to create new tables. The following values are supported:
        CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table.
        CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result.
        Creation, truncation and append actions occur as one atomic update upon job completion
        Default value is `CREATE_IF_NEEDED`.
        Possible values are: `CREATE_IF_NEEDED`, `CREATE_NEVER`.
        """
        destination_encryption_configuration: NotRequired[pulumi.Input['JobCopyDestinationEncryptionConfigurationArgsDict']]
        """
        Custom encryption configuration (e.g., Cloud KMS keys)
        Structure is documented below.
        """
        destination_table: NotRequired[pulumi.Input['JobCopyDestinationTableArgsDict']]
        """
        The destination table.
        Structure is documented below.
        """
        write_disposition: NotRequired[pulumi.Input[str]]
        """
        Specifies the action that occurs if the destination table already exists. The following values are supported:
        WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result.
        WRITE_APPEND: If the table already exists, BigQuery appends the data to the table.
        WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result.
        Each action is atomic and only occurs if BigQuery is able to complete the job successfully.
        Creation, truncation and append actions occur as one atomic update upon job completion.
        Default value is `WRITE_EMPTY`.
        Possible values are: `WRITE_TRUNCATE`, `WRITE_APPEND`, `WRITE_EMPTY`.
        """
elif False:
    JobCopyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobCopyArgs:
    def __init__(__self__, *,
                 source_tables: pulumi.Input[Sequence[pulumi.Input['JobCopySourceTableArgs']]],
                 create_disposition: Optional[pulumi.Input[str]] = None,
                 destination_encryption_configuration: Optional[pulumi.Input['JobCopyDestinationEncryptionConfigurationArgs']] = None,
                 destination_table: Optional[pulumi.Input['JobCopyDestinationTableArgs']] = None,
                 write_disposition: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['JobCopySourceTableArgs']]] source_tables: Source tables to copy.
               Structure is documented below.
        :param pulumi.Input[str] create_disposition: Specifies whether the job is allowed to create new tables. The following values are supported:
               CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table.
               CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result.
               Creation, truncation and append actions occur as one atomic update upon job completion
               Default value is `CREATE_IF_NEEDED`.
               Possible values are: `CREATE_IF_NEEDED`, `CREATE_NEVER`.
        :param pulumi.Input['JobCopyDestinationEncryptionConfigurationArgs'] destination_encryption_configuration: Custom encryption configuration (e.g., Cloud KMS keys)
               Structure is documented below.
        :param pulumi.Input['JobCopyDestinationTableArgs'] destination_table: The destination table.
               Structure is documented below.
        :param pulumi.Input[str] write_disposition: Specifies the action that occurs if the destination table already exists. The following values are supported:
               WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result.
               WRITE_APPEND: If the table already exists, BigQuery appends the data to the table.
               WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result.
               Each action is atomic and only occurs if BigQuery is able to complete the job successfully.
               Creation, truncation and append actions occur as one atomic update upon job completion.
               Default value is `WRITE_EMPTY`.
               Possible values are: `WRITE_TRUNCATE`, `WRITE_APPEND`, `WRITE_EMPTY`.
        """
        pulumi.set(__self__, "source_tables", source_tables)
        if create_disposition is not None:
            pulumi.set(__self__, "create_disposition", create_disposition)
        if destination_encryption_configuration is not None:
            pulumi.set(__self__, "destination_encryption_configuration", destination_encryption_configuration)
        if destination_table is not None:
            pulumi.set(__self__, "destination_table", destination_table)
        if write_disposition is not None:
            pulumi.set(__self__, "write_disposition", write_disposition)

    @property
    @pulumi.getter(name="sourceTables")
    def source_tables(self) -> pulumi.Input[Sequence[pulumi.Input['JobCopySourceTableArgs']]]:
        """
        Source tables to copy.
        Structure is documented below.
        """
        return pulumi.get(self, "source_tables")

    @source_tables.setter
    def source_tables(self, value: pulumi.Input[Sequence[pulumi.Input['JobCopySourceTableArgs']]]):
        pulumi.set(self, "source_tables", value)

    @property
    @pulumi.getter(name="createDisposition")
    def create_disposition(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether the job is allowed to create new tables. The following values are supported:
        CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table.
        CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result.
        Creation, truncation and append actions occur as one atomic update upon job completion
        Default value is `CREATE_IF_NEEDED`.
        Possible values are: `CREATE_IF_NEEDED`, `CREATE_NEVER`.
        """
        return pulumi.get(self, "create_disposition")

    @create_disposition.setter
    def create_disposition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create_disposition", value)

    @property
    @pulumi.getter(name="destinationEncryptionConfiguration")
    def destination_encryption_configuration(self) -> Optional[pulumi.Input['JobCopyDestinationEncryptionConfigurationArgs']]:
        """
        Custom encryption configuration (e.g., Cloud KMS keys)
        Structure is documented below.
        """
        return pulumi.get(self, "destination_encryption_configuration")

    @destination_encryption_configuration.setter
    def destination_encryption_configuration(self, value: Optional[pulumi.Input['JobCopyDestinationEncryptionConfigurationArgs']]):
        pulumi.set(self, "destination_encryption_configuration", value)

    @property
    @pulumi.getter(name="destinationTable")
    def destination_table(self) -> Optional[pulumi.Input['JobCopyDestinationTableArgs']]:
        """
        The destination table.
        Structure is documented below.
        """
        return pulumi.get(self, "destination_table")

    @destination_table.setter
    def destination_table(self, value: Optional[pulumi.Input['JobCopyDestinationTableArgs']]):
        pulumi.set(self, "destination_table", value)

    @property
    @pulumi.getter(name="writeDisposition")
    def write_disposition(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the action that occurs if the destination table already exists. The following values are supported:
        WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result.
        WRITE_APPEND: If the table already exists, BigQuery appends the data to the table.
        WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result.
        Each action is atomic and only occurs if BigQuery is able to complete the job successfully.
        Creation, truncation and append actions occur as one atomic update upon job completion.
        Default value is `WRITE_EMPTY`.
        Possible values are: `WRITE_TRUNCATE`, `WRITE_APPEND`, `WRITE_EMPTY`.
        """
        return pulumi.get(self, "write_disposition")

    @write_disposition.setter
    def write_disposition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "write_disposition", value)


if not MYPY:
    class JobCopyDestinationEncryptionConfigurationArgsDict(TypedDict):
        kms_key_name: pulumi.Input[str]
        """
        Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table.
        The BigQuery Service Account associated with your project requires access to this encryption key.
        """
        kms_key_version: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Describes the Cloud KMS encryption key version used to protect destination BigQuery table.
        """
elif False:
    JobCopyDestinationEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobCopyDestinationEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 kms_key_name: pulumi.Input[str],
                 kms_key_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kms_key_name: Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table.
               The BigQuery Service Account associated with your project requires access to this encryption key.
        :param pulumi.Input[str] kms_key_version: (Output)
               Describes the Cloud KMS encryption key version used to protect destination BigQuery table.
        """
        pulumi.set(__self__, "kms_key_name", kms_key_name)
        if kms_key_version is not None:
            pulumi.set(__self__, "kms_key_version", kms_key_version)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> pulumi.Input[str]:
        """
        Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table.
        The BigQuery Service Account associated with your project requires access to this encryption key.
        """
        return pulumi.get(self, "kms_key_name")

    @kms_key_name.setter
    def kms_key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "kms_key_name", value)

    @property
    @pulumi.getter(name="kmsKeyVersion")
    def kms_key_version(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Describes the Cloud KMS encryption key version used to protect destination BigQuery table.
        """
        return pulumi.get(self, "kms_key_version")

    @kms_key_version.setter
    def kms_key_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_version", value)


if not MYPY:
    class JobCopyDestinationTableArgsDict(TypedDict):
        table_id: pulumi.Input[str]
        """
        The table. Can be specified `{{table_id}}` if `project_id` and `dataset_id` are also set,
        or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
        """
        dataset_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the dataset containing this table.
        """
        project_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the project containing this table.
        """
elif False:
    JobCopyDestinationTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobCopyDestinationTableArgs:
    def __init__(__self__, *,
                 table_id: pulumi.Input[str],
                 dataset_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] table_id: The table. Can be specified `{{table_id}}` if `project_id` and `dataset_id` are also set,
               or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
        :param pulumi.Input[str] dataset_id: The ID of the dataset containing this table.
        :param pulumi.Input[str] project_id: The ID of the project containing this table.
        """
        pulumi.set(__self__, "table_id", table_id)
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="tableId")
    def table_id(self) -> pulumi.Input[str]:
        """
        The table. Can be specified `{{table_id}}` if `project_id` and `dataset_id` are also set,
        or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
        """
        return pulumi.get(self, "table_id")

    @table_id.setter
    def table_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_id", value)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the dataset containing this table.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the project containing this table.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class JobCopySourceTableArgsDict(TypedDict):
        table_id: pulumi.Input[str]
        """
        The table. Can be specified `{{table_id}}` if `project_id` and `dataset_id` are also set,
        or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
        """
        dataset_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the dataset containing this table.
        """
        project_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the project containing this table.
        """
elif False:
    JobCopySourceTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobCopySourceTableArgs:
    def __init__(__self__, *,
                 table_id: pulumi.Input[str],
                 dataset_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] table_id: The table. Can be specified `{{table_id}}` if `project_id` and `dataset_id` are also set,
               or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
        :param pulumi.Input[str] dataset_id: The ID of the dataset containing this table.
        :param pulumi.Input[str] project_id: The ID of the project containing this table.
        """
        pulumi.set(__self__, "table_id", table_id)
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="tableId")
    def table_id(self) -> pulumi.Input[str]:
        """
        The table. Can be specified `{{table_id}}` if `project_id` and `dataset_id` are also set,
        or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
        """
        return pulumi.get(self, "table_id")

    @table_id.setter
    def table_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_id", value)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the dataset containing this table.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the project containing this table.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class JobExtractArgsDict(TypedDict):
        destination_uris: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of fully-qualified Google Cloud Storage URIs where the extracted table should be written.
        """
        compression: NotRequired[pulumi.Input[str]]
        """
        The compression type to use for exported files. Possible values include GZIP, DEFLATE, SNAPPY, and NONE.
        The default value is NONE. DEFLATE and SNAPPY are only supported for Avro.
        """
        destination_format: NotRequired[pulumi.Input[str]]
        """
        The exported file format. Possible values include CSV, NEWLINE_DELIMITED_JSON and AVRO for tables and SAVED_MODEL for models.
        The default value for tables is CSV. Tables with nested or repeated fields cannot be exported as CSV.
        The default value for models is SAVED_MODEL.
        """
        field_delimiter: NotRequired[pulumi.Input[str]]
        """
        When extracting data in CSV format, this defines the delimiter to use between fields in the exported data.
        Default is ','
        """
        print_header: NotRequired[pulumi.Input[bool]]
        """
        Whether to print out a header row in the results. Default is true.
        """
        source_model: NotRequired[pulumi.Input['JobExtractSourceModelArgsDict']]
        """
        A reference to the model being exported.
        Structure is documented below.
        """
        source_table: NotRequired[pulumi.Input['JobExtractSourceTableArgsDict']]
        """
        A reference to the table being exported.
        Structure is documented below.
        """
        use_avro_logical_types: NotRequired[pulumi.Input[bool]]
        """
        Whether to use logical types when extracting to AVRO format.
        """
elif False:
    JobExtractArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobExtractArgs:
    def __init__(__self__, *,
                 destination_uris: pulumi.Input[Sequence[pulumi.Input[str]]],
                 compression: Optional[pulumi.Input[str]] = None,
                 destination_format: Optional[pulumi.Input[str]] = None,
                 field_delimiter: Optional[pulumi.Input[str]] = None,
                 print_header: Optional[pulumi.Input[bool]] = None,
                 source_model: Optional[pulumi.Input['JobExtractSourceModelArgs']] = None,
                 source_table: Optional[pulumi.Input['JobExtractSourceTableArgs']] = None,
                 use_avro_logical_types: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] destination_uris: A list of fully-qualified Google Cloud Storage URIs where the extracted table should be written.
        :param pulumi.Input[str] compression: The compression type to use for exported files. Possible values include GZIP, DEFLATE, SNAPPY, and NONE.
               The default value is NONE. DEFLATE and SNAPPY are only supported for Avro.
        :param pulumi.Input[str] destination_format: The exported file format. Possible values include CSV, NEWLINE_DELIMITED_JSON and AVRO for tables and SAVED_MODEL for models.
               The default value for tables is CSV. Tables with nested or repeated fields cannot be exported as CSV.
               The default value for models is SAVED_MODEL.
        :param pulumi.Input[str] field_delimiter: When extracting data in CSV format, this defines the delimiter to use between fields in the exported data.
               Default is ','
        :param pulumi.Input[bool] print_header: Whether to print out a header row in the results. Default is true.
        :param pulumi.Input['JobExtractSourceModelArgs'] source_model: A reference to the model being exported.
               Structure is documented below.
        :param pulumi.Input['JobExtractSourceTableArgs'] source_table: A reference to the table being exported.
               Structure is documented below.
        :param pulumi.Input[bool] use_avro_logical_types: Whether to use logical types when extracting to AVRO format.
        """
        pulumi.set(__self__, "destination_uris", destination_uris)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if destination_format is not None:
            pulumi.set(__self__, "destination_format", destination_format)
        if field_delimiter is not None:
            pulumi.set(__self__, "field_delimiter", field_delimiter)
        if print_header is not None:
            pulumi.set(__self__, "print_header", print_header)
        if source_model is not None:
            pulumi.set(__self__, "source_model", source_model)
        if source_table is not None:
            pulumi.set(__self__, "source_table", source_table)
        if use_avro_logical_types is not None:
            pulumi.set(__self__, "use_avro_logical_types", use_avro_logical_types)

    @property
    @pulumi.getter(name="destinationUris")
    def destination_uris(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of fully-qualified Google Cloud Storage URIs where the extracted table should be written.
        """
        return pulumi.get(self, "destination_uris")

    @destination_uris.setter
    def destination_uris(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "destination_uris", value)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input[str]]:
        """
        The compression type to use for exported files. Possible values include GZIP, DEFLATE, SNAPPY, and NONE.
        The default value is NONE. DEFLATE and SNAPPY are only supported for Avro.
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter(name="destinationFormat")
    def destination_format(self) -> Optional[pulumi.Input[str]]:
        """
        The exported file format. Possible values include CSV, NEWLINE_DELIMITED_JSON and AVRO for tables and SAVED_MODEL for models.
        The default value for tables is CSV. Tables with nested or repeated fields cannot be exported as CSV.
        The default value for models is SAVED_MODEL.
        """
        return pulumi.get(self, "destination_format")

    @destination_format.setter
    def destination_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "destination_format", value)

    @property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        When extracting data in CSV format, this defines the delimiter to use between fields in the exported data.
        Default is ','
        """
        return pulumi.get(self, "field_delimiter")

    @field_delimiter.setter
    def field_delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_delimiter", value)

    @property
    @pulumi.getter(name="printHeader")
    def print_header(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to print out a header row in the results. Default is true.
        """
        return pulumi.get(self, "print_header")

    @print_header.setter
    def print_header(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "print_header", value)

    @property
    @pulumi.getter(name="sourceModel")
    def source_model(self) -> Optional[pulumi.Input['JobExtractSourceModelArgs']]:
        """
        A reference to the model being exported.
        Structure is documented below.
        """
        return pulumi.get(self, "source_model")

    @source_model.setter
    def source_model(self, value: Optional[pulumi.Input['JobExtractSourceModelArgs']]):
        pulumi.set(self, "source_model", value)

    @property
    @pulumi.getter(name="sourceTable")
    def source_table(self) -> Optional[pulumi.Input['JobExtractSourceTableArgs']]:
        """
        A reference to the table being exported.
        Structure is documented below.
        """
        return pulumi.get(self, "source_table")

    @source_table.setter
    def source_table(self, value: Optional[pulumi.Input['JobExtractSourceTableArgs']]):
        pulumi.set(self, "source_table", value)

    @property
    @pulumi.getter(name="useAvroLogicalTypes")
    def use_avro_logical_types(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to use logical types when extracting to AVRO format.
        """
        return pulumi.get(self, "use_avro_logical_types")

    @use_avro_logical_types.setter
    def use_avro_logical_types(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_avro_logical_types", value)


if not MYPY:
    class JobExtractSourceModelArgsDict(TypedDict):
        dataset_id: pulumi.Input[str]
        """
        The ID of the dataset containing this model.
        """
        model_id: pulumi.Input[str]
        """
        The ID of the model.

        - - -
        """
        project_id: pulumi.Input[str]
        """
        The ID of the project containing this model.
        """
elif False:
    JobExtractSourceModelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobExtractSourceModelArgs:
    def __init__(__self__, *,
                 dataset_id: pulumi.Input[str],
                 model_id: pulumi.Input[str],
                 project_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] dataset_id: The ID of the dataset containing this model.
        :param pulumi.Input[str] model_id: The ID of the model.
               
               - - -
        :param pulumi.Input[str] project_id: The ID of the project containing this model.
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "model_id", model_id)
        pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> pulumi.Input[str]:
        """
        The ID of the dataset containing this model.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="modelId")
    def model_id(self) -> pulumi.Input[str]:
        """
        The ID of the model.

        - - -
        """
        return pulumi.get(self, "model_id")

    @model_id.setter
    def model_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "model_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The ID of the project containing this model.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class JobExtractSourceTableArgsDict(TypedDict):
        table_id: pulumi.Input[str]
        """
        The table. Can be specified `{{table_id}}` if `project_id` and `dataset_id` are also set,
        or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
        """
        dataset_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the dataset containing this table.
        """
        project_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the project containing this table.
        """
elif False:
    JobExtractSourceTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobExtractSourceTableArgs:
    def __init__(__self__, *,
                 table_id: pulumi.Input[str],
                 dataset_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] table_id: The table. Can be specified `{{table_id}}` if `project_id` and `dataset_id` are also set,
               or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
        :param pulumi.Input[str] dataset_id: The ID of the dataset containing this table.
        :param pulumi.Input[str] project_id: The ID of the project containing this table.
        """
        pulumi.set(__self__, "table_id", table_id)
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="tableId")
    def table_id(self) -> pulumi.Input[str]:
        """
        The table. Can be specified `{{table_id}}` if `project_id` and `dataset_id` are also set,
        or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
        """
        return pulumi.get(self, "table_id")

    @table_id.setter
    def table_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_id", value)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the dataset containing this table.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the project containing this table.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class JobLoadArgsDict(TypedDict):
        destination_table: pulumi.Input['JobLoadDestinationTableArgsDict']
        """
        The destination table to load the data into.
        Structure is documented below.
        """
        source_uris: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The fully-qualified URIs that point to your data in Google Cloud.
        For Google Cloud Storage URIs: Each URI can contain one '\\*' wildcard character
        and it must come after the 'bucket' name. Size limits related to load jobs apply
        to external data sources. For Google Cloud Bigtable URIs: Exactly one URI can be
        specified and it has be a fully specified and valid HTTPS URL for a Google Cloud Bigtable table.
        For Google Cloud Datastore backups: Exactly one URI can be specified. Also, the '\\*' wildcard character is not allowed.
        """
        allow_jagged_rows: NotRequired[pulumi.Input[bool]]
        """
        Accept rows that are missing trailing optional columns. The missing values are treated as nulls.
        If false, records with missing trailing columns are treated as bad records, and if there are too many bad records,
        an invalid error is returned in the job result. The default value is false. Only applicable to CSV, ignored for other formats.
        """
        allow_quoted_newlines: NotRequired[pulumi.Input[bool]]
        """
        Indicates if BigQuery should allow quoted data sections that contain newline characters in a CSV file.
        The default value is false.
        """
        autodetect: NotRequired[pulumi.Input[bool]]
        """
        Indicates if we should automatically infer the options and schema for CSV and JSON sources.
        """
        create_disposition: NotRequired[pulumi.Input[str]]
        """
        Specifies whether the job is allowed to create new tables. The following values are supported:
        CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table.
        CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result.
        Creation, truncation and append actions occur as one atomic update upon job completion
        Default value is `CREATE_IF_NEEDED`.
        Possible values are: `CREATE_IF_NEEDED`, `CREATE_NEVER`.
        """
        destination_encryption_configuration: NotRequired[pulumi.Input['JobLoadDestinationEncryptionConfigurationArgsDict']]
        """
        Custom encryption configuration (e.g., Cloud KMS keys)
        Structure is documented below.
        """
        encoding: NotRequired[pulumi.Input[str]]
        """
        The character encoding of the data. The supported values are UTF-8 or ISO-8859-1.
        The default value is UTF-8. BigQuery decodes the data after the raw, binary data
        has been split using the values of the quote and fieldDelimiter properties.
        """
        field_delimiter: NotRequired[pulumi.Input[str]]
        """
        The separator for fields in a CSV file. The separator can be any ISO-8859-1 single-byte character.
        To use a character in the range 128-255, you must encode the character as UTF8. BigQuery converts
        the string to ISO-8859-1 encoding, and then uses the first byte of the encoded string to split the
        data in its raw, binary state. BigQuery also supports the escape sequence "\\t" to specify a tab separator.
        The default value is a comma (',').
        """
        ignore_unknown_values: NotRequired[pulumi.Input[bool]]
        """
        Indicates if BigQuery should allow extra values that are not represented in the table schema.
        If true, the extra values are ignored. If false, records with extra columns are treated as bad records,
        and if there are too many bad records, an invalid error is returned in the job result.
        The default value is false. The sourceFormat property determines what BigQuery treats as an extra value:
        CSV: Trailing columns
        JSON: Named values that don't match any column names
        """
        json_extension: NotRequired[pulumi.Input[str]]
        """
        If sourceFormat is set to newline-delimited JSON, indicates whether it should be processed as a JSON variant such as GeoJSON.
        For a sourceFormat other than JSON, omit this field. If the sourceFormat is newline-delimited JSON: - for newline-delimited
        GeoJSON: set to GEOJSON.
        """
        max_bad_records: NotRequired[pulumi.Input[int]]
        """
        The maximum number of bad records that BigQuery can ignore when running the job. If the number of bad records exceeds this value,
        an invalid error is returned in the job result. The default value is 0, which requires that all records are valid.
        """
        null_marker: NotRequired[pulumi.Input[str]]
        """
        Specifies a string that represents a null value in a CSV file. The default value is the empty string. If you set this
        property to a custom value, BigQuery throws an error if an
        empty string is present for all data types except for STRING and BYTE. For STRING and BYTE columns, BigQuery interprets the empty string as
        an empty value.
        """
        parquet_options: NotRequired[pulumi.Input['JobLoadParquetOptionsArgsDict']]
        """
        Parquet Options for load and make external tables.
        Structure is documented below.
        """
        projection_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        If sourceFormat is set to "DATASTORE_BACKUP", indicates which entity properties to load into BigQuery from a Cloud Datastore backup.
        Property names are case sensitive and must be top-level properties. If no properties are specified, BigQuery loads all properties.
        If any named property isn't found in the Cloud Datastore backup, an invalid error is returned in the job result.
        """
        quote: NotRequired[pulumi.Input[str]]
        """
        The value that is used to quote data sections in a CSV file. BigQuery converts the string to ISO-8859-1 encoding,
        and then uses the first byte of the encoded string to split the data in its raw, binary state.
        The default value is a double-quote ('"'). If your data does not contain quoted sections, set the property value to an empty string.
        If your data contains quoted newline characters, you must also set the allowQuotedNewlines property to true.
        """
        schema_update_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Allows the schema of the destination table to be updated as a side effect of the load job if a schema is autodetected or
        supplied in the job configuration. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND;
        when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators.
        For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following values are specified:
        ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.
        ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.
        """
        skip_leading_rows: NotRequired[pulumi.Input[int]]
        """
        The number of rows at the top of a CSV file that BigQuery will skip when loading the data.
        The default value is 0. This property is useful if you have header rows in the file that should be skipped.
        When autodetect is on, the behavior is the following:
        skipLeadingRows unspecified - Autodetect tries to detect headers in the first row. If they are not detected,
        the row is read as data. Otherwise data is read starting from the second row.
        skipLeadingRows is 0 - Instructs autodetect that there are no headers and data should be read starting from the first row.
        skipLeadingRows = N > 0 - Autodetect skips N-1 rows and tries to detect headers in row N. If headers are not detected,
        row N is just skipped. Otherwise row N is used to extract column names for the detected schema.
        """
        source_format: NotRequired[pulumi.Input[str]]
        """
        The format of the data files. For CSV files, specify "CSV". For datastore backups, specify "DATASTORE_BACKUP".
        For newline-delimited JSON, specify "NEWLINE_DELIMITED_JSON". For Avro, specify "AVRO". For parquet, specify "PARQUET".
        For orc, specify "ORC". [Beta] For Bigtable, specify "BIGTABLE".
        The default value is CSV.
        """
        time_partitioning: NotRequired[pulumi.Input['JobLoadTimePartitioningArgsDict']]
        """
        Time-based partitioning specification for the destination table.
        Structure is documented below.
        """
        write_disposition: NotRequired[pulumi.Input[str]]
        """
        Specifies the action that occurs if the destination table already exists. The following values are supported:
        WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result.
        WRITE_APPEND: If the table already exists, BigQuery appends the data to the table.
        WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result.
        Each action is atomic and only occurs if BigQuery is able to complete the job successfully.
        Creation, truncation and append actions occur as one atomic update upon job completion.
        Default value is `WRITE_EMPTY`.
        Possible values are: `WRITE_TRUNCATE`, `WRITE_APPEND`, `WRITE_EMPTY`.
        """
elif False:
    JobLoadArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobLoadArgs:
    def __init__(__self__, *,
                 destination_table: pulumi.Input['JobLoadDestinationTableArgs'],
                 source_uris: pulumi.Input[Sequence[pulumi.Input[str]]],
                 allow_jagged_rows: Optional[pulumi.Input[bool]] = None,
                 allow_quoted_newlines: Optional[pulumi.Input[bool]] = None,
                 autodetect: Optional[pulumi.Input[bool]] = None,
                 create_disposition: Optional[pulumi.Input[str]] = None,
                 destination_encryption_configuration: Optional[pulumi.Input['JobLoadDestinationEncryptionConfigurationArgs']] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 field_delimiter: Optional[pulumi.Input[str]] = None,
                 ignore_unknown_values: Optional[pulumi.Input[bool]] = None,
                 json_extension: Optional[pulumi.Input[str]] = None,
                 max_bad_records: Optional[pulumi.Input[int]] = None,
                 null_marker: Optional[pulumi.Input[str]] = None,
                 parquet_options: Optional[pulumi.Input['JobLoadParquetOptionsArgs']] = None,
                 projection_fields: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 quote: Optional[pulumi.Input[str]] = None,
                 schema_update_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 skip_leading_rows: Optional[pulumi.Input[int]] = None,
                 source_format: Optional[pulumi.Input[str]] = None,
                 time_partitioning: Optional[pulumi.Input['JobLoadTimePartitioningArgs']] = None,
                 write_disposition: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['JobLoadDestinationTableArgs'] destination_table: The destination table to load the data into.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_uris: The fully-qualified URIs that point to your data in Google Cloud.
               For Google Cloud Storage URIs: Each URI can contain one '\\*' wildcard character
               and it must come after the 'bucket' name. Size limits related to load jobs apply
               to external data sources. For Google Cloud Bigtable URIs: Exactly one URI can be
               specified and it has be a fully specified and valid HTTPS URL for a Google Cloud Bigtable table.
               For Google Cloud Datastore backups: Exactly one URI can be specified. Also, the '\\*' wildcard character is not allowed.
        :param pulumi.Input[bool] allow_jagged_rows: Accept rows that are missing trailing optional columns. The missing values are treated as nulls.
               If false, records with missing trailing columns are treated as bad records, and if there are too many bad records,
               an invalid error is returned in the job result. The default value is false. Only applicable to CSV, ignored for other formats.
        :param pulumi.Input[bool] allow_quoted_newlines: Indicates if BigQuery should allow quoted data sections that contain newline characters in a CSV file.
               The default value is false.
        :param pulumi.Input[bool] autodetect: Indicates if we should automatically infer the options and schema for CSV and JSON sources.
        :param pulumi.Input[str] create_disposition: Specifies whether the job is allowed to create new tables. The following values are supported:
               CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table.
               CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result.
               Creation, truncation and append actions occur as one atomic update upon job completion
               Default value is `CREATE_IF_NEEDED`.
               Possible values are: `CREATE_IF_NEEDED`, `CREATE_NEVER`.
        :param pulumi.Input['JobLoadDestinationEncryptionConfigurationArgs'] destination_encryption_configuration: Custom encryption configuration (e.g., Cloud KMS keys)
               Structure is documented below.
        :param pulumi.Input[str] encoding: The character encoding of the data. The supported values are UTF-8 or ISO-8859-1.
               The default value is UTF-8. BigQuery decodes the data after the raw, binary data
               has been split using the values of the quote and fieldDelimiter properties.
        :param pulumi.Input[str] field_delimiter: The separator for fields in a CSV file. The separator can be any ISO-8859-1 single-byte character.
               To use a character in the range 128-255, you must encode the character as UTF8. BigQuery converts
               the string to ISO-8859-1 encoding, and then uses the first byte of the encoded string to split the
               data in its raw, binary state. BigQuery also supports the escape sequence "\\t" to specify a tab separator.
               The default value is a comma (',').
        :param pulumi.Input[bool] ignore_unknown_values: Indicates if BigQuery should allow extra values that are not represented in the table schema.
               If true, the extra values are ignored. If false, records with extra columns are treated as bad records,
               and if there are too many bad records, an invalid error is returned in the job result.
               The default value is false. The sourceFormat property determines what BigQuery treats as an extra value:
               CSV: Trailing columns
               JSON: Named values that don't match any column names
        :param pulumi.Input[str] json_extension: If sourceFormat is set to newline-delimited JSON, indicates whether it should be processed as a JSON variant such as GeoJSON.
               For a sourceFormat other than JSON, omit this field. If the sourceFormat is newline-delimited JSON: - for newline-delimited
               GeoJSON: set to GEOJSON.
        :param pulumi.Input[int] max_bad_records: The maximum number of bad records that BigQuery can ignore when running the job. If the number of bad records exceeds this value,
               an invalid error is returned in the job result. The default value is 0, which requires that all records are valid.
        :param pulumi.Input[str] null_marker: Specifies a string that represents a null value in a CSV file. The default value is the empty string. If you set this
               property to a custom value, BigQuery throws an error if an
               empty string is present for all data types except for STRING and BYTE. For STRING and BYTE columns, BigQuery interprets the empty string as
               an empty value.
        :param pulumi.Input['JobLoadParquetOptionsArgs'] parquet_options: Parquet Options for load and make external tables.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] projection_fields: If sourceFormat is set to "DATASTORE_BACKUP", indicates which entity properties to load into BigQuery from a Cloud Datastore backup.
               Property names are case sensitive and must be top-level properties. If no properties are specified, BigQuery loads all properties.
               If any named property isn't found in the Cloud Datastore backup, an invalid error is returned in the job result.
        :param pulumi.Input[str] quote: The value that is used to quote data sections in a CSV file. BigQuery converts the string to ISO-8859-1 encoding,
               and then uses the first byte of the encoded string to split the data in its raw, binary state.
               The default value is a double-quote ('"'). If your data does not contain quoted sections, set the property value to an empty string.
               If your data contains quoted newline characters, you must also set the allowQuotedNewlines property to true.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] schema_update_options: Allows the schema of the destination table to be updated as a side effect of the load job if a schema is autodetected or
               supplied in the job configuration. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND;
               when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators.
               For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following values are specified:
               ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.
               ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.
        :param pulumi.Input[int] skip_leading_rows: The number of rows at the top of a CSV file that BigQuery will skip when loading the data.
               The default value is 0. This property is useful if you have header rows in the file that should be skipped.
               When autodetect is on, the behavior is the following:
               skipLeadingRows unspecified - Autodetect tries to detect headers in the first row. If they are not detected,
               the row is read as data. Otherwise data is read starting from the second row.
               skipLeadingRows is 0 - Instructs autodetect that there are no headers and data should be read starting from the first row.
               skipLeadingRows = N > 0 - Autodetect skips N-1 rows and tries to detect headers in row N. If headers are not detected,
               row N is just skipped. Otherwise row N is used to extract column names for the detected schema.
        :param pulumi.Input[str] source_format: The format of the data files. For CSV files, specify "CSV". For datastore backups, specify "DATASTORE_BACKUP".
               For newline-delimited JSON, specify "NEWLINE_DELIMITED_JSON". For Avro, specify "AVRO". For parquet, specify "PARQUET".
               For orc, specify "ORC". [Beta] For Bigtable, specify "BIGTABLE".
               The default value is CSV.
        :param pulumi.Input['JobLoadTimePartitioningArgs'] time_partitioning: Time-based partitioning specification for the destination table.
               Structure is documented below.
        :param pulumi.Input[str] write_disposition: Specifies the action that occurs if the destination table already exists. The following values are supported:
               WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result.
               WRITE_APPEND: If the table already exists, BigQuery appends the data to the table.
               WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result.
               Each action is atomic and only occurs if BigQuery is able to complete the job successfully.
               Creation, truncation and append actions occur as one atomic update upon job completion.
               Default value is `WRITE_EMPTY`.
               Possible values are: `WRITE_TRUNCATE`, `WRITE_APPEND`, `WRITE_EMPTY`.
        """
        pulumi.set(__self__, "destination_table", destination_table)
        pulumi.set(__self__, "source_uris", source_uris)
        if allow_jagged_rows is not None:
            pulumi.set(__self__, "allow_jagged_rows", allow_jagged_rows)
        if allow_quoted_newlines is not None:
            pulumi.set(__self__, "allow_quoted_newlines", allow_quoted_newlines)
        if autodetect is not None:
            pulumi.set(__self__, "autodetect", autodetect)
        if create_disposition is not None:
            pulumi.set(__self__, "create_disposition", create_disposition)
        if destination_encryption_configuration is not None:
            pulumi.set(__self__, "destination_encryption_configuration", destination_encryption_configuration)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if field_delimiter is not None:
            pulumi.set(__self__, "field_delimiter", field_delimiter)
        if ignore_unknown_values is not None:
            pulumi.set(__self__, "ignore_unknown_values", ignore_unknown_values)
        if json_extension is not None:
            pulumi.set(__self__, "json_extension", json_extension)
        if max_bad_records is not None:
            pulumi.set(__self__, "max_bad_records", max_bad_records)
        if null_marker is not None:
            pulumi.set(__self__, "null_marker", null_marker)
        if parquet_options is not None:
            pulumi.set(__self__, "parquet_options", parquet_options)
        if projection_fields is not None:
            pulumi.set(__self__, "projection_fields", projection_fields)
        if quote is not None:
            pulumi.set(__self__, "quote", quote)
        if schema_update_options is not None:
            pulumi.set(__self__, "schema_update_options", schema_update_options)
        if skip_leading_rows is not None:
            pulumi.set(__self__, "skip_leading_rows", skip_leading_rows)
        if source_format is not None:
            pulumi.set(__self__, "source_format", source_format)
        if time_partitioning is not None:
            pulumi.set(__self__, "time_partitioning", time_partitioning)
        if write_disposition is not None:
            pulumi.set(__self__, "write_disposition", write_disposition)

    @property
    @pulumi.getter(name="destinationTable")
    def destination_table(self) -> pulumi.Input['JobLoadDestinationTableArgs']:
        """
        The destination table to load the data into.
        Structure is documented below.
        """
        return pulumi.get(self, "destination_table")

    @destination_table.setter
    def destination_table(self, value: pulumi.Input['JobLoadDestinationTableArgs']):
        pulumi.set(self, "destination_table", value)

    @property
    @pulumi.getter(name="sourceUris")
    def source_uris(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The fully-qualified URIs that point to your data in Google Cloud.
        For Google Cloud Storage URIs: Each URI can contain one '\\*' wildcard character
        and it must come after the 'bucket' name. Size limits related to load jobs apply
        to external data sources. For Google Cloud Bigtable URIs: Exactly one URI can be
        specified and it has be a fully specified and valid HTTPS URL for a Google Cloud Bigtable table.
        For Google Cloud Datastore backups: Exactly one URI can be specified. Also, the '\\*' wildcard character is not allowed.
        """
        return pulumi.get(self, "source_uris")

    @source_uris.setter
    def source_uris(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "source_uris", value)

    @property
    @pulumi.getter(name="allowJaggedRows")
    def allow_jagged_rows(self) -> Optional[pulumi.Input[bool]]:
        """
        Accept rows that are missing trailing optional columns. The missing values are treated as nulls.
        If false, records with missing trailing columns are treated as bad records, and if there are too many bad records,
        an invalid error is returned in the job result. The default value is false. Only applicable to CSV, ignored for other formats.
        """
        return pulumi.get(self, "allow_jagged_rows")

    @allow_jagged_rows.setter
    def allow_jagged_rows(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_jagged_rows", value)

    @property
    @pulumi.getter(name="allowQuotedNewlines")
    def allow_quoted_newlines(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if BigQuery should allow quoted data sections that contain newline characters in a CSV file.
        The default value is false.
        """
        return pulumi.get(self, "allow_quoted_newlines")

    @allow_quoted_newlines.setter
    def allow_quoted_newlines(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_quoted_newlines", value)

    @property
    @pulumi.getter
    def autodetect(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if we should automatically infer the options and schema for CSV and JSON sources.
        """
        return pulumi.get(self, "autodetect")

    @autodetect.setter
    def autodetect(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "autodetect", value)

    @property
    @pulumi.getter(name="createDisposition")
    def create_disposition(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether the job is allowed to create new tables. The following values are supported:
        CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table.
        CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result.
        Creation, truncation and append actions occur as one atomic update upon job completion
        Default value is `CREATE_IF_NEEDED`.
        Possible values are: `CREATE_IF_NEEDED`, `CREATE_NEVER`.
        """
        return pulumi.get(self, "create_disposition")

    @create_disposition.setter
    def create_disposition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create_disposition", value)

    @property
    @pulumi.getter(name="destinationEncryptionConfiguration")
    def destination_encryption_configuration(self) -> Optional[pulumi.Input['JobLoadDestinationEncryptionConfigurationArgs']]:
        """
        Custom encryption configuration (e.g., Cloud KMS keys)
        Structure is documented below.
        """
        return pulumi.get(self, "destination_encryption_configuration")

    @destination_encryption_configuration.setter
    def destination_encryption_configuration(self, value: Optional[pulumi.Input['JobLoadDestinationEncryptionConfigurationArgs']]):
        pulumi.set(self, "destination_encryption_configuration", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        The character encoding of the data. The supported values are UTF-8 or ISO-8859-1.
        The default value is UTF-8. BigQuery decodes the data after the raw, binary data
        has been split using the values of the quote and fieldDelimiter properties.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        The separator for fields in a CSV file. The separator can be any ISO-8859-1 single-byte character.
        To use a character in the range 128-255, you must encode the character as UTF8. BigQuery converts
        the string to ISO-8859-1 encoding, and then uses the first byte of the encoded string to split the
        data in its raw, binary state. BigQuery also supports the escape sequence "\\t" to specify a tab separator.
        The default value is a comma (',').
        """
        return pulumi.get(self, "field_delimiter")

    @field_delimiter.setter
    def field_delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_delimiter", value)

    @property
    @pulumi.getter(name="ignoreUnknownValues")
    def ignore_unknown_values(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if BigQuery should allow extra values that are not represented in the table schema.
        If true, the extra values are ignored. If false, records with extra columns are treated as bad records,
        and if there are too many bad records, an invalid error is returned in the job result.
        The default value is false. The sourceFormat property determines what BigQuery treats as an extra value:
        CSV: Trailing columns
        JSON: Named values that don't match any column names
        """
        return pulumi.get(self, "ignore_unknown_values")

    @ignore_unknown_values.setter
    def ignore_unknown_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_unknown_values", value)

    @property
    @pulumi.getter(name="jsonExtension")
    def json_extension(self) -> Optional[pulumi.Input[str]]:
        """
        If sourceFormat is set to newline-delimited JSON, indicates whether it should be processed as a JSON variant such as GeoJSON.
        For a sourceFormat other than JSON, omit this field. If the sourceFormat is newline-delimited JSON: - for newline-delimited
        GeoJSON: set to GEOJSON.
        """
        return pulumi.get(self, "json_extension")

    @json_extension.setter
    def json_extension(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "json_extension", value)

    @property
    @pulumi.getter(name="maxBadRecords")
    def max_bad_records(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of bad records that BigQuery can ignore when running the job. If the number of bad records exceeds this value,
        an invalid error is returned in the job result. The default value is 0, which requires that all records are valid.
        """
        return pulumi.get(self, "max_bad_records")

    @max_bad_records.setter
    def max_bad_records(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bad_records", value)

    @property
    @pulumi.getter(name="nullMarker")
    def null_marker(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a string that represents a null value in a CSV file. The default value is the empty string. If you set this
        property to a custom value, BigQuery throws an error if an
        empty string is present for all data types except for STRING and BYTE. For STRING and BYTE columns, BigQuery interprets the empty string as
        an empty value.
        """
        return pulumi.get(self, "null_marker")

    @null_marker.setter
    def null_marker(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "null_marker", value)

    @property
    @pulumi.getter(name="parquetOptions")
    def parquet_options(self) -> Optional[pulumi.Input['JobLoadParquetOptionsArgs']]:
        """
        Parquet Options for load and make external tables.
        Structure is documented below.
        """
        return pulumi.get(self, "parquet_options")

    @parquet_options.setter
    def parquet_options(self, value: Optional[pulumi.Input['JobLoadParquetOptionsArgs']]):
        pulumi.set(self, "parquet_options", value)

    @property
    @pulumi.getter(name="projectionFields")
    def projection_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        If sourceFormat is set to "DATASTORE_BACKUP", indicates which entity properties to load into BigQuery from a Cloud Datastore backup.
        Property names are case sensitive and must be top-level properties. If no properties are specified, BigQuery loads all properties.
        If any named property isn't found in the Cloud Datastore backup, an invalid error is returned in the job result.
        """
        return pulumi.get(self, "projection_fields")

    @projection_fields.setter
    def projection_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "projection_fields", value)

    @property
    @pulumi.getter
    def quote(self) -> Optional[pulumi.Input[str]]:
        """
        The value that is used to quote data sections in a CSV file. BigQuery converts the string to ISO-8859-1 encoding,
        and then uses the first byte of the encoded string to split the data in its raw, binary state.
        The default value is a double-quote ('"'). If your data does not contain quoted sections, set the property value to an empty string.
        If your data contains quoted newline characters, you must also set the allowQuotedNewlines property to true.
        """
        return pulumi.get(self, "quote")

    @quote.setter
    def quote(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "quote", value)

    @property
    @pulumi.getter(name="schemaUpdateOptions")
    def schema_update_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Allows the schema of the destination table to be updated as a side effect of the load job if a schema is autodetected or
        supplied in the job configuration. Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND;
        when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table, specified by partition decorators.
        For normal tables, WRITE_TRUNCATE will always overwrite the schema. One or more of the following values are specified:
        ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.
        ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.
        """
        return pulumi.get(self, "schema_update_options")

    @schema_update_options.setter
    def schema_update_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "schema_update_options", value)

    @property
    @pulumi.getter(name="skipLeadingRows")
    def skip_leading_rows(self) -> Optional[pulumi.Input[int]]:
        """
        The number of rows at the top of a CSV file that BigQuery will skip when loading the data.
        The default value is 0. This property is useful if you have header rows in the file that should be skipped.
        When autodetect is on, the behavior is the following:
        skipLeadingRows unspecified - Autodetect tries to detect headers in the first row. If they are not detected,
        the row is read as data. Otherwise data is read starting from the second row.
        skipLeadingRows is 0 - Instructs autodetect that there are no headers and data should be read starting from the first row.
        skipLeadingRows = N > 0 - Autodetect skips N-1 rows and tries to detect headers in row N. If headers are not detected,
        row N is just skipped. Otherwise row N is used to extract column names for the detected schema.
        """
        return pulumi.get(self, "skip_leading_rows")

    @skip_leading_rows.setter
    def skip_leading_rows(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_leading_rows", value)

    @property
    @pulumi.getter(name="sourceFormat")
    def source_format(self) -> Optional[pulumi.Input[str]]:
        """
        The format of the data files. For CSV files, specify "CSV". For datastore backups, specify "DATASTORE_BACKUP".
        For newline-delimited JSON, specify "NEWLINE_DELIMITED_JSON". For Avro, specify "AVRO". For parquet, specify "PARQUET".
        For orc, specify "ORC". [Beta] For Bigtable, specify "BIGTABLE".
        The default value is CSV.
        """
        return pulumi.get(self, "source_format")

    @source_format.setter
    def source_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_format", value)

    @property
    @pulumi.getter(name="timePartitioning")
    def time_partitioning(self) -> Optional[pulumi.Input['JobLoadTimePartitioningArgs']]:
        """
        Time-based partitioning specification for the destination table.
        Structure is documented below.
        """
        return pulumi.get(self, "time_partitioning")

    @time_partitioning.setter
    def time_partitioning(self, value: Optional[pulumi.Input['JobLoadTimePartitioningArgs']]):
        pulumi.set(self, "time_partitioning", value)

    @property
    @pulumi.getter(name="writeDisposition")
    def write_disposition(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the action that occurs if the destination table already exists. The following values are supported:
        WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result.
        WRITE_APPEND: If the table already exists, BigQuery appends the data to the table.
        WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result.
        Each action is atomic and only occurs if BigQuery is able to complete the job successfully.
        Creation, truncation and append actions occur as one atomic update upon job completion.
        Default value is `WRITE_EMPTY`.
        Possible values are: `WRITE_TRUNCATE`, `WRITE_APPEND`, `WRITE_EMPTY`.
        """
        return pulumi.get(self, "write_disposition")

    @write_disposition.setter
    def write_disposition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "write_disposition", value)


if not MYPY:
    class JobLoadDestinationEncryptionConfigurationArgsDict(TypedDict):
        kms_key_name: pulumi.Input[str]
        """
        Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table.
        The BigQuery Service Account associated with your project requires access to this encryption key.
        """
        kms_key_version: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Describes the Cloud KMS encryption key version used to protect destination BigQuery table.
        """
elif False:
    JobLoadDestinationEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobLoadDestinationEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 kms_key_name: pulumi.Input[str],
                 kms_key_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kms_key_name: Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table.
               The BigQuery Service Account associated with your project requires access to this encryption key.
        :param pulumi.Input[str] kms_key_version: (Output)
               Describes the Cloud KMS encryption key version used to protect destination BigQuery table.
        """
        pulumi.set(__self__, "kms_key_name", kms_key_name)
        if kms_key_version is not None:
            pulumi.set(__self__, "kms_key_version", kms_key_version)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> pulumi.Input[str]:
        """
        Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table.
        The BigQuery Service Account associated with your project requires access to this encryption key.
        """
        return pulumi.get(self, "kms_key_name")

    @kms_key_name.setter
    def kms_key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "kms_key_name", value)

    @property
    @pulumi.getter(name="kmsKeyVersion")
    def kms_key_version(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Describes the Cloud KMS encryption key version used to protect destination BigQuery table.
        """
        return pulumi.get(self, "kms_key_version")

    @kms_key_version.setter
    def kms_key_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_version", value)


if not MYPY:
    class JobLoadDestinationTableArgsDict(TypedDict):
        table_id: pulumi.Input[str]
        """
        The table. Can be specified `{{table_id}}` if `project_id` and `dataset_id` are also set,
        or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
        """
        dataset_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the dataset containing this table.
        """
        project_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the project containing this table.
        """
elif False:
    JobLoadDestinationTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobLoadDestinationTableArgs:
    def __init__(__self__, *,
                 table_id: pulumi.Input[str],
                 dataset_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] table_id: The table. Can be specified `{{table_id}}` if `project_id` and `dataset_id` are also set,
               or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
        :param pulumi.Input[str] dataset_id: The ID of the dataset containing this table.
        :param pulumi.Input[str] project_id: The ID of the project containing this table.
        """
        pulumi.set(__self__, "table_id", table_id)
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="tableId")
    def table_id(self) -> pulumi.Input[str]:
        """
        The table. Can be specified `{{table_id}}` if `project_id` and `dataset_id` are also set,
        or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
        """
        return pulumi.get(self, "table_id")

    @table_id.setter
    def table_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_id", value)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the dataset containing this table.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the project containing this table.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class JobLoadParquetOptionsArgsDict(TypedDict):
        enable_list_inference: NotRequired[pulumi.Input[bool]]
        """
        If sourceFormat is set to PARQUET, indicates whether to use schema inference specifically for Parquet LIST logical type.
        """
        enum_as_string: NotRequired[pulumi.Input[bool]]
        """
        If sourceFormat is set to PARQUET, indicates whether to infer Parquet ENUM logical type as STRING instead of BYTES by default.
        """
elif False:
    JobLoadParquetOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobLoadParquetOptionsArgs:
    def __init__(__self__, *,
                 enable_list_inference: Optional[pulumi.Input[bool]] = None,
                 enum_as_string: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enable_list_inference: If sourceFormat is set to PARQUET, indicates whether to use schema inference specifically for Parquet LIST logical type.
        :param pulumi.Input[bool] enum_as_string: If sourceFormat is set to PARQUET, indicates whether to infer Parquet ENUM logical type as STRING instead of BYTES by default.
        """
        if enable_list_inference is not None:
            pulumi.set(__self__, "enable_list_inference", enable_list_inference)
        if enum_as_string is not None:
            pulumi.set(__self__, "enum_as_string", enum_as_string)

    @property
    @pulumi.getter(name="enableListInference")
    def enable_list_inference(self) -> Optional[pulumi.Input[bool]]:
        """
        If sourceFormat is set to PARQUET, indicates whether to use schema inference specifically for Parquet LIST logical type.
        """
        return pulumi.get(self, "enable_list_inference")

    @enable_list_inference.setter
    def enable_list_inference(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_list_inference", value)

    @property
    @pulumi.getter(name="enumAsString")
    def enum_as_string(self) -> Optional[pulumi.Input[bool]]:
        """
        If sourceFormat is set to PARQUET, indicates whether to infer Parquet ENUM logical type as STRING instead of BYTES by default.
        """
        return pulumi.get(self, "enum_as_string")

    @enum_as_string.setter
    def enum_as_string(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enum_as_string", value)


if not MYPY:
    class JobLoadTimePartitioningArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The only type supported is DAY, which will generate one partition per day. Providing an empty string used to cause an error,
        but in OnePlatform the field will be treated as unset.
        """
        expiration_ms: NotRequired[pulumi.Input[str]]
        """
        Number of milliseconds for which to keep the storage for a partition. A wrapper is used here because 0 is an invalid value.
        """
        field: NotRequired[pulumi.Input[str]]
        """
        If not set, the table is partitioned by pseudo column '_PARTITIONTIME'; if set, the table is partitioned by this field.
        The field must be a top-level TIMESTAMP or DATE field. Its mode must be NULLABLE or REQUIRED.
        A wrapper is used here because an empty string is an invalid value.
        """
elif False:
    JobLoadTimePartitioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobLoadTimePartitioningArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 expiration_ms: Optional[pulumi.Input[str]] = None,
                 field: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] type: The only type supported is DAY, which will generate one partition per day. Providing an empty string used to cause an error,
               but in OnePlatform the field will be treated as unset.
        :param pulumi.Input[str] expiration_ms: Number of milliseconds for which to keep the storage for a partition. A wrapper is used here because 0 is an invalid value.
        :param pulumi.Input[str] field: If not set, the table is partitioned by pseudo column '_PARTITIONTIME'; if set, the table is partitioned by this field.
               The field must be a top-level TIMESTAMP or DATE field. Its mode must be NULLABLE or REQUIRED.
               A wrapper is used here because an empty string is an invalid value.
        """
        pulumi.set(__self__, "type", type)
        if expiration_ms is not None:
            pulumi.set(__self__, "expiration_ms", expiration_ms)
        if field is not None:
            pulumi.set(__self__, "field", field)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The only type supported is DAY, which will generate one partition per day. Providing an empty string used to cause an error,
        but in OnePlatform the field will be treated as unset.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="expirationMs")
    def expiration_ms(self) -> Optional[pulumi.Input[str]]:
        """
        Number of milliseconds for which to keep the storage for a partition. A wrapper is used here because 0 is an invalid value.
        """
        return pulumi.get(self, "expiration_ms")

    @expiration_ms.setter
    def expiration_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "expiration_ms", value)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[str]]:
        """
        If not set, the table is partitioned by pseudo column '_PARTITIONTIME'; if set, the table is partitioned by this field.
        The field must be a top-level TIMESTAMP or DATE field. Its mode must be NULLABLE or REQUIRED.
        A wrapper is used here because an empty string is an invalid value.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field", value)


if not MYPY:
    class JobQueryArgsDict(TypedDict):
        query: pulumi.Input[str]
        """
        SQL query text to execute. The useLegacySql field can be used to indicate whether the query uses legacy SQL or standard SQL.
        *NOTE*: queries containing [DML language](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-manipulation-language)
        (`DELETE`, `UPDATE`, `MERGE`, `INSERT`) must specify `create_disposition = ""` and `write_disposition = ""`.
        """
        allow_large_results: NotRequired[pulumi.Input[bool]]
        """
        If true and query uses legacy SQL dialect, allows the query to produce arbitrarily large result tables at a slight cost in performance.
        Requires destinationTable to be set. For standard SQL queries, this flag is ignored and large results are always allowed.
        However, you must still set destinationTable when result size exceeds the allowed maximum response size.
        """
        create_disposition: NotRequired[pulumi.Input[str]]
        """
        Specifies whether the job is allowed to create new tables. The following values are supported:
        CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table.
        CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result.
        Creation, truncation and append actions occur as one atomic update upon job completion
        Default value is `CREATE_IF_NEEDED`.
        Possible values are: `CREATE_IF_NEEDED`, `CREATE_NEVER`.
        """
        default_dataset: NotRequired[pulumi.Input['JobQueryDefaultDatasetArgsDict']]
        """
        Specifies the default dataset to use for unqualified table names in the query. Note that this does not alter behavior of unqualified dataset names.
        Structure is documented below.
        """
        destination_encryption_configuration: NotRequired[pulumi.Input['JobQueryDestinationEncryptionConfigurationArgsDict']]
        """
        Custom encryption configuration (e.g., Cloud KMS keys)
        Structure is documented below.
        """
        destination_table: NotRequired[pulumi.Input['JobQueryDestinationTableArgsDict']]
        """
        Describes the table where the query results should be stored.
        This property must be set for large results that exceed the maximum response size.
        For queries that produce anonymous (cached) results, this field will be populated by BigQuery.
        Structure is documented below.
        """
        flatten_results: NotRequired[pulumi.Input[bool]]
        """
        If true and query uses legacy SQL dialect, flattens all nested and repeated fields in the query results.
        allowLargeResults must be true if this is set to false. For standard SQL queries, this flag is ignored and results are never flattened.
        """
        maximum_billing_tier: NotRequired[pulumi.Input[int]]
        """
        Limits the billing tier for this job. Queries that have resource usage beyond this tier will fail (without incurring a charge).
        If unspecified, this will be set to your project default.
        """
        maximum_bytes_billed: NotRequired[pulumi.Input[str]]
        """
        Limits the bytes billed for this job. Queries that will have bytes billed beyond this limit will fail (without incurring a charge).
        If unspecified, this will be set to your project default.
        """
        parameter_mode: NotRequired[pulumi.Input[str]]
        """
        Standard SQL only. Set to POSITIONAL to use positional (?) query parameters or to NAMED to use named (@myparam) query parameters in this query.
        """
        priority: NotRequired[pulumi.Input[str]]
        """
        Specifies a priority for the query.
        Default value is `INTERACTIVE`.
        Possible values are: `INTERACTIVE`, `BATCH`.
        """
        schema_update_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Allows the schema of the destination table to be updated as a side effect of the query job.
        Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND;
        when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table,
        specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema.
        One or more of the following values are specified:
        ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.
        ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.
        """
        script_options: NotRequired[pulumi.Input['JobQueryScriptOptionsArgsDict']]
        """
        Options controlling the execution of scripts.
        Structure is documented below.
        """
        use_legacy_sql: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether to use BigQuery's legacy SQL dialect for this query. The default value is true.
        If set to false, the query will use BigQuery's standard SQL.
        """
        use_query_cache: NotRequired[pulumi.Input[bool]]
        """
        Whether to look for the result in the query cache. The query cache is a best-effort cache that will be flushed whenever
        tables in the query are modified. Moreover, the query cache is only available when a query does not have a destination table specified.
        The default value is true.
        """
        user_defined_function_resources: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobQueryUserDefinedFunctionResourceArgsDict']]]]
        """
        Describes user-defined function resources used in the query.
        Structure is documented below.
        """
        write_disposition: NotRequired[pulumi.Input[str]]
        """
        Specifies the action that occurs if the destination table already exists. The following values are supported:
        WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result.
        WRITE_APPEND: If the table already exists, BigQuery appends the data to the table.
        WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result.
        Each action is atomic and only occurs if BigQuery is able to complete the job successfully.
        Creation, truncation and append actions occur as one atomic update upon job completion.
        Default value is `WRITE_EMPTY`.
        Possible values are: `WRITE_TRUNCATE`, `WRITE_APPEND`, `WRITE_EMPTY`.
        """
elif False:
    JobQueryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobQueryArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 allow_large_results: Optional[pulumi.Input[bool]] = None,
                 create_disposition: Optional[pulumi.Input[str]] = None,
                 default_dataset: Optional[pulumi.Input['JobQueryDefaultDatasetArgs']] = None,
                 destination_encryption_configuration: Optional[pulumi.Input['JobQueryDestinationEncryptionConfigurationArgs']] = None,
                 destination_table: Optional[pulumi.Input['JobQueryDestinationTableArgs']] = None,
                 flatten_results: Optional[pulumi.Input[bool]] = None,
                 maximum_billing_tier: Optional[pulumi.Input[int]] = None,
                 maximum_bytes_billed: Optional[pulumi.Input[str]] = None,
                 parameter_mode: Optional[pulumi.Input[str]] = None,
                 priority: Optional[pulumi.Input[str]] = None,
                 schema_update_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 script_options: Optional[pulumi.Input['JobQueryScriptOptionsArgs']] = None,
                 use_legacy_sql: Optional[pulumi.Input[bool]] = None,
                 use_query_cache: Optional[pulumi.Input[bool]] = None,
                 user_defined_function_resources: Optional[pulumi.Input[Sequence[pulumi.Input['JobQueryUserDefinedFunctionResourceArgs']]]] = None,
                 write_disposition: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] query: SQL query text to execute. The useLegacySql field can be used to indicate whether the query uses legacy SQL or standard SQL.
               *NOTE*: queries containing [DML language](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-manipulation-language)
               (`DELETE`, `UPDATE`, `MERGE`, `INSERT`) must specify `create_disposition = ""` and `write_disposition = ""`.
        :param pulumi.Input[bool] allow_large_results: If true and query uses legacy SQL dialect, allows the query to produce arbitrarily large result tables at a slight cost in performance.
               Requires destinationTable to be set. For standard SQL queries, this flag is ignored and large results are always allowed.
               However, you must still set destinationTable when result size exceeds the allowed maximum response size.
        :param pulumi.Input[str] create_disposition: Specifies whether the job is allowed to create new tables. The following values are supported:
               CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table.
               CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result.
               Creation, truncation and append actions occur as one atomic update upon job completion
               Default value is `CREATE_IF_NEEDED`.
               Possible values are: `CREATE_IF_NEEDED`, `CREATE_NEVER`.
        :param pulumi.Input['JobQueryDefaultDatasetArgs'] default_dataset: Specifies the default dataset to use for unqualified table names in the query. Note that this does not alter behavior of unqualified dataset names.
               Structure is documented below.
        :param pulumi.Input['JobQueryDestinationEncryptionConfigurationArgs'] destination_encryption_configuration: Custom encryption configuration (e.g., Cloud KMS keys)
               Structure is documented below.
        :param pulumi.Input['JobQueryDestinationTableArgs'] destination_table: Describes the table where the query results should be stored.
               This property must be set for large results that exceed the maximum response size.
               For queries that produce anonymous (cached) results, this field will be populated by BigQuery.
               Structure is documented below.
        :param pulumi.Input[bool] flatten_results: If true and query uses legacy SQL dialect, flattens all nested and repeated fields in the query results.
               allowLargeResults must be true if this is set to false. For standard SQL queries, this flag is ignored and results are never flattened.
        :param pulumi.Input[int] maximum_billing_tier: Limits the billing tier for this job. Queries that have resource usage beyond this tier will fail (without incurring a charge).
               If unspecified, this will be set to your project default.
        :param pulumi.Input[str] maximum_bytes_billed: Limits the bytes billed for this job. Queries that will have bytes billed beyond this limit will fail (without incurring a charge).
               If unspecified, this will be set to your project default.
        :param pulumi.Input[str] parameter_mode: Standard SQL only. Set to POSITIONAL to use positional (?) query parameters or to NAMED to use named (@myparam) query parameters in this query.
        :param pulumi.Input[str] priority: Specifies a priority for the query.
               Default value is `INTERACTIVE`.
               Possible values are: `INTERACTIVE`, `BATCH`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] schema_update_options: Allows the schema of the destination table to be updated as a side effect of the query job.
               Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND;
               when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table,
               specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema.
               One or more of the following values are specified:
               ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.
               ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.
        :param pulumi.Input['JobQueryScriptOptionsArgs'] script_options: Options controlling the execution of scripts.
               Structure is documented below.
        :param pulumi.Input[bool] use_legacy_sql: Specifies whether to use BigQuery's legacy SQL dialect for this query. The default value is true.
               If set to false, the query will use BigQuery's standard SQL.
        :param pulumi.Input[bool] use_query_cache: Whether to look for the result in the query cache. The query cache is a best-effort cache that will be flushed whenever
               tables in the query are modified. Moreover, the query cache is only available when a query does not have a destination table specified.
               The default value is true.
        :param pulumi.Input[Sequence[pulumi.Input['JobQueryUserDefinedFunctionResourceArgs']]] user_defined_function_resources: Describes user-defined function resources used in the query.
               Structure is documented below.
        :param pulumi.Input[str] write_disposition: Specifies the action that occurs if the destination table already exists. The following values are supported:
               WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result.
               WRITE_APPEND: If the table already exists, BigQuery appends the data to the table.
               WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result.
               Each action is atomic and only occurs if BigQuery is able to complete the job successfully.
               Creation, truncation and append actions occur as one atomic update upon job completion.
               Default value is `WRITE_EMPTY`.
               Possible values are: `WRITE_TRUNCATE`, `WRITE_APPEND`, `WRITE_EMPTY`.
        """
        pulumi.set(__self__, "query", query)
        if allow_large_results is not None:
            pulumi.set(__self__, "allow_large_results", allow_large_results)
        if create_disposition is not None:
            pulumi.set(__self__, "create_disposition", create_disposition)
        if default_dataset is not None:
            pulumi.set(__self__, "default_dataset", default_dataset)
        if destination_encryption_configuration is not None:
            pulumi.set(__self__, "destination_encryption_configuration", destination_encryption_configuration)
        if destination_table is not None:
            pulumi.set(__self__, "destination_table", destination_table)
        if flatten_results is not None:
            pulumi.set(__self__, "flatten_results", flatten_results)
        if maximum_billing_tier is not None:
            pulumi.set(__self__, "maximum_billing_tier", maximum_billing_tier)
        if maximum_bytes_billed is not None:
            pulumi.set(__self__, "maximum_bytes_billed", maximum_bytes_billed)
        if parameter_mode is not None:
            pulumi.set(__self__, "parameter_mode", parameter_mode)
        if priority is not None:
            pulumi.set(__self__, "priority", priority)
        if schema_update_options is not None:
            pulumi.set(__self__, "schema_update_options", schema_update_options)
        if script_options is not None:
            pulumi.set(__self__, "script_options", script_options)
        if use_legacy_sql is not None:
            pulumi.set(__self__, "use_legacy_sql", use_legacy_sql)
        if use_query_cache is not None:
            pulumi.set(__self__, "use_query_cache", use_query_cache)
        if user_defined_function_resources is not None:
            pulumi.set(__self__, "user_defined_function_resources", user_defined_function_resources)
        if write_disposition is not None:
            pulumi.set(__self__, "write_disposition", write_disposition)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        SQL query text to execute. The useLegacySql field can be used to indicate whether the query uses legacy SQL or standard SQL.
        *NOTE*: queries containing [DML language](https://cloud.google.com/bigquery/docs/reference/standard-sql/data-manipulation-language)
        (`DELETE`, `UPDATE`, `MERGE`, `INSERT`) must specify `create_disposition = ""` and `write_disposition = ""`.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="allowLargeResults")
    def allow_large_results(self) -> Optional[pulumi.Input[bool]]:
        """
        If true and query uses legacy SQL dialect, allows the query to produce arbitrarily large result tables at a slight cost in performance.
        Requires destinationTable to be set. For standard SQL queries, this flag is ignored and large results are always allowed.
        However, you must still set destinationTable when result size exceeds the allowed maximum response size.
        """
        return pulumi.get(self, "allow_large_results")

    @allow_large_results.setter
    def allow_large_results(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_large_results", value)

    @property
    @pulumi.getter(name="createDisposition")
    def create_disposition(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether the job is allowed to create new tables. The following values are supported:
        CREATE_IF_NEEDED: If the table does not exist, BigQuery creates the table.
        CREATE_NEVER: The table must already exist. If it does not, a 'notFound' error is returned in the job result.
        Creation, truncation and append actions occur as one atomic update upon job completion
        Default value is `CREATE_IF_NEEDED`.
        Possible values are: `CREATE_IF_NEEDED`, `CREATE_NEVER`.
        """
        return pulumi.get(self, "create_disposition")

    @create_disposition.setter
    def create_disposition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create_disposition", value)

    @property
    @pulumi.getter(name="defaultDataset")
    def default_dataset(self) -> Optional[pulumi.Input['JobQueryDefaultDatasetArgs']]:
        """
        Specifies the default dataset to use for unqualified table names in the query. Note that this does not alter behavior of unqualified dataset names.
        Structure is documented below.
        """
        return pulumi.get(self, "default_dataset")

    @default_dataset.setter
    def default_dataset(self, value: Optional[pulumi.Input['JobQueryDefaultDatasetArgs']]):
        pulumi.set(self, "default_dataset", value)

    @property
    @pulumi.getter(name="destinationEncryptionConfiguration")
    def destination_encryption_configuration(self) -> Optional[pulumi.Input['JobQueryDestinationEncryptionConfigurationArgs']]:
        """
        Custom encryption configuration (e.g., Cloud KMS keys)
        Structure is documented below.
        """
        return pulumi.get(self, "destination_encryption_configuration")

    @destination_encryption_configuration.setter
    def destination_encryption_configuration(self, value: Optional[pulumi.Input['JobQueryDestinationEncryptionConfigurationArgs']]):
        pulumi.set(self, "destination_encryption_configuration", value)

    @property
    @pulumi.getter(name="destinationTable")
    def destination_table(self) -> Optional[pulumi.Input['JobQueryDestinationTableArgs']]:
        """
        Describes the table where the query results should be stored.
        This property must be set for large results that exceed the maximum response size.
        For queries that produce anonymous (cached) results, this field will be populated by BigQuery.
        Structure is documented below.
        """
        return pulumi.get(self, "destination_table")

    @destination_table.setter
    def destination_table(self, value: Optional[pulumi.Input['JobQueryDestinationTableArgs']]):
        pulumi.set(self, "destination_table", value)

    @property
    @pulumi.getter(name="flattenResults")
    def flatten_results(self) -> Optional[pulumi.Input[bool]]:
        """
        If true and query uses legacy SQL dialect, flattens all nested and repeated fields in the query results.
        allowLargeResults must be true if this is set to false. For standard SQL queries, this flag is ignored and results are never flattened.
        """
        return pulumi.get(self, "flatten_results")

    @flatten_results.setter
    def flatten_results(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "flatten_results", value)

    @property
    @pulumi.getter(name="maximumBillingTier")
    def maximum_billing_tier(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the billing tier for this job. Queries that have resource usage beyond this tier will fail (without incurring a charge).
        If unspecified, this will be set to your project default.
        """
        return pulumi.get(self, "maximum_billing_tier")

    @maximum_billing_tier.setter
    def maximum_billing_tier(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "maximum_billing_tier", value)

    @property
    @pulumi.getter(name="maximumBytesBilled")
    def maximum_bytes_billed(self) -> Optional[pulumi.Input[str]]:
        """
        Limits the bytes billed for this job. Queries that will have bytes billed beyond this limit will fail (without incurring a charge).
        If unspecified, this will be set to your project default.
        """
        return pulumi.get(self, "maximum_bytes_billed")

    @maximum_bytes_billed.setter
    def maximum_bytes_billed(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "maximum_bytes_billed", value)

    @property
    @pulumi.getter(name="parameterMode")
    def parameter_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Standard SQL only. Set to POSITIONAL to use positional (?) query parameters or to NAMED to use named (@myparam) query parameters in this query.
        """
        return pulumi.get(self, "parameter_mode")

    @parameter_mode.setter
    def parameter_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "parameter_mode", value)

    @property
    @pulumi.getter
    def priority(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies a priority for the query.
        Default value is `INTERACTIVE`.
        Possible values are: `INTERACTIVE`, `BATCH`.
        """
        return pulumi.get(self, "priority")

    @priority.setter
    def priority(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "priority", value)

    @property
    @pulumi.getter(name="schemaUpdateOptions")
    def schema_update_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Allows the schema of the destination table to be updated as a side effect of the query job.
        Schema update options are supported in two cases: when writeDisposition is WRITE_APPEND;
        when writeDisposition is WRITE_TRUNCATE and the destination table is a partition of a table,
        specified by partition decorators. For normal tables, WRITE_TRUNCATE will always overwrite the schema.
        One or more of the following values are specified:
        ALLOW_FIELD_ADDITION: allow adding a nullable field to the schema.
        ALLOW_FIELD_RELAXATION: allow relaxing a required field in the original schema to nullable.
        """
        return pulumi.get(self, "schema_update_options")

    @schema_update_options.setter
    def schema_update_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "schema_update_options", value)

    @property
    @pulumi.getter(name="scriptOptions")
    def script_options(self) -> Optional[pulumi.Input['JobQueryScriptOptionsArgs']]:
        """
        Options controlling the execution of scripts.
        Structure is documented below.
        """
        return pulumi.get(self, "script_options")

    @script_options.setter
    def script_options(self, value: Optional[pulumi.Input['JobQueryScriptOptionsArgs']]):
        pulumi.set(self, "script_options", value)

    @property
    @pulumi.getter(name="useLegacySql")
    def use_legacy_sql(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether to use BigQuery's legacy SQL dialect for this query. The default value is true.
        If set to false, the query will use BigQuery's standard SQL.
        """
        return pulumi.get(self, "use_legacy_sql")

    @use_legacy_sql.setter
    def use_legacy_sql(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_legacy_sql", value)

    @property
    @pulumi.getter(name="useQueryCache")
    def use_query_cache(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to look for the result in the query cache. The query cache is a best-effort cache that will be flushed whenever
        tables in the query are modified. Moreover, the query cache is only available when a query does not have a destination table specified.
        The default value is true.
        """
        return pulumi.get(self, "use_query_cache")

    @use_query_cache.setter
    def use_query_cache(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_query_cache", value)

    @property
    @pulumi.getter(name="userDefinedFunctionResources")
    def user_defined_function_resources(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobQueryUserDefinedFunctionResourceArgs']]]]:
        """
        Describes user-defined function resources used in the query.
        Structure is documented below.
        """
        return pulumi.get(self, "user_defined_function_resources")

    @user_defined_function_resources.setter
    def user_defined_function_resources(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobQueryUserDefinedFunctionResourceArgs']]]]):
        pulumi.set(self, "user_defined_function_resources", value)

    @property
    @pulumi.getter(name="writeDisposition")
    def write_disposition(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the action that occurs if the destination table already exists. The following values are supported:
        WRITE_TRUNCATE: If the table already exists, BigQuery overwrites the table data and uses the schema from the query result.
        WRITE_APPEND: If the table already exists, BigQuery appends the data to the table.
        WRITE_EMPTY: If the table already exists and contains data, a 'duplicate' error is returned in the job result.
        Each action is atomic and only occurs if BigQuery is able to complete the job successfully.
        Creation, truncation and append actions occur as one atomic update upon job completion.
        Default value is `WRITE_EMPTY`.
        Possible values are: `WRITE_TRUNCATE`, `WRITE_APPEND`, `WRITE_EMPTY`.
        """
        return pulumi.get(self, "write_disposition")

    @write_disposition.setter
    def write_disposition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "write_disposition", value)


if not MYPY:
    class JobQueryDefaultDatasetArgsDict(TypedDict):
        dataset_id: pulumi.Input[str]
        """
        The dataset. Can be specified `{{dataset_id}}` if `project_id` is also set,
        or of the form `projects/{{project}}/datasets/{{dataset_id}}` if not.
        """
        project_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the project containing this table.
        """
elif False:
    JobQueryDefaultDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobQueryDefaultDatasetArgs:
    def __init__(__self__, *,
                 dataset_id: pulumi.Input[str],
                 project_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dataset_id: The dataset. Can be specified `{{dataset_id}}` if `project_id` is also set,
               or of the form `projects/{{project}}/datasets/{{dataset_id}}` if not.
        :param pulumi.Input[str] project_id: The ID of the project containing this table.
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> pulumi.Input[str]:
        """
        The dataset. Can be specified `{{dataset_id}}` if `project_id` is also set,
        or of the form `projects/{{project}}/datasets/{{dataset_id}}` if not.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the project containing this table.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class JobQueryDestinationEncryptionConfigurationArgsDict(TypedDict):
        kms_key_name: pulumi.Input[str]
        """
        Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table.
        The BigQuery Service Account associated with your project requires access to this encryption key.
        """
        kms_key_version: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Describes the Cloud KMS encryption key version used to protect destination BigQuery table.
        """
elif False:
    JobQueryDestinationEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobQueryDestinationEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 kms_key_name: pulumi.Input[str],
                 kms_key_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kms_key_name: Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table.
               The BigQuery Service Account associated with your project requires access to this encryption key.
        :param pulumi.Input[str] kms_key_version: (Output)
               Describes the Cloud KMS encryption key version used to protect destination BigQuery table.
        """
        pulumi.set(__self__, "kms_key_name", kms_key_name)
        if kms_key_version is not None:
            pulumi.set(__self__, "kms_key_version", kms_key_version)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> pulumi.Input[str]:
        """
        Describes the Cloud KMS encryption key that will be used to protect destination BigQuery table.
        The BigQuery Service Account associated with your project requires access to this encryption key.
        """
        return pulumi.get(self, "kms_key_name")

    @kms_key_name.setter
    def kms_key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "kms_key_name", value)

    @property
    @pulumi.getter(name="kmsKeyVersion")
    def kms_key_version(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Describes the Cloud KMS encryption key version used to protect destination BigQuery table.
        """
        return pulumi.get(self, "kms_key_version")

    @kms_key_version.setter
    def kms_key_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_version", value)


if not MYPY:
    class JobQueryDestinationTableArgsDict(TypedDict):
        table_id: pulumi.Input[str]
        """
        The table. Can be specified `{{table_id}}` if `project_id` and `dataset_id` are also set,
        or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
        """
        dataset_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the dataset containing this table.
        """
        project_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the project containing this table.
        """
elif False:
    JobQueryDestinationTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobQueryDestinationTableArgs:
    def __init__(__self__, *,
                 table_id: pulumi.Input[str],
                 dataset_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] table_id: The table. Can be specified `{{table_id}}` if `project_id` and `dataset_id` are also set,
               or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
        :param pulumi.Input[str] dataset_id: The ID of the dataset containing this table.
        :param pulumi.Input[str] project_id: The ID of the project containing this table.
        """
        pulumi.set(__self__, "table_id", table_id)
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="tableId")
    def table_id(self) -> pulumi.Input[str]:
        """
        The table. Can be specified `{{table_id}}` if `project_id` and `dataset_id` are also set,
        or of the form `projects/{{project}}/datasets/{{dataset_id}}/tables/{{table_id}}` if not.
        """
        return pulumi.get(self, "table_id")

    @table_id.setter
    def table_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_id", value)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the dataset containing this table.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the project containing this table.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class JobQueryScriptOptionsArgsDict(TypedDict):
        key_result_statement: NotRequired[pulumi.Input[str]]
        """
        Determines which statement in the script represents the "key result",
        used to populate the schema and query results of the script job.
        Possible values are: `LAST`, `FIRST_SELECT`.
        """
        statement_byte_budget: NotRequired[pulumi.Input[str]]
        """
        Limit on the number of bytes billed per statement. Exceeding this budget results in an error.
        """
        statement_timeout_ms: NotRequired[pulumi.Input[str]]
        """
        Timeout period for each statement in a script.
        """
elif False:
    JobQueryScriptOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobQueryScriptOptionsArgs:
    def __init__(__self__, *,
                 key_result_statement: Optional[pulumi.Input[str]] = None,
                 statement_byte_budget: Optional[pulumi.Input[str]] = None,
                 statement_timeout_ms: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key_result_statement: Determines which statement in the script represents the "key result",
               used to populate the schema and query results of the script job.
               Possible values are: `LAST`, `FIRST_SELECT`.
        :param pulumi.Input[str] statement_byte_budget: Limit on the number of bytes billed per statement. Exceeding this budget results in an error.
        :param pulumi.Input[str] statement_timeout_ms: Timeout period for each statement in a script.
        """
        if key_result_statement is not None:
            pulumi.set(__self__, "key_result_statement", key_result_statement)
        if statement_byte_budget is not None:
            pulumi.set(__self__, "statement_byte_budget", statement_byte_budget)
        if statement_timeout_ms is not None:
            pulumi.set(__self__, "statement_timeout_ms", statement_timeout_ms)

    @property
    @pulumi.getter(name="keyResultStatement")
    def key_result_statement(self) -> Optional[pulumi.Input[str]]:
        """
        Determines which statement in the script represents the "key result",
        used to populate the schema and query results of the script job.
        Possible values are: `LAST`, `FIRST_SELECT`.
        """
        return pulumi.get(self, "key_result_statement")

    @key_result_statement.setter
    def key_result_statement(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key_result_statement", value)

    @property
    @pulumi.getter(name="statementByteBudget")
    def statement_byte_budget(self) -> Optional[pulumi.Input[str]]:
        """
        Limit on the number of bytes billed per statement. Exceeding this budget results in an error.
        """
        return pulumi.get(self, "statement_byte_budget")

    @statement_byte_budget.setter
    def statement_byte_budget(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "statement_byte_budget", value)

    @property
    @pulumi.getter(name="statementTimeoutMs")
    def statement_timeout_ms(self) -> Optional[pulumi.Input[str]]:
        """
        Timeout period for each statement in a script.
        """
        return pulumi.get(self, "statement_timeout_ms")

    @statement_timeout_ms.setter
    def statement_timeout_ms(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "statement_timeout_ms", value)


if not MYPY:
    class JobQueryUserDefinedFunctionResourceArgsDict(TypedDict):
        inline_code: NotRequired[pulumi.Input[str]]
        """
        An inline resource that contains code for a user-defined function (UDF).
        Providing a inline code resource is equivalent to providing a URI for a file containing the same code.
        """
        resource_uri: NotRequired[pulumi.Input[str]]
        """
        A code resource to load from a Google Cloud Storage URI (gs://bucket/path).
        """
elif False:
    JobQueryUserDefinedFunctionResourceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobQueryUserDefinedFunctionResourceArgs:
    def __init__(__self__, *,
                 inline_code: Optional[pulumi.Input[str]] = None,
                 resource_uri: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] inline_code: An inline resource that contains code for a user-defined function (UDF).
               Providing a inline code resource is equivalent to providing a URI for a file containing the same code.
        :param pulumi.Input[str] resource_uri: A code resource to load from a Google Cloud Storage URI (gs://bucket/path).
        """
        if inline_code is not None:
            pulumi.set(__self__, "inline_code", inline_code)
        if resource_uri is not None:
            pulumi.set(__self__, "resource_uri", resource_uri)

    @property
    @pulumi.getter(name="inlineCode")
    def inline_code(self) -> Optional[pulumi.Input[str]]:
        """
        An inline resource that contains code for a user-defined function (UDF).
        Providing a inline code resource is equivalent to providing a URI for a file containing the same code.
        """
        return pulumi.get(self, "inline_code")

    @inline_code.setter
    def inline_code(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "inline_code", value)

    @property
    @pulumi.getter(name="resourceUri")
    def resource_uri(self) -> Optional[pulumi.Input[str]]:
        """
        A code resource to load from a Google Cloud Storage URI (gs://bucket/path).
        """
        return pulumi.get(self, "resource_uri")

    @resource_uri.setter
    def resource_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_uri", value)


if not MYPY:
    class JobStatusArgsDict(TypedDict):
        error_results: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobStatusErrorResultArgsDict']]]]
        """
        (Output)
        Final error result of the job. If present, indicates that the job has completed and was unsuccessful.
        Structure is documented below.
        """
        errors: NotRequired[pulumi.Input[Sequence[pulumi.Input['JobStatusErrorArgsDict']]]]
        """
        (Output)
        The first errors encountered during the running of the job. The final message
        includes the number of errors that caused the process to stop. Errors here do
        not necessarily mean that the job has not completed or was unsuccessful.
        Structure is documented below.
        """
        state: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Running state of the job. Valid states include 'PENDING', 'RUNNING', and 'DONE'.
        """
elif False:
    JobStatusArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobStatusArgs:
    def __init__(__self__, *,
                 error_results: Optional[pulumi.Input[Sequence[pulumi.Input['JobStatusErrorResultArgs']]]] = None,
                 errors: Optional[pulumi.Input[Sequence[pulumi.Input['JobStatusErrorArgs']]]] = None,
                 state: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['JobStatusErrorResultArgs']]] error_results: (Output)
               Final error result of the job. If present, indicates that the job has completed and was unsuccessful.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['JobStatusErrorArgs']]] errors: (Output)
               The first errors encountered during the running of the job. The final message
               includes the number of errors that caused the process to stop. Errors here do
               not necessarily mean that the job has not completed or was unsuccessful.
               Structure is documented below.
        :param pulumi.Input[str] state: (Output)
               Running state of the job. Valid states include 'PENDING', 'RUNNING', and 'DONE'.
        """
        if error_results is not None:
            pulumi.set(__self__, "error_results", error_results)
        if errors is not None:
            pulumi.set(__self__, "errors", errors)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter(name="errorResults")
    def error_results(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobStatusErrorResultArgs']]]]:
        """
        (Output)
        Final error result of the job. If present, indicates that the job has completed and was unsuccessful.
        Structure is documented below.
        """
        return pulumi.get(self, "error_results")

    @error_results.setter
    def error_results(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobStatusErrorResultArgs']]]]):
        pulumi.set(self, "error_results", value)

    @property
    @pulumi.getter
    def errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['JobStatusErrorArgs']]]]:
        """
        (Output)
        The first errors encountered during the running of the job. The final message
        includes the number of errors that caused the process to stop. Errors here do
        not necessarily mean that the job has not completed or was unsuccessful.
        Structure is documented below.
        """
        return pulumi.get(self, "errors")

    @errors.setter
    def errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['JobStatusErrorArgs']]]]):
        pulumi.set(self, "errors", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Running state of the job. Valid states include 'PENDING', 'RUNNING', and 'DONE'.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class JobStatusErrorArgsDict(TypedDict):
        location: NotRequired[pulumi.Input[str]]
        """
        Specifies where the error occurred, if present.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        A human-readable description of the error.
        """
        reason: NotRequired[pulumi.Input[str]]
        """
        A short error code that summarizes the error.
        """
elif False:
    JobStatusErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobStatusErrorArgs:
    def __init__(__self__, *,
                 location: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] location: Specifies where the error occurred, if present.
        :param pulumi.Input[str] message: A human-readable description of the error.
        :param pulumi.Input[str] reason: A short error code that summarizes the error.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies where the error occurred, if present.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A human-readable description of the error.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        A short error code that summarizes the error.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


if not MYPY:
    class JobStatusErrorResultArgsDict(TypedDict):
        location: NotRequired[pulumi.Input[str]]
        """
        Specifies where the error occurred, if present.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        A human-readable description of the error.
        """
        reason: NotRequired[pulumi.Input[str]]
        """
        A short error code that summarizes the error.
        """
elif False:
    JobStatusErrorResultArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class JobStatusErrorResultArgs:
    def __init__(__self__, *,
                 location: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] location: Specifies where the error occurred, if present.
        :param pulumi.Input[str] message: A human-readable description of the error.
        :param pulumi.Input[str] reason: A short error code that summarizes the error.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies where the error occurred, if present.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A human-readable description of the error.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        A short error code that summarizes the error.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


if not MYPY:
    class ReservationAutoscaleArgsDict(TypedDict):
        current_slots: NotRequired[pulumi.Input[int]]
        """
        (Output)
        The slot capacity added to this reservation when autoscale happens. Will be between [0, max_slots].
        """
        max_slots: NotRequired[pulumi.Input[int]]
        """
        Number of slots to be scaled when needed.
        """
elif False:
    ReservationAutoscaleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReservationAutoscaleArgs:
    def __init__(__self__, *,
                 current_slots: Optional[pulumi.Input[int]] = None,
                 max_slots: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] current_slots: (Output)
               The slot capacity added to this reservation when autoscale happens. Will be between [0, max_slots].
        :param pulumi.Input[int] max_slots: Number of slots to be scaled when needed.
        """
        if current_slots is not None:
            pulumi.set(__self__, "current_slots", current_slots)
        if max_slots is not None:
            pulumi.set(__self__, "max_slots", max_slots)

    @property
    @pulumi.getter(name="currentSlots")
    def current_slots(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        The slot capacity added to this reservation when autoscale happens. Will be between [0, max_slots].
        """
        return pulumi.get(self, "current_slots")

    @current_slots.setter
    def current_slots(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "current_slots", value)

    @property
    @pulumi.getter(name="maxSlots")
    def max_slots(self) -> Optional[pulumi.Input[int]]:
        """
        Number of slots to be scaled when needed.
        """
        return pulumi.get(self, "max_slots")

    @max_slots.setter
    def max_slots(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_slots", value)


if not MYPY:
    class RoutineArgumentArgsDict(TypedDict):
        argument_kind: NotRequired[pulumi.Input[str]]
        """
        Defaults to FIXED_TYPE.
        Default value is `FIXED_TYPE`.
        Possible values are: `FIXED_TYPE`, `ANY_TYPE`.
        """
        data_type: NotRequired[pulumi.Input[str]]
        """
        A JSON schema for the data type. Required unless argumentKind = ANY_TYPE.
        ~>**NOTE**: Because this field expects a JSON string, any changes to the string
        will create a diff, even if the JSON itself hasn't changed. If the API returns
        a different value for the same schema, e.g. it switched the order of values
        or replaced STRUCT field type with RECORD field type, we currently cannot
        suppress the recurring diff this causes. As a workaround, we recommend using
        the schema as returned by the API.
        """
        mode: NotRequired[pulumi.Input[str]]
        """
        Specifies whether the argument is input or output. Can be set for procedures only.
        Possible values are: `IN`, `OUT`, `INOUT`.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        The name of this argument. Can be absent for function return argument.
        """
elif False:
    RoutineArgumentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutineArgumentArgs:
    def __init__(__self__, *,
                 argument_kind: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 mode: Optional[pulumi.Input[str]] = None,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] argument_kind: Defaults to FIXED_TYPE.
               Default value is `FIXED_TYPE`.
               Possible values are: `FIXED_TYPE`, `ANY_TYPE`.
        :param pulumi.Input[str] data_type: A JSON schema for the data type. Required unless argumentKind = ANY_TYPE.
               ~>**NOTE**: Because this field expects a JSON string, any changes to the string
               will create a diff, even if the JSON itself hasn't changed. If the API returns
               a different value for the same schema, e.g. it switched the order of values
               or replaced STRUCT field type with RECORD field type, we currently cannot
               suppress the recurring diff this causes. As a workaround, we recommend using
               the schema as returned by the API.
        :param pulumi.Input[str] mode: Specifies whether the argument is input or output. Can be set for procedures only.
               Possible values are: `IN`, `OUT`, `INOUT`.
        :param pulumi.Input[str] name: The name of this argument. Can be absent for function return argument.
        """
        if argument_kind is not None:
            pulumi.set(__self__, "argument_kind", argument_kind)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="argumentKind")
    def argument_kind(self) -> Optional[pulumi.Input[str]]:
        """
        Defaults to FIXED_TYPE.
        Default value is `FIXED_TYPE`.
        Possible values are: `FIXED_TYPE`, `ANY_TYPE`.
        """
        return pulumi.get(self, "argument_kind")

    @argument_kind.setter
    def argument_kind(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "argument_kind", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON schema for the data type. Required unless argumentKind = ANY_TYPE.
        ~>**NOTE**: Because this field expects a JSON string, any changes to the string
        will create a diff, even if the JSON itself hasn't changed. If the API returns
        a different value for the same schema, e.g. it switched the order of values
        or replaced STRUCT field type with RECORD field type, we currently cannot
        suppress the recurring diff this causes. As a workaround, we recommend using
        the schema as returned by the API.
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies whether the argument is input or output. Can be set for procedures only.
        Possible values are: `IN`, `OUT`, `INOUT`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of this argument. Can be absent for function return argument.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class RoutineRemoteFunctionOptionsArgsDict(TypedDict):
        connection: NotRequired[pulumi.Input[str]]
        """
        Fully qualified name of the user-provided connection object which holds
        the authentication information to send requests to the remote service.
        Format: "projects/{projectId}/locations/{locationId}/connections/{connectionId}"
        """
        endpoint: NotRequired[pulumi.Input[str]]
        """
        Endpoint of the user-provided remote service, e.g.
        `https://us-east1-my_gcf_project.cloudfunctions.net/remote_add`
        """
        max_batching_rows: NotRequired[pulumi.Input[str]]
        """
        Max number of rows in each batch sent to the remote service. If absent or if 0,
        BigQuery dynamically decides the number of rows in a batch.
        """
        user_defined_context: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        User-defined context as a set of key/value pairs, which will be sent as function
        invocation context together with batched arguments in the requests to the remote
        service. The total number of bytes of keys and values must be less than 8KB.
        An object containing a list of "key": value pairs. Example:
        `{ "name": "wrench", "mass": "1.3kg", "count": "3" }`.
        """
elif False:
    RoutineRemoteFunctionOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutineRemoteFunctionOptionsArgs:
    def __init__(__self__, *,
                 connection: Optional[pulumi.Input[str]] = None,
                 endpoint: Optional[pulumi.Input[str]] = None,
                 max_batching_rows: Optional[pulumi.Input[str]] = None,
                 user_defined_context: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] connection: Fully qualified name of the user-provided connection object which holds
               the authentication information to send requests to the remote service.
               Format: "projects/{projectId}/locations/{locationId}/connections/{connectionId}"
        :param pulumi.Input[str] endpoint: Endpoint of the user-provided remote service, e.g.
               `https://us-east1-my_gcf_project.cloudfunctions.net/remote_add`
        :param pulumi.Input[str] max_batching_rows: Max number of rows in each batch sent to the remote service. If absent or if 0,
               BigQuery dynamically decides the number of rows in a batch.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] user_defined_context: User-defined context as a set of key/value pairs, which will be sent as function
               invocation context together with batched arguments in the requests to the remote
               service. The total number of bytes of keys and values must be less than 8KB.
               An object containing a list of "key": value pairs. Example:
               `{ "name": "wrench", "mass": "1.3kg", "count": "3" }`.
        """
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if endpoint is not None:
            pulumi.set(__self__, "endpoint", endpoint)
        if max_batching_rows is not None:
            pulumi.set(__self__, "max_batching_rows", max_batching_rows)
        if user_defined_context is not None:
            pulumi.set(__self__, "user_defined_context", user_defined_context)

    @property
    @pulumi.getter
    def connection(self) -> Optional[pulumi.Input[str]]:
        """
        Fully qualified name of the user-provided connection object which holds
        the authentication information to send requests to the remote service.
        Format: "projects/{projectId}/locations/{locationId}/connections/{connectionId}"
        """
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection", value)

    @property
    @pulumi.getter
    def endpoint(self) -> Optional[pulumi.Input[str]]:
        """
        Endpoint of the user-provided remote service, e.g.
        `https://us-east1-my_gcf_project.cloudfunctions.net/remote_add`
        """
        return pulumi.get(self, "endpoint")

    @endpoint.setter
    def endpoint(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "endpoint", value)

    @property
    @pulumi.getter(name="maxBatchingRows")
    def max_batching_rows(self) -> Optional[pulumi.Input[str]]:
        """
        Max number of rows in each batch sent to the remote service. If absent or if 0,
        BigQuery dynamically decides the number of rows in a batch.
        """
        return pulumi.get(self, "max_batching_rows")

    @max_batching_rows.setter
    def max_batching_rows(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "max_batching_rows", value)

    @property
    @pulumi.getter(name="userDefinedContext")
    def user_defined_context(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        User-defined context as a set of key/value pairs, which will be sent as function
        invocation context together with batched arguments in the requests to the remote
        service. The total number of bytes of keys and values must be less than 8KB.
        An object containing a list of "key": value pairs. Example:
        `{ "name": "wrench", "mass": "1.3kg", "count": "3" }`.
        """
        return pulumi.get(self, "user_defined_context")

    @user_defined_context.setter
    def user_defined_context(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "user_defined_context", value)


if not MYPY:
    class RoutineSparkOptionsArgsDict(TypedDict):
        archive_uris: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Archive files to be extracted into the working directory of each executor. For more information about Apache Spark, see Apache Spark.
        """
        connection: NotRequired[pulumi.Input[str]]
        """
        Fully qualified name of the user-provided Spark connection object.
        Format: "projects/{projectId}/locations/{locationId}/connections/{connectionId}"
        """
        container_image: NotRequired[pulumi.Input[str]]
        """
        Custom container image for the runtime environment.
        """
        file_uris: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Files to be placed in the working directory of each executor. For more information about Apache Spark, see Apache Spark.
        """
        jar_uris: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        JARs to include on the driver and executor CLASSPATH. For more information about Apache Spark, see Apache Spark.
        """
        main_class: NotRequired[pulumi.Input[str]]
        """
        The fully qualified name of a class in jarUris, for example, com.example.wordcount.
        Exactly one of mainClass and main_jar_uri field should be set for Java/Scala language type.
        """
        main_file_uri: NotRequired[pulumi.Input[str]]
        """
        The main file/jar URI of the Spark application.
        Exactly one of the definitionBody field and the mainFileUri field must be set for Python.
        Exactly one of mainClass and mainFileUri field should be set for Java/Scala language type.
        """
        properties: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Configuration properties as a set of key/value pairs, which will be passed on to the Spark application.
        For more information, see Apache Spark and the procedure option list.
        An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        py_file_uris: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Python files to be placed on the PYTHONPATH for PySpark application. Supported file types: .py, .egg, and .zip. For more information about Apache Spark, see Apache Spark.
        """
        runtime_version: NotRequired[pulumi.Input[str]]
        """
        Runtime version. If not specified, the default runtime version is used.
        """
elif False:
    RoutineSparkOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RoutineSparkOptionsArgs:
    def __init__(__self__, *,
                 archive_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 connection: Optional[pulumi.Input[str]] = None,
                 container_image: Optional[pulumi.Input[str]] = None,
                 file_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 jar_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 main_class: Optional[pulumi.Input[str]] = None,
                 main_file_uri: Optional[pulumi.Input[str]] = None,
                 properties: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 py_file_uris: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 runtime_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] archive_uris: Archive files to be extracted into the working directory of each executor. For more information about Apache Spark, see Apache Spark.
        :param pulumi.Input[str] connection: Fully qualified name of the user-provided Spark connection object.
               Format: "projects/{projectId}/locations/{locationId}/connections/{connectionId}"
        :param pulumi.Input[str] container_image: Custom container image for the runtime environment.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] file_uris: Files to be placed in the working directory of each executor. For more information about Apache Spark, see Apache Spark.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] jar_uris: JARs to include on the driver and executor CLASSPATH. For more information about Apache Spark, see Apache Spark.
        :param pulumi.Input[str] main_class: The fully qualified name of a class in jarUris, for example, com.example.wordcount.
               Exactly one of mainClass and main_jar_uri field should be set for Java/Scala language type.
        :param pulumi.Input[str] main_file_uri: The main file/jar URI of the Spark application.
               Exactly one of the definitionBody field and the mainFileUri field must be set for Python.
               Exactly one of mainClass and mainFileUri field should be set for Java/Scala language type.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] properties: Configuration properties as a set of key/value pairs, which will be passed on to the Spark application.
               For more information, see Apache Spark and the procedure option list.
               An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] py_file_uris: Python files to be placed on the PYTHONPATH for PySpark application. Supported file types: .py, .egg, and .zip. For more information about Apache Spark, see Apache Spark.
        :param pulumi.Input[str] runtime_version: Runtime version. If not specified, the default runtime version is used.
        """
        if archive_uris is not None:
            pulumi.set(__self__, "archive_uris", archive_uris)
        if connection is not None:
            pulumi.set(__self__, "connection", connection)
        if container_image is not None:
            pulumi.set(__self__, "container_image", container_image)
        if file_uris is not None:
            pulumi.set(__self__, "file_uris", file_uris)
        if jar_uris is not None:
            pulumi.set(__self__, "jar_uris", jar_uris)
        if main_class is not None:
            pulumi.set(__self__, "main_class", main_class)
        if main_file_uri is not None:
            pulumi.set(__self__, "main_file_uri", main_file_uri)
        if properties is not None:
            pulumi.set(__self__, "properties", properties)
        if py_file_uris is not None:
            pulumi.set(__self__, "py_file_uris", py_file_uris)
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)

    @property
    @pulumi.getter(name="archiveUris")
    def archive_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Archive files to be extracted into the working directory of each executor. For more information about Apache Spark, see Apache Spark.
        """
        return pulumi.get(self, "archive_uris")

    @archive_uris.setter
    def archive_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "archive_uris", value)

    @property
    @pulumi.getter
    def connection(self) -> Optional[pulumi.Input[str]]:
        """
        Fully qualified name of the user-provided Spark connection object.
        Format: "projects/{projectId}/locations/{locationId}/connections/{connectionId}"
        """
        return pulumi.get(self, "connection")

    @connection.setter
    def connection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection", value)

    @property
    @pulumi.getter(name="containerImage")
    def container_image(self) -> Optional[pulumi.Input[str]]:
        """
        Custom container image for the runtime environment.
        """
        return pulumi.get(self, "container_image")

    @container_image.setter
    def container_image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_image", value)

    @property
    @pulumi.getter(name="fileUris")
    def file_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Files to be placed in the working directory of each executor. For more information about Apache Spark, see Apache Spark.
        """
        return pulumi.get(self, "file_uris")

    @file_uris.setter
    def file_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "file_uris", value)

    @property
    @pulumi.getter(name="jarUris")
    def jar_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        JARs to include on the driver and executor CLASSPATH. For more information about Apache Spark, see Apache Spark.
        """
        return pulumi.get(self, "jar_uris")

    @jar_uris.setter
    def jar_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "jar_uris", value)

    @property
    @pulumi.getter(name="mainClass")
    def main_class(self) -> Optional[pulumi.Input[str]]:
        """
        The fully qualified name of a class in jarUris, for example, com.example.wordcount.
        Exactly one of mainClass and main_jar_uri field should be set for Java/Scala language type.
        """
        return pulumi.get(self, "main_class")

    @main_class.setter
    def main_class(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "main_class", value)

    @property
    @pulumi.getter(name="mainFileUri")
    def main_file_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The main file/jar URI of the Spark application.
        Exactly one of the definitionBody field and the mainFileUri field must be set for Python.
        Exactly one of mainClass and mainFileUri field should be set for Java/Scala language type.
        """
        return pulumi.get(self, "main_file_uri")

    @main_file_uri.setter
    def main_file_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "main_file_uri", value)

    @property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Configuration properties as a set of key/value pairs, which will be passed on to the Spark application.
        For more information, see Apache Spark and the procedure option list.
        An object containing a list of "key": value pairs. Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "properties", value)

    @property
    @pulumi.getter(name="pyFileUris")
    def py_file_uris(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Python files to be placed on the PYTHONPATH for PySpark application. Supported file types: .py, .egg, and .zip. For more information about Apache Spark, see Apache Spark.
        """
        return pulumi.get(self, "py_file_uris")

    @py_file_uris.setter
    def py_file_uris(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "py_file_uris", value)

    @property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[str]]:
        """
        Runtime version. If not specified, the default runtime version is used.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "runtime_version", value)


if not MYPY:
    class TableBiglakeConfigurationArgsDict(TypedDict):
        connection_id: pulumi.Input[str]
        """
        The connection specifying the credentials to be used to
        read and write to external storage, such as Cloud Storage. The connection_id can
        have the form "&lt;project\\_id&gt;.&lt;location\\_id&gt;.&lt;connection\\_id&gt;" or
        projects/&lt;project\\_id&gt;/locations/&lt;location\\_id&gt;/connections/&lt;connection\\_id&gt;".
        """
        file_format: pulumi.Input[str]
        """
        The file format the table data is stored in.
        """
        storage_uri: pulumi.Input[str]
        """
        The fully qualified location prefix of the external folder where table data
        is stored. The '*' wildcard character is not allowed. The URI should be in the format "gs://bucket/path_to_table/"
        """
        table_format: pulumi.Input[str]
        """
        The table format the metadata only snapshots are stored in.
        """
elif False:
    TableBiglakeConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableBiglakeConfigurationArgs:
    def __init__(__self__, *,
                 connection_id: pulumi.Input[str],
                 file_format: pulumi.Input[str],
                 storage_uri: pulumi.Input[str],
                 table_format: pulumi.Input[str]):
        """
        :param pulumi.Input[str] connection_id: The connection specifying the credentials to be used to
               read and write to external storage, such as Cloud Storage. The connection_id can
               have the form "&lt;project\\_id&gt;.&lt;location\\_id&gt;.&lt;connection\\_id&gt;" or
               projects/&lt;project\\_id&gt;/locations/&lt;location\\_id&gt;/connections/&lt;connection\\_id&gt;".
        :param pulumi.Input[str] file_format: The file format the table data is stored in.
        :param pulumi.Input[str] storage_uri: The fully qualified location prefix of the external folder where table data
               is stored. The '*' wildcard character is not allowed. The URI should be in the format "gs://bucket/path_to_table/"
        :param pulumi.Input[str] table_format: The table format the metadata only snapshots are stored in.
        """
        pulumi.set(__self__, "connection_id", connection_id)
        pulumi.set(__self__, "file_format", file_format)
        pulumi.set(__self__, "storage_uri", storage_uri)
        pulumi.set(__self__, "table_format", table_format)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> pulumi.Input[str]:
        """
        The connection specifying the credentials to be used to
        read and write to external storage, such as Cloud Storage. The connection_id can
        have the form "&lt;project\\_id&gt;.&lt;location\\_id&gt;.&lt;connection\\_id&gt;" or
        projects/&lt;project\\_id&gt;/locations/&lt;location\\_id&gt;/connections/&lt;connection\\_id&gt;".
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "connection_id", value)

    @property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> pulumi.Input[str]:
        """
        The file format the table data is stored in.
        """
        return pulumi.get(self, "file_format")

    @file_format.setter
    def file_format(self, value: pulumi.Input[str]):
        pulumi.set(self, "file_format", value)

    @property
    @pulumi.getter(name="storageUri")
    def storage_uri(self) -> pulumi.Input[str]:
        """
        The fully qualified location prefix of the external folder where table data
        is stored. The '*' wildcard character is not allowed. The URI should be in the format "gs://bucket/path_to_table/"
        """
        return pulumi.get(self, "storage_uri")

    @storage_uri.setter
    def storage_uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_uri", value)

    @property
    @pulumi.getter(name="tableFormat")
    def table_format(self) -> pulumi.Input[str]:
        """
        The table format the metadata only snapshots are stored in.
        """
        return pulumi.get(self, "table_format")

    @table_format.setter
    def table_format(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_format", value)


if not MYPY:
    class TableEncryptionConfigurationArgsDict(TypedDict):
        kms_key_name: pulumi.Input[str]
        """
        The self link or full name of a key which should be used to
        encrypt this table.  Note that the default bigquery service account will need to have
        encrypt/decrypt permissions on this key - you may want to see the
        `bigquery_get_default_service_account` datasource and the
        `kms.CryptoKeyIAMBinding` resource.
        """
        kms_key_version: NotRequired[pulumi.Input[str]]
        """
        The self link or full name of the kms key version used to encrypt this table.
        """
elif False:
    TableEncryptionConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableEncryptionConfigurationArgs:
    def __init__(__self__, *,
                 kms_key_name: pulumi.Input[str],
                 kms_key_version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kms_key_name: The self link or full name of a key which should be used to
               encrypt this table.  Note that the default bigquery service account will need to have
               encrypt/decrypt permissions on this key - you may want to see the
               `bigquery_get_default_service_account` datasource and the
               `kms.CryptoKeyIAMBinding` resource.
        :param pulumi.Input[str] kms_key_version: The self link or full name of the kms key version used to encrypt this table.
        """
        pulumi.set(__self__, "kms_key_name", kms_key_name)
        if kms_key_version is not None:
            pulumi.set(__self__, "kms_key_version", kms_key_version)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> pulumi.Input[str]:
        """
        The self link or full name of a key which should be used to
        encrypt this table.  Note that the default bigquery service account will need to have
        encrypt/decrypt permissions on this key - you may want to see the
        `bigquery_get_default_service_account` datasource and the
        `kms.CryptoKeyIAMBinding` resource.
        """
        return pulumi.get(self, "kms_key_name")

    @kms_key_name.setter
    def kms_key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "kms_key_name", value)

    @property
    @pulumi.getter(name="kmsKeyVersion")
    def kms_key_version(self) -> Optional[pulumi.Input[str]]:
        """
        The self link or full name of the kms key version used to encrypt this table.
        """
        return pulumi.get(self, "kms_key_version")

    @kms_key_version.setter
    def kms_key_version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_version", value)


if not MYPY:
    class TableExternalCatalogTableOptionsArgsDict(TypedDict):
        connection_id: NotRequired[pulumi.Input[str]]
        """
        The connection specifying the credentials to be used to read external storage, such as Azure Blob, Cloud Storage, or S3. The connection is needed to read the open source table from BigQuery Engine. The connection_id can have the form <project_id>.<location_id>.<connection_id> or projects/<project_id>/locations/<location_id>/connections/<connection_id>.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A map of key value pairs defining the parameters and properties of the open source table. Corresponds with hive meta store table parameters. Maximum size of 4Mib.
        """
        storage_descriptor: NotRequired[pulumi.Input['TableExternalCatalogTableOptionsStorageDescriptorArgsDict']]
        """
        A storage descriptor containing information about the physical storage of this table.
        """
elif False:
    TableExternalCatalogTableOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableExternalCatalogTableOptionsArgs:
    def __init__(__self__, *,
                 connection_id: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 storage_descriptor: Optional[pulumi.Input['TableExternalCatalogTableOptionsStorageDescriptorArgs']] = None):
        """
        :param pulumi.Input[str] connection_id: The connection specifying the credentials to be used to read external storage, such as Azure Blob, Cloud Storage, or S3. The connection is needed to read the open source table from BigQuery Engine. The connection_id can have the form <project_id>.<location_id>.<connection_id> or projects/<project_id>/locations/<location_id>/connections/<connection_id>.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: A map of key value pairs defining the parameters and properties of the open source table. Corresponds with hive meta store table parameters. Maximum size of 4Mib.
        :param pulumi.Input['TableExternalCatalogTableOptionsStorageDescriptorArgs'] storage_descriptor: A storage descriptor containing information about the physical storage of this table.
        """
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)
        if storage_descriptor is not None:
            pulumi.set(__self__, "storage_descriptor", storage_descriptor)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The connection specifying the credentials to be used to read external storage, such as Azure Blob, Cloud Storage, or S3. The connection is needed to read the open source table from BigQuery Engine. The connection_id can have the form <project_id>.<location_id>.<connection_id> or projects/<project_id>/locations/<location_id>/connections/<connection_id>.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_id", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A map of key value pairs defining the parameters and properties of the open source table. Corresponds with hive meta store table parameters. Maximum size of 4Mib.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)

    @property
    @pulumi.getter(name="storageDescriptor")
    def storage_descriptor(self) -> Optional[pulumi.Input['TableExternalCatalogTableOptionsStorageDescriptorArgs']]:
        """
        A storage descriptor containing information about the physical storage of this table.
        """
        return pulumi.get(self, "storage_descriptor")

    @storage_descriptor.setter
    def storage_descriptor(self, value: Optional[pulumi.Input['TableExternalCatalogTableOptionsStorageDescriptorArgs']]):
        pulumi.set(self, "storage_descriptor", value)


if not MYPY:
    class TableExternalCatalogTableOptionsStorageDescriptorArgsDict(TypedDict):
        input_format: NotRequired[pulumi.Input[str]]
        """
        Specifies the fully qualified class name of the InputFormat (e.g. "org.apache.hadoop.hive.ql.io.orc.OrcInputFormat"). The maximum length is 128 characters.
        """
        location_uri: NotRequired[pulumi.Input[str]]
        """
        The physical location of the table (e.g. 'gs://spark-dataproc-data/pangea-data/case_sensitive/' or 'gs://spark-dataproc-data/pangea-data/*'). The maximum length is 2056 bytes.
        """
        output_format: NotRequired[pulumi.Input[str]]
        """
        Specifies the fully qualified class name of the OutputFormat (e.g. "org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat"). The maximum length is 128 characters.
        """
        serde_info: NotRequired[pulumi.Input['TableExternalCatalogTableOptionsStorageDescriptorSerdeInfoArgsDict']]
        """
        Serializer and deserializer information.
        """
elif False:
    TableExternalCatalogTableOptionsStorageDescriptorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableExternalCatalogTableOptionsStorageDescriptorArgs:
    def __init__(__self__, *,
                 input_format: Optional[pulumi.Input[str]] = None,
                 location_uri: Optional[pulumi.Input[str]] = None,
                 output_format: Optional[pulumi.Input[str]] = None,
                 serde_info: Optional[pulumi.Input['TableExternalCatalogTableOptionsStorageDescriptorSerdeInfoArgs']] = None):
        """
        :param pulumi.Input[str] input_format: Specifies the fully qualified class name of the InputFormat (e.g. "org.apache.hadoop.hive.ql.io.orc.OrcInputFormat"). The maximum length is 128 characters.
        :param pulumi.Input[str] location_uri: The physical location of the table (e.g. 'gs://spark-dataproc-data/pangea-data/case_sensitive/' or 'gs://spark-dataproc-data/pangea-data/*'). The maximum length is 2056 bytes.
        :param pulumi.Input[str] output_format: Specifies the fully qualified class name of the OutputFormat (e.g. "org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat"). The maximum length is 128 characters.
        :param pulumi.Input['TableExternalCatalogTableOptionsStorageDescriptorSerdeInfoArgs'] serde_info: Serializer and deserializer information.
        """
        if input_format is not None:
            pulumi.set(__self__, "input_format", input_format)
        if location_uri is not None:
            pulumi.set(__self__, "location_uri", location_uri)
        if output_format is not None:
            pulumi.set(__self__, "output_format", output_format)
        if serde_info is not None:
            pulumi.set(__self__, "serde_info", serde_info)

    @property
    @pulumi.getter(name="inputFormat")
    def input_format(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the fully qualified class name of the InputFormat (e.g. "org.apache.hadoop.hive.ql.io.orc.OrcInputFormat"). The maximum length is 128 characters.
        """
        return pulumi.get(self, "input_format")

    @input_format.setter
    def input_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "input_format", value)

    @property
    @pulumi.getter(name="locationUri")
    def location_uri(self) -> Optional[pulumi.Input[str]]:
        """
        The physical location of the table (e.g. 'gs://spark-dataproc-data/pangea-data/case_sensitive/' or 'gs://spark-dataproc-data/pangea-data/*'). The maximum length is 2056 bytes.
        """
        return pulumi.get(self, "location_uri")

    @location_uri.setter
    def location_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location_uri", value)

    @property
    @pulumi.getter(name="outputFormat")
    def output_format(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the fully qualified class name of the OutputFormat (e.g. "org.apache.hadoop.hive.ql.io.orc.OrcOutputFormat"). The maximum length is 128 characters.
        """
        return pulumi.get(self, "output_format")

    @output_format.setter
    def output_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_format", value)

    @property
    @pulumi.getter(name="serdeInfo")
    def serde_info(self) -> Optional[pulumi.Input['TableExternalCatalogTableOptionsStorageDescriptorSerdeInfoArgs']]:
        """
        Serializer and deserializer information.
        """
        return pulumi.get(self, "serde_info")

    @serde_info.setter
    def serde_info(self, value: Optional[pulumi.Input['TableExternalCatalogTableOptionsStorageDescriptorSerdeInfoArgs']]):
        pulumi.set(self, "serde_info", value)


if not MYPY:
    class TableExternalCatalogTableOptionsStorageDescriptorSerdeInfoArgsDict(TypedDict):
        serialization_library: pulumi.Input[str]
        """
        Specifies a fully-qualified class name of the serialization library that is responsible for the translation of data between table representation and the underlying low-level input and output format structures. The maximum length is 256 characters.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the SerDe. The maximum length is 256 characters.
        """
        parameters: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Key-value pairs that define the initialization parameters for the serialization library. Maximum size 10 Kib.
        """
elif False:
    TableExternalCatalogTableOptionsStorageDescriptorSerdeInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableExternalCatalogTableOptionsStorageDescriptorSerdeInfoArgs:
    def __init__(__self__, *,
                 serialization_library: pulumi.Input[str],
                 name: Optional[pulumi.Input[str]] = None,
                 parameters: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] serialization_library: Specifies a fully-qualified class name of the serialization library that is responsible for the translation of data between table representation and the underlying low-level input and output format structures. The maximum length is 256 characters.
        :param pulumi.Input[str] name: Name of the SerDe. The maximum length is 256 characters.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] parameters: Key-value pairs that define the initialization parameters for the serialization library. Maximum size 10 Kib.
        """
        pulumi.set(__self__, "serialization_library", serialization_library)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parameters is not None:
            pulumi.set(__self__, "parameters", parameters)

    @property
    @pulumi.getter(name="serializationLibrary")
    def serialization_library(self) -> pulumi.Input[str]:
        """
        Specifies a fully-qualified class name of the serialization library that is responsible for the translation of data between table representation and the underlying low-level input and output format structures. The maximum length is 256 characters.
        """
        return pulumi.get(self, "serialization_library")

    @serialization_library.setter
    def serialization_library(self, value: pulumi.Input[str]):
        pulumi.set(self, "serialization_library", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the SerDe. The maximum length is 256 characters.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter
    def parameters(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Key-value pairs that define the initialization parameters for the serialization library. Maximum size 10 Kib.
        """
        return pulumi.get(self, "parameters")

    @parameters.setter
    def parameters(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "parameters", value)


if not MYPY:
    class TableExternalDataConfigurationArgsDict(TypedDict):
        autodetect: pulumi.Input[bool]
        """
        Let BigQuery try to autodetect the schema
        and format of the table.
        """
        source_uris: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        A list of the fully-qualified URIs that point to
        your data in Google Cloud.
        """
        avro_options: NotRequired[pulumi.Input['TableExternalDataConfigurationAvroOptionsArgsDict']]
        """
        Additional options if `source_format` is set to
        "AVRO".  Structure is documented below.
        """
        bigtable_options: NotRequired[pulumi.Input['TableExternalDataConfigurationBigtableOptionsArgsDict']]
        """
        Additional properties to set if
        `source_format` is set to "BIGTABLE". Structure is documented below.
        """
        compression: NotRequired[pulumi.Input[str]]
        """
        The compression type of the data source.
        Valid values are "NONE" or "GZIP".
        """
        connection_id: NotRequired[pulumi.Input[str]]
        """
        The connection specifying the credentials to be used to read
        external storage, such as Azure Blob, Cloud Storage, or S3. The `connection_id` can have
        the form `{{project}}.{{location}}.{{connection_id}}`
        or `projects/{{project}}/locations/{{location}}/connections/{{connection_id}}`.

        ~>**NOTE:** If you set `external_data_configuration.connection_id`, the
        table schema must be specified using the top-level `schema` field
        documented above.
        """
        csv_options: NotRequired[pulumi.Input['TableExternalDataConfigurationCsvOptionsArgsDict']]
        """
        Additional properties to set if
        `source_format` is set to "CSV". Structure is documented below.
        """
        file_set_spec_type: NotRequired[pulumi.Input[str]]
        """
        Specifies how source URIs are interpreted for constructing the file set to load.
        By default source URIs are expanded against the underlying storage.
        Other options include specifying manifest files. Only applicable to object storage systems. Docs
        """
        google_sheets_options: NotRequired[pulumi.Input['TableExternalDataConfigurationGoogleSheetsOptionsArgsDict']]
        """
        Additional options if
        `source_format` is set to "GOOGLE_SHEETS". Structure is
        documented below.
        """
        hive_partitioning_options: NotRequired[pulumi.Input['TableExternalDataConfigurationHivePartitioningOptionsArgsDict']]
        """
        When set, configures hive partitioning
        support. Not all storage formats support hive partitioning -- requesting hive
        partitioning on an unsupported format will lead to an error, as will providing
        an invalid specification. Structure is documented below.
        """
        ignore_unknown_values: NotRequired[pulumi.Input[bool]]
        """
        Indicates if BigQuery should
        allow extra values that are not represented in the table schema.
        If true, the extra values are ignored. If false, records with
        extra columns are treated as bad records, and if there are too
        many bad records, an invalid error is returned in the job result.
        The default value is false.
        """
        json_extension: NotRequired[pulumi.Input[str]]
        """
        Used to indicate that a JSON variant, rather than normal JSON, is being used as the sourceFormat. This should only be used in combination with the `JSON` source format. Valid values are: `GEOJSON`.
        """
        json_options: NotRequired[pulumi.Input['TableExternalDataConfigurationJsonOptionsArgsDict']]
        """
        Additional properties to set if
        `source_format` is set to "JSON". Structure is documented below.
        """
        max_bad_records: NotRequired[pulumi.Input[int]]
        """
        The maximum number of bad records that
        BigQuery can ignore when reading data.
        """
        metadata_cache_mode: NotRequired[pulumi.Input[str]]
        """
        Metadata Cache Mode for the table. Set this to enable caching of metadata from external data source. Valid values are `AUTOMATIC` and `MANUAL`.
        """
        object_metadata: NotRequired[pulumi.Input[str]]
        """
        Object Metadata is used to create Object Tables. Object Tables contain a listing of objects (with their metadata) found at the sourceUris. If `object_metadata` is set, `source_format` should be omitted.
        """
        parquet_options: NotRequired[pulumi.Input['TableExternalDataConfigurationParquetOptionsArgsDict']]
        """
        Additional properties to set if
        `source_format` is set to "PARQUET". Structure is documented below.
        """
        reference_file_schema_uri: NotRequired[pulumi.Input[str]]
        """
        When creating an external table, the user can provide a reference file with the table schema. This is enabled for the following formats: AVRO, PARQUET, ORC.
        """
        schema: NotRequired[pulumi.Input[str]]
        """
        A JSON schema for the external table. Schema is required
        for CSV and JSON formats if autodetect is not on. Schema is disallowed
        for Google Cloud Bigtable, Cloud Datastore backups, Avro, Iceberg, ORC and Parquet formats.
        ~>**NOTE:** Because this field expects a JSON string, any changes to the
        string will create a diff, even if the JSON itself hasn't changed.
        Furthermore drift for this field cannot not be detected because BigQuery
        only uses this schema to compute the effective schema for the table, therefore
        any changes on the configured value will force the table to be recreated.
        This schema is effectively only applied when creating a table from an external
        datasource, after creation the computed schema will be stored in
        `google_bigquery_table.schema`

        ~>**NOTE:** If you set `external_data_configuration.connection_id`, the
        table schema must be specified using the top-level `schema` field
        documented above.
        """
        source_format: NotRequired[pulumi.Input[str]]
        """
        The data format. Please see sourceFormat under
        [ExternalDataConfiguration](https://cloud.google.com/bigquery/docs/reference/rest/v2/tables#externaldataconfiguration)
        in Bigquery's public API documentation for supported formats. To use "GOOGLE_SHEETS"
        the `scopes` must include "https://www.googleapis.com/auth/drive.readonly".
        """
elif False:
    TableExternalDataConfigurationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableExternalDataConfigurationArgs:
    def __init__(__self__, *,
                 autodetect: pulumi.Input[bool],
                 source_uris: pulumi.Input[Sequence[pulumi.Input[str]]],
                 avro_options: Optional[pulumi.Input['TableExternalDataConfigurationAvroOptionsArgs']] = None,
                 bigtable_options: Optional[pulumi.Input['TableExternalDataConfigurationBigtableOptionsArgs']] = None,
                 compression: Optional[pulumi.Input[str]] = None,
                 connection_id: Optional[pulumi.Input[str]] = None,
                 csv_options: Optional[pulumi.Input['TableExternalDataConfigurationCsvOptionsArgs']] = None,
                 file_set_spec_type: Optional[pulumi.Input[str]] = None,
                 google_sheets_options: Optional[pulumi.Input['TableExternalDataConfigurationGoogleSheetsOptionsArgs']] = None,
                 hive_partitioning_options: Optional[pulumi.Input['TableExternalDataConfigurationHivePartitioningOptionsArgs']] = None,
                 ignore_unknown_values: Optional[pulumi.Input[bool]] = None,
                 json_extension: Optional[pulumi.Input[str]] = None,
                 json_options: Optional[pulumi.Input['TableExternalDataConfigurationJsonOptionsArgs']] = None,
                 max_bad_records: Optional[pulumi.Input[int]] = None,
                 metadata_cache_mode: Optional[pulumi.Input[str]] = None,
                 object_metadata: Optional[pulumi.Input[str]] = None,
                 parquet_options: Optional[pulumi.Input['TableExternalDataConfigurationParquetOptionsArgs']] = None,
                 reference_file_schema_uri: Optional[pulumi.Input[str]] = None,
                 schema: Optional[pulumi.Input[str]] = None,
                 source_format: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] autodetect: Let BigQuery try to autodetect the schema
               and format of the table.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] source_uris: A list of the fully-qualified URIs that point to
               your data in Google Cloud.
        :param pulumi.Input['TableExternalDataConfigurationAvroOptionsArgs'] avro_options: Additional options if `source_format` is set to
               "AVRO".  Structure is documented below.
        :param pulumi.Input['TableExternalDataConfigurationBigtableOptionsArgs'] bigtable_options: Additional properties to set if
               `source_format` is set to "BIGTABLE". Structure is documented below.
        :param pulumi.Input[str] compression: The compression type of the data source.
               Valid values are "NONE" or "GZIP".
        :param pulumi.Input[str] connection_id: The connection specifying the credentials to be used to read
               external storage, such as Azure Blob, Cloud Storage, or S3. The `connection_id` can have
               the form `{{project}}.{{location}}.{{connection_id}}`
               or `projects/{{project}}/locations/{{location}}/connections/{{connection_id}}`.
               
               ~>**NOTE:** If you set `external_data_configuration.connection_id`, the
               table schema must be specified using the top-level `schema` field
               documented above.
        :param pulumi.Input['TableExternalDataConfigurationCsvOptionsArgs'] csv_options: Additional properties to set if
               `source_format` is set to "CSV". Structure is documented below.
        :param pulumi.Input[str] file_set_spec_type: Specifies how source URIs are interpreted for constructing the file set to load.
               By default source URIs are expanded against the underlying storage.
               Other options include specifying manifest files. Only applicable to object storage systems. Docs
        :param pulumi.Input['TableExternalDataConfigurationGoogleSheetsOptionsArgs'] google_sheets_options: Additional options if
               `source_format` is set to "GOOGLE_SHEETS". Structure is
               documented below.
        :param pulumi.Input['TableExternalDataConfigurationHivePartitioningOptionsArgs'] hive_partitioning_options: When set, configures hive partitioning
               support. Not all storage formats support hive partitioning -- requesting hive
               partitioning on an unsupported format will lead to an error, as will providing
               an invalid specification. Structure is documented below.
        :param pulumi.Input[bool] ignore_unknown_values: Indicates if BigQuery should
               allow extra values that are not represented in the table schema.
               If true, the extra values are ignored. If false, records with
               extra columns are treated as bad records, and if there are too
               many bad records, an invalid error is returned in the job result.
               The default value is false.
        :param pulumi.Input[str] json_extension: Used to indicate that a JSON variant, rather than normal JSON, is being used as the sourceFormat. This should only be used in combination with the `JSON` source format. Valid values are: `GEOJSON`.
        :param pulumi.Input['TableExternalDataConfigurationJsonOptionsArgs'] json_options: Additional properties to set if
               `source_format` is set to "JSON". Structure is documented below.
        :param pulumi.Input[int] max_bad_records: The maximum number of bad records that
               BigQuery can ignore when reading data.
        :param pulumi.Input[str] metadata_cache_mode: Metadata Cache Mode for the table. Set this to enable caching of metadata from external data source. Valid values are `AUTOMATIC` and `MANUAL`.
        :param pulumi.Input[str] object_metadata: Object Metadata is used to create Object Tables. Object Tables contain a listing of objects (with their metadata) found at the sourceUris. If `object_metadata` is set, `source_format` should be omitted.
        :param pulumi.Input['TableExternalDataConfigurationParquetOptionsArgs'] parquet_options: Additional properties to set if
               `source_format` is set to "PARQUET". Structure is documented below.
        :param pulumi.Input[str] reference_file_schema_uri: When creating an external table, the user can provide a reference file with the table schema. This is enabled for the following formats: AVRO, PARQUET, ORC.
        :param pulumi.Input[str] schema: A JSON schema for the external table. Schema is required
               for CSV and JSON formats if autodetect is not on. Schema is disallowed
               for Google Cloud Bigtable, Cloud Datastore backups, Avro, Iceberg, ORC and Parquet formats.
               ~>**NOTE:** Because this field expects a JSON string, any changes to the
               string will create a diff, even if the JSON itself hasn't changed.
               Furthermore drift for this field cannot not be detected because BigQuery
               only uses this schema to compute the effective schema for the table, therefore
               any changes on the configured value will force the table to be recreated.
               This schema is effectively only applied when creating a table from an external
               datasource, after creation the computed schema will be stored in
               `google_bigquery_table.schema`
               
               ~>**NOTE:** If you set `external_data_configuration.connection_id`, the
               table schema must be specified using the top-level `schema` field
               documented above.
        :param pulumi.Input[str] source_format: The data format. Please see sourceFormat under
               [ExternalDataConfiguration](https://cloud.google.com/bigquery/docs/reference/rest/v2/tables#externaldataconfiguration)
               in Bigquery's public API documentation for supported formats. To use "GOOGLE_SHEETS"
               the `scopes` must include "https://www.googleapis.com/auth/drive.readonly".
        """
        pulumi.set(__self__, "autodetect", autodetect)
        pulumi.set(__self__, "source_uris", source_uris)
        if avro_options is not None:
            pulumi.set(__self__, "avro_options", avro_options)
        if bigtable_options is not None:
            pulumi.set(__self__, "bigtable_options", bigtable_options)
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if connection_id is not None:
            pulumi.set(__self__, "connection_id", connection_id)
        if csv_options is not None:
            pulumi.set(__self__, "csv_options", csv_options)
        if file_set_spec_type is not None:
            pulumi.set(__self__, "file_set_spec_type", file_set_spec_type)
        if google_sheets_options is not None:
            pulumi.set(__self__, "google_sheets_options", google_sheets_options)
        if hive_partitioning_options is not None:
            pulumi.set(__self__, "hive_partitioning_options", hive_partitioning_options)
        if ignore_unknown_values is not None:
            pulumi.set(__self__, "ignore_unknown_values", ignore_unknown_values)
        if json_extension is not None:
            pulumi.set(__self__, "json_extension", json_extension)
        if json_options is not None:
            pulumi.set(__self__, "json_options", json_options)
        if max_bad_records is not None:
            pulumi.set(__self__, "max_bad_records", max_bad_records)
        if metadata_cache_mode is not None:
            pulumi.set(__self__, "metadata_cache_mode", metadata_cache_mode)
        if object_metadata is not None:
            pulumi.set(__self__, "object_metadata", object_metadata)
        if parquet_options is not None:
            pulumi.set(__self__, "parquet_options", parquet_options)
        if reference_file_schema_uri is not None:
            pulumi.set(__self__, "reference_file_schema_uri", reference_file_schema_uri)
        if schema is not None:
            pulumi.set(__self__, "schema", schema)
        if source_format is not None:
            pulumi.set(__self__, "source_format", source_format)

    @property
    @pulumi.getter
    def autodetect(self) -> pulumi.Input[bool]:
        """
        Let BigQuery try to autodetect the schema
        and format of the table.
        """
        return pulumi.get(self, "autodetect")

    @autodetect.setter
    def autodetect(self, value: pulumi.Input[bool]):
        pulumi.set(self, "autodetect", value)

    @property
    @pulumi.getter(name="sourceUris")
    def source_uris(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        A list of the fully-qualified URIs that point to
        your data in Google Cloud.
        """
        return pulumi.get(self, "source_uris")

    @source_uris.setter
    def source_uris(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "source_uris", value)

    @property
    @pulumi.getter(name="avroOptions")
    def avro_options(self) -> Optional[pulumi.Input['TableExternalDataConfigurationAvroOptionsArgs']]:
        """
        Additional options if `source_format` is set to
        "AVRO".  Structure is documented below.
        """
        return pulumi.get(self, "avro_options")

    @avro_options.setter
    def avro_options(self, value: Optional[pulumi.Input['TableExternalDataConfigurationAvroOptionsArgs']]):
        pulumi.set(self, "avro_options", value)

    @property
    @pulumi.getter(name="bigtableOptions")
    def bigtable_options(self) -> Optional[pulumi.Input['TableExternalDataConfigurationBigtableOptionsArgs']]:
        """
        Additional properties to set if
        `source_format` is set to "BIGTABLE". Structure is documented below.
        """
        return pulumi.get(self, "bigtable_options")

    @bigtable_options.setter
    def bigtable_options(self, value: Optional[pulumi.Input['TableExternalDataConfigurationBigtableOptionsArgs']]):
        pulumi.set(self, "bigtable_options", value)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input[str]]:
        """
        The compression type of the data source.
        Valid values are "NONE" or "GZIP".
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter(name="connectionId")
    def connection_id(self) -> Optional[pulumi.Input[str]]:
        """
        The connection specifying the credentials to be used to read
        external storage, such as Azure Blob, Cloud Storage, or S3. The `connection_id` can have
        the form `{{project}}.{{location}}.{{connection_id}}`
        or `projects/{{project}}/locations/{{location}}/connections/{{connection_id}}`.

        ~>**NOTE:** If you set `external_data_configuration.connection_id`, the
        table schema must be specified using the top-level `schema` field
        documented above.
        """
        return pulumi.get(self, "connection_id")

    @connection_id.setter
    def connection_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "connection_id", value)

    @property
    @pulumi.getter(name="csvOptions")
    def csv_options(self) -> Optional[pulumi.Input['TableExternalDataConfigurationCsvOptionsArgs']]:
        """
        Additional properties to set if
        `source_format` is set to "CSV". Structure is documented below.
        """
        return pulumi.get(self, "csv_options")

    @csv_options.setter
    def csv_options(self, value: Optional[pulumi.Input['TableExternalDataConfigurationCsvOptionsArgs']]):
        pulumi.set(self, "csv_options", value)

    @property
    @pulumi.getter(name="fileSetSpecType")
    def file_set_spec_type(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies how source URIs are interpreted for constructing the file set to load.
        By default source URIs are expanded against the underlying storage.
        Other options include specifying manifest files. Only applicable to object storage systems. Docs
        """
        return pulumi.get(self, "file_set_spec_type")

    @file_set_spec_type.setter
    def file_set_spec_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_set_spec_type", value)

    @property
    @pulumi.getter(name="googleSheetsOptions")
    def google_sheets_options(self) -> Optional[pulumi.Input['TableExternalDataConfigurationGoogleSheetsOptionsArgs']]:
        """
        Additional options if
        `source_format` is set to "GOOGLE_SHEETS". Structure is
        documented below.
        """
        return pulumi.get(self, "google_sheets_options")

    @google_sheets_options.setter
    def google_sheets_options(self, value: Optional[pulumi.Input['TableExternalDataConfigurationGoogleSheetsOptionsArgs']]):
        pulumi.set(self, "google_sheets_options", value)

    @property
    @pulumi.getter(name="hivePartitioningOptions")
    def hive_partitioning_options(self) -> Optional[pulumi.Input['TableExternalDataConfigurationHivePartitioningOptionsArgs']]:
        """
        When set, configures hive partitioning
        support. Not all storage formats support hive partitioning -- requesting hive
        partitioning on an unsupported format will lead to an error, as will providing
        an invalid specification. Structure is documented below.
        """
        return pulumi.get(self, "hive_partitioning_options")

    @hive_partitioning_options.setter
    def hive_partitioning_options(self, value: Optional[pulumi.Input['TableExternalDataConfigurationHivePartitioningOptionsArgs']]):
        pulumi.set(self, "hive_partitioning_options", value)

    @property
    @pulumi.getter(name="ignoreUnknownValues")
    def ignore_unknown_values(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if BigQuery should
        allow extra values that are not represented in the table schema.
        If true, the extra values are ignored. If false, records with
        extra columns are treated as bad records, and if there are too
        many bad records, an invalid error is returned in the job result.
        The default value is false.
        """
        return pulumi.get(self, "ignore_unknown_values")

    @ignore_unknown_values.setter
    def ignore_unknown_values(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_unknown_values", value)

    @property
    @pulumi.getter(name="jsonExtension")
    def json_extension(self) -> Optional[pulumi.Input[str]]:
        """
        Used to indicate that a JSON variant, rather than normal JSON, is being used as the sourceFormat. This should only be used in combination with the `JSON` source format. Valid values are: `GEOJSON`.
        """
        return pulumi.get(self, "json_extension")

    @json_extension.setter
    def json_extension(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "json_extension", value)

    @property
    @pulumi.getter(name="jsonOptions")
    def json_options(self) -> Optional[pulumi.Input['TableExternalDataConfigurationJsonOptionsArgs']]:
        """
        Additional properties to set if
        `source_format` is set to "JSON". Structure is documented below.
        """
        return pulumi.get(self, "json_options")

    @json_options.setter
    def json_options(self, value: Optional[pulumi.Input['TableExternalDataConfigurationJsonOptionsArgs']]):
        pulumi.set(self, "json_options", value)

    @property
    @pulumi.getter(name="maxBadRecords")
    def max_bad_records(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of bad records that
        BigQuery can ignore when reading data.
        """
        return pulumi.get(self, "max_bad_records")

    @max_bad_records.setter
    def max_bad_records(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_bad_records", value)

    @property
    @pulumi.getter(name="metadataCacheMode")
    def metadata_cache_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Metadata Cache Mode for the table. Set this to enable caching of metadata from external data source. Valid values are `AUTOMATIC` and `MANUAL`.
        """
        return pulumi.get(self, "metadata_cache_mode")

    @metadata_cache_mode.setter
    def metadata_cache_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "metadata_cache_mode", value)

    @property
    @pulumi.getter(name="objectMetadata")
    def object_metadata(self) -> Optional[pulumi.Input[str]]:
        """
        Object Metadata is used to create Object Tables. Object Tables contain a listing of objects (with their metadata) found at the sourceUris. If `object_metadata` is set, `source_format` should be omitted.
        """
        return pulumi.get(self, "object_metadata")

    @object_metadata.setter
    def object_metadata(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "object_metadata", value)

    @property
    @pulumi.getter(name="parquetOptions")
    def parquet_options(self) -> Optional[pulumi.Input['TableExternalDataConfigurationParquetOptionsArgs']]:
        """
        Additional properties to set if
        `source_format` is set to "PARQUET". Structure is documented below.
        """
        return pulumi.get(self, "parquet_options")

    @parquet_options.setter
    def parquet_options(self, value: Optional[pulumi.Input['TableExternalDataConfigurationParquetOptionsArgs']]):
        pulumi.set(self, "parquet_options", value)

    @property
    @pulumi.getter(name="referenceFileSchemaUri")
    def reference_file_schema_uri(self) -> Optional[pulumi.Input[str]]:
        """
        When creating an external table, the user can provide a reference file with the table schema. This is enabled for the following formats: AVRO, PARQUET, ORC.
        """
        return pulumi.get(self, "reference_file_schema_uri")

    @reference_file_schema_uri.setter
    def reference_file_schema_uri(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reference_file_schema_uri", value)

    @property
    @pulumi.getter
    def schema(self) -> Optional[pulumi.Input[str]]:
        """
        A JSON schema for the external table. Schema is required
        for CSV and JSON formats if autodetect is not on. Schema is disallowed
        for Google Cloud Bigtable, Cloud Datastore backups, Avro, Iceberg, ORC and Parquet formats.
        ~>**NOTE:** Because this field expects a JSON string, any changes to the
        string will create a diff, even if the JSON itself hasn't changed.
        Furthermore drift for this field cannot not be detected because BigQuery
        only uses this schema to compute the effective schema for the table, therefore
        any changes on the configured value will force the table to be recreated.
        This schema is effectively only applied when creating a table from an external
        datasource, after creation the computed schema will be stored in
        `google_bigquery_table.schema`

        ~>**NOTE:** If you set `external_data_configuration.connection_id`, the
        table schema must be specified using the top-level `schema` field
        documented above.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="sourceFormat")
    def source_format(self) -> Optional[pulumi.Input[str]]:
        """
        The data format. Please see sourceFormat under
        [ExternalDataConfiguration](https://cloud.google.com/bigquery/docs/reference/rest/v2/tables#externaldataconfiguration)
        in Bigquery's public API documentation for supported formats. To use "GOOGLE_SHEETS"
        the `scopes` must include "https://www.googleapis.com/auth/drive.readonly".
        """
        return pulumi.get(self, "source_format")

    @source_format.setter
    def source_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_format", value)


if not MYPY:
    class TableExternalDataConfigurationAvroOptionsArgsDict(TypedDict):
        use_avro_logical_types: pulumi.Input[bool]
        """
        If is set to true, indicates whether
        to interpret logical types as the corresponding BigQuery data type
        (for example, TIMESTAMP), instead of using the raw type (for example, INTEGER).
        """
elif False:
    TableExternalDataConfigurationAvroOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableExternalDataConfigurationAvroOptionsArgs:
    def __init__(__self__, *,
                 use_avro_logical_types: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] use_avro_logical_types: If is set to true, indicates whether
               to interpret logical types as the corresponding BigQuery data type
               (for example, TIMESTAMP), instead of using the raw type (for example, INTEGER).
        """
        pulumi.set(__self__, "use_avro_logical_types", use_avro_logical_types)

    @property
    @pulumi.getter(name="useAvroLogicalTypes")
    def use_avro_logical_types(self) -> pulumi.Input[bool]:
        """
        If is set to true, indicates whether
        to interpret logical types as the corresponding BigQuery data type
        (for example, TIMESTAMP), instead of using the raw type (for example, INTEGER).
        """
        return pulumi.get(self, "use_avro_logical_types")

    @use_avro_logical_types.setter
    def use_avro_logical_types(self, value: pulumi.Input[bool]):
        pulumi.set(self, "use_avro_logical_types", value)


if not MYPY:
    class TableExternalDataConfigurationBigtableOptionsArgsDict(TypedDict):
        column_families: NotRequired[pulumi.Input[Sequence[pulumi.Input['TableExternalDataConfigurationBigtableOptionsColumnFamilyArgsDict']]]]
        """
        A list of column families to expose in the table schema along with their types. This list restricts the column families that can be referenced in queries and specifies their value types. You can use this list to do type conversions - see the 'type' field for more details. If you leave this list empty, all column families are present in the table schema and their values are read as BYTES. During a query only the column families referenced in that query are read from Bigtable.  Structure is documented below.
        """
        ignore_unspecified_column_families: NotRequired[pulumi.Input[bool]]
        """
        If field is true, then the column families that are not specified in columnFamilies list are not exposed in the table schema. Otherwise, they are read with BYTES type values. The default value is false.
        """
        output_column_families_as_json: NotRequired[pulumi.Input[bool]]
        """
        If field is true, then each column family will be read as a single JSON column. Otherwise they are read as a repeated cell structure containing timestamp/value tuples. The default value is false.
        """
        read_rowkey_as_string: NotRequired[pulumi.Input[bool]]
        """
        If field is true, then the rowkey column families will be read and converted to string. Otherwise they are read with BYTES type values and users need to manually cast them with CAST if necessary. The default value is false.
        """
elif False:
    TableExternalDataConfigurationBigtableOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableExternalDataConfigurationBigtableOptionsArgs:
    def __init__(__self__, *,
                 column_families: Optional[pulumi.Input[Sequence[pulumi.Input['TableExternalDataConfigurationBigtableOptionsColumnFamilyArgs']]]] = None,
                 ignore_unspecified_column_families: Optional[pulumi.Input[bool]] = None,
                 output_column_families_as_json: Optional[pulumi.Input[bool]] = None,
                 read_rowkey_as_string: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TableExternalDataConfigurationBigtableOptionsColumnFamilyArgs']]] column_families: A list of column families to expose in the table schema along with their types. This list restricts the column families that can be referenced in queries and specifies their value types. You can use this list to do type conversions - see the 'type' field for more details. If you leave this list empty, all column families are present in the table schema and their values are read as BYTES. During a query only the column families referenced in that query are read from Bigtable.  Structure is documented below.
        :param pulumi.Input[bool] ignore_unspecified_column_families: If field is true, then the column families that are not specified in columnFamilies list are not exposed in the table schema. Otherwise, they are read with BYTES type values. The default value is false.
        :param pulumi.Input[bool] output_column_families_as_json: If field is true, then each column family will be read as a single JSON column. Otherwise they are read as a repeated cell structure containing timestamp/value tuples. The default value is false.
        :param pulumi.Input[bool] read_rowkey_as_string: If field is true, then the rowkey column families will be read and converted to string. Otherwise they are read with BYTES type values and users need to manually cast them with CAST if necessary. The default value is false.
        """
        if column_families is not None:
            pulumi.set(__self__, "column_families", column_families)
        if ignore_unspecified_column_families is not None:
            pulumi.set(__self__, "ignore_unspecified_column_families", ignore_unspecified_column_families)
        if output_column_families_as_json is not None:
            pulumi.set(__self__, "output_column_families_as_json", output_column_families_as_json)
        if read_rowkey_as_string is not None:
            pulumi.set(__self__, "read_rowkey_as_string", read_rowkey_as_string)

    @property
    @pulumi.getter(name="columnFamilies")
    def column_families(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TableExternalDataConfigurationBigtableOptionsColumnFamilyArgs']]]]:
        """
        A list of column families to expose in the table schema along with their types. This list restricts the column families that can be referenced in queries and specifies their value types. You can use this list to do type conversions - see the 'type' field for more details. If you leave this list empty, all column families are present in the table schema and their values are read as BYTES. During a query only the column families referenced in that query are read from Bigtable.  Structure is documented below.
        """
        return pulumi.get(self, "column_families")

    @column_families.setter
    def column_families(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TableExternalDataConfigurationBigtableOptionsColumnFamilyArgs']]]]):
        pulumi.set(self, "column_families", value)

    @property
    @pulumi.getter(name="ignoreUnspecifiedColumnFamilies")
    def ignore_unspecified_column_families(self) -> Optional[pulumi.Input[bool]]:
        """
        If field is true, then the column families that are not specified in columnFamilies list are not exposed in the table schema. Otherwise, they are read with BYTES type values. The default value is false.
        """
        return pulumi.get(self, "ignore_unspecified_column_families")

    @ignore_unspecified_column_families.setter
    def ignore_unspecified_column_families(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ignore_unspecified_column_families", value)

    @property
    @pulumi.getter(name="outputColumnFamiliesAsJson")
    def output_column_families_as_json(self) -> Optional[pulumi.Input[bool]]:
        """
        If field is true, then each column family will be read as a single JSON column. Otherwise they are read as a repeated cell structure containing timestamp/value tuples. The default value is false.
        """
        return pulumi.get(self, "output_column_families_as_json")

    @output_column_families_as_json.setter
    def output_column_families_as_json(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "output_column_families_as_json", value)

    @property
    @pulumi.getter(name="readRowkeyAsString")
    def read_rowkey_as_string(self) -> Optional[pulumi.Input[bool]]:
        """
        If field is true, then the rowkey column families will be read and converted to string. Otherwise they are read with BYTES type values and users need to manually cast them with CAST if necessary. The default value is false.
        """
        return pulumi.get(self, "read_rowkey_as_string")

    @read_rowkey_as_string.setter
    def read_rowkey_as_string(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "read_rowkey_as_string", value)


if not MYPY:
    class TableExternalDataConfigurationBigtableOptionsColumnFamilyArgsDict(TypedDict):
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['TableExternalDataConfigurationBigtableOptionsColumnFamilyColumnArgsDict']]]]
        """
        A List of columns that should be exposed as individual fields as opposed to a list of (column name, value) pairs. All columns whose qualifier matches a qualifier in this list can be accessed as Other columns can be accessed as a list through column field.  Structure is documented below.
        """
        encoding: NotRequired[pulumi.Input[str]]
        """
        The encoding of the values when the type is not STRING. Acceptable encoding values are: TEXT - indicates values are alphanumeric text strings. BINARY - indicates values are encoded using HBase Bytes.toBytes family of functions. This can be overridden for a specific column by listing that column in 'columns' and specifying an encoding for it.
        """
        family_id: NotRequired[pulumi.Input[str]]
        """
        Identifier of the column family.
        """
        only_read_latest: NotRequired[pulumi.Input[bool]]
        """
        If this is set only the latest version of value are exposed for all columns in this column family. This can be overridden for a specific column by listing that column in 'columns' and specifying a different setting for that column.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type to convert the value in cells of this column family. The values are expected to be encoded using HBase Bytes.toBytes function when using the BINARY encoding value. Following BigQuery types are allowed (case-sensitive): "BYTES", "STRING", "INTEGER", "FLOAT", "BOOLEAN", "JSON". Default type is BYTES. This can be overridden for a specific column by listing that column in 'columns' and specifying a type for it.
        """
elif False:
    TableExternalDataConfigurationBigtableOptionsColumnFamilyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableExternalDataConfigurationBigtableOptionsColumnFamilyArgs:
    def __init__(__self__, *,
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['TableExternalDataConfigurationBigtableOptionsColumnFamilyColumnArgs']]]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 family_id: Optional[pulumi.Input[str]] = None,
                 only_read_latest: Optional[pulumi.Input[bool]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TableExternalDataConfigurationBigtableOptionsColumnFamilyColumnArgs']]] columns: A List of columns that should be exposed as individual fields as opposed to a list of (column name, value) pairs. All columns whose qualifier matches a qualifier in this list can be accessed as Other columns can be accessed as a list through column field.  Structure is documented below.
        :param pulumi.Input[str] encoding: The encoding of the values when the type is not STRING. Acceptable encoding values are: TEXT - indicates values are alphanumeric text strings. BINARY - indicates values are encoded using HBase Bytes.toBytes family of functions. This can be overridden for a specific column by listing that column in 'columns' and specifying an encoding for it.
        :param pulumi.Input[str] family_id: Identifier of the column family.
        :param pulumi.Input[bool] only_read_latest: If this is set only the latest version of value are exposed for all columns in this column family. This can be overridden for a specific column by listing that column in 'columns' and specifying a different setting for that column.
        :param pulumi.Input[str] type: The type to convert the value in cells of this column family. The values are expected to be encoded using HBase Bytes.toBytes function when using the BINARY encoding value. Following BigQuery types are allowed (case-sensitive): "BYTES", "STRING", "INTEGER", "FLOAT", "BOOLEAN", "JSON". Default type is BYTES. This can be overridden for a specific column by listing that column in 'columns' and specifying a type for it.
        """
        if columns is not None:
            pulumi.set(__self__, "columns", columns)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if family_id is not None:
            pulumi.set(__self__, "family_id", family_id)
        if only_read_latest is not None:
            pulumi.set(__self__, "only_read_latest", only_read_latest)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TableExternalDataConfigurationBigtableOptionsColumnFamilyColumnArgs']]]]:
        """
        A List of columns that should be exposed as individual fields as opposed to a list of (column name, value) pairs. All columns whose qualifier matches a qualifier in this list can be accessed as Other columns can be accessed as a list through column field.  Structure is documented below.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TableExternalDataConfigurationBigtableOptionsColumnFamilyColumnArgs']]]]):
        pulumi.set(self, "columns", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        The encoding of the values when the type is not STRING. Acceptable encoding values are: TEXT - indicates values are alphanumeric text strings. BINARY - indicates values are encoded using HBase Bytes.toBytes family of functions. This can be overridden for a specific column by listing that column in 'columns' and specifying an encoding for it.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="familyId")
    def family_id(self) -> Optional[pulumi.Input[str]]:
        """
        Identifier of the column family.
        """
        return pulumi.get(self, "family_id")

    @family_id.setter
    def family_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "family_id", value)

    @property
    @pulumi.getter(name="onlyReadLatest")
    def only_read_latest(self) -> Optional[pulumi.Input[bool]]:
        """
        If this is set only the latest version of value are exposed for all columns in this column family. This can be overridden for a specific column by listing that column in 'columns' and specifying a different setting for that column.
        """
        return pulumi.get(self, "only_read_latest")

    @only_read_latest.setter
    def only_read_latest(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "only_read_latest", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type to convert the value in cells of this column family. The values are expected to be encoded using HBase Bytes.toBytes function when using the BINARY encoding value. Following BigQuery types are allowed (case-sensitive): "BYTES", "STRING", "INTEGER", "FLOAT", "BOOLEAN", "JSON". Default type is BYTES. This can be overridden for a specific column by listing that column in 'columns' and specifying a type for it.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class TableExternalDataConfigurationBigtableOptionsColumnFamilyColumnArgsDict(TypedDict):
        encoding: NotRequired[pulumi.Input[str]]
        """
        The encoding of the values when the type is not STRING. Acceptable encoding values are: TEXT - indicates values are alphanumeric text strings. BINARY - indicates values are encoded using HBase Bytes.toBytes family of functions. 'encoding' can also be set at the column family level. However, the setting at this level takes precedence if 'encoding' is set at both levels.
        """
        field_name: NotRequired[pulumi.Input[str]]
        """
        If the qualifier is not a valid BigQuery field identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier must be provided as the column field name and is used as field name in queries.
        """
        only_read_latest: NotRequired[pulumi.Input[bool]]
        """
        If this is set, only the latest version of value in this column are exposed. 'onlyReadLatest' can also be set at the column family level. However, the setting at this level takes precedence if 'onlyReadLatest' is set at both levels.
        """
        qualifier_encoded: NotRequired[pulumi.Input[str]]
        """
        Qualifier of the column. Columns in the parent column family that has this exact qualifier are exposed as . field. If the qualifier is valid UTF-8 string, it can be specified in the qualifierString field. Otherwise, a base-64 encoded value must be set to qualifierEncoded. The column field name is the same as the column qualifier. However, if the qualifier is not a valid BigQuery field identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier must be provided as fieldName.
        """
        qualifier_string: NotRequired[pulumi.Input[str]]
        """
        Qualifier string.
        """
        type: NotRequired[pulumi.Input[str]]
        """
        The type to convert the value in cells of this column. The values are expected to be encoded using HBase Bytes.toBytes function when using the BINARY encoding value. Following BigQuery types are allowed (case-sensitive): "BYTES", "STRING", "INTEGER", "FLOAT", "BOOLEAN", "JSON", Default type is "BYTES". 'type' can also be set at the column family level. However, the setting at this level takes precedence if 'type' is set at both levels.
        """
elif False:
    TableExternalDataConfigurationBigtableOptionsColumnFamilyColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableExternalDataConfigurationBigtableOptionsColumnFamilyColumnArgs:
    def __init__(__self__, *,
                 encoding: Optional[pulumi.Input[str]] = None,
                 field_name: Optional[pulumi.Input[str]] = None,
                 only_read_latest: Optional[pulumi.Input[bool]] = None,
                 qualifier_encoded: Optional[pulumi.Input[str]] = None,
                 qualifier_string: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] encoding: The encoding of the values when the type is not STRING. Acceptable encoding values are: TEXT - indicates values are alphanumeric text strings. BINARY - indicates values are encoded using HBase Bytes.toBytes family of functions. 'encoding' can also be set at the column family level. However, the setting at this level takes precedence if 'encoding' is set at both levels.
        :param pulumi.Input[str] field_name: If the qualifier is not a valid BigQuery field identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier must be provided as the column field name and is used as field name in queries.
        :param pulumi.Input[bool] only_read_latest: If this is set, only the latest version of value in this column are exposed. 'onlyReadLatest' can also be set at the column family level. However, the setting at this level takes precedence if 'onlyReadLatest' is set at both levels.
        :param pulumi.Input[str] qualifier_encoded: Qualifier of the column. Columns in the parent column family that has this exact qualifier are exposed as . field. If the qualifier is valid UTF-8 string, it can be specified in the qualifierString field. Otherwise, a base-64 encoded value must be set to qualifierEncoded. The column field name is the same as the column qualifier. However, if the qualifier is not a valid BigQuery field identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier must be provided as fieldName.
        :param pulumi.Input[str] qualifier_string: Qualifier string.
        :param pulumi.Input[str] type: The type to convert the value in cells of this column. The values are expected to be encoded using HBase Bytes.toBytes function when using the BINARY encoding value. Following BigQuery types are allowed (case-sensitive): "BYTES", "STRING", "INTEGER", "FLOAT", "BOOLEAN", "JSON", Default type is "BYTES". 'type' can also be set at the column family level. However, the setting at this level takes precedence if 'type' is set at both levels.
        """
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)
        if only_read_latest is not None:
            pulumi.set(__self__, "only_read_latest", only_read_latest)
        if qualifier_encoded is not None:
            pulumi.set(__self__, "qualifier_encoded", qualifier_encoded)
        if qualifier_string is not None:
            pulumi.set(__self__, "qualifier_string", qualifier_string)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        The encoding of the values when the type is not STRING. Acceptable encoding values are: TEXT - indicates values are alphanumeric text strings. BINARY - indicates values are encoded using HBase Bytes.toBytes family of functions. 'encoding' can also be set at the column family level. However, the setting at this level takes precedence if 'encoding' is set at both levels.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[pulumi.Input[str]]:
        """
        If the qualifier is not a valid BigQuery field identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier must be provided as the column field name and is used as field name in queries.
        """
        return pulumi.get(self, "field_name")

    @field_name.setter
    def field_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_name", value)

    @property
    @pulumi.getter(name="onlyReadLatest")
    def only_read_latest(self) -> Optional[pulumi.Input[bool]]:
        """
        If this is set, only the latest version of value in this column are exposed. 'onlyReadLatest' can also be set at the column family level. However, the setting at this level takes precedence if 'onlyReadLatest' is set at both levels.
        """
        return pulumi.get(self, "only_read_latest")

    @only_read_latest.setter
    def only_read_latest(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "only_read_latest", value)

    @property
    @pulumi.getter(name="qualifierEncoded")
    def qualifier_encoded(self) -> Optional[pulumi.Input[str]]:
        """
        Qualifier of the column. Columns in the parent column family that has this exact qualifier are exposed as . field. If the qualifier is valid UTF-8 string, it can be specified in the qualifierString field. Otherwise, a base-64 encoded value must be set to qualifierEncoded. The column field name is the same as the column qualifier. However, if the qualifier is not a valid BigQuery field identifier i.e. does not match [a-zA-Z][a-zA-Z0-9_]*, a valid identifier must be provided as fieldName.
        """
        return pulumi.get(self, "qualifier_encoded")

    @qualifier_encoded.setter
    def qualifier_encoded(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "qualifier_encoded", value)

    @property
    @pulumi.getter(name="qualifierString")
    def qualifier_string(self) -> Optional[pulumi.Input[str]]:
        """
        Qualifier string.
        """
        return pulumi.get(self, "qualifier_string")

    @qualifier_string.setter
    def qualifier_string(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "qualifier_string", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        The type to convert the value in cells of this column. The values are expected to be encoded using HBase Bytes.toBytes function when using the BINARY encoding value. Following BigQuery types are allowed (case-sensitive): "BYTES", "STRING", "INTEGER", "FLOAT", "BOOLEAN", "JSON", Default type is "BYTES". 'type' can also be set at the column family level. However, the setting at this level takes precedence if 'type' is set at both levels.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class TableExternalDataConfigurationCsvOptionsArgsDict(TypedDict):
        quote: pulumi.Input[str]
        """
        The value that is used to quote data sections in a
        CSV file. If your data does not contain quoted sections, set the
        property value to an empty string. If your data contains quoted newline
        characters, you must also set the `allow_quoted_newlines` property to true.
        The API-side default is `"`, specified in the provider escaped as `\\"`. Due to
        limitations with default values, this value is required to be
        explicitly set.
        """
        allow_jagged_rows: NotRequired[pulumi.Input[bool]]
        """
        Indicates if BigQuery should accept rows
        that are missing trailing optional columns.
        """
        allow_quoted_newlines: NotRequired[pulumi.Input[bool]]
        """
        Indicates if BigQuery should allow
        quoted data sections that contain newline characters in a CSV file.
        The default value is false.
        """
        encoding: NotRequired[pulumi.Input[str]]
        """
        The character encoding of the data. The supported
        values are UTF-8 or ISO-8859-1.
        """
        field_delimiter: NotRequired[pulumi.Input[str]]
        """
        The separator for fields in a CSV file.
        """
        skip_leading_rows: NotRequired[pulumi.Input[int]]
        """
        The number of rows at the top of a CSV
        file that BigQuery will skip when reading the data.
        """
elif False:
    TableExternalDataConfigurationCsvOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableExternalDataConfigurationCsvOptionsArgs:
    def __init__(__self__, *,
                 quote: pulumi.Input[str],
                 allow_jagged_rows: Optional[pulumi.Input[bool]] = None,
                 allow_quoted_newlines: Optional[pulumi.Input[bool]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 field_delimiter: Optional[pulumi.Input[str]] = None,
                 skip_leading_rows: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] quote: The value that is used to quote data sections in a
               CSV file. If your data does not contain quoted sections, set the
               property value to an empty string. If your data contains quoted newline
               characters, you must also set the `allow_quoted_newlines` property to true.
               The API-side default is `"`, specified in the provider escaped as `\\"`. Due to
               limitations with default values, this value is required to be
               explicitly set.
        :param pulumi.Input[bool] allow_jagged_rows: Indicates if BigQuery should accept rows
               that are missing trailing optional columns.
        :param pulumi.Input[bool] allow_quoted_newlines: Indicates if BigQuery should allow
               quoted data sections that contain newline characters in a CSV file.
               The default value is false.
        :param pulumi.Input[str] encoding: The character encoding of the data. The supported
               values are UTF-8 or ISO-8859-1.
        :param pulumi.Input[str] field_delimiter: The separator for fields in a CSV file.
        :param pulumi.Input[int] skip_leading_rows: The number of rows at the top of a CSV
               file that BigQuery will skip when reading the data.
        """
        pulumi.set(__self__, "quote", quote)
        if allow_jagged_rows is not None:
            pulumi.set(__self__, "allow_jagged_rows", allow_jagged_rows)
        if allow_quoted_newlines is not None:
            pulumi.set(__self__, "allow_quoted_newlines", allow_quoted_newlines)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if field_delimiter is not None:
            pulumi.set(__self__, "field_delimiter", field_delimiter)
        if skip_leading_rows is not None:
            pulumi.set(__self__, "skip_leading_rows", skip_leading_rows)

    @property
    @pulumi.getter
    def quote(self) -> pulumi.Input[str]:
        """
        The value that is used to quote data sections in a
        CSV file. If your data does not contain quoted sections, set the
        property value to an empty string. If your data contains quoted newline
        characters, you must also set the `allow_quoted_newlines` property to true.
        The API-side default is `"`, specified in the provider escaped as `\\"`. Due to
        limitations with default values, this value is required to be
        explicitly set.
        """
        return pulumi.get(self, "quote")

    @quote.setter
    def quote(self, value: pulumi.Input[str]):
        pulumi.set(self, "quote", value)

    @property
    @pulumi.getter(name="allowJaggedRows")
    def allow_jagged_rows(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if BigQuery should accept rows
        that are missing trailing optional columns.
        """
        return pulumi.get(self, "allow_jagged_rows")

    @allow_jagged_rows.setter
    def allow_jagged_rows(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_jagged_rows", value)

    @property
    @pulumi.getter(name="allowQuotedNewlines")
    def allow_quoted_newlines(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates if BigQuery should allow
        quoted data sections that contain newline characters in a CSV file.
        The default value is false.
        """
        return pulumi.get(self, "allow_quoted_newlines")

    @allow_quoted_newlines.setter
    def allow_quoted_newlines(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_quoted_newlines", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        The character encoding of the data. The supported
        values are UTF-8 or ISO-8859-1.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter(name="fieldDelimiter")
    def field_delimiter(self) -> Optional[pulumi.Input[str]]:
        """
        The separator for fields in a CSV file.
        """
        return pulumi.get(self, "field_delimiter")

    @field_delimiter.setter
    def field_delimiter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field_delimiter", value)

    @property
    @pulumi.getter(name="skipLeadingRows")
    def skip_leading_rows(self) -> Optional[pulumi.Input[int]]:
        """
        The number of rows at the top of a CSV
        file that BigQuery will skip when reading the data.
        """
        return pulumi.get(self, "skip_leading_rows")

    @skip_leading_rows.setter
    def skip_leading_rows(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_leading_rows", value)


if not MYPY:
    class TableExternalDataConfigurationGoogleSheetsOptionsArgsDict(TypedDict):
        range: NotRequired[pulumi.Input[str]]
        """
        Range of a sheet to query from. Only used when
        non-empty. At least one of `range` or `skip_leading_rows` must be set.
        Typical format: "sheet_name!top_left_cell_id:bottom_right_cell_id"
        For example: "sheet1!A1:B20"
        """
        skip_leading_rows: NotRequired[pulumi.Input[int]]
        """
        The number of rows at the top of the sheet
        that BigQuery will skip when reading the data. At least one of `range` or
        `skip_leading_rows` must be set.
        """
elif False:
    TableExternalDataConfigurationGoogleSheetsOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableExternalDataConfigurationGoogleSheetsOptionsArgs:
    def __init__(__self__, *,
                 range: Optional[pulumi.Input[str]] = None,
                 skip_leading_rows: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] range: Range of a sheet to query from. Only used when
               non-empty. At least one of `range` or `skip_leading_rows` must be set.
               Typical format: "sheet_name!top_left_cell_id:bottom_right_cell_id"
               For example: "sheet1!A1:B20"
        :param pulumi.Input[int] skip_leading_rows: The number of rows at the top of the sheet
               that BigQuery will skip when reading the data. At least one of `range` or
               `skip_leading_rows` must be set.
        """
        if range is not None:
            pulumi.set(__self__, "range", range)
        if skip_leading_rows is not None:
            pulumi.set(__self__, "skip_leading_rows", skip_leading_rows)

    @property
    @pulumi.getter
    def range(self) -> Optional[pulumi.Input[str]]:
        """
        Range of a sheet to query from. Only used when
        non-empty. At least one of `range` or `skip_leading_rows` must be set.
        Typical format: "sheet_name!top_left_cell_id:bottom_right_cell_id"
        For example: "sheet1!A1:B20"
        """
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "range", value)

    @property
    @pulumi.getter(name="skipLeadingRows")
    def skip_leading_rows(self) -> Optional[pulumi.Input[int]]:
        """
        The number of rows at the top of the sheet
        that BigQuery will skip when reading the data. At least one of `range` or
        `skip_leading_rows` must be set.
        """
        return pulumi.get(self, "skip_leading_rows")

    @skip_leading_rows.setter
    def skip_leading_rows(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "skip_leading_rows", value)


if not MYPY:
    class TableExternalDataConfigurationHivePartitioningOptionsArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[str]]
        """
        When set, what mode of hive partitioning to use when
        reading data. The following modes are supported.
        * AUTO: automatically infer partition key name(s) and type(s).
        * STRINGS: automatically infer partition key name(s). All types are
        Not all storage formats support hive partitioning. Requesting hive
        partitioning on an unsupported format will lead to an error.
        Currently supported formats are: JSON, CSV, ORC, Avro and Parquet.
        * CUSTOM: when set to `CUSTOM`, you must encode the partition key schema within the `source_uri_prefix` by setting `source_uri_prefix` to `gs://bucket/path_to_table/{key1:TYPE1}/{key2:TYPE2}/{key3:TYPE3}`.
        """
        require_partition_filter: NotRequired[pulumi.Input[bool]]
        """
        If set to true, queries over this table
        require a partition filter that can be used for partition elimination to be
        specified.
        """
        source_uri_prefix: NotRequired[pulumi.Input[str]]
        """
        When hive partition detection is requested,
        a common for all source uris must be required. The prefix must end immediately
        before the partition key encoding begins. For example, consider files following
        this data layout. `gs://bucket/path_to_table/dt=2019-06-01/country=USA/id=7/file.avro`
        `gs://bucket/path_to_table/dt=2019-05-31/country=CA/id=3/file.avro` When hive
        partitioning is requested with either AUTO or STRINGS detection, the common prefix
        can be either of `gs://bucket/path_to_table` or `gs://bucket/path_to_table/`.
        Note that when `mode` is set to `CUSTOM`, you must encode the partition key schema within the `source_uri_prefix` by setting `source_uri_prefix` to `gs://bucket/path_to_table/{key1:TYPE1}/{key2:TYPE2}/{key3:TYPE3}`.
        """
elif False:
    TableExternalDataConfigurationHivePartitioningOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableExternalDataConfigurationHivePartitioningOptionsArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[str]] = None,
                 require_partition_filter: Optional[pulumi.Input[bool]] = None,
                 source_uri_prefix: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] mode: When set, what mode of hive partitioning to use when
               reading data. The following modes are supported.
               * AUTO: automatically infer partition key name(s) and type(s).
               * STRINGS: automatically infer partition key name(s). All types are
               Not all storage formats support hive partitioning. Requesting hive
               partitioning on an unsupported format will lead to an error.
               Currently supported formats are: JSON, CSV, ORC, Avro and Parquet.
               * CUSTOM: when set to `CUSTOM`, you must encode the partition key schema within the `source_uri_prefix` by setting `source_uri_prefix` to `gs://bucket/path_to_table/{key1:TYPE1}/{key2:TYPE2}/{key3:TYPE3}`.
        :param pulumi.Input[bool] require_partition_filter: If set to true, queries over this table
               require a partition filter that can be used for partition elimination to be
               specified.
        :param pulumi.Input[str] source_uri_prefix: When hive partition detection is requested,
               a common for all source uris must be required. The prefix must end immediately
               before the partition key encoding begins. For example, consider files following
               this data layout. `gs://bucket/path_to_table/dt=2019-06-01/country=USA/id=7/file.avro`
               `gs://bucket/path_to_table/dt=2019-05-31/country=CA/id=3/file.avro` When hive
               partitioning is requested with either AUTO or STRINGS detection, the common prefix
               can be either of `gs://bucket/path_to_table` or `gs://bucket/path_to_table/`.
               Note that when `mode` is set to `CUSTOM`, you must encode the partition key schema within the `source_uri_prefix` by setting `source_uri_prefix` to `gs://bucket/path_to_table/{key1:TYPE1}/{key2:TYPE2}/{key3:TYPE3}`.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if require_partition_filter is not None:
            pulumi.set(__self__, "require_partition_filter", require_partition_filter)
        if source_uri_prefix is not None:
            pulumi.set(__self__, "source_uri_prefix", source_uri_prefix)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[str]]:
        """
        When set, what mode of hive partitioning to use when
        reading data. The following modes are supported.
        * AUTO: automatically infer partition key name(s) and type(s).
        * STRINGS: automatically infer partition key name(s). All types are
        Not all storage formats support hive partitioning. Requesting hive
        partitioning on an unsupported format will lead to an error.
        Currently supported formats are: JSON, CSV, ORC, Avro and Parquet.
        * CUSTOM: when set to `CUSTOM`, you must encode the partition key schema within the `source_uri_prefix` by setting `source_uri_prefix` to `gs://bucket/path_to_table/{key1:TYPE1}/{key2:TYPE2}/{key3:TYPE3}`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="requirePartitionFilter")
    def require_partition_filter(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, queries over this table
        require a partition filter that can be used for partition elimination to be
        specified.
        """
        return pulumi.get(self, "require_partition_filter")

    @require_partition_filter.setter
    def require_partition_filter(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_partition_filter", value)

    @property
    @pulumi.getter(name="sourceUriPrefix")
    def source_uri_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        When hive partition detection is requested,
        a common for all source uris must be required. The prefix must end immediately
        before the partition key encoding begins. For example, consider files following
        this data layout. `gs://bucket/path_to_table/dt=2019-06-01/country=USA/id=7/file.avro`
        `gs://bucket/path_to_table/dt=2019-05-31/country=CA/id=3/file.avro` When hive
        partitioning is requested with either AUTO or STRINGS detection, the common prefix
        can be either of `gs://bucket/path_to_table` or `gs://bucket/path_to_table/`.
        Note that when `mode` is set to `CUSTOM`, you must encode the partition key schema within the `source_uri_prefix` by setting `source_uri_prefix` to `gs://bucket/path_to_table/{key1:TYPE1}/{key2:TYPE2}/{key3:TYPE3}`.
        """
        return pulumi.get(self, "source_uri_prefix")

    @source_uri_prefix.setter
    def source_uri_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_uri_prefix", value)


if not MYPY:
    class TableExternalDataConfigurationJsonOptionsArgsDict(TypedDict):
        encoding: NotRequired[pulumi.Input[str]]
        """
        The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
        """
elif False:
    TableExternalDataConfigurationJsonOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableExternalDataConfigurationJsonOptionsArgs:
    def __init__(__self__, *,
                 encoding: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] encoding: The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
        """
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        The character encoding of the data. The supported values are UTF-8, UTF-16BE, UTF-16LE, UTF-32BE, and UTF-32LE. The default value is UTF-8.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)


if not MYPY:
    class TableExternalDataConfigurationParquetOptionsArgsDict(TypedDict):
        enable_list_inference: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether to use schema inference specifically for Parquet LIST logical type.
        """
        enum_as_string: NotRequired[pulumi.Input[bool]]
        """
        Indicates whether to infer Parquet ENUM logical type as STRING instead of BYTES by default.
        """
elif False:
    TableExternalDataConfigurationParquetOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableExternalDataConfigurationParquetOptionsArgs:
    def __init__(__self__, *,
                 enable_list_inference: Optional[pulumi.Input[bool]] = None,
                 enum_as_string: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enable_list_inference: Indicates whether to use schema inference specifically for Parquet LIST logical type.
        :param pulumi.Input[bool] enum_as_string: Indicates whether to infer Parquet ENUM logical type as STRING instead of BYTES by default.
        """
        if enable_list_inference is not None:
            pulumi.set(__self__, "enable_list_inference", enable_list_inference)
        if enum_as_string is not None:
            pulumi.set(__self__, "enum_as_string", enum_as_string)

    @property
    @pulumi.getter(name="enableListInference")
    def enable_list_inference(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to use schema inference specifically for Parquet LIST logical type.
        """
        return pulumi.get(self, "enable_list_inference")

    @enable_list_inference.setter
    def enable_list_inference(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_list_inference", value)

    @property
    @pulumi.getter(name="enumAsString")
    def enum_as_string(self) -> Optional[pulumi.Input[bool]]:
        """
        Indicates whether to infer Parquet ENUM logical type as STRING instead of BYTES by default.
        """
        return pulumi.get(self, "enum_as_string")

    @enum_as_string.setter
    def enum_as_string(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enum_as_string", value)


if not MYPY:
    class TableMaterializedViewArgsDict(TypedDict):
        query: pulumi.Input[str]
        """
        A query whose result is persisted.
        """
        allow_non_incremental_definition: NotRequired[pulumi.Input[bool]]
        """
        Allow non incremental materialized view definition.
        The default value is false.
        """
        enable_refresh: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether to use BigQuery's automatic refresh for this materialized view when the base table is updated.
        The default value is true.
        """
        refresh_interval_ms: NotRequired[pulumi.Input[int]]
        """
        The maximum frequency at which this materialized view will be refreshed.
        The default value is 1800000
        """
elif False:
    TableMaterializedViewArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableMaterializedViewArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 allow_non_incremental_definition: Optional[pulumi.Input[bool]] = None,
                 enable_refresh: Optional[pulumi.Input[bool]] = None,
                 refresh_interval_ms: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] query: A query whose result is persisted.
        :param pulumi.Input[bool] allow_non_incremental_definition: Allow non incremental materialized view definition.
               The default value is false.
        :param pulumi.Input[bool] enable_refresh: Specifies whether to use BigQuery's automatic refresh for this materialized view when the base table is updated.
               The default value is true.
        :param pulumi.Input[int] refresh_interval_ms: The maximum frequency at which this materialized view will be refreshed.
               The default value is 1800000
        """
        pulumi.set(__self__, "query", query)
        if allow_non_incremental_definition is not None:
            pulumi.set(__self__, "allow_non_incremental_definition", allow_non_incremental_definition)
        if enable_refresh is not None:
            pulumi.set(__self__, "enable_refresh", enable_refresh)
        if refresh_interval_ms is not None:
            pulumi.set(__self__, "refresh_interval_ms", refresh_interval_ms)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        A query whose result is persisted.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="allowNonIncrementalDefinition")
    def allow_non_incremental_definition(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow non incremental materialized view definition.
        The default value is false.
        """
        return pulumi.get(self, "allow_non_incremental_definition")

    @allow_non_incremental_definition.setter
    def allow_non_incremental_definition(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "allow_non_incremental_definition", value)

    @property
    @pulumi.getter(name="enableRefresh")
    def enable_refresh(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether to use BigQuery's automatic refresh for this materialized view when the base table is updated.
        The default value is true.
        """
        return pulumi.get(self, "enable_refresh")

    @enable_refresh.setter
    def enable_refresh(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_refresh", value)

    @property
    @pulumi.getter(name="refreshIntervalMs")
    def refresh_interval_ms(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum frequency at which this materialized view will be refreshed.
        The default value is 1800000
        """
        return pulumi.get(self, "refresh_interval_ms")

    @refresh_interval_ms.setter
    def refresh_interval_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "refresh_interval_ms", value)


if not MYPY:
    class TableRangePartitioningArgsDict(TypedDict):
        field: pulumi.Input[str]
        """
        The field used to determine how to create a range-based
        partition.
        """
        range: pulumi.Input['TableRangePartitioningRangeArgsDict']
        """
        Information required to partition based on ranges.
        Structure is documented below.
        """
elif False:
    TableRangePartitioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableRangePartitioningArgs:
    def __init__(__self__, *,
                 field: pulumi.Input[str],
                 range: pulumi.Input['TableRangePartitioningRangeArgs']):
        """
        :param pulumi.Input[str] field: The field used to determine how to create a range-based
               partition.
        :param pulumi.Input['TableRangePartitioningRangeArgs'] range: Information required to partition based on ranges.
               Structure is documented below.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "range", range)

    @property
    @pulumi.getter
    def field(self) -> pulumi.Input[str]:
        """
        The field used to determine how to create a range-based
        partition.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input[str]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def range(self) -> pulumi.Input['TableRangePartitioningRangeArgs']:
        """
        Information required to partition based on ranges.
        Structure is documented below.
        """
        return pulumi.get(self, "range")

    @range.setter
    def range(self, value: pulumi.Input['TableRangePartitioningRangeArgs']):
        pulumi.set(self, "range", value)


if not MYPY:
    class TableRangePartitioningRangeArgsDict(TypedDict):
        end: pulumi.Input[int]
        """
        End of the range partitioning, exclusive.
        """
        interval: pulumi.Input[int]
        """
        The width of each range within the partition.
        """
        start: pulumi.Input[int]
        """
        Start of the range partitioning, inclusive.
        """
elif False:
    TableRangePartitioningRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableRangePartitioningRangeArgs:
    def __init__(__self__, *,
                 end: pulumi.Input[int],
                 interval: pulumi.Input[int],
                 start: pulumi.Input[int]):
        """
        :param pulumi.Input[int] end: End of the range partitioning, exclusive.
        :param pulumi.Input[int] interval: The width of each range within the partition.
        :param pulumi.Input[int] start: Start of the range partitioning, inclusive.
        """
        pulumi.set(__self__, "end", end)
        pulumi.set(__self__, "interval", interval)
        pulumi.set(__self__, "start", start)

    @property
    @pulumi.getter
    def end(self) -> pulumi.Input[int]:
        """
        End of the range partitioning, exclusive.
        """
        return pulumi.get(self, "end")

    @end.setter
    def end(self, value: pulumi.Input[int]):
        pulumi.set(self, "end", value)

    @property
    @pulumi.getter
    def interval(self) -> pulumi.Input[int]:
        """
        The width of each range within the partition.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: pulumi.Input[int]):
        pulumi.set(self, "interval", value)

    @property
    @pulumi.getter
    def start(self) -> pulumi.Input[int]:
        """
        Start of the range partitioning, inclusive.
        """
        return pulumi.get(self, "start")

    @start.setter
    def start(self, value: pulumi.Input[int]):
        pulumi.set(self, "start", value)


if not MYPY:
    class TableSchemaForeignTypeInfoArgsDict(TypedDict):
        type_system: pulumi.Input[str]
        """
        Specifies the system which defines the foreign data type.
        """
elif False:
    TableSchemaForeignTypeInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableSchemaForeignTypeInfoArgs:
    def __init__(__self__, *,
                 type_system: pulumi.Input[str]):
        """
        :param pulumi.Input[str] type_system: Specifies the system which defines the foreign data type.
        """
        pulumi.set(__self__, "type_system", type_system)

    @property
    @pulumi.getter(name="typeSystem")
    def type_system(self) -> pulumi.Input[str]:
        """
        Specifies the system which defines the foreign data type.
        """
        return pulumi.get(self, "type_system")

    @type_system.setter
    def type_system(self, value: pulumi.Input[str]):
        pulumi.set(self, "type_system", value)


if not MYPY:
    class TableTableConstraintsArgsDict(TypedDict):
        foreign_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input['TableTableConstraintsForeignKeyArgsDict']]]]
        """
        Present only if the table has a foreign key.
        The foreign key is not enforced.
        Structure is documented below.
        """
        primary_key: NotRequired[pulumi.Input['TableTableConstraintsPrimaryKeyArgsDict']]
        """
        Represents the primary key constraint
        on a table's columns. Present only if the table has a primary key.
        The primary key is not enforced.
        Structure is documented below.
        """
elif False:
    TableTableConstraintsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableTableConstraintsArgs:
    def __init__(__self__, *,
                 foreign_keys: Optional[pulumi.Input[Sequence[pulumi.Input['TableTableConstraintsForeignKeyArgs']]]] = None,
                 primary_key: Optional[pulumi.Input['TableTableConstraintsPrimaryKeyArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['TableTableConstraintsForeignKeyArgs']]] foreign_keys: Present only if the table has a foreign key.
               The foreign key is not enforced.
               Structure is documented below.
        :param pulumi.Input['TableTableConstraintsPrimaryKeyArgs'] primary_key: Represents the primary key constraint
               on a table's columns. Present only if the table has a primary key.
               The primary key is not enforced.
               Structure is documented below.
        """
        if foreign_keys is not None:
            pulumi.set(__self__, "foreign_keys", foreign_keys)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)

    @property
    @pulumi.getter(name="foreignKeys")
    def foreign_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['TableTableConstraintsForeignKeyArgs']]]]:
        """
        Present only if the table has a foreign key.
        The foreign key is not enforced.
        Structure is documented below.
        """
        return pulumi.get(self, "foreign_keys")

    @foreign_keys.setter
    def foreign_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['TableTableConstraintsForeignKeyArgs']]]]):
        pulumi.set(self, "foreign_keys", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input['TableTableConstraintsPrimaryKeyArgs']]:
        """
        Represents the primary key constraint
        on a table's columns. Present only if the table has a primary key.
        The primary key is not enforced.
        Structure is documented below.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input['TableTableConstraintsPrimaryKeyArgs']]):
        pulumi.set(self, "primary_key", value)


if not MYPY:
    class TableTableConstraintsForeignKeyArgsDict(TypedDict):
        column_references: pulumi.Input['TableTableConstraintsForeignKeyColumnReferencesArgsDict']
        """
        The pair of the foreign key column and primary key column.
        Structure is documented below.
        """
        referenced_table: pulumi.Input['TableTableConstraintsForeignKeyReferencedTableArgsDict']
        """
        The table that holds the primary key
        and is referenced by this foreign key.
        Structure is documented below.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        Set only if the foreign key constraint is named.
        """
elif False:
    TableTableConstraintsForeignKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableTableConstraintsForeignKeyArgs:
    def __init__(__self__, *,
                 column_references: pulumi.Input['TableTableConstraintsForeignKeyColumnReferencesArgs'],
                 referenced_table: pulumi.Input['TableTableConstraintsForeignKeyReferencedTableArgs'],
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['TableTableConstraintsForeignKeyColumnReferencesArgs'] column_references: The pair of the foreign key column and primary key column.
               Structure is documented below.
        :param pulumi.Input['TableTableConstraintsForeignKeyReferencedTableArgs'] referenced_table: The table that holds the primary key
               and is referenced by this foreign key.
               Structure is documented below.
        :param pulumi.Input[str] name: Set only if the foreign key constraint is named.
        """
        pulumi.set(__self__, "column_references", column_references)
        pulumi.set(__self__, "referenced_table", referenced_table)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter(name="columnReferences")
    def column_references(self) -> pulumi.Input['TableTableConstraintsForeignKeyColumnReferencesArgs']:
        """
        The pair of the foreign key column and primary key column.
        Structure is documented below.
        """
        return pulumi.get(self, "column_references")

    @column_references.setter
    def column_references(self, value: pulumi.Input['TableTableConstraintsForeignKeyColumnReferencesArgs']):
        pulumi.set(self, "column_references", value)

    @property
    @pulumi.getter(name="referencedTable")
    def referenced_table(self) -> pulumi.Input['TableTableConstraintsForeignKeyReferencedTableArgs']:
        """
        The table that holds the primary key
        and is referenced by this foreign key.
        Structure is documented below.
        """
        return pulumi.get(self, "referenced_table")

    @referenced_table.setter
    def referenced_table(self, value: pulumi.Input['TableTableConstraintsForeignKeyReferencedTableArgs']):
        pulumi.set(self, "referenced_table", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Set only if the foreign key constraint is named.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class TableTableConstraintsForeignKeyColumnReferencesArgsDict(TypedDict):
        referenced_column: pulumi.Input[str]
        """
        The column in the primary key that are
        referenced by the referencingColumn
        """
        referencing_column: pulumi.Input[str]
        """
        The column that composes the foreign key.
        """
elif False:
    TableTableConstraintsForeignKeyColumnReferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableTableConstraintsForeignKeyColumnReferencesArgs:
    def __init__(__self__, *,
                 referenced_column: pulumi.Input[str],
                 referencing_column: pulumi.Input[str]):
        """
        :param pulumi.Input[str] referenced_column: The column in the primary key that are
               referenced by the referencingColumn
        :param pulumi.Input[str] referencing_column: The column that composes the foreign key.
        """
        pulumi.set(__self__, "referenced_column", referenced_column)
        pulumi.set(__self__, "referencing_column", referencing_column)

    @property
    @pulumi.getter(name="referencedColumn")
    def referenced_column(self) -> pulumi.Input[str]:
        """
        The column in the primary key that are
        referenced by the referencingColumn
        """
        return pulumi.get(self, "referenced_column")

    @referenced_column.setter
    def referenced_column(self, value: pulumi.Input[str]):
        pulumi.set(self, "referenced_column", value)

    @property
    @pulumi.getter(name="referencingColumn")
    def referencing_column(self) -> pulumi.Input[str]:
        """
        The column that composes the foreign key.
        """
        return pulumi.get(self, "referencing_column")

    @referencing_column.setter
    def referencing_column(self, value: pulumi.Input[str]):
        pulumi.set(self, "referencing_column", value)


if not MYPY:
    class TableTableConstraintsForeignKeyReferencedTableArgsDict(TypedDict):
        dataset_id: pulumi.Input[str]
        """
        The ID of the dataset containing this table.
        """
        project_id: pulumi.Input[str]
        """
        The ID of the project containing this table.
        """
        table_id: pulumi.Input[str]
        """
        The ID of the table. The ID must contain only
        letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum
        length is 1,024 characters. Certain operations allow suffixing of
        the table ID with a partition decorator, such as
        sample_table$20190123.
        """
elif False:
    TableTableConstraintsForeignKeyReferencedTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableTableConstraintsForeignKeyReferencedTableArgs:
    def __init__(__self__, *,
                 dataset_id: pulumi.Input[str],
                 project_id: pulumi.Input[str],
                 table_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] dataset_id: The ID of the dataset containing this table.
        :param pulumi.Input[str] project_id: The ID of the project containing this table.
        :param pulumi.Input[str] table_id: The ID of the table. The ID must contain only
               letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum
               length is 1,024 characters. Certain operations allow suffixing of
               the table ID with a partition decorator, such as
               sample_table$20190123.
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "table_id", table_id)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> pulumi.Input[str]:
        """
        The ID of the dataset containing this table.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The ID of the project containing this table.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="tableId")
    def table_id(self) -> pulumi.Input[str]:
        """
        The ID of the table. The ID must contain only
        letters (a-z, A-Z), numbers (0-9), or underscores (_). The maximum
        length is 1,024 characters. Certain operations allow suffixing of
        the table ID with a partition decorator, such as
        sample_table$20190123.
        """
        return pulumi.get(self, "table_id")

    @table_id.setter
    def table_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_id", value)


if not MYPY:
    class TableTableConstraintsPrimaryKeyArgsDict(TypedDict):
        columns: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        The columns that are composed of the primary key constraint.
        """
elif False:
    TableTableConstraintsPrimaryKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableTableConstraintsPrimaryKeyArgs:
    def __init__(__self__, *,
                 columns: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] columns: The columns that are composed of the primary key constraint.
        """
        pulumi.set(__self__, "columns", columns)

    @property
    @pulumi.getter
    def columns(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The columns that are composed of the primary key constraint.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "columns", value)


if not MYPY:
    class TableTableReplicationInfoArgsDict(TypedDict):
        source_dataset_id: pulumi.Input[str]
        """
        The ID of the source dataset.
        """
        source_project_id: pulumi.Input[str]
        """
        The ID of the source project.
        """
        source_table_id: pulumi.Input[str]
        """
        The ID of the source materialized view.
        """
        replication_interval_ms: NotRequired[pulumi.Input[int]]
        """
        The interval at which the source
        materialized view is polled for updates. The default is 300000.
        """
elif False:
    TableTableReplicationInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableTableReplicationInfoArgs:
    def __init__(__self__, *,
                 source_dataset_id: pulumi.Input[str],
                 source_project_id: pulumi.Input[str],
                 source_table_id: pulumi.Input[str],
                 replication_interval_ms: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] source_dataset_id: The ID of the source dataset.
        :param pulumi.Input[str] source_project_id: The ID of the source project.
        :param pulumi.Input[str] source_table_id: The ID of the source materialized view.
        :param pulumi.Input[int] replication_interval_ms: The interval at which the source
               materialized view is polled for updates. The default is 300000.
        """
        pulumi.set(__self__, "source_dataset_id", source_dataset_id)
        pulumi.set(__self__, "source_project_id", source_project_id)
        pulumi.set(__self__, "source_table_id", source_table_id)
        if replication_interval_ms is not None:
            pulumi.set(__self__, "replication_interval_ms", replication_interval_ms)

    @property
    @pulumi.getter(name="sourceDatasetId")
    def source_dataset_id(self) -> pulumi.Input[str]:
        """
        The ID of the source dataset.
        """
        return pulumi.get(self, "source_dataset_id")

    @source_dataset_id.setter
    def source_dataset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_dataset_id", value)

    @property
    @pulumi.getter(name="sourceProjectId")
    def source_project_id(self) -> pulumi.Input[str]:
        """
        The ID of the source project.
        """
        return pulumi.get(self, "source_project_id")

    @source_project_id.setter
    def source_project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_project_id", value)

    @property
    @pulumi.getter(name="sourceTableId")
    def source_table_id(self) -> pulumi.Input[str]:
        """
        The ID of the source materialized view.
        """
        return pulumi.get(self, "source_table_id")

    @source_table_id.setter
    def source_table_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_table_id", value)

    @property
    @pulumi.getter(name="replicationIntervalMs")
    def replication_interval_ms(self) -> Optional[pulumi.Input[int]]:
        """
        The interval at which the source
        materialized view is polled for updates. The default is 300000.
        """
        return pulumi.get(self, "replication_interval_ms")

    @replication_interval_ms.setter
    def replication_interval_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replication_interval_ms", value)


if not MYPY:
    class TableTimePartitioningArgsDict(TypedDict):
        type: pulumi.Input[str]
        """
        The supported types are DAY, HOUR, MONTH, and YEAR,
        which will generate one partition per day, hour, month, and year, respectively.
        """
        expiration_ms: NotRequired[pulumi.Input[int]]
        """
        Number of milliseconds for which to keep the
        storage for a partition.
        """
        field: NotRequired[pulumi.Input[str]]
        """
        The field used to determine how to create a time-based
        partition. If time-based partitioning is enabled without this value, the
        table is partitioned based on the load time.
        """
        require_partition_filter: NotRequired[pulumi.Input[bool]]
        """
        If set to true, queries over this table
        require a partition filter that can be used for partition elimination to be
        specified. `require_partition_filter` is deprecated and will be removed in
        a future major release. Use the top level field with the same name instead.
        """
elif False:
    TableTimePartitioningArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableTimePartitioningArgs:
    def __init__(__self__, *,
                 type: pulumi.Input[str],
                 expiration_ms: Optional[pulumi.Input[int]] = None,
                 field: Optional[pulumi.Input[str]] = None,
                 require_partition_filter: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] type: The supported types are DAY, HOUR, MONTH, and YEAR,
               which will generate one partition per day, hour, month, and year, respectively.
        :param pulumi.Input[int] expiration_ms: Number of milliseconds for which to keep the
               storage for a partition.
        :param pulumi.Input[str] field: The field used to determine how to create a time-based
               partition. If time-based partitioning is enabled without this value, the
               table is partitioned based on the load time.
        :param pulumi.Input[bool] require_partition_filter: If set to true, queries over this table
               require a partition filter that can be used for partition elimination to be
               specified. `require_partition_filter` is deprecated and will be removed in
               a future major release. Use the top level field with the same name instead.
        """
        pulumi.set(__self__, "type", type)
        if expiration_ms is not None:
            pulumi.set(__self__, "expiration_ms", expiration_ms)
        if field is not None:
            pulumi.set(__self__, "field", field)
        if require_partition_filter is not None:
            warnings.warn("""This field is deprecated and will be removed in a future major release; please use the top level field with the same name instead.""", DeprecationWarning)
            pulumi.log.warn("""require_partition_filter is deprecated: This field is deprecated and will be removed in a future major release; please use the top level field with the same name instead.""")
        if require_partition_filter is not None:
            pulumi.set(__self__, "require_partition_filter", require_partition_filter)

    @property
    @pulumi.getter
    def type(self) -> pulumi.Input[str]:
        """
        The supported types are DAY, HOUR, MONTH, and YEAR,
        which will generate one partition per day, hour, month, and year, respectively.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: pulumi.Input[str]):
        pulumi.set(self, "type", value)

    @property
    @pulumi.getter(name="expirationMs")
    def expiration_ms(self) -> Optional[pulumi.Input[int]]:
        """
        Number of milliseconds for which to keep the
        storage for a partition.
        """
        return pulumi.get(self, "expiration_ms")

    @expiration_ms.setter
    def expiration_ms(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "expiration_ms", value)

    @property
    @pulumi.getter
    def field(self) -> Optional[pulumi.Input[str]]:
        """
        The field used to determine how to create a time-based
        partition. If time-based partitioning is enabled without this value, the
        table is partitioned based on the load time.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter(name="requirePartitionFilter")
    @_utilities.deprecated("""This field is deprecated and will be removed in a future major release; please use the top level field with the same name instead.""")
    def require_partition_filter(self) -> Optional[pulumi.Input[bool]]:
        """
        If set to true, queries over this table
        require a partition filter that can be used for partition elimination to be
        specified. `require_partition_filter` is deprecated and will be removed in
        a future major release. Use the top level field with the same name instead.
        """
        return pulumi.get(self, "require_partition_filter")

    @require_partition_filter.setter
    def require_partition_filter(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "require_partition_filter", value)


if not MYPY:
    class TableViewArgsDict(TypedDict):
        query: pulumi.Input[str]
        """
        A query that BigQuery executes when the view is referenced.
        """
        use_legacy_sql: NotRequired[pulumi.Input[bool]]
        """
        Specifies whether to use BigQuery's legacy SQL for this view.
        The default value is true. If set to false, the view will use BigQuery's standard SQL.
        """
elif False:
    TableViewArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableViewArgs:
    def __init__(__self__, *,
                 query: pulumi.Input[str],
                 use_legacy_sql: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] query: A query that BigQuery executes when the view is referenced.
        :param pulumi.Input[bool] use_legacy_sql: Specifies whether to use BigQuery's legacy SQL for this view.
               The default value is true. If set to false, the view will use BigQuery's standard SQL.
        """
        pulumi.set(__self__, "query", query)
        if use_legacy_sql is not None:
            pulumi.set(__self__, "use_legacy_sql", use_legacy_sql)

    @property
    @pulumi.getter
    def query(self) -> pulumi.Input[str]:
        """
        A query that BigQuery executes when the view is referenced.
        """
        return pulumi.get(self, "query")

    @query.setter
    def query(self, value: pulumi.Input[str]):
        pulumi.set(self, "query", value)

    @property
    @pulumi.getter(name="useLegacySql")
    def use_legacy_sql(self) -> Optional[pulumi.Input[bool]]:
        """
        Specifies whether to use BigQuery's legacy SQL for this view.
        The default value is true. If set to false, the view will use BigQuery's standard SQL.
        """
        return pulumi.get(self, "use_legacy_sql")

    @use_legacy_sql.setter
    def use_legacy_sql(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_legacy_sql", value)


