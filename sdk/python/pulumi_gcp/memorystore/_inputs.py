# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'InstanceCrossInstanceReplicationConfigArgs',
    'InstanceCrossInstanceReplicationConfigArgsDict',
    'InstanceCrossInstanceReplicationConfigMembershipArgs',
    'InstanceCrossInstanceReplicationConfigMembershipArgsDict',
    'InstanceCrossInstanceReplicationConfigMembershipPrimaryInstanceArgs',
    'InstanceCrossInstanceReplicationConfigMembershipPrimaryInstanceArgsDict',
    'InstanceCrossInstanceReplicationConfigMembershipSecondaryInstanceArgs',
    'InstanceCrossInstanceReplicationConfigMembershipSecondaryInstanceArgsDict',
    'InstanceCrossInstanceReplicationConfigPrimaryInstanceArgs',
    'InstanceCrossInstanceReplicationConfigPrimaryInstanceArgsDict',
    'InstanceCrossInstanceReplicationConfigSecondaryInstanceArgs',
    'InstanceCrossInstanceReplicationConfigSecondaryInstanceArgsDict',
    'InstanceDesiredPscAutoConnectionArgs',
    'InstanceDesiredPscAutoConnectionArgsDict',
    'InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointArgs',
    'InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointArgsDict',
    'InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionArgs',
    'InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionArgsDict',
    'InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionPscConnectionArgs',
    'InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionPscConnectionArgsDict',
    'InstanceDiscoveryEndpointArgs',
    'InstanceDiscoveryEndpointArgsDict',
    'InstanceEndpointArgs',
    'InstanceEndpointArgsDict',
    'InstanceEndpointConnectionArgs',
    'InstanceEndpointConnectionArgsDict',
    'InstanceEndpointConnectionPscAutoConnectionArgs',
    'InstanceEndpointConnectionPscAutoConnectionArgsDict',
    'InstanceMaintenancePolicyArgs',
    'InstanceMaintenancePolicyArgsDict',
    'InstanceMaintenancePolicyWeeklyMaintenanceWindowArgs',
    'InstanceMaintenancePolicyWeeklyMaintenanceWindowArgsDict',
    'InstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeArgs',
    'InstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeArgsDict',
    'InstanceMaintenanceScheduleArgs',
    'InstanceMaintenanceScheduleArgsDict',
    'InstanceNodeConfigArgs',
    'InstanceNodeConfigArgsDict',
    'InstancePersistenceConfigArgs',
    'InstancePersistenceConfigArgsDict',
    'InstancePersistenceConfigAofConfigArgs',
    'InstancePersistenceConfigAofConfigArgsDict',
    'InstancePersistenceConfigRdbConfigArgs',
    'InstancePersistenceConfigRdbConfigArgsDict',
    'InstancePscAttachmentDetailArgs',
    'InstancePscAttachmentDetailArgsDict',
    'InstancePscAutoConnectionArgs',
    'InstancePscAutoConnectionArgsDict',
    'InstanceStateInfoArgs',
    'InstanceStateInfoArgsDict',
    'InstanceStateInfoUpdateInfoArgs',
    'InstanceStateInfoUpdateInfoArgsDict',
    'InstanceZoneDistributionConfigArgs',
    'InstanceZoneDistributionConfigArgsDict',
]

MYPY = False

if not MYPY:
    class InstanceCrossInstanceReplicationConfigArgsDict(TypedDict):
        instance_role: NotRequired[pulumi.Input[builtins.str]]
        """
        The instance role supports the following values:
        1. `INSTANCE_ROLE_UNSPECIFIED`: This is an independent instance that has never participated in cross instance replication. It allows both reads and writes.
        2. `NONE`: This is an independent instance that previously participated in cross instance replication(either as a `PRIMARY` or `SECONDARY` cluster). It allows both reads and writes.
        3. `PRIMARY`: This instance serves as the replication source for secondary instance that are replicating from it. Any data written to it is automatically replicated to its secondary clusters. It allows both reads and writes.
        4. `SECONDARY`: This instance replicates data from the primary instance. It allows only reads.
        Possible values are: `INSTANCE_ROLE_UNSPECIFIED`, `NONE`, `PRIMARY`, `SECONDARY`.
        """
        memberships: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigMembershipArgsDict']]]]
        """
        (Output)
        An output only view of all the member instance participating in cross instance replication. This field is populated for all the member clusters irrespective of their cluster role.
        Structure is documented below.
        """
        primary_instance: NotRequired[pulumi.Input['InstanceCrossInstanceReplicationConfigPrimaryInstanceArgsDict']]
        """
        This field is only set for a secondary instance. Details of the primary instance that is used as the replication source for this secondary instance. This is allowed to be set only for clusters whose cluster role is of type `SECONDARY`.
        Structure is documented below.
        """
        secondary_instances: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigSecondaryInstanceArgsDict']]]]
        """
        List of secondary instances that are replicating from this primary cluster. This is allowed to be set only for instances whose cluster role is of type `PRIMARY`.
        Structure is documented below.
        """
        update_time: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        The last time cross instance replication config was updated.
        """
elif False:
    InstanceCrossInstanceReplicationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceCrossInstanceReplicationConfigArgs:
    def __init__(__self__, *,
                 instance_role: Optional[pulumi.Input[builtins.str]] = None,
                 memberships: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigMembershipArgs']]]] = None,
                 primary_instance: Optional[pulumi.Input['InstanceCrossInstanceReplicationConfigPrimaryInstanceArgs']] = None,
                 secondary_instances: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigSecondaryInstanceArgs']]]] = None,
                 update_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] instance_role: The instance role supports the following values:
               1. `INSTANCE_ROLE_UNSPECIFIED`: This is an independent instance that has never participated in cross instance replication. It allows both reads and writes.
               2. `NONE`: This is an independent instance that previously participated in cross instance replication(either as a `PRIMARY` or `SECONDARY` cluster). It allows both reads and writes.
               3. `PRIMARY`: This instance serves as the replication source for secondary instance that are replicating from it. Any data written to it is automatically replicated to its secondary clusters. It allows both reads and writes.
               4. `SECONDARY`: This instance replicates data from the primary instance. It allows only reads.
               Possible values are: `INSTANCE_ROLE_UNSPECIFIED`, `NONE`, `PRIMARY`, `SECONDARY`.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigMembershipArgs']]] memberships: (Output)
               An output only view of all the member instance participating in cross instance replication. This field is populated for all the member clusters irrespective of their cluster role.
               Structure is documented below.
        :param pulumi.Input['InstanceCrossInstanceReplicationConfigPrimaryInstanceArgs'] primary_instance: This field is only set for a secondary instance. Details of the primary instance that is used as the replication source for this secondary instance. This is allowed to be set only for clusters whose cluster role is of type `SECONDARY`.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigSecondaryInstanceArgs']]] secondary_instances: List of secondary instances that are replicating from this primary cluster. This is allowed to be set only for instances whose cluster role is of type `PRIMARY`.
               Structure is documented below.
        :param pulumi.Input[builtins.str] update_time: (Output)
               The last time cross instance replication config was updated.
        """
        if instance_role is not None:
            pulumi.set(__self__, "instance_role", instance_role)
        if memberships is not None:
            pulumi.set(__self__, "memberships", memberships)
        if primary_instance is not None:
            pulumi.set(__self__, "primary_instance", primary_instance)
        if secondary_instances is not None:
            pulumi.set(__self__, "secondary_instances", secondary_instances)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)

    @property
    @pulumi.getter(name="instanceRole")
    def instance_role(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The instance role supports the following values:
        1. `INSTANCE_ROLE_UNSPECIFIED`: This is an independent instance that has never participated in cross instance replication. It allows both reads and writes.
        2. `NONE`: This is an independent instance that previously participated in cross instance replication(either as a `PRIMARY` or `SECONDARY` cluster). It allows both reads and writes.
        3. `PRIMARY`: This instance serves as the replication source for secondary instance that are replicating from it. Any data written to it is automatically replicated to its secondary clusters. It allows both reads and writes.
        4. `SECONDARY`: This instance replicates data from the primary instance. It allows only reads.
        Possible values are: `INSTANCE_ROLE_UNSPECIFIED`, `NONE`, `PRIMARY`, `SECONDARY`.
        """
        return pulumi.get(self, "instance_role")

    @instance_role.setter
    def instance_role(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "instance_role", value)

    @property
    @pulumi.getter
    def memberships(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigMembershipArgs']]]]:
        """
        (Output)
        An output only view of all the member instance participating in cross instance replication. This field is populated for all the member clusters irrespective of their cluster role.
        Structure is documented below.
        """
        return pulumi.get(self, "memberships")

    @memberships.setter
    def memberships(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigMembershipArgs']]]]):
        pulumi.set(self, "memberships", value)

    @property
    @pulumi.getter(name="primaryInstance")
    def primary_instance(self) -> Optional[pulumi.Input['InstanceCrossInstanceReplicationConfigPrimaryInstanceArgs']]:
        """
        This field is only set for a secondary instance. Details of the primary instance that is used as the replication source for this secondary instance. This is allowed to be set only for clusters whose cluster role is of type `SECONDARY`.
        Structure is documented below.
        """
        return pulumi.get(self, "primary_instance")

    @primary_instance.setter
    def primary_instance(self, value: Optional[pulumi.Input['InstanceCrossInstanceReplicationConfigPrimaryInstanceArgs']]):
        pulumi.set(self, "primary_instance", value)

    @property
    @pulumi.getter(name="secondaryInstances")
    def secondary_instances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigSecondaryInstanceArgs']]]]:
        """
        List of secondary instances that are replicating from this primary cluster. This is allowed to be set only for instances whose cluster role is of type `PRIMARY`.
        Structure is documented below.
        """
        return pulumi.get(self, "secondary_instances")

    @secondary_instances.setter
    def secondary_instances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigSecondaryInstanceArgs']]]]):
        pulumi.set(self, "secondary_instances", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        The last time cross instance replication config was updated.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update_time", value)


if not MYPY:
    class InstanceCrossInstanceReplicationConfigMembershipArgsDict(TypedDict):
        primary_instances: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigMembershipPrimaryInstanceArgsDict']]]]
        """
        Details of the primary instance that is used as the replication source for all the secondary instances.
        """
        secondary_instances: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigMembershipSecondaryInstanceArgsDict']]]]
        """
        List of secondary instances that are replicating from the primary instance.
        """
elif False:
    InstanceCrossInstanceReplicationConfigMembershipArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceCrossInstanceReplicationConfigMembershipArgs:
    def __init__(__self__, *,
                 primary_instances: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigMembershipPrimaryInstanceArgs']]]] = None,
                 secondary_instances: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigMembershipSecondaryInstanceArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigMembershipPrimaryInstanceArgs']]] primary_instances: Details of the primary instance that is used as the replication source for all the secondary instances.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigMembershipSecondaryInstanceArgs']]] secondary_instances: List of secondary instances that are replicating from the primary instance.
        """
        if primary_instances is not None:
            pulumi.set(__self__, "primary_instances", primary_instances)
        if secondary_instances is not None:
            pulumi.set(__self__, "secondary_instances", secondary_instances)

    @property
    @pulumi.getter(name="primaryInstances")
    def primary_instances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigMembershipPrimaryInstanceArgs']]]]:
        """
        Details of the primary instance that is used as the replication source for all the secondary instances.
        """
        return pulumi.get(self, "primary_instances")

    @primary_instances.setter
    def primary_instances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigMembershipPrimaryInstanceArgs']]]]):
        pulumi.set(self, "primary_instances", value)

    @property
    @pulumi.getter(name="secondaryInstances")
    def secondary_instances(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigMembershipSecondaryInstanceArgs']]]]:
        """
        List of secondary instances that are replicating from the primary instance.
        """
        return pulumi.get(self, "secondary_instances")

    @secondary_instances.setter
    def secondary_instances(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceCrossInstanceReplicationConfigMembershipSecondaryInstanceArgs']]]]):
        pulumi.set(self, "secondary_instances", value)


if not MYPY:
    class InstanceCrossInstanceReplicationConfigMembershipPrimaryInstanceArgsDict(TypedDict):
        instance: NotRequired[pulumi.Input[builtins.str]]
        """
        The full resource path of the primary instance in the format: projects/{project}/locations/{region}/instances/{instance-id}
        """
        uid: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        The unique id of the primary instance.
        """
elif False:
    InstanceCrossInstanceReplicationConfigMembershipPrimaryInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceCrossInstanceReplicationConfigMembershipPrimaryInstanceArgs:
    def __init__(__self__, *,
                 instance: Optional[pulumi.Input[builtins.str]] = None,
                 uid: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] instance: The full resource path of the primary instance in the format: projects/{project}/locations/{region}/instances/{instance-id}
        :param pulumi.Input[builtins.str] uid: (Output)
               The unique id of the primary instance.
        """
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def instance(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The full resource path of the primary instance in the format: projects/{project}/locations/{region}/instances/{instance-id}
        """
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "instance", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        The unique id of the primary instance.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class InstanceCrossInstanceReplicationConfigMembershipSecondaryInstanceArgsDict(TypedDict):
        instance: NotRequired[pulumi.Input[builtins.str]]
        """
        The full resource path of the secondary instance in the format: projects/{project}/locations/{region}/instance/{instance-id}
        """
        uid: NotRequired[pulumi.Input[builtins.str]]
        """
        Output only. System assigned, unique identifier for the instance.
        """
elif False:
    InstanceCrossInstanceReplicationConfigMembershipSecondaryInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceCrossInstanceReplicationConfigMembershipSecondaryInstanceArgs:
    def __init__(__self__, *,
                 instance: Optional[pulumi.Input[builtins.str]] = None,
                 uid: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] instance: The full resource path of the secondary instance in the format: projects/{project}/locations/{region}/instance/{instance-id}
        :param pulumi.Input[builtins.str] uid: Output only. System assigned, unique identifier for the instance.
        """
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def instance(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The full resource path of the secondary instance in the format: projects/{project}/locations/{region}/instance/{instance-id}
        """
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "instance", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Output only. System assigned, unique identifier for the instance.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class InstanceCrossInstanceReplicationConfigPrimaryInstanceArgsDict(TypedDict):
        instance: NotRequired[pulumi.Input[builtins.str]]
        """
        The full resource path of the primary instance in the format: projects/{project}/locations/{region}/instances/{instance-id}
        """
        uid: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        The unique id of the primary instance.
        """
elif False:
    InstanceCrossInstanceReplicationConfigPrimaryInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceCrossInstanceReplicationConfigPrimaryInstanceArgs:
    def __init__(__self__, *,
                 instance: Optional[pulumi.Input[builtins.str]] = None,
                 uid: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] instance: The full resource path of the primary instance in the format: projects/{project}/locations/{region}/instances/{instance-id}
        :param pulumi.Input[builtins.str] uid: (Output)
               The unique id of the primary instance.
        """
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def instance(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The full resource path of the primary instance in the format: projects/{project}/locations/{region}/instances/{instance-id}
        """
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "instance", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        The unique id of the primary instance.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class InstanceCrossInstanceReplicationConfigSecondaryInstanceArgsDict(TypedDict):
        instance: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        The full resource path of the secondary instance in the format: projects/{project}/locations/{region}/instance/{instance-id}
        """
        uid: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        The unique id of the secondary instance.
        """
elif False:
    InstanceCrossInstanceReplicationConfigSecondaryInstanceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceCrossInstanceReplicationConfigSecondaryInstanceArgs:
    def __init__(__self__, *,
                 instance: Optional[pulumi.Input[builtins.str]] = None,
                 uid: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] instance: (Output)
               The full resource path of the secondary instance in the format: projects/{project}/locations/{region}/instance/{instance-id}
        :param pulumi.Input[builtins.str] uid: (Output)
               The unique id of the secondary instance.
        """
        if instance is not None:
            pulumi.set(__self__, "instance", instance)
        if uid is not None:
            pulumi.set(__self__, "uid", uid)

    @property
    @pulumi.getter
    def instance(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        The full resource path of the secondary instance in the format: projects/{project}/locations/{region}/instance/{instance-id}
        """
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "instance", value)

    @property
    @pulumi.getter
    def uid(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        The unique id of the secondary instance.
        """
        return pulumi.get(self, "uid")

    @uid.setter
    def uid(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "uid", value)


if not MYPY:
    class InstanceDesiredPscAutoConnectionArgsDict(TypedDict):
        network: pulumi.Input[builtins.str]
        """
        (Output)
        Output only. The consumer network where the IP address resides, in the form of
        projects/{project_id}/global/networks/{network_id}.
        """
        project_id: pulumi.Input[builtins.str]
        """
        (Output)
        Output only. The consumer project_id where the forwarding rule is created from.
        """
elif False:
    InstanceDesiredPscAutoConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDesiredPscAutoConnectionArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[builtins.str],
                 project_id: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] network: (Output)
               Output only. The consumer network where the IP address resides, in the form of
               projects/{project_id}/global/networks/{network_id}.
        :param pulumi.Input[builtins.str] project_id: (Output)
               Output only. The consumer project_id where the forwarding rule is created from.
        """
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter
    def network(self) -> pulumi.Input[builtins.str]:
        """
        (Output)
        Output only. The consumer network where the IP address resides, in the form of
        projects/{project_id}/global/networks/{network_id}.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[builtins.str]:
        """
        (Output)
        Output only. The consumer project_id where the forwarding rule is created from.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointArgsDict(TypedDict):
        connections: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionArgsDict']]]]
        """
        Structure is documented below.
        """
elif False:
    InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointArgs:
    def __init__(__self__, *,
                 connections: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionArgs']]] connections: Structure is documented below.
        """
        if connections is not None:
            pulumi.set(__self__, "connections", connections)

    @property
    @pulumi.getter
    def connections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionArgs']]]]:
        """
        Structure is documented below.
        """
        return pulumi.get(self, "connections")

    @connections.setter
    def connections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionArgs']]]]):
        pulumi.set(self, "connections", value)


if not MYPY:
    class InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionArgsDict(TypedDict):
        psc_connection: NotRequired[pulumi.Input['InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionPscConnectionArgsDict']]
        """
        Detailed information of a PSC connection that is created by the customer
        who owns the cluster.
        Structure is documented below.
        """
elif False:
    InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionArgs:
    def __init__(__self__, *,
                 psc_connection: Optional[pulumi.Input['InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionPscConnectionArgs']] = None):
        """
        :param pulumi.Input['InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionPscConnectionArgs'] psc_connection: Detailed information of a PSC connection that is created by the customer
               who owns the cluster.
               Structure is documented below.
        """
        if psc_connection is not None:
            pulumi.set(__self__, "psc_connection", psc_connection)

    @property
    @pulumi.getter(name="pscConnection")
    def psc_connection(self) -> Optional[pulumi.Input['InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionPscConnectionArgs']]:
        """
        Detailed information of a PSC connection that is created by the customer
        who owns the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "psc_connection")

    @psc_connection.setter
    def psc_connection(self, value: Optional[pulumi.Input['InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionPscConnectionArgs']]):
        pulumi.set(self, "psc_connection", value)


if not MYPY:
    class InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionPscConnectionArgsDict(TypedDict):
        forwarding_rule: pulumi.Input[builtins.str]
        """
        The URI of the consumer side forwarding rule.
        Format:
        projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}
        """
        ip_address: pulumi.Input[builtins.str]
        """
        The IP allocated on the consumer network for the PSC forwarding rule.
        """
        network: pulumi.Input[builtins.str]
        """
        The consumer network where the IP address resides, in the form of
        projects/{project_id}/global/networks/{network_id}.
        """
        psc_connection_id: pulumi.Input[builtins.str]
        """
        The PSC connection id of the forwarding rule connected to the
        service attachment.
        """
        service_attachment: pulumi.Input[builtins.str]
        """
        The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
        """
        connection_type: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output Only. Type of a PSC Connection.
        Possible values:
        CONNECTION_TYPE_DISCOVERY
        CONNECTION_TYPE_PRIMARY
        CONNECTION_TYPE_READER
        """
        project_id: NotRequired[pulumi.Input[builtins.str]]
        """
        The consumer project_id where the forwarding rule is created from.
        """
        psc_connection_status: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output Only. The status of the PSC connection: whether a connection exists and ACTIVE or it no longer exists.
        Possible values:
        ACTIVE
        NOT_FOUND
        """
elif False:
    InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionPscConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDesiredUserCreatedEndpointsDesiredUserCreatedEndpointConnectionPscConnectionArgs:
    def __init__(__self__, *,
                 forwarding_rule: pulumi.Input[builtins.str],
                 ip_address: pulumi.Input[builtins.str],
                 network: pulumi.Input[builtins.str],
                 psc_connection_id: pulumi.Input[builtins.str],
                 service_attachment: pulumi.Input[builtins.str],
                 connection_type: Optional[pulumi.Input[builtins.str]] = None,
                 project_id: Optional[pulumi.Input[builtins.str]] = None,
                 psc_connection_status: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] forwarding_rule: The URI of the consumer side forwarding rule.
               Format:
               projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}
        :param pulumi.Input[builtins.str] ip_address: The IP allocated on the consumer network for the PSC forwarding rule.
        :param pulumi.Input[builtins.str] network: The consumer network where the IP address resides, in the form of
               projects/{project_id}/global/networks/{network_id}.
        :param pulumi.Input[builtins.str] psc_connection_id: The PSC connection id of the forwarding rule connected to the
               service attachment.
        :param pulumi.Input[builtins.str] service_attachment: The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
        :param pulumi.Input[builtins.str] connection_type: (Output)
               Output Only. Type of a PSC Connection.
               Possible values:
               CONNECTION_TYPE_DISCOVERY
               CONNECTION_TYPE_PRIMARY
               CONNECTION_TYPE_READER
        :param pulumi.Input[builtins.str] project_id: The consumer project_id where the forwarding rule is created from.
        :param pulumi.Input[builtins.str] psc_connection_status: (Output)
               Output Only. The status of the PSC connection: whether a connection exists and ACTIVE or it no longer exists.
               Possible values:
               ACTIVE
               NOT_FOUND
        """
        pulumi.set(__self__, "forwarding_rule", forwarding_rule)
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "psc_connection_id", psc_connection_id)
        pulumi.set(__self__, "service_attachment", service_attachment)
        if connection_type is not None:
            pulumi.set(__self__, "connection_type", connection_type)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if psc_connection_status is not None:
            pulumi.set(__self__, "psc_connection_status", psc_connection_status)

    @property
    @pulumi.getter(name="forwardingRule")
    def forwarding_rule(self) -> pulumi.Input[builtins.str]:
        """
        The URI of the consumer side forwarding rule.
        Format:
        projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}
        """
        return pulumi.get(self, "forwarding_rule")

    @forwarding_rule.setter
    def forwarding_rule(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "forwarding_rule", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input[builtins.str]:
        """
        The IP allocated on the consumer network for the PSC forwarding rule.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def network(self) -> pulumi.Input[builtins.str]:
        """
        The consumer network where the IP address resides, in the form of
        projects/{project_id}/global/networks/{network_id}.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="pscConnectionId")
    def psc_connection_id(self) -> pulumi.Input[builtins.str]:
        """
        The PSC connection id of the forwarding rule connected to the
        service attachment.
        """
        return pulumi.get(self, "psc_connection_id")

    @psc_connection_id.setter
    def psc_connection_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "psc_connection_id", value)

    @property
    @pulumi.getter(name="serviceAttachment")
    def service_attachment(self) -> pulumi.Input[builtins.str]:
        """
        The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
        """
        return pulumi.get(self, "service_attachment")

    @service_attachment.setter
    def service_attachment(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "service_attachment", value)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output Only. Type of a PSC Connection.
        Possible values:
        CONNECTION_TYPE_DISCOVERY
        CONNECTION_TYPE_PRIMARY
        CONNECTION_TYPE_READER
        """
        return pulumi.get(self, "connection_type")

    @connection_type.setter
    def connection_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connection_type", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The consumer project_id where the forwarding rule is created from.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="pscConnectionStatus")
    def psc_connection_status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output Only. The status of the PSC connection: whether a connection exists and ACTIVE or it no longer exists.
        Possible values:
        ACTIVE
        NOT_FOUND
        """
        return pulumi.get(self, "psc_connection_status")

    @psc_connection_status.setter
    def psc_connection_status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "psc_connection_status", value)


if not MYPY:
    class InstanceDiscoveryEndpointArgsDict(TypedDict):
        address: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. IP address of the exposed endpoint clients connect to.
        """
        network: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. The consumer network where the IP address resides, in the form of
        projects/{project_id}/global/networks/{network_id}.
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        (Output)
        Output only. Ports of the exposed endpoint.
        """
elif False:
    InstanceDiscoveryEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceDiscoveryEndpointArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[builtins.str]] = None,
                 network: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] address: (Output)
               Output only. IP address of the exposed endpoint clients connect to.
        :param pulumi.Input[builtins.str] network: (Output)
               Output only. The consumer network where the IP address resides, in the form of
               projects/{project_id}/global/networks/{network_id}.
        :param pulumi.Input[builtins.int] port: (Output)
               Output only. Ports of the exposed endpoint.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. IP address of the exposed endpoint clients connect to.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. The consumer network where the IP address resides, in the form of
        projects/{project_id}/global/networks/{network_id}.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Output)
        Output only. Ports of the exposed endpoint.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class InstanceEndpointArgsDict(TypedDict):
        connections: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstanceEndpointConnectionArgsDict']]]]
        """
        A group of PSC connections. They are created in the same VPC network, one for each service attachment in the cluster.
        Structure is documented below.
        """
elif False:
    InstanceEndpointArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceEndpointArgs:
    def __init__(__self__, *,
                 connections: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceEndpointConnectionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['InstanceEndpointConnectionArgs']]] connections: A group of PSC connections. They are created in the same VPC network, one for each service attachment in the cluster.
               Structure is documented below.
        """
        if connections is not None:
            pulumi.set(__self__, "connections", connections)

    @property
    @pulumi.getter
    def connections(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceEndpointConnectionArgs']]]]:
        """
        A group of PSC connections. They are created in the same VPC network, one for each service attachment in the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "connections")

    @connections.setter
    def connections(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceEndpointConnectionArgs']]]]):
        pulumi.set(self, "connections", value)


if not MYPY:
    class InstanceEndpointConnectionArgsDict(TypedDict):
        psc_auto_connection: NotRequired[pulumi.Input['InstanceEndpointConnectionPscAutoConnectionArgsDict']]
        """
        Detailed information of a PSC connection that is created through service connectivity automation.
        Structure is documented below.
        """
elif False:
    InstanceEndpointConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceEndpointConnectionArgs:
    def __init__(__self__, *,
                 psc_auto_connection: Optional[pulumi.Input['InstanceEndpointConnectionPscAutoConnectionArgs']] = None):
        """
        :param pulumi.Input['InstanceEndpointConnectionPscAutoConnectionArgs'] psc_auto_connection: Detailed information of a PSC connection that is created through service connectivity automation.
               Structure is documented below.
        """
        if psc_auto_connection is not None:
            pulumi.set(__self__, "psc_auto_connection", psc_auto_connection)

    @property
    @pulumi.getter(name="pscAutoConnection")
    def psc_auto_connection(self) -> Optional[pulumi.Input['InstanceEndpointConnectionPscAutoConnectionArgs']]:
        """
        Detailed information of a PSC connection that is created through service connectivity automation.
        Structure is documented below.
        """
        return pulumi.get(self, "psc_auto_connection")

    @psc_auto_connection.setter
    def psc_auto_connection(self, value: Optional[pulumi.Input['InstanceEndpointConnectionPscAutoConnectionArgs']]):
        pulumi.set(self, "psc_auto_connection", value)


if not MYPY:
    class InstanceEndpointConnectionPscAutoConnectionArgsDict(TypedDict):
        connection_type: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output Only. Type of a PSC Connection.
        Possible values:
        CONNECTION_TYPE_DISCOVERY
        CONNECTION_TYPE_PRIMARY
        CONNECTION_TYPE_READER
        """
        forwarding_rule: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. The URI of the consumer side forwarding rule.
        Format:
        projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}
        """
        ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. The IP allocated on the consumer network for the PSC forwarding rule.
        """
        network: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. The consumer network where the IP address resides, in the form of
        projects/{project_id}/global/networks/{network_id}.
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        (Output)
        Output only. Ports of the exposed endpoint.
        """
        project_id: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. The consumer project_id where the forwarding rule is created from.
        """
        psc_connection_id: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. The PSC connection id of the forwarding rule connected to the
        service attachment.
        """
        service_attachment: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
        """
elif False:
    InstanceEndpointConnectionPscAutoConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceEndpointConnectionPscAutoConnectionArgs:
    def __init__(__self__, *,
                 connection_type: Optional[pulumi.Input[builtins.str]] = None,
                 forwarding_rule: Optional[pulumi.Input[builtins.str]] = None,
                 ip_address: Optional[pulumi.Input[builtins.str]] = None,
                 network: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 project_id: Optional[pulumi.Input[builtins.str]] = None,
                 psc_connection_id: Optional[pulumi.Input[builtins.str]] = None,
                 service_attachment: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] connection_type: (Output)
               Output Only. Type of a PSC Connection.
               Possible values:
               CONNECTION_TYPE_DISCOVERY
               CONNECTION_TYPE_PRIMARY
               CONNECTION_TYPE_READER
        :param pulumi.Input[builtins.str] forwarding_rule: (Output)
               Output only. The URI of the consumer side forwarding rule.
               Format:
               projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}
        :param pulumi.Input[builtins.str] ip_address: (Output)
               Output only. The IP allocated on the consumer network for the PSC forwarding rule.
        :param pulumi.Input[builtins.str] network: (Output)
               Output only. The consumer network where the IP address resides, in the form of
               projects/{project_id}/global/networks/{network_id}.
        :param pulumi.Input[builtins.int] port: (Output)
               Output only. Ports of the exposed endpoint.
        :param pulumi.Input[builtins.str] project_id: (Output)
               Output only. The consumer project_id where the forwarding rule is created from.
        :param pulumi.Input[builtins.str] psc_connection_id: (Output)
               Output only. The PSC connection id of the forwarding rule connected to the
               service attachment.
        :param pulumi.Input[builtins.str] service_attachment: (Output)
               Output only. The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
        """
        if connection_type is not None:
            pulumi.set(__self__, "connection_type", connection_type)
        if forwarding_rule is not None:
            pulumi.set(__self__, "forwarding_rule", forwarding_rule)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if psc_connection_id is not None:
            pulumi.set(__self__, "psc_connection_id", psc_connection_id)
        if service_attachment is not None:
            pulumi.set(__self__, "service_attachment", service_attachment)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output Only. Type of a PSC Connection.
        Possible values:
        CONNECTION_TYPE_DISCOVERY
        CONNECTION_TYPE_PRIMARY
        CONNECTION_TYPE_READER
        """
        return pulumi.get(self, "connection_type")

    @connection_type.setter
    def connection_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connection_type", value)

    @property
    @pulumi.getter(name="forwardingRule")
    def forwarding_rule(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. The URI of the consumer side forwarding rule.
        Format:
        projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}
        """
        return pulumi.get(self, "forwarding_rule")

    @forwarding_rule.setter
    def forwarding_rule(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "forwarding_rule", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. The IP allocated on the consumer network for the PSC forwarding rule.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. The consumer network where the IP address resides, in the form of
        projects/{project_id}/global/networks/{network_id}.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Output)
        Output only. Ports of the exposed endpoint.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. The consumer project_id where the forwarding rule is created from.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="pscConnectionId")
    def psc_connection_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. The PSC connection id of the forwarding rule connected to the
        service attachment.
        """
        return pulumi.get(self, "psc_connection_id")

    @psc_connection_id.setter
    def psc_connection_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "psc_connection_id", value)

    @property
    @pulumi.getter(name="serviceAttachment")
    def service_attachment(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
        """
        return pulumi.get(self, "service_attachment")

    @service_attachment.setter
    def service_attachment(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "service_attachment", value)


if not MYPY:
    class InstanceMaintenancePolicyArgsDict(TypedDict):
        create_time: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        The time when the policy was created.
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
        resolution and up to nine fractional digits.
        """
        update_time: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        The time when the policy was last updated.
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
        resolution and up to nine fractional digits.
        """
        weekly_maintenance_windows: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstanceMaintenancePolicyWeeklyMaintenanceWindowArgsDict']]]]
        """
        Optional. Maintenance window that is applied to resources covered by this policy.
        Minimum 1. For the current version, the maximum number
        of weekly_window is expected to be one.
        Structure is documented below.
        """
elif False:
    InstanceMaintenancePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceMaintenancePolicyArgs:
    def __init__(__self__, *,
                 create_time: Optional[pulumi.Input[builtins.str]] = None,
                 update_time: Optional[pulumi.Input[builtins.str]] = None,
                 weekly_maintenance_windows: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceMaintenancePolicyWeeklyMaintenanceWindowArgs']]]] = None):
        """
        :param pulumi.Input[builtins.str] create_time: (Output)
               The time when the policy was created.
               A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
               resolution and up to nine fractional digits.
        :param pulumi.Input[builtins.str] update_time: (Output)
               The time when the policy was last updated.
               A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
               resolution and up to nine fractional digits.
        :param pulumi.Input[Sequence[pulumi.Input['InstanceMaintenancePolicyWeeklyMaintenanceWindowArgs']]] weekly_maintenance_windows: Optional. Maintenance window that is applied to resources covered by this policy.
               Minimum 1. For the current version, the maximum number
               of weekly_window is expected to be one.
               Structure is documented below.
        """
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)
        if update_time is not None:
            pulumi.set(__self__, "update_time", update_time)
        if weekly_maintenance_windows is not None:
            pulumi.set(__self__, "weekly_maintenance_windows", weekly_maintenance_windows)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        The time when the policy was created.
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
        resolution and up to nine fractional digits.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "create_time", value)

    @property
    @pulumi.getter(name="updateTime")
    def update_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        The time when the policy was last updated.
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
        resolution and up to nine fractional digits.
        """
        return pulumi.get(self, "update_time")

    @update_time.setter
    def update_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "update_time", value)

    @property
    @pulumi.getter(name="weeklyMaintenanceWindows")
    def weekly_maintenance_windows(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceMaintenancePolicyWeeklyMaintenanceWindowArgs']]]]:
        """
        Optional. Maintenance window that is applied to resources covered by this policy.
        Minimum 1. For the current version, the maximum number
        of weekly_window is expected to be one.
        Structure is documented below.
        """
        return pulumi.get(self, "weekly_maintenance_windows")

    @weekly_maintenance_windows.setter
    def weekly_maintenance_windows(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceMaintenancePolicyWeeklyMaintenanceWindowArgs']]]]):
        pulumi.set(self, "weekly_maintenance_windows", value)


if not MYPY:
    class InstanceMaintenancePolicyWeeklyMaintenanceWindowArgsDict(TypedDict):
        day: pulumi.Input[builtins.str]
        """
        The day of week that maintenance updates occur.
        - DAY_OF_WEEK_UNSPECIFIED: The day of the week is unspecified.
        - MONDAY: Monday
        - TUESDAY: Tuesday
        - WEDNESDAY: Wednesday
        - THURSDAY: Thursday
        - FRIDAY: Friday
        - SATURDAY: Saturday
        - SUNDAY: Sunday
        Possible values are: `DAY_OF_WEEK_UNSPECIFIED`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        start_time: pulumi.Input['InstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeArgsDict']
        """
        Start time of the window in UTC time.
        Structure is documented below.
        """
        duration: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Duration of the maintenance window.
        The current window is fixed at 1 hour.
        A duration in seconds with up to nine fractional digits,
        terminated by 's'. Example: "3.5s".
        """
elif False:
    InstanceMaintenancePolicyWeeklyMaintenanceWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceMaintenancePolicyWeeklyMaintenanceWindowArgs:
    def __init__(__self__, *,
                 day: pulumi.Input[builtins.str],
                 start_time: pulumi.Input['InstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeArgs'],
                 duration: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] day: The day of week that maintenance updates occur.
               - DAY_OF_WEEK_UNSPECIFIED: The day of the week is unspecified.
               - MONDAY: Monday
               - TUESDAY: Tuesday
               - WEDNESDAY: Wednesday
               - THURSDAY: Thursday
               - FRIDAY: Friday
               - SATURDAY: Saturday
               - SUNDAY: Sunday
               Possible values are: `DAY_OF_WEEK_UNSPECIFIED`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input['InstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeArgs'] start_time: Start time of the window in UTC time.
               Structure is documented below.
        :param pulumi.Input[builtins.str] duration: (Output)
               Duration of the maintenance window.
               The current window is fixed at 1 hour.
               A duration in seconds with up to nine fractional digits,
               terminated by 's'. Example: "3.5s".
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "start_time", start_time)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @property
    @pulumi.getter
    def day(self) -> pulumi.Input[builtins.str]:
        """
        The day of week that maintenance updates occur.
        - DAY_OF_WEEK_UNSPECIFIED: The day of the week is unspecified.
        - MONDAY: Monday
        - TUESDAY: Tuesday
        - WEDNESDAY: Wednesday
        - THURSDAY: Thursday
        - FRIDAY: Friday
        - SATURDAY: Saturday
        - SUNDAY: Sunday
        Possible values are: `DAY_OF_WEEK_UNSPECIFIED`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input['InstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeArgs']:
        """
        Start time of the window in UTC time.
        Structure is documented below.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input['InstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeArgs']):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Duration of the maintenance window.
        The current window is fixed at 1 hour.
        A duration in seconds with up to nine fractional digits,
        terminated by 's'. Example: "3.5s".
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "duration", value)


if not MYPY:
    class InstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[builtins.int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23.
        An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[builtins.int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[builtins.int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[builtins.int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59.
        An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    InstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceMaintenancePolicyWeeklyMaintenanceWindowStartTimeArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[builtins.int]] = None,
                 minutes: Optional[pulumi.Input[builtins.int]] = None,
                 nanos: Optional[pulumi.Input[builtins.int]] = None,
                 seconds: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] hours: Hours of day in 24 hour format. Should be from 0 to 23.
               An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[builtins.int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[builtins.int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[builtins.int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59.
               An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23.
        An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59.
        An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class InstanceMaintenanceScheduleArgsDict(TypedDict):
        end_time: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        The end time of any upcoming scheduled maintenance for this cluster.
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
        resolution and up to nine fractional digits.
        """
        schedule_deadline_time: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        The deadline that the maintenance schedule start time
        can not go beyond, including reschedule.
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
        resolution and up to nine fractional digits.
        """
        start_time: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        The start time of any upcoming scheduled maintenance for this cluster.
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
        resolution and up to nine fractional digits.
        """
elif False:
    InstanceMaintenanceScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceMaintenanceScheduleArgs:
    def __init__(__self__, *,
                 end_time: Optional[pulumi.Input[builtins.str]] = None,
                 schedule_deadline_time: Optional[pulumi.Input[builtins.str]] = None,
                 start_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] end_time: (Output)
               The end time of any upcoming scheduled maintenance for this cluster.
               A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
               resolution and up to nine fractional digits.
        :param pulumi.Input[builtins.str] schedule_deadline_time: (Output)
               The deadline that the maintenance schedule start time
               can not go beyond, including reschedule.
               A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
               resolution and up to nine fractional digits.
        :param pulumi.Input[builtins.str] start_time: (Output)
               The start time of any upcoming scheduled maintenance for this cluster.
               A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
               resolution and up to nine fractional digits.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if schedule_deadline_time is not None:
            pulumi.set(__self__, "schedule_deadline_time", schedule_deadline_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        The end time of any upcoming scheduled maintenance for this cluster.
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
        resolution and up to nine fractional digits.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="scheduleDeadlineTime")
    def schedule_deadline_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        The deadline that the maintenance schedule start time
        can not go beyond, including reschedule.
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
        resolution and up to nine fractional digits.
        """
        return pulumi.get(self, "schedule_deadline_time")

    @schedule_deadline_time.setter
    def schedule_deadline_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "schedule_deadline_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        The start time of any upcoming scheduled maintenance for this cluster.
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond
        resolution and up to nine fractional digits.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class InstanceNodeConfigArgsDict(TypedDict):
        size_gb: NotRequired[pulumi.Input[builtins.float]]
        """
        (Output)
        Output only. Memory size in GB of the node.
        """
elif False:
    InstanceNodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceNodeConfigArgs:
    def __init__(__self__, *,
                 size_gb: Optional[pulumi.Input[builtins.float]] = None):
        """
        :param pulumi.Input[builtins.float] size_gb: (Output)
               Output only. Memory size in GB of the node.
        """
        if size_gb is not None:
            pulumi.set(__self__, "size_gb", size_gb)

    @property
    @pulumi.getter(name="sizeGb")
    def size_gb(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        (Output)
        Output only. Memory size in GB of the node.
        """
        return pulumi.get(self, "size_gb")

    @size_gb.setter
    def size_gb(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "size_gb", value)


if not MYPY:
    class InstancePersistenceConfigArgsDict(TypedDict):
        aof_config: NotRequired[pulumi.Input['InstancePersistenceConfigAofConfigArgsDict']]
        """
        Configuration for AOF based persistence.
        Structure is documented below.
        """
        mode: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. Current persistence mode.
        Possible values:
        DISABLED
        RDB
        AOF
        Possible values are: `DISABLED`, `RDB`, `AOF`.
        """
        rdb_config: NotRequired[pulumi.Input['InstancePersistenceConfigRdbConfigArgsDict']]
        """
        Configuration for RDB based persistence.
        Structure is documented below.
        """
elif False:
    InstancePersistenceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePersistenceConfigArgs:
    def __init__(__self__, *,
                 aof_config: Optional[pulumi.Input['InstancePersistenceConfigAofConfigArgs']] = None,
                 mode: Optional[pulumi.Input[builtins.str]] = None,
                 rdb_config: Optional[pulumi.Input['InstancePersistenceConfigRdbConfigArgs']] = None):
        """
        :param pulumi.Input['InstancePersistenceConfigAofConfigArgs'] aof_config: Configuration for AOF based persistence.
               Structure is documented below.
        :param pulumi.Input[builtins.str] mode: Optional. Current persistence mode.
               Possible values:
               DISABLED
               RDB
               AOF
               Possible values are: `DISABLED`, `RDB`, `AOF`.
        :param pulumi.Input['InstancePersistenceConfigRdbConfigArgs'] rdb_config: Configuration for RDB based persistence.
               Structure is documented below.
        """
        if aof_config is not None:
            pulumi.set(__self__, "aof_config", aof_config)
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if rdb_config is not None:
            pulumi.set(__self__, "rdb_config", rdb_config)

    @property
    @pulumi.getter(name="aofConfig")
    def aof_config(self) -> Optional[pulumi.Input['InstancePersistenceConfigAofConfigArgs']]:
        """
        Configuration for AOF based persistence.
        Structure is documented below.
        """
        return pulumi.get(self, "aof_config")

    @aof_config.setter
    def aof_config(self, value: Optional[pulumi.Input['InstancePersistenceConfigAofConfigArgs']]):
        pulumi.set(self, "aof_config", value)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. Current persistence mode.
        Possible values:
        DISABLED
        RDB
        AOF
        Possible values are: `DISABLED`, `RDB`, `AOF`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter(name="rdbConfig")
    def rdb_config(self) -> Optional[pulumi.Input['InstancePersistenceConfigRdbConfigArgs']]:
        """
        Configuration for RDB based persistence.
        Structure is documented below.
        """
        return pulumi.get(self, "rdb_config")

    @rdb_config.setter
    def rdb_config(self, value: Optional[pulumi.Input['InstancePersistenceConfigRdbConfigArgs']]):
        pulumi.set(self, "rdb_config", value)


if not MYPY:
    class InstancePersistenceConfigAofConfigArgsDict(TypedDict):
        append_fsync: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. The fsync mode.
        Possible values:
        NEVER
        EVERY_SEC
        ALWAYS
        """
elif False:
    InstancePersistenceConfigAofConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePersistenceConfigAofConfigArgs:
    def __init__(__self__, *,
                 append_fsync: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] append_fsync: Optional. The fsync mode.
               Possible values:
               NEVER
               EVERY_SEC
               ALWAYS
        """
        if append_fsync is not None:
            pulumi.set(__self__, "append_fsync", append_fsync)

    @property
    @pulumi.getter(name="appendFsync")
    def append_fsync(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. The fsync mode.
        Possible values:
        NEVER
        EVERY_SEC
        ALWAYS
        """
        return pulumi.get(self, "append_fsync")

    @append_fsync.setter
    def append_fsync(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "append_fsync", value)


if not MYPY:
    class InstancePersistenceConfigRdbConfigArgsDict(TypedDict):
        rdb_snapshot_period: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. Period between RDB snapshots.
        Possible values:
        ONE_HOUR
        SIX_HOURS
        TWELVE_HOURS
        TWENTY_FOUR_HOURS
        """
        rdb_snapshot_start_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. Time that the first snapshot was/will be attempted, and to which future
        snapshots will be aligned. If not provided, the current time will be
        used.
        """
elif False:
    InstancePersistenceConfigRdbConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePersistenceConfigRdbConfigArgs:
    def __init__(__self__, *,
                 rdb_snapshot_period: Optional[pulumi.Input[builtins.str]] = None,
                 rdb_snapshot_start_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] rdb_snapshot_period: Optional. Period between RDB snapshots.
               Possible values:
               ONE_HOUR
               SIX_HOURS
               TWELVE_HOURS
               TWENTY_FOUR_HOURS
        :param pulumi.Input[builtins.str] rdb_snapshot_start_time: Optional. Time that the first snapshot was/will be attempted, and to which future
               snapshots will be aligned. If not provided, the current time will be
               used.
        """
        if rdb_snapshot_period is not None:
            pulumi.set(__self__, "rdb_snapshot_period", rdb_snapshot_period)
        if rdb_snapshot_start_time is not None:
            pulumi.set(__self__, "rdb_snapshot_start_time", rdb_snapshot_start_time)

    @property
    @pulumi.getter(name="rdbSnapshotPeriod")
    def rdb_snapshot_period(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. Period between RDB snapshots.
        Possible values:
        ONE_HOUR
        SIX_HOURS
        TWELVE_HOURS
        TWENTY_FOUR_HOURS
        """
        return pulumi.get(self, "rdb_snapshot_period")

    @rdb_snapshot_period.setter
    def rdb_snapshot_period(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "rdb_snapshot_period", value)

    @property
    @pulumi.getter(name="rdbSnapshotStartTime")
    def rdb_snapshot_start_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. Time that the first snapshot was/will be attempted, and to which future
        snapshots will be aligned. If not provided, the current time will be
        used.
        """
        return pulumi.get(self, "rdb_snapshot_start_time")

    @rdb_snapshot_start_time.setter
    def rdb_snapshot_start_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "rdb_snapshot_start_time", value)


if not MYPY:
    class InstancePscAttachmentDetailArgsDict(TypedDict):
        connection_type: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output Only. Type of a PSC Connection.
        Possible values:
        CONNECTION_TYPE_DISCOVERY
        CONNECTION_TYPE_PRIMARY
        CONNECTION_TYPE_READER
        """
        service_attachment: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
        """
elif False:
    InstancePscAttachmentDetailArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePscAttachmentDetailArgs:
    def __init__(__self__, *,
                 connection_type: Optional[pulumi.Input[builtins.str]] = None,
                 service_attachment: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] connection_type: (Output)
               Output Only. Type of a PSC Connection.
               Possible values:
               CONNECTION_TYPE_DISCOVERY
               CONNECTION_TYPE_PRIMARY
               CONNECTION_TYPE_READER
        :param pulumi.Input[builtins.str] service_attachment: (Output)
               Output only. The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
        """
        if connection_type is not None:
            pulumi.set(__self__, "connection_type", connection_type)
        if service_attachment is not None:
            pulumi.set(__self__, "service_attachment", service_attachment)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output Only. Type of a PSC Connection.
        Possible values:
        CONNECTION_TYPE_DISCOVERY
        CONNECTION_TYPE_PRIMARY
        CONNECTION_TYPE_READER
        """
        return pulumi.get(self, "connection_type")

    @connection_type.setter
    def connection_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connection_type", value)

    @property
    @pulumi.getter(name="serviceAttachment")
    def service_attachment(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
        """
        return pulumi.get(self, "service_attachment")

    @service_attachment.setter
    def service_attachment(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "service_attachment", value)


if not MYPY:
    class InstancePscAutoConnectionArgsDict(TypedDict):
        connection_type: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output Only. Type of a PSC Connection.
        Possible values:
        CONNECTION_TYPE_DISCOVERY
        CONNECTION_TYPE_PRIMARY
        CONNECTION_TYPE_READER
        """
        forwarding_rule: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. The URI of the consumer side forwarding rule.
        Format:
        projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}
        """
        ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. The IP allocated on the consumer network for the PSC forwarding rule.
        """
        network: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. The consumer network where the IP address resides, in the form of
        projects/{project_id}/global/networks/{network_id}.
        """
        port: NotRequired[pulumi.Input[builtins.int]]
        """
        (Output)
        Output only. Ports of the exposed endpoint.
        """
        project_id: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. The consumer project_id where the forwarding rule is created from.
        """
        psc_connection_id: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. The PSC connection id of the forwarding rule connected to the
        service attachment.
        """
        psc_connection_status: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output Only. The status of the PSC connection: whether a connection exists and ACTIVE or it no longer exists.
        Possible values:
        ACTIVE
        NOT_FOUND
        """
        service_attachment: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
        """
elif False:
    InstancePscAutoConnectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstancePscAutoConnectionArgs:
    def __init__(__self__, *,
                 connection_type: Optional[pulumi.Input[builtins.str]] = None,
                 forwarding_rule: Optional[pulumi.Input[builtins.str]] = None,
                 ip_address: Optional[pulumi.Input[builtins.str]] = None,
                 network: Optional[pulumi.Input[builtins.str]] = None,
                 port: Optional[pulumi.Input[builtins.int]] = None,
                 project_id: Optional[pulumi.Input[builtins.str]] = None,
                 psc_connection_id: Optional[pulumi.Input[builtins.str]] = None,
                 psc_connection_status: Optional[pulumi.Input[builtins.str]] = None,
                 service_attachment: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] connection_type: (Output)
               Output Only. Type of a PSC Connection.
               Possible values:
               CONNECTION_TYPE_DISCOVERY
               CONNECTION_TYPE_PRIMARY
               CONNECTION_TYPE_READER
        :param pulumi.Input[builtins.str] forwarding_rule: (Output)
               Output only. The URI of the consumer side forwarding rule.
               Format:
               projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}
        :param pulumi.Input[builtins.str] ip_address: (Output)
               Output only. The IP allocated on the consumer network for the PSC forwarding rule.
        :param pulumi.Input[builtins.str] network: (Output)
               Output only. The consumer network where the IP address resides, in the form of
               projects/{project_id}/global/networks/{network_id}.
        :param pulumi.Input[builtins.int] port: (Output)
               Output only. Ports of the exposed endpoint.
        :param pulumi.Input[builtins.str] project_id: (Output)
               Output only. The consumer project_id where the forwarding rule is created from.
        :param pulumi.Input[builtins.str] psc_connection_id: (Output)
               Output only. The PSC connection id of the forwarding rule connected to the
               service attachment.
        :param pulumi.Input[builtins.str] psc_connection_status: (Output)
               Output Only. The status of the PSC connection: whether a connection exists and ACTIVE or it no longer exists.
               Possible values:
               ACTIVE
               NOT_FOUND
        :param pulumi.Input[builtins.str] service_attachment: (Output)
               Output only. The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
        """
        if connection_type is not None:
            pulumi.set(__self__, "connection_type", connection_type)
        if forwarding_rule is not None:
            pulumi.set(__self__, "forwarding_rule", forwarding_rule)
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if network is not None:
            pulumi.set(__self__, "network", network)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if psc_connection_id is not None:
            pulumi.set(__self__, "psc_connection_id", psc_connection_id)
        if psc_connection_status is not None:
            pulumi.set(__self__, "psc_connection_status", psc_connection_status)
        if service_attachment is not None:
            pulumi.set(__self__, "service_attachment", service_attachment)

    @property
    @pulumi.getter(name="connectionType")
    def connection_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output Only. Type of a PSC Connection.
        Possible values:
        CONNECTION_TYPE_DISCOVERY
        CONNECTION_TYPE_PRIMARY
        CONNECTION_TYPE_READER
        """
        return pulumi.get(self, "connection_type")

    @connection_type.setter
    def connection_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "connection_type", value)

    @property
    @pulumi.getter(name="forwardingRule")
    def forwarding_rule(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. The URI of the consumer side forwarding rule.
        Format:
        projects/{project}/regions/{region}/forwardingRules/{forwarding_rule}
        """
        return pulumi.get(self, "forwarding_rule")

    @forwarding_rule.setter
    def forwarding_rule(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "forwarding_rule", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. The IP allocated on the consumer network for the PSC forwarding rule.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. The consumer network where the IP address resides, in the form of
        projects/{project_id}/global/networks/{network_id}.
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Output)
        Output only. Ports of the exposed endpoint.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. The consumer project_id where the forwarding rule is created from.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="pscConnectionId")
    def psc_connection_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. The PSC connection id of the forwarding rule connected to the
        service attachment.
        """
        return pulumi.get(self, "psc_connection_id")

    @psc_connection_id.setter
    def psc_connection_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "psc_connection_id", value)

    @property
    @pulumi.getter(name="pscConnectionStatus")
    def psc_connection_status(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output Only. The status of the PSC connection: whether a connection exists and ACTIVE or it no longer exists.
        Possible values:
        ACTIVE
        NOT_FOUND
        """
        return pulumi.get(self, "psc_connection_status")

    @psc_connection_status.setter
    def psc_connection_status(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "psc_connection_status", value)

    @property
    @pulumi.getter(name="serviceAttachment")
    def service_attachment(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. The service attachment which is the target of the PSC connection, in the form of projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
        """
        return pulumi.get(self, "service_attachment")

    @service_attachment.setter
    def service_attachment(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "service_attachment", value)


if not MYPY:
    class InstanceStateInfoArgsDict(TypedDict):
        update_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['InstanceStateInfoUpdateInfoArgsDict']]]]
        """
        (Output)
        Represents information about instance with state UPDATING.
        Structure is documented below.
        """
elif False:
    InstanceStateInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceStateInfoArgs:
    def __init__(__self__, *,
                 update_infos: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceStateInfoUpdateInfoArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['InstanceStateInfoUpdateInfoArgs']]] update_infos: (Output)
               Represents information about instance with state UPDATING.
               Structure is documented below.
        """
        if update_infos is not None:
            pulumi.set(__self__, "update_infos", update_infos)

    @property
    @pulumi.getter(name="updateInfos")
    def update_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['InstanceStateInfoUpdateInfoArgs']]]]:
        """
        (Output)
        Represents information about instance with state UPDATING.
        Structure is documented below.
        """
        return pulumi.get(self, "update_infos")

    @update_infos.setter
    def update_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['InstanceStateInfoUpdateInfoArgs']]]]):
        pulumi.set(self, "update_infos", value)


if not MYPY:
    class InstanceStateInfoUpdateInfoArgsDict(TypedDict):
        target_engine_version: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. Target engine version for the instance.
        """
        target_node_type: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. Target node type for the instance.
        """
        target_replica_count: NotRequired[pulumi.Input[builtins.int]]
        """
        (Output)
        Output only. Target number of replica nodes per shard for the instance.
        """
        target_shard_count: NotRequired[pulumi.Input[builtins.int]]
        """
        (Output)
        Output only. Target number of shards for the instance.
        """
elif False:
    InstanceStateInfoUpdateInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceStateInfoUpdateInfoArgs:
    def __init__(__self__, *,
                 target_engine_version: Optional[pulumi.Input[builtins.str]] = None,
                 target_node_type: Optional[pulumi.Input[builtins.str]] = None,
                 target_replica_count: Optional[pulumi.Input[builtins.int]] = None,
                 target_shard_count: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.str] target_engine_version: (Output)
               Output only. Target engine version for the instance.
        :param pulumi.Input[builtins.str] target_node_type: (Output)
               Output only. Target node type for the instance.
        :param pulumi.Input[builtins.int] target_replica_count: (Output)
               Output only. Target number of replica nodes per shard for the instance.
        :param pulumi.Input[builtins.int] target_shard_count: (Output)
               Output only. Target number of shards for the instance.
        """
        if target_engine_version is not None:
            pulumi.set(__self__, "target_engine_version", target_engine_version)
        if target_node_type is not None:
            pulumi.set(__self__, "target_node_type", target_node_type)
        if target_replica_count is not None:
            pulumi.set(__self__, "target_replica_count", target_replica_count)
        if target_shard_count is not None:
            pulumi.set(__self__, "target_shard_count", target_shard_count)

    @property
    @pulumi.getter(name="targetEngineVersion")
    def target_engine_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. Target engine version for the instance.
        """
        return pulumi.get(self, "target_engine_version")

    @target_engine_version.setter
    def target_engine_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "target_engine_version", value)

    @property
    @pulumi.getter(name="targetNodeType")
    def target_node_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. Target node type for the instance.
        """
        return pulumi.get(self, "target_node_type")

    @target_node_type.setter
    def target_node_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "target_node_type", value)

    @property
    @pulumi.getter(name="targetReplicaCount")
    def target_replica_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Output)
        Output only. Target number of replica nodes per shard for the instance.
        """
        return pulumi.get(self, "target_replica_count")

    @target_replica_count.setter
    def target_replica_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "target_replica_count", value)

    @property
    @pulumi.getter(name="targetShardCount")
    def target_shard_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Output)
        Output only. Target number of shards for the instance.
        """
        return pulumi.get(self, "target_shard_count")

    @target_shard_count.setter
    def target_shard_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "target_shard_count", value)


if not MYPY:
    class InstanceZoneDistributionConfigArgsDict(TypedDict):
        mode: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. Current zone distribution mode. Defaults to MULTI_ZONE.
        Possible values:
        MULTI_ZONE
        SINGLE_ZONE
        Possible values are: `MULTI_ZONE`, `SINGLE_ZONE`.
        """
        zone: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. Defines zone where all resources will be allocated with SINGLE_ZONE mode.
        Ignored for MULTI_ZONE mode.
        """
elif False:
    InstanceZoneDistributionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceZoneDistributionConfigArgs:
    def __init__(__self__, *,
                 mode: Optional[pulumi.Input[builtins.str]] = None,
                 zone: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] mode: Optional. Current zone distribution mode. Defaults to MULTI_ZONE.
               Possible values:
               MULTI_ZONE
               SINGLE_ZONE
               Possible values are: `MULTI_ZONE`, `SINGLE_ZONE`.
        :param pulumi.Input[builtins.str] zone: Optional. Defines zone where all resources will be allocated with SINGLE_ZONE mode.
               Ignored for MULTI_ZONE mode.
        """
        if mode is not None:
            pulumi.set(__self__, "mode", mode)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter
    def mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. Current zone distribution mode. Defaults to MULTI_ZONE.
        Possible values:
        MULTI_ZONE
        SINGLE_ZONE
        Possible values are: `MULTI_ZONE`, `SINGLE_ZONE`.
        """
        return pulumi.get(self, "mode")

    @mode.setter
    def mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "mode", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. Defines zone where all resources will be allocated with SINGLE_ZONE mode.
        Ignored for MULTI_ZONE mode.
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "zone", value)


