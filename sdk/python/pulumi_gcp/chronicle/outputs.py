# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'DataAccessScopeAllowedDataAccessLabel',
    'DataAccessScopeAllowedDataAccessLabelIngestionLabel',
    'DataAccessScopeDeniedDataAccessLabel',
    'DataAccessScopeDeniedDataAccessLabelIngestionLabel',
    'ReferenceListEntry',
    'ReferenceListScopeInfo',
    'ReferenceListScopeInfoReferenceListScope',
    'RetrohuntExecutionInterval',
    'RetrohuntProcessInterval',
    'RuleCompilationDiagnostic',
    'RuleCompilationDiagnosticPosition',
    'RuleSeverity',
    'WatchlistEntityCount',
    'WatchlistEntityPopulationMechanism',
    'WatchlistEntityPopulationMechanismManual',
    'WatchlistWatchlistUserPreferences',
]

@pulumi.output_type
class DataAccessScopeAllowedDataAccessLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assetNamespace":
            suggest = "asset_namespace"
        elif key == "dataAccessLabel":
            suggest = "data_access_label"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "ingestionLabel":
            suggest = "ingestion_label"
        elif key == "logType":
            suggest = "log_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAccessScopeAllowedDataAccessLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAccessScopeAllowedDataAccessLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAccessScopeAllowedDataAccessLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asset_namespace: Optional[builtins.str] = None,
                 data_access_label: Optional[builtins.str] = None,
                 display_name: Optional[builtins.str] = None,
                 ingestion_label: Optional['outputs.DataAccessScopeAllowedDataAccessLabelIngestionLabel'] = None,
                 log_type: Optional[builtins.str] = None):
        """
        :param builtins.str asset_namespace: The asset namespace configured in the forwarder
               of the customer's events.
        :param builtins.str data_access_label: The name of the data access label.
        :param builtins.str display_name: (Output)
               Output only. The display name of the label.
               Data access label and log types's name
               will match the display name of the resource.
               The asset namespace will match the namespace itself.
               The ingestion key value pair will match the key of the tuple.
        :param 'DataAccessScopeAllowedDataAccessLabelIngestionLabelArgs' ingestion_label: Representation of an ingestion label type.
               Structure is documented below.
        :param builtins.str log_type: The name of the log type.
        """
        if asset_namespace is not None:
            pulumi.set(__self__, "asset_namespace", asset_namespace)
        if data_access_label is not None:
            pulumi.set(__self__, "data_access_label", data_access_label)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if ingestion_label is not None:
            pulumi.set(__self__, "ingestion_label", ingestion_label)
        if log_type is not None:
            pulumi.set(__self__, "log_type", log_type)

    @property
    @pulumi.getter(name="assetNamespace")
    def asset_namespace(self) -> Optional[builtins.str]:
        """
        The asset namespace configured in the forwarder
        of the customer's events.
        """
        return pulumi.get(self, "asset_namespace")

    @property
    @pulumi.getter(name="dataAccessLabel")
    def data_access_label(self) -> Optional[builtins.str]:
        """
        The name of the data access label.
        """
        return pulumi.get(self, "data_access_label")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        (Output)
        Output only. The display name of the label.
        Data access label and log types's name
        will match the display name of the resource.
        The asset namespace will match the namespace itself.
        The ingestion key value pair will match the key of the tuple.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="ingestionLabel")
    def ingestion_label(self) -> Optional['outputs.DataAccessScopeAllowedDataAccessLabelIngestionLabel']:
        """
        Representation of an ingestion label type.
        Structure is documented below.
        """
        return pulumi.get(self, "ingestion_label")

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional[builtins.str]:
        """
        The name of the log type.
        """
        return pulumi.get(self, "log_type")


@pulumi.output_type
class DataAccessScopeAllowedDataAccessLabelIngestionLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ingestionLabelKey":
            suggest = "ingestion_label_key"
        elif key == "ingestionLabelValue":
            suggest = "ingestion_label_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAccessScopeAllowedDataAccessLabelIngestionLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAccessScopeAllowedDataAccessLabelIngestionLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAccessScopeAllowedDataAccessLabelIngestionLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ingestion_label_key: builtins.str,
                 ingestion_label_value: Optional[builtins.str] = None):
        """
        :param builtins.str ingestion_label_key: Required. The key of the ingestion label. Always required.
        :param builtins.str ingestion_label_value: Optional. The value of the ingestion label. Optional. An object
               with no provided value and some key provided would match
               against the given key and ANY value.
        """
        pulumi.set(__self__, "ingestion_label_key", ingestion_label_key)
        if ingestion_label_value is not None:
            pulumi.set(__self__, "ingestion_label_value", ingestion_label_value)

    @property
    @pulumi.getter(name="ingestionLabelKey")
    def ingestion_label_key(self) -> builtins.str:
        """
        Required. The key of the ingestion label. Always required.
        """
        return pulumi.get(self, "ingestion_label_key")

    @property
    @pulumi.getter(name="ingestionLabelValue")
    def ingestion_label_value(self) -> Optional[builtins.str]:
        """
        Optional. The value of the ingestion label. Optional. An object
        with no provided value and some key provided would match
        against the given key and ANY value.
        """
        return pulumi.get(self, "ingestion_label_value")


@pulumi.output_type
class DataAccessScopeDeniedDataAccessLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "assetNamespace":
            suggest = "asset_namespace"
        elif key == "dataAccessLabel":
            suggest = "data_access_label"
        elif key == "displayName":
            suggest = "display_name"
        elif key == "ingestionLabel":
            suggest = "ingestion_label"
        elif key == "logType":
            suggest = "log_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAccessScopeDeniedDataAccessLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAccessScopeDeniedDataAccessLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAccessScopeDeniedDataAccessLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asset_namespace: Optional[builtins.str] = None,
                 data_access_label: Optional[builtins.str] = None,
                 display_name: Optional[builtins.str] = None,
                 ingestion_label: Optional['outputs.DataAccessScopeDeniedDataAccessLabelIngestionLabel'] = None,
                 log_type: Optional[builtins.str] = None):
        """
        :param builtins.str asset_namespace: The asset namespace configured in the forwarder
               of the customer's events.
        :param builtins.str data_access_label: The name of the data access label.
        :param builtins.str display_name: (Output)
               Output only. The display name of the label.
               Data access label and log types's name
               will match the display name of the resource.
               The asset namespace will match the namespace itself.
               The ingestion key value pair will match the key of the tuple.
        :param 'DataAccessScopeDeniedDataAccessLabelIngestionLabelArgs' ingestion_label: Representation of an ingestion label type.
               Structure is documented below.
        :param builtins.str log_type: The name of the log type.
        """
        if asset_namespace is not None:
            pulumi.set(__self__, "asset_namespace", asset_namespace)
        if data_access_label is not None:
            pulumi.set(__self__, "data_access_label", data_access_label)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if ingestion_label is not None:
            pulumi.set(__self__, "ingestion_label", ingestion_label)
        if log_type is not None:
            pulumi.set(__self__, "log_type", log_type)

    @property
    @pulumi.getter(name="assetNamespace")
    def asset_namespace(self) -> Optional[builtins.str]:
        """
        The asset namespace configured in the forwarder
        of the customer's events.
        """
        return pulumi.get(self, "asset_namespace")

    @property
    @pulumi.getter(name="dataAccessLabel")
    def data_access_label(self) -> Optional[builtins.str]:
        """
        The name of the data access label.
        """
        return pulumi.get(self, "data_access_label")

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        (Output)
        Output only. The display name of the label.
        Data access label and log types's name
        will match the display name of the resource.
        The asset namespace will match the namespace itself.
        The ingestion key value pair will match the key of the tuple.
        """
        return pulumi.get(self, "display_name")

    @property
    @pulumi.getter(name="ingestionLabel")
    def ingestion_label(self) -> Optional['outputs.DataAccessScopeDeniedDataAccessLabelIngestionLabel']:
        """
        Representation of an ingestion label type.
        Structure is documented below.
        """
        return pulumi.get(self, "ingestion_label")

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional[builtins.str]:
        """
        The name of the log type.
        """
        return pulumi.get(self, "log_type")


@pulumi.output_type
class DataAccessScopeDeniedDataAccessLabelIngestionLabel(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ingestionLabelKey":
            suggest = "ingestion_label_key"
        elif key == "ingestionLabelValue":
            suggest = "ingestion_label_value"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataAccessScopeDeniedDataAccessLabelIngestionLabel. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataAccessScopeDeniedDataAccessLabelIngestionLabel.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataAccessScopeDeniedDataAccessLabelIngestionLabel.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ingestion_label_key: builtins.str,
                 ingestion_label_value: Optional[builtins.str] = None):
        """
        :param builtins.str ingestion_label_key: Required. The key of the ingestion label. Always required.
        :param builtins.str ingestion_label_value: Optional. The value of the ingestion label. Optional. An object
               with no provided value and some key provided would match
               against the given key and ANY value.
        """
        pulumi.set(__self__, "ingestion_label_key", ingestion_label_key)
        if ingestion_label_value is not None:
            pulumi.set(__self__, "ingestion_label_value", ingestion_label_value)

    @property
    @pulumi.getter(name="ingestionLabelKey")
    def ingestion_label_key(self) -> builtins.str:
        """
        Required. The key of the ingestion label. Always required.
        """
        return pulumi.get(self, "ingestion_label_key")

    @property
    @pulumi.getter(name="ingestionLabelValue")
    def ingestion_label_value(self) -> Optional[builtins.str]:
        """
        Optional. The value of the ingestion label. Optional. An object
        with no provided value and some key provided would match
        against the given key and ANY value.
        """
        return pulumi.get(self, "ingestion_label_value")


@pulumi.output_type
class ReferenceListEntry(dict):
    def __init__(__self__, *,
                 value: builtins.str):
        """
        :param builtins.str value: Required. The value of the entry. Maximum length is 512 characters.
               
               - - -
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        Required. The value of the entry. Maximum length is 512 characters.

        - - -
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ReferenceListScopeInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "referenceListScope":
            suggest = "reference_list_scope"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReferenceListScopeInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReferenceListScopeInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReferenceListScopeInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 reference_list_scope: 'outputs.ReferenceListScopeInfoReferenceListScope'):
        """
        :param 'ReferenceListScopeInfoReferenceListScopeArgs' reference_list_scope: ReferenceListScope specifies the list of scope names of the reference list.
               Structure is documented below.
        """
        pulumi.set(__self__, "reference_list_scope", reference_list_scope)

    @property
    @pulumi.getter(name="referenceListScope")
    def reference_list_scope(self) -> 'outputs.ReferenceListScopeInfoReferenceListScope':
        """
        ReferenceListScope specifies the list of scope names of the reference list.
        Structure is documented below.
        """
        return pulumi.get(self, "reference_list_scope")


@pulumi.output_type
class ReferenceListScopeInfoReferenceListScope(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scopeNames":
            suggest = "scope_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ReferenceListScopeInfoReferenceListScope. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ReferenceListScopeInfoReferenceListScope.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ReferenceListScopeInfoReferenceListScope.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scope_names: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] scope_names: Optional. The list of scope names of the reference list. The scope names should be
               full resource names and should be of the format:
               "projects/{project}/locations/{location}/instances/{instance}/dataAccessScopes/{scope_name}".
        """
        if scope_names is not None:
            pulumi.set(__self__, "scope_names", scope_names)

    @property
    @pulumi.getter(name="scopeNames")
    def scope_names(self) -> Optional[Sequence[builtins.str]]:
        """
        Optional. The list of scope names of the reference list. The scope names should be
        full resource names and should be of the format:
        "projects/{project}/locations/{location}/instances/{instance}/dataAccessScopes/{scope_name}".
        """
        return pulumi.get(self, "scope_names")


@pulumi.output_type
class RetrohuntExecutionInterval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RetrohuntExecutionInterval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RetrohuntExecutionInterval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RetrohuntExecutionInterval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: Optional[builtins.str] = None,
                 start_time: Optional[builtins.str] = None):
        """
        :param builtins.str end_time: Optional. Exclusive end of the interval.
               If specified, a Timestamp matching this interval will have to be before the
               end.
        :param builtins.str start_time: Optional. Inclusive start of the interval.
               If specified, a Timestamp matching this interval will have to be the same
               or after the start.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[builtins.str]:
        """
        Optional. Exclusive end of the interval.
        If specified, a Timestamp matching this interval will have to be before the
        end.
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[builtins.str]:
        """
        Optional. Inclusive start of the interval.
        If specified, a Timestamp matching this interval will have to be the same
        or after the start.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class RetrohuntProcessInterval(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RetrohuntProcessInterval. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RetrohuntProcessInterval.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RetrohuntProcessInterval.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: builtins.str,
                 start_time: builtins.str):
        """
        :param builtins.str end_time: Exclusive end of the interval.
               
               - - -
        :param builtins.str start_time: Inclusive start of the interval.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> builtins.str:
        """
        Exclusive end of the interval.

        - - -
        """
        return pulumi.get(self, "end_time")

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> builtins.str:
        """
        Inclusive start of the interval.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class RuleCompilationDiagnostic(dict):
    def __init__(__self__, *,
                 message: Optional[builtins.str] = None,
                 position: Optional['outputs.RuleCompilationDiagnosticPosition'] = None,
                 severity: Optional[builtins.str] = None,
                 uri: Optional[builtins.str] = None):
        """
        :param builtins.str message: (Output)
               Output only. The diagnostic message.
        :param 'RuleCompilationDiagnosticPositionArgs' position: CompilationPosition represents the location of a compilation diagnostic in
               rule text.
               Structure is documented below.
        :param builtins.str severity: (Output)
               Output only. The severity of a rule's compilation diagnostic.
               Possible values:
               SEVERITY_UNSPECIFIED
               WARNING
               ERROR
        :param builtins.str uri: (Output)
               Output only. Link to documentation that describes a diagnostic in more detail.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if position is not None:
            pulumi.set(__self__, "position", position)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        (Output)
        Output only. The diagnostic message.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def position(self) -> Optional['outputs.RuleCompilationDiagnosticPosition']:
        """
        CompilationPosition represents the location of a compilation diagnostic in
        rule text.
        Structure is documented below.
        """
        return pulumi.get(self, "position")

    @property
    @pulumi.getter
    def severity(self) -> Optional[builtins.str]:
        """
        (Output)
        Output only. The severity of a rule's compilation diagnostic.
        Possible values:
        SEVERITY_UNSPECIFIED
        WARNING
        ERROR
        """
        return pulumi.get(self, "severity")

    @property
    @pulumi.getter
    def uri(self) -> Optional[builtins.str]:
        """
        (Output)
        Output only. Link to documentation that describes a diagnostic in more detail.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class RuleCompilationDiagnosticPosition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endColumn":
            suggest = "end_column"
        elif key == "endLine":
            suggest = "end_line"
        elif key == "startColumn":
            suggest = "start_column"
        elif key == "startLine":
            suggest = "start_line"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleCompilationDiagnosticPosition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleCompilationDiagnosticPosition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleCompilationDiagnosticPosition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_column: Optional[builtins.int] = None,
                 end_line: Optional[builtins.int] = None,
                 start_column: Optional[builtins.int] = None,
                 start_line: Optional[builtins.int] = None):
        """
        :param builtins.int end_column: (Output)
               Output only. End column number, beginning at 1.
        :param builtins.int end_line: (Output)
               Output only. End line number, beginning at 1.
        :param builtins.int start_column: (Output)
               Output only. Start column number, beginning at 1.
        :param builtins.int start_line: (Output)
               Output only. Start line number, beginning at 1.
        """
        if end_column is not None:
            pulumi.set(__self__, "end_column", end_column)
        if end_line is not None:
            pulumi.set(__self__, "end_line", end_line)
        if start_column is not None:
            pulumi.set(__self__, "start_column", start_column)
        if start_line is not None:
            pulumi.set(__self__, "start_line", start_line)

    @property
    @pulumi.getter(name="endColumn")
    def end_column(self) -> Optional[builtins.int]:
        """
        (Output)
        Output only. End column number, beginning at 1.
        """
        return pulumi.get(self, "end_column")

    @property
    @pulumi.getter(name="endLine")
    def end_line(self) -> Optional[builtins.int]:
        """
        (Output)
        Output only. End line number, beginning at 1.
        """
        return pulumi.get(self, "end_line")

    @property
    @pulumi.getter(name="startColumn")
    def start_column(self) -> Optional[builtins.int]:
        """
        (Output)
        Output only. Start column number, beginning at 1.
        """
        return pulumi.get(self, "start_column")

    @property
    @pulumi.getter(name="startLine")
    def start_line(self) -> Optional[builtins.int]:
        """
        (Output)
        Output only. Start line number, beginning at 1.
        """
        return pulumi.get(self, "start_line")


@pulumi.output_type
class RuleSeverity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RuleSeverity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RuleSeverity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RuleSeverity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 display_name: Optional[builtins.str] = None):
        """
        :param builtins.str display_name: The display name of the severity level. Extracted from the meta section of
               the rule text.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[builtins.str]:
        """
        The display name of the severity level. Extracted from the meta section of
        the rule text.
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class WatchlistEntityCount(dict):
    def __init__(__self__, *,
                 asset: Optional[builtins.int] = None,
                 user: Optional[builtins.int] = None):
        """
        :param builtins.int asset: (Output)
               Output only. Count of asset type entities in the watchlist.
        :param builtins.int user: (Output)
               Output only. Count of user type entities in the watchlist.
        """
        if asset is not None:
            pulumi.set(__self__, "asset", asset)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def asset(self) -> Optional[builtins.int]:
        """
        (Output)
        Output only. Count of asset type entities in the watchlist.
        """
        return pulumi.get(self, "asset")

    @property
    @pulumi.getter
    def user(self) -> Optional[builtins.int]:
        """
        (Output)
        Output only. Count of user type entities in the watchlist.
        """
        return pulumi.get(self, "user")


@pulumi.output_type
class WatchlistEntityPopulationMechanism(dict):
    def __init__(__self__, *,
                 manual: Optional['outputs.WatchlistEntityPopulationMechanismManual'] = None):
        """
        :param 'WatchlistEntityPopulationMechanismManualArgs' manual: Entities are added manually.
               
               - - -
        """
        if manual is not None:
            pulumi.set(__self__, "manual", manual)

    @property
    @pulumi.getter
    def manual(self) -> Optional['outputs.WatchlistEntityPopulationMechanismManual']:
        """
        Entities are added manually.

        - - -
        """
        return pulumi.get(self, "manual")


@pulumi.output_type
class WatchlistEntityPopulationMechanismManual(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class WatchlistWatchlistUserPreferences(dict):
    def __init__(__self__, *,
                 pinned: Optional[builtins.bool] = None):
        """
        :param builtins.bool pinned: Optional. Whether the watchlist is pinned on the dashboard.
        """
        if pinned is not None:
            pulumi.set(__self__, "pinned", pinned)

    @property
    @pulumi.getter
    def pinned(self) -> Optional[builtins.bool]:
        """
        Optional. Whether the watchlist is pinned on the dashboard.
        """
        return pulumi.get(self, "pinned")


