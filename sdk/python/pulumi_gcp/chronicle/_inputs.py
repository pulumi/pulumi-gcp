# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'DataAccessScopeAllowedDataAccessLabelArgs',
    'DataAccessScopeAllowedDataAccessLabelArgsDict',
    'DataAccessScopeAllowedDataAccessLabelIngestionLabelArgs',
    'DataAccessScopeAllowedDataAccessLabelIngestionLabelArgsDict',
    'DataAccessScopeDeniedDataAccessLabelArgs',
    'DataAccessScopeDeniedDataAccessLabelArgsDict',
    'DataAccessScopeDeniedDataAccessLabelIngestionLabelArgs',
    'DataAccessScopeDeniedDataAccessLabelIngestionLabelArgsDict',
    'ReferenceListEntryArgs',
    'ReferenceListEntryArgsDict',
    'ReferenceListScopeInfoArgs',
    'ReferenceListScopeInfoArgsDict',
    'ReferenceListScopeInfoReferenceListScopeArgs',
    'ReferenceListScopeInfoReferenceListScopeArgsDict',
    'RetrohuntExecutionIntervalArgs',
    'RetrohuntExecutionIntervalArgsDict',
    'RetrohuntProcessIntervalArgs',
    'RetrohuntProcessIntervalArgsDict',
    'RuleCompilationDiagnosticArgs',
    'RuleCompilationDiagnosticArgsDict',
    'RuleCompilationDiagnosticPositionArgs',
    'RuleCompilationDiagnosticPositionArgsDict',
    'RuleSeverityArgs',
    'RuleSeverityArgsDict',
    'WatchlistEntityCountArgs',
    'WatchlistEntityCountArgsDict',
    'WatchlistEntityPopulationMechanismArgs',
    'WatchlistEntityPopulationMechanismArgsDict',
    'WatchlistEntityPopulationMechanismManualArgs',
    'WatchlistEntityPopulationMechanismManualArgsDict',
    'WatchlistWatchlistUserPreferencesArgs',
    'WatchlistWatchlistUserPreferencesArgsDict',
]

MYPY = False

if not MYPY:
    class DataAccessScopeAllowedDataAccessLabelArgsDict(TypedDict):
        asset_namespace: NotRequired[pulumi.Input[builtins.str]]
        """
        The asset namespace configured in the forwarder
        of the customer's events.
        """
        data_access_label: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the data access label.
        """
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. The display name of the label.
        Data access label and log types's name
        will match the display name of the resource.
        The asset namespace will match the namespace itself.
        The ingestion key value pair will match the key of the tuple.
        """
        ingestion_label: NotRequired[pulumi.Input['DataAccessScopeAllowedDataAccessLabelIngestionLabelArgsDict']]
        """
        Representation of an ingestion label type.
        Structure is documented below.
        """
        log_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the log type.
        """
elif False:
    DataAccessScopeAllowedDataAccessLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAccessScopeAllowedDataAccessLabelArgs:
    def __init__(__self__, *,
                 asset_namespace: Optional[pulumi.Input[builtins.str]] = None,
                 data_access_label: Optional[pulumi.Input[builtins.str]] = None,
                 display_name: Optional[pulumi.Input[builtins.str]] = None,
                 ingestion_label: Optional[pulumi.Input['DataAccessScopeAllowedDataAccessLabelIngestionLabelArgs']] = None,
                 log_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] asset_namespace: The asset namespace configured in the forwarder
               of the customer's events.
        :param pulumi.Input[builtins.str] data_access_label: The name of the data access label.
        :param pulumi.Input[builtins.str] display_name: (Output)
               Output only. The display name of the label.
               Data access label and log types's name
               will match the display name of the resource.
               The asset namespace will match the namespace itself.
               The ingestion key value pair will match the key of the tuple.
        :param pulumi.Input['DataAccessScopeAllowedDataAccessLabelIngestionLabelArgs'] ingestion_label: Representation of an ingestion label type.
               Structure is documented below.
        :param pulumi.Input[builtins.str] log_type: The name of the log type.
        """
        if asset_namespace is not None:
            pulumi.set(__self__, "asset_namespace", asset_namespace)
        if data_access_label is not None:
            pulumi.set(__self__, "data_access_label", data_access_label)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if ingestion_label is not None:
            pulumi.set(__self__, "ingestion_label", ingestion_label)
        if log_type is not None:
            pulumi.set(__self__, "log_type", log_type)

    @property
    @pulumi.getter(name="assetNamespace")
    def asset_namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The asset namespace configured in the forwarder
        of the customer's events.
        """
        return pulumi.get(self, "asset_namespace")

    @asset_namespace.setter
    def asset_namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "asset_namespace", value)

    @property
    @pulumi.getter(name="dataAccessLabel")
    def data_access_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the data access label.
        """
        return pulumi.get(self, "data_access_label")

    @data_access_label.setter
    def data_access_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_access_label", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. The display name of the label.
        Data access label and log types's name
        will match the display name of the resource.
        The asset namespace will match the namespace itself.
        The ingestion key value pair will match the key of the tuple.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="ingestionLabel")
    def ingestion_label(self) -> Optional[pulumi.Input['DataAccessScopeAllowedDataAccessLabelIngestionLabelArgs']]:
        """
        Representation of an ingestion label type.
        Structure is documented below.
        """
        return pulumi.get(self, "ingestion_label")

    @ingestion_label.setter
    def ingestion_label(self, value: Optional[pulumi.Input['DataAccessScopeAllowedDataAccessLabelIngestionLabelArgs']]):
        pulumi.set(self, "ingestion_label", value)

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the log type.
        """
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "log_type", value)


if not MYPY:
    class DataAccessScopeAllowedDataAccessLabelIngestionLabelArgsDict(TypedDict):
        ingestion_label_key: pulumi.Input[builtins.str]
        """
        Required. The key of the ingestion label. Always required.
        """
        ingestion_label_value: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. The value of the ingestion label. Optional. An object
        with no provided value and some key provided would match
        against the given key and ANY value.
        """
elif False:
    DataAccessScopeAllowedDataAccessLabelIngestionLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAccessScopeAllowedDataAccessLabelIngestionLabelArgs:
    def __init__(__self__, *,
                 ingestion_label_key: pulumi.Input[builtins.str],
                 ingestion_label_value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] ingestion_label_key: Required. The key of the ingestion label. Always required.
        :param pulumi.Input[builtins.str] ingestion_label_value: Optional. The value of the ingestion label. Optional. An object
               with no provided value and some key provided would match
               against the given key and ANY value.
        """
        pulumi.set(__self__, "ingestion_label_key", ingestion_label_key)
        if ingestion_label_value is not None:
            pulumi.set(__self__, "ingestion_label_value", ingestion_label_value)

    @property
    @pulumi.getter(name="ingestionLabelKey")
    def ingestion_label_key(self) -> pulumi.Input[builtins.str]:
        """
        Required. The key of the ingestion label. Always required.
        """
        return pulumi.get(self, "ingestion_label_key")

    @ingestion_label_key.setter
    def ingestion_label_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ingestion_label_key", value)

    @property
    @pulumi.getter(name="ingestionLabelValue")
    def ingestion_label_value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. The value of the ingestion label. Optional. An object
        with no provided value and some key provided would match
        against the given key and ANY value.
        """
        return pulumi.get(self, "ingestion_label_value")

    @ingestion_label_value.setter
    def ingestion_label_value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ingestion_label_value", value)


if not MYPY:
    class DataAccessScopeDeniedDataAccessLabelArgsDict(TypedDict):
        asset_namespace: NotRequired[pulumi.Input[builtins.str]]
        """
        The asset namespace configured in the forwarder
        of the customer's events.
        """
        data_access_label: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the data access label.
        """
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. The display name of the label.
        Data access label and log types's name
        will match the display name of the resource.
        The asset namespace will match the namespace itself.
        The ingestion key value pair will match the key of the tuple.
        """
        ingestion_label: NotRequired[pulumi.Input['DataAccessScopeDeniedDataAccessLabelIngestionLabelArgsDict']]
        """
        Representation of an ingestion label type.
        Structure is documented below.
        """
        log_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the log type.
        """
elif False:
    DataAccessScopeDeniedDataAccessLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAccessScopeDeniedDataAccessLabelArgs:
    def __init__(__self__, *,
                 asset_namespace: Optional[pulumi.Input[builtins.str]] = None,
                 data_access_label: Optional[pulumi.Input[builtins.str]] = None,
                 display_name: Optional[pulumi.Input[builtins.str]] = None,
                 ingestion_label: Optional[pulumi.Input['DataAccessScopeDeniedDataAccessLabelIngestionLabelArgs']] = None,
                 log_type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] asset_namespace: The asset namespace configured in the forwarder
               of the customer's events.
        :param pulumi.Input[builtins.str] data_access_label: The name of the data access label.
        :param pulumi.Input[builtins.str] display_name: (Output)
               Output only. The display name of the label.
               Data access label and log types's name
               will match the display name of the resource.
               The asset namespace will match the namespace itself.
               The ingestion key value pair will match the key of the tuple.
        :param pulumi.Input['DataAccessScopeDeniedDataAccessLabelIngestionLabelArgs'] ingestion_label: Representation of an ingestion label type.
               Structure is documented below.
        :param pulumi.Input[builtins.str] log_type: The name of the log type.
        """
        if asset_namespace is not None:
            pulumi.set(__self__, "asset_namespace", asset_namespace)
        if data_access_label is not None:
            pulumi.set(__self__, "data_access_label", data_access_label)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if ingestion_label is not None:
            pulumi.set(__self__, "ingestion_label", ingestion_label)
        if log_type is not None:
            pulumi.set(__self__, "log_type", log_type)

    @property
    @pulumi.getter(name="assetNamespace")
    def asset_namespace(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The asset namespace configured in the forwarder
        of the customer's events.
        """
        return pulumi.get(self, "asset_namespace")

    @asset_namespace.setter
    def asset_namespace(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "asset_namespace", value)

    @property
    @pulumi.getter(name="dataAccessLabel")
    def data_access_label(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the data access label.
        """
        return pulumi.get(self, "data_access_label")

    @data_access_label.setter
    def data_access_label(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "data_access_label", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. The display name of the label.
        Data access label and log types's name
        will match the display name of the resource.
        The asset namespace will match the namespace itself.
        The ingestion key value pair will match the key of the tuple.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="ingestionLabel")
    def ingestion_label(self) -> Optional[pulumi.Input['DataAccessScopeDeniedDataAccessLabelIngestionLabelArgs']]:
        """
        Representation of an ingestion label type.
        Structure is documented below.
        """
        return pulumi.get(self, "ingestion_label")

    @ingestion_label.setter
    def ingestion_label(self, value: Optional[pulumi.Input['DataAccessScopeDeniedDataAccessLabelIngestionLabelArgs']]):
        pulumi.set(self, "ingestion_label", value)

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the log type.
        """
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "log_type", value)


if not MYPY:
    class DataAccessScopeDeniedDataAccessLabelIngestionLabelArgsDict(TypedDict):
        ingestion_label_key: pulumi.Input[builtins.str]
        """
        Required. The key of the ingestion label. Always required.
        """
        ingestion_label_value: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. The value of the ingestion label. Optional. An object
        with no provided value and some key provided would match
        against the given key and ANY value.
        """
elif False:
    DataAccessScopeDeniedDataAccessLabelIngestionLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAccessScopeDeniedDataAccessLabelIngestionLabelArgs:
    def __init__(__self__, *,
                 ingestion_label_key: pulumi.Input[builtins.str],
                 ingestion_label_value: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] ingestion_label_key: Required. The key of the ingestion label. Always required.
        :param pulumi.Input[builtins.str] ingestion_label_value: Optional. The value of the ingestion label. Optional. An object
               with no provided value and some key provided would match
               against the given key and ANY value.
        """
        pulumi.set(__self__, "ingestion_label_key", ingestion_label_key)
        if ingestion_label_value is not None:
            pulumi.set(__self__, "ingestion_label_value", ingestion_label_value)

    @property
    @pulumi.getter(name="ingestionLabelKey")
    def ingestion_label_key(self) -> pulumi.Input[builtins.str]:
        """
        Required. The key of the ingestion label. Always required.
        """
        return pulumi.get(self, "ingestion_label_key")

    @ingestion_label_key.setter
    def ingestion_label_key(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "ingestion_label_key", value)

    @property
    @pulumi.getter(name="ingestionLabelValue")
    def ingestion_label_value(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. The value of the ingestion label. Optional. An object
        with no provided value and some key provided would match
        against the given key and ANY value.
        """
        return pulumi.get(self, "ingestion_label_value")

    @ingestion_label_value.setter
    def ingestion_label_value(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ingestion_label_value", value)


if not MYPY:
    class ReferenceListEntryArgsDict(TypedDict):
        value: pulumi.Input[builtins.str]
        """
        Required. The value of the entry. Maximum length is 512 characters.

        - - -
        """
elif False:
    ReferenceListEntryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReferenceListEntryArgs:
    def __init__(__self__, *,
                 value: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] value: Required. The value of the entry. Maximum length is 512 characters.
               
               - - -
        """
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[builtins.str]:
        """
        Required. The value of the entry. Maximum length is 512 characters.

        - - -
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ReferenceListScopeInfoArgsDict(TypedDict):
        reference_list_scope: pulumi.Input['ReferenceListScopeInfoReferenceListScopeArgsDict']
        """
        ReferenceListScope specifies the list of scope names of the reference list.
        Structure is documented below.
        """
elif False:
    ReferenceListScopeInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReferenceListScopeInfoArgs:
    def __init__(__self__, *,
                 reference_list_scope: pulumi.Input['ReferenceListScopeInfoReferenceListScopeArgs']):
        """
        :param pulumi.Input['ReferenceListScopeInfoReferenceListScopeArgs'] reference_list_scope: ReferenceListScope specifies the list of scope names of the reference list.
               Structure is documented below.
        """
        pulumi.set(__self__, "reference_list_scope", reference_list_scope)

    @property
    @pulumi.getter(name="referenceListScope")
    def reference_list_scope(self) -> pulumi.Input['ReferenceListScopeInfoReferenceListScopeArgs']:
        """
        ReferenceListScope specifies the list of scope names of the reference list.
        Structure is documented below.
        """
        return pulumi.get(self, "reference_list_scope")

    @reference_list_scope.setter
    def reference_list_scope(self, value: pulumi.Input['ReferenceListScopeInfoReferenceListScopeArgs']):
        pulumi.set(self, "reference_list_scope", value)


if not MYPY:
    class ReferenceListScopeInfoReferenceListScopeArgsDict(TypedDict):
        scope_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional. The list of scope names of the reference list. The scope names should be
        full resource names and should be of the format:
        "projects/{project}/locations/{location}/instances/{instance}/dataAccessScopes/{scope_name}".
        """
elif False:
    ReferenceListScopeInfoReferenceListScopeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ReferenceListScopeInfoReferenceListScopeArgs:
    def __init__(__self__, *,
                 scope_names: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] scope_names: Optional. The list of scope names of the reference list. The scope names should be
               full resource names and should be of the format:
               "projects/{project}/locations/{location}/instances/{instance}/dataAccessScopes/{scope_name}".
        """
        if scope_names is not None:
            pulumi.set(__self__, "scope_names", scope_names)

    @property
    @pulumi.getter(name="scopeNames")
    def scope_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional. The list of scope names of the reference list. The scope names should be
        full resource names and should be of the format:
        "projects/{project}/locations/{location}/instances/{instance}/dataAccessScopes/{scope_name}".
        """
        return pulumi.get(self, "scope_names")

    @scope_names.setter
    def scope_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "scope_names", value)


if not MYPY:
    class RetrohuntExecutionIntervalArgsDict(TypedDict):
        end_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. Exclusive end of the interval.
        If specified, a Timestamp matching this interval will have to be before the
        end.
        """
        start_time: NotRequired[pulumi.Input[builtins.str]]
        """
        Optional. Inclusive start of the interval.
        If specified, a Timestamp matching this interval will have to be the same
        or after the start.
        """
elif False:
    RetrohuntExecutionIntervalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RetrohuntExecutionIntervalArgs:
    def __init__(__self__, *,
                 end_time: Optional[pulumi.Input[builtins.str]] = None,
                 start_time: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] end_time: Optional. Exclusive end of the interval.
               If specified, a Timestamp matching this interval will have to be before the
               end.
        :param pulumi.Input[builtins.str] start_time: Optional. Inclusive start of the interval.
               If specified, a Timestamp matching this interval will have to be the same
               or after the start.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. Exclusive end of the interval.
        If specified, a Timestamp matching this interval will have to be before the
        end.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Optional. Inclusive start of the interval.
        If specified, a Timestamp matching this interval will have to be the same
        or after the start.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class RetrohuntProcessIntervalArgsDict(TypedDict):
        end_time: pulumi.Input[builtins.str]
        """
        Exclusive end of the interval.

        - - -
        """
        start_time: pulumi.Input[builtins.str]
        """
        Inclusive start of the interval.
        """
elif False:
    RetrohuntProcessIntervalArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RetrohuntProcessIntervalArgs:
    def __init__(__self__, *,
                 end_time: pulumi.Input[builtins.str],
                 start_time: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] end_time: Exclusive end of the interval.
               
               - - -
        :param pulumi.Input[builtins.str] start_time: Inclusive start of the interval.
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> pulumi.Input[builtins.str]:
        """
        Exclusive end of the interval.

        - - -
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> pulumi.Input[builtins.str]:
        """
        Inclusive start of the interval.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "start_time", value)


if not MYPY:
    class RuleCompilationDiagnosticArgsDict(TypedDict):
        message: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. The diagnostic message.
        """
        position: NotRequired[pulumi.Input['RuleCompilationDiagnosticPositionArgsDict']]
        """
        CompilationPosition represents the location of a compilation diagnostic in
        rule text.
        Structure is documented below.
        """
        severity: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. The severity of a rule's compilation diagnostic.
        Possible values:
        SEVERITY_UNSPECIFIED
        WARNING
        ERROR
        """
        uri: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Output only. Link to documentation that describes a diagnostic in more detail.
        """
elif False:
    RuleCompilationDiagnosticArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleCompilationDiagnosticArgs:
    def __init__(__self__, *,
                 message: Optional[pulumi.Input[builtins.str]] = None,
                 position: Optional[pulumi.Input['RuleCompilationDiagnosticPositionArgs']] = None,
                 severity: Optional[pulumi.Input[builtins.str]] = None,
                 uri: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] message: (Output)
               Output only. The diagnostic message.
        :param pulumi.Input['RuleCompilationDiagnosticPositionArgs'] position: CompilationPosition represents the location of a compilation diagnostic in
               rule text.
               Structure is documented below.
        :param pulumi.Input[builtins.str] severity: (Output)
               Output only. The severity of a rule's compilation diagnostic.
               Possible values:
               SEVERITY_UNSPECIFIED
               WARNING
               ERROR
        :param pulumi.Input[builtins.str] uri: (Output)
               Output only. Link to documentation that describes a diagnostic in more detail.
        """
        if message is not None:
            pulumi.set(__self__, "message", message)
        if position is not None:
            pulumi.set(__self__, "position", position)
        if severity is not None:
            pulumi.set(__self__, "severity", severity)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. The diagnostic message.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def position(self) -> Optional[pulumi.Input['RuleCompilationDiagnosticPositionArgs']]:
        """
        CompilationPosition represents the location of a compilation diagnostic in
        rule text.
        Structure is documented below.
        """
        return pulumi.get(self, "position")

    @position.setter
    def position(self, value: Optional[pulumi.Input['RuleCompilationDiagnosticPositionArgs']]):
        pulumi.set(self, "position", value)

    @property
    @pulumi.getter
    def severity(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. The severity of a rule's compilation diagnostic.
        Possible values:
        SEVERITY_UNSPECIFIED
        WARNING
        ERROR
        """
        return pulumi.get(self, "severity")

    @severity.setter
    def severity(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "severity", value)

    @property
    @pulumi.getter
    def uri(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Output only. Link to documentation that describes a diagnostic in more detail.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "uri", value)


if not MYPY:
    class RuleCompilationDiagnosticPositionArgsDict(TypedDict):
        end_column: NotRequired[pulumi.Input[builtins.int]]
        """
        (Output)
        Output only. End column number, beginning at 1.
        """
        end_line: NotRequired[pulumi.Input[builtins.int]]
        """
        (Output)
        Output only. End line number, beginning at 1.
        """
        start_column: NotRequired[pulumi.Input[builtins.int]]
        """
        (Output)
        Output only. Start column number, beginning at 1.
        """
        start_line: NotRequired[pulumi.Input[builtins.int]]
        """
        (Output)
        Output only. Start line number, beginning at 1.
        """
elif False:
    RuleCompilationDiagnosticPositionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleCompilationDiagnosticPositionArgs:
    def __init__(__self__, *,
                 end_column: Optional[pulumi.Input[builtins.int]] = None,
                 end_line: Optional[pulumi.Input[builtins.int]] = None,
                 start_column: Optional[pulumi.Input[builtins.int]] = None,
                 start_line: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] end_column: (Output)
               Output only. End column number, beginning at 1.
        :param pulumi.Input[builtins.int] end_line: (Output)
               Output only. End line number, beginning at 1.
        :param pulumi.Input[builtins.int] start_column: (Output)
               Output only. Start column number, beginning at 1.
        :param pulumi.Input[builtins.int] start_line: (Output)
               Output only. Start line number, beginning at 1.
        """
        if end_column is not None:
            pulumi.set(__self__, "end_column", end_column)
        if end_line is not None:
            pulumi.set(__self__, "end_line", end_line)
        if start_column is not None:
            pulumi.set(__self__, "start_column", start_column)
        if start_line is not None:
            pulumi.set(__self__, "start_line", start_line)

    @property
    @pulumi.getter(name="endColumn")
    def end_column(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Output)
        Output only. End column number, beginning at 1.
        """
        return pulumi.get(self, "end_column")

    @end_column.setter
    def end_column(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "end_column", value)

    @property
    @pulumi.getter(name="endLine")
    def end_line(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Output)
        Output only. End line number, beginning at 1.
        """
        return pulumi.get(self, "end_line")

    @end_line.setter
    def end_line(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "end_line", value)

    @property
    @pulumi.getter(name="startColumn")
    def start_column(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Output)
        Output only. Start column number, beginning at 1.
        """
        return pulumi.get(self, "start_column")

    @start_column.setter
    def start_column(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "start_column", value)

    @property
    @pulumi.getter(name="startLine")
    def start_line(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Output)
        Output only. Start line number, beginning at 1.
        """
        return pulumi.get(self, "start_line")

    @start_line.setter
    def start_line(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "start_line", value)


if not MYPY:
    class RuleSeverityArgsDict(TypedDict):
        display_name: NotRequired[pulumi.Input[builtins.str]]
        """
        The display name of the severity level. Extracted from the meta section of
        the rule text.
        """
elif False:
    RuleSeverityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RuleSeverityArgs:
    def __init__(__self__, *,
                 display_name: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] display_name: The display name of the severity level. Extracted from the meta section of
               the rule text.
        """
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The display name of the severity level. Extracted from the meta section of
        the rule text.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "display_name", value)


if not MYPY:
    class WatchlistEntityCountArgsDict(TypedDict):
        asset: NotRequired[pulumi.Input[builtins.int]]
        """
        (Output)
        Output only. Count of asset type entities in the watchlist.
        """
        user: NotRequired[pulumi.Input[builtins.int]]
        """
        (Output)
        Output only. Count of user type entities in the watchlist.
        """
elif False:
    WatchlistEntityCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WatchlistEntityCountArgs:
    def __init__(__self__, *,
                 asset: Optional[pulumi.Input[builtins.int]] = None,
                 user: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] asset: (Output)
               Output only. Count of asset type entities in the watchlist.
        :param pulumi.Input[builtins.int] user: (Output)
               Output only. Count of user type entities in the watchlist.
        """
        if asset is not None:
            pulumi.set(__self__, "asset", asset)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def asset(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Output)
        Output only. Count of asset type entities in the watchlist.
        """
        return pulumi.get(self, "asset")

    @asset.setter
    def asset(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "asset", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Output)
        Output only. Count of user type entities in the watchlist.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class WatchlistEntityPopulationMechanismArgsDict(TypedDict):
        manual: NotRequired[pulumi.Input['WatchlistEntityPopulationMechanismManualArgsDict']]
        """
        Entities are added manually.

        - - -
        """
elif False:
    WatchlistEntityPopulationMechanismArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WatchlistEntityPopulationMechanismArgs:
    def __init__(__self__, *,
                 manual: Optional[pulumi.Input['WatchlistEntityPopulationMechanismManualArgs']] = None):
        """
        :param pulumi.Input['WatchlistEntityPopulationMechanismManualArgs'] manual: Entities are added manually.
               
               - - -
        """
        if manual is not None:
            pulumi.set(__self__, "manual", manual)

    @property
    @pulumi.getter
    def manual(self) -> Optional[pulumi.Input['WatchlistEntityPopulationMechanismManualArgs']]:
        """
        Entities are added manually.

        - - -
        """
        return pulumi.get(self, "manual")

    @manual.setter
    def manual(self, value: Optional[pulumi.Input['WatchlistEntityPopulationMechanismManualArgs']]):
        pulumi.set(self, "manual", value)


if not MYPY:
    class WatchlistEntityPopulationMechanismManualArgsDict(TypedDict):
        pass
elif False:
    WatchlistEntityPopulationMechanismManualArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WatchlistEntityPopulationMechanismManualArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WatchlistWatchlistUserPreferencesArgsDict(TypedDict):
        pinned: NotRequired[pulumi.Input[builtins.bool]]
        """
        Optional. Whether the watchlist is pinned on the dashboard.
        """
elif False:
    WatchlistWatchlistUserPreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WatchlistWatchlistUserPreferencesArgs:
    def __init__(__self__, *,
                 pinned: Optional[pulumi.Input[builtins.bool]] = None):
        """
        :param pulumi.Input[builtins.bool] pinned: Optional. Whether the watchlist is pinned on the dashboard.
        """
        if pinned is not None:
            pulumi.set(__self__, "pinned", pinned)

    @property
    @pulumi.getter
    def pinned(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Optional. Whether the watchlist is pinned on the dashboard.
        """
        return pulumi.get(self, "pinned")

    @pinned.setter
    def pinned(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "pinned", value)


