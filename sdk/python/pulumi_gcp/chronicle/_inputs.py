# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'DataAccessScopeAllowedDataAccessLabelArgs',
    'DataAccessScopeAllowedDataAccessLabelArgsDict',
    'DataAccessScopeAllowedDataAccessLabelIngestionLabelArgs',
    'DataAccessScopeAllowedDataAccessLabelIngestionLabelArgsDict',
    'DataAccessScopeDeniedDataAccessLabelArgs',
    'DataAccessScopeDeniedDataAccessLabelArgsDict',
    'DataAccessScopeDeniedDataAccessLabelIngestionLabelArgs',
    'DataAccessScopeDeniedDataAccessLabelIngestionLabelArgsDict',
    'WatchlistEntityCountArgs',
    'WatchlistEntityCountArgsDict',
    'WatchlistEntityPopulationMechanismArgs',
    'WatchlistEntityPopulationMechanismArgsDict',
    'WatchlistEntityPopulationMechanismManualArgs',
    'WatchlistEntityPopulationMechanismManualArgsDict',
    'WatchlistWatchlistUserPreferencesArgs',
    'WatchlistWatchlistUserPreferencesArgsDict',
]

MYPY = False

if not MYPY:
    class DataAccessScopeAllowedDataAccessLabelArgsDict(TypedDict):
        asset_namespace: NotRequired[pulumi.Input[str]]
        """
        The asset namespace configured in the forwarder
        of the customer's events.
        """
        data_access_label: NotRequired[pulumi.Input[str]]
        """
        The name of the data access label.
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Output only. The display name of the label.
        Data access label and log types's name
        will match the display name of the resource.
        The asset namespace will match the namespace itself.
        The ingestion key value pair will match the key of the tuple.
        """
        ingestion_label: NotRequired[pulumi.Input['DataAccessScopeAllowedDataAccessLabelIngestionLabelArgsDict']]
        """
        Representation of an ingestion label type.
        Structure is documented below.
        """
        log_type: NotRequired[pulumi.Input[str]]
        """
        The name of the log type.
        """
elif False:
    DataAccessScopeAllowedDataAccessLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAccessScopeAllowedDataAccessLabelArgs:
    def __init__(__self__, *,
                 asset_namespace: Optional[pulumi.Input[str]] = None,
                 data_access_label: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 ingestion_label: Optional[pulumi.Input['DataAccessScopeAllowedDataAccessLabelIngestionLabelArgs']] = None,
                 log_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] asset_namespace: The asset namespace configured in the forwarder
               of the customer's events.
        :param pulumi.Input[str] data_access_label: The name of the data access label.
        :param pulumi.Input[str] display_name: (Output)
               Output only. The display name of the label.
               Data access label and log types's name
               will match the display name of the resource.
               The asset namespace will match the namespace itself.
               The ingestion key value pair will match the key of the tuple.
        :param pulumi.Input['DataAccessScopeAllowedDataAccessLabelIngestionLabelArgs'] ingestion_label: Representation of an ingestion label type.
               Structure is documented below.
        :param pulumi.Input[str] log_type: The name of the log type.
        """
        if asset_namespace is not None:
            pulumi.set(__self__, "asset_namespace", asset_namespace)
        if data_access_label is not None:
            pulumi.set(__self__, "data_access_label", data_access_label)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if ingestion_label is not None:
            pulumi.set(__self__, "ingestion_label", ingestion_label)
        if log_type is not None:
            pulumi.set(__self__, "log_type", log_type)

    @property
    @pulumi.getter(name="assetNamespace")
    def asset_namespace(self) -> Optional[pulumi.Input[str]]:
        """
        The asset namespace configured in the forwarder
        of the customer's events.
        """
        return pulumi.get(self, "asset_namespace")

    @asset_namespace.setter
    def asset_namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "asset_namespace", value)

    @property
    @pulumi.getter(name="dataAccessLabel")
    def data_access_label(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the data access label.
        """
        return pulumi.get(self, "data_access_label")

    @data_access_label.setter
    def data_access_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_access_label", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Output only. The display name of the label.
        Data access label and log types's name
        will match the display name of the resource.
        The asset namespace will match the namespace itself.
        The ingestion key value pair will match the key of the tuple.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="ingestionLabel")
    def ingestion_label(self) -> Optional[pulumi.Input['DataAccessScopeAllowedDataAccessLabelIngestionLabelArgs']]:
        """
        Representation of an ingestion label type.
        Structure is documented below.
        """
        return pulumi.get(self, "ingestion_label")

    @ingestion_label.setter
    def ingestion_label(self, value: Optional[pulumi.Input['DataAccessScopeAllowedDataAccessLabelIngestionLabelArgs']]):
        pulumi.set(self, "ingestion_label", value)

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the log type.
        """
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_type", value)


if not MYPY:
    class DataAccessScopeAllowedDataAccessLabelIngestionLabelArgsDict(TypedDict):
        ingestion_label_key: pulumi.Input[str]
        """
        Required. The key of the ingestion label. Always required.
        """
        ingestion_label_value: NotRequired[pulumi.Input[str]]
        """
        Optional. The value of the ingestion label. Optional. An object
        with no provided value and some key provided would match
        against the given key and ANY value.
        """
elif False:
    DataAccessScopeAllowedDataAccessLabelIngestionLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAccessScopeAllowedDataAccessLabelIngestionLabelArgs:
    def __init__(__self__, *,
                 ingestion_label_key: pulumi.Input[str],
                 ingestion_label_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ingestion_label_key: Required. The key of the ingestion label. Always required.
        :param pulumi.Input[str] ingestion_label_value: Optional. The value of the ingestion label. Optional. An object
               with no provided value and some key provided would match
               against the given key and ANY value.
        """
        pulumi.set(__self__, "ingestion_label_key", ingestion_label_key)
        if ingestion_label_value is not None:
            pulumi.set(__self__, "ingestion_label_value", ingestion_label_value)

    @property
    @pulumi.getter(name="ingestionLabelKey")
    def ingestion_label_key(self) -> pulumi.Input[str]:
        """
        Required. The key of the ingestion label. Always required.
        """
        return pulumi.get(self, "ingestion_label_key")

    @ingestion_label_key.setter
    def ingestion_label_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "ingestion_label_key", value)

    @property
    @pulumi.getter(name="ingestionLabelValue")
    def ingestion_label_value(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The value of the ingestion label. Optional. An object
        with no provided value and some key provided would match
        against the given key and ANY value.
        """
        return pulumi.get(self, "ingestion_label_value")

    @ingestion_label_value.setter
    def ingestion_label_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ingestion_label_value", value)


if not MYPY:
    class DataAccessScopeDeniedDataAccessLabelArgsDict(TypedDict):
        asset_namespace: NotRequired[pulumi.Input[str]]
        """
        The asset namespace configured in the forwarder
        of the customer's events.
        """
        data_access_label: NotRequired[pulumi.Input[str]]
        """
        The name of the data access label.
        """
        display_name: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Output only. The display name of the label.
        Data access label and log types's name
        will match the display name of the resource.
        The asset namespace will match the namespace itself.
        The ingestion key value pair will match the key of the tuple.
        """
        ingestion_label: NotRequired[pulumi.Input['DataAccessScopeDeniedDataAccessLabelIngestionLabelArgsDict']]
        """
        Representation of an ingestion label type.
        Structure is documented below.
        """
        log_type: NotRequired[pulumi.Input[str]]
        """
        The name of the log type.
        """
elif False:
    DataAccessScopeDeniedDataAccessLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAccessScopeDeniedDataAccessLabelArgs:
    def __init__(__self__, *,
                 asset_namespace: Optional[pulumi.Input[str]] = None,
                 data_access_label: Optional[pulumi.Input[str]] = None,
                 display_name: Optional[pulumi.Input[str]] = None,
                 ingestion_label: Optional[pulumi.Input['DataAccessScopeDeniedDataAccessLabelIngestionLabelArgs']] = None,
                 log_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] asset_namespace: The asset namespace configured in the forwarder
               of the customer's events.
        :param pulumi.Input[str] data_access_label: The name of the data access label.
        :param pulumi.Input[str] display_name: (Output)
               Output only. The display name of the label.
               Data access label and log types's name
               will match the display name of the resource.
               The asset namespace will match the namespace itself.
               The ingestion key value pair will match the key of the tuple.
        :param pulumi.Input['DataAccessScopeDeniedDataAccessLabelIngestionLabelArgs'] ingestion_label: Representation of an ingestion label type.
               Structure is documented below.
        :param pulumi.Input[str] log_type: The name of the log type.
        """
        if asset_namespace is not None:
            pulumi.set(__self__, "asset_namespace", asset_namespace)
        if data_access_label is not None:
            pulumi.set(__self__, "data_access_label", data_access_label)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)
        if ingestion_label is not None:
            pulumi.set(__self__, "ingestion_label", ingestion_label)
        if log_type is not None:
            pulumi.set(__self__, "log_type", log_type)

    @property
    @pulumi.getter(name="assetNamespace")
    def asset_namespace(self) -> Optional[pulumi.Input[str]]:
        """
        The asset namespace configured in the forwarder
        of the customer's events.
        """
        return pulumi.get(self, "asset_namespace")

    @asset_namespace.setter
    def asset_namespace(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "asset_namespace", value)

    @property
    @pulumi.getter(name="dataAccessLabel")
    def data_access_label(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the data access label.
        """
        return pulumi.get(self, "data_access_label")

    @data_access_label.setter
    def data_access_label(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_access_label", value)

    @property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Output only. The display name of the label.
        Data access label and log types's name
        will match the display name of the resource.
        The asset namespace will match the namespace itself.
        The ingestion key value pair will match the key of the tuple.
        """
        return pulumi.get(self, "display_name")

    @display_name.setter
    def display_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "display_name", value)

    @property
    @pulumi.getter(name="ingestionLabel")
    def ingestion_label(self) -> Optional[pulumi.Input['DataAccessScopeDeniedDataAccessLabelIngestionLabelArgs']]:
        """
        Representation of an ingestion label type.
        Structure is documented below.
        """
        return pulumi.get(self, "ingestion_label")

    @ingestion_label.setter
    def ingestion_label(self, value: Optional[pulumi.Input['DataAccessScopeDeniedDataAccessLabelIngestionLabelArgs']]):
        pulumi.set(self, "ingestion_label", value)

    @property
    @pulumi.getter(name="logType")
    def log_type(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the log type.
        """
        return pulumi.get(self, "log_type")

    @log_type.setter
    def log_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "log_type", value)


if not MYPY:
    class DataAccessScopeDeniedDataAccessLabelIngestionLabelArgsDict(TypedDict):
        ingestion_label_key: pulumi.Input[str]
        """
        Required. The key of the ingestion label. Always required.
        """
        ingestion_label_value: NotRequired[pulumi.Input[str]]
        """
        Optional. The value of the ingestion label. Optional. An object
        with no provided value and some key provided would match
        against the given key and ANY value.
        """
elif False:
    DataAccessScopeDeniedDataAccessLabelIngestionLabelArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataAccessScopeDeniedDataAccessLabelIngestionLabelArgs:
    def __init__(__self__, *,
                 ingestion_label_key: pulumi.Input[str],
                 ingestion_label_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ingestion_label_key: Required. The key of the ingestion label. Always required.
        :param pulumi.Input[str] ingestion_label_value: Optional. The value of the ingestion label. Optional. An object
               with no provided value and some key provided would match
               against the given key and ANY value.
        """
        pulumi.set(__self__, "ingestion_label_key", ingestion_label_key)
        if ingestion_label_value is not None:
            pulumi.set(__self__, "ingestion_label_value", ingestion_label_value)

    @property
    @pulumi.getter(name="ingestionLabelKey")
    def ingestion_label_key(self) -> pulumi.Input[str]:
        """
        Required. The key of the ingestion label. Always required.
        """
        return pulumi.get(self, "ingestion_label_key")

    @ingestion_label_key.setter
    def ingestion_label_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "ingestion_label_key", value)

    @property
    @pulumi.getter(name="ingestionLabelValue")
    def ingestion_label_value(self) -> Optional[pulumi.Input[str]]:
        """
        Optional. The value of the ingestion label. Optional. An object
        with no provided value and some key provided would match
        against the given key and ANY value.
        """
        return pulumi.get(self, "ingestion_label_value")

    @ingestion_label_value.setter
    def ingestion_label_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ingestion_label_value", value)


if not MYPY:
    class WatchlistEntityCountArgsDict(TypedDict):
        asset: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Output only. Count of asset type entities in the watchlist.
        """
        user: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Output only. Count of user type entities in the watchlist.
        """
elif False:
    WatchlistEntityCountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WatchlistEntityCountArgs:
    def __init__(__self__, *,
                 asset: Optional[pulumi.Input[int]] = None,
                 user: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] asset: (Output)
               Output only. Count of asset type entities in the watchlist.
        :param pulumi.Input[int] user: (Output)
               Output only. Count of user type entities in the watchlist.
        """
        if asset is not None:
            pulumi.set(__self__, "asset", asset)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def asset(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Output only. Count of asset type entities in the watchlist.
        """
        return pulumi.get(self, "asset")

    @asset.setter
    def asset(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "asset", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Output only. Count of user type entities in the watchlist.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "user", value)


if not MYPY:
    class WatchlistEntityPopulationMechanismArgsDict(TypedDict):
        manual: NotRequired[pulumi.Input['WatchlistEntityPopulationMechanismManualArgsDict']]
        """
        Entities are added manually.

        - - -
        """
elif False:
    WatchlistEntityPopulationMechanismArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WatchlistEntityPopulationMechanismArgs:
    def __init__(__self__, *,
                 manual: Optional[pulumi.Input['WatchlistEntityPopulationMechanismManualArgs']] = None):
        """
        :param pulumi.Input['WatchlistEntityPopulationMechanismManualArgs'] manual: Entities are added manually.
               
               - - -
        """
        if manual is not None:
            pulumi.set(__self__, "manual", manual)

    @property
    @pulumi.getter
    def manual(self) -> Optional[pulumi.Input['WatchlistEntityPopulationMechanismManualArgs']]:
        """
        Entities are added manually.

        - - -
        """
        return pulumi.get(self, "manual")

    @manual.setter
    def manual(self, value: Optional[pulumi.Input['WatchlistEntityPopulationMechanismManualArgs']]):
        pulumi.set(self, "manual", value)


if not MYPY:
    class WatchlistEntityPopulationMechanismManualArgsDict(TypedDict):
        pass
elif False:
    WatchlistEntityPopulationMechanismManualArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WatchlistEntityPopulationMechanismManualArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class WatchlistWatchlistUserPreferencesArgsDict(TypedDict):
        pinned: NotRequired[pulumi.Input[bool]]
        """
        Optional. Whether the watchlist is pinned on the dashboard.
        """
elif False:
    WatchlistWatchlistUserPreferencesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class WatchlistWatchlistUserPreferencesArgs:
    def __init__(__self__, *,
                 pinned: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] pinned: Optional. Whether the watchlist is pinned on the dashboard.
        """
        if pinned is not None:
            pulumi.set(__self__, "pinned", pinned)

    @property
    @pulumi.getter
    def pinned(self) -> Optional[pulumi.Input[bool]]:
        """
        Optional. Whether the watchlist is pinned on the dashboard.
        """
        return pulumi.get(self, "pinned")

    @pinned.setter
    def pinned(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "pinned", value)


