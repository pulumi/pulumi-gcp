# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'BackupPlanAssociationRulesConfigInfoArgs',
    'BackupPlanAssociationRulesConfigInfoArgsDict',
    'BackupPlanAssociationRulesConfigInfoLastBackupErrorArgs',
    'BackupPlanAssociationRulesConfigInfoLastBackupErrorArgsDict',
    'BackupPlanBackupRuleArgs',
    'BackupPlanBackupRuleArgsDict',
    'BackupPlanBackupRuleStandardScheduleArgs',
    'BackupPlanBackupRuleStandardScheduleArgsDict',
    'BackupPlanBackupRuleStandardScheduleBackupWindowArgs',
    'BackupPlanBackupRuleStandardScheduleBackupWindowArgsDict',
    'BackupPlanBackupRuleStandardScheduleWeekDayOfMonthArgs',
    'BackupPlanBackupRuleStandardScheduleWeekDayOfMonthArgsDict',
    'ManagementServerManagementUriArgs',
    'ManagementServerManagementUriArgsDict',
    'ManagementServerNetworkArgs',
    'ManagementServerNetworkArgsDict',
]

MYPY = False

if not MYPY:
    class BackupPlanAssociationRulesConfigInfoArgsDict(TypedDict):
        last_backup_errors: NotRequired[pulumi.Input[Sequence[pulumi.Input['BackupPlanAssociationRulesConfigInfoLastBackupErrorArgsDict']]]]
        """
        (Output)
        google.rpc.Status object to store the last backup error
        Structure is documented below.
        """
        last_backup_state: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        State of last backup taken.
        """
        rule_id: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        Backup Rule id fetched from backup plan.
        """
elif False:
    BackupPlanAssociationRulesConfigInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupPlanAssociationRulesConfigInfoArgs:
    def __init__(__self__, *,
                 last_backup_errors: Optional[pulumi.Input[Sequence[pulumi.Input['BackupPlanAssociationRulesConfigInfoLastBackupErrorArgs']]]] = None,
                 last_backup_state: Optional[pulumi.Input[builtins.str]] = None,
                 rule_id: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BackupPlanAssociationRulesConfigInfoLastBackupErrorArgs']]] last_backup_errors: (Output)
               google.rpc.Status object to store the last backup error
               Structure is documented below.
        :param pulumi.Input[builtins.str] last_backup_state: (Output)
               State of last backup taken.
        :param pulumi.Input[builtins.str] rule_id: (Output)
               Backup Rule id fetched from backup plan.
        """
        if last_backup_errors is not None:
            pulumi.set(__self__, "last_backup_errors", last_backup_errors)
        if last_backup_state is not None:
            pulumi.set(__self__, "last_backup_state", last_backup_state)
        if rule_id is not None:
            pulumi.set(__self__, "rule_id", rule_id)

    @property
    @pulumi.getter(name="lastBackupErrors")
    def last_backup_errors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BackupPlanAssociationRulesConfigInfoLastBackupErrorArgs']]]]:
        """
        (Output)
        google.rpc.Status object to store the last backup error
        Structure is documented below.
        """
        return pulumi.get(self, "last_backup_errors")

    @last_backup_errors.setter
    def last_backup_errors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BackupPlanAssociationRulesConfigInfoLastBackupErrorArgs']]]]):
        pulumi.set(self, "last_backup_errors", value)

    @property
    @pulumi.getter(name="lastBackupState")
    def last_backup_state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        State of last backup taken.
        """
        return pulumi.get(self, "last_backup_state")

    @last_backup_state.setter
    def last_backup_state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_backup_state", value)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        Backup Rule id fetched from backup plan.
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "rule_id", value)


if not MYPY:
    class BackupPlanAssociationRulesConfigInfoLastBackupErrorArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[builtins.float]]
        """
        (Output)
        The status code, which should be an enum value of [google.rpc.Code]
        """
        message: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        A developer-facing error message, which should be in English.
        """
elif False:
    BackupPlanAssociationRulesConfigInfoLastBackupErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupPlanAssociationRulesConfigInfoLastBackupErrorArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[builtins.float]] = None,
                 message: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.float] code: (Output)
               The status code, which should be an enum value of [google.rpc.Code]
        :param pulumi.Input[builtins.str] message: (Output)
               A developer-facing error message, which should be in English.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[builtins.float]]:
        """
        (Output)
        The status code, which should be an enum value of [google.rpc.Code]
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[builtins.float]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        A developer-facing error message, which should be in English.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class BackupPlanBackupRuleArgsDict(TypedDict):
        backup_retention_days: pulumi.Input[builtins.int]
        """
        Configures the duration for which backup data will be kept. The value should be greater than or equal to minimum enforced retention of the backup vault.
        """
        rule_id: pulumi.Input[builtins.str]
        """
        The unique ID of this `BackupRule`. The `rule_id` is unique per `BackupPlan`.
        """
        standard_schedule: pulumi.Input['BackupPlanBackupRuleStandardScheduleArgsDict']
        """
        StandardSchedule defines a schedule that runs within the confines of a defined window of days.
        Structure is documented below.
        """
elif False:
    BackupPlanBackupRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupPlanBackupRuleArgs:
    def __init__(__self__, *,
                 backup_retention_days: pulumi.Input[builtins.int],
                 rule_id: pulumi.Input[builtins.str],
                 standard_schedule: pulumi.Input['BackupPlanBackupRuleStandardScheduleArgs']):
        """
        :param pulumi.Input[builtins.int] backup_retention_days: Configures the duration for which backup data will be kept. The value should be greater than or equal to minimum enforced retention of the backup vault.
        :param pulumi.Input[builtins.str] rule_id: The unique ID of this `BackupRule`. The `rule_id` is unique per `BackupPlan`.
        :param pulumi.Input['BackupPlanBackupRuleStandardScheduleArgs'] standard_schedule: StandardSchedule defines a schedule that runs within the confines of a defined window of days.
               Structure is documented below.
        """
        pulumi.set(__self__, "backup_retention_days", backup_retention_days)
        pulumi.set(__self__, "rule_id", rule_id)
        pulumi.set(__self__, "standard_schedule", standard_schedule)

    @property
    @pulumi.getter(name="backupRetentionDays")
    def backup_retention_days(self) -> pulumi.Input[builtins.int]:
        """
        Configures the duration for which backup data will be kept. The value should be greater than or equal to minimum enforced retention of the backup vault.
        """
        return pulumi.get(self, "backup_retention_days")

    @backup_retention_days.setter
    def backup_retention_days(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "backup_retention_days", value)

    @property
    @pulumi.getter(name="ruleId")
    def rule_id(self) -> pulumi.Input[builtins.str]:
        """
        The unique ID of this `BackupRule`. The `rule_id` is unique per `BackupPlan`.
        """
        return pulumi.get(self, "rule_id")

    @rule_id.setter
    def rule_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "rule_id", value)

    @property
    @pulumi.getter(name="standardSchedule")
    def standard_schedule(self) -> pulumi.Input['BackupPlanBackupRuleStandardScheduleArgs']:
        """
        StandardSchedule defines a schedule that runs within the confines of a defined window of days.
        Structure is documented below.
        """
        return pulumi.get(self, "standard_schedule")

    @standard_schedule.setter
    def standard_schedule(self, value: pulumi.Input['BackupPlanBackupRuleStandardScheduleArgs']):
        pulumi.set(self, "standard_schedule", value)


if not MYPY:
    class BackupPlanBackupRuleStandardScheduleArgsDict(TypedDict):
        recurrence_type: pulumi.Input[builtins.str]
        """
        RecurrenceType enumerates the applicable periodicity for the schedule.
        Possible values are: `HOURLY`, `DAILY`, `WEEKLY`, `MONTHLY`, `YEARLY`.
        """
        time_zone: pulumi.Input[builtins.str]
        """
        The time zone to be used when interpreting the schedule.
        """
        backup_window: NotRequired[pulumi.Input['BackupPlanBackupRuleStandardScheduleBackupWindowArgsDict']]
        """
        A BackupWindow defines the window of the day during which backup jobs will run. Jobs are queued at the beginning of the window and will be marked as
        `NOT_RUN` if they do not start by the end of the window.
        Structure is documented below.
        """
        days_of_months: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]
        """
        Specifies days of months like 1, 5, or 14 on which jobs will run.
        """
        days_of_weeks: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Specifies days of week like MONDAY or TUESDAY, on which jobs will run. This is required for `recurrence_type`, `WEEKLY` and is not applicable otherwise.
        Each value may be one of: `DAY_OF_WEEK_UNSPECIFIED`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        hourly_frequency: NotRequired[pulumi.Input[builtins.int]]
        """
        Specifies frequency for hourly backups. An hourly frequency of 2 means jobs will run every 2 hours from start time till end time defined.
        This is required for `recurrence_type`, `HOURLY` and is not applicable otherwise.
        """
        months: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Specifies values of months
        Each value may be one of: `MONTH_UNSPECIFIED`, `JANUARY`, `FEBRUARY`, `MARCH`, `APRIL`, `MAY`, `JUNE`, `JULY`, `AUGUST`, `SEPTEMBER`, `OCTOBER`, `NOVEMBER`, `DECEMBER`.
        """
        week_day_of_month: NotRequired[pulumi.Input['BackupPlanBackupRuleStandardScheduleWeekDayOfMonthArgsDict']]
        """
        Specifies a week day of the month like FIRST SUNDAY or LAST MONDAY, on which jobs will run.
        Structure is documented below.
        """
elif False:
    BackupPlanBackupRuleStandardScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupPlanBackupRuleStandardScheduleArgs:
    def __init__(__self__, *,
                 recurrence_type: pulumi.Input[builtins.str],
                 time_zone: pulumi.Input[builtins.str],
                 backup_window: Optional[pulumi.Input['BackupPlanBackupRuleStandardScheduleBackupWindowArgs']] = None,
                 days_of_months: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]] = None,
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 hourly_frequency: Optional[pulumi.Input[builtins.int]] = None,
                 months: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 week_day_of_month: Optional[pulumi.Input['BackupPlanBackupRuleStandardScheduleWeekDayOfMonthArgs']] = None):
        """
        :param pulumi.Input[builtins.str] recurrence_type: RecurrenceType enumerates the applicable periodicity for the schedule.
               Possible values are: `HOURLY`, `DAILY`, `WEEKLY`, `MONTHLY`, `YEARLY`.
        :param pulumi.Input[builtins.str] time_zone: The time zone to be used when interpreting the schedule.
        :param pulumi.Input['BackupPlanBackupRuleStandardScheduleBackupWindowArgs'] backup_window: A BackupWindow defines the window of the day during which backup jobs will run. Jobs are queued at the beginning of the window and will be marked as
               `NOT_RUN` if they do not start by the end of the window.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.int]]] days_of_months: Specifies days of months like 1, 5, or 14 on which jobs will run.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] days_of_weeks: Specifies days of week like MONDAY or TUESDAY, on which jobs will run. This is required for `recurrence_type`, `WEEKLY` and is not applicable otherwise.
               Each value may be one of: `DAY_OF_WEEK_UNSPECIFIED`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input[builtins.int] hourly_frequency: Specifies frequency for hourly backups. An hourly frequency of 2 means jobs will run every 2 hours from start time till end time defined.
               This is required for `recurrence_type`, `HOURLY` and is not applicable otherwise.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] months: Specifies values of months
               Each value may be one of: `MONTH_UNSPECIFIED`, `JANUARY`, `FEBRUARY`, `MARCH`, `APRIL`, `MAY`, `JUNE`, `JULY`, `AUGUST`, `SEPTEMBER`, `OCTOBER`, `NOVEMBER`, `DECEMBER`.
        :param pulumi.Input['BackupPlanBackupRuleStandardScheduleWeekDayOfMonthArgs'] week_day_of_month: Specifies a week day of the month like FIRST SUNDAY or LAST MONDAY, on which jobs will run.
               Structure is documented below.
        """
        pulumi.set(__self__, "recurrence_type", recurrence_type)
        pulumi.set(__self__, "time_zone", time_zone)
        if backup_window is not None:
            pulumi.set(__self__, "backup_window", backup_window)
        if days_of_months is not None:
            pulumi.set(__self__, "days_of_months", days_of_months)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)
        if hourly_frequency is not None:
            pulumi.set(__self__, "hourly_frequency", hourly_frequency)
        if months is not None:
            pulumi.set(__self__, "months", months)
        if week_day_of_month is not None:
            pulumi.set(__self__, "week_day_of_month", week_day_of_month)

    @property
    @pulumi.getter(name="recurrenceType")
    def recurrence_type(self) -> pulumi.Input[builtins.str]:
        """
        RecurrenceType enumerates the applicable periodicity for the schedule.
        Possible values are: `HOURLY`, `DAILY`, `WEEKLY`, `MONTHLY`, `YEARLY`.
        """
        return pulumi.get(self, "recurrence_type")

    @recurrence_type.setter
    def recurrence_type(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "recurrence_type", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[builtins.str]:
        """
        The time zone to be used when interpreting the schedule.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter(name="backupWindow")
    def backup_window(self) -> Optional[pulumi.Input['BackupPlanBackupRuleStandardScheduleBackupWindowArgs']]:
        """
        A BackupWindow defines the window of the day during which backup jobs will run. Jobs are queued at the beginning of the window and will be marked as
        `NOT_RUN` if they do not start by the end of the window.
        Structure is documented below.
        """
        return pulumi.get(self, "backup_window")

    @backup_window.setter
    def backup_window(self, value: Optional[pulumi.Input['BackupPlanBackupRuleStandardScheduleBackupWindowArgs']]):
        pulumi.set(self, "backup_window", value)

    @property
    @pulumi.getter(name="daysOfMonths")
    def days_of_months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]:
        """
        Specifies days of months like 1, 5, or 14 on which jobs will run.
        """
        return pulumi.get(self, "days_of_months")

    @days_of_months.setter
    def days_of_months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.int]]]]):
        pulumi.set(self, "days_of_months", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Specifies days of week like MONDAY or TUESDAY, on which jobs will run. This is required for `recurrence_type`, `WEEKLY` and is not applicable otherwise.
        Each value may be one of: `DAY_OF_WEEK_UNSPECIFIED`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "days_of_weeks", value)

    @property
    @pulumi.getter(name="hourlyFrequency")
    def hourly_frequency(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Specifies frequency for hourly backups. An hourly frequency of 2 means jobs will run every 2 hours from start time till end time defined.
        This is required for `recurrence_type`, `HOURLY` and is not applicable otherwise.
        """
        return pulumi.get(self, "hourly_frequency")

    @hourly_frequency.setter
    def hourly_frequency(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "hourly_frequency", value)

    @property
    @pulumi.getter
    def months(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Specifies values of months
        Each value may be one of: `MONTH_UNSPECIFIED`, `JANUARY`, `FEBRUARY`, `MARCH`, `APRIL`, `MAY`, `JUNE`, `JULY`, `AUGUST`, `SEPTEMBER`, `OCTOBER`, `NOVEMBER`, `DECEMBER`.
        """
        return pulumi.get(self, "months")

    @months.setter
    def months(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "months", value)

    @property
    @pulumi.getter(name="weekDayOfMonth")
    def week_day_of_month(self) -> Optional[pulumi.Input['BackupPlanBackupRuleStandardScheduleWeekDayOfMonthArgs']]:
        """
        Specifies a week day of the month like FIRST SUNDAY or LAST MONDAY, on which jobs will run.
        Structure is documented below.
        """
        return pulumi.get(self, "week_day_of_month")

    @week_day_of_month.setter
    def week_day_of_month(self, value: Optional[pulumi.Input['BackupPlanBackupRuleStandardScheduleWeekDayOfMonthArgs']]):
        pulumi.set(self, "week_day_of_month", value)


if not MYPY:
    class BackupPlanBackupRuleStandardScheduleBackupWindowArgsDict(TypedDict):
        start_hour_of_day: pulumi.Input[builtins.int]
        """
        The hour of the day (0-23) when the window starts, for example, if the value of the start hour of the day is 6, that means the backup window starts at 6:00.
        """
        end_hour_of_day: NotRequired[pulumi.Input[builtins.int]]
        """
        The hour of the day (1-24) when the window ends, for example, if the value of end hour of the day is 10, that means the backup window end time is 10:00.
        The end hour of the day should be greater than the start

        - - -
        """
elif False:
    BackupPlanBackupRuleStandardScheduleBackupWindowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupPlanBackupRuleStandardScheduleBackupWindowArgs:
    def __init__(__self__, *,
                 start_hour_of_day: pulumi.Input[builtins.int],
                 end_hour_of_day: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] start_hour_of_day: The hour of the day (0-23) when the window starts, for example, if the value of the start hour of the day is 6, that means the backup window starts at 6:00.
        :param pulumi.Input[builtins.int] end_hour_of_day: The hour of the day (1-24) when the window ends, for example, if the value of end hour of the day is 10, that means the backup window end time is 10:00.
               The end hour of the day should be greater than the start
               
               - - -
        """
        pulumi.set(__self__, "start_hour_of_day", start_hour_of_day)
        if end_hour_of_day is not None:
            pulumi.set(__self__, "end_hour_of_day", end_hour_of_day)

    @property
    @pulumi.getter(name="startHourOfDay")
    def start_hour_of_day(self) -> pulumi.Input[builtins.int]:
        """
        The hour of the day (0-23) when the window starts, for example, if the value of the start hour of the day is 6, that means the backup window starts at 6:00.
        """
        return pulumi.get(self, "start_hour_of_day")

    @start_hour_of_day.setter
    def start_hour_of_day(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "start_hour_of_day", value)

    @property
    @pulumi.getter(name="endHourOfDay")
    def end_hour_of_day(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The hour of the day (1-24) when the window ends, for example, if the value of end hour of the day is 10, that means the backup window end time is 10:00.
        The end hour of the day should be greater than the start

        - - -
        """
        return pulumi.get(self, "end_hour_of_day")

    @end_hour_of_day.setter
    def end_hour_of_day(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "end_hour_of_day", value)


if not MYPY:
    class BackupPlanBackupRuleStandardScheduleWeekDayOfMonthArgsDict(TypedDict):
        day_of_week: pulumi.Input[builtins.str]
        """
        Specifies the day of the week.
        Possible values are: `DAY_OF_WEEK_UNSPECIFIED`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        week_of_month: pulumi.Input[builtins.str]
        """
        WeekOfMonth enumerates possible weeks in the month, e.g. the first, third, or last week of the month.
        Possible values are: `WEEK_OF_MONTH_UNSPECIFIED`, `FIRST`, `SECOND`, `THIRD`, `FOURTH`, `LAST`.
        """
elif False:
    BackupPlanBackupRuleStandardScheduleWeekDayOfMonthArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BackupPlanBackupRuleStandardScheduleWeekDayOfMonthArgs:
    def __init__(__self__, *,
                 day_of_week: pulumi.Input[builtins.str],
                 week_of_month: pulumi.Input[builtins.str]):
        """
        :param pulumi.Input[builtins.str] day_of_week: Specifies the day of the week.
               Possible values are: `DAY_OF_WEEK_UNSPECIFIED`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input[builtins.str] week_of_month: WeekOfMonth enumerates possible weeks in the month, e.g. the first, third, or last week of the month.
               Possible values are: `WEEK_OF_MONTH_UNSPECIFIED`, `FIRST`, `SECOND`, `THIRD`, `FOURTH`, `LAST`.
        """
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "week_of_month", week_of_month)

    @property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> pulumi.Input[builtins.str]:
        """
        Specifies the day of the week.
        Possible values are: `DAY_OF_WEEK_UNSPECIFIED`, `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week")

    @day_of_week.setter
    def day_of_week(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "day_of_week", value)

    @property
    @pulumi.getter(name="weekOfMonth")
    def week_of_month(self) -> pulumi.Input[builtins.str]:
        """
        WeekOfMonth enumerates possible weeks in the month, e.g. the first, third, or last week of the month.
        Possible values are: `WEEK_OF_MONTH_UNSPECIFIED`, `FIRST`, `SECOND`, `THIRD`, `FOURTH`, `LAST`.
        """
        return pulumi.get(self, "week_of_month")

    @week_of_month.setter
    def week_of_month(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "week_of_month", value)


if not MYPY:
    class ManagementServerManagementUriArgsDict(TypedDict):
        api: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        The management console api endpoint.
        """
        web_ui: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        The management console webUi.
        """
elif False:
    ManagementServerManagementUriArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementServerManagementUriArgs:
    def __init__(__self__, *,
                 api: Optional[pulumi.Input[builtins.str]] = None,
                 web_ui: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] api: (Output)
               The management console api endpoint.
        :param pulumi.Input[builtins.str] web_ui: (Output)
               The management console webUi.
        """
        if api is not None:
            pulumi.set(__self__, "api", api)
        if web_ui is not None:
            pulumi.set(__self__, "web_ui", web_ui)

    @property
    @pulumi.getter
    def api(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        The management console api endpoint.
        """
        return pulumi.get(self, "api")

    @api.setter
    def api(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "api", value)

    @property
    @pulumi.getter(name="webUi")
    def web_ui(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        The management console webUi.
        """
        return pulumi.get(self, "web_ui")

    @web_ui.setter
    def web_ui(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "web_ui", value)


if not MYPY:
    class ManagementServerNetworkArgsDict(TypedDict):
        network: pulumi.Input[builtins.str]
        """
        Network with format `projects/{{project_id}}/global/networks/{{network_id}}`
        """
        peering_mode: NotRequired[pulumi.Input[builtins.str]]
        """
        Type of Network peeringMode
        Default value is `PRIVATE_SERVICE_ACCESS`.
        Possible values are: `PRIVATE_SERVICE_ACCESS`.
        """
elif False:
    ManagementServerNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ManagementServerNetworkArgs:
    def __init__(__self__, *,
                 network: pulumi.Input[builtins.str],
                 peering_mode: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] network: Network with format `projects/{{project_id}}/global/networks/{{network_id}}`
        :param pulumi.Input[builtins.str] peering_mode: Type of Network peeringMode
               Default value is `PRIVATE_SERVICE_ACCESS`.
               Possible values are: `PRIVATE_SERVICE_ACCESS`.
        """
        pulumi.set(__self__, "network", network)
        if peering_mode is not None:
            pulumi.set(__self__, "peering_mode", peering_mode)

    @property
    @pulumi.getter
    def network(self) -> pulumi.Input[builtins.str]:
        """
        Network with format `projects/{{project_id}}/global/networks/{{network_id}}`
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter(name="peeringMode")
    def peering_mode(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Type of Network peeringMode
        Default value is `PRIVATE_SERVICE_ACCESS`.
        Possible values are: `PRIVATE_SERVICE_ACCESS`.
        """
        return pulumi.get(self, "peering_mode")

    @peering_mode.setter
    def peering_mode(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "peering_mode", value)


