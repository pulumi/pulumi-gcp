# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'BareMetalAdminClusterClusterOperationsArgs',
    'BareMetalAdminClusterControlPlaneArgs',
    'BareMetalAdminClusterControlPlaneApiServerArgArgs',
    'BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigArgs',
    'BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigArgs',
    'BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfigArgs',
    'BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaintArgs',
    'BareMetalAdminClusterFleetArgs',
    'BareMetalAdminClusterLoadBalancerArgs',
    'BareMetalAdminClusterLoadBalancerManualLbConfigArgs',
    'BareMetalAdminClusterLoadBalancerPortConfigArgs',
    'BareMetalAdminClusterLoadBalancerVipConfigArgs',
    'BareMetalAdminClusterMaintenanceConfigArgs',
    'BareMetalAdminClusterNetworkConfigArgs',
    'BareMetalAdminClusterNetworkConfigIslandModeCidrArgs',
    'BareMetalAdminClusterNodeAccessConfigArgs',
    'BareMetalAdminClusterNodeConfigArgs',
    'BareMetalAdminClusterProxyArgs',
    'BareMetalAdminClusterSecurityConfigArgs',
    'BareMetalAdminClusterSecurityConfigAuthorizationArgs',
    'BareMetalAdminClusterSecurityConfigAuthorizationAdminUserArgs',
    'BareMetalAdminClusterStatusArgs',
    'BareMetalAdminClusterStatusConditionArgs',
    'BareMetalAdminClusterStorageArgs',
    'BareMetalAdminClusterStorageLvpNodeMountsConfigArgs',
    'BareMetalAdminClusterStorageLvpShareConfigArgs',
    'BareMetalAdminClusterStorageLvpShareConfigLvpConfigArgs',
    'BareMetalAdminClusterValidationCheckArgs',
    'BareMetalAdminClusterValidationCheckStatusArgs',
    'BareMetalAdminClusterValidationCheckStatusResultArgs',
    'BareMetalClusterBinaryAuthorizationArgs',
    'BareMetalClusterClusterOperationsArgs',
    'BareMetalClusterControlPlaneArgs',
    'BareMetalClusterControlPlaneApiServerArgArgs',
    'BareMetalClusterControlPlaneControlPlaneNodePoolConfigArgs',
    'BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigArgs',
    'BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfigArgs',
    'BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaintArgs',
    'BareMetalClusterFleetArgs',
    'BareMetalClusterLoadBalancerArgs',
    'BareMetalClusterLoadBalancerBgpLbConfigArgs',
    'BareMetalClusterLoadBalancerBgpLbConfigAddressPoolArgs',
    'BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfigArgs',
    'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigArgs',
    'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigArgs',
    'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfigArgs',
    'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfigArgs',
    'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaintArgs',
    'BareMetalClusterLoadBalancerManualLbConfigArgs',
    'BareMetalClusterLoadBalancerMetalLbConfigArgs',
    'BareMetalClusterLoadBalancerMetalLbConfigAddressPoolArgs',
    'BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigArgs',
    'BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigArgs',
    'BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfigArgs',
    'BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaintArgs',
    'BareMetalClusterLoadBalancerPortConfigArgs',
    'BareMetalClusterLoadBalancerVipConfigArgs',
    'BareMetalClusterMaintenanceConfigArgs',
    'BareMetalClusterNetworkConfigArgs',
    'BareMetalClusterNetworkConfigIslandModeCidrArgs',
    'BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfigArgs',
    'BareMetalClusterNetworkConfigSrIovConfigArgs',
    'BareMetalClusterNodeAccessConfigArgs',
    'BareMetalClusterNodeConfigArgs',
    'BareMetalClusterOsEnvironmentConfigArgs',
    'BareMetalClusterProxyArgs',
    'BareMetalClusterSecurityConfigArgs',
    'BareMetalClusterSecurityConfigAuthorizationArgs',
    'BareMetalClusterSecurityConfigAuthorizationAdminUserArgs',
    'BareMetalClusterStatusArgs',
    'BareMetalClusterStatusConditionArgs',
    'BareMetalClusterStorageArgs',
    'BareMetalClusterStorageLvpNodeMountsConfigArgs',
    'BareMetalClusterStorageLvpShareConfigArgs',
    'BareMetalClusterStorageLvpShareConfigLvpConfigArgs',
    'BareMetalClusterUpgradePolicyArgs',
    'BareMetalClusterValidationCheckArgs',
    'BareMetalClusterValidationCheckStatusArgs',
    'BareMetalClusterValidationCheckStatusResultArgs',
    'BareMetalNodePoolNodePoolConfigArgs',
    'BareMetalNodePoolNodePoolConfigNodeConfigArgs',
    'BareMetalNodePoolNodePoolConfigTaintArgs',
    'BareMetalNodePoolStatusArgs',
    'BareMetalNodePoolStatusConditionArgs',
    'VMwareClusterAntiAffinityGroupsArgs',
    'VMwareClusterAuthorizationArgs',
    'VMwareClusterAuthorizationAdminUserArgs',
    'VMwareClusterAutoRepairConfigArgs',
    'VMwareClusterControlPlaneNodeArgs',
    'VMwareClusterControlPlaneNodeAutoResizeConfigArgs',
    'VMwareClusterControlPlaneNodeVsphereConfigArgs',
    'VMwareClusterDataplaneV2Args',
    'VMwareClusterFleetArgs',
    'VMwareClusterLoadBalancerArgs',
    'VMwareClusterLoadBalancerF5ConfigArgs',
    'VMwareClusterLoadBalancerManualLbConfigArgs',
    'VMwareClusterLoadBalancerMetalLbConfigArgs',
    'VMwareClusterLoadBalancerMetalLbConfigAddressPoolArgs',
    'VMwareClusterLoadBalancerVipConfigArgs',
    'VMwareClusterNetworkConfigArgs',
    'VMwareClusterNetworkConfigControlPlaneV2ConfigArgs',
    'VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockArgs',
    'VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIpArgs',
    'VMwareClusterNetworkConfigDhcpIpConfigArgs',
    'VMwareClusterNetworkConfigHostConfigArgs',
    'VMwareClusterNetworkConfigStaticIpConfigArgs',
    'VMwareClusterNetworkConfigStaticIpConfigIpBlockArgs',
    'VMwareClusterNetworkConfigStaticIpConfigIpBlockIpArgs',
    'VMwareClusterStatusArgs',
    'VMwareClusterStatusConditionArgs',
    'VMwareClusterStorageArgs',
    'VMwareClusterUpgradePolicyArgs',
    'VMwareClusterValidationCheckArgs',
    'VMwareClusterValidationCheckStatusArgs',
    'VMwareClusterValidationCheckStatusResultArgs',
    'VMwareClusterVcenterArgs',
    'VMwareNodePoolConfigArgs',
    'VMwareNodePoolConfigTaintArgs',
    'VMwareNodePoolConfigVsphereConfigArgs',
    'VMwareNodePoolConfigVsphereConfigTagArgs',
    'VMwareNodePoolNodePoolAutoscalingArgs',
    'VMwareNodePoolStatusArgs',
    'VMwareNodePoolStatusConditionArgs',
]

@pulumi.input_type
class BareMetalAdminClusterClusterOperationsArgs:
    def __init__(__self__, *,
                 enable_application_logs: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enable_application_logs: Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        if enable_application_logs is not None:
            pulumi.set(__self__, "enable_application_logs", enable_application_logs)

    @property
    @pulumi.getter(name="enableApplicationLogs")
    def enable_application_logs(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        return pulumi.get(self, "enable_application_logs")

    @enable_application_logs.setter
    def enable_application_logs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_application_logs", value)


@pulumi.input_type
class BareMetalAdminClusterControlPlaneArgs:
    def __init__(__self__, *,
                 control_plane_node_pool_config: pulumi.Input['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigArgs'],
                 api_server_args: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterControlPlaneApiServerArgArgs']]]] = None):
        """
        :param pulumi.Input['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigArgs'] control_plane_node_pool_config: Configures the node pool running the control plane. If specified the corresponding NodePool will be created for the cluster's control plane. The NodePool will have the same name and namespace as the cluster.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterControlPlaneApiServerArgArgs']]] api_server_args: Customizes the default API server args. Only a subset of
               customized flags are supported. Please refer to the API server
               documentation below to know the exact format:
               https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
               Structure is documented below.
        """
        pulumi.set(__self__, "control_plane_node_pool_config", control_plane_node_pool_config)
        if api_server_args is not None:
            pulumi.set(__self__, "api_server_args", api_server_args)

    @property
    @pulumi.getter(name="controlPlaneNodePoolConfig")
    def control_plane_node_pool_config(self) -> pulumi.Input['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigArgs']:
        """
        Configures the node pool running the control plane. If specified the corresponding NodePool will be created for the cluster's control plane. The NodePool will have the same name and namespace as the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "control_plane_node_pool_config")

    @control_plane_node_pool_config.setter
    def control_plane_node_pool_config(self, value: pulumi.Input['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigArgs']):
        pulumi.set(self, "control_plane_node_pool_config", value)

    @property
    @pulumi.getter(name="apiServerArgs")
    def api_server_args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterControlPlaneApiServerArgArgs']]]]:
        """
        Customizes the default API server args. Only a subset of
        customized flags are supported. Please refer to the API server
        documentation below to know the exact format:
        https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
        Structure is documented below.
        """
        return pulumi.get(self, "api_server_args")

    @api_server_args.setter
    def api_server_args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterControlPlaneApiServerArgArgs']]]]):
        pulumi.set(self, "api_server_args", value)


@pulumi.input_type
class BareMetalAdminClusterControlPlaneApiServerArgArgs:
    def __init__(__self__, *,
                 argument: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] argument: The argument name as it appears on the API Server command line please make sure to remove the leading dashes.
        :param pulumi.Input[str] value: The value of the arg as it will be passed to the API Server command line.
        """
        pulumi.set(__self__, "argument", argument)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def argument(self) -> pulumi.Input[str]:
        """
        The argument name as it appears on the API Server command line please make sure to remove the leading dashes.
        """
        return pulumi.get(self, "argument")

    @argument.setter
    def argument(self, value: pulumi.Input[str]):
        pulumi.set(self, "argument", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the arg as it will be passed to the API Server command line.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigArgs:
    def __init__(__self__, *,
                 node_pool_config: pulumi.Input['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigArgs']):
        """
        :param pulumi.Input['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigArgs'] node_pool_config: The generic configuration for a node pool running the control plane.
               Structure is documented below.
        """
        pulumi.set(__self__, "node_pool_config", node_pool_config)

    @property
    @pulumi.getter(name="nodePoolConfig")
    def node_pool_config(self) -> pulumi.Input['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigArgs']:
        """
        The generic configuration for a node pool running the control plane.
        Structure is documented below.
        """
        return pulumi.get(self, "node_pool_config")

    @node_pool_config.setter
    def node_pool_config(self, value: pulumi.Input['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigArgs']):
        pulumi.set(self, "node_pool_config", value)


@pulumi.input_type
class BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigArgs:
    def __init__(__self__, *,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 node_configs: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfigArgs']]]] = None,
                 operating_system: Optional[pulumi.Input[str]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaintArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfigArgs']]] node_configs: The list of machine addresses in the Bare Metal Node Pool.
               Structure is documented below.
        :param pulumi.Input[str] operating_system: Specifies the nodes operating system (default: LINUX).
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaintArgs']]] taints: The initial taints assigned to nodes of this node pool.
               Structure is documented below.
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_configs is not None:
            pulumi.set(__self__, "node_configs", node_configs)
        if operating_system is not None:
            pulumi.set(__self__, "operating_system", operating_system)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="nodeConfigs")
    def node_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfigArgs']]]]:
        """
        The list of machine addresses in the Bare Metal Node Pool.
        Structure is documented below.
        """
        return pulumi.get(self, "node_configs")

    @node_configs.setter
    def node_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfigArgs']]]]):
        pulumi.set(self, "node_configs", value)

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the nodes operating system (default: LINUX).
        """
        return pulumi.get(self, "operating_system")

    @operating_system.setter
    def operating_system(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operating_system", value)

    @property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaintArgs']]]]:
        """
        The initial taints assigned to nodes of this node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaintArgs']]]]):
        pulumi.set(self, "taints", value)


@pulumi.input_type
class BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfigArgs:
    def __init__(__self__, *,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 node_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param pulumi.Input[str] node_ip: The default IPv4 address for SSH access and Kubernetes node.
               Example: 192.168.0.1
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_ip is not None:
            pulumi.set(__self__, "node_ip", node_ip)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The default IPv4 address for SSH access and Kubernetes node.
        Example: 192.168.0.1
        """
        return pulumi.get(self, "node_ip")

    @node_ip.setter
    def node_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_ip", value)


@pulumi.input_type
class BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effect: Specifies the nodes operating system (default: LINUX).
               Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        :param pulumi.Input[str] key: Key associated with the effect.
        :param pulumi.Input[str] value: Value associated with the effect.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the nodes operating system (default: LINUX).
        Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BareMetalAdminClusterFleetArgs:
    def __init__(__self__, *,
                 membership: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] membership: (Output)
               The name of the managed Hub Membership resource associated to this cluster.
               Membership names are formatted as
               `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        if membership is not None:
            pulumi.set(__self__, "membership", membership)

    @property
    @pulumi.getter
    def membership(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The name of the managed Hub Membership resource associated to this cluster.
        Membership names are formatted as
        `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        return pulumi.get(self, "membership")

    @membership.setter
    def membership(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "membership", value)


@pulumi.input_type
class BareMetalAdminClusterLoadBalancerArgs:
    def __init__(__self__, *,
                 port_config: pulumi.Input['BareMetalAdminClusterLoadBalancerPortConfigArgs'],
                 vip_config: pulumi.Input['BareMetalAdminClusterLoadBalancerVipConfigArgs'],
                 manual_lb_config: Optional[pulumi.Input['BareMetalAdminClusterLoadBalancerManualLbConfigArgs']] = None):
        """
        :param pulumi.Input['BareMetalAdminClusterLoadBalancerPortConfigArgs'] port_config: Specifies the load balancer ports.
               Structure is documented below.
        :param pulumi.Input['BareMetalAdminClusterLoadBalancerVipConfigArgs'] vip_config: Specified the Bare Metal Load Balancer Config
               Structure is documented below.
        :param pulumi.Input['BareMetalAdminClusterLoadBalancerManualLbConfigArgs'] manual_lb_config: A nested object resource
               Structure is documented below.
        """
        pulumi.set(__self__, "port_config", port_config)
        pulumi.set(__self__, "vip_config", vip_config)
        if manual_lb_config is not None:
            pulumi.set(__self__, "manual_lb_config", manual_lb_config)

    @property
    @pulumi.getter(name="portConfig")
    def port_config(self) -> pulumi.Input['BareMetalAdminClusterLoadBalancerPortConfigArgs']:
        """
        Specifies the load balancer ports.
        Structure is documented below.
        """
        return pulumi.get(self, "port_config")

    @port_config.setter
    def port_config(self, value: pulumi.Input['BareMetalAdminClusterLoadBalancerPortConfigArgs']):
        pulumi.set(self, "port_config", value)

    @property
    @pulumi.getter(name="vipConfig")
    def vip_config(self) -> pulumi.Input['BareMetalAdminClusterLoadBalancerVipConfigArgs']:
        """
        Specified the Bare Metal Load Balancer Config
        Structure is documented below.
        """
        return pulumi.get(self, "vip_config")

    @vip_config.setter
    def vip_config(self, value: pulumi.Input['BareMetalAdminClusterLoadBalancerVipConfigArgs']):
        pulumi.set(self, "vip_config", value)

    @property
    @pulumi.getter(name="manualLbConfig")
    def manual_lb_config(self) -> Optional[pulumi.Input['BareMetalAdminClusterLoadBalancerManualLbConfigArgs']]:
        """
        A nested object resource
        Structure is documented below.
        """
        return pulumi.get(self, "manual_lb_config")

    @manual_lb_config.setter
    def manual_lb_config(self, value: Optional[pulumi.Input['BareMetalAdminClusterLoadBalancerManualLbConfigArgs']]):
        pulumi.set(self, "manual_lb_config", value)


@pulumi.input_type
class BareMetalAdminClusterLoadBalancerManualLbConfigArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Whether manual load balancing is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether manual load balancing is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class BareMetalAdminClusterLoadBalancerPortConfigArgs:
    def __init__(__self__, *,
                 control_plane_load_balancer_port: pulumi.Input[int]):
        """
        :param pulumi.Input[int] control_plane_load_balancer_port: The port that control plane hosted load balancers will listen on.
        """
        pulumi.set(__self__, "control_plane_load_balancer_port", control_plane_load_balancer_port)

    @property
    @pulumi.getter(name="controlPlaneLoadBalancerPort")
    def control_plane_load_balancer_port(self) -> pulumi.Input[int]:
        """
        The port that control plane hosted load balancers will listen on.
        """
        return pulumi.get(self, "control_plane_load_balancer_port")

    @control_plane_load_balancer_port.setter
    def control_plane_load_balancer_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "control_plane_load_balancer_port", value)


@pulumi.input_type
class BareMetalAdminClusterLoadBalancerVipConfigArgs:
    def __init__(__self__, *,
                 control_plane_vip: pulumi.Input[str]):
        """
        :param pulumi.Input[str] control_plane_vip: The VIP which you previously set aside for the Kubernetes API of this Bare Metal Admin Cluster.
        """
        pulumi.set(__self__, "control_plane_vip", control_plane_vip)

    @property
    @pulumi.getter(name="controlPlaneVip")
    def control_plane_vip(self) -> pulumi.Input[str]:
        """
        The VIP which you previously set aside for the Kubernetes API of this Bare Metal Admin Cluster.
        """
        return pulumi.get(self, "control_plane_vip")

    @control_plane_vip.setter
    def control_plane_vip(self, value: pulumi.Input[str]):
        pulumi.set(self, "control_plane_vip", value)


@pulumi.input_type
class BareMetalAdminClusterMaintenanceConfigArgs:
    def __init__(__self__, *,
                 maintenance_address_cidr_blocks: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] maintenance_address_cidr_blocks: All IPv4 address from these ranges will be placed into maintenance mode.
               Nodes in maintenance mode will be cordoned and drained. When both of these
               are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set
               on the node resource.
        """
        pulumi.set(__self__, "maintenance_address_cidr_blocks", maintenance_address_cidr_blocks)

    @property
    @pulumi.getter(name="maintenanceAddressCidrBlocks")
    def maintenance_address_cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        All IPv4 address from these ranges will be placed into maintenance mode.
        Nodes in maintenance mode will be cordoned and drained. When both of these
        are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set
        on the node resource.
        """
        return pulumi.get(self, "maintenance_address_cidr_blocks")

    @maintenance_address_cidr_blocks.setter
    def maintenance_address_cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "maintenance_address_cidr_blocks", value)


@pulumi.input_type
class BareMetalAdminClusterNetworkConfigArgs:
    def __init__(__self__, *,
                 island_mode_cidr: Optional[pulumi.Input['BareMetalAdminClusterNetworkConfigIslandModeCidrArgs']] = None):
        """
        :param pulumi.Input['BareMetalAdminClusterNetworkConfigIslandModeCidrArgs'] island_mode_cidr: A nested object resource
               Structure is documented below.
        """
        if island_mode_cidr is not None:
            pulumi.set(__self__, "island_mode_cidr", island_mode_cidr)

    @property
    @pulumi.getter(name="islandModeCidr")
    def island_mode_cidr(self) -> Optional[pulumi.Input['BareMetalAdminClusterNetworkConfigIslandModeCidrArgs']]:
        """
        A nested object resource
        Structure is documented below.
        """
        return pulumi.get(self, "island_mode_cidr")

    @island_mode_cidr.setter
    def island_mode_cidr(self, value: Optional[pulumi.Input['BareMetalAdminClusterNetworkConfigIslandModeCidrArgs']]):
        pulumi.set(self, "island_mode_cidr", value)


@pulumi.input_type
class BareMetalAdminClusterNetworkConfigIslandModeCidrArgs:
    def __init__(__self__, *,
                 pod_address_cidr_blocks: pulumi.Input[Sequence[pulumi.Input[str]]],
                 service_address_cidr_blocks: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pod_address_cidr_blocks: All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_address_cidr_blocks: All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        pulumi.set(__self__, "pod_address_cidr_blocks", pod_address_cidr_blocks)
        pulumi.set(__self__, "service_address_cidr_blocks", service_address_cidr_blocks)

    @property
    @pulumi.getter(name="podAddressCidrBlocks")
    def pod_address_cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        return pulumi.get(self, "pod_address_cidr_blocks")

    @pod_address_cidr_blocks.setter
    def pod_address_cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "pod_address_cidr_blocks", value)

    @property
    @pulumi.getter(name="serviceAddressCidrBlocks")
    def service_address_cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        return pulumi.get(self, "service_address_cidr_blocks")

    @service_address_cidr_blocks.setter
    def service_address_cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "service_address_cidr_blocks", value)


@pulumi.input_type
class BareMetalAdminClusterNodeAccessConfigArgs:
    def __init__(__self__, *,
                 login_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] login_user: LoginUser is the user name used to access node machines.
               It defaults to "root" if not set.
        """
        if login_user is not None:
            pulumi.set(__self__, "login_user", login_user)

    @property
    @pulumi.getter(name="loginUser")
    def login_user(self) -> Optional[pulumi.Input[str]]:
        """
        LoginUser is the user name used to access node machines.
        It defaults to "root" if not set.
        """
        return pulumi.get(self, "login_user")

    @login_user.setter
    def login_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_user", value)


@pulumi.input_type
class BareMetalAdminClusterNodeConfigArgs:
    def __init__(__self__, *,
                 max_pods_per_node: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] max_pods_per_node: The maximum number of pods a node can run. The size of the CIDR range
               assigned to the node will be derived from this parameter.
        """
        if max_pods_per_node is not None:
            pulumi.set(__self__, "max_pods_per_node", max_pods_per_node)

    @property
    @pulumi.getter(name="maxPodsPerNode")
    def max_pods_per_node(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of pods a node can run. The size of the CIDR range
        assigned to the node will be derived from this parameter.
        """
        return pulumi.get(self, "max_pods_per_node")

    @max_pods_per_node.setter
    def max_pods_per_node(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_pods_per_node", value)


@pulumi.input_type
class BareMetalAdminClusterProxyArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 no_proxies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] uri: Specifies the address of your proxy server.
               Examples: http://domain
               WARNING: Do not provide credentials in the format
               http://(username:password@)domain these will be rejected by the server.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] no_proxies: A list of IPs, hostnames, and domains that should skip the proxy.
               Examples: ["127.0.0.1", "example.com", ".corp", "localhost"].
        """
        pulumi.set(__self__, "uri", uri)
        if no_proxies is not None:
            pulumi.set(__self__, "no_proxies", no_proxies)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        Specifies the address of your proxy server.
        Examples: http://domain
        WARNING: Do not provide credentials in the format
        http://(username:password@)domain these will be rejected by the server.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="noProxies")
    def no_proxies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IPs, hostnames, and domains that should skip the proxy.
        Examples: ["127.0.0.1", "example.com", ".corp", "localhost"].
        """
        return pulumi.get(self, "no_proxies")

    @no_proxies.setter
    def no_proxies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "no_proxies", value)


@pulumi.input_type
class BareMetalAdminClusterSecurityConfigArgs:
    def __init__(__self__, *,
                 authorization: Optional[pulumi.Input['BareMetalAdminClusterSecurityConfigAuthorizationArgs']] = None):
        """
        :param pulumi.Input['BareMetalAdminClusterSecurityConfigAuthorizationArgs'] authorization: Configures user access to the Bare Metal User cluster.
               Structure is documented below.
        """
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input['BareMetalAdminClusterSecurityConfigAuthorizationArgs']]:
        """
        Configures user access to the Bare Metal User cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input['BareMetalAdminClusterSecurityConfigAuthorizationArgs']]):
        pulumi.set(self, "authorization", value)


@pulumi.input_type
class BareMetalAdminClusterSecurityConfigAuthorizationArgs:
    def __init__(__self__, *,
                 admin_users: pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterSecurityConfigAuthorizationAdminUserArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterSecurityConfigAuthorizationAdminUserArgs']]] admin_users: Users that will be granted the cluster-admin role on the cluster, providing full access to the cluster.
               Structure is documented below.
        """
        pulumi.set(__self__, "admin_users", admin_users)

    @property
    @pulumi.getter(name="adminUsers")
    def admin_users(self) -> pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterSecurityConfigAuthorizationAdminUserArgs']]]:
        """
        Users that will be granted the cluster-admin role on the cluster, providing full access to the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "admin_users")

    @admin_users.setter
    def admin_users(self, value: pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterSecurityConfigAuthorizationAdminUserArgs']]]):
        pulumi.set(self, "admin_users", value)


@pulumi.input_type
class BareMetalAdminClusterSecurityConfigAuthorizationAdminUserArgs:
    def __init__(__self__, *,
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] username: The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class BareMetalAdminClusterStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterStatusConditionArgs']]]] = None,
                 error_message: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterStatusConditionArgs']]] conditions: (Output)
               ResourceConditions provide a standard mechanism for higher-level status reporting from admin cluster controller.
               Structure is documented below.
        :param pulumi.Input[str] error_message: (Output)
               Human-friendly representation of the error message from the admin cluster
               controller. The error message can be temporary as the admin cluster
               controller creates a cluster or node pool. If the error message persists
               for a longer period of time, it can be used to surface error message to
               indicate real problems requiring user intervention.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterStatusConditionArgs']]]]:
        """
        (Output)
        ResourceConditions provide a standard mechanism for higher-level status reporting from admin cluster controller.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterStatusConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Human-friendly representation of the error message from the admin cluster
        controller. The error message can be temporary as the admin cluster
        controller creates a cluster or node pool. If the error message persists
        for a longer period of time, it can be used to surface error message to
        indicate real problems requiring user intervention.
        """
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_message", value)


@pulumi.input_type
class BareMetalAdminClusterStatusConditionArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] last_transition_time: (Output)
               Last time the condition transit from one status to another.
        :param pulumi.Input[str] message: Human-readable message indicating details about last transition.
        :param pulumi.Input[str] reason: (Output)
               A human-readable message of the check failure.
        :param pulumi.Input[str] state: (Output)
               The lifecycle state of the condition.
        :param pulumi.Input[str] type: Type of the condition.
               (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Human-readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        A human-readable message of the check failure.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The lifecycle state of the condition.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the condition.
        (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class BareMetalAdminClusterStorageArgs:
    def __init__(__self__, *,
                 lvp_node_mounts_config: pulumi.Input['BareMetalAdminClusterStorageLvpNodeMountsConfigArgs'],
                 lvp_share_config: pulumi.Input['BareMetalAdminClusterStorageLvpShareConfigArgs']):
        """
        :param pulumi.Input['BareMetalAdminClusterStorageLvpNodeMountsConfigArgs'] lvp_node_mounts_config: Specifies the config for local PersistentVolumes backed
               by mounted node disks. These disks need to be formatted and mounted by the
               user, which can be done before or after cluster creation.
               Structure is documented below.
        :param pulumi.Input['BareMetalAdminClusterStorageLvpShareConfigArgs'] lvp_share_config: Specifies the config for local PersistentVolumes backed by
               subdirectories in a shared filesystem. These subdirectores are
               automatically created during cluster creation.
               Structure is documented below.
        """
        pulumi.set(__self__, "lvp_node_mounts_config", lvp_node_mounts_config)
        pulumi.set(__self__, "lvp_share_config", lvp_share_config)

    @property
    @pulumi.getter(name="lvpNodeMountsConfig")
    def lvp_node_mounts_config(self) -> pulumi.Input['BareMetalAdminClusterStorageLvpNodeMountsConfigArgs']:
        """
        Specifies the config for local PersistentVolumes backed
        by mounted node disks. These disks need to be formatted and mounted by the
        user, which can be done before or after cluster creation.
        Structure is documented below.
        """
        return pulumi.get(self, "lvp_node_mounts_config")

    @lvp_node_mounts_config.setter
    def lvp_node_mounts_config(self, value: pulumi.Input['BareMetalAdminClusterStorageLvpNodeMountsConfigArgs']):
        pulumi.set(self, "lvp_node_mounts_config", value)

    @property
    @pulumi.getter(name="lvpShareConfig")
    def lvp_share_config(self) -> pulumi.Input['BareMetalAdminClusterStorageLvpShareConfigArgs']:
        """
        Specifies the config for local PersistentVolumes backed by
        subdirectories in a shared filesystem. These subdirectores are
        automatically created during cluster creation.
        Structure is documented below.
        """
        return pulumi.get(self, "lvp_share_config")

    @lvp_share_config.setter
    def lvp_share_config(self, value: pulumi.Input['BareMetalAdminClusterStorageLvpShareConfigArgs']):
        pulumi.set(self, "lvp_share_config", value)


@pulumi.input_type
class BareMetalAdminClusterStorageLvpNodeMountsConfigArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 storage_class: pulumi.Input[str]):
        """
        :param pulumi.Input[str] path: The host machine path.
        :param pulumi.Input[str] storage_class: The StorageClass name that PVs will be created with.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The host machine path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[str]:
        """
        The StorageClass name that PVs will be created with.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_class", value)


@pulumi.input_type
class BareMetalAdminClusterStorageLvpShareConfigArgs:
    def __init__(__self__, *,
                 lvp_config: pulumi.Input['BareMetalAdminClusterStorageLvpShareConfigLvpConfigArgs'],
                 shared_path_pv_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['BareMetalAdminClusterStorageLvpShareConfigLvpConfigArgs'] lvp_config: Defines the machine path and storage class for the LVP Share.
               Structure is documented below.
        :param pulumi.Input[int] shared_path_pv_count: The number of subdirectories to create under path.
        """
        pulumi.set(__self__, "lvp_config", lvp_config)
        if shared_path_pv_count is not None:
            pulumi.set(__self__, "shared_path_pv_count", shared_path_pv_count)

    @property
    @pulumi.getter(name="lvpConfig")
    def lvp_config(self) -> pulumi.Input['BareMetalAdminClusterStorageLvpShareConfigLvpConfigArgs']:
        """
        Defines the machine path and storage class for the LVP Share.
        Structure is documented below.
        """
        return pulumi.get(self, "lvp_config")

    @lvp_config.setter
    def lvp_config(self, value: pulumi.Input['BareMetalAdminClusterStorageLvpShareConfigLvpConfigArgs']):
        pulumi.set(self, "lvp_config", value)

    @property
    @pulumi.getter(name="sharedPathPvCount")
    def shared_path_pv_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of subdirectories to create under path.
        """
        return pulumi.get(self, "shared_path_pv_count")

    @shared_path_pv_count.setter
    def shared_path_pv_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "shared_path_pv_count", value)


@pulumi.input_type
class BareMetalAdminClusterStorageLvpShareConfigLvpConfigArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 storage_class: pulumi.Input[str]):
        """
        :param pulumi.Input[str] path: The host machine path.
        :param pulumi.Input[str] storage_class: The StorageClass name that PVs will be created with.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The host machine path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[str]:
        """
        The StorageClass name that PVs will be created with.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_class", value)


@pulumi.input_type
class BareMetalAdminClusterValidationCheckArgs:
    def __init__(__self__, *,
                 options: Optional[pulumi.Input[str]] = None,
                 scenario: Optional[pulumi.Input[str]] = None,
                 statuses: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterValidationCheckStatusArgs']]]] = None):
        """
        :param pulumi.Input[str] options: (Output)
               Options used for the validation check.
        :param pulumi.Input[str] scenario: (Output)
               The scenario when the preflight checks were run..
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterValidationCheckStatusArgs']]] statuses: (Output)
               Specifies the detailed validation check status
               Structure is documented below.
        """
        if options is not None:
            pulumi.set(__self__, "options", options)
        if scenario is not None:
            pulumi.set(__self__, "scenario", scenario)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Options used for the validation check.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def scenario(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The scenario when the preflight checks were run..
        """
        return pulumi.get(self, "scenario")

    @scenario.setter
    def scenario(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scenario", value)

    @property
    @pulumi.getter
    def statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterValidationCheckStatusArgs']]]]:
        """
        (Output)
        Specifies the detailed validation check status
        Structure is documented below.
        """
        return pulumi.get(self, "statuses")

    @statuses.setter
    def statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterValidationCheckStatusArgs']]]]):
        pulumi.set(self, "statuses", value)


@pulumi.input_type
class BareMetalAdminClusterValidationCheckStatusArgs:
    def __init__(__self__, *,
                 results: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterValidationCheckStatusResultArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterValidationCheckStatusResultArgs']]] results: (Output)
               Individual checks which failed as part of the Preflight check execution.
               Structure is documented below.
        """
        if results is not None:
            pulumi.set(__self__, "results", results)

    @property
    @pulumi.getter
    def results(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterValidationCheckStatusResultArgs']]]]:
        """
        (Output)
        Individual checks which failed as part of the Preflight check execution.
        Structure is documented below.
        """
        return pulumi.get(self, "results")

    @results.setter
    def results(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalAdminClusterValidationCheckStatusResultArgs']]]]):
        pulumi.set(self, "results", value)


@pulumi.input_type
class BareMetalAdminClusterValidationCheckStatusResultArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 details: Optional[pulumi.Input[str]] = None,
                 options: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] category: (Output)
               The category of the validation.
        :param pulumi.Input[str] description: A human readable description of this Bare Metal Admin Cluster.
        :param pulumi.Input[str] details: (Output)
               Detailed failure information, which might be unformatted.
        :param pulumi.Input[str] options: (Output)
               Options used for the validation check.
        :param pulumi.Input[str] reason: (Output)
               A human-readable message of the check failure.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The category of the validation.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A human readable description of this Bare Metal Admin Cluster.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Detailed failure information, which might be unformatted.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Options used for the validation check.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        A human-readable message of the check failure.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


@pulumi.input_type
class BareMetalClusterBinaryAuthorizationArgs:
    def __init__(__self__, *,
                 evaluation_mode: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] evaluation_mode: Mode of operation for binauthz policy evaluation. If unspecified,
               defaults to DISABLED.
               Possible values are: `DISABLED`, `PROJECT_SINGLETON_POLICY_ENFORCE`.
        """
        if evaluation_mode is not None:
            pulumi.set(__self__, "evaluation_mode", evaluation_mode)

    @property
    @pulumi.getter(name="evaluationMode")
    def evaluation_mode(self) -> Optional[pulumi.Input[str]]:
        """
        Mode of operation for binauthz policy evaluation. If unspecified,
        defaults to DISABLED.
        Possible values are: `DISABLED`, `PROJECT_SINGLETON_POLICY_ENFORCE`.
        """
        return pulumi.get(self, "evaluation_mode")

    @evaluation_mode.setter
    def evaluation_mode(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "evaluation_mode", value)


@pulumi.input_type
class BareMetalClusterClusterOperationsArgs:
    def __init__(__self__, *,
                 enable_application_logs: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enable_application_logs: Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        if enable_application_logs is not None:
            pulumi.set(__self__, "enable_application_logs", enable_application_logs)

    @property
    @pulumi.getter(name="enableApplicationLogs")
    def enable_application_logs(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        return pulumi.get(self, "enable_application_logs")

    @enable_application_logs.setter
    def enable_application_logs(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_application_logs", value)


@pulumi.input_type
class BareMetalClusterControlPlaneArgs:
    def __init__(__self__, *,
                 control_plane_node_pool_config: pulumi.Input['BareMetalClusterControlPlaneControlPlaneNodePoolConfigArgs'],
                 api_server_args: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterControlPlaneApiServerArgArgs']]]] = None):
        """
        :param pulumi.Input['BareMetalClusterControlPlaneControlPlaneNodePoolConfigArgs'] control_plane_node_pool_config: Configures the node pool running the control plane. If specified the corresponding NodePool will be created for the cluster's control plane. The NodePool will have the same name and namespace as the cluster.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalClusterControlPlaneApiServerArgArgs']]] api_server_args: Customizes the default API server args. Only a subset of
               customized flags are supported. Please refer to the API server
               documentation below to know the exact format:
               https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
               Structure is documented below.
        """
        pulumi.set(__self__, "control_plane_node_pool_config", control_plane_node_pool_config)
        if api_server_args is not None:
            pulumi.set(__self__, "api_server_args", api_server_args)

    @property
    @pulumi.getter(name="controlPlaneNodePoolConfig")
    def control_plane_node_pool_config(self) -> pulumi.Input['BareMetalClusterControlPlaneControlPlaneNodePoolConfigArgs']:
        """
        Configures the node pool running the control plane. If specified the corresponding NodePool will be created for the cluster's control plane. The NodePool will have the same name and namespace as the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "control_plane_node_pool_config")

    @control_plane_node_pool_config.setter
    def control_plane_node_pool_config(self, value: pulumi.Input['BareMetalClusterControlPlaneControlPlaneNodePoolConfigArgs']):
        pulumi.set(self, "control_plane_node_pool_config", value)

    @property
    @pulumi.getter(name="apiServerArgs")
    def api_server_args(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterControlPlaneApiServerArgArgs']]]]:
        """
        Customizes the default API server args. Only a subset of
        customized flags are supported. Please refer to the API server
        documentation below to know the exact format:
        https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
        Structure is documented below.
        """
        return pulumi.get(self, "api_server_args")

    @api_server_args.setter
    def api_server_args(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterControlPlaneApiServerArgArgs']]]]):
        pulumi.set(self, "api_server_args", value)


@pulumi.input_type
class BareMetalClusterControlPlaneApiServerArgArgs:
    def __init__(__self__, *,
                 argument: pulumi.Input[str],
                 value: pulumi.Input[str]):
        """
        :param pulumi.Input[str] argument: The argument name as it appears on the API Server command line please make sure to remove the leading dashes.
        :param pulumi.Input[str] value: The value of the arg as it will be passed to the API Server command line.
        """
        pulumi.set(__self__, "argument", argument)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def argument(self) -> pulumi.Input[str]:
        """
        The argument name as it appears on the API Server command line please make sure to remove the leading dashes.
        """
        return pulumi.get(self, "argument")

    @argument.setter
    def argument(self, value: pulumi.Input[str]):
        pulumi.set(self, "argument", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        The value of the arg as it will be passed to the API Server command line.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BareMetalClusterControlPlaneControlPlaneNodePoolConfigArgs:
    def __init__(__self__, *,
                 node_pool_config: pulumi.Input['BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigArgs']):
        """
        :param pulumi.Input['BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigArgs'] node_pool_config: The generic configuration for a node pool running the control plane.
               Structure is documented below.
        """
        pulumi.set(__self__, "node_pool_config", node_pool_config)

    @property
    @pulumi.getter(name="nodePoolConfig")
    def node_pool_config(self) -> pulumi.Input['BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigArgs']:
        """
        The generic configuration for a node pool running the control plane.
        Structure is documented below.
        """
        return pulumi.get(self, "node_pool_config")

    @node_pool_config.setter
    def node_pool_config(self, value: pulumi.Input['BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigArgs']):
        pulumi.set(self, "node_pool_config", value)


@pulumi.input_type
class BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigArgs:
    def __init__(__self__, *,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 node_configs: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfigArgs']]]] = None,
                 operating_system: Optional[pulumi.Input[str]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaintArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfigArgs']]] node_configs: The list of machine addresses in the Bare Metal Node Pool.
               Structure is documented below.
        :param pulumi.Input[str] operating_system: Specifies the nodes operating system (default: LINUX).
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaintArgs']]] taints: The initial taints assigned to nodes of this node pool.
               Structure is documented below.
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_configs is not None:
            pulumi.set(__self__, "node_configs", node_configs)
        if operating_system is not None:
            pulumi.set(__self__, "operating_system", operating_system)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="nodeConfigs")
    def node_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfigArgs']]]]:
        """
        The list of machine addresses in the Bare Metal Node Pool.
        Structure is documented below.
        """
        return pulumi.get(self, "node_configs")

    @node_configs.setter
    def node_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfigArgs']]]]):
        pulumi.set(self, "node_configs", value)

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the nodes operating system (default: LINUX).
        """
        return pulumi.get(self, "operating_system")

    @operating_system.setter
    def operating_system(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operating_system", value)

    @property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaintArgs']]]]:
        """
        The initial taints assigned to nodes of this node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaintArgs']]]]):
        pulumi.set(self, "taints", value)


@pulumi.input_type
class BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfigArgs:
    def __init__(__self__, *,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 node_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param pulumi.Input[str] node_ip: The default IPv4 address for SSH access and Kubernetes node.
               Example: 192.168.0.1
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_ip is not None:
            pulumi.set(__self__, "node_ip", node_ip)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The default IPv4 address for SSH access and Kubernetes node.
        Example: 192.168.0.1
        """
        return pulumi.get(self, "node_ip")

    @node_ip.setter
    def node_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_ip", value)


@pulumi.input_type
class BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effect: Specifies the nodes operating system (default: LINUX).
               Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        :param pulumi.Input[str] key: Key associated with the effect.
        :param pulumi.Input[str] value: Value associated with the effect.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the nodes operating system (default: LINUX).
        Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BareMetalClusterFleetArgs:
    def __init__(__self__, *,
                 membership: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] membership: (Output)
               The name of the managed Hub Membership resource associated to this cluster.
               Membership names are formatted as
               `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        if membership is not None:
            pulumi.set(__self__, "membership", membership)

    @property
    @pulumi.getter
    def membership(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The name of the managed Hub Membership resource associated to this cluster.
        Membership names are formatted as
        `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        return pulumi.get(self, "membership")

    @membership.setter
    def membership(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "membership", value)


@pulumi.input_type
class BareMetalClusterLoadBalancerArgs:
    def __init__(__self__, *,
                 port_config: pulumi.Input['BareMetalClusterLoadBalancerPortConfigArgs'],
                 vip_config: pulumi.Input['BareMetalClusterLoadBalancerVipConfigArgs'],
                 bgp_lb_config: Optional[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigArgs']] = None,
                 manual_lb_config: Optional[pulumi.Input['BareMetalClusterLoadBalancerManualLbConfigArgs']] = None,
                 metal_lb_config: Optional[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigArgs']] = None):
        """
        :param pulumi.Input['BareMetalClusterLoadBalancerPortConfigArgs'] port_config: Specifies the load balancer ports.
               Structure is documented below.
        :param pulumi.Input['BareMetalClusterLoadBalancerVipConfigArgs'] vip_config: Specified the Bare Metal Load Balancer Config
               Structure is documented below.
        :param pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigArgs'] bgp_lb_config: Configuration for BGP typed load balancers.
               Structure is documented below.
        :param pulumi.Input['BareMetalClusterLoadBalancerManualLbConfigArgs'] manual_lb_config: A nested object resource
               Structure is documented below.
        :param pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigArgs'] metal_lb_config: A nested object resource
               Structure is documented below.
        """
        pulumi.set(__self__, "port_config", port_config)
        pulumi.set(__self__, "vip_config", vip_config)
        if bgp_lb_config is not None:
            pulumi.set(__self__, "bgp_lb_config", bgp_lb_config)
        if manual_lb_config is not None:
            pulumi.set(__self__, "manual_lb_config", manual_lb_config)
        if metal_lb_config is not None:
            pulumi.set(__self__, "metal_lb_config", metal_lb_config)

    @property
    @pulumi.getter(name="portConfig")
    def port_config(self) -> pulumi.Input['BareMetalClusterLoadBalancerPortConfigArgs']:
        """
        Specifies the load balancer ports.
        Structure is documented below.
        """
        return pulumi.get(self, "port_config")

    @port_config.setter
    def port_config(self, value: pulumi.Input['BareMetalClusterLoadBalancerPortConfigArgs']):
        pulumi.set(self, "port_config", value)

    @property
    @pulumi.getter(name="vipConfig")
    def vip_config(self) -> pulumi.Input['BareMetalClusterLoadBalancerVipConfigArgs']:
        """
        Specified the Bare Metal Load Balancer Config
        Structure is documented below.
        """
        return pulumi.get(self, "vip_config")

    @vip_config.setter
    def vip_config(self, value: pulumi.Input['BareMetalClusterLoadBalancerVipConfigArgs']):
        pulumi.set(self, "vip_config", value)

    @property
    @pulumi.getter(name="bgpLbConfig")
    def bgp_lb_config(self) -> Optional[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigArgs']]:
        """
        Configuration for BGP typed load balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "bgp_lb_config")

    @bgp_lb_config.setter
    def bgp_lb_config(self, value: Optional[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigArgs']]):
        pulumi.set(self, "bgp_lb_config", value)

    @property
    @pulumi.getter(name="manualLbConfig")
    def manual_lb_config(self) -> Optional[pulumi.Input['BareMetalClusterLoadBalancerManualLbConfigArgs']]:
        """
        A nested object resource
        Structure is documented below.
        """
        return pulumi.get(self, "manual_lb_config")

    @manual_lb_config.setter
    def manual_lb_config(self, value: Optional[pulumi.Input['BareMetalClusterLoadBalancerManualLbConfigArgs']]):
        pulumi.set(self, "manual_lb_config", value)

    @property
    @pulumi.getter(name="metalLbConfig")
    def metal_lb_config(self) -> Optional[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigArgs']]:
        """
        A nested object resource
        Structure is documented below.
        """
        return pulumi.get(self, "metal_lb_config")

    @metal_lb_config.setter
    def metal_lb_config(self, value: Optional[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigArgs']]):
        pulumi.set(self, "metal_lb_config", value)


@pulumi.input_type
class BareMetalClusterLoadBalancerBgpLbConfigArgs:
    def __init__(__self__, *,
                 address_pools: pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigAddressPoolArgs']]],
                 asn: pulumi.Input[int],
                 bgp_peer_configs: pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfigArgs']]],
                 load_balancer_node_pool_config: Optional[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigAddressPoolArgs']]] address_pools: AddressPools is a list of non-overlapping IP pools used by load balancer
               typed services. All addresses must be routable to load balancer nodes.
               IngressVIP must be included in the pools.
               Structure is documented below.
        :param pulumi.Input[int] asn: BGP autonomous system number (ASN) of the cluster.
               This field can be updated after cluster creation.
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfigArgs']]] bgp_peer_configs: The list of BGP peers that the cluster will connect to.
               At least one peer must be configured for each control plane node.
               Control plane nodes will connect to these peers to advertise the control
               plane VIP. The Services load balancer also uses these peers by default.
               This field can be updated after cluster creation.
               Structure is documented below.
        :param pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigArgs'] load_balancer_node_pool_config: Specifies the node pool running data plane load balancing. L2 connectivity
               is required among nodes in this pool. If missing, the control plane node
               pool is used for data plane load balancing.
               Structure is documented below.
        """
        pulumi.set(__self__, "address_pools", address_pools)
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "bgp_peer_configs", bgp_peer_configs)
        if load_balancer_node_pool_config is not None:
            pulumi.set(__self__, "load_balancer_node_pool_config", load_balancer_node_pool_config)

    @property
    @pulumi.getter(name="addressPools")
    def address_pools(self) -> pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigAddressPoolArgs']]]:
        """
        AddressPools is a list of non-overlapping IP pools used by load balancer
        typed services. All addresses must be routable to load balancer nodes.
        IngressVIP must be included in the pools.
        Structure is documented below.
        """
        return pulumi.get(self, "address_pools")

    @address_pools.setter
    def address_pools(self, value: pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigAddressPoolArgs']]]):
        pulumi.set(self, "address_pools", value)

    @property
    @pulumi.getter
    def asn(self) -> pulumi.Input[int]:
        """
        BGP autonomous system number (ASN) of the cluster.
        This field can be updated after cluster creation.
        """
        return pulumi.get(self, "asn")

    @asn.setter
    def asn(self, value: pulumi.Input[int]):
        pulumi.set(self, "asn", value)

    @property
    @pulumi.getter(name="bgpPeerConfigs")
    def bgp_peer_configs(self) -> pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfigArgs']]]:
        """
        The list of BGP peers that the cluster will connect to.
        At least one peer must be configured for each control plane node.
        Control plane nodes will connect to these peers to advertise the control
        plane VIP. The Services load balancer also uses these peers by default.
        This field can be updated after cluster creation.
        Structure is documented below.
        """
        return pulumi.get(self, "bgp_peer_configs")

    @bgp_peer_configs.setter
    def bgp_peer_configs(self, value: pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfigArgs']]]):
        pulumi.set(self, "bgp_peer_configs", value)

    @property
    @pulumi.getter(name="loadBalancerNodePoolConfig")
    def load_balancer_node_pool_config(self) -> Optional[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigArgs']]:
        """
        Specifies the node pool running data plane load balancing. L2 connectivity
        is required among nodes in this pool. If missing, the control plane node
        pool is used for data plane load balancing.
        Structure is documented below.
        """
        return pulumi.get(self, "load_balancer_node_pool_config")

    @load_balancer_node_pool_config.setter
    def load_balancer_node_pool_config(self, value: Optional[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigArgs']]):
        pulumi.set(self, "load_balancer_node_pool_config", value)


@pulumi.input_type
class BareMetalClusterLoadBalancerBgpLbConfigAddressPoolArgs:
    def __init__(__self__, *,
                 addresses: pulumi.Input[Sequence[pulumi.Input[str]]],
                 pool: pulumi.Input[str],
                 avoid_buggy_ips: Optional[pulumi.Input[bool]] = None,
                 manual_assign: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] addresses: The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        :param pulumi.Input[str] pool: The name of the address pool.
        :param pulumi.Input[bool] avoid_buggy_ips: If true, avoid using IPs ending in .0 or .255.
               This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        :param pulumi.Input[str] manual_assign: If true, prevent IP addresses from being automatically assigned.
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "pool", pool)
        if avoid_buggy_ips is not None:
            pulumi.set(__self__, "avoid_buggy_ips", avoid_buggy_ips)
        if manual_assign is not None:
            pulumi.set(__self__, "manual_assign", manual_assign)

    @property
    @pulumi.getter
    def addresses(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter
    def pool(self) -> pulumi.Input[str]:
        """
        The name of the address pool.
        """
        return pulumi.get(self, "pool")

    @pool.setter
    def pool(self, value: pulumi.Input[str]):
        pulumi.set(self, "pool", value)

    @property
    @pulumi.getter(name="avoidBuggyIps")
    def avoid_buggy_ips(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, avoid using IPs ending in .0 or .255.
        This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        """
        return pulumi.get(self, "avoid_buggy_ips")

    @avoid_buggy_ips.setter
    def avoid_buggy_ips(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "avoid_buggy_ips", value)

    @property
    @pulumi.getter(name="manualAssign")
    def manual_assign(self) -> Optional[pulumi.Input[str]]:
        """
        If true, prevent IP addresses from being automatically assigned.
        """
        return pulumi.get(self, "manual_assign")

    @manual_assign.setter
    def manual_assign(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "manual_assign", value)


@pulumi.input_type
class BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfigArgs:
    def __init__(__self__, *,
                 asn: pulumi.Input[int],
                 ip_address: pulumi.Input[str],
                 control_plane_nodes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[int] asn: BGP autonomous system number (ASN) for the network that contains the
               external peer device.
        :param pulumi.Input[str] ip_address: The IP address of the external peer device.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] control_plane_nodes: The IP address of the control plane node that connects to the external
               peer.
               If you don't specify any control plane nodes, all control plane nodes
               can connect to the external peer. If you specify one or more IP addresses,
               only the nodes specified participate in peering sessions.
        """
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "ip_address", ip_address)
        if control_plane_nodes is not None:
            pulumi.set(__self__, "control_plane_nodes", control_plane_nodes)

    @property
    @pulumi.getter
    def asn(self) -> pulumi.Input[int]:
        """
        BGP autonomous system number (ASN) for the network that contains the
        external peer device.
        """
        return pulumi.get(self, "asn")

    @asn.setter
    def asn(self, value: pulumi.Input[int]):
        pulumi.set(self, "asn", value)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> pulumi.Input[str]:
        """
        The IP address of the external peer device.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="controlPlaneNodes")
    def control_plane_nodes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The IP address of the control plane node that connects to the external
        peer.
        If you don't specify any control plane nodes, all control plane nodes
        can connect to the external peer. If you specify one or more IP addresses,
        only the nodes specified participate in peering sessions.
        """
        return pulumi.get(self, "control_plane_nodes")

    @control_plane_nodes.setter
    def control_plane_nodes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "control_plane_nodes", value)


@pulumi.input_type
class BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigArgs:
    def __init__(__self__, *,
                 node_pool_config: Optional[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigArgs']] = None):
        """
        :param pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigArgs'] node_pool_config: The generic configuration for a node pool running a load balancer.
               Structure is documented below.
        """
        if node_pool_config is not None:
            pulumi.set(__self__, "node_pool_config", node_pool_config)

    @property
    @pulumi.getter(name="nodePoolConfig")
    def node_pool_config(self) -> Optional[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigArgs']]:
        """
        The generic configuration for a node pool running a load balancer.
        Structure is documented below.
        """
        return pulumi.get(self, "node_pool_config")

    @node_pool_config.setter
    def node_pool_config(self, value: Optional[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigArgs']]):
        pulumi.set(self, "node_pool_config", value)


@pulumi.input_type
class BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigArgs:
    def __init__(__self__, *,
                 kubelet_config: Optional[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfigArgs']] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 node_configs: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfigArgs']]]] = None,
                 operating_system: Optional[pulumi.Input[str]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaintArgs']]]] = None):
        """
        :param pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfigArgs'] kubelet_config: The modifiable kubelet configurations for the baremetal machines.
               Structure is documented below.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfigArgs']]] node_configs: The list of machine addresses in the Bare Metal Node Pool.
               Structure is documented below.
        :param pulumi.Input[str] operating_system: Specifies the nodes operating system (default: LINUX).
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaintArgs']]] taints: The initial taints assigned to nodes of this node pool.
               Structure is documented below.
        """
        if kubelet_config is not None:
            pulumi.set(__self__, "kubelet_config", kubelet_config)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_configs is not None:
            pulumi.set(__self__, "node_configs", node_configs)
        if operating_system is not None:
            pulumi.set(__self__, "operating_system", operating_system)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter(name="kubeletConfig")
    def kubelet_config(self) -> Optional[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfigArgs']]:
        """
        The modifiable kubelet configurations for the baremetal machines.
        Structure is documented below.
        """
        return pulumi.get(self, "kubelet_config")

    @kubelet_config.setter
    def kubelet_config(self, value: Optional[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfigArgs']]):
        pulumi.set(self, "kubelet_config", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="nodeConfigs")
    def node_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfigArgs']]]]:
        """
        The list of machine addresses in the Bare Metal Node Pool.
        Structure is documented below.
        """
        return pulumi.get(self, "node_configs")

    @node_configs.setter
    def node_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfigArgs']]]]):
        pulumi.set(self, "node_configs", value)

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the nodes operating system (default: LINUX).
        """
        return pulumi.get(self, "operating_system")

    @operating_system.setter
    def operating_system(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operating_system", value)

    @property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaintArgs']]]]:
        """
        The initial taints assigned to nodes of this node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaintArgs']]]]):
        pulumi.set(self, "taints", value)


@pulumi.input_type
class BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfigArgs:
    def __init__(__self__, *,
                 registry_burst: Optional[pulumi.Input[int]] = None,
                 registry_pull_qps: Optional[pulumi.Input[int]] = None,
                 serialize_image_pulls_disabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] registry_burst: The maximum size of bursty pulls, temporarily allows pulls to burst to this
               number, while still not exceeding registry_pull_qps.
               The value must not be a negative number.
               Updating this field may impact scalability by changing the amount of
               traffic produced by image pulls.
               Defaults to 10.
        :param pulumi.Input[int] registry_pull_qps: The limit of registry pulls per second.
               Setting this value to 0 means no limit.
               Updating this field may impact scalability by changing the amount of
               traffic produced by image pulls.
               Defaults to 5.
        :param pulumi.Input[bool] serialize_image_pulls_disabled: Prevents the Kubelet from pulling multiple images at a time.
               We recommend *not* changing the default value on nodes that run docker
               daemon with version  < 1.9 or an Another Union File System (Aufs) storage
               backend. Issue https://github.com/kubernetes/kubernetes/issues/10959 has
               more details.
        """
        if registry_burst is not None:
            pulumi.set(__self__, "registry_burst", registry_burst)
        if registry_pull_qps is not None:
            pulumi.set(__self__, "registry_pull_qps", registry_pull_qps)
        if serialize_image_pulls_disabled is not None:
            pulumi.set(__self__, "serialize_image_pulls_disabled", serialize_image_pulls_disabled)

    @property
    @pulumi.getter(name="registryBurst")
    def registry_burst(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum size of bursty pulls, temporarily allows pulls to burst to this
        number, while still not exceeding registry_pull_qps.
        The value must not be a negative number.
        Updating this field may impact scalability by changing the amount of
        traffic produced by image pulls.
        Defaults to 10.
        """
        return pulumi.get(self, "registry_burst")

    @registry_burst.setter
    def registry_burst(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "registry_burst", value)

    @property
    @pulumi.getter(name="registryPullQps")
    def registry_pull_qps(self) -> Optional[pulumi.Input[int]]:
        """
        The limit of registry pulls per second.
        Setting this value to 0 means no limit.
        Updating this field may impact scalability by changing the amount of
        traffic produced by image pulls.
        Defaults to 5.
        """
        return pulumi.get(self, "registry_pull_qps")

    @registry_pull_qps.setter
    def registry_pull_qps(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "registry_pull_qps", value)

    @property
    @pulumi.getter(name="serializeImagePullsDisabled")
    def serialize_image_pulls_disabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Prevents the Kubelet from pulling multiple images at a time.
        We recommend *not* changing the default value on nodes that run docker
        daemon with version  < 1.9 or an Another Union File System (Aufs) storage
        backend. Issue https://github.com/kubernetes/kubernetes/issues/10959 has
        more details.
        """
        return pulumi.get(self, "serialize_image_pulls_disabled")

    @serialize_image_pulls_disabled.setter
    def serialize_image_pulls_disabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "serialize_image_pulls_disabled", value)


@pulumi.input_type
class BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfigArgs:
    def __init__(__self__, *,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 node_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param pulumi.Input[str] node_ip: The default IPv4 address for SSH access and Kubernetes node.
               Example: 192.168.0.1
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_ip is not None:
            pulumi.set(__self__, "node_ip", node_ip)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The default IPv4 address for SSH access and Kubernetes node.
        Example: 192.168.0.1
        """
        return pulumi.get(self, "node_ip")

    @node_ip.setter
    def node_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_ip", value)


@pulumi.input_type
class BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effect: Specifies the nodes operating system (default: LINUX).
               Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        :param pulumi.Input[str] key: Key associated with the effect.
        :param pulumi.Input[str] value: Value associated with the effect.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the nodes operating system (default: LINUX).
        Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BareMetalClusterLoadBalancerManualLbConfigArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Whether manual load balancing is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether manual load balancing is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class BareMetalClusterLoadBalancerMetalLbConfigArgs:
    def __init__(__self__, *,
                 address_pools: pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigAddressPoolArgs']]],
                 load_balancer_node_pool_config: Optional[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigAddressPoolArgs']]] address_pools: AddressPools is a list of non-overlapping IP pools used by load balancer
               typed services. All addresses must be routable to load balancer nodes.
               IngressVIP must be included in the pools.
               Structure is documented below.
        :param pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigArgs'] load_balancer_node_pool_config: Specifies the load balancer's node pool configuration.
               Structure is documented below.
        """
        pulumi.set(__self__, "address_pools", address_pools)
        if load_balancer_node_pool_config is not None:
            pulumi.set(__self__, "load_balancer_node_pool_config", load_balancer_node_pool_config)

    @property
    @pulumi.getter(name="addressPools")
    def address_pools(self) -> pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigAddressPoolArgs']]]:
        """
        AddressPools is a list of non-overlapping IP pools used by load balancer
        typed services. All addresses must be routable to load balancer nodes.
        IngressVIP must be included in the pools.
        Structure is documented below.
        """
        return pulumi.get(self, "address_pools")

    @address_pools.setter
    def address_pools(self, value: pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigAddressPoolArgs']]]):
        pulumi.set(self, "address_pools", value)

    @property
    @pulumi.getter(name="loadBalancerNodePoolConfig")
    def load_balancer_node_pool_config(self) -> Optional[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigArgs']]:
        """
        Specifies the load balancer's node pool configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "load_balancer_node_pool_config")

    @load_balancer_node_pool_config.setter
    def load_balancer_node_pool_config(self, value: Optional[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigArgs']]):
        pulumi.set(self, "load_balancer_node_pool_config", value)


@pulumi.input_type
class BareMetalClusterLoadBalancerMetalLbConfigAddressPoolArgs:
    def __init__(__self__, *,
                 addresses: pulumi.Input[Sequence[pulumi.Input[str]]],
                 pool: pulumi.Input[str],
                 avoid_buggy_ips: Optional[pulumi.Input[bool]] = None,
                 manual_assign: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] addresses: The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        :param pulumi.Input[str] pool: The name of the address pool.
        :param pulumi.Input[bool] avoid_buggy_ips: If true, avoid using IPs ending in .0 or .255.
               This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        :param pulumi.Input[bool] manual_assign: If true, prevent IP addresses from being automatically assigned.
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "pool", pool)
        if avoid_buggy_ips is not None:
            pulumi.set(__self__, "avoid_buggy_ips", avoid_buggy_ips)
        if manual_assign is not None:
            pulumi.set(__self__, "manual_assign", manual_assign)

    @property
    @pulumi.getter
    def addresses(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter
    def pool(self) -> pulumi.Input[str]:
        """
        The name of the address pool.
        """
        return pulumi.get(self, "pool")

    @pool.setter
    def pool(self, value: pulumi.Input[str]):
        pulumi.set(self, "pool", value)

    @property
    @pulumi.getter(name="avoidBuggyIps")
    def avoid_buggy_ips(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, avoid using IPs ending in .0 or .255.
        This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        """
        return pulumi.get(self, "avoid_buggy_ips")

    @avoid_buggy_ips.setter
    def avoid_buggy_ips(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "avoid_buggy_ips", value)

    @property
    @pulumi.getter(name="manualAssign")
    def manual_assign(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, prevent IP addresses from being automatically assigned.
        """
        return pulumi.get(self, "manual_assign")

    @manual_assign.setter
    def manual_assign(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "manual_assign", value)


@pulumi.input_type
class BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigArgs:
    def __init__(__self__, *,
                 node_pool_config: Optional[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigArgs']] = None):
        """
        :param pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigArgs'] node_pool_config: The generic configuration for a node pool running a load balancer.
               Structure is documented below.
        """
        if node_pool_config is not None:
            pulumi.set(__self__, "node_pool_config", node_pool_config)

    @property
    @pulumi.getter(name="nodePoolConfig")
    def node_pool_config(self) -> Optional[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigArgs']]:
        """
        The generic configuration for a node pool running a load balancer.
        Structure is documented below.
        """
        return pulumi.get(self, "node_pool_config")

    @node_pool_config.setter
    def node_pool_config(self, value: Optional[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigArgs']]):
        pulumi.set(self, "node_pool_config", value)


@pulumi.input_type
class BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigArgs:
    def __init__(__self__, *,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 node_configs: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfigArgs']]]] = None,
                 operating_system: Optional[pulumi.Input[str]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaintArgs']]]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfigArgs']]] node_configs: The list of machine addresses in the Bare Metal Node Pool.
               Structure is documented below.
        :param pulumi.Input[str] operating_system: Specifies the nodes operating system (default: LINUX).
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaintArgs']]] taints: The initial taints assigned to nodes of this node pool.
               Structure is documented below.
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_configs is not None:
            pulumi.set(__self__, "node_configs", node_configs)
        if operating_system is not None:
            pulumi.set(__self__, "operating_system", operating_system)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="nodeConfigs")
    def node_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfigArgs']]]]:
        """
        The list of machine addresses in the Bare Metal Node Pool.
        Structure is documented below.
        """
        return pulumi.get(self, "node_configs")

    @node_configs.setter
    def node_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfigArgs']]]]):
        pulumi.set(self, "node_configs", value)

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the nodes operating system (default: LINUX).
        """
        return pulumi.get(self, "operating_system")

    @operating_system.setter
    def operating_system(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operating_system", value)

    @property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaintArgs']]]]:
        """
        The initial taints assigned to nodes of this node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaintArgs']]]]):
        pulumi.set(self, "taints", value)


@pulumi.input_type
class BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfigArgs:
    def __init__(__self__, *,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 node_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param pulumi.Input[str] node_ip: The default IPv4 address for SSH access and Kubernetes node.
               Example: 192.168.0.1
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_ip is not None:
            pulumi.set(__self__, "node_ip", node_ip)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The default IPv4 address for SSH access and Kubernetes node.
        Example: 192.168.0.1
        """
        return pulumi.get(self, "node_ip")

    @node_ip.setter
    def node_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_ip", value)


@pulumi.input_type
class BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effect: Specifies the nodes operating system (default: LINUX).
               Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        :param pulumi.Input[str] key: Key associated with the effect.
        :param pulumi.Input[str] value: Value associated with the effect.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the nodes operating system (default: LINUX).
        Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BareMetalClusterLoadBalancerPortConfigArgs:
    def __init__(__self__, *,
                 control_plane_load_balancer_port: pulumi.Input[int]):
        """
        :param pulumi.Input[int] control_plane_load_balancer_port: The port that control plane hosted load balancers will listen on.
        """
        pulumi.set(__self__, "control_plane_load_balancer_port", control_plane_load_balancer_port)

    @property
    @pulumi.getter(name="controlPlaneLoadBalancerPort")
    def control_plane_load_balancer_port(self) -> pulumi.Input[int]:
        """
        The port that control plane hosted load balancers will listen on.
        """
        return pulumi.get(self, "control_plane_load_balancer_port")

    @control_plane_load_balancer_port.setter
    def control_plane_load_balancer_port(self, value: pulumi.Input[int]):
        pulumi.set(self, "control_plane_load_balancer_port", value)


@pulumi.input_type
class BareMetalClusterLoadBalancerVipConfigArgs:
    def __init__(__self__, *,
                 control_plane_vip: pulumi.Input[str],
                 ingress_vip: pulumi.Input[str]):
        """
        :param pulumi.Input[str] control_plane_vip: The VIP which you previously set aside for the Kubernetes API of this Bare Metal User Cluster.
        :param pulumi.Input[str] ingress_vip: The VIP which you previously set aside for ingress traffic into this Bare Metal User Cluster.
        """
        pulumi.set(__self__, "control_plane_vip", control_plane_vip)
        pulumi.set(__self__, "ingress_vip", ingress_vip)

    @property
    @pulumi.getter(name="controlPlaneVip")
    def control_plane_vip(self) -> pulumi.Input[str]:
        """
        The VIP which you previously set aside for the Kubernetes API of this Bare Metal User Cluster.
        """
        return pulumi.get(self, "control_plane_vip")

    @control_plane_vip.setter
    def control_plane_vip(self, value: pulumi.Input[str]):
        pulumi.set(self, "control_plane_vip", value)

    @property
    @pulumi.getter(name="ingressVip")
    def ingress_vip(self) -> pulumi.Input[str]:
        """
        The VIP which you previously set aside for ingress traffic into this Bare Metal User Cluster.
        """
        return pulumi.get(self, "ingress_vip")

    @ingress_vip.setter
    def ingress_vip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ingress_vip", value)


@pulumi.input_type
class BareMetalClusterMaintenanceConfigArgs:
    def __init__(__self__, *,
                 maintenance_address_cidr_blocks: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] maintenance_address_cidr_blocks: All IPv4 address from these ranges will be placed into maintenance mode.
               Nodes in maintenance mode will be cordoned and drained. When both of these
               are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set
               on the node resource.
        """
        pulumi.set(__self__, "maintenance_address_cidr_blocks", maintenance_address_cidr_blocks)

    @property
    @pulumi.getter(name="maintenanceAddressCidrBlocks")
    def maintenance_address_cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        All IPv4 address from these ranges will be placed into maintenance mode.
        Nodes in maintenance mode will be cordoned and drained. When both of these
        are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set
        on the node resource.
        """
        return pulumi.get(self, "maintenance_address_cidr_blocks")

    @maintenance_address_cidr_blocks.setter
    def maintenance_address_cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "maintenance_address_cidr_blocks", value)


@pulumi.input_type
class BareMetalClusterNetworkConfigArgs:
    def __init__(__self__, *,
                 advanced_networking: Optional[pulumi.Input[bool]] = None,
                 island_mode_cidr: Optional[pulumi.Input['BareMetalClusterNetworkConfigIslandModeCidrArgs']] = None,
                 multiple_network_interfaces_config: Optional[pulumi.Input['BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfigArgs']] = None,
                 sr_iov_config: Optional[pulumi.Input['BareMetalClusterNetworkConfigSrIovConfigArgs']] = None):
        """
        :param pulumi.Input[bool] advanced_networking: Enables the use of advanced Anthos networking features, such as Bundled
               Load Balancing with BGP or the egress NAT gateway.
               Setting configuration for advanced networking features will automatically
               set this flag.
        :param pulumi.Input['BareMetalClusterNetworkConfigIslandModeCidrArgs'] island_mode_cidr: A nested object resource
               Structure is documented below.
        :param pulumi.Input['BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfigArgs'] multiple_network_interfaces_config: Configuration for multiple network interfaces.
               Structure is documented below.
        :param pulumi.Input['BareMetalClusterNetworkConfigSrIovConfigArgs'] sr_iov_config: Configuration for SR-IOV.
               Structure is documented below.
        """
        if advanced_networking is not None:
            pulumi.set(__self__, "advanced_networking", advanced_networking)
        if island_mode_cidr is not None:
            pulumi.set(__self__, "island_mode_cidr", island_mode_cidr)
        if multiple_network_interfaces_config is not None:
            pulumi.set(__self__, "multiple_network_interfaces_config", multiple_network_interfaces_config)
        if sr_iov_config is not None:
            pulumi.set(__self__, "sr_iov_config", sr_iov_config)

    @property
    @pulumi.getter(name="advancedNetworking")
    def advanced_networking(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables the use of advanced Anthos networking features, such as Bundled
        Load Balancing with BGP or the egress NAT gateway.
        Setting configuration for advanced networking features will automatically
        set this flag.
        """
        return pulumi.get(self, "advanced_networking")

    @advanced_networking.setter
    def advanced_networking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "advanced_networking", value)

    @property
    @pulumi.getter(name="islandModeCidr")
    def island_mode_cidr(self) -> Optional[pulumi.Input['BareMetalClusterNetworkConfigIslandModeCidrArgs']]:
        """
        A nested object resource
        Structure is documented below.
        """
        return pulumi.get(self, "island_mode_cidr")

    @island_mode_cidr.setter
    def island_mode_cidr(self, value: Optional[pulumi.Input['BareMetalClusterNetworkConfigIslandModeCidrArgs']]):
        pulumi.set(self, "island_mode_cidr", value)

    @property
    @pulumi.getter(name="multipleNetworkInterfacesConfig")
    def multiple_network_interfaces_config(self) -> Optional[pulumi.Input['BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfigArgs']]:
        """
        Configuration for multiple network interfaces.
        Structure is documented below.
        """
        return pulumi.get(self, "multiple_network_interfaces_config")

    @multiple_network_interfaces_config.setter
    def multiple_network_interfaces_config(self, value: Optional[pulumi.Input['BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfigArgs']]):
        pulumi.set(self, "multiple_network_interfaces_config", value)

    @property
    @pulumi.getter(name="srIovConfig")
    def sr_iov_config(self) -> Optional[pulumi.Input['BareMetalClusterNetworkConfigSrIovConfigArgs']]:
        """
        Configuration for SR-IOV.
        Structure is documented below.
        """
        return pulumi.get(self, "sr_iov_config")

    @sr_iov_config.setter
    def sr_iov_config(self, value: Optional[pulumi.Input['BareMetalClusterNetworkConfigSrIovConfigArgs']]):
        pulumi.set(self, "sr_iov_config", value)


@pulumi.input_type
class BareMetalClusterNetworkConfigIslandModeCidrArgs:
    def __init__(__self__, *,
                 pod_address_cidr_blocks: pulumi.Input[Sequence[pulumi.Input[str]]],
                 service_address_cidr_blocks: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pod_address_cidr_blocks: All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_address_cidr_blocks: All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        pulumi.set(__self__, "pod_address_cidr_blocks", pod_address_cidr_blocks)
        pulumi.set(__self__, "service_address_cidr_blocks", service_address_cidr_blocks)

    @property
    @pulumi.getter(name="podAddressCidrBlocks")
    def pod_address_cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        return pulumi.get(self, "pod_address_cidr_blocks")

    @pod_address_cidr_blocks.setter
    def pod_address_cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "pod_address_cidr_blocks", value)

    @property
    @pulumi.getter(name="serviceAddressCidrBlocks")
    def service_address_cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        return pulumi.get(self, "service_address_cidr_blocks")

    @service_address_cidr_blocks.setter
    def service_address_cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "service_address_cidr_blocks", value)


@pulumi.input_type
class BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether to enable multiple network interfaces for your pods.
               When set network_config.advanced_networking is automatically
               set to true.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to enable multiple network interfaces for your pods.
        When set network_config.advanced_networking is automatically
        set to true.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class BareMetalClusterNetworkConfigSrIovConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether to install the SR-IOV operator.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to install the SR-IOV operator.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class BareMetalClusterNodeAccessConfigArgs:
    def __init__(__self__, *,
                 login_user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] login_user: LoginUser is the user name used to access node machines.
               It defaults to "root" if not set.
        """
        if login_user is not None:
            pulumi.set(__self__, "login_user", login_user)

    @property
    @pulumi.getter(name="loginUser")
    def login_user(self) -> Optional[pulumi.Input[str]]:
        """
        LoginUser is the user name used to access node machines.
        It defaults to "root" if not set.
        """
        return pulumi.get(self, "login_user")

    @login_user.setter
    def login_user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "login_user", value)


@pulumi.input_type
class BareMetalClusterNodeConfigArgs:
    def __init__(__self__, *,
                 container_runtime: Optional[pulumi.Input[str]] = None,
                 max_pods_per_node: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] container_runtime: The available runtimes that can be used to run containers in a Bare Metal User Cluster.
               Possible values are: `CONTAINER_RUNTIME_UNSPECIFIED`, `DOCKER`, `CONTAINERD`.
        :param pulumi.Input[int] max_pods_per_node: The maximum number of pods a node can run. The size of the CIDR range
               assigned to the node will be derived from this parameter.
        """
        if container_runtime is not None:
            pulumi.set(__self__, "container_runtime", container_runtime)
        if max_pods_per_node is not None:
            pulumi.set(__self__, "max_pods_per_node", max_pods_per_node)

    @property
    @pulumi.getter(name="containerRuntime")
    def container_runtime(self) -> Optional[pulumi.Input[str]]:
        """
        The available runtimes that can be used to run containers in a Bare Metal User Cluster.
        Possible values are: `CONTAINER_RUNTIME_UNSPECIFIED`, `DOCKER`, `CONTAINERD`.
        """
        return pulumi.get(self, "container_runtime")

    @container_runtime.setter
    def container_runtime(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "container_runtime", value)

    @property
    @pulumi.getter(name="maxPodsPerNode")
    def max_pods_per_node(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum number of pods a node can run. The size of the CIDR range
        assigned to the node will be derived from this parameter.
        """
        return pulumi.get(self, "max_pods_per_node")

    @max_pods_per_node.setter
    def max_pods_per_node(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_pods_per_node", value)


@pulumi.input_type
class BareMetalClusterOsEnvironmentConfigArgs:
    def __init__(__self__, *,
                 package_repo_excluded: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] package_repo_excluded: Whether the package repo should not be included when initializing
               bare metal machines.
        """
        pulumi.set(__self__, "package_repo_excluded", package_repo_excluded)

    @property
    @pulumi.getter(name="packageRepoExcluded")
    def package_repo_excluded(self) -> pulumi.Input[bool]:
        """
        Whether the package repo should not be included when initializing
        bare metal machines.
        """
        return pulumi.get(self, "package_repo_excluded")

    @package_repo_excluded.setter
    def package_repo_excluded(self, value: pulumi.Input[bool]):
        pulumi.set(self, "package_repo_excluded", value)


@pulumi.input_type
class BareMetalClusterProxyArgs:
    def __init__(__self__, *,
                 uri: pulumi.Input[str],
                 no_proxies: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] uri: Specifies the address of your proxy server.
               Examples: http://domain
               WARNING: Do not provide credentials in the format
               http://(username:password@)domain these will be rejected by the server.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] no_proxies: A list of IPs, hostnames, and domains that should skip the proxy.
               Examples: ["127.0.0.1", "example.com", ".corp", "localhost"].
        """
        pulumi.set(__self__, "uri", uri)
        if no_proxies is not None:
            pulumi.set(__self__, "no_proxies", no_proxies)

    @property
    @pulumi.getter
    def uri(self) -> pulumi.Input[str]:
        """
        Specifies the address of your proxy server.
        Examples: http://domain
        WARNING: Do not provide credentials in the format
        http://(username:password@)domain these will be rejected by the server.
        """
        return pulumi.get(self, "uri")

    @uri.setter
    def uri(self, value: pulumi.Input[str]):
        pulumi.set(self, "uri", value)

    @property
    @pulumi.getter(name="noProxies")
    def no_proxies(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of IPs, hostnames, and domains that should skip the proxy.
        Examples: ["127.0.0.1", "example.com", ".corp", "localhost"].
        """
        return pulumi.get(self, "no_proxies")

    @no_proxies.setter
    def no_proxies(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "no_proxies", value)


@pulumi.input_type
class BareMetalClusterSecurityConfigArgs:
    def __init__(__self__, *,
                 authorization: Optional[pulumi.Input['BareMetalClusterSecurityConfigAuthorizationArgs']] = None):
        """
        :param pulumi.Input['BareMetalClusterSecurityConfigAuthorizationArgs'] authorization: Configures user access to the Bare Metal User cluster.
               Structure is documented below.
        """
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)

    @property
    @pulumi.getter
    def authorization(self) -> Optional[pulumi.Input['BareMetalClusterSecurityConfigAuthorizationArgs']]:
        """
        Configures user access to the Bare Metal User cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "authorization")

    @authorization.setter
    def authorization(self, value: Optional[pulumi.Input['BareMetalClusterSecurityConfigAuthorizationArgs']]):
        pulumi.set(self, "authorization", value)


@pulumi.input_type
class BareMetalClusterSecurityConfigAuthorizationArgs:
    def __init__(__self__, *,
                 admin_users: pulumi.Input[Sequence[pulumi.Input['BareMetalClusterSecurityConfigAuthorizationAdminUserArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalClusterSecurityConfigAuthorizationAdminUserArgs']]] admin_users: Users that will be granted the cluster-admin role on the cluster, providing full access to the cluster.
               Structure is documented below.
        """
        pulumi.set(__self__, "admin_users", admin_users)

    @property
    @pulumi.getter(name="adminUsers")
    def admin_users(self) -> pulumi.Input[Sequence[pulumi.Input['BareMetalClusterSecurityConfigAuthorizationAdminUserArgs']]]:
        """
        Users that will be granted the cluster-admin role on the cluster, providing full access to the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "admin_users")

    @admin_users.setter
    def admin_users(self, value: pulumi.Input[Sequence[pulumi.Input['BareMetalClusterSecurityConfigAuthorizationAdminUserArgs']]]):
        pulumi.set(self, "admin_users", value)


@pulumi.input_type
class BareMetalClusterSecurityConfigAuthorizationAdminUserArgs:
    def __init__(__self__, *,
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] username: The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class BareMetalClusterStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterStatusConditionArgs']]]] = None,
                 error_message: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalClusterStatusConditionArgs']]] conditions: (Output)
               ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
               Structure is documented below.
        :param pulumi.Input[str] error_message: (Output)
               Human-friendly representation of the error message from the user cluster
               controller. The error message can be temporary as the user cluster
               controller creates a cluster or node pool. If the error message persists
               for a longer period of time, it can be used to surface error message to
               indicate real problems requiring user intervention.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterStatusConditionArgs']]]]:
        """
        (Output)
        ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterStatusConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Human-friendly representation of the error message from the user cluster
        controller. The error message can be temporary as the user cluster
        controller creates a cluster or node pool. If the error message persists
        for a longer period of time, it can be used to surface error message to
        indicate real problems requiring user intervention.
        """
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_message", value)


@pulumi.input_type
class BareMetalClusterStatusConditionArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] last_transition_time: (Output)
               Last time the condition transit from one status to another.
        :param pulumi.Input[str] message: Human-readable message indicating details about last transition.
        :param pulumi.Input[str] reason: (Output)
               A human-readable message of the check failure.
        :param pulumi.Input[str] state: (Output)
               The lifecycle state of the condition.
        :param pulumi.Input[str] type: Type of the condition.
               (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Human-readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        A human-readable message of the check failure.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The lifecycle state of the condition.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the condition.
        (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class BareMetalClusterStorageArgs:
    def __init__(__self__, *,
                 lvp_node_mounts_config: pulumi.Input['BareMetalClusterStorageLvpNodeMountsConfigArgs'],
                 lvp_share_config: pulumi.Input['BareMetalClusterStorageLvpShareConfigArgs']):
        """
        :param pulumi.Input['BareMetalClusterStorageLvpNodeMountsConfigArgs'] lvp_node_mounts_config: Specifies the config for local PersistentVolumes backed
               by mounted node disks. These disks need to be formatted and mounted by the
               user, which can be done before or after cluster creation.
               Structure is documented below.
        :param pulumi.Input['BareMetalClusterStorageLvpShareConfigArgs'] lvp_share_config: Specifies the config for local PersistentVolumes backed by
               subdirectories in a shared filesystem. These subdirectores are
               automatically created during cluster creation.
               Structure is documented below.
        """
        pulumi.set(__self__, "lvp_node_mounts_config", lvp_node_mounts_config)
        pulumi.set(__self__, "lvp_share_config", lvp_share_config)

    @property
    @pulumi.getter(name="lvpNodeMountsConfig")
    def lvp_node_mounts_config(self) -> pulumi.Input['BareMetalClusterStorageLvpNodeMountsConfigArgs']:
        """
        Specifies the config for local PersistentVolumes backed
        by mounted node disks. These disks need to be formatted and mounted by the
        user, which can be done before or after cluster creation.
        Structure is documented below.
        """
        return pulumi.get(self, "lvp_node_mounts_config")

    @lvp_node_mounts_config.setter
    def lvp_node_mounts_config(self, value: pulumi.Input['BareMetalClusterStorageLvpNodeMountsConfigArgs']):
        pulumi.set(self, "lvp_node_mounts_config", value)

    @property
    @pulumi.getter(name="lvpShareConfig")
    def lvp_share_config(self) -> pulumi.Input['BareMetalClusterStorageLvpShareConfigArgs']:
        """
        Specifies the config for local PersistentVolumes backed by
        subdirectories in a shared filesystem. These subdirectores are
        automatically created during cluster creation.
        Structure is documented below.
        """
        return pulumi.get(self, "lvp_share_config")

    @lvp_share_config.setter
    def lvp_share_config(self, value: pulumi.Input['BareMetalClusterStorageLvpShareConfigArgs']):
        pulumi.set(self, "lvp_share_config", value)


@pulumi.input_type
class BareMetalClusterStorageLvpNodeMountsConfigArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 storage_class: pulumi.Input[str]):
        """
        :param pulumi.Input[str] path: The host machine path.
        :param pulumi.Input[str] storage_class: The StorageClass name that PVs will be created with.
               
               - - -
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The host machine path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[str]:
        """
        The StorageClass name that PVs will be created with.

        - - -
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_class", value)


@pulumi.input_type
class BareMetalClusterStorageLvpShareConfigArgs:
    def __init__(__self__, *,
                 lvp_config: pulumi.Input['BareMetalClusterStorageLvpShareConfigLvpConfigArgs'],
                 shared_path_pv_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['BareMetalClusterStorageLvpShareConfigLvpConfigArgs'] lvp_config: Defines the machine path and storage class for the LVP Share.
               Structure is documented below.
        :param pulumi.Input[int] shared_path_pv_count: The number of subdirectories to create under path.
        """
        pulumi.set(__self__, "lvp_config", lvp_config)
        if shared_path_pv_count is not None:
            pulumi.set(__self__, "shared_path_pv_count", shared_path_pv_count)

    @property
    @pulumi.getter(name="lvpConfig")
    def lvp_config(self) -> pulumi.Input['BareMetalClusterStorageLvpShareConfigLvpConfigArgs']:
        """
        Defines the machine path and storage class for the LVP Share.
        Structure is documented below.
        """
        return pulumi.get(self, "lvp_config")

    @lvp_config.setter
    def lvp_config(self, value: pulumi.Input['BareMetalClusterStorageLvpShareConfigLvpConfigArgs']):
        pulumi.set(self, "lvp_config", value)

    @property
    @pulumi.getter(name="sharedPathPvCount")
    def shared_path_pv_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of subdirectories to create under path.
        """
        return pulumi.get(self, "shared_path_pv_count")

    @shared_path_pv_count.setter
    def shared_path_pv_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "shared_path_pv_count", value)


@pulumi.input_type
class BareMetalClusterStorageLvpShareConfigLvpConfigArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str],
                 storage_class: pulumi.Input[str]):
        """
        :param pulumi.Input[str] path: The host machine path.
        :param pulumi.Input[str] storage_class: The StorageClass name that PVs will be created with.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        The host machine path.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> pulumi.Input[str]:
        """
        The StorageClass name that PVs will be created with.
        """
        return pulumi.get(self, "storage_class")

    @storage_class.setter
    def storage_class(self, value: pulumi.Input[str]):
        pulumi.set(self, "storage_class", value)


@pulumi.input_type
class BareMetalClusterUpgradePolicyArgs:
    def __init__(__self__, *,
                 policy: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] policy: Specifies which upgrade policy to use.
               Possible values are: `SERIAL`, `CONCURRENT`.
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies which upgrade policy to use.
        Possible values are: `SERIAL`, `CONCURRENT`.
        """
        return pulumi.get(self, "policy")

    @policy.setter
    def policy(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "policy", value)


@pulumi.input_type
class BareMetalClusterValidationCheckArgs:
    def __init__(__self__, *,
                 options: Optional[pulumi.Input[str]] = None,
                 scenario: Optional[pulumi.Input[str]] = None,
                 statuses: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterValidationCheckStatusArgs']]]] = None):
        """
        :param pulumi.Input[str] options: (Output)
               Options used for the validation check.
        :param pulumi.Input[str] scenario: (Output)
               The scenario when the preflight checks were run..
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalClusterValidationCheckStatusArgs']]] statuses: (Output)
               Specifies the detailed validation check status
               Structure is documented below.
        """
        if options is not None:
            pulumi.set(__self__, "options", options)
        if scenario is not None:
            pulumi.set(__self__, "scenario", scenario)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Options used for the validation check.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def scenario(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The scenario when the preflight checks were run..
        """
        return pulumi.get(self, "scenario")

    @scenario.setter
    def scenario(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scenario", value)

    @property
    @pulumi.getter
    def statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterValidationCheckStatusArgs']]]]:
        """
        (Output)
        Specifies the detailed validation check status
        Structure is documented below.
        """
        return pulumi.get(self, "statuses")

    @statuses.setter
    def statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterValidationCheckStatusArgs']]]]):
        pulumi.set(self, "statuses", value)


@pulumi.input_type
class BareMetalClusterValidationCheckStatusArgs:
    def __init__(__self__, *,
                 results: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterValidationCheckStatusResultArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalClusterValidationCheckStatusResultArgs']]] results: (Output)
               Individual checks which failed as part of the Preflight check execution.
               Structure is documented below.
        """
        if results is not None:
            pulumi.set(__self__, "results", results)

    @property
    @pulumi.getter
    def results(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterValidationCheckStatusResultArgs']]]]:
        """
        (Output)
        Individual checks which failed as part of the Preflight check execution.
        Structure is documented below.
        """
        return pulumi.get(self, "results")

    @results.setter
    def results(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalClusterValidationCheckStatusResultArgs']]]]):
        pulumi.set(self, "results", value)


@pulumi.input_type
class BareMetalClusterValidationCheckStatusResultArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 details: Optional[pulumi.Input[str]] = None,
                 options: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] category: (Output)
               The category of the validation.
        :param pulumi.Input[str] description: A human readable description of this Bare Metal User Cluster.
        :param pulumi.Input[str] details: (Output)
               Detailed failure information, which might be unformatted.
        :param pulumi.Input[str] options: (Output)
               Options used for the validation check.
        :param pulumi.Input[str] reason: (Output)
               A human-readable message of the check failure.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The category of the validation.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A human readable description of this Bare Metal User Cluster.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Detailed failure information, which might be unformatted.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Options used for the validation check.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        A human-readable message of the check failure.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


@pulumi.input_type
class BareMetalNodePoolNodePoolConfigArgs:
    def __init__(__self__, *,
                 node_configs: pulumi.Input[Sequence[pulumi.Input['BareMetalNodePoolNodePoolConfigNodeConfigArgs']]],
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 operating_system: Optional[pulumi.Input[str]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalNodePoolNodePoolConfigTaintArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalNodePoolNodePoolConfigNodeConfigArgs']]] node_configs: The list of machine addresses in the Bare Metal Node Pool.
               Structure is documented below.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param pulumi.Input[str] operating_system: Specifies the nodes operating system (default: LINUX).
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalNodePoolNodePoolConfigTaintArgs']]] taints: The initial taints assigned to nodes of this node pool.
               Structure is documented below.
        """
        pulumi.set(__self__, "node_configs", node_configs)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if operating_system is not None:
            pulumi.set(__self__, "operating_system", operating_system)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter(name="nodeConfigs")
    def node_configs(self) -> pulumi.Input[Sequence[pulumi.Input['BareMetalNodePoolNodePoolConfigNodeConfigArgs']]]:
        """
        The list of machine addresses in the Bare Metal Node Pool.
        Structure is documented below.
        """
        return pulumi.get(self, "node_configs")

    @node_configs.setter
    def node_configs(self, value: pulumi.Input[Sequence[pulumi.Input['BareMetalNodePoolNodePoolConfigNodeConfigArgs']]]):
        pulumi.set(self, "node_configs", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the nodes operating system (default: LINUX).
        """
        return pulumi.get(self, "operating_system")

    @operating_system.setter
    def operating_system(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "operating_system", value)

    @property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalNodePoolNodePoolConfigTaintArgs']]]]:
        """
        The initial taints assigned to nodes of this node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalNodePoolNodePoolConfigTaintArgs']]]]):
        pulumi.set(self, "taints", value)


@pulumi.input_type
class BareMetalNodePoolNodePoolConfigNodeConfigArgs:
    def __init__(__self__, *,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 node_ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param pulumi.Input[str] node_ip: The default IPv4 address for SSH access and Kubernetes node.
               Example: 192.168.0.1
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_ip is not None:
            pulumi.set(__self__, "node_ip", node_ip)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> Optional[pulumi.Input[str]]:
        """
        The default IPv4 address for SSH access and Kubernetes node.
        Example: 192.168.0.1
        """
        return pulumi.get(self, "node_ip")

    @node_ip.setter
    def node_ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "node_ip", value)


@pulumi.input_type
class BareMetalNodePoolNodePoolConfigTaintArgs:
    def __init__(__self__, *,
                 effect: Optional[pulumi.Input[str]] = None,
                 key: Optional[pulumi.Input[str]] = None,
                 value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] effect: Specifies the nodes operating system (default: LINUX).
               Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
               
               - - -
        :param pulumi.Input[str] key: Key associated with the effect.
        :param pulumi.Input[str] value: Value associated with the effect.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        Specifies the nodes operating system (default: LINUX).
        Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.

        - - -
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)

    @property
    @pulumi.getter
    def key(self) -> Optional[pulumi.Input[str]]:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[str]]:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "value", value)


@pulumi.input_type
class BareMetalNodePoolStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalNodePoolStatusConditionArgs']]]] = None,
                 error_message: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['BareMetalNodePoolStatusConditionArgs']]] conditions: (Output)
               ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
               Structure is documented below.
        :param pulumi.Input[str] error_message: (Output)
               Human-friendly representation of the error message from the user cluster
               controller. The error message can be temporary as the user cluster
               controller creates a cluster or node pool. If the error message persists
               for a longer period of time, it can be used to surface error message to
               indicate real problems requiring user intervention.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalNodePoolStatusConditionArgs']]]]:
        """
        (Output)
        ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['BareMetalNodePoolStatusConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Human-friendly representation of the error message from the user cluster
        controller. The error message can be temporary as the user cluster
        controller creates a cluster or node pool. If the error message persists
        for a longer period of time, it can be used to surface error message to
        indicate real problems requiring user intervention.
        """
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_message", value)


@pulumi.input_type
class BareMetalNodePoolStatusConditionArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] last_transition_time: (Output)
               Last time the condition transit from one status to another.
        :param pulumi.Input[str] message: Human-readable message indicating details about last transition.
        :param pulumi.Input[str] reason: Machine-readable message indicating details about last transition.
        :param pulumi.Input[str] state: (Output)
               The lifecycle state of the condition.
        :param pulumi.Input[str] type: Type of the condition.
               (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        Human-readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        Machine-readable message indicating details about last transition.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The lifecycle state of the condition.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of the condition.
        (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class VMwareClusterAntiAffinityGroupsArgs:
    def __init__(__self__, *,
                 aag_config_disabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] aag_config_disabled: Spread nodes across at least three physical hosts (requires at least three
               hosts).
               Enabled by default.
        """
        pulumi.set(__self__, "aag_config_disabled", aag_config_disabled)

    @property
    @pulumi.getter(name="aagConfigDisabled")
    def aag_config_disabled(self) -> pulumi.Input[bool]:
        """
        Spread nodes across at least three physical hosts (requires at least three
        hosts).
        Enabled by default.
        """
        return pulumi.get(self, "aag_config_disabled")

    @aag_config_disabled.setter
    def aag_config_disabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "aag_config_disabled", value)


@pulumi.input_type
class VMwareClusterAuthorizationArgs:
    def __init__(__self__, *,
                 admin_users: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareClusterAuthorizationAdminUserArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VMwareClusterAuthorizationAdminUserArgs']]] admin_users: Users that will be granted the cluster-admin role on the cluster, providing
               full access to the cluster.
               Structure is documented below.
        """
        if admin_users is not None:
            pulumi.set(__self__, "admin_users", admin_users)

    @property
    @pulumi.getter(name="adminUsers")
    def admin_users(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VMwareClusterAuthorizationAdminUserArgs']]]]:
        """
        Users that will be granted the cluster-admin role on the cluster, providing
        full access to the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "admin_users")

    @admin_users.setter
    def admin_users(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareClusterAuthorizationAdminUserArgs']]]]):
        pulumi.set(self, "admin_users", value)


@pulumi.input_type
class VMwareClusterAuthorizationAdminUserArgs:
    def __init__(__self__, *,
                 username: pulumi.Input[str]):
        """
        :param pulumi.Input[str] username: The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)


@pulumi.input_type
class VMwareClusterAutoRepairConfigArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Whether auto repair is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether auto repair is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class VMwareClusterControlPlaneNodeArgs:
    def __init__(__self__, *,
                 auto_resize_config: Optional[pulumi.Input['VMwareClusterControlPlaneNodeAutoResizeConfigArgs']] = None,
                 cpus: Optional[pulumi.Input[int]] = None,
                 memory: Optional[pulumi.Input[int]] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 vsphere_configs: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareClusterControlPlaneNodeVsphereConfigArgs']]]] = None):
        """
        :param pulumi.Input['VMwareClusterControlPlaneNodeAutoResizeConfigArgs'] auto_resize_config: AutoResizeConfig provides auto resizing configurations.
               Structure is documented below.
        :param pulumi.Input[int] cpus: The number of CPUs for each admin cluster node that serve as control planes
               for this VMware User Cluster. (default: 4 CPUs)
        :param pulumi.Input[int] memory: The megabytes of memory for each admin cluster node that serves as a
               control plane for this VMware User Cluster (default: 8192 MB memory).
        :param pulumi.Input[int] replicas: The number of control plane nodes for this VMware User Cluster.
               (default: 1 replica).
        :param pulumi.Input[Sequence[pulumi.Input['VMwareClusterControlPlaneNodeVsphereConfigArgs']]] vsphere_configs: (Output)
               Vsphere-specific config.
               Structure is documented below.
        """
        if auto_resize_config is not None:
            pulumi.set(__self__, "auto_resize_config", auto_resize_config)
        if cpus is not None:
            pulumi.set(__self__, "cpus", cpus)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if vsphere_configs is not None:
            pulumi.set(__self__, "vsphere_configs", vsphere_configs)

    @property
    @pulumi.getter(name="autoResizeConfig")
    def auto_resize_config(self) -> Optional[pulumi.Input['VMwareClusterControlPlaneNodeAutoResizeConfigArgs']]:
        """
        AutoResizeConfig provides auto resizing configurations.
        Structure is documented below.
        """
        return pulumi.get(self, "auto_resize_config")

    @auto_resize_config.setter
    def auto_resize_config(self, value: Optional[pulumi.Input['VMwareClusterControlPlaneNodeAutoResizeConfigArgs']]):
        pulumi.set(self, "auto_resize_config", value)

    @property
    @pulumi.getter
    def cpus(self) -> Optional[pulumi.Input[int]]:
        """
        The number of CPUs for each admin cluster node that serve as control planes
        for this VMware User Cluster. (default: 4 CPUs)
        """
        return pulumi.get(self, "cpus")

    @cpus.setter
    def cpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpus", value)

    @property
    @pulumi.getter
    def memory(self) -> Optional[pulumi.Input[int]]:
        """
        The megabytes of memory for each admin cluster node that serves as a
        control plane for this VMware User Cluster (default: 8192 MB memory).
        """
        return pulumi.get(self, "memory")

    @memory.setter
    def memory(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The number of control plane nodes for this VMware User Cluster.
        (default: 1 replica).
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter(name="vsphereConfigs")
    def vsphere_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VMwareClusterControlPlaneNodeVsphereConfigArgs']]]]:
        """
        (Output)
        Vsphere-specific config.
        Structure is documented below.
        """
        return pulumi.get(self, "vsphere_configs")

    @vsphere_configs.setter
    def vsphere_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareClusterControlPlaneNodeVsphereConfigArgs']]]]):
        pulumi.set(self, "vsphere_configs", value)


@pulumi.input_type
class VMwareClusterControlPlaneNodeAutoResizeConfigArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: Whether to enable control plane node auto resizing.
               
               <a name="nested_vsphere_config"></a>The `vsphere_config` block contains:
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        Whether to enable control plane node auto resizing.

        <a name="nested_vsphere_config"></a>The `vsphere_config` block contains:
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class VMwareClusterControlPlaneNodeVsphereConfigArgs:
    def __init__(__self__, *,
                 datastore: Optional[pulumi.Input[str]] = None,
                 storage_policy_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] datastore: (Output)
               The Vsphere datastore used by the Control Plane Node.
        :param pulumi.Input[str] storage_policy_name: (Output)
               The Vsphere storage policy used by the control plane Node.
               
               - - -
        """
        if datastore is not None:
            pulumi.set(__self__, "datastore", datastore)
        if storage_policy_name is not None:
            pulumi.set(__self__, "storage_policy_name", storage_policy_name)

    @property
    @pulumi.getter
    def datastore(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The Vsphere datastore used by the Control Plane Node.
        """
        return pulumi.get(self, "datastore")

    @datastore.setter
    def datastore(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore", value)

    @property
    @pulumi.getter(name="storagePolicyName")
    def storage_policy_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The Vsphere storage policy used by the control plane Node.

        - - -
        """
        return pulumi.get(self, "storage_policy_name")

    @storage_policy_name.setter
    def storage_policy_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_policy_name", value)


@pulumi.input_type
class VMwareClusterDataplaneV2Args:
    def __init__(__self__, *,
                 advanced_networking: Optional[pulumi.Input[bool]] = None,
                 dataplane_v2_enabled: Optional[pulumi.Input[bool]] = None,
                 windows_dataplane_v2_enabled: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] advanced_networking: Enable advanced networking which requires dataplane_v2_enabled to be set true.
        :param pulumi.Input[bool] dataplane_v2_enabled: Enables Dataplane V2.
        :param pulumi.Input[bool] windows_dataplane_v2_enabled: Enable Dataplane V2 for clusters with Windows nodes.
        """
        if advanced_networking is not None:
            pulumi.set(__self__, "advanced_networking", advanced_networking)
        if dataplane_v2_enabled is not None:
            pulumi.set(__self__, "dataplane_v2_enabled", dataplane_v2_enabled)
        if windows_dataplane_v2_enabled is not None:
            pulumi.set(__self__, "windows_dataplane_v2_enabled", windows_dataplane_v2_enabled)

    @property
    @pulumi.getter(name="advancedNetworking")
    def advanced_networking(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable advanced networking which requires dataplane_v2_enabled to be set true.
        """
        return pulumi.get(self, "advanced_networking")

    @advanced_networking.setter
    def advanced_networking(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "advanced_networking", value)

    @property
    @pulumi.getter(name="dataplaneV2Enabled")
    def dataplane_v2_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enables Dataplane V2.
        """
        return pulumi.get(self, "dataplane_v2_enabled")

    @dataplane_v2_enabled.setter
    def dataplane_v2_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "dataplane_v2_enabled", value)

    @property
    @pulumi.getter(name="windowsDataplaneV2Enabled")
    def windows_dataplane_v2_enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Enable Dataplane V2 for clusters with Windows nodes.
        """
        return pulumi.get(self, "windows_dataplane_v2_enabled")

    @windows_dataplane_v2_enabled.setter
    def windows_dataplane_v2_enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "windows_dataplane_v2_enabled", value)


@pulumi.input_type
class VMwareClusterFleetArgs:
    def __init__(__self__, *,
                 membership: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] membership: (Output)
               The name of the managed Hub Membership resource associated to this cluster.
               Membership names are formatted as
               `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        if membership is not None:
            pulumi.set(__self__, "membership", membership)

    @property
    @pulumi.getter
    def membership(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The name of the managed Hub Membership resource associated to this cluster.
        Membership names are formatted as
        `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        return pulumi.get(self, "membership")

    @membership.setter
    def membership(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "membership", value)


@pulumi.input_type
class VMwareClusterLoadBalancerArgs:
    def __init__(__self__, *,
                 f5_config: Optional[pulumi.Input['VMwareClusterLoadBalancerF5ConfigArgs']] = None,
                 manual_lb_config: Optional[pulumi.Input['VMwareClusterLoadBalancerManualLbConfigArgs']] = None,
                 metal_lb_config: Optional[pulumi.Input['VMwareClusterLoadBalancerMetalLbConfigArgs']] = None,
                 vip_config: Optional[pulumi.Input['VMwareClusterLoadBalancerVipConfigArgs']] = None):
        """
        :param pulumi.Input['VMwareClusterLoadBalancerF5ConfigArgs'] f5_config: Configuration for F5 Big IP typed load balancers.
               Structure is documented below.
        :param pulumi.Input['VMwareClusterLoadBalancerManualLbConfigArgs'] manual_lb_config: Manually configured load balancers.
               Structure is documented below.
        :param pulumi.Input['VMwareClusterLoadBalancerMetalLbConfigArgs'] metal_lb_config: Configuration for MetalLB typed load balancers.
               Structure is documented below.
        :param pulumi.Input['VMwareClusterLoadBalancerVipConfigArgs'] vip_config: The VIPs used by the load balancer.
               Structure is documented below.
        """
        if f5_config is not None:
            pulumi.set(__self__, "f5_config", f5_config)
        if manual_lb_config is not None:
            pulumi.set(__self__, "manual_lb_config", manual_lb_config)
        if metal_lb_config is not None:
            pulumi.set(__self__, "metal_lb_config", metal_lb_config)
        if vip_config is not None:
            pulumi.set(__self__, "vip_config", vip_config)

    @property
    @pulumi.getter(name="f5Config")
    def f5_config(self) -> Optional[pulumi.Input['VMwareClusterLoadBalancerF5ConfigArgs']]:
        """
        Configuration for F5 Big IP typed load balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "f5_config")

    @f5_config.setter
    def f5_config(self, value: Optional[pulumi.Input['VMwareClusterLoadBalancerF5ConfigArgs']]):
        pulumi.set(self, "f5_config", value)

    @property
    @pulumi.getter(name="manualLbConfig")
    def manual_lb_config(self) -> Optional[pulumi.Input['VMwareClusterLoadBalancerManualLbConfigArgs']]:
        """
        Manually configured load balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "manual_lb_config")

    @manual_lb_config.setter
    def manual_lb_config(self, value: Optional[pulumi.Input['VMwareClusterLoadBalancerManualLbConfigArgs']]):
        pulumi.set(self, "manual_lb_config", value)

    @property
    @pulumi.getter(name="metalLbConfig")
    def metal_lb_config(self) -> Optional[pulumi.Input['VMwareClusterLoadBalancerMetalLbConfigArgs']]:
        """
        Configuration for MetalLB typed load balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "metal_lb_config")

    @metal_lb_config.setter
    def metal_lb_config(self, value: Optional[pulumi.Input['VMwareClusterLoadBalancerMetalLbConfigArgs']]):
        pulumi.set(self, "metal_lb_config", value)

    @property
    @pulumi.getter(name="vipConfig")
    def vip_config(self) -> Optional[pulumi.Input['VMwareClusterLoadBalancerVipConfigArgs']]:
        """
        The VIPs used by the load balancer.
        Structure is documented below.
        """
        return pulumi.get(self, "vip_config")

    @vip_config.setter
    def vip_config(self, value: Optional[pulumi.Input['VMwareClusterLoadBalancerVipConfigArgs']]):
        pulumi.set(self, "vip_config", value)


@pulumi.input_type
class VMwareClusterLoadBalancerF5ConfigArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 partition: Optional[pulumi.Input[str]] = None,
                 snat_pool: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The load balancer's IP address.
        :param pulumi.Input[str] partition: he preexisting partition to be used by the load balancer. T
               his partition is usually created for the admin cluster for example:
               'my-f5-admin-partition'.
        :param pulumi.Input[str] snat_pool: The pool name. Only necessary, if using SNAT.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if snat_pool is not None:
            pulumi.set(__self__, "snat_pool", snat_pool)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The load balancer's IP address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter
    def partition(self) -> Optional[pulumi.Input[str]]:
        """
        he preexisting partition to be used by the load balancer. T
        his partition is usually created for the admin cluster for example:
        'my-f5-admin-partition'.
        """
        return pulumi.get(self, "partition")

    @partition.setter
    def partition(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "partition", value)

    @property
    @pulumi.getter(name="snatPool")
    def snat_pool(self) -> Optional[pulumi.Input[str]]:
        """
        The pool name. Only necessary, if using SNAT.
        """
        return pulumi.get(self, "snat_pool")

    @snat_pool.setter
    def snat_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "snat_pool", value)


@pulumi.input_type
class VMwareClusterLoadBalancerManualLbConfigArgs:
    def __init__(__self__, *,
                 control_plane_node_port: Optional[pulumi.Input[int]] = None,
                 ingress_http_node_port: Optional[pulumi.Input[int]] = None,
                 ingress_https_node_port: Optional[pulumi.Input[int]] = None,
                 konnectivity_server_node_port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] control_plane_node_port: NodePort for control plane service. The Kubernetes API server in the admin
               cluster is implemented as a Service of type NodePort (ex. 30968).
        :param pulumi.Input[int] ingress_http_node_port: NodePort for ingress service's http. The ingress service in the admin
               cluster is implemented as a Service of type NodePort (ex. 32527).
        :param pulumi.Input[int] ingress_https_node_port: NodePort for ingress service's https. The ingress service in the admin
               cluster is implemented as a Service of type NodePort (ex. 30139).
        :param pulumi.Input[int] konnectivity_server_node_port: NodePort for konnectivity server service running as a sidecar in each
               kube-apiserver pod (ex. 30564).
        """
        if control_plane_node_port is not None:
            pulumi.set(__self__, "control_plane_node_port", control_plane_node_port)
        if ingress_http_node_port is not None:
            pulumi.set(__self__, "ingress_http_node_port", ingress_http_node_port)
        if ingress_https_node_port is not None:
            pulumi.set(__self__, "ingress_https_node_port", ingress_https_node_port)
        if konnectivity_server_node_port is not None:
            pulumi.set(__self__, "konnectivity_server_node_port", konnectivity_server_node_port)

    @property
    @pulumi.getter(name="controlPlaneNodePort")
    def control_plane_node_port(self) -> Optional[pulumi.Input[int]]:
        """
        NodePort for control plane service. The Kubernetes API server in the admin
        cluster is implemented as a Service of type NodePort (ex. 30968).
        """
        return pulumi.get(self, "control_plane_node_port")

    @control_plane_node_port.setter
    def control_plane_node_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "control_plane_node_port", value)

    @property
    @pulumi.getter(name="ingressHttpNodePort")
    def ingress_http_node_port(self) -> Optional[pulumi.Input[int]]:
        """
        NodePort for ingress service's http. The ingress service in the admin
        cluster is implemented as a Service of type NodePort (ex. 32527).
        """
        return pulumi.get(self, "ingress_http_node_port")

    @ingress_http_node_port.setter
    def ingress_http_node_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ingress_http_node_port", value)

    @property
    @pulumi.getter(name="ingressHttpsNodePort")
    def ingress_https_node_port(self) -> Optional[pulumi.Input[int]]:
        """
        NodePort for ingress service's https. The ingress service in the admin
        cluster is implemented as a Service of type NodePort (ex. 30139).
        """
        return pulumi.get(self, "ingress_https_node_port")

    @ingress_https_node_port.setter
    def ingress_https_node_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ingress_https_node_port", value)

    @property
    @pulumi.getter(name="konnectivityServerNodePort")
    def konnectivity_server_node_port(self) -> Optional[pulumi.Input[int]]:
        """
        NodePort for konnectivity server service running as a sidecar in each
        kube-apiserver pod (ex. 30564).
        """
        return pulumi.get(self, "konnectivity_server_node_port")

    @konnectivity_server_node_port.setter
    def konnectivity_server_node_port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "konnectivity_server_node_port", value)


@pulumi.input_type
class VMwareClusterLoadBalancerMetalLbConfigArgs:
    def __init__(__self__, *,
                 address_pools: pulumi.Input[Sequence[pulumi.Input['VMwareClusterLoadBalancerMetalLbConfigAddressPoolArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VMwareClusterLoadBalancerMetalLbConfigAddressPoolArgs']]] address_pools: AddressPools is a list of non-overlapping IP pools used by load balancer
               typed services. All addresses must be routable to load balancer nodes.
               IngressVIP must be included in the pools.
               Structure is documented below.
        """
        pulumi.set(__self__, "address_pools", address_pools)

    @property
    @pulumi.getter(name="addressPools")
    def address_pools(self) -> pulumi.Input[Sequence[pulumi.Input['VMwareClusterLoadBalancerMetalLbConfigAddressPoolArgs']]]:
        """
        AddressPools is a list of non-overlapping IP pools used by load balancer
        typed services. All addresses must be routable to load balancer nodes.
        IngressVIP must be included in the pools.
        Structure is documented below.
        """
        return pulumi.get(self, "address_pools")

    @address_pools.setter
    def address_pools(self, value: pulumi.Input[Sequence[pulumi.Input['VMwareClusterLoadBalancerMetalLbConfigAddressPoolArgs']]]):
        pulumi.set(self, "address_pools", value)


@pulumi.input_type
class VMwareClusterLoadBalancerMetalLbConfigAddressPoolArgs:
    def __init__(__self__, *,
                 addresses: pulumi.Input[Sequence[pulumi.Input[str]]],
                 pool: pulumi.Input[str],
                 avoid_buggy_ips: Optional[pulumi.Input[bool]] = None,
                 manual_assign: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] addresses: The addresses that are part of this pool. Each address
               must be either in the CIDR form (1.2.3.0/24) or range
               form (1.2.3.1-1.2.3.5).
        :param pulumi.Input[str] pool: The name of the address pool.
        :param pulumi.Input[bool] avoid_buggy_ips: If true, avoid using IPs ending in .0 or .255.
               This avoids buggy consumer devices mistakenly dropping IPv4 traffic for
               those special IP addresses.
        :param pulumi.Input[bool] manual_assign: If true, prevent IP addresses from being automatically assigned.
               
               <a name="nested_dataplane_v2"></a>The `dataplane_v2` block supports:
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "pool", pool)
        if avoid_buggy_ips is not None:
            pulumi.set(__self__, "avoid_buggy_ips", avoid_buggy_ips)
        if manual_assign is not None:
            pulumi.set(__self__, "manual_assign", manual_assign)

    @property
    @pulumi.getter
    def addresses(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        The addresses that are part of this pool. Each address
        must be either in the CIDR form (1.2.3.0/24) or range
        form (1.2.3.1-1.2.3.5).
        """
        return pulumi.get(self, "addresses")

    @addresses.setter
    def addresses(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "addresses", value)

    @property
    @pulumi.getter
    def pool(self) -> pulumi.Input[str]:
        """
        The name of the address pool.
        """
        return pulumi.get(self, "pool")

    @pool.setter
    def pool(self, value: pulumi.Input[str]):
        pulumi.set(self, "pool", value)

    @property
    @pulumi.getter(name="avoidBuggyIps")
    def avoid_buggy_ips(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, avoid using IPs ending in .0 or .255.
        This avoids buggy consumer devices mistakenly dropping IPv4 traffic for
        those special IP addresses.
        """
        return pulumi.get(self, "avoid_buggy_ips")

    @avoid_buggy_ips.setter
    def avoid_buggy_ips(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "avoid_buggy_ips", value)

    @property
    @pulumi.getter(name="manualAssign")
    def manual_assign(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, prevent IP addresses from being automatically assigned.

        <a name="nested_dataplane_v2"></a>The `dataplane_v2` block supports:
        """
        return pulumi.get(self, "manual_assign")

    @manual_assign.setter
    def manual_assign(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "manual_assign", value)


@pulumi.input_type
class VMwareClusterLoadBalancerVipConfigArgs:
    def __init__(__self__, *,
                 control_plane_vip: Optional[pulumi.Input[str]] = None,
                 ingress_vip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] control_plane_vip: The VIP which you previously set aside for the Kubernetes API of this cluster.
        :param pulumi.Input[str] ingress_vip: The VIP which you previously set aside for ingress traffic into this cluster.
               
               <a name="nested_f5_config"></a>The `f5_config` block supports:
        """
        if control_plane_vip is not None:
            pulumi.set(__self__, "control_plane_vip", control_plane_vip)
        if ingress_vip is not None:
            pulumi.set(__self__, "ingress_vip", ingress_vip)

    @property
    @pulumi.getter(name="controlPlaneVip")
    def control_plane_vip(self) -> Optional[pulumi.Input[str]]:
        """
        The VIP which you previously set aside for the Kubernetes API of this cluster.
        """
        return pulumi.get(self, "control_plane_vip")

    @control_plane_vip.setter
    def control_plane_vip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "control_plane_vip", value)

    @property
    @pulumi.getter(name="ingressVip")
    def ingress_vip(self) -> Optional[pulumi.Input[str]]:
        """
        The VIP which you previously set aside for ingress traffic into this cluster.

        <a name="nested_f5_config"></a>The `f5_config` block supports:
        """
        return pulumi.get(self, "ingress_vip")

    @ingress_vip.setter
    def ingress_vip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ingress_vip", value)


@pulumi.input_type
class VMwareClusterNetworkConfigArgs:
    def __init__(__self__, *,
                 pod_address_cidr_blocks: pulumi.Input[Sequence[pulumi.Input[str]]],
                 service_address_cidr_blocks: pulumi.Input[Sequence[pulumi.Input[str]]],
                 control_plane_v2_config: Optional[pulumi.Input['VMwareClusterNetworkConfigControlPlaneV2ConfigArgs']] = None,
                 dhcp_ip_config: Optional[pulumi.Input['VMwareClusterNetworkConfigDhcpIpConfigArgs']] = None,
                 host_config: Optional[pulumi.Input['VMwareClusterNetworkConfigHostConfigArgs']] = None,
                 static_ip_config: Optional[pulumi.Input['VMwareClusterNetworkConfigStaticIpConfigArgs']] = None,
                 vcenter_network: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] pod_address_cidr_blocks: All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges.
               Only a single range is supported. This field cannot be changed after creation.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] service_address_cidr_blocks: All services in the cluster are assigned an RFC1918 IPv4 address
               from these ranges. Only a single range is supported.. This field
               cannot be changed after creation.
        :param pulumi.Input['VMwareClusterNetworkConfigControlPlaneV2ConfigArgs'] control_plane_v2_config: Configuration for control plane V2 mode.
               Structure is documented below.
        :param pulumi.Input['VMwareClusterNetworkConfigDhcpIpConfigArgs'] dhcp_ip_config: Configuration settings for a DHCP IP configuration.
               Structure is documented below.
        :param pulumi.Input['VMwareClusterNetworkConfigHostConfigArgs'] host_config: Represents common network settings irrespective of the host's IP address.
               Structure is documented below.
        :param pulumi.Input['VMwareClusterNetworkConfigStaticIpConfigArgs'] static_ip_config: Configuration settings for a static IP configuration.
               Structure is documented below.
        :param pulumi.Input[str] vcenter_network: (Output)
               vcenter_network specifies vCenter network name. Inherited from the admin cluster.
        """
        pulumi.set(__self__, "pod_address_cidr_blocks", pod_address_cidr_blocks)
        pulumi.set(__self__, "service_address_cidr_blocks", service_address_cidr_blocks)
        if control_plane_v2_config is not None:
            pulumi.set(__self__, "control_plane_v2_config", control_plane_v2_config)
        if dhcp_ip_config is not None:
            pulumi.set(__self__, "dhcp_ip_config", dhcp_ip_config)
        if host_config is not None:
            pulumi.set(__self__, "host_config", host_config)
        if static_ip_config is not None:
            pulumi.set(__self__, "static_ip_config", static_ip_config)
        if vcenter_network is not None:
            pulumi.set(__self__, "vcenter_network", vcenter_network)

    @property
    @pulumi.getter(name="podAddressCidrBlocks")
    def pod_address_cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges.
        Only a single range is supported. This field cannot be changed after creation.
        """
        return pulumi.get(self, "pod_address_cidr_blocks")

    @pod_address_cidr_blocks.setter
    def pod_address_cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "pod_address_cidr_blocks", value)

    @property
    @pulumi.getter(name="serviceAddressCidrBlocks")
    def service_address_cidr_blocks(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        All services in the cluster are assigned an RFC1918 IPv4 address
        from these ranges. Only a single range is supported.. This field
        cannot be changed after creation.
        """
        return pulumi.get(self, "service_address_cidr_blocks")

    @service_address_cidr_blocks.setter
    def service_address_cidr_blocks(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "service_address_cidr_blocks", value)

    @property
    @pulumi.getter(name="controlPlaneV2Config")
    def control_plane_v2_config(self) -> Optional[pulumi.Input['VMwareClusterNetworkConfigControlPlaneV2ConfigArgs']]:
        """
        Configuration for control plane V2 mode.
        Structure is documented below.
        """
        return pulumi.get(self, "control_plane_v2_config")

    @control_plane_v2_config.setter
    def control_plane_v2_config(self, value: Optional[pulumi.Input['VMwareClusterNetworkConfigControlPlaneV2ConfigArgs']]):
        pulumi.set(self, "control_plane_v2_config", value)

    @property
    @pulumi.getter(name="dhcpIpConfig")
    def dhcp_ip_config(self) -> Optional[pulumi.Input['VMwareClusterNetworkConfigDhcpIpConfigArgs']]:
        """
        Configuration settings for a DHCP IP configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "dhcp_ip_config")

    @dhcp_ip_config.setter
    def dhcp_ip_config(self, value: Optional[pulumi.Input['VMwareClusterNetworkConfigDhcpIpConfigArgs']]):
        pulumi.set(self, "dhcp_ip_config", value)

    @property
    @pulumi.getter(name="hostConfig")
    def host_config(self) -> Optional[pulumi.Input['VMwareClusterNetworkConfigHostConfigArgs']]:
        """
        Represents common network settings irrespective of the host's IP address.
        Structure is documented below.
        """
        return pulumi.get(self, "host_config")

    @host_config.setter
    def host_config(self, value: Optional[pulumi.Input['VMwareClusterNetworkConfigHostConfigArgs']]):
        pulumi.set(self, "host_config", value)

    @property
    @pulumi.getter(name="staticIpConfig")
    def static_ip_config(self) -> Optional[pulumi.Input['VMwareClusterNetworkConfigStaticIpConfigArgs']]:
        """
        Configuration settings for a static IP configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "static_ip_config")

    @static_ip_config.setter
    def static_ip_config(self, value: Optional[pulumi.Input['VMwareClusterNetworkConfigStaticIpConfigArgs']]):
        pulumi.set(self, "static_ip_config", value)

    @property
    @pulumi.getter(name="vcenterNetwork")
    def vcenter_network(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        vcenter_network specifies vCenter network name. Inherited from the admin cluster.
        """
        return pulumi.get(self, "vcenter_network")

    @vcenter_network.setter
    def vcenter_network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "vcenter_network", value)


@pulumi.input_type
class VMwareClusterNetworkConfigControlPlaneV2ConfigArgs:
    def __init__(__self__, *,
                 control_plane_ip_block: Optional[pulumi.Input['VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockArgs']] = None):
        """
        :param pulumi.Input['VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockArgs'] control_plane_ip_block: Static IP addresses for the control plane nodes.
               Structure is documented below.
        """
        if control_plane_ip_block is not None:
            pulumi.set(__self__, "control_plane_ip_block", control_plane_ip_block)

    @property
    @pulumi.getter(name="controlPlaneIpBlock")
    def control_plane_ip_block(self) -> Optional[pulumi.Input['VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockArgs']]:
        """
        Static IP addresses for the control plane nodes.
        Structure is documented below.
        """
        return pulumi.get(self, "control_plane_ip_block")

    @control_plane_ip_block.setter
    def control_plane_ip_block(self, value: Optional[pulumi.Input['VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockArgs']]):
        pulumi.set(self, "control_plane_ip_block", value)


@pulumi.input_type
class VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockArgs:
    def __init__(__self__, *,
                 gateway: Optional[pulumi.Input[str]] = None,
                 ips: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIpArgs']]]] = None,
                 netmask: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] gateway: The network gateway used by the VMware User Cluster.
        :param pulumi.Input[Sequence[pulumi.Input['VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIpArgs']]] ips: The node's network configurations used by the VMware User Cluster.
               Structure is documented below.
        :param pulumi.Input[str] netmask: The netmask used by the VMware User Cluster.
        """
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[pulumi.Input[str]]:
        """
        The network gateway used by the VMware User Cluster.
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def ips(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIpArgs']]]]:
        """
        The node's network configurations used by the VMware User Cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIpArgs']]]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter
    def netmask(self) -> Optional[pulumi.Input[str]]:
        """
        The netmask used by the VMware User Cluster.
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "netmask", value)


@pulumi.input_type
class VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIpArgs:
    def __init__(__self__, *,
                 hostname: Optional[pulumi.Input[str]] = None,
                 ip: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hostname: Hostname of the machine. VM's name will be used if this field is empty.
        :param pulumi.Input[str] ip: IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname of the machine. VM's name will be used if this field is empty.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def ip(self) -> Optional[pulumi.Input[str]]:
        """
        IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ip", value)


@pulumi.input_type
class VMwareClusterNetworkConfigDhcpIpConfigArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] enabled: enabled is a flag to mark if DHCP IP allocation is
               used for VMware user clusters.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[bool]:
        """
        enabled is a flag to mark if DHCP IP allocation is
        used for VMware user clusters.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "enabled", value)


@pulumi.input_type
class VMwareClusterNetworkConfigHostConfigArgs:
    def __init__(__self__, *,
                 dns_search_domains: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 dns_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 ntp_servers: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_search_domains: DNS search domains.
               
               <a name="nested_control_plane_v2_config"></a>The `control_plane_v2_config` block supports:
        :param pulumi.Input[Sequence[pulumi.Input[str]]] dns_servers: DNS servers.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] ntp_servers: NTP servers.
        """
        if dns_search_domains is not None:
            pulumi.set(__self__, "dns_search_domains", dns_search_domains)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if ntp_servers is not None:
            pulumi.set(__self__, "ntp_servers", ntp_servers)

    @property
    @pulumi.getter(name="dnsSearchDomains")
    def dns_search_domains(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        DNS search domains.

        <a name="nested_control_plane_v2_config"></a>The `control_plane_v2_config` block supports:
        """
        return pulumi.get(self, "dns_search_domains")

    @dns_search_domains.setter
    def dns_search_domains(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_search_domains", value)

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        DNS servers.
        """
        return pulumi.get(self, "dns_servers")

    @dns_servers.setter
    def dns_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "dns_servers", value)

    @property
    @pulumi.getter(name="ntpServers")
    def ntp_servers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        NTP servers.
        """
        return pulumi.get(self, "ntp_servers")

    @ntp_servers.setter
    def ntp_servers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "ntp_servers", value)


@pulumi.input_type
class VMwareClusterNetworkConfigStaticIpConfigArgs:
    def __init__(__self__, *,
                 ip_blocks: pulumi.Input[Sequence[pulumi.Input['VMwareClusterNetworkConfigStaticIpConfigIpBlockArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VMwareClusterNetworkConfigStaticIpConfigIpBlockArgs']]] ip_blocks: Represents the configuration values for static IP allocation to nodes.
               Structure is documented below.
        """
        pulumi.set(__self__, "ip_blocks", ip_blocks)

    @property
    @pulumi.getter(name="ipBlocks")
    def ip_blocks(self) -> pulumi.Input[Sequence[pulumi.Input['VMwareClusterNetworkConfigStaticIpConfigIpBlockArgs']]]:
        """
        Represents the configuration values for static IP allocation to nodes.
        Structure is documented below.
        """
        return pulumi.get(self, "ip_blocks")

    @ip_blocks.setter
    def ip_blocks(self, value: pulumi.Input[Sequence[pulumi.Input['VMwareClusterNetworkConfigStaticIpConfigIpBlockArgs']]]):
        pulumi.set(self, "ip_blocks", value)


@pulumi.input_type
class VMwareClusterNetworkConfigStaticIpConfigIpBlockArgs:
    def __init__(__self__, *,
                 gateway: pulumi.Input[str],
                 ips: pulumi.Input[Sequence[pulumi.Input['VMwareClusterNetworkConfigStaticIpConfigIpBlockIpArgs']]],
                 netmask: pulumi.Input[str]):
        """
        :param pulumi.Input[str] gateway: The network gateway used by the VMware User Cluster.
        :param pulumi.Input[Sequence[pulumi.Input['VMwareClusterNetworkConfigStaticIpConfigIpBlockIpArgs']]] ips: The node's network configurations used by the VMware User Cluster.
               Structure is documented below.
        :param pulumi.Input[str] netmask: The netmask used by the VMware User Cluster.
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "netmask", netmask)

    @property
    @pulumi.getter
    def gateway(self) -> pulumi.Input[str]:
        """
        The network gateway used by the VMware User Cluster.
        """
        return pulumi.get(self, "gateway")

    @gateway.setter
    def gateway(self, value: pulumi.Input[str]):
        pulumi.set(self, "gateway", value)

    @property
    @pulumi.getter
    def ips(self) -> pulumi.Input[Sequence[pulumi.Input['VMwareClusterNetworkConfigStaticIpConfigIpBlockIpArgs']]]:
        """
        The node's network configurations used by the VMware User Cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "ips")

    @ips.setter
    def ips(self, value: pulumi.Input[Sequence[pulumi.Input['VMwareClusterNetworkConfigStaticIpConfigIpBlockIpArgs']]]):
        pulumi.set(self, "ips", value)

    @property
    @pulumi.getter
    def netmask(self) -> pulumi.Input[str]:
        """
        The netmask used by the VMware User Cluster.
        """
        return pulumi.get(self, "netmask")

    @netmask.setter
    def netmask(self, value: pulumi.Input[str]):
        pulumi.set(self, "netmask", value)


@pulumi.input_type
class VMwareClusterNetworkConfigStaticIpConfigIpBlockIpArgs:
    def __init__(__self__, *,
                 ip: pulumi.Input[str],
                 hostname: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] ip: IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        :param pulumi.Input[str] hostname: Hostname of the machine. VM's name will be used if this field is empty.
        """
        pulumi.set(__self__, "ip", ip)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter
    def ip(self) -> pulumi.Input[str]:
        """
        IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        """
        return pulumi.get(self, "ip")

    @ip.setter
    def ip(self, value: pulumi.Input[str]):
        pulumi.set(self, "ip", value)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[pulumi.Input[str]]:
        """
        Hostname of the machine. VM's name will be used if this field is empty.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "hostname", value)


@pulumi.input_type
class VMwareClusterStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareClusterStatusConditionArgs']]]] = None,
                 error_message: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VMwareClusterStatusConditionArgs']]] conditions: (Output)
               ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
               Structure is documented below.
        :param pulumi.Input[str] error_message: (Output)
               Human-friendly representation of the error message from the user cluster
               controller. The error message can be temporary as the user cluster
               controller creates a cluster or node pool. If the error message persists
               for a longer period of time, it can be used to surface error message to
               indicate real problems requiring user intervention.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VMwareClusterStatusConditionArgs']]]]:
        """
        (Output)
        ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareClusterStatusConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Human-friendly representation of the error message from the user cluster
        controller. The error message can be temporary as the user cluster
        controller creates a cluster or node pool. If the error message persists
        for a longer period of time, it can be used to surface error message to
        indicate real problems requiring user intervention.
        """
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_message", value)


@pulumi.input_type
class VMwareClusterStatusConditionArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] last_transition_time: (Output)
               Last time the condition transit from one status to another.
        :param pulumi.Input[str] message: (Output)
               Human-readable message indicating details about last transition.
        :param pulumi.Input[str] reason: (Output)
               Machine-readable message indicating details about last transition.
        :param pulumi.Input[str] state: (Output)
               The lifecycle state of the condition.
        :param pulumi.Input[str] type: (Output)
               Type of the condition.
               (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Human-readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Machine-readable message indicating details about last transition.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The lifecycle state of the condition.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Type of the condition.
        (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


@pulumi.input_type
class VMwareClusterStorageArgs:
    def __init__(__self__, *,
                 vsphere_csi_disabled: pulumi.Input[bool]):
        """
        :param pulumi.Input[bool] vsphere_csi_disabled: Whether or not to deploy vSphere CSI components in the VMware User Cluster.
               Enabled by default.
        """
        pulumi.set(__self__, "vsphere_csi_disabled", vsphere_csi_disabled)

    @property
    @pulumi.getter(name="vsphereCsiDisabled")
    def vsphere_csi_disabled(self) -> pulumi.Input[bool]:
        """
        Whether or not to deploy vSphere CSI components in the VMware User Cluster.
        Enabled by default.
        """
        return pulumi.get(self, "vsphere_csi_disabled")

    @vsphere_csi_disabled.setter
    def vsphere_csi_disabled(self, value: pulumi.Input[bool]):
        pulumi.set(self, "vsphere_csi_disabled", value)


@pulumi.input_type
class VMwareClusterUpgradePolicyArgs:
    def __init__(__self__, *,
                 control_plane_only: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] control_plane_only: Controls whether the upgrade applies to the control plane only.
        """
        if control_plane_only is not None:
            pulumi.set(__self__, "control_plane_only", control_plane_only)

    @property
    @pulumi.getter(name="controlPlaneOnly")
    def control_plane_only(self) -> Optional[pulumi.Input[bool]]:
        """
        Controls whether the upgrade applies to the control plane only.
        """
        return pulumi.get(self, "control_plane_only")

    @control_plane_only.setter
    def control_plane_only(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "control_plane_only", value)


@pulumi.input_type
class VMwareClusterValidationCheckArgs:
    def __init__(__self__, *,
                 options: Optional[pulumi.Input[str]] = None,
                 scenario: Optional[pulumi.Input[str]] = None,
                 statuses: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareClusterValidationCheckStatusArgs']]]] = None):
        """
        :param pulumi.Input[str] options: (Output)
               Options used for the validation check.
        :param pulumi.Input[str] scenario: (Output)
               The scenario when the preflight checks were run..
        :param pulumi.Input[Sequence[pulumi.Input['VMwareClusterValidationCheckStatusArgs']]] statuses: (Output)
               Specifies the detailed validation check status
               Structure is documented below.
        """
        if options is not None:
            pulumi.set(__self__, "options", options)
        if scenario is not None:
            pulumi.set(__self__, "scenario", scenario)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Options used for the validation check.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def scenario(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The scenario when the preflight checks were run..
        """
        return pulumi.get(self, "scenario")

    @scenario.setter
    def scenario(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "scenario", value)

    @property
    @pulumi.getter
    def statuses(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VMwareClusterValidationCheckStatusArgs']]]]:
        """
        (Output)
        Specifies the detailed validation check status
        Structure is documented below.
        """
        return pulumi.get(self, "statuses")

    @statuses.setter
    def statuses(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareClusterValidationCheckStatusArgs']]]]):
        pulumi.set(self, "statuses", value)


@pulumi.input_type
class VMwareClusterValidationCheckStatusArgs:
    def __init__(__self__, *,
                 results: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareClusterValidationCheckStatusResultArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VMwareClusterValidationCheckStatusResultArgs']]] results: (Output)
               Individual checks which failed as part of the Preflight check execution.
               Structure is documented below.
        """
        if results is not None:
            pulumi.set(__self__, "results", results)

    @property
    @pulumi.getter
    def results(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VMwareClusterValidationCheckStatusResultArgs']]]]:
        """
        (Output)
        Individual checks which failed as part of the Preflight check execution.
        Structure is documented below.
        """
        return pulumi.get(self, "results")

    @results.setter
    def results(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareClusterValidationCheckStatusResultArgs']]]]):
        pulumi.set(self, "results", value)


@pulumi.input_type
class VMwareClusterValidationCheckStatusResultArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[str]] = None,
                 description: Optional[pulumi.Input[str]] = None,
                 details: Optional[pulumi.Input[str]] = None,
                 options: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] category: (Output)
               The category of the validation.
        :param pulumi.Input[str] description: A human readable description of this VMware User Cluster.
        :param pulumi.Input[str] details: (Output)
               Detailed failure information, which might be unformatted.
        :param pulumi.Input[str] options: (Output)
               Options used for the validation check.
        :param pulumi.Input[str] reason: (Output)
               Machine-readable message indicating details about last transition.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The category of the validation.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A human readable description of this VMware User Cluster.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Detailed failure information, which might be unformatted.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter
    def options(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Options used for the validation check.
        """
        return pulumi.get(self, "options")

    @options.setter
    def options(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "options", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Machine-readable message indicating details about last transition.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)


@pulumi.input_type
class VMwareClusterVcenterArgs:
    def __init__(__self__, *,
                 address: Optional[pulumi.Input[str]] = None,
                 ca_cert_data: Optional[pulumi.Input[str]] = None,
                 cluster: Optional[pulumi.Input[str]] = None,
                 datacenter: Optional[pulumi.Input[str]] = None,
                 datastore: Optional[pulumi.Input[str]] = None,
                 folder: Optional[pulumi.Input[str]] = None,
                 resource_pool: Optional[pulumi.Input[str]] = None,
                 storage_policy_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] address: The load balancer's IP address.
        :param pulumi.Input[str] ca_cert_data: (Output)
               Contains the vCenter CA certificate public key for SSL verification.
        :param pulumi.Input[str] cluster: (Output)
               The name of the vCenter cluster for the user cluster.
        :param pulumi.Input[str] datacenter: (Output)
               The name of the vCenter datacenter for the user cluster.
        :param pulumi.Input[str] datastore: (Output)
               The Vsphere datastore used by the Control Plane Node.
        :param pulumi.Input[str] folder: (Output)
               The name of the vCenter folder for the user cluster.
        :param pulumi.Input[str] resource_pool: (Output)
               The name of the vCenter resource pool for the user cluster.
        :param pulumi.Input[str] storage_policy_name: (Output)
               The Vsphere storage policy used by the control plane Node.
               
               - - -
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if ca_cert_data is not None:
            pulumi.set(__self__, "ca_cert_data", ca_cert_data)
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if datastore is not None:
            pulumi.set(__self__, "datastore", datastore)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if resource_pool is not None:
            pulumi.set(__self__, "resource_pool", resource_pool)
        if storage_policy_name is not None:
            pulumi.set(__self__, "storage_policy_name", storage_policy_name)

    @property
    @pulumi.getter
    def address(self) -> Optional[pulumi.Input[str]]:
        """
        The load balancer's IP address.
        """
        return pulumi.get(self, "address")

    @address.setter
    def address(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "address", value)

    @property
    @pulumi.getter(name="caCertData")
    def ca_cert_data(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Contains the vCenter CA certificate public key for SSL verification.
        """
        return pulumi.get(self, "ca_cert_data")

    @ca_cert_data.setter
    def ca_cert_data(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_cert_data", value)

    @property
    @pulumi.getter
    def cluster(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The name of the vCenter cluster for the user cluster.
        """
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "cluster", value)

    @property
    @pulumi.getter
    def datacenter(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The name of the vCenter datacenter for the user cluster.
        """
        return pulumi.get(self, "datacenter")

    @datacenter.setter
    def datacenter(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datacenter", value)

    @property
    @pulumi.getter
    def datastore(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The Vsphere datastore used by the Control Plane Node.
        """
        return pulumi.get(self, "datastore")

    @datastore.setter
    def datastore(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore", value)

    @property
    @pulumi.getter
    def folder(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The name of the vCenter folder for the user cluster.
        """
        return pulumi.get(self, "folder")

    @folder.setter
    def folder(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder", value)

    @property
    @pulumi.getter(name="resourcePool")
    def resource_pool(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The name of the vCenter resource pool for the user cluster.
        """
        return pulumi.get(self, "resource_pool")

    @resource_pool.setter
    def resource_pool(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "resource_pool", value)

    @property
    @pulumi.getter(name="storagePolicyName")
    def storage_policy_name(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The Vsphere storage policy used by the control plane Node.

        - - -
        """
        return pulumi.get(self, "storage_policy_name")

    @storage_policy_name.setter
    def storage_policy_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "storage_policy_name", value)


@pulumi.input_type
class VMwareNodePoolConfigArgs:
    def __init__(__self__, *,
                 image_type: pulumi.Input[str],
                 boot_disk_size_gb: Optional[pulumi.Input[int]] = None,
                 cpus: Optional[pulumi.Input[int]] = None,
                 enable_load_balancer: Optional[pulumi.Input[bool]] = None,
                 image: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 memory_mb: Optional[pulumi.Input[int]] = None,
                 replicas: Optional[pulumi.Input[int]] = None,
                 taints: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareNodePoolConfigTaintArgs']]]] = None,
                 vsphere_configs: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareNodePoolConfigVsphereConfigArgs']]]] = None):
        """
        :param pulumi.Input[str] image_type: The OS image to be used for each node in a node pool.
               Currently `cos`, `ubuntu`, `ubuntu_containerd` and `windows` are supported.
        :param pulumi.Input[int] boot_disk_size_gb: VMware disk size to be used during creation.
        :param pulumi.Input[int] cpus: The number of CPUs for each node in the node pool.
        :param pulumi.Input[bool] enable_load_balancer: Allow node pool traffic to be load balanced. Only works for clusters with
               MetalLB load balancers.
        :param pulumi.Input[str] image: The OS image name in vCenter, only valid when using Windows.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: The map of Kubernetes labels (key/value pairs) to be applied to each node.
               These will added in addition to any default label(s) that
               Kubernetes may apply to the node.
               In case of conflict in label keys, the applied set may differ depending on
               the Kubernetes version -- it's best to assume the behavior is undefined
               and conflicts should be avoided.
        :param pulumi.Input[int] memory_mb: The megabytes of memory for each node in the node pool.
        :param pulumi.Input[int] replicas: The number of nodes in the node pool.
        :param pulumi.Input[Sequence[pulumi.Input['VMwareNodePoolConfigTaintArgs']]] taints: The initial taints assigned to nodes of this node pool.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['VMwareNodePoolConfigVsphereConfigArgs']]] vsphere_configs: (Output)
               Specifies the vSphere config for node pool.
               Structure is documented below.
        """
        pulumi.set(__self__, "image_type", image_type)
        if boot_disk_size_gb is not None:
            pulumi.set(__self__, "boot_disk_size_gb", boot_disk_size_gb)
        if cpus is not None:
            pulumi.set(__self__, "cpus", cpus)
        if enable_load_balancer is not None:
            pulumi.set(__self__, "enable_load_balancer", enable_load_balancer)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if memory_mb is not None:
            pulumi.set(__self__, "memory_mb", memory_mb)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if vsphere_configs is not None:
            pulumi.set(__self__, "vsphere_configs", vsphere_configs)

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> pulumi.Input[str]:
        """
        The OS image to be used for each node in a node pool.
        Currently `cos`, `ubuntu`, `ubuntu_containerd` and `windows` are supported.
        """
        return pulumi.get(self, "image_type")

    @image_type.setter
    def image_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "image_type", value)

    @property
    @pulumi.getter(name="bootDiskSizeGb")
    def boot_disk_size_gb(self) -> Optional[pulumi.Input[int]]:
        """
        VMware disk size to be used during creation.
        """
        return pulumi.get(self, "boot_disk_size_gb")

    @boot_disk_size_gb.setter
    def boot_disk_size_gb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "boot_disk_size_gb", value)

    @property
    @pulumi.getter
    def cpus(self) -> Optional[pulumi.Input[int]]:
        """
        The number of CPUs for each node in the node pool.
        """
        return pulumi.get(self, "cpus")

    @cpus.setter
    def cpus(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpus", value)

    @property
    @pulumi.getter(name="enableLoadBalancer")
    def enable_load_balancer(self) -> Optional[pulumi.Input[bool]]:
        """
        Allow node pool traffic to be load balanced. Only works for clusters with
        MetalLB load balancers.
        """
        return pulumi.get(self, "enable_load_balancer")

    @enable_load_balancer.setter
    def enable_load_balancer(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_load_balancer", value)

    @property
    @pulumi.getter
    def image(self) -> Optional[pulumi.Input[str]]:
        """
        The OS image name in vCenter, only valid when using Windows.
        """
        return pulumi.get(self, "image")

    @image.setter
    def image(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to each node.
        These will added in addition to any default label(s) that
        Kubernetes may apply to the node.
        In case of conflict in label keys, the applied set may differ depending on
        the Kubernetes version -- it's best to assume the behavior is undefined
        and conflicts should be avoided.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="memoryMb")
    def memory_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The megabytes of memory for each node in the node pool.
        """
        return pulumi.get(self, "memory_mb")

    @memory_mb.setter
    def memory_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "memory_mb", value)

    @property
    @pulumi.getter
    def replicas(self) -> Optional[pulumi.Input[int]]:
        """
        The number of nodes in the node pool.
        """
        return pulumi.get(self, "replicas")

    @replicas.setter
    def replicas(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "replicas", value)

    @property
    @pulumi.getter
    def taints(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VMwareNodePoolConfigTaintArgs']]]]:
        """
        The initial taints assigned to nodes of this node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "taints")

    @taints.setter
    def taints(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareNodePoolConfigTaintArgs']]]]):
        pulumi.set(self, "taints", value)

    @property
    @pulumi.getter(name="vsphereConfigs")
    def vsphere_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VMwareNodePoolConfigVsphereConfigArgs']]]]:
        """
        (Output)
        Specifies the vSphere config for node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "vsphere_configs")

    @vsphere_configs.setter
    def vsphere_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareNodePoolConfigVsphereConfigArgs']]]]):
        pulumi.set(self, "vsphere_configs", value)


@pulumi.input_type
class VMwareNodePoolConfigTaintArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str],
                 value: pulumi.Input[str],
                 effect: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] key: Key associated with the effect.
        :param pulumi.Input[str] value: Value associated with the effect.
        :param pulumi.Input[str] effect: Available taint effects.
               Possible values are: `EFFECT_UNSPECIFIED`, `NO_SCHEDULE`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
               
               <a name="nested_vsphere_config"></a>The `vsphere_config` block contains:
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)

    @property
    @pulumi.getter
    def value(self) -> pulumi.Input[str]:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: pulumi.Input[str]):
        pulumi.set(self, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[pulumi.Input[str]]:
        """
        Available taint effects.
        Possible values are: `EFFECT_UNSPECIFIED`, `NO_SCHEDULE`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.

        <a name="nested_vsphere_config"></a>The `vsphere_config` block contains:
        """
        return pulumi.get(self, "effect")

    @effect.setter
    def effect(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "effect", value)


@pulumi.input_type
class VMwareNodePoolConfigVsphereConfigArgs:
    def __init__(__self__, *,
                 datastore: Optional[pulumi.Input[str]] = None,
                 tags: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareNodePoolConfigVsphereConfigTagArgs']]]] = None):
        """
        :param pulumi.Input[str] datastore: (Output)
               The name of the vCenter datastore. Inherited from the user cluster.
        :param pulumi.Input[Sequence[pulumi.Input['VMwareNodePoolConfigVsphereConfigTagArgs']]] tags: (Output)
               Tags to apply to VMs.
               Structure is documented below.
               
               
               <a name="nested_tags"></a>The `tags` block contains:
        """
        if datastore is not None:
            pulumi.set(__self__, "datastore", datastore)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def datastore(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The name of the vCenter datastore. Inherited from the user cluster.
        """
        return pulumi.get(self, "datastore")

    @datastore.setter
    def datastore(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "datastore", value)

    @property
    @pulumi.getter
    def tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VMwareNodePoolConfigVsphereConfigTagArgs']]]]:
        """
        (Output)
        Tags to apply to VMs.
        Structure is documented below.


        <a name="nested_tags"></a>The `tags` block contains:
        """
        return pulumi.get(self, "tags")

    @tags.setter
    def tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareNodePoolConfigVsphereConfigTagArgs']]]]):
        pulumi.set(self, "tags", value)


@pulumi.input_type
class VMwareNodePoolConfigVsphereConfigTagArgs:
    def __init__(__self__, *,
                 category: Optional[pulumi.Input[str]] = None,
                 tag: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] category: (Output)
               The Vsphere tag category.
        :param pulumi.Input[str] tag: (Output)
               The Vsphere tag name.
               
               - - -
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def category(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The Vsphere tag category.
        """
        return pulumi.get(self, "category")

    @category.setter
    def category(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "category", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The Vsphere tag name.

        - - -
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "tag", value)


@pulumi.input_type
class VMwareNodePoolNodePoolAutoscalingArgs:
    def __init__(__self__, *,
                 max_replicas: pulumi.Input[int],
                 min_replicas: pulumi.Input[int]):
        """
        :param pulumi.Input[int] max_replicas: Maximum number of replicas in the NodePool.
        :param pulumi.Input[int] min_replicas: Minimum number of replicas in the NodePool.
        """
        pulumi.set(__self__, "max_replicas", max_replicas)
        pulumi.set(__self__, "min_replicas", min_replicas)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> pulumi.Input[int]:
        """
        Maximum number of replicas in the NodePool.
        """
        return pulumi.get(self, "max_replicas")

    @max_replicas.setter
    def max_replicas(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_replicas", value)

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> pulumi.Input[int]:
        """
        Minimum number of replicas in the NodePool.
        """
        return pulumi.get(self, "min_replicas")

    @min_replicas.setter
    def min_replicas(self, value: pulumi.Input[int]):
        pulumi.set(self, "min_replicas", value)


@pulumi.input_type
class VMwareNodePoolStatusArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareNodePoolStatusConditionArgs']]]] = None,
                 error_message: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['VMwareNodePoolStatusConditionArgs']]] conditions: (Output)
               ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
               Structure is documented below.
        :param pulumi.Input[str] error_message: (Output)
               Human-friendly representation of the error message from the user cluster
               controller. The error message can be temporary as the user cluster
               controller creates a cluster or node pool. If the error message persists
               for a longer period of time, it can be used to surface error message to
               indicate real problems requiring user intervention.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['VMwareNodePoolStatusConditionArgs']]]]:
        """
        (Output)
        ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['VMwareNodePoolStatusConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Human-friendly representation of the error message from the user cluster
        controller. The error message can be temporary as the user cluster
        controller creates a cluster or node pool. If the error message persists
        for a longer period of time, it can be used to surface error message to
        indicate real problems requiring user intervention.
        """
        return pulumi.get(self, "error_message")

    @error_message.setter
    def error_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "error_message", value)


@pulumi.input_type
class VMwareNodePoolStatusConditionArgs:
    def __init__(__self__, *,
                 last_transition_time: Optional[pulumi.Input[str]] = None,
                 message: Optional[pulumi.Input[str]] = None,
                 reason: Optional[pulumi.Input[str]] = None,
                 state: Optional[pulumi.Input[str]] = None,
                 type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] last_transition_time: (Output)
               Last time the condition transit from one status to another.
        :param pulumi.Input[str] message: (Output)
               Human-readable message indicating details about last transition.
        :param pulumi.Input[str] reason: (Output)
               Machine-readable message indicating details about last transition.
        :param pulumi.Input[str] state: (Output)
               The lifecycle state of the condition.
        :param pulumi.Input[str] type: (Output)
               Type of the condition.
               (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @last_transition_time.setter
    def last_transition_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "last_transition_time", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Human-readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)

    @property
    @pulumi.getter
    def reason(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Machine-readable message indicating details about last transition.
        """
        return pulumi.get(self, "reason")

    @reason.setter
    def reason(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reason", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The lifecycle state of the condition.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Type of the condition.
        (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type", value)


