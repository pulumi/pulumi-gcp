# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'BareMetalAdminClusterClusterOperations',
    'BareMetalAdminClusterControlPlane',
    'BareMetalAdminClusterControlPlaneApiServerArg',
    'BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfig',
    'BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig',
    'BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig',
    'BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint',
    'BareMetalAdminClusterFleet',
    'BareMetalAdminClusterLoadBalancer',
    'BareMetalAdminClusterLoadBalancerManualLbConfig',
    'BareMetalAdminClusterLoadBalancerPortConfig',
    'BareMetalAdminClusterLoadBalancerVipConfig',
    'BareMetalAdminClusterMaintenanceConfig',
    'BareMetalAdminClusterNetworkConfig',
    'BareMetalAdminClusterNetworkConfigIslandModeCidr',
    'BareMetalAdminClusterNodeAccessConfig',
    'BareMetalAdminClusterNodeConfig',
    'BareMetalAdminClusterProxy',
    'BareMetalAdminClusterSecurityConfig',
    'BareMetalAdminClusterSecurityConfigAuthorization',
    'BareMetalAdminClusterSecurityConfigAuthorizationAdminUser',
    'BareMetalAdminClusterStatus',
    'BareMetalAdminClusterStatusCondition',
    'BareMetalAdminClusterStorage',
    'BareMetalAdminClusterStorageLvpNodeMountsConfig',
    'BareMetalAdminClusterStorageLvpShareConfig',
    'BareMetalAdminClusterStorageLvpShareConfigLvpConfig',
    'BareMetalAdminClusterValidationCheck',
    'BareMetalAdminClusterValidationCheckStatus',
    'BareMetalAdminClusterValidationCheckStatusResult',
    'BareMetalClusterBinaryAuthorization',
    'BareMetalClusterClusterOperations',
    'BareMetalClusterControlPlane',
    'BareMetalClusterControlPlaneApiServerArg',
    'BareMetalClusterControlPlaneControlPlaneNodePoolConfig',
    'BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig',
    'BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig',
    'BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint',
    'BareMetalClusterFleet',
    'BareMetalClusterLoadBalancer',
    'BareMetalClusterLoadBalancerBgpLbConfig',
    'BareMetalClusterLoadBalancerBgpLbConfigAddressPool',
    'BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfig',
    'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfig',
    'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfig',
    'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfig',
    'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig',
    'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint',
    'BareMetalClusterLoadBalancerManualLbConfig',
    'BareMetalClusterLoadBalancerMetalLbConfig',
    'BareMetalClusterLoadBalancerMetalLbConfigAddressPool',
    'BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfig',
    'BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfig',
    'BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig',
    'BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint',
    'BareMetalClusterLoadBalancerPortConfig',
    'BareMetalClusterLoadBalancerVipConfig',
    'BareMetalClusterMaintenanceConfig',
    'BareMetalClusterNetworkConfig',
    'BareMetalClusterNetworkConfigIslandModeCidr',
    'BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfig',
    'BareMetalClusterNetworkConfigSrIovConfig',
    'BareMetalClusterNodeAccessConfig',
    'BareMetalClusterNodeConfig',
    'BareMetalClusterOsEnvironmentConfig',
    'BareMetalClusterProxy',
    'BareMetalClusterSecurityConfig',
    'BareMetalClusterSecurityConfigAuthorization',
    'BareMetalClusterSecurityConfigAuthorizationAdminUser',
    'BareMetalClusterStatus',
    'BareMetalClusterStatusCondition',
    'BareMetalClusterStorage',
    'BareMetalClusterStorageLvpNodeMountsConfig',
    'BareMetalClusterStorageLvpShareConfig',
    'BareMetalClusterStorageLvpShareConfigLvpConfig',
    'BareMetalClusterUpgradePolicy',
    'BareMetalClusterValidationCheck',
    'BareMetalClusterValidationCheckStatus',
    'BareMetalClusterValidationCheckStatusResult',
    'BareMetalNodePoolNodePoolConfig',
    'BareMetalNodePoolNodePoolConfigNodeConfig',
    'BareMetalNodePoolNodePoolConfigTaint',
    'BareMetalNodePoolStatus',
    'BareMetalNodePoolStatusCondition',
    'VMwareClusterAntiAffinityGroups',
    'VMwareClusterAuthorization',
    'VMwareClusterAuthorizationAdminUser',
    'VMwareClusterAutoRepairConfig',
    'VMwareClusterControlPlaneNode',
    'VMwareClusterControlPlaneNodeAutoResizeConfig',
    'VMwareClusterControlPlaneNodeVsphereConfig',
    'VMwareClusterDataplaneV2',
    'VMwareClusterFleet',
    'VMwareClusterLoadBalancer',
    'VMwareClusterLoadBalancerF5Config',
    'VMwareClusterLoadBalancerManualLbConfig',
    'VMwareClusterLoadBalancerMetalLbConfig',
    'VMwareClusterLoadBalancerMetalLbConfigAddressPool',
    'VMwareClusterLoadBalancerVipConfig',
    'VMwareClusterNetworkConfig',
    'VMwareClusterNetworkConfigControlPlaneV2Config',
    'VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlock',
    'VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIp',
    'VMwareClusterNetworkConfigDhcpIpConfig',
    'VMwareClusterNetworkConfigHostConfig',
    'VMwareClusterNetworkConfigStaticIpConfig',
    'VMwareClusterNetworkConfigStaticIpConfigIpBlock',
    'VMwareClusterNetworkConfigStaticIpConfigIpBlockIp',
    'VMwareClusterStatus',
    'VMwareClusterStatusCondition',
    'VMwareClusterStorage',
    'VMwareClusterUpgradePolicy',
    'VMwareClusterValidationCheck',
    'VMwareClusterValidationCheckStatus',
    'VMwareClusterValidationCheckStatusResult',
    'VMwareClusterVcenter',
    'VMwareNodePoolConfig',
    'VMwareNodePoolConfigTaint',
    'VMwareNodePoolConfigVsphereConfig',
    'VMwareNodePoolConfigVsphereConfigTag',
    'VMwareNodePoolNodePoolAutoscaling',
    'VMwareNodePoolStatus',
    'VMwareNodePoolStatusCondition',
    'VmwareAdminClusterAddonNode',
    'VmwareAdminClusterAddonNodeAutoResizeConfig',
    'VmwareAdminClusterAntiAffinityGroups',
    'VmwareAdminClusterAuthorization',
    'VmwareAdminClusterAuthorizationViewerUser',
    'VmwareAdminClusterAutoRepairConfig',
    'VmwareAdminClusterControlPlaneNode',
    'VmwareAdminClusterFleet',
    'VmwareAdminClusterLoadBalancer',
    'VmwareAdminClusterLoadBalancerF5Config',
    'VmwareAdminClusterLoadBalancerManualLbConfig',
    'VmwareAdminClusterLoadBalancerMetalLbConfig',
    'VmwareAdminClusterLoadBalancerVipConfig',
    'VmwareAdminClusterNetworkConfig',
    'VmwareAdminClusterNetworkConfigDhcpIpConfig',
    'VmwareAdminClusterNetworkConfigHaControlPlaneConfig',
    'VmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlock',
    'VmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockIp',
    'VmwareAdminClusterNetworkConfigHostConfig',
    'VmwareAdminClusterNetworkConfigStaticIpConfig',
    'VmwareAdminClusterNetworkConfigStaticIpConfigIpBlock',
    'VmwareAdminClusterNetworkConfigStaticIpConfigIpBlockIp',
    'VmwareAdminClusterPlatformConfig',
    'VmwareAdminClusterPlatformConfigBundle',
    'VmwareAdminClusterPlatformConfigBundleStatus',
    'VmwareAdminClusterPlatformConfigBundleStatusCondition',
    'VmwareAdminClusterPlatformConfigStatus',
    'VmwareAdminClusterPlatformConfigStatusCondition',
    'VmwareAdminClusterStatus',
    'VmwareAdminClusterStatusCondition',
    'VmwareAdminClusterVcenter',
]

@pulumi.output_type
class BareMetalAdminClusterClusterOperations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableApplicationLogs":
            suggest = "enable_application_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterClusterOperations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterClusterOperations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterClusterOperations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_application_logs: Optional[builtins.bool] = None):
        """
        :param builtins.bool enable_application_logs: Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        if enable_application_logs is not None:
            pulumi.set(__self__, "enable_application_logs", enable_application_logs)

    @property
    @pulumi.getter(name="enableApplicationLogs")
    def enable_application_logs(self) -> Optional[builtins.bool]:
        """
        Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        return pulumi.get(self, "enable_application_logs")


@pulumi.output_type
class BareMetalAdminClusterControlPlane(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneNodePoolConfig":
            suggest = "control_plane_node_pool_config"
        elif key == "apiServerArgs":
            suggest = "api_server_args"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterControlPlane. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterControlPlane.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterControlPlane.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_node_pool_config: 'outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfig',
                 api_server_args: Optional[Sequence['outputs.BareMetalAdminClusterControlPlaneApiServerArg']] = None):
        """
        :param 'BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigArgs' control_plane_node_pool_config: Configures the node pool running the control plane. If specified the corresponding NodePool will be created for the cluster's control plane. The NodePool will have the same name and namespace as the cluster.
               Structure is documented below.
        :param Sequence['BareMetalAdminClusterControlPlaneApiServerArgArgs'] api_server_args: Customizes the default API server args. Only a subset of
               customized flags are supported. Please refer to the API server
               documentation below to know the exact format:
               https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
               Structure is documented below.
        """
        pulumi.set(__self__, "control_plane_node_pool_config", control_plane_node_pool_config)
        if api_server_args is not None:
            pulumi.set(__self__, "api_server_args", api_server_args)

    @property
    @pulumi.getter(name="controlPlaneNodePoolConfig")
    def control_plane_node_pool_config(self) -> 'outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfig':
        """
        Configures the node pool running the control plane. If specified the corresponding NodePool will be created for the cluster's control plane. The NodePool will have the same name and namespace as the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "control_plane_node_pool_config")

    @property
    @pulumi.getter(name="apiServerArgs")
    def api_server_args(self) -> Optional[Sequence['outputs.BareMetalAdminClusterControlPlaneApiServerArg']]:
        """
        Customizes the default API server args. Only a subset of
        customized flags are supported. Please refer to the API server
        documentation below to know the exact format:
        https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
        Structure is documented below.
        """
        return pulumi.get(self, "api_server_args")


@pulumi.output_type
class BareMetalAdminClusterControlPlaneApiServerArg(dict):
    def __init__(__self__, *,
                 argument: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str argument: The argument name as it appears on the API Server command line please make sure to remove the leading dashes.
        :param builtins.str value: The value of the arg as it will be passed to the API Server command line.
        """
        pulumi.set(__self__, "argument", argument)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def argument(self) -> builtins.str:
        """
        The argument name as it appears on the API Server command line please make sure to remove the leading dashes.
        """
        return pulumi.get(self, "argument")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        The value of the arg as it will be passed to the API Server command line.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodePoolConfig":
            suggest = "node_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_pool_config: 'outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig'):
        """
        :param 'BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigArgs' node_pool_config: The generic configuration for a node pool running the control plane.
               Structure is documented below.
        """
        pulumi.set(__self__, "node_pool_config", node_pool_config)

    @property
    @pulumi.getter(name="nodePoolConfig")
    def node_pool_config(self) -> 'outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig':
        """
        The generic configuration for a node pool running the control plane.
        Structure is documented below.
        """
        return pulumi.get(self, "node_pool_config")


@pulumi.output_type
class BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeConfigs":
            suggest = "node_configs"
        elif key == "operatingSystem":
            suggest = "operating_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Mapping[str, builtins.str]] = None,
                 node_configs: Optional[Sequence['outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig']] = None,
                 operating_system: Optional[builtins.str] = None,
                 taints: Optional[Sequence['outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint']] = None):
        """
        :param Mapping[str, builtins.str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               - http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param Sequence['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfigArgs'] node_configs: The list of machine addresses in the Bare Metal Node Pool.
               Structure is documented below.
        :param builtins.str operating_system: Specifies the nodes operating system (default: LINUX).
        :param Sequence['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaintArgs'] taints: The initial taints assigned to nodes of this node pool.
               Structure is documented below.
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_configs is not None:
            pulumi.set(__self__, "node_configs", node_configs)
        if operating_system is not None:
            pulumi.set(__self__, "operating_system", operating_system)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        - http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeConfigs")
    def node_configs(self) -> Optional[Sequence['outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig']]:
        """
        The list of machine addresses in the Bare Metal Node Pool.
        Structure is documented below.
        """
        return pulumi.get(self, "node_configs")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[builtins.str]:
        """
        Specifies the nodes operating system (default: LINUX).
        """
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint']]:
        """
        The initial taints assigned to nodes of this node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeIp":
            suggest = "node_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Mapping[str, builtins.str]] = None,
                 node_ip: Optional[builtins.str] = None):
        """
        :param Mapping[str, builtins.str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               - http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param builtins.str node_ip: The default IPv4 address for SSH access and Kubernetes node.
               Example: 192.168.0.1
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_ip is not None:
            pulumi.set(__self__, "node_ip", node_ip)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        - http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> Optional[builtins.str]:
        """
        The default IPv4 address for SSH access and Kubernetes node.
        Example: 192.168.0.1
        """
        return pulumi.get(self, "node_ip")


@pulumi.output_type
class BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[builtins.str] = None,
                 key: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str effect: Specifies the nodes operating system (default: LINUX).
               Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        :param builtins.str key: Key associated with the effect.
        :param builtins.str value: Value associated with the effect.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[builtins.str]:
        """
        Specifies the nodes operating system (default: LINUX).
        Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BareMetalAdminClusterFleet(dict):
    def __init__(__self__, *,
                 membership: Optional[builtins.str] = None):
        """
        :param builtins.str membership: (Output)
               The name of the managed Hub Membership resource associated to this cluster.
               Membership names are formatted as
               `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        if membership is not None:
            pulumi.set(__self__, "membership", membership)

    @property
    @pulumi.getter
    def membership(self) -> Optional[builtins.str]:
        """
        (Output)
        The name of the managed Hub Membership resource associated to this cluster.
        Membership names are formatted as
        `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        return pulumi.get(self, "membership")


@pulumi.output_type
class BareMetalAdminClusterLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portConfig":
            suggest = "port_config"
        elif key == "vipConfig":
            suggest = "vip_config"
        elif key == "manualLbConfig":
            suggest = "manual_lb_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_config: 'outputs.BareMetalAdminClusterLoadBalancerPortConfig',
                 vip_config: 'outputs.BareMetalAdminClusterLoadBalancerVipConfig',
                 manual_lb_config: Optional['outputs.BareMetalAdminClusterLoadBalancerManualLbConfig'] = None):
        """
        :param 'BareMetalAdminClusterLoadBalancerPortConfigArgs' port_config: Specifies the load balancer ports.
               Structure is documented below.
        :param 'BareMetalAdminClusterLoadBalancerVipConfigArgs' vip_config: Specified the Bare Metal Load Balancer Config
               Structure is documented below.
        :param 'BareMetalAdminClusterLoadBalancerManualLbConfigArgs' manual_lb_config: A nested object resource.
               Structure is documented below.
        """
        pulumi.set(__self__, "port_config", port_config)
        pulumi.set(__self__, "vip_config", vip_config)
        if manual_lb_config is not None:
            pulumi.set(__self__, "manual_lb_config", manual_lb_config)

    @property
    @pulumi.getter(name="portConfig")
    def port_config(self) -> 'outputs.BareMetalAdminClusterLoadBalancerPortConfig':
        """
        Specifies the load balancer ports.
        Structure is documented below.
        """
        return pulumi.get(self, "port_config")

    @property
    @pulumi.getter(name="vipConfig")
    def vip_config(self) -> 'outputs.BareMetalAdminClusterLoadBalancerVipConfig':
        """
        Specified the Bare Metal Load Balancer Config
        Structure is documented below.
        """
        return pulumi.get(self, "vip_config")

    @property
    @pulumi.getter(name="manualLbConfig")
    def manual_lb_config(self) -> Optional['outputs.BareMetalAdminClusterLoadBalancerManualLbConfig']:
        """
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "manual_lb_config")


@pulumi.output_type
class BareMetalAdminClusterLoadBalancerManualLbConfig(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool):
        """
        :param builtins.bool enabled: Whether manual load balancing is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether manual load balancing is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class BareMetalAdminClusterLoadBalancerPortConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneLoadBalancerPort":
            suggest = "control_plane_load_balancer_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterLoadBalancerPortConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterLoadBalancerPortConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterLoadBalancerPortConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_load_balancer_port: builtins.int):
        """
        :param builtins.int control_plane_load_balancer_port: The port that control plane hosted load balancers will listen on.
        """
        pulumi.set(__self__, "control_plane_load_balancer_port", control_plane_load_balancer_port)

    @property
    @pulumi.getter(name="controlPlaneLoadBalancerPort")
    def control_plane_load_balancer_port(self) -> builtins.int:
        """
        The port that control plane hosted load balancers will listen on.
        """
        return pulumi.get(self, "control_plane_load_balancer_port")


@pulumi.output_type
class BareMetalAdminClusterLoadBalancerVipConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneVip":
            suggest = "control_plane_vip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterLoadBalancerVipConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterLoadBalancerVipConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterLoadBalancerVipConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_vip: builtins.str):
        """
        :param builtins.str control_plane_vip: The VIP which you previously set aside for the Kubernetes API of this Bare Metal Admin Cluster.
        """
        pulumi.set(__self__, "control_plane_vip", control_plane_vip)

    @property
    @pulumi.getter(name="controlPlaneVip")
    def control_plane_vip(self) -> builtins.str:
        """
        The VIP which you previously set aside for the Kubernetes API of this Bare Metal Admin Cluster.
        """
        return pulumi.get(self, "control_plane_vip")


@pulumi.output_type
class BareMetalAdminClusterMaintenanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maintenanceAddressCidrBlocks":
            suggest = "maintenance_address_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterMaintenanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterMaintenanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterMaintenanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maintenance_address_cidr_blocks: Sequence[builtins.str]):
        """
        :param Sequence[builtins.str] maintenance_address_cidr_blocks: All IPv4 address from these ranges will be placed into maintenance mode.
               Nodes in maintenance mode will be cordoned and drained. When both of these
               are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set
               on the node resource.
        """
        pulumi.set(__self__, "maintenance_address_cidr_blocks", maintenance_address_cidr_blocks)

    @property
    @pulumi.getter(name="maintenanceAddressCidrBlocks")
    def maintenance_address_cidr_blocks(self) -> Sequence[builtins.str]:
        """
        All IPv4 address from these ranges will be placed into maintenance mode.
        Nodes in maintenance mode will be cordoned and drained. When both of these
        are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set
        on the node resource.
        """
        return pulumi.get(self, "maintenance_address_cidr_blocks")


@pulumi.output_type
class BareMetalAdminClusterNetworkConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "islandModeCidr":
            suggest = "island_mode_cidr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterNetworkConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterNetworkConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterNetworkConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 island_mode_cidr: Optional['outputs.BareMetalAdminClusterNetworkConfigIslandModeCidr'] = None):
        """
        :param 'BareMetalAdminClusterNetworkConfigIslandModeCidrArgs' island_mode_cidr: A nested object resource.
               Structure is documented below.
        """
        if island_mode_cidr is not None:
            pulumi.set(__self__, "island_mode_cidr", island_mode_cidr)

    @property
    @pulumi.getter(name="islandModeCidr")
    def island_mode_cidr(self) -> Optional['outputs.BareMetalAdminClusterNetworkConfigIslandModeCidr']:
        """
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "island_mode_cidr")


@pulumi.output_type
class BareMetalAdminClusterNetworkConfigIslandModeCidr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podAddressCidrBlocks":
            suggest = "pod_address_cidr_blocks"
        elif key == "serviceAddressCidrBlocks":
            suggest = "service_address_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterNetworkConfigIslandModeCidr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterNetworkConfigIslandModeCidr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterNetworkConfigIslandModeCidr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_address_cidr_blocks: Sequence[builtins.str],
                 service_address_cidr_blocks: Sequence[builtins.str]):
        """
        :param Sequence[builtins.str] pod_address_cidr_blocks: All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        :param Sequence[builtins.str] service_address_cidr_blocks: All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        pulumi.set(__self__, "pod_address_cidr_blocks", pod_address_cidr_blocks)
        pulumi.set(__self__, "service_address_cidr_blocks", service_address_cidr_blocks)

    @property
    @pulumi.getter(name="podAddressCidrBlocks")
    def pod_address_cidr_blocks(self) -> Sequence[builtins.str]:
        """
        All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        return pulumi.get(self, "pod_address_cidr_blocks")

    @property
    @pulumi.getter(name="serviceAddressCidrBlocks")
    def service_address_cidr_blocks(self) -> Sequence[builtins.str]:
        """
        All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        return pulumi.get(self, "service_address_cidr_blocks")


@pulumi.output_type
class BareMetalAdminClusterNodeAccessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loginUser":
            suggest = "login_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterNodeAccessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterNodeAccessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterNodeAccessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login_user: Optional[builtins.str] = None):
        """
        :param builtins.str login_user: LoginUser is the user name used to access node machines.
               It defaults to "root" if not set.
        """
        if login_user is not None:
            pulumi.set(__self__, "login_user", login_user)

    @property
    @pulumi.getter(name="loginUser")
    def login_user(self) -> Optional[builtins.str]:
        """
        LoginUser is the user name used to access node machines.
        It defaults to "root" if not set.
        """
        return pulumi.get(self, "login_user")


@pulumi.output_type
class BareMetalAdminClusterNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxPodsPerNode":
            suggest = "max_pods_per_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_pods_per_node: Optional[builtins.int] = None):
        """
        :param builtins.int max_pods_per_node: The maximum number of pods a node can run. The size of the CIDR range
               assigned to the node will be derived from this parameter.
        """
        if max_pods_per_node is not None:
            pulumi.set(__self__, "max_pods_per_node", max_pods_per_node)

    @property
    @pulumi.getter(name="maxPodsPerNode")
    def max_pods_per_node(self) -> Optional[builtins.int]:
        """
        The maximum number of pods a node can run. The size of the CIDR range
        assigned to the node will be derived from this parameter.
        """
        return pulumi.get(self, "max_pods_per_node")


@pulumi.output_type
class BareMetalAdminClusterProxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noProxies":
            suggest = "no_proxies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterProxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterProxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterProxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: builtins.str,
                 no_proxies: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str uri: Specifies the address of your proxy server.
               For Example: http://domain
               WARNING: Do not provide credentials in the format
               of http://(username:password@)domain these will be rejected by the server.
        :param Sequence[builtins.str] no_proxies: A list of IPs, hostnames, and domains that should skip the proxy.
               For example: ["127.0.0.1", "example.com", ".corp", "localhost"].
        """
        pulumi.set(__self__, "uri", uri)
        if no_proxies is not None:
            pulumi.set(__self__, "no_proxies", no_proxies)

    @property
    @pulumi.getter
    def uri(self) -> builtins.str:
        """
        Specifies the address of your proxy server.
        For Example: http://domain
        WARNING: Do not provide credentials in the format
        of http://(username:password@)domain these will be rejected by the server.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="noProxies")
    def no_proxies(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of IPs, hostnames, and domains that should skip the proxy.
        For example: ["127.0.0.1", "example.com", ".corp", "localhost"].
        """
        return pulumi.get(self, "no_proxies")


@pulumi.output_type
class BareMetalAdminClusterSecurityConfig(dict):
    def __init__(__self__, *,
                 authorization: Optional['outputs.BareMetalAdminClusterSecurityConfigAuthorization'] = None):
        """
        :param 'BareMetalAdminClusterSecurityConfigAuthorizationArgs' authorization: Configures user access to the Bare Metal User cluster.
               Structure is documented below.
        """
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)

    @property
    @pulumi.getter
    def authorization(self) -> Optional['outputs.BareMetalAdminClusterSecurityConfigAuthorization']:
        """
        Configures user access to the Bare Metal User cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "authorization")


@pulumi.output_type
class BareMetalAdminClusterSecurityConfigAuthorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsers":
            suggest = "admin_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterSecurityConfigAuthorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterSecurityConfigAuthorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterSecurityConfigAuthorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_users: Sequence['outputs.BareMetalAdminClusterSecurityConfigAuthorizationAdminUser']):
        """
        :param Sequence['BareMetalAdminClusterSecurityConfigAuthorizationAdminUserArgs'] admin_users: Users that will be granted the cluster-admin role on the cluster, providing full access to the cluster.
               Structure is documented below.
        """
        pulumi.set(__self__, "admin_users", admin_users)

    @property
    @pulumi.getter(name="adminUsers")
    def admin_users(self) -> Sequence['outputs.BareMetalAdminClusterSecurityConfigAuthorizationAdminUser']:
        """
        Users that will be granted the cluster-admin role on the cluster, providing full access to the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "admin_users")


@pulumi.output_type
class BareMetalAdminClusterSecurityConfigAuthorizationAdminUser(dict):
    def __init__(__self__, *,
                 username: builtins.str):
        """
        :param builtins.str username: The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def username(self) -> builtins.str:
        """
        The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class BareMetalAdminClusterStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.BareMetalAdminClusterStatusCondition']] = None,
                 error_message: Optional[builtins.str] = None):
        """
        :param Sequence['BareMetalAdminClusterStatusConditionArgs'] conditions: (Output)
               ResourceConditions provide a standard mechanism for higher-level status reporting from admin cluster controller.
               Structure is documented below.
        :param builtins.str error_message: (Output)
               Human-friendly representation of the error message from the admin cluster
               controller. The error message can be temporary as the admin cluster
               controller creates a cluster or node pool. If the error message persists
               for a longer period of time, it can be used to surface error message to
               indicate real problems requiring user intervention.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.BareMetalAdminClusterStatusCondition']]:
        """
        (Output)
        ResourceConditions provide a standard mechanism for higher-level status reporting from admin cluster controller.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[builtins.str]:
        """
        (Output)
        Human-friendly representation of the error message from the admin cluster
        controller. The error message can be temporary as the admin cluster
        controller creates a cluster or node pool. If the error message persists
        for a longer period of time, it can be used to surface error message to
        indicate real problems requiring user intervention.
        """
        return pulumi.get(self, "error_message")


@pulumi.output_type
class BareMetalAdminClusterStatusCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterStatusCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterStatusCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterStatusCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[builtins.str] = None,
                 message: Optional[builtins.str] = None,
                 reason: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str last_transition_time: (Output)
               Last time the condition transit from one status to another.
        :param builtins.str message: Human-readable message indicating details about last transition.
        :param builtins.str reason: (Output)
               A human-readable message of the check failure.
        :param builtins.str state: (Output)
               The lifecycle state of the condition.
        :param builtins.str type: Type of the condition.
               (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[builtins.str]:
        """
        (Output)
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        Human-readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[builtins.str]:
        """
        (Output)
        A human-readable message of the check failure.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        (Output)
        The lifecycle state of the condition.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the condition.
        (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class BareMetalAdminClusterStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lvpNodeMountsConfig":
            suggest = "lvp_node_mounts_config"
        elif key == "lvpShareConfig":
            suggest = "lvp_share_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lvp_node_mounts_config: 'outputs.BareMetalAdminClusterStorageLvpNodeMountsConfig',
                 lvp_share_config: 'outputs.BareMetalAdminClusterStorageLvpShareConfig'):
        """
        :param 'BareMetalAdminClusterStorageLvpNodeMountsConfigArgs' lvp_node_mounts_config: Specifies the config for local PersistentVolumes backed
               by mounted node disks. These disks need to be formatted and mounted by the
               user, which can be done before or after cluster creation.
               Structure is documented below.
        :param 'BareMetalAdminClusterStorageLvpShareConfigArgs' lvp_share_config: Specifies the config for local PersistentVolumes backed by
               subdirectories in a shared filesystem. These subdirectores are
               automatically created during cluster creation.
               Structure is documented below.
        """
        pulumi.set(__self__, "lvp_node_mounts_config", lvp_node_mounts_config)
        pulumi.set(__self__, "lvp_share_config", lvp_share_config)

    @property
    @pulumi.getter(name="lvpNodeMountsConfig")
    def lvp_node_mounts_config(self) -> 'outputs.BareMetalAdminClusterStorageLvpNodeMountsConfig':
        """
        Specifies the config for local PersistentVolumes backed
        by mounted node disks. These disks need to be formatted and mounted by the
        user, which can be done before or after cluster creation.
        Structure is documented below.
        """
        return pulumi.get(self, "lvp_node_mounts_config")

    @property
    @pulumi.getter(name="lvpShareConfig")
    def lvp_share_config(self) -> 'outputs.BareMetalAdminClusterStorageLvpShareConfig':
        """
        Specifies the config for local PersistentVolumes backed by
        subdirectories in a shared filesystem. These subdirectores are
        automatically created during cluster creation.
        Structure is documented below.
        """
        return pulumi.get(self, "lvp_share_config")


@pulumi.output_type
class BareMetalAdminClusterStorageLvpNodeMountsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterStorageLvpNodeMountsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterStorageLvpNodeMountsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterStorageLvpNodeMountsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: builtins.str,
                 storage_class: builtins.str):
        """
        :param builtins.str path: The host machine path.
        :param builtins.str storage_class: The StorageClass name that PVs will be created with.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def path(self) -> builtins.str:
        """
        The host machine path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> builtins.str:
        """
        The StorageClass name that PVs will be created with.
        """
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class BareMetalAdminClusterStorageLvpShareConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lvpConfig":
            suggest = "lvp_config"
        elif key == "sharedPathPvCount":
            suggest = "shared_path_pv_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterStorageLvpShareConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterStorageLvpShareConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterStorageLvpShareConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lvp_config: 'outputs.BareMetalAdminClusterStorageLvpShareConfigLvpConfig',
                 shared_path_pv_count: Optional[builtins.int] = None):
        """
        :param 'BareMetalAdminClusterStorageLvpShareConfigLvpConfigArgs' lvp_config: Defines the machine path and storage class for the LVP Share.
               Structure is documented below.
        :param builtins.int shared_path_pv_count: The number of subdirectories to create under path.
        """
        pulumi.set(__self__, "lvp_config", lvp_config)
        if shared_path_pv_count is not None:
            pulumi.set(__self__, "shared_path_pv_count", shared_path_pv_count)

    @property
    @pulumi.getter(name="lvpConfig")
    def lvp_config(self) -> 'outputs.BareMetalAdminClusterStorageLvpShareConfigLvpConfig':
        """
        Defines the machine path and storage class for the LVP Share.
        Structure is documented below.
        """
        return pulumi.get(self, "lvp_config")

    @property
    @pulumi.getter(name="sharedPathPvCount")
    def shared_path_pv_count(self) -> Optional[builtins.int]:
        """
        The number of subdirectories to create under path.
        """
        return pulumi.get(self, "shared_path_pv_count")


@pulumi.output_type
class BareMetalAdminClusterStorageLvpShareConfigLvpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterStorageLvpShareConfigLvpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterStorageLvpShareConfigLvpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterStorageLvpShareConfigLvpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: builtins.str,
                 storage_class: builtins.str):
        """
        :param builtins.str path: The host machine path.
        :param builtins.str storage_class: The StorageClass name that PVs will be created with.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def path(self) -> builtins.str:
        """
        The host machine path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> builtins.str:
        """
        The StorageClass name that PVs will be created with.
        """
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class BareMetalAdminClusterValidationCheck(dict):
    def __init__(__self__, *,
                 options: Optional[builtins.str] = None,
                 scenario: Optional[builtins.str] = None,
                 statuses: Optional[Sequence['outputs.BareMetalAdminClusterValidationCheckStatus']] = None):
        """
        :param builtins.str options: (Output)
               Options used for the validation check.
        :param builtins.str scenario: (Output)
               The scenario when the preflight checks were run..
        :param Sequence['BareMetalAdminClusterValidationCheckStatusArgs'] statuses: (Output)
               Specifies the detailed validation check status
               Structure is documented below.
        """
        if options is not None:
            pulumi.set(__self__, "options", options)
        if scenario is not None:
            pulumi.set(__self__, "scenario", scenario)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter
    def options(self) -> Optional[builtins.str]:
        """
        (Output)
        Options used for the validation check.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def scenario(self) -> Optional[builtins.str]:
        """
        (Output)
        The scenario when the preflight checks were run..
        """
        return pulumi.get(self, "scenario")

    @property
    @pulumi.getter
    def statuses(self) -> Optional[Sequence['outputs.BareMetalAdminClusterValidationCheckStatus']]:
        """
        (Output)
        Specifies the detailed validation check status
        Structure is documented below.
        """
        return pulumi.get(self, "statuses")


@pulumi.output_type
class BareMetalAdminClusterValidationCheckStatus(dict):
    def __init__(__self__, *,
                 results: Optional[Sequence['outputs.BareMetalAdminClusterValidationCheckStatusResult']] = None):
        """
        :param Sequence['BareMetalAdminClusterValidationCheckStatusResultArgs'] results: (Output)
               Individual checks which failed as part of the Preflight check execution.
               Structure is documented below.
        """
        if results is not None:
            pulumi.set(__self__, "results", results)

    @property
    @pulumi.getter
    def results(self) -> Optional[Sequence['outputs.BareMetalAdminClusterValidationCheckStatusResult']]:
        """
        (Output)
        Individual checks which failed as part of the Preflight check execution.
        Structure is documented below.
        """
        return pulumi.get(self, "results")


@pulumi.output_type
class BareMetalAdminClusterValidationCheckStatusResult(dict):
    def __init__(__self__, *,
                 category: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 details: Optional[builtins.str] = None,
                 options: Optional[builtins.str] = None,
                 reason: Optional[builtins.str] = None):
        """
        :param builtins.str category: (Output)
               The category of the validation.
        :param builtins.str description: A human readable description of this Bare Metal Admin Cluster.
        :param builtins.str details: (Output)
               Detailed failure information, which might be unformatted.
        :param builtins.str options: (Output)
               Options used for the validation check.
        :param builtins.str reason: (Output)
               A human-readable message of the check failure.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        (Output)
        The category of the validation.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        A human readable description of this Bare Metal Admin Cluster.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Optional[builtins.str]:
        """
        (Output)
        Detailed failure information, which might be unformatted.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def options(self) -> Optional[builtins.str]:
        """
        (Output)
        Options used for the validation check.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def reason(self) -> Optional[builtins.str]:
        """
        (Output)
        A human-readable message of the check failure.
        """
        return pulumi.get(self, "reason")


@pulumi.output_type
class BareMetalClusterBinaryAuthorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluationMode":
            suggest = "evaluation_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterBinaryAuthorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterBinaryAuthorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterBinaryAuthorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluation_mode: Optional[builtins.str] = None):
        """
        :param builtins.str evaluation_mode: Mode of operation for binauthz policy evaluation. If unspecified,
               defaults to DISABLED.
               Possible values are: `DISABLED`, `PROJECT_SINGLETON_POLICY_ENFORCE`.
        """
        if evaluation_mode is not None:
            pulumi.set(__self__, "evaluation_mode", evaluation_mode)

    @property
    @pulumi.getter(name="evaluationMode")
    def evaluation_mode(self) -> Optional[builtins.str]:
        """
        Mode of operation for binauthz policy evaluation. If unspecified,
        defaults to DISABLED.
        Possible values are: `DISABLED`, `PROJECT_SINGLETON_POLICY_ENFORCE`.
        """
        return pulumi.get(self, "evaluation_mode")


@pulumi.output_type
class BareMetalClusterClusterOperations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableApplicationLogs":
            suggest = "enable_application_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterClusterOperations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterClusterOperations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterClusterOperations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_application_logs: Optional[builtins.bool] = None):
        """
        :param builtins.bool enable_application_logs: Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        if enable_application_logs is not None:
            pulumi.set(__self__, "enable_application_logs", enable_application_logs)

    @property
    @pulumi.getter(name="enableApplicationLogs")
    def enable_application_logs(self) -> Optional[builtins.bool]:
        """
        Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        return pulumi.get(self, "enable_application_logs")


@pulumi.output_type
class BareMetalClusterControlPlane(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneNodePoolConfig":
            suggest = "control_plane_node_pool_config"
        elif key == "apiServerArgs":
            suggest = "api_server_args"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterControlPlane. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterControlPlane.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterControlPlane.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_node_pool_config: 'outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfig',
                 api_server_args: Optional[Sequence['outputs.BareMetalClusterControlPlaneApiServerArg']] = None):
        """
        :param 'BareMetalClusterControlPlaneControlPlaneNodePoolConfigArgs' control_plane_node_pool_config: Configures the node pool running the control plane. If specified the corresponding NodePool will be created for the cluster's control plane. The NodePool will have the same name and namespace as the cluster.
               Structure is documented below.
        :param Sequence['BareMetalClusterControlPlaneApiServerArgArgs'] api_server_args: Customizes the default API server args. Only a subset of
               customized flags are supported. Please refer to the API server
               documentation below to know the exact format:
               https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
               Structure is documented below.
        """
        pulumi.set(__self__, "control_plane_node_pool_config", control_plane_node_pool_config)
        if api_server_args is not None:
            pulumi.set(__self__, "api_server_args", api_server_args)

    @property
    @pulumi.getter(name="controlPlaneNodePoolConfig")
    def control_plane_node_pool_config(self) -> 'outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfig':
        """
        Configures the node pool running the control plane. If specified the corresponding NodePool will be created for the cluster's control plane. The NodePool will have the same name and namespace as the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "control_plane_node_pool_config")

    @property
    @pulumi.getter(name="apiServerArgs")
    def api_server_args(self) -> Optional[Sequence['outputs.BareMetalClusterControlPlaneApiServerArg']]:
        """
        Customizes the default API server args. Only a subset of
        customized flags are supported. Please refer to the API server
        documentation below to know the exact format:
        https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
        Structure is documented below.
        """
        return pulumi.get(self, "api_server_args")


@pulumi.output_type
class BareMetalClusterControlPlaneApiServerArg(dict):
    def __init__(__self__, *,
                 argument: builtins.str,
                 value: builtins.str):
        """
        :param builtins.str argument: The argument name as it appears on the API Server command line please make sure to remove the leading dashes.
        :param builtins.str value: The value of the arg as it will be passed to the API Server command line.
        """
        pulumi.set(__self__, "argument", argument)
        pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def argument(self) -> builtins.str:
        """
        The argument name as it appears on the API Server command line please make sure to remove the leading dashes.
        """
        return pulumi.get(self, "argument")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        The value of the arg as it will be passed to the API Server command line.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BareMetalClusterControlPlaneControlPlaneNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodePoolConfig":
            suggest = "node_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterControlPlaneControlPlaneNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterControlPlaneControlPlaneNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterControlPlaneControlPlaneNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_pool_config: 'outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig'):
        """
        :param 'BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigArgs' node_pool_config: The generic configuration for a node pool running the control plane.
               Structure is documented below.
        """
        pulumi.set(__self__, "node_pool_config", node_pool_config)

    @property
    @pulumi.getter(name="nodePoolConfig")
    def node_pool_config(self) -> 'outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig':
        """
        The generic configuration for a node pool running the control plane.
        Structure is documented below.
        """
        return pulumi.get(self, "node_pool_config")


@pulumi.output_type
class BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeConfigs":
            suggest = "node_configs"
        elif key == "operatingSystem":
            suggest = "operating_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Mapping[str, builtins.str]] = None,
                 node_configs: Optional[Sequence['outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig']] = None,
                 operating_system: Optional[builtins.str] = None,
                 taints: Optional[Sequence['outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint']] = None):
        """
        :param Mapping[str, builtins.str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               - http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param Sequence['BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfigArgs'] node_configs: The list of machine addresses in the Bare Metal Node Pool.
               Structure is documented below.
        :param builtins.str operating_system: Specifies the nodes operating system (default: LINUX).
        :param Sequence['BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaintArgs'] taints: The initial taints assigned to nodes of this node pool.
               Structure is documented below.
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_configs is not None:
            pulumi.set(__self__, "node_configs", node_configs)
        if operating_system is not None:
            pulumi.set(__self__, "operating_system", operating_system)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        - http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeConfigs")
    def node_configs(self) -> Optional[Sequence['outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig']]:
        """
        The list of machine addresses in the Bare Metal Node Pool.
        Structure is documented below.
        """
        return pulumi.get(self, "node_configs")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[builtins.str]:
        """
        Specifies the nodes operating system (default: LINUX).
        """
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint']]:
        """
        The initial taints assigned to nodes of this node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeIp":
            suggest = "node_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Mapping[str, builtins.str]] = None,
                 node_ip: Optional[builtins.str] = None):
        """
        :param Mapping[str, builtins.str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               - http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param builtins.str node_ip: The default IPv4 address for SSH access and Kubernetes node.
               Example: 192.168.0.1
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_ip is not None:
            pulumi.set(__self__, "node_ip", node_ip)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        - http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> Optional[builtins.str]:
        """
        The default IPv4 address for SSH access and Kubernetes node.
        Example: 192.168.0.1
        """
        return pulumi.get(self, "node_ip")


@pulumi.output_type
class BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[builtins.str] = None,
                 key: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str effect: Specifies the nodes operating system (default: LINUX).
               Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        :param builtins.str key: Key associated with the effect.
        :param builtins.str value: Value associated with the effect.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[builtins.str]:
        """
        Specifies the nodes operating system (default: LINUX).
        Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BareMetalClusterFleet(dict):
    def __init__(__self__, *,
                 membership: Optional[builtins.str] = None):
        """
        :param builtins.str membership: (Output)
               The name of the managed Hub Membership resource associated to this cluster.
               Membership names are formatted as
               `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        if membership is not None:
            pulumi.set(__self__, "membership", membership)

    @property
    @pulumi.getter
    def membership(self) -> Optional[builtins.str]:
        """
        (Output)
        The name of the managed Hub Membership resource associated to this cluster.
        Membership names are formatted as
        `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        return pulumi.get(self, "membership")


@pulumi.output_type
class BareMetalClusterLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portConfig":
            suggest = "port_config"
        elif key == "vipConfig":
            suggest = "vip_config"
        elif key == "bgpLbConfig":
            suggest = "bgp_lb_config"
        elif key == "manualLbConfig":
            suggest = "manual_lb_config"
        elif key == "metalLbConfig":
            suggest = "metal_lb_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_config: 'outputs.BareMetalClusterLoadBalancerPortConfig',
                 vip_config: 'outputs.BareMetalClusterLoadBalancerVipConfig',
                 bgp_lb_config: Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfig'] = None,
                 manual_lb_config: Optional['outputs.BareMetalClusterLoadBalancerManualLbConfig'] = None,
                 metal_lb_config: Optional['outputs.BareMetalClusterLoadBalancerMetalLbConfig'] = None):
        """
        :param 'BareMetalClusterLoadBalancerPortConfigArgs' port_config: Specifies the load balancer ports.
               Structure is documented below.
        :param 'BareMetalClusterLoadBalancerVipConfigArgs' vip_config: Specified the Bare Metal Load Balancer Config
               Structure is documented below.
        :param 'BareMetalClusterLoadBalancerBgpLbConfigArgs' bgp_lb_config: Configuration for BGP typed load balancers.
               Structure is documented below.
        :param 'BareMetalClusterLoadBalancerManualLbConfigArgs' manual_lb_config: A nested object resource.
               Structure is documented below.
        :param 'BareMetalClusterLoadBalancerMetalLbConfigArgs' metal_lb_config: A nested object resource.
               Structure is documented below.
        """
        pulumi.set(__self__, "port_config", port_config)
        pulumi.set(__self__, "vip_config", vip_config)
        if bgp_lb_config is not None:
            pulumi.set(__self__, "bgp_lb_config", bgp_lb_config)
        if manual_lb_config is not None:
            pulumi.set(__self__, "manual_lb_config", manual_lb_config)
        if metal_lb_config is not None:
            pulumi.set(__self__, "metal_lb_config", metal_lb_config)

    @property
    @pulumi.getter(name="portConfig")
    def port_config(self) -> 'outputs.BareMetalClusterLoadBalancerPortConfig':
        """
        Specifies the load balancer ports.
        Structure is documented below.
        """
        return pulumi.get(self, "port_config")

    @property
    @pulumi.getter(name="vipConfig")
    def vip_config(self) -> 'outputs.BareMetalClusterLoadBalancerVipConfig':
        """
        Specified the Bare Metal Load Balancer Config
        Structure is documented below.
        """
        return pulumi.get(self, "vip_config")

    @property
    @pulumi.getter(name="bgpLbConfig")
    def bgp_lb_config(self) -> Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfig']:
        """
        Configuration for BGP typed load balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "bgp_lb_config")

    @property
    @pulumi.getter(name="manualLbConfig")
    def manual_lb_config(self) -> Optional['outputs.BareMetalClusterLoadBalancerManualLbConfig']:
        """
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "manual_lb_config")

    @property
    @pulumi.getter(name="metalLbConfig")
    def metal_lb_config(self) -> Optional['outputs.BareMetalClusterLoadBalancerMetalLbConfig']:
        """
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "metal_lb_config")


@pulumi.output_type
class BareMetalClusterLoadBalancerBgpLbConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPools":
            suggest = "address_pools"
        elif key == "bgpPeerConfigs":
            suggest = "bgp_peer_configs"
        elif key == "loadBalancerNodePoolConfig":
            suggest = "load_balancer_node_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerBgpLbConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_pools: Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigAddressPool'],
                 asn: builtins.int,
                 bgp_peer_configs: Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfig'],
                 load_balancer_node_pool_config: Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfig'] = None):
        """
        :param Sequence['BareMetalClusterLoadBalancerBgpLbConfigAddressPoolArgs'] address_pools: AddressPools is a list of non-overlapping IP pools used by load balancer
               typed services. All addresses must be routable to load balancer nodes.
               IngressVIP must be included in the pools.
               Structure is documented below.
        :param builtins.int asn: BGP autonomous system number (ASN) of the cluster.
               This field can be updated after cluster creation.
        :param Sequence['BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfigArgs'] bgp_peer_configs: The list of BGP peers that the cluster will connect to.
               At least one peer must be configured for each control plane node.
               Control plane nodes will connect to these peers to advertise the control
               plane VIP. The Services load balancer also uses these peers by default.
               This field can be updated after cluster creation.
               Structure is documented below.
        :param 'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigArgs' load_balancer_node_pool_config: Specifies the node pool running data plane load balancing. L2 connectivity
               is required among nodes in this pool. If missing, the control plane node
               pool is used for data plane load balancing.
               Structure is documented below.
        """
        pulumi.set(__self__, "address_pools", address_pools)
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "bgp_peer_configs", bgp_peer_configs)
        if load_balancer_node_pool_config is not None:
            pulumi.set(__self__, "load_balancer_node_pool_config", load_balancer_node_pool_config)

    @property
    @pulumi.getter(name="addressPools")
    def address_pools(self) -> Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigAddressPool']:
        """
        AddressPools is a list of non-overlapping IP pools used by load balancer
        typed services. All addresses must be routable to load balancer nodes.
        IngressVIP must be included in the pools.
        Structure is documented below.
        """
        return pulumi.get(self, "address_pools")

    @property
    @pulumi.getter
    def asn(self) -> builtins.int:
        """
        BGP autonomous system number (ASN) of the cluster.
        This field can be updated after cluster creation.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="bgpPeerConfigs")
    def bgp_peer_configs(self) -> Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfig']:
        """
        The list of BGP peers that the cluster will connect to.
        At least one peer must be configured for each control plane node.
        Control plane nodes will connect to these peers to advertise the control
        plane VIP. The Services load balancer also uses these peers by default.
        This field can be updated after cluster creation.
        Structure is documented below.
        """
        return pulumi.get(self, "bgp_peer_configs")

    @property
    @pulumi.getter(name="loadBalancerNodePoolConfig")
    def load_balancer_node_pool_config(self) -> Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfig']:
        """
        Specifies the node pool running data plane load balancing. L2 connectivity
        is required among nodes in this pool. If missing, the control plane node
        pool is used for data plane load balancing.
        Structure is documented below.
        """
        return pulumi.get(self, "load_balancer_node_pool_config")


@pulumi.output_type
class BareMetalClusterLoadBalancerBgpLbConfigAddressPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avoidBuggyIps":
            suggest = "avoid_buggy_ips"
        elif key == "manualAssign":
            suggest = "manual_assign"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerBgpLbConfigAddressPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigAddressPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigAddressPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Sequence[builtins.str],
                 pool: builtins.str,
                 avoid_buggy_ips: Optional[builtins.bool] = None,
                 manual_assign: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] addresses: The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        :param builtins.str pool: The name of the address pool.
        :param builtins.bool avoid_buggy_ips: If true, avoid using IPs ending in .0 or .255.
               This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        :param builtins.str manual_assign: If true, prevent IP addresses from being automatically assigned.
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "pool", pool)
        if avoid_buggy_ips is not None:
            pulumi.set(__self__, "avoid_buggy_ips", avoid_buggy_ips)
        if manual_assign is not None:
            pulumi.set(__self__, "manual_assign", manual_assign)

    @property
    @pulumi.getter
    def addresses(self) -> Sequence[builtins.str]:
        """
        The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def pool(self) -> builtins.str:
        """
        The name of the address pool.
        """
        return pulumi.get(self, "pool")

    @property
    @pulumi.getter(name="avoidBuggyIps")
    def avoid_buggy_ips(self) -> Optional[builtins.bool]:
        """
        If true, avoid using IPs ending in .0 or .255.
        This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        """
        return pulumi.get(self, "avoid_buggy_ips")

    @property
    @pulumi.getter(name="manualAssign")
    def manual_assign(self) -> Optional[builtins.str]:
        """
        If true, prevent IP addresses from being automatically assigned.
        """
        return pulumi.get(self, "manual_assign")


@pulumi.output_type
class BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "controlPlaneNodes":
            suggest = "control_plane_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn: builtins.int,
                 ip_address: builtins.str,
                 control_plane_nodes: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.int asn: BGP autonomous system number (ASN) for the network that contains the
               external peer device.
        :param builtins.str ip_address: The IP address of the external peer device.
        :param Sequence[builtins.str] control_plane_nodes: The IP address of the control plane node that connects to the external
               peer.
               If you don't specify any control plane nodes, all control plane nodes
               can connect to the external peer. If you specify one or more IP addresses,
               only the nodes specified participate in peering sessions.
        """
        pulumi.set(__self__, "asn", asn)
        pulumi.set(__self__, "ip_address", ip_address)
        if control_plane_nodes is not None:
            pulumi.set(__self__, "control_plane_nodes", control_plane_nodes)

    @property
    @pulumi.getter
    def asn(self) -> builtins.int:
        """
        BGP autonomous system number (ASN) for the network that contains the
        external peer device.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> builtins.str:
        """
        The IP address of the external peer device.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="controlPlaneNodes")
    def control_plane_nodes(self) -> Optional[Sequence[builtins.str]]:
        """
        The IP address of the control plane node that connects to the external
        peer.
        If you don't specify any control plane nodes, all control plane nodes
        can connect to the external peer. If you specify one or more IP addresses,
        only the nodes specified participate in peering sessions.
        """
        return pulumi.get(self, "control_plane_nodes")


@pulumi.output_type
class BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodePoolConfig":
            suggest = "node_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_pool_config: Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfig'] = None):
        """
        :param 'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigArgs' node_pool_config: The generic configuration for a node pool running a load balancer.
               Structure is documented below.
        """
        if node_pool_config is not None:
            pulumi.set(__self__, "node_pool_config", node_pool_config)

    @property
    @pulumi.getter(name="nodePoolConfig")
    def node_pool_config(self) -> Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfig']:
        """
        The generic configuration for a node pool running a load balancer.
        Structure is documented below.
        """
        return pulumi.get(self, "node_pool_config")


@pulumi.output_type
class BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kubeletConfig":
            suggest = "kubelet_config"
        elif key == "nodeConfigs":
            suggest = "node_configs"
        elif key == "operatingSystem":
            suggest = "operating_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kubelet_config: Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfig'] = None,
                 labels: Optional[Mapping[str, builtins.str]] = None,
                 node_configs: Optional[Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig']] = None,
                 operating_system: Optional[builtins.str] = None,
                 taints: Optional[Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint']] = None):
        """
        :param 'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfigArgs' kubelet_config: The modifiable kubelet configurations for the baremetal machines.
               Structure is documented below.
        :param Mapping[str, builtins.str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               - http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param Sequence['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfigArgs'] node_configs: The list of machine addresses in the Bare Metal Node Pool.
               Structure is documented below.
        :param builtins.str operating_system: Specifies the nodes operating system (default: LINUX).
        :param Sequence['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaintArgs'] taints: The initial taints assigned to nodes of this node pool.
               Structure is documented below.
        """
        if kubelet_config is not None:
            pulumi.set(__self__, "kubelet_config", kubelet_config)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_configs is not None:
            pulumi.set(__self__, "node_configs", node_configs)
        if operating_system is not None:
            pulumi.set(__self__, "operating_system", operating_system)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter(name="kubeletConfig")
    def kubelet_config(self) -> Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfig']:
        """
        The modifiable kubelet configurations for the baremetal machines.
        Structure is documented below.
        """
        return pulumi.get(self, "kubelet_config")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        - http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeConfigs")
    def node_configs(self) -> Optional[Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig']]:
        """
        The list of machine addresses in the Bare Metal Node Pool.
        Structure is documented below.
        """
        return pulumi.get(self, "node_configs")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[builtins.str]:
        """
        Specifies the nodes operating system (default: LINUX).
        """
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint']]:
        """
        The initial taints assigned to nodes of this node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "registryBurst":
            suggest = "registry_burst"
        elif key == "registryPullQps":
            suggest = "registry_pull_qps"
        elif key == "serializeImagePullsDisabled":
            suggest = "serialize_image_pulls_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry_burst: Optional[builtins.int] = None,
                 registry_pull_qps: Optional[builtins.int] = None,
                 serialize_image_pulls_disabled: Optional[builtins.bool] = None):
        """
        :param builtins.int registry_burst: The maximum size of bursty pulls, temporarily allows pulls to burst to this
               number, while still not exceeding registry_pull_qps.
               The value must not be a negative number.
               Updating this field may impact scalability by changing the amount of
               traffic produced by image pulls.
               Defaults to 10.
        :param builtins.int registry_pull_qps: The limit of registry pulls per second.
               Setting this value to 0 means no limit.
               Updating this field may impact scalability by changing the amount of
               traffic produced by image pulls.
               Defaults to 5.
        :param builtins.bool serialize_image_pulls_disabled: Prevents the Kubelet from pulling multiple images at a time.
               We recommend *not* changing the default value on nodes that run docker
               daemon with version  < 1.9 or an Another Union File System (Aufs) storage
               backend. Issue https://github.com/kubernetes/kubernetes/issues/10959 has
               more details.
        """
        if registry_burst is not None:
            pulumi.set(__self__, "registry_burst", registry_burst)
        if registry_pull_qps is not None:
            pulumi.set(__self__, "registry_pull_qps", registry_pull_qps)
        if serialize_image_pulls_disabled is not None:
            pulumi.set(__self__, "serialize_image_pulls_disabled", serialize_image_pulls_disabled)

    @property
    @pulumi.getter(name="registryBurst")
    def registry_burst(self) -> Optional[builtins.int]:
        """
        The maximum size of bursty pulls, temporarily allows pulls to burst to this
        number, while still not exceeding registry_pull_qps.
        The value must not be a negative number.
        Updating this field may impact scalability by changing the amount of
        traffic produced by image pulls.
        Defaults to 10.
        """
        return pulumi.get(self, "registry_burst")

    @property
    @pulumi.getter(name="registryPullQps")
    def registry_pull_qps(self) -> Optional[builtins.int]:
        """
        The limit of registry pulls per second.
        Setting this value to 0 means no limit.
        Updating this field may impact scalability by changing the amount of
        traffic produced by image pulls.
        Defaults to 5.
        """
        return pulumi.get(self, "registry_pull_qps")

    @property
    @pulumi.getter(name="serializeImagePullsDisabled")
    def serialize_image_pulls_disabled(self) -> Optional[builtins.bool]:
        """
        Prevents the Kubelet from pulling multiple images at a time.
        We recommend *not* changing the default value on nodes that run docker
        daemon with version  < 1.9 or an Another Union File System (Aufs) storage
        backend. Issue https://github.com/kubernetes/kubernetes/issues/10959 has
        more details.
        """
        return pulumi.get(self, "serialize_image_pulls_disabled")


@pulumi.output_type
class BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeIp":
            suggest = "node_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Mapping[str, builtins.str]] = None,
                 node_ip: Optional[builtins.str] = None):
        """
        :param Mapping[str, builtins.str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               - http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param builtins.str node_ip: The default IPv4 address for SSH access and Kubernetes node.
               Example: 192.168.0.1
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_ip is not None:
            pulumi.set(__self__, "node_ip", node_ip)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        - http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> Optional[builtins.str]:
        """
        The default IPv4 address for SSH access and Kubernetes node.
        Example: 192.168.0.1
        """
        return pulumi.get(self, "node_ip")


@pulumi.output_type
class BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[builtins.str] = None,
                 key: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str effect: Specifies the nodes operating system (default: LINUX).
               Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        :param builtins.str key: Key associated with the effect.
        :param builtins.str value: Value associated with the effect.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[builtins.str]:
        """
        Specifies the nodes operating system (default: LINUX).
        Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BareMetalClusterLoadBalancerManualLbConfig(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool):
        """
        :param builtins.bool enabled: Whether manual load balancing is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether manual load balancing is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class BareMetalClusterLoadBalancerMetalLbConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPools":
            suggest = "address_pools"
        elif key == "loadBalancerNodePoolConfig":
            suggest = "load_balancer_node_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerMetalLbConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_pools: Sequence['outputs.BareMetalClusterLoadBalancerMetalLbConfigAddressPool'],
                 load_balancer_node_pool_config: Optional['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfig'] = None):
        """
        :param Sequence['BareMetalClusterLoadBalancerMetalLbConfigAddressPoolArgs'] address_pools: AddressPools is a list of non-overlapping IP pools used by load balancer
               typed services. All addresses must be routable to load balancer nodes.
               IngressVIP must be included in the pools.
               Structure is documented below.
        :param 'BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigArgs' load_balancer_node_pool_config: Specifies the load balancer's node pool configuration.
               Structure is documented below.
        """
        pulumi.set(__self__, "address_pools", address_pools)
        if load_balancer_node_pool_config is not None:
            pulumi.set(__self__, "load_balancer_node_pool_config", load_balancer_node_pool_config)

    @property
    @pulumi.getter(name="addressPools")
    def address_pools(self) -> Sequence['outputs.BareMetalClusterLoadBalancerMetalLbConfigAddressPool']:
        """
        AddressPools is a list of non-overlapping IP pools used by load balancer
        typed services. All addresses must be routable to load balancer nodes.
        IngressVIP must be included in the pools.
        Structure is documented below.
        """
        return pulumi.get(self, "address_pools")

    @property
    @pulumi.getter(name="loadBalancerNodePoolConfig")
    def load_balancer_node_pool_config(self) -> Optional['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfig']:
        """
        Specifies the load balancer's node pool configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "load_balancer_node_pool_config")


@pulumi.output_type
class BareMetalClusterLoadBalancerMetalLbConfigAddressPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avoidBuggyIps":
            suggest = "avoid_buggy_ips"
        elif key == "manualAssign":
            suggest = "manual_assign"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerMetalLbConfigAddressPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfigAddressPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfigAddressPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Sequence[builtins.str],
                 pool: builtins.str,
                 avoid_buggy_ips: Optional[builtins.bool] = None,
                 manual_assign: Optional[builtins.bool] = None):
        """
        :param Sequence[builtins.str] addresses: The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        :param builtins.str pool: The name of the address pool.
        :param builtins.bool avoid_buggy_ips: If true, avoid using IPs ending in .0 or .255.
               This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        :param builtins.bool manual_assign: If true, prevent IP addresses from being automatically assigned.
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "pool", pool)
        if avoid_buggy_ips is not None:
            pulumi.set(__self__, "avoid_buggy_ips", avoid_buggy_ips)
        if manual_assign is not None:
            pulumi.set(__self__, "manual_assign", manual_assign)

    @property
    @pulumi.getter
    def addresses(self) -> Sequence[builtins.str]:
        """
        The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def pool(self) -> builtins.str:
        """
        The name of the address pool.
        """
        return pulumi.get(self, "pool")

    @property
    @pulumi.getter(name="avoidBuggyIps")
    def avoid_buggy_ips(self) -> Optional[builtins.bool]:
        """
        If true, avoid using IPs ending in .0 or .255.
        This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        """
        return pulumi.get(self, "avoid_buggy_ips")

    @property
    @pulumi.getter(name="manualAssign")
    def manual_assign(self) -> Optional[builtins.bool]:
        """
        If true, prevent IP addresses from being automatically assigned.
        """
        return pulumi.get(self, "manual_assign")


@pulumi.output_type
class BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodePoolConfig":
            suggest = "node_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_pool_config: Optional['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfig'] = None):
        """
        :param 'BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigArgs' node_pool_config: The generic configuration for a node pool running a load balancer.
               Structure is documented below.
        """
        if node_pool_config is not None:
            pulumi.set(__self__, "node_pool_config", node_pool_config)

    @property
    @pulumi.getter(name="nodePoolConfig")
    def node_pool_config(self) -> Optional['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfig']:
        """
        The generic configuration for a node pool running a load balancer.
        Structure is documented below.
        """
        return pulumi.get(self, "node_pool_config")


@pulumi.output_type
class BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeConfigs":
            suggest = "node_configs"
        elif key == "operatingSystem":
            suggest = "operating_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Mapping[str, builtins.str]] = None,
                 node_configs: Optional[Sequence['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig']] = None,
                 operating_system: Optional[builtins.str] = None,
                 taints: Optional[Sequence['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint']] = None):
        """
        :param Mapping[str, builtins.str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               - http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param Sequence['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfigArgs'] node_configs: The list of machine addresses in the Bare Metal Node Pool.
               Structure is documented below.
        :param builtins.str operating_system: Specifies the nodes operating system (default: LINUX).
        :param Sequence['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaintArgs'] taints: The initial taints assigned to nodes of this node pool.
               Structure is documented below.
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_configs is not None:
            pulumi.set(__self__, "node_configs", node_configs)
        if operating_system is not None:
            pulumi.set(__self__, "operating_system", operating_system)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        - http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeConfigs")
    def node_configs(self) -> Optional[Sequence['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig']]:
        """
        The list of machine addresses in the Bare Metal Node Pool.
        Structure is documented below.
        """
        return pulumi.get(self, "node_configs")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[builtins.str]:
        """
        Specifies the nodes operating system (default: LINUX).
        """
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint']]:
        """
        The initial taints assigned to nodes of this node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeIp":
            suggest = "node_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Mapping[str, builtins.str]] = None,
                 node_ip: Optional[builtins.str] = None):
        """
        :param Mapping[str, builtins.str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               - http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param builtins.str node_ip: The default IPv4 address for SSH access and Kubernetes node.
               Example: 192.168.0.1
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_ip is not None:
            pulumi.set(__self__, "node_ip", node_ip)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        - http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> Optional[builtins.str]:
        """
        The default IPv4 address for SSH access and Kubernetes node.
        Example: 192.168.0.1
        """
        return pulumi.get(self, "node_ip")


@pulumi.output_type
class BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[builtins.str] = None,
                 key: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str effect: Specifies the nodes operating system (default: LINUX).
               Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        :param builtins.str key: Key associated with the effect.
        :param builtins.str value: Value associated with the effect.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[builtins.str]:
        """
        Specifies the nodes operating system (default: LINUX).
        Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BareMetalClusterLoadBalancerPortConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneLoadBalancerPort":
            suggest = "control_plane_load_balancer_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerPortConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerPortConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerPortConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_load_balancer_port: builtins.int):
        """
        :param builtins.int control_plane_load_balancer_port: The port that control plane hosted load balancers will listen on.
        """
        pulumi.set(__self__, "control_plane_load_balancer_port", control_plane_load_balancer_port)

    @property
    @pulumi.getter(name="controlPlaneLoadBalancerPort")
    def control_plane_load_balancer_port(self) -> builtins.int:
        """
        The port that control plane hosted load balancers will listen on.
        """
        return pulumi.get(self, "control_plane_load_balancer_port")


@pulumi.output_type
class BareMetalClusterLoadBalancerVipConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneVip":
            suggest = "control_plane_vip"
        elif key == "ingressVip":
            suggest = "ingress_vip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerVipConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerVipConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerVipConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_vip: builtins.str,
                 ingress_vip: builtins.str):
        """
        :param builtins.str control_plane_vip: The VIP which you previously set aside for the Kubernetes API of this Bare Metal User Cluster.
        :param builtins.str ingress_vip: The VIP which you previously set aside for ingress traffic into this Bare Metal User Cluster.
        """
        pulumi.set(__self__, "control_plane_vip", control_plane_vip)
        pulumi.set(__self__, "ingress_vip", ingress_vip)

    @property
    @pulumi.getter(name="controlPlaneVip")
    def control_plane_vip(self) -> builtins.str:
        """
        The VIP which you previously set aside for the Kubernetes API of this Bare Metal User Cluster.
        """
        return pulumi.get(self, "control_plane_vip")

    @property
    @pulumi.getter(name="ingressVip")
    def ingress_vip(self) -> builtins.str:
        """
        The VIP which you previously set aside for ingress traffic into this Bare Metal User Cluster.
        """
        return pulumi.get(self, "ingress_vip")


@pulumi.output_type
class BareMetalClusterMaintenanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maintenanceAddressCidrBlocks":
            suggest = "maintenance_address_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterMaintenanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterMaintenanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterMaintenanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maintenance_address_cidr_blocks: Sequence[builtins.str]):
        """
        :param Sequence[builtins.str] maintenance_address_cidr_blocks: All IPv4 address from these ranges will be placed into maintenance mode.
               Nodes in maintenance mode will be cordoned and drained. When both of these
               are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set
               on the node resource.
        """
        pulumi.set(__self__, "maintenance_address_cidr_blocks", maintenance_address_cidr_blocks)

    @property
    @pulumi.getter(name="maintenanceAddressCidrBlocks")
    def maintenance_address_cidr_blocks(self) -> Sequence[builtins.str]:
        """
        All IPv4 address from these ranges will be placed into maintenance mode.
        Nodes in maintenance mode will be cordoned and drained. When both of these
        are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set
        on the node resource.
        """
        return pulumi.get(self, "maintenance_address_cidr_blocks")


@pulumi.output_type
class BareMetalClusterNetworkConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedNetworking":
            suggest = "advanced_networking"
        elif key == "islandModeCidr":
            suggest = "island_mode_cidr"
        elif key == "multipleNetworkInterfacesConfig":
            suggest = "multiple_network_interfaces_config"
        elif key == "srIovConfig":
            suggest = "sr_iov_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterNetworkConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterNetworkConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterNetworkConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_networking: Optional[builtins.bool] = None,
                 island_mode_cidr: Optional['outputs.BareMetalClusterNetworkConfigIslandModeCidr'] = None,
                 multiple_network_interfaces_config: Optional['outputs.BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfig'] = None,
                 sr_iov_config: Optional['outputs.BareMetalClusterNetworkConfigSrIovConfig'] = None):
        """
        :param builtins.bool advanced_networking: Enables the use of advanced Anthos networking features, such as Bundled
               Load Balancing with BGP or the egress NAT gateway.
               Setting configuration for advanced networking features will automatically
               set this flag.
        :param 'BareMetalClusterNetworkConfigIslandModeCidrArgs' island_mode_cidr: A nested object resource.
               Structure is documented below.
        :param 'BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfigArgs' multiple_network_interfaces_config: Configuration for multiple network interfaces.
               Structure is documented below.
        :param 'BareMetalClusterNetworkConfigSrIovConfigArgs' sr_iov_config: Configuration for SR-IOV.
               Structure is documented below.
        """
        if advanced_networking is not None:
            pulumi.set(__self__, "advanced_networking", advanced_networking)
        if island_mode_cidr is not None:
            pulumi.set(__self__, "island_mode_cidr", island_mode_cidr)
        if multiple_network_interfaces_config is not None:
            pulumi.set(__self__, "multiple_network_interfaces_config", multiple_network_interfaces_config)
        if sr_iov_config is not None:
            pulumi.set(__self__, "sr_iov_config", sr_iov_config)

    @property
    @pulumi.getter(name="advancedNetworking")
    def advanced_networking(self) -> Optional[builtins.bool]:
        """
        Enables the use of advanced Anthos networking features, such as Bundled
        Load Balancing with BGP or the egress NAT gateway.
        Setting configuration for advanced networking features will automatically
        set this flag.
        """
        return pulumi.get(self, "advanced_networking")

    @property
    @pulumi.getter(name="islandModeCidr")
    def island_mode_cidr(self) -> Optional['outputs.BareMetalClusterNetworkConfigIslandModeCidr']:
        """
        A nested object resource.
        Structure is documented below.
        """
        return pulumi.get(self, "island_mode_cidr")

    @property
    @pulumi.getter(name="multipleNetworkInterfacesConfig")
    def multiple_network_interfaces_config(self) -> Optional['outputs.BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfig']:
        """
        Configuration for multiple network interfaces.
        Structure is documented below.
        """
        return pulumi.get(self, "multiple_network_interfaces_config")

    @property
    @pulumi.getter(name="srIovConfig")
    def sr_iov_config(self) -> Optional['outputs.BareMetalClusterNetworkConfigSrIovConfig']:
        """
        Configuration for SR-IOV.
        Structure is documented below.
        """
        return pulumi.get(self, "sr_iov_config")


@pulumi.output_type
class BareMetalClusterNetworkConfigIslandModeCidr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podAddressCidrBlocks":
            suggest = "pod_address_cidr_blocks"
        elif key == "serviceAddressCidrBlocks":
            suggest = "service_address_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterNetworkConfigIslandModeCidr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterNetworkConfigIslandModeCidr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterNetworkConfigIslandModeCidr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_address_cidr_blocks: Sequence[builtins.str],
                 service_address_cidr_blocks: Sequence[builtins.str]):
        """
        :param Sequence[builtins.str] pod_address_cidr_blocks: All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        :param Sequence[builtins.str] service_address_cidr_blocks: All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        pulumi.set(__self__, "pod_address_cidr_blocks", pod_address_cidr_blocks)
        pulumi.set(__self__, "service_address_cidr_blocks", service_address_cidr_blocks)

    @property
    @pulumi.getter(name="podAddressCidrBlocks")
    def pod_address_cidr_blocks(self) -> Sequence[builtins.str]:
        """
        All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        return pulumi.get(self, "pod_address_cidr_blocks")

    @property
    @pulumi.getter(name="serviceAddressCidrBlocks")
    def service_address_cidr_blocks(self) -> Sequence[builtins.str]:
        """
        All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        return pulumi.get(self, "service_address_cidr_blocks")


@pulumi.output_type
class BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None):
        """
        :param builtins.bool enabled: Whether to enable multiple network interfaces for your pods.
               When set network_config.advanced_networking is automatically
               set to true.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Whether to enable multiple network interfaces for your pods.
        When set network_config.advanced_networking is automatically
        set to true.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class BareMetalClusterNetworkConfigSrIovConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None):
        """
        :param builtins.bool enabled: Whether to install the SR-IOV operator.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Whether to install the SR-IOV operator.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class BareMetalClusterNodeAccessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loginUser":
            suggest = "login_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterNodeAccessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterNodeAccessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterNodeAccessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login_user: Optional[builtins.str] = None):
        """
        :param builtins.str login_user: LoginUser is the user name used to access node machines.
               It defaults to "root" if not set.
        """
        if login_user is not None:
            pulumi.set(__self__, "login_user", login_user)

    @property
    @pulumi.getter(name="loginUser")
    def login_user(self) -> Optional[builtins.str]:
        """
        LoginUser is the user name used to access node machines.
        It defaults to "root" if not set.
        """
        return pulumi.get(self, "login_user")


@pulumi.output_type
class BareMetalClusterNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerRuntime":
            suggest = "container_runtime"
        elif key == "maxPodsPerNode":
            suggest = "max_pods_per_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_runtime: Optional[builtins.str] = None,
                 max_pods_per_node: Optional[builtins.int] = None):
        """
        :param builtins.str container_runtime: The available runtimes that can be used to run containers in a Bare Metal User Cluster.
               Possible values are: `CONTAINER_RUNTIME_UNSPECIFIED`, `DOCKER`, `CONTAINERD`.
        :param builtins.int max_pods_per_node: The maximum number of pods a node can run. The size of the CIDR range
               assigned to the node will be derived from this parameter.
        """
        if container_runtime is not None:
            pulumi.set(__self__, "container_runtime", container_runtime)
        if max_pods_per_node is not None:
            pulumi.set(__self__, "max_pods_per_node", max_pods_per_node)

    @property
    @pulumi.getter(name="containerRuntime")
    def container_runtime(self) -> Optional[builtins.str]:
        """
        The available runtimes that can be used to run containers in a Bare Metal User Cluster.
        Possible values are: `CONTAINER_RUNTIME_UNSPECIFIED`, `DOCKER`, `CONTAINERD`.
        """
        return pulumi.get(self, "container_runtime")

    @property
    @pulumi.getter(name="maxPodsPerNode")
    def max_pods_per_node(self) -> Optional[builtins.int]:
        """
        The maximum number of pods a node can run. The size of the CIDR range
        assigned to the node will be derived from this parameter.
        """
        return pulumi.get(self, "max_pods_per_node")


@pulumi.output_type
class BareMetalClusterOsEnvironmentConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "packageRepoExcluded":
            suggest = "package_repo_excluded"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterOsEnvironmentConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterOsEnvironmentConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterOsEnvironmentConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 package_repo_excluded: builtins.bool):
        """
        :param builtins.bool package_repo_excluded: Whether the package repo should not be included when initializing
               bare metal machines.
        """
        pulumi.set(__self__, "package_repo_excluded", package_repo_excluded)

    @property
    @pulumi.getter(name="packageRepoExcluded")
    def package_repo_excluded(self) -> builtins.bool:
        """
        Whether the package repo should not be included when initializing
        bare metal machines.
        """
        return pulumi.get(self, "package_repo_excluded")


@pulumi.output_type
class BareMetalClusterProxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noProxies":
            suggest = "no_proxies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterProxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterProxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterProxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: builtins.str,
                 no_proxies: Optional[Sequence[builtins.str]] = None):
        """
        :param builtins.str uri: Specifies the address of your proxy server.
               For example: http://domain
               WARNING: Do not provide credentials in the format
               of http://(username:password@)domain these will be rejected by the server.
        :param Sequence[builtins.str] no_proxies: A list of IPs, hostnames, and domains that should skip the proxy.
               For example ["127.0.0.1", "example.com", ".corp", "localhost"].
        """
        pulumi.set(__self__, "uri", uri)
        if no_proxies is not None:
            pulumi.set(__self__, "no_proxies", no_proxies)

    @property
    @pulumi.getter
    def uri(self) -> builtins.str:
        """
        Specifies the address of your proxy server.
        For example: http://domain
        WARNING: Do not provide credentials in the format
        of http://(username:password@)domain these will be rejected by the server.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="noProxies")
    def no_proxies(self) -> Optional[Sequence[builtins.str]]:
        """
        A list of IPs, hostnames, and domains that should skip the proxy.
        For example ["127.0.0.1", "example.com", ".corp", "localhost"].
        """
        return pulumi.get(self, "no_proxies")


@pulumi.output_type
class BareMetalClusterSecurityConfig(dict):
    def __init__(__self__, *,
                 authorization: Optional['outputs.BareMetalClusterSecurityConfigAuthorization'] = None):
        """
        :param 'BareMetalClusterSecurityConfigAuthorizationArgs' authorization: Configures user access to the Bare Metal User cluster.
               Structure is documented below.
        """
        if authorization is not None:
            pulumi.set(__self__, "authorization", authorization)

    @property
    @pulumi.getter
    def authorization(self) -> Optional['outputs.BareMetalClusterSecurityConfigAuthorization']:
        """
        Configures user access to the Bare Metal User cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "authorization")


@pulumi.output_type
class BareMetalClusterSecurityConfigAuthorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsers":
            suggest = "admin_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterSecurityConfigAuthorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterSecurityConfigAuthorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterSecurityConfigAuthorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_users: Sequence['outputs.BareMetalClusterSecurityConfigAuthorizationAdminUser']):
        """
        :param Sequence['BareMetalClusterSecurityConfigAuthorizationAdminUserArgs'] admin_users: Users that will be granted the cluster-admin role on the cluster, providing full access to the cluster.
               Structure is documented below.
        """
        pulumi.set(__self__, "admin_users", admin_users)

    @property
    @pulumi.getter(name="adminUsers")
    def admin_users(self) -> Sequence['outputs.BareMetalClusterSecurityConfigAuthorizationAdminUser']:
        """
        Users that will be granted the cluster-admin role on the cluster, providing full access to the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "admin_users")


@pulumi.output_type
class BareMetalClusterSecurityConfigAuthorizationAdminUser(dict):
    def __init__(__self__, *,
                 username: builtins.str):
        """
        :param builtins.str username: The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def username(self) -> builtins.str:
        """
        The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class BareMetalClusterStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.BareMetalClusterStatusCondition']] = None,
                 error_message: Optional[builtins.str] = None):
        """
        :param Sequence['BareMetalClusterStatusConditionArgs'] conditions: (Output)
               ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
               Structure is documented below.
        :param builtins.str error_message: (Output)
               Human-friendly representation of the error message from the user cluster
               controller. The error message can be temporary as the user cluster
               controller creates a cluster or node pool. If the error message persists
               for a longer period of time, it can be used to surface error message to
               indicate real problems requiring user intervention.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.BareMetalClusterStatusCondition']]:
        """
        (Output)
        ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[builtins.str]:
        """
        (Output)
        Human-friendly representation of the error message from the user cluster
        controller. The error message can be temporary as the user cluster
        controller creates a cluster or node pool. If the error message persists
        for a longer period of time, it can be used to surface error message to
        indicate real problems requiring user intervention.
        """
        return pulumi.get(self, "error_message")


@pulumi.output_type
class BareMetalClusterStatusCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterStatusCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterStatusCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterStatusCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[builtins.str] = None,
                 message: Optional[builtins.str] = None,
                 reason: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str last_transition_time: (Output)
               Last time the condition transit from one status to another.
        :param builtins.str message: Human-readable message indicating details about last transition.
        :param builtins.str reason: (Output)
               A human-readable message of the check failure.
        :param builtins.str state: (Output)
               The lifecycle state of the condition.
        :param builtins.str type: Type of the condition.
               (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[builtins.str]:
        """
        (Output)
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        Human-readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[builtins.str]:
        """
        (Output)
        A human-readable message of the check failure.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        (Output)
        The lifecycle state of the condition.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the condition.
        (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class BareMetalClusterStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lvpNodeMountsConfig":
            suggest = "lvp_node_mounts_config"
        elif key == "lvpShareConfig":
            suggest = "lvp_share_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lvp_node_mounts_config: 'outputs.BareMetalClusterStorageLvpNodeMountsConfig',
                 lvp_share_config: 'outputs.BareMetalClusterStorageLvpShareConfig'):
        """
        :param 'BareMetalClusterStorageLvpNodeMountsConfigArgs' lvp_node_mounts_config: Specifies the config for local PersistentVolumes backed
               by mounted node disks. These disks need to be formatted and mounted by the
               user, which can be done before or after cluster creation.
               Structure is documented below.
        :param 'BareMetalClusterStorageLvpShareConfigArgs' lvp_share_config: Specifies the config for local PersistentVolumes backed by
               subdirectories in a shared filesystem. These subdirectores are
               automatically created during cluster creation.
               Structure is documented below.
        """
        pulumi.set(__self__, "lvp_node_mounts_config", lvp_node_mounts_config)
        pulumi.set(__self__, "lvp_share_config", lvp_share_config)

    @property
    @pulumi.getter(name="lvpNodeMountsConfig")
    def lvp_node_mounts_config(self) -> 'outputs.BareMetalClusterStorageLvpNodeMountsConfig':
        """
        Specifies the config for local PersistentVolumes backed
        by mounted node disks. These disks need to be formatted and mounted by the
        user, which can be done before or after cluster creation.
        Structure is documented below.
        """
        return pulumi.get(self, "lvp_node_mounts_config")

    @property
    @pulumi.getter(name="lvpShareConfig")
    def lvp_share_config(self) -> 'outputs.BareMetalClusterStorageLvpShareConfig':
        """
        Specifies the config for local PersistentVolumes backed by
        subdirectories in a shared filesystem. These subdirectores are
        automatically created during cluster creation.
        Structure is documented below.
        """
        return pulumi.get(self, "lvp_share_config")


@pulumi.output_type
class BareMetalClusterStorageLvpNodeMountsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterStorageLvpNodeMountsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterStorageLvpNodeMountsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterStorageLvpNodeMountsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: builtins.str,
                 storage_class: builtins.str):
        """
        :param builtins.str path: The host machine path.
        :param builtins.str storage_class: The StorageClass name that PVs will be created with.
               
               - - -
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def path(self) -> builtins.str:
        """
        The host machine path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> builtins.str:
        """
        The StorageClass name that PVs will be created with.

        - - -
        """
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class BareMetalClusterStorageLvpShareConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lvpConfig":
            suggest = "lvp_config"
        elif key == "sharedPathPvCount":
            suggest = "shared_path_pv_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterStorageLvpShareConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterStorageLvpShareConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterStorageLvpShareConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lvp_config: 'outputs.BareMetalClusterStorageLvpShareConfigLvpConfig',
                 shared_path_pv_count: Optional[builtins.int] = None):
        """
        :param 'BareMetalClusterStorageLvpShareConfigLvpConfigArgs' lvp_config: Defines the machine path and storage class for the LVP Share.
               Structure is documented below.
        :param builtins.int shared_path_pv_count: The number of subdirectories to create under path.
        """
        pulumi.set(__self__, "lvp_config", lvp_config)
        if shared_path_pv_count is not None:
            pulumi.set(__self__, "shared_path_pv_count", shared_path_pv_count)

    @property
    @pulumi.getter(name="lvpConfig")
    def lvp_config(self) -> 'outputs.BareMetalClusterStorageLvpShareConfigLvpConfig':
        """
        Defines the machine path and storage class for the LVP Share.
        Structure is documented below.
        """
        return pulumi.get(self, "lvp_config")

    @property
    @pulumi.getter(name="sharedPathPvCount")
    def shared_path_pv_count(self) -> Optional[builtins.int]:
        """
        The number of subdirectories to create under path.
        """
        return pulumi.get(self, "shared_path_pv_count")


@pulumi.output_type
class BareMetalClusterStorageLvpShareConfigLvpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterStorageLvpShareConfigLvpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterStorageLvpShareConfigLvpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterStorageLvpShareConfigLvpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: builtins.str,
                 storage_class: builtins.str):
        """
        :param builtins.str path: The host machine path.
        :param builtins.str storage_class: The StorageClass name that PVs will be created with.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "storage_class", storage_class)

    @property
    @pulumi.getter
    def path(self) -> builtins.str:
        """
        The host machine path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> builtins.str:
        """
        The StorageClass name that PVs will be created with.
        """
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class BareMetalClusterUpgradePolicy(dict):
    def __init__(__self__, *,
                 policy: Optional[builtins.str] = None):
        """
        :param builtins.str policy: Specifies which upgrade policy to use.
               Possible values are: `SERIAL`, `CONCURRENT`.
        """
        if policy is not None:
            pulumi.set(__self__, "policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> Optional[builtins.str]:
        """
        Specifies which upgrade policy to use.
        Possible values are: `SERIAL`, `CONCURRENT`.
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class BareMetalClusterValidationCheck(dict):
    def __init__(__self__, *,
                 options: Optional[builtins.str] = None,
                 scenario: Optional[builtins.str] = None,
                 statuses: Optional[Sequence['outputs.BareMetalClusterValidationCheckStatus']] = None):
        """
        :param builtins.str options: (Output)
               Options used for the validation check.
        :param builtins.str scenario: (Output)
               The scenario when the preflight checks were run..
        :param Sequence['BareMetalClusterValidationCheckStatusArgs'] statuses: (Output)
               Specifies the detailed validation check status
               Structure is documented below.
        """
        if options is not None:
            pulumi.set(__self__, "options", options)
        if scenario is not None:
            pulumi.set(__self__, "scenario", scenario)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter
    def options(self) -> Optional[builtins.str]:
        """
        (Output)
        Options used for the validation check.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def scenario(self) -> Optional[builtins.str]:
        """
        (Output)
        The scenario when the preflight checks were run..
        """
        return pulumi.get(self, "scenario")

    @property
    @pulumi.getter
    def statuses(self) -> Optional[Sequence['outputs.BareMetalClusterValidationCheckStatus']]:
        """
        (Output)
        Specifies the detailed validation check status
        Structure is documented below.
        """
        return pulumi.get(self, "statuses")


@pulumi.output_type
class BareMetalClusterValidationCheckStatus(dict):
    def __init__(__self__, *,
                 results: Optional[Sequence['outputs.BareMetalClusterValidationCheckStatusResult']] = None):
        """
        :param Sequence['BareMetalClusterValidationCheckStatusResultArgs'] results: (Output)
               Individual checks which failed as part of the Preflight check execution.
               Structure is documented below.
        """
        if results is not None:
            pulumi.set(__self__, "results", results)

    @property
    @pulumi.getter
    def results(self) -> Optional[Sequence['outputs.BareMetalClusterValidationCheckStatusResult']]:
        """
        (Output)
        Individual checks which failed as part of the Preflight check execution.
        Structure is documented below.
        """
        return pulumi.get(self, "results")


@pulumi.output_type
class BareMetalClusterValidationCheckStatusResult(dict):
    def __init__(__self__, *,
                 category: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 details: Optional[builtins.str] = None,
                 options: Optional[builtins.str] = None,
                 reason: Optional[builtins.str] = None):
        """
        :param builtins.str category: (Output)
               The category of the validation.
        :param builtins.str description: (Output)
               The description of the validation check.
        :param builtins.str details: (Output)
               Detailed failure information, which might be unformatted.
        :param builtins.str options: (Output)
               Options used for the validation check.
        :param builtins.str reason: (Output)
               A human-readable message of the check failure.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        (Output)
        The category of the validation.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        (Output)
        The description of the validation check.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Optional[builtins.str]:
        """
        (Output)
        Detailed failure information, which might be unformatted.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def options(self) -> Optional[builtins.str]:
        """
        (Output)
        Options used for the validation check.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def reason(self) -> Optional[builtins.str]:
        """
        (Output)
        A human-readable message of the check failure.
        """
        return pulumi.get(self, "reason")


@pulumi.output_type
class BareMetalNodePoolNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeConfigs":
            suggest = "node_configs"
        elif key == "operatingSystem":
            suggest = "operating_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalNodePoolNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalNodePoolNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalNodePoolNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_configs: Sequence['outputs.BareMetalNodePoolNodePoolConfigNodeConfig'],
                 labels: Optional[Mapping[str, builtins.str]] = None,
                 operating_system: Optional[builtins.str] = None,
                 taints: Optional[Sequence['outputs.BareMetalNodePoolNodePoolConfigTaint']] = None):
        """
        :param Sequence['BareMetalNodePoolNodePoolConfigNodeConfigArgs'] node_configs: The list of machine addresses in the Bare Metal Node Pool.
               Structure is documented below.
        :param Mapping[str, builtins.str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               - http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param builtins.str operating_system: Specifies the nodes operating system (default: LINUX).
        :param Sequence['BareMetalNodePoolNodePoolConfigTaintArgs'] taints: The initial taints assigned to nodes of this node pool.
               Structure is documented below.
        """
        pulumi.set(__self__, "node_configs", node_configs)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if operating_system is not None:
            pulumi.set(__self__, "operating_system", operating_system)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)

    @property
    @pulumi.getter(name="nodeConfigs")
    def node_configs(self) -> Sequence['outputs.BareMetalNodePoolNodePoolConfigNodeConfig']:
        """
        The list of machine addresses in the Bare Metal Node Pool.
        Structure is documented below.
        """
        return pulumi.get(self, "node_configs")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        - http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[builtins.str]:
        """
        Specifies the nodes operating system (default: LINUX).
        """
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.BareMetalNodePoolNodePoolConfigTaint']]:
        """
        The initial taints assigned to nodes of this node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class BareMetalNodePoolNodePoolConfigNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeIp":
            suggest = "node_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalNodePoolNodePoolConfigNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalNodePoolNodePoolConfigNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalNodePoolNodePoolConfigNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Mapping[str, builtins.str]] = None,
                 node_ip: Optional[builtins.str] = None):
        """
        :param Mapping[str, builtins.str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               - http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param builtins.str node_ip: The default IPv4 address for SSH access and Kubernetes node.
               Example: 192.168.0.1
        """
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if node_ip is not None:
            pulumi.set(__self__, "node_ip", node_ip)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        - http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        For example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> Optional[builtins.str]:
        """
        The default IPv4 address for SSH access and Kubernetes node.
        Example: 192.168.0.1
        """
        return pulumi.get(self, "node_ip")


@pulumi.output_type
class BareMetalNodePoolNodePoolConfigTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[builtins.str] = None,
                 key: Optional[builtins.str] = None,
                 value: Optional[builtins.str] = None):
        """
        :param builtins.str effect: Specifies the nodes operating system (default: LINUX).
               Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
               
               - - -
        :param builtins.str key: Key associated with the effect.
        :param builtins.str value: Value associated with the effect.
        """
        if effect is not None:
            pulumi.set(__self__, "effect", effect)
        if key is not None:
            pulumi.set(__self__, "key", key)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[builtins.str]:
        """
        Specifies the nodes operating system (default: LINUX).
        Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.

        - - -
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[builtins.str]:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[builtins.str]:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BareMetalNodePoolStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalNodePoolStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalNodePoolStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalNodePoolStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.BareMetalNodePoolStatusCondition']] = None,
                 error_message: Optional[builtins.str] = None):
        """
        :param Sequence['BareMetalNodePoolStatusConditionArgs'] conditions: (Output)
               ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
               Structure is documented below.
        :param builtins.str error_message: (Output)
               Human-friendly representation of the error message from the user cluster
               controller. The error message can be temporary as the user cluster
               controller creates a cluster or node pool. If the error message persists
               for a longer period of time, it can be used to surface error message to
               indicate real problems requiring user intervention.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.BareMetalNodePoolStatusCondition']]:
        """
        (Output)
        ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[builtins.str]:
        """
        (Output)
        Human-friendly representation of the error message from the user cluster
        controller. The error message can be temporary as the user cluster
        controller creates a cluster or node pool. If the error message persists
        for a longer period of time, it can be used to surface error message to
        indicate real problems requiring user intervention.
        """
        return pulumi.get(self, "error_message")


@pulumi.output_type
class BareMetalNodePoolStatusCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalNodePoolStatusCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalNodePoolStatusCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalNodePoolStatusCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[builtins.str] = None,
                 message: Optional[builtins.str] = None,
                 reason: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str last_transition_time: (Output)
               Last time the condition transit from one status to another.
        :param builtins.str message: Human-readable message indicating details about last transition.
        :param builtins.str reason: Machine-readable message indicating details about last transition.
        :param builtins.str state: (Output)
               The lifecycle state of the condition.
        :param builtins.str type: Type of the condition.
               (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[builtins.str]:
        """
        (Output)
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        Human-readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[builtins.str]:
        """
        Machine-readable message indicating details about last transition.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        (Output)
        The lifecycle state of the condition.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        Type of the condition.
        (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VMwareClusterAntiAffinityGroups(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aagConfigDisabled":
            suggest = "aag_config_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterAntiAffinityGroups. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterAntiAffinityGroups.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterAntiAffinityGroups.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aag_config_disabled: builtins.bool):
        """
        :param builtins.bool aag_config_disabled: Spread nodes across at least three physical hosts (requires at least three
               hosts).
               Enabled by default.
        """
        pulumi.set(__self__, "aag_config_disabled", aag_config_disabled)

    @property
    @pulumi.getter(name="aagConfigDisabled")
    def aag_config_disabled(self) -> builtins.bool:
        """
        Spread nodes across at least three physical hosts (requires at least three
        hosts).
        Enabled by default.
        """
        return pulumi.get(self, "aag_config_disabled")


@pulumi.output_type
class VMwareClusterAuthorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsers":
            suggest = "admin_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterAuthorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterAuthorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterAuthorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_users: Optional[Sequence['outputs.VMwareClusterAuthorizationAdminUser']] = None):
        """
        :param Sequence['VMwareClusterAuthorizationAdminUserArgs'] admin_users: Users that will be granted the cluster-admin role on the cluster, providing
               full access to the cluster.
               Structure is documented below.
        """
        if admin_users is not None:
            pulumi.set(__self__, "admin_users", admin_users)

    @property
    @pulumi.getter(name="adminUsers")
    def admin_users(self) -> Optional[Sequence['outputs.VMwareClusterAuthorizationAdminUser']]:
        """
        Users that will be granted the cluster-admin role on the cluster, providing
        full access to the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "admin_users")


@pulumi.output_type
class VMwareClusterAuthorizationAdminUser(dict):
    def __init__(__self__, *,
                 username: builtins.str):
        """
        :param builtins.str username: The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def username(self) -> builtins.str:
        """
        The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class VMwareClusterAutoRepairConfig(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool):
        """
        :param builtins.bool enabled: Whether auto repair is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether auto repair is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class VMwareClusterControlPlaneNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoResizeConfig":
            suggest = "auto_resize_config"
        elif key == "vsphereConfigs":
            suggest = "vsphere_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterControlPlaneNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterControlPlaneNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterControlPlaneNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_resize_config: Optional['outputs.VMwareClusterControlPlaneNodeAutoResizeConfig'] = None,
                 cpus: Optional[builtins.int] = None,
                 memory: Optional[builtins.int] = None,
                 replicas: Optional[builtins.int] = None,
                 vsphere_configs: Optional[Sequence['outputs.VMwareClusterControlPlaneNodeVsphereConfig']] = None):
        """
        :param 'VMwareClusterControlPlaneNodeAutoResizeConfigArgs' auto_resize_config: AutoResizeConfig provides auto resizing configurations.
               Structure is documented below.
        :param builtins.int cpus: The number of CPUs for each admin cluster node that serve as control planes
               for this VMware User Cluster. (default: 4 CPUs)
        :param builtins.int memory: The megabytes of memory for each admin cluster node that serves as a
               control plane for this VMware User Cluster (default: 8192 MB memory).
        :param builtins.int replicas: The number of control plane nodes for this VMware User Cluster.
               (default: 1 replica).
        :param Sequence['VMwareClusterControlPlaneNodeVsphereConfigArgs'] vsphere_configs: (Output)
               Vsphere-specific config.
               Structure is documented below.
        """
        if auto_resize_config is not None:
            pulumi.set(__self__, "auto_resize_config", auto_resize_config)
        if cpus is not None:
            pulumi.set(__self__, "cpus", cpus)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if vsphere_configs is not None:
            pulumi.set(__self__, "vsphere_configs", vsphere_configs)

    @property
    @pulumi.getter(name="autoResizeConfig")
    def auto_resize_config(self) -> Optional['outputs.VMwareClusterControlPlaneNodeAutoResizeConfig']:
        """
        AutoResizeConfig provides auto resizing configurations.
        Structure is documented below.
        """
        return pulumi.get(self, "auto_resize_config")

    @property
    @pulumi.getter
    def cpus(self) -> Optional[builtins.int]:
        """
        The number of CPUs for each admin cluster node that serve as control planes
        for this VMware User Cluster. (default: 4 CPUs)
        """
        return pulumi.get(self, "cpus")

    @property
    @pulumi.getter
    def memory(self) -> Optional[builtins.int]:
        """
        The megabytes of memory for each admin cluster node that serves as a
        control plane for this VMware User Cluster (default: 8192 MB memory).
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[builtins.int]:
        """
        The number of control plane nodes for this VMware User Cluster.
        (default: 1 replica).
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter(name="vsphereConfigs")
    def vsphere_configs(self) -> Optional[Sequence['outputs.VMwareClusterControlPlaneNodeVsphereConfig']]:
        """
        (Output)
        Vsphere-specific config.
        Structure is documented below.
        """
        return pulumi.get(self, "vsphere_configs")


@pulumi.output_type
class VMwareClusterControlPlaneNodeAutoResizeConfig(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool):
        """
        :param builtins.bool enabled: Whether to enable control plane node auto resizing.
               
               <a name="nested_control_plane_node_vsphere_config"></a>The `vsphere_config` block contains:
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether to enable control plane node auto resizing.

        <a name="nested_control_plane_node_vsphere_config"></a>The `vsphere_config` block contains:
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class VMwareClusterControlPlaneNodeVsphereConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storagePolicyName":
            suggest = "storage_policy_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterControlPlaneNodeVsphereConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterControlPlaneNodeVsphereConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterControlPlaneNodeVsphereConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datastore: Optional[builtins.str] = None,
                 storage_policy_name: Optional[builtins.str] = None):
        """
        :param builtins.str datastore: The Vsphere datastore used by the Control Plane Node.
        :param builtins.str storage_policy_name: The Vsphere storage policy used by the control plane Node.
        """
        if datastore is not None:
            pulumi.set(__self__, "datastore", datastore)
        if storage_policy_name is not None:
            pulumi.set(__self__, "storage_policy_name", storage_policy_name)

    @property
    @pulumi.getter
    def datastore(self) -> Optional[builtins.str]:
        """
        The Vsphere datastore used by the Control Plane Node.
        """
        return pulumi.get(self, "datastore")

    @property
    @pulumi.getter(name="storagePolicyName")
    def storage_policy_name(self) -> Optional[builtins.str]:
        """
        The Vsphere storage policy used by the control plane Node.
        """
        return pulumi.get(self, "storage_policy_name")


@pulumi.output_type
class VMwareClusterDataplaneV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedNetworking":
            suggest = "advanced_networking"
        elif key == "dataplaneV2Enabled":
            suggest = "dataplane_v2_enabled"
        elif key == "windowsDataplaneV2Enabled":
            suggest = "windows_dataplane_v2_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterDataplaneV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterDataplaneV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterDataplaneV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_networking: Optional[builtins.bool] = None,
                 dataplane_v2_enabled: Optional[builtins.bool] = None,
                 windows_dataplane_v2_enabled: Optional[builtins.bool] = None):
        """
        :param builtins.bool advanced_networking: Enable advanced networking which requires dataplane_v2_enabled to be set true.
        :param builtins.bool dataplane_v2_enabled: Enables Dataplane V2.
        :param builtins.bool windows_dataplane_v2_enabled: Enable Dataplane V2 for clusters with Windows nodes.
        """
        if advanced_networking is not None:
            pulumi.set(__self__, "advanced_networking", advanced_networking)
        if dataplane_v2_enabled is not None:
            pulumi.set(__self__, "dataplane_v2_enabled", dataplane_v2_enabled)
        if windows_dataplane_v2_enabled is not None:
            pulumi.set(__self__, "windows_dataplane_v2_enabled", windows_dataplane_v2_enabled)

    @property
    @pulumi.getter(name="advancedNetworking")
    def advanced_networking(self) -> Optional[builtins.bool]:
        """
        Enable advanced networking which requires dataplane_v2_enabled to be set true.
        """
        return pulumi.get(self, "advanced_networking")

    @property
    @pulumi.getter(name="dataplaneV2Enabled")
    def dataplane_v2_enabled(self) -> Optional[builtins.bool]:
        """
        Enables Dataplane V2.
        """
        return pulumi.get(self, "dataplane_v2_enabled")

    @property
    @pulumi.getter(name="windowsDataplaneV2Enabled")
    def windows_dataplane_v2_enabled(self) -> Optional[builtins.bool]:
        """
        Enable Dataplane V2 for clusters with Windows nodes.
        """
        return pulumi.get(self, "windows_dataplane_v2_enabled")


@pulumi.output_type
class VMwareClusterFleet(dict):
    def __init__(__self__, *,
                 membership: Optional[builtins.str] = None):
        """
        :param builtins.str membership: (Output)
               The name of the managed Hub Membership resource associated to this cluster.
               Membership names are formatted as
               `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        if membership is not None:
            pulumi.set(__self__, "membership", membership)

    @property
    @pulumi.getter
    def membership(self) -> Optional[builtins.str]:
        """
        (Output)
        The name of the managed Hub Membership resource associated to this cluster.
        Membership names are formatted as
        `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        return pulumi.get(self, "membership")


@pulumi.output_type
class VMwareClusterLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "f5Config":
            suggest = "f5_config"
        elif key == "manualLbConfig":
            suggest = "manual_lb_config"
        elif key == "metalLbConfig":
            suggest = "metal_lb_config"
        elif key == "vipConfig":
            suggest = "vip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 f5_config: Optional['outputs.VMwareClusterLoadBalancerF5Config'] = None,
                 manual_lb_config: Optional['outputs.VMwareClusterLoadBalancerManualLbConfig'] = None,
                 metal_lb_config: Optional['outputs.VMwareClusterLoadBalancerMetalLbConfig'] = None,
                 vip_config: Optional['outputs.VMwareClusterLoadBalancerVipConfig'] = None):
        """
        :param 'VMwareClusterLoadBalancerF5ConfigArgs' f5_config: Configuration for F5 Big IP typed load balancers.
               Structure is documented below.
        :param 'VMwareClusterLoadBalancerManualLbConfigArgs' manual_lb_config: Manually configured load balancers.
               Structure is documented below.
        :param 'VMwareClusterLoadBalancerMetalLbConfigArgs' metal_lb_config: Configuration for MetalLB typed load balancers.
               Structure is documented below.
        :param 'VMwareClusterLoadBalancerVipConfigArgs' vip_config: The VIPs used by the load balancer.
               Structure is documented below.
        """
        if f5_config is not None:
            pulumi.set(__self__, "f5_config", f5_config)
        if manual_lb_config is not None:
            pulumi.set(__self__, "manual_lb_config", manual_lb_config)
        if metal_lb_config is not None:
            pulumi.set(__self__, "metal_lb_config", metal_lb_config)
        if vip_config is not None:
            pulumi.set(__self__, "vip_config", vip_config)

    @property
    @pulumi.getter(name="f5Config")
    def f5_config(self) -> Optional['outputs.VMwareClusterLoadBalancerF5Config']:
        """
        Configuration for F5 Big IP typed load balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "f5_config")

    @property
    @pulumi.getter(name="manualLbConfig")
    def manual_lb_config(self) -> Optional['outputs.VMwareClusterLoadBalancerManualLbConfig']:
        """
        Manually configured load balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "manual_lb_config")

    @property
    @pulumi.getter(name="metalLbConfig")
    def metal_lb_config(self) -> Optional['outputs.VMwareClusterLoadBalancerMetalLbConfig']:
        """
        Configuration for MetalLB typed load balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "metal_lb_config")

    @property
    @pulumi.getter(name="vipConfig")
    def vip_config(self) -> Optional['outputs.VMwareClusterLoadBalancerVipConfig']:
        """
        The VIPs used by the load balancer.
        Structure is documented below.
        """
        return pulumi.get(self, "vip_config")


@pulumi.output_type
class VMwareClusterLoadBalancerF5Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snatPool":
            suggest = "snat_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterLoadBalancerF5Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterLoadBalancerF5Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterLoadBalancerF5Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[builtins.str] = None,
                 partition: Optional[builtins.str] = None,
                 snat_pool: Optional[builtins.str] = None):
        """
        :param builtins.str address: The load balancer's IP address.
        :param builtins.str partition: he preexisting partition to be used by the load balancer. T
               his partition is usually created for the admin cluster for example:
               'my-f5-admin-partition'.
        :param builtins.str snat_pool: The pool name. Only necessary, if using SNAT.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if snat_pool is not None:
            pulumi.set(__self__, "snat_pool", snat_pool)

    @property
    @pulumi.getter
    def address(self) -> Optional[builtins.str]:
        """
        The load balancer's IP address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def partition(self) -> Optional[builtins.str]:
        """
        he preexisting partition to be used by the load balancer. T
        his partition is usually created for the admin cluster for example:
        'my-f5-admin-partition'.
        """
        return pulumi.get(self, "partition")

    @property
    @pulumi.getter(name="snatPool")
    def snat_pool(self) -> Optional[builtins.str]:
        """
        The pool name. Only necessary, if using SNAT.
        """
        return pulumi.get(self, "snat_pool")


@pulumi.output_type
class VMwareClusterLoadBalancerManualLbConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneNodePort":
            suggest = "control_plane_node_port"
        elif key == "ingressHttpNodePort":
            suggest = "ingress_http_node_port"
        elif key == "ingressHttpsNodePort":
            suggest = "ingress_https_node_port"
        elif key == "konnectivityServerNodePort":
            suggest = "konnectivity_server_node_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterLoadBalancerManualLbConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterLoadBalancerManualLbConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterLoadBalancerManualLbConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_node_port: Optional[builtins.int] = None,
                 ingress_http_node_port: Optional[builtins.int] = None,
                 ingress_https_node_port: Optional[builtins.int] = None,
                 konnectivity_server_node_port: Optional[builtins.int] = None):
        """
        :param builtins.int control_plane_node_port: NodePort for control plane service. The Kubernetes API server in the admin
               cluster is implemented as a Service of type NodePort (ex. 30968).
        :param builtins.int ingress_http_node_port: NodePort for ingress service's http. The ingress service in the admin
               cluster is implemented as a Service of type NodePort (ex. 32527).
        :param builtins.int ingress_https_node_port: NodePort for ingress service's https. The ingress service in the admin
               cluster is implemented as a Service of type NodePort (ex. 30139).
        :param builtins.int konnectivity_server_node_port: NodePort for konnectivity server service running as a sidecar in each
               kube-apiserver pod (ex. 30564).
        """
        if control_plane_node_port is not None:
            pulumi.set(__self__, "control_plane_node_port", control_plane_node_port)
        if ingress_http_node_port is not None:
            pulumi.set(__self__, "ingress_http_node_port", ingress_http_node_port)
        if ingress_https_node_port is not None:
            pulumi.set(__self__, "ingress_https_node_port", ingress_https_node_port)
        if konnectivity_server_node_port is not None:
            pulumi.set(__self__, "konnectivity_server_node_port", konnectivity_server_node_port)

    @property
    @pulumi.getter(name="controlPlaneNodePort")
    def control_plane_node_port(self) -> Optional[builtins.int]:
        """
        NodePort for control plane service. The Kubernetes API server in the admin
        cluster is implemented as a Service of type NodePort (ex. 30968).
        """
        return pulumi.get(self, "control_plane_node_port")

    @property
    @pulumi.getter(name="ingressHttpNodePort")
    def ingress_http_node_port(self) -> Optional[builtins.int]:
        """
        NodePort for ingress service's http. The ingress service in the admin
        cluster is implemented as a Service of type NodePort (ex. 32527).
        """
        return pulumi.get(self, "ingress_http_node_port")

    @property
    @pulumi.getter(name="ingressHttpsNodePort")
    def ingress_https_node_port(self) -> Optional[builtins.int]:
        """
        NodePort for ingress service's https. The ingress service in the admin
        cluster is implemented as a Service of type NodePort (ex. 30139).
        """
        return pulumi.get(self, "ingress_https_node_port")

    @property
    @pulumi.getter(name="konnectivityServerNodePort")
    def konnectivity_server_node_port(self) -> Optional[builtins.int]:
        """
        NodePort for konnectivity server service running as a sidecar in each
        kube-apiserver pod (ex. 30564).
        """
        return pulumi.get(self, "konnectivity_server_node_port")


@pulumi.output_type
class VMwareClusterLoadBalancerMetalLbConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPools":
            suggest = "address_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterLoadBalancerMetalLbConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterLoadBalancerMetalLbConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterLoadBalancerMetalLbConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_pools: Sequence['outputs.VMwareClusterLoadBalancerMetalLbConfigAddressPool']):
        """
        :param Sequence['VMwareClusterLoadBalancerMetalLbConfigAddressPoolArgs'] address_pools: AddressPools is a list of non-overlapping IP pools used by load balancer
               typed services. All addresses must be routable to load balancer nodes.
               IngressVIP must be included in the pools.
               Structure is documented below.
        """
        pulumi.set(__self__, "address_pools", address_pools)

    @property
    @pulumi.getter(name="addressPools")
    def address_pools(self) -> Sequence['outputs.VMwareClusterLoadBalancerMetalLbConfigAddressPool']:
        """
        AddressPools is a list of non-overlapping IP pools used by load balancer
        typed services. All addresses must be routable to load balancer nodes.
        IngressVIP must be included in the pools.
        Structure is documented below.
        """
        return pulumi.get(self, "address_pools")


@pulumi.output_type
class VMwareClusterLoadBalancerMetalLbConfigAddressPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avoidBuggyIps":
            suggest = "avoid_buggy_ips"
        elif key == "manualAssign":
            suggest = "manual_assign"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterLoadBalancerMetalLbConfigAddressPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterLoadBalancerMetalLbConfigAddressPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterLoadBalancerMetalLbConfigAddressPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Sequence[builtins.str],
                 pool: builtins.str,
                 avoid_buggy_ips: Optional[builtins.bool] = None,
                 manual_assign: Optional[builtins.bool] = None):
        """
        :param Sequence[builtins.str] addresses: The addresses that are part of this pool. Each address
               must be either in the CIDR form (1.2.3.0/24) or range
               form (1.2.3.1-1.2.3.5).
        :param builtins.str pool: The name of the address pool.
        :param builtins.bool avoid_buggy_ips: If true, avoid using IPs ending in .0 or .255.
               This avoids buggy consumer devices mistakenly dropping IPv4 traffic for
               those special IP addresses.
        :param builtins.bool manual_assign: If true, prevent IP addresses from being automatically assigned.
               
               <a name="nested_dataplane_v2"></a>The `dataplane_v2` block supports:
        """
        pulumi.set(__self__, "addresses", addresses)
        pulumi.set(__self__, "pool", pool)
        if avoid_buggy_ips is not None:
            pulumi.set(__self__, "avoid_buggy_ips", avoid_buggy_ips)
        if manual_assign is not None:
            pulumi.set(__self__, "manual_assign", manual_assign)

    @property
    @pulumi.getter
    def addresses(self) -> Sequence[builtins.str]:
        """
        The addresses that are part of this pool. Each address
        must be either in the CIDR form (1.2.3.0/24) or range
        form (1.2.3.1-1.2.3.5).
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def pool(self) -> builtins.str:
        """
        The name of the address pool.
        """
        return pulumi.get(self, "pool")

    @property
    @pulumi.getter(name="avoidBuggyIps")
    def avoid_buggy_ips(self) -> Optional[builtins.bool]:
        """
        If true, avoid using IPs ending in .0 or .255.
        This avoids buggy consumer devices mistakenly dropping IPv4 traffic for
        those special IP addresses.
        """
        return pulumi.get(self, "avoid_buggy_ips")

    @property
    @pulumi.getter(name="manualAssign")
    def manual_assign(self) -> Optional[builtins.bool]:
        """
        If true, prevent IP addresses from being automatically assigned.

        <a name="nested_dataplane_v2"></a>The `dataplane_v2` block supports:
        """
        return pulumi.get(self, "manual_assign")


@pulumi.output_type
class VMwareClusterLoadBalancerVipConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneVip":
            suggest = "control_plane_vip"
        elif key == "ingressVip":
            suggest = "ingress_vip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterLoadBalancerVipConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterLoadBalancerVipConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterLoadBalancerVipConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_vip: Optional[builtins.str] = None,
                 ingress_vip: Optional[builtins.str] = None):
        """
        :param builtins.str control_plane_vip: The VIP which you previously set aside for the Kubernetes API of this cluster.
        :param builtins.str ingress_vip: The VIP which you previously set aside for ingress traffic into this cluster.
               
               <a name="nested_load_balancer_f5_config"></a>The `f5_config` block supports:
        """
        if control_plane_vip is not None:
            pulumi.set(__self__, "control_plane_vip", control_plane_vip)
        if ingress_vip is not None:
            pulumi.set(__self__, "ingress_vip", ingress_vip)

    @property
    @pulumi.getter(name="controlPlaneVip")
    def control_plane_vip(self) -> Optional[builtins.str]:
        """
        The VIP which you previously set aside for the Kubernetes API of this cluster.
        """
        return pulumi.get(self, "control_plane_vip")

    @property
    @pulumi.getter(name="ingressVip")
    def ingress_vip(self) -> Optional[builtins.str]:
        """
        The VIP which you previously set aside for ingress traffic into this cluster.

        <a name="nested_load_balancer_f5_config"></a>The `f5_config` block supports:
        """
        return pulumi.get(self, "ingress_vip")


@pulumi.output_type
class VMwareClusterNetworkConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podAddressCidrBlocks":
            suggest = "pod_address_cidr_blocks"
        elif key == "serviceAddressCidrBlocks":
            suggest = "service_address_cidr_blocks"
        elif key == "controlPlaneV2Config":
            suggest = "control_plane_v2_config"
        elif key == "dhcpIpConfig":
            suggest = "dhcp_ip_config"
        elif key == "hostConfig":
            suggest = "host_config"
        elif key == "staticIpConfig":
            suggest = "static_ip_config"
        elif key == "vcenterNetwork":
            suggest = "vcenter_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterNetworkConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterNetworkConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterNetworkConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_address_cidr_blocks: Sequence[builtins.str],
                 service_address_cidr_blocks: Sequence[builtins.str],
                 control_plane_v2_config: Optional['outputs.VMwareClusterNetworkConfigControlPlaneV2Config'] = None,
                 dhcp_ip_config: Optional['outputs.VMwareClusterNetworkConfigDhcpIpConfig'] = None,
                 host_config: Optional['outputs.VMwareClusterNetworkConfigHostConfig'] = None,
                 static_ip_config: Optional['outputs.VMwareClusterNetworkConfigStaticIpConfig'] = None,
                 vcenter_network: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] pod_address_cidr_blocks: All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges.
               Only a single range is supported. This field cannot be changed after creation.
        :param Sequence[builtins.str] service_address_cidr_blocks: All services in the cluster are assigned an RFC1918 IPv4 address
               from these ranges. Only a single range is supported.. This field
               cannot be changed after creation.
        :param 'VMwareClusterNetworkConfigControlPlaneV2ConfigArgs' control_plane_v2_config: Configuration for control plane V2 mode.
               Structure is documented below.
        :param 'VMwareClusterNetworkConfigDhcpIpConfigArgs' dhcp_ip_config: Configuration settings for a DHCP IP configuration.
               Structure is documented below.
        :param 'VMwareClusterNetworkConfigHostConfigArgs' host_config: Represents common network settings irrespective of the host's IP address.
               Structure is documented below.
        :param 'VMwareClusterNetworkConfigStaticIpConfigArgs' static_ip_config: Configuration settings for a static IP configuration.
               Structure is documented below.
        :param builtins.str vcenter_network: vcenter_network specifies vCenter network name. Inherited from the admin cluster.
        """
        pulumi.set(__self__, "pod_address_cidr_blocks", pod_address_cidr_blocks)
        pulumi.set(__self__, "service_address_cidr_blocks", service_address_cidr_blocks)
        if control_plane_v2_config is not None:
            pulumi.set(__self__, "control_plane_v2_config", control_plane_v2_config)
        if dhcp_ip_config is not None:
            pulumi.set(__self__, "dhcp_ip_config", dhcp_ip_config)
        if host_config is not None:
            pulumi.set(__self__, "host_config", host_config)
        if static_ip_config is not None:
            pulumi.set(__self__, "static_ip_config", static_ip_config)
        if vcenter_network is not None:
            pulumi.set(__self__, "vcenter_network", vcenter_network)

    @property
    @pulumi.getter(name="podAddressCidrBlocks")
    def pod_address_cidr_blocks(self) -> Sequence[builtins.str]:
        """
        All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges.
        Only a single range is supported. This field cannot be changed after creation.
        """
        return pulumi.get(self, "pod_address_cidr_blocks")

    @property
    @pulumi.getter(name="serviceAddressCidrBlocks")
    def service_address_cidr_blocks(self) -> Sequence[builtins.str]:
        """
        All services in the cluster are assigned an RFC1918 IPv4 address
        from these ranges. Only a single range is supported.. This field
        cannot be changed after creation.
        """
        return pulumi.get(self, "service_address_cidr_blocks")

    @property
    @pulumi.getter(name="controlPlaneV2Config")
    def control_plane_v2_config(self) -> Optional['outputs.VMwareClusterNetworkConfigControlPlaneV2Config']:
        """
        Configuration for control plane V2 mode.
        Structure is documented below.
        """
        return pulumi.get(self, "control_plane_v2_config")

    @property
    @pulumi.getter(name="dhcpIpConfig")
    def dhcp_ip_config(self) -> Optional['outputs.VMwareClusterNetworkConfigDhcpIpConfig']:
        """
        Configuration settings for a DHCP IP configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "dhcp_ip_config")

    @property
    @pulumi.getter(name="hostConfig")
    def host_config(self) -> Optional['outputs.VMwareClusterNetworkConfigHostConfig']:
        """
        Represents common network settings irrespective of the host's IP address.
        Structure is documented below.
        """
        return pulumi.get(self, "host_config")

    @property
    @pulumi.getter(name="staticIpConfig")
    def static_ip_config(self) -> Optional['outputs.VMwareClusterNetworkConfigStaticIpConfig']:
        """
        Configuration settings for a static IP configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "static_ip_config")

    @property
    @pulumi.getter(name="vcenterNetwork")
    def vcenter_network(self) -> Optional[builtins.str]:
        """
        vcenter_network specifies vCenter network name. Inherited from the admin cluster.
        """
        return pulumi.get(self, "vcenter_network")


@pulumi.output_type
class VMwareClusterNetworkConfigControlPlaneV2Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneIpBlock":
            suggest = "control_plane_ip_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterNetworkConfigControlPlaneV2Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterNetworkConfigControlPlaneV2Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterNetworkConfigControlPlaneV2Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_ip_block: Optional['outputs.VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlock'] = None):
        """
        :param 'VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockArgs' control_plane_ip_block: Static IP addresses for the control plane nodes.
        """
        if control_plane_ip_block is not None:
            pulumi.set(__self__, "control_plane_ip_block", control_plane_ip_block)

    @property
    @pulumi.getter(name="controlPlaneIpBlock")
    def control_plane_ip_block(self) -> Optional['outputs.VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlock']:
        """
        Static IP addresses for the control plane nodes.
        """
        return pulumi.get(self, "control_plane_ip_block")


@pulumi.output_type
class VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlock(dict):
    def __init__(__self__, *,
                 gateway: Optional[builtins.str] = None,
                 ips: Optional[Sequence['outputs.VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIp']] = None,
                 netmask: Optional[builtins.str] = None):
        """
        :param builtins.str gateway: The network gateway used by the VMware User Cluster.
        :param Sequence['VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIpArgs'] ips: The node's network configurations used by the VMware User Cluster.
               Structure is documented below.
        :param builtins.str netmask: The netmask used by the VMware User Cluster.
        """
        if gateway is not None:
            pulumi.set(__self__, "gateway", gateway)
        if ips is not None:
            pulumi.set(__self__, "ips", ips)
        if netmask is not None:
            pulumi.set(__self__, "netmask", netmask)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[builtins.str]:
        """
        The network gateway used by the VMware User Cluster.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence['outputs.VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIp']]:
        """
        The node's network configurations used by the VMware User Cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def netmask(self) -> Optional[builtins.str]:
        """
        The netmask used by the VMware User Cluster.
        """
        return pulumi.get(self, "netmask")


@pulumi.output_type
class VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIp(dict):
    def __init__(__self__, *,
                 hostname: Optional[builtins.str] = None,
                 ip: Optional[builtins.str] = None):
        """
        :param builtins.str hostname: Hostname of the machine. VM's name will be used if this field is empty.
        :param builtins.str ip: IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        """
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)
        if ip is not None:
            pulumi.set(__self__, "ip", ip)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[builtins.str]:
        """
        Hostname of the machine. VM's name will be used if this field is empty.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> Optional[builtins.str]:
        """
        IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class VMwareClusterNetworkConfigDhcpIpConfig(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool):
        """
        :param builtins.bool enabled: enabled is a flag to mark if DHCP IP allocation is
               used for VMware user clusters.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        enabled is a flag to mark if DHCP IP allocation is
        used for VMware user clusters.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class VMwareClusterNetworkConfigHostConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsSearchDomains":
            suggest = "dns_search_domains"
        elif key == "dnsServers":
            suggest = "dns_servers"
        elif key == "ntpServers":
            suggest = "ntp_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterNetworkConfigHostConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterNetworkConfigHostConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterNetworkConfigHostConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_search_domains: Optional[Sequence[builtins.str]] = None,
                 dns_servers: Optional[Sequence[builtins.str]] = None,
                 ntp_servers: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] dns_search_domains: DNS search domains.
               
               <a name="nested_network_config_control_plane_v2_config"></a>The `control_plane_v2_config` block supports:
        :param Sequence[builtins.str] dns_servers: DNS servers.
        :param Sequence[builtins.str] ntp_servers: NTP servers.
        """
        if dns_search_domains is not None:
            pulumi.set(__self__, "dns_search_domains", dns_search_domains)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if ntp_servers is not None:
            pulumi.set(__self__, "ntp_servers", ntp_servers)

    @property
    @pulumi.getter(name="dnsSearchDomains")
    def dns_search_domains(self) -> Optional[Sequence[builtins.str]]:
        """
        DNS search domains.

        <a name="nested_network_config_control_plane_v2_config"></a>The `control_plane_v2_config` block supports:
        """
        return pulumi.get(self, "dns_search_domains")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[builtins.str]]:
        """
        DNS servers.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter(name="ntpServers")
    def ntp_servers(self) -> Optional[Sequence[builtins.str]]:
        """
        NTP servers.
        """
        return pulumi.get(self, "ntp_servers")


@pulumi.output_type
class VMwareClusterNetworkConfigStaticIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipBlocks":
            suggest = "ip_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterNetworkConfigStaticIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterNetworkConfigStaticIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterNetworkConfigStaticIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_blocks: Sequence['outputs.VMwareClusterNetworkConfigStaticIpConfigIpBlock']):
        """
        :param Sequence['VMwareClusterNetworkConfigStaticIpConfigIpBlockArgs'] ip_blocks: Represents the configuration values for static IP allocation to nodes.
               Structure is documented below.
        """
        pulumi.set(__self__, "ip_blocks", ip_blocks)

    @property
    @pulumi.getter(name="ipBlocks")
    def ip_blocks(self) -> Sequence['outputs.VMwareClusterNetworkConfigStaticIpConfigIpBlock']:
        """
        Represents the configuration values for static IP allocation to nodes.
        Structure is documented below.
        """
        return pulumi.get(self, "ip_blocks")


@pulumi.output_type
class VMwareClusterNetworkConfigStaticIpConfigIpBlock(dict):
    def __init__(__self__, *,
                 gateway: builtins.str,
                 ips: Sequence['outputs.VMwareClusterNetworkConfigStaticIpConfigIpBlockIp'],
                 netmask: builtins.str):
        """
        :param builtins.str gateway: The network gateway used by the VMware User Cluster.
        :param Sequence['VMwareClusterNetworkConfigStaticIpConfigIpBlockIpArgs'] ips: The node's network configurations used by the VMware User Cluster.
               Structure is documented below.
        :param builtins.str netmask: The netmask used by the VMware User Cluster.
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "netmask", netmask)

    @property
    @pulumi.getter
    def gateway(self) -> builtins.str:
        """
        The network gateway used by the VMware User Cluster.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def ips(self) -> Sequence['outputs.VMwareClusterNetworkConfigStaticIpConfigIpBlockIp']:
        """
        The node's network configurations used by the VMware User Cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def netmask(self) -> builtins.str:
        """
        The netmask used by the VMware User Cluster.
        """
        return pulumi.get(self, "netmask")


@pulumi.output_type
class VMwareClusterNetworkConfigStaticIpConfigIpBlockIp(dict):
    def __init__(__self__, *,
                 ip: builtins.str,
                 hostname: Optional[builtins.str] = None):
        """
        :param builtins.str ip: IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        :param builtins.str hostname: Hostname of the machine. VM's name will be used if this field is empty.
        """
        pulumi.set(__self__, "ip", ip)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter
    def ip(self) -> builtins.str:
        """
        IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[builtins.str]:
        """
        Hostname of the machine. VM's name will be used if this field is empty.
        """
        return pulumi.get(self, "hostname")


@pulumi.output_type
class VMwareClusterStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.VMwareClusterStatusCondition']] = None,
                 error_message: Optional[builtins.str] = None):
        """
        :param Sequence['VMwareClusterStatusConditionArgs'] conditions: (Output)
               ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
               Structure is documented below.
        :param builtins.str error_message: (Output)
               Human-friendly representation of the error message from the user cluster
               controller. The error message can be temporary as the user cluster
               controller creates a cluster or node pool. If the error message persists
               for a longer period of time, it can be used to surface error message to
               indicate real problems requiring user intervention.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.VMwareClusterStatusCondition']]:
        """
        (Output)
        ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[builtins.str]:
        """
        (Output)
        Human-friendly representation of the error message from the user cluster
        controller. The error message can be temporary as the user cluster
        controller creates a cluster or node pool. If the error message persists
        for a longer period of time, it can be used to surface error message to
        indicate real problems requiring user intervention.
        """
        return pulumi.get(self, "error_message")


@pulumi.output_type
class VMwareClusterStatusCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterStatusCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterStatusCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterStatusCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[builtins.str] = None,
                 message: Optional[builtins.str] = None,
                 reason: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str last_transition_time: (Output)
               Last time the condition transit from one status to another.
        :param builtins.str message: (Output)
               Human-readable message indicating details about last transition.
        :param builtins.str reason: (Output)
               Machine-readable message indicating details about last transition.
        :param builtins.str state: (Output)
               The lifecycle state of the condition.
        :param builtins.str type: (Output)
               Type of the condition.
               (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[builtins.str]:
        """
        (Output)
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        (Output)
        Human-readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[builtins.str]:
        """
        (Output)
        Machine-readable message indicating details about last transition.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        (Output)
        The lifecycle state of the condition.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        (Output)
        Type of the condition.
        (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VMwareClusterStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vsphereCsiDisabled":
            suggest = "vsphere_csi_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vsphere_csi_disabled: builtins.bool):
        """
        :param builtins.bool vsphere_csi_disabled: Whether or not to deploy vSphere CSI components in the VMware User Cluster.
               Enabled by default.
        """
        pulumi.set(__self__, "vsphere_csi_disabled", vsphere_csi_disabled)

    @property
    @pulumi.getter(name="vsphereCsiDisabled")
    def vsphere_csi_disabled(self) -> builtins.bool:
        """
        Whether or not to deploy vSphere CSI components in the VMware User Cluster.
        Enabled by default.
        """
        return pulumi.get(self, "vsphere_csi_disabled")


@pulumi.output_type
class VMwareClusterUpgradePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneOnly":
            suggest = "control_plane_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterUpgradePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterUpgradePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterUpgradePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_only: Optional[builtins.bool] = None):
        """
        :param builtins.bool control_plane_only: Controls whether the upgrade applies to the control plane only.
        """
        if control_plane_only is not None:
            pulumi.set(__self__, "control_plane_only", control_plane_only)

    @property
    @pulumi.getter(name="controlPlaneOnly")
    def control_plane_only(self) -> Optional[builtins.bool]:
        """
        Controls whether the upgrade applies to the control plane only.
        """
        return pulumi.get(self, "control_plane_only")


@pulumi.output_type
class VMwareClusterValidationCheck(dict):
    def __init__(__self__, *,
                 options: Optional[builtins.str] = None,
                 scenario: Optional[builtins.str] = None,
                 statuses: Optional[Sequence['outputs.VMwareClusterValidationCheckStatus']] = None):
        """
        :param builtins.str options: (Output)
               Options used for the validation check.
        :param builtins.str scenario: (Output)
               The scenario when the preflight checks were run..
        :param Sequence['VMwareClusterValidationCheckStatusArgs'] statuses: (Output)
               Specifies the detailed validation check status
               Structure is documented below.
        """
        if options is not None:
            pulumi.set(__self__, "options", options)
        if scenario is not None:
            pulumi.set(__self__, "scenario", scenario)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter
    def options(self) -> Optional[builtins.str]:
        """
        (Output)
        Options used for the validation check.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def scenario(self) -> Optional[builtins.str]:
        """
        (Output)
        The scenario when the preflight checks were run..
        """
        return pulumi.get(self, "scenario")

    @property
    @pulumi.getter
    def statuses(self) -> Optional[Sequence['outputs.VMwareClusterValidationCheckStatus']]:
        """
        (Output)
        Specifies the detailed validation check status
        Structure is documented below.
        """
        return pulumi.get(self, "statuses")


@pulumi.output_type
class VMwareClusterValidationCheckStatus(dict):
    def __init__(__self__, *,
                 results: Optional[Sequence['outputs.VMwareClusterValidationCheckStatusResult']] = None):
        """
        :param Sequence['VMwareClusterValidationCheckStatusResultArgs'] results: (Output)
               Individual checks which failed as part of the Preflight check execution.
               Structure is documented below.
        """
        if results is not None:
            pulumi.set(__self__, "results", results)

    @property
    @pulumi.getter
    def results(self) -> Optional[Sequence['outputs.VMwareClusterValidationCheckStatusResult']]:
        """
        (Output)
        Individual checks which failed as part of the Preflight check execution.
        Structure is documented below.
        """
        return pulumi.get(self, "results")


@pulumi.output_type
class VMwareClusterValidationCheckStatusResult(dict):
    def __init__(__self__, *,
                 category: Optional[builtins.str] = None,
                 description: Optional[builtins.str] = None,
                 details: Optional[builtins.str] = None,
                 options: Optional[builtins.str] = None,
                 reason: Optional[builtins.str] = None):
        """
        :param builtins.str category: (Output)
               The category of the validation.
        :param builtins.str description: (Output)
               The description of the validation check.
        :param builtins.str details: (Output)
               Detailed failure information, which might be unformatted.
        :param builtins.str options: (Output)
               Options used for the validation check.
        :param builtins.str reason: (Output)
               Machine-readable message indicating details about last transition.
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if options is not None:
            pulumi.set(__self__, "options", options)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        (Output)
        The category of the validation.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def description(self) -> Optional[builtins.str]:
        """
        (Output)
        The description of the validation check.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Optional[builtins.str]:
        """
        (Output)
        Detailed failure information, which might be unformatted.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def options(self) -> Optional[builtins.str]:
        """
        (Output)
        Options used for the validation check.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def reason(self) -> Optional[builtins.str]:
        """
        (Output)
        Machine-readable message indicating details about last transition.
        """
        return pulumi.get(self, "reason")


@pulumi.output_type
class VMwareClusterVcenter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertData":
            suggest = "ca_cert_data"
        elif key == "resourcePool":
            suggest = "resource_pool"
        elif key == "storagePolicyName":
            suggest = "storage_policy_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterVcenter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterVcenter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterVcenter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[builtins.str] = None,
                 ca_cert_data: Optional[builtins.str] = None,
                 cluster: Optional[builtins.str] = None,
                 datacenter: Optional[builtins.str] = None,
                 datastore: Optional[builtins.str] = None,
                 folder: Optional[builtins.str] = None,
                 resource_pool: Optional[builtins.str] = None,
                 storage_policy_name: Optional[builtins.str] = None):
        """
        :param builtins.str address: (Output)
               The vCenter IP address.
        :param builtins.str ca_cert_data: Contains the vCenter CA certificate public key for SSL verification.
        :param builtins.str cluster: The name of the vCenter cluster for the user cluster.
        :param builtins.str datacenter: The name of the vCenter datacenter for the user cluster.
        :param builtins.str datastore: The name of the vCenter datastore for the user cluster.
        :param builtins.str folder: The name of the vCenter folder for the user cluster.
        :param builtins.str resource_pool: The name of the vCenter resource pool for the user cluster.
        :param builtins.str storage_policy_name: The name of the vCenter storage policy for the user cluster.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if ca_cert_data is not None:
            pulumi.set(__self__, "ca_cert_data", ca_cert_data)
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if datastore is not None:
            pulumi.set(__self__, "datastore", datastore)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if resource_pool is not None:
            pulumi.set(__self__, "resource_pool", resource_pool)
        if storage_policy_name is not None:
            pulumi.set(__self__, "storage_policy_name", storage_policy_name)

    @property
    @pulumi.getter
    def address(self) -> Optional[builtins.str]:
        """
        (Output)
        The vCenter IP address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="caCertData")
    def ca_cert_data(self) -> Optional[builtins.str]:
        """
        Contains the vCenter CA certificate public key for SSL verification.
        """
        return pulumi.get(self, "ca_cert_data")

    @property
    @pulumi.getter
    def cluster(self) -> Optional[builtins.str]:
        """
        The name of the vCenter cluster for the user cluster.
        """
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter
    def datacenter(self) -> Optional[builtins.str]:
        """
        The name of the vCenter datacenter for the user cluster.
        """
        return pulumi.get(self, "datacenter")

    @property
    @pulumi.getter
    def datastore(self) -> Optional[builtins.str]:
        """
        The name of the vCenter datastore for the user cluster.
        """
        return pulumi.get(self, "datastore")

    @property
    @pulumi.getter
    def folder(self) -> Optional[builtins.str]:
        """
        The name of the vCenter folder for the user cluster.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter(name="resourcePool")
    def resource_pool(self) -> Optional[builtins.str]:
        """
        The name of the vCenter resource pool for the user cluster.
        """
        return pulumi.get(self, "resource_pool")

    @property
    @pulumi.getter(name="storagePolicyName")
    def storage_policy_name(self) -> Optional[builtins.str]:
        """
        The name of the vCenter storage policy for the user cluster.
        """
        return pulumi.get(self, "storage_policy_name")


@pulumi.output_type
class VMwareNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageType":
            suggest = "image_type"
        elif key == "bootDiskSizeGb":
            suggest = "boot_disk_size_gb"
        elif key == "enableLoadBalancer":
            suggest = "enable_load_balancer"
        elif key == "memoryMb":
            suggest = "memory_mb"
        elif key == "vsphereConfig":
            suggest = "vsphere_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_type: builtins.str,
                 boot_disk_size_gb: Optional[builtins.int] = None,
                 cpus: Optional[builtins.int] = None,
                 enable_load_balancer: Optional[builtins.bool] = None,
                 image: Optional[builtins.str] = None,
                 labels: Optional[Mapping[str, builtins.str]] = None,
                 memory_mb: Optional[builtins.int] = None,
                 replicas: Optional[builtins.int] = None,
                 taints: Optional[Sequence['outputs.VMwareNodePoolConfigTaint']] = None,
                 vsphere_config: Optional['outputs.VMwareNodePoolConfigVsphereConfig'] = None):
        """
        :param builtins.str image_type: The OS image to be used for each node in a node pool.
               Currently `cos`, `cos_cgv2`, `ubuntu`, `ubuntu_cgv2`, `ubuntu_containerd` and `windows` are supported.
        :param builtins.int boot_disk_size_gb: VMware disk size to be used during creation.
        :param builtins.int cpus: The number of CPUs for each node in the node pool.
        :param builtins.bool enable_load_balancer: Allow node pool traffic to be load balanced. Only works for clusters with
               MetalLB load balancers.
        :param builtins.str image: The OS image name in vCenter, only valid when using Windows.
        :param Mapping[str, builtins.str] labels: The map of Kubernetes labels (key/value pairs) to be applied to each node.
               These will added in addition to any default label(s) that
               Kubernetes may apply to the node.
               In case of conflict in label keys, the applied set may differ depending on
               the Kubernetes version -- it's best to assume the behavior is undefined
               and conflicts should be avoided.
        :param builtins.int memory_mb: The megabytes of memory for each node in the node pool.
        :param builtins.int replicas: The number of nodes in the node pool.
        :param Sequence['VMwareNodePoolConfigTaintArgs'] taints: The initial taints assigned to nodes of this node pool.
               Structure is documented below.
        :param 'VMwareNodePoolConfigVsphereConfigArgs' vsphere_config: Specifies the vSphere config for node pool.
               Structure is documented below.
        """
        pulumi.set(__self__, "image_type", image_type)
        if boot_disk_size_gb is not None:
            pulumi.set(__self__, "boot_disk_size_gb", boot_disk_size_gb)
        if cpus is not None:
            pulumi.set(__self__, "cpus", cpus)
        if enable_load_balancer is not None:
            pulumi.set(__self__, "enable_load_balancer", enable_load_balancer)
        if image is not None:
            pulumi.set(__self__, "image", image)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if memory_mb is not None:
            pulumi.set(__self__, "memory_mb", memory_mb)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)
        if taints is not None:
            pulumi.set(__self__, "taints", taints)
        if vsphere_config is not None:
            pulumi.set(__self__, "vsphere_config", vsphere_config)

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> builtins.str:
        """
        The OS image to be used for each node in a node pool.
        Currently `cos`, `cos_cgv2`, `ubuntu`, `ubuntu_cgv2`, `ubuntu_containerd` and `windows` are supported.
        """
        return pulumi.get(self, "image_type")

    @property
    @pulumi.getter(name="bootDiskSizeGb")
    def boot_disk_size_gb(self) -> Optional[builtins.int]:
        """
        VMware disk size to be used during creation.
        """
        return pulumi.get(self, "boot_disk_size_gb")

    @property
    @pulumi.getter
    def cpus(self) -> Optional[builtins.int]:
        """
        The number of CPUs for each node in the node pool.
        """
        return pulumi.get(self, "cpus")

    @property
    @pulumi.getter(name="enableLoadBalancer")
    def enable_load_balancer(self) -> Optional[builtins.bool]:
        """
        Allow node pool traffic to be load balanced. Only works for clusters with
        MetalLB load balancers.
        """
        return pulumi.get(self, "enable_load_balancer")

    @property
    @pulumi.getter
    def image(self) -> Optional[builtins.str]:
        """
        The OS image name in vCenter, only valid when using Windows.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, builtins.str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to each node.
        These will added in addition to any default label(s) that
        Kubernetes may apply to the node.
        In case of conflict in label keys, the applied set may differ depending on
        the Kubernetes version -- it's best to assume the behavior is undefined
        and conflicts should be avoided.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="memoryMb")
    def memory_mb(self) -> Optional[builtins.int]:
        """
        The megabytes of memory for each node in the node pool.
        """
        return pulumi.get(self, "memory_mb")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[builtins.int]:
        """
        The number of nodes in the node pool.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.VMwareNodePoolConfigTaint']]:
        """
        The initial taints assigned to nodes of this node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "taints")

    @property
    @pulumi.getter(name="vsphereConfig")
    def vsphere_config(self) -> Optional['outputs.VMwareNodePoolConfigVsphereConfig']:
        """
        Specifies the vSphere config for node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "vsphere_config")


@pulumi.output_type
class VMwareNodePoolConfigTaint(dict):
    def __init__(__self__, *,
                 key: builtins.str,
                 value: builtins.str,
                 effect: Optional[builtins.str] = None):
        """
        :param builtins.str key: Key associated with the effect.
        :param builtins.str value: Value associated with the effect.
        :param builtins.str effect: Available taint effects.
               Possible values are: `EFFECT_UNSPECIFIED`, `NO_SCHEDULE`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "value", value)
        if effect is not None:
            pulumi.set(__self__, "effect", effect)

    @property
    @pulumi.getter
    def key(self) -> builtins.str:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> builtins.str:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def effect(self) -> Optional[builtins.str]:
        """
        Available taint effects.
        Possible values are: `EFFECT_UNSPECIFIED`, `NO_SCHEDULE`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        """
        return pulumi.get(self, "effect")


@pulumi.output_type
class VMwareNodePoolConfigVsphereConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostGroups":
            suggest = "host_groups"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareNodePoolConfigVsphereConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareNodePoolConfigVsphereConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareNodePoolConfigVsphereConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datastore: Optional[builtins.str] = None,
                 host_groups: Optional[Sequence[builtins.str]] = None,
                 tags: Optional[Sequence['outputs.VMwareNodePoolConfigVsphereConfigTag']] = None):
        """
        :param builtins.str datastore: The name of the vCenter datastore. Inherited from the user cluster.
        :param Sequence[builtins.str] host_groups: Vsphere host groups to apply to all VMs in the node pool
        :param Sequence['VMwareNodePoolConfigVsphereConfigTagArgs'] tags: Tags to apply to VMs.
               Structure is documented below.
        """
        if datastore is not None:
            pulumi.set(__self__, "datastore", datastore)
        if host_groups is not None:
            pulumi.set(__self__, "host_groups", host_groups)
        if tags is not None:
            pulumi.set(__self__, "tags", tags)

    @property
    @pulumi.getter
    def datastore(self) -> Optional[builtins.str]:
        """
        The name of the vCenter datastore. Inherited from the user cluster.
        """
        return pulumi.get(self, "datastore")

    @property
    @pulumi.getter(name="hostGroups")
    def host_groups(self) -> Optional[Sequence[builtins.str]]:
        """
        Vsphere host groups to apply to all VMs in the node pool
        """
        return pulumi.get(self, "host_groups")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.VMwareNodePoolConfigVsphereConfigTag']]:
        """
        Tags to apply to VMs.
        Structure is documented below.
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class VMwareNodePoolConfigVsphereConfigTag(dict):
    def __init__(__self__, *,
                 category: Optional[builtins.str] = None,
                 tag: Optional[builtins.str] = None):
        """
        :param builtins.str category: The Vsphere tag category.
        :param builtins.str tag: The Vsphere tag name.
               
               - - -
        """
        if category is not None:
            pulumi.set(__self__, "category", category)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter
    def category(self) -> Optional[builtins.str]:
        """
        The Vsphere tag category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def tag(self) -> Optional[builtins.str]:
        """
        The Vsphere tag name.

        - - -
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class VMwareNodePoolNodePoolAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxReplicas":
            suggest = "max_replicas"
        elif key == "minReplicas":
            suggest = "min_replicas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareNodePoolNodePoolAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareNodePoolNodePoolAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareNodePoolNodePoolAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_replicas: builtins.int,
                 min_replicas: builtins.int):
        """
        :param builtins.int max_replicas: Maximum number of replicas in the NodePool.
        :param builtins.int min_replicas: Minimum number of replicas in the NodePool.
        """
        pulumi.set(__self__, "max_replicas", max_replicas)
        pulumi.set(__self__, "min_replicas", min_replicas)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> builtins.int:
        """
        Maximum number of replicas in the NodePool.
        """
        return pulumi.get(self, "max_replicas")

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> builtins.int:
        """
        Minimum number of replicas in the NodePool.
        """
        return pulumi.get(self, "min_replicas")


@pulumi.output_type
class VMwareNodePoolStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareNodePoolStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareNodePoolStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareNodePoolStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.VMwareNodePoolStatusCondition']] = None,
                 error_message: Optional[builtins.str] = None):
        """
        :param Sequence['VMwareNodePoolStatusConditionArgs'] conditions: (Output)
               ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
               Structure is documented below.
        :param builtins.str error_message: (Output)
               Human-friendly representation of the error message from the user cluster
               controller. The error message can be temporary as the user cluster
               controller creates a cluster or node pool. If the error message persists
               for a longer period of time, it can be used to surface error message to
               indicate real problems requiring user intervention.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.VMwareNodePoolStatusCondition']]:
        """
        (Output)
        ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[builtins.str]:
        """
        (Output)
        Human-friendly representation of the error message from the user cluster
        controller. The error message can be temporary as the user cluster
        controller creates a cluster or node pool. If the error message persists
        for a longer period of time, it can be used to surface error message to
        indicate real problems requiring user intervention.
        """
        return pulumi.get(self, "error_message")


@pulumi.output_type
class VMwareNodePoolStatusCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareNodePoolStatusCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareNodePoolStatusCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareNodePoolStatusCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[builtins.str] = None,
                 message: Optional[builtins.str] = None,
                 reason: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str last_transition_time: (Output)
               Last time the condition transit from one status to another.
        :param builtins.str message: (Output)
               Human-readable message indicating details about last transition.
        :param builtins.str reason: (Output)
               Machine-readable message indicating details about last transition.
        :param builtins.str state: (Output)
               The lifecycle state of the condition.
        :param builtins.str type: (Output)
               Type of the condition.
               (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[builtins.str]:
        """
        (Output)
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        (Output)
        Human-readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[builtins.str]:
        """
        (Output)
        Machine-readable message indicating details about last transition.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        (Output)
        The lifecycle state of the condition.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        (Output)
        Type of the condition.
        (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VmwareAdminClusterAddonNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoResizeConfig":
            suggest = "auto_resize_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAdminClusterAddonNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAdminClusterAddonNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAdminClusterAddonNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_resize_config: Optional['outputs.VmwareAdminClusterAddonNodeAutoResizeConfig'] = None):
        """
        :param 'VmwareAdminClusterAddonNodeAutoResizeConfigArgs' auto_resize_config: Specifies auto resize config.
               Structure is documented below.
        """
        if auto_resize_config is not None:
            pulumi.set(__self__, "auto_resize_config", auto_resize_config)

    @property
    @pulumi.getter(name="autoResizeConfig")
    def auto_resize_config(self) -> Optional['outputs.VmwareAdminClusterAddonNodeAutoResizeConfig']:
        """
        Specifies auto resize config.
        Structure is documented below.
        """
        return pulumi.get(self, "auto_resize_config")


@pulumi.output_type
class VmwareAdminClusterAddonNodeAutoResizeConfig(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool):
        """
        :param builtins.bool enabled: Whether to enable controle plane node auto resizing.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether to enable controle plane node auto resizing.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class VmwareAdminClusterAntiAffinityGroups(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aagConfigDisabled":
            suggest = "aag_config_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAdminClusterAntiAffinityGroups. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAdminClusterAntiAffinityGroups.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAdminClusterAntiAffinityGroups.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aag_config_disabled: builtins.bool):
        """
        :param builtins.bool aag_config_disabled: Spread nodes across at least three physical hosts (requires at least three
               hosts).
               Enabled by default.
        """
        pulumi.set(__self__, "aag_config_disabled", aag_config_disabled)

    @property
    @pulumi.getter(name="aagConfigDisabled")
    def aag_config_disabled(self) -> builtins.bool:
        """
        Spread nodes across at least three physical hosts (requires at least three
        hosts).
        Enabled by default.
        """
        return pulumi.get(self, "aag_config_disabled")


@pulumi.output_type
class VmwareAdminClusterAuthorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "viewerUsers":
            suggest = "viewer_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAdminClusterAuthorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAdminClusterAuthorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAdminClusterAuthorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 viewer_users: Optional[Sequence['outputs.VmwareAdminClusterAuthorizationViewerUser']] = None):
        """
        :param Sequence['VmwareAdminClusterAuthorizationViewerUserArgs'] viewer_users: Users that will be granted the cluster-admin role on the cluster, providing
               full access to the cluster.
               Structure is documented below.
        """
        if viewer_users is not None:
            pulumi.set(__self__, "viewer_users", viewer_users)

    @property
    @pulumi.getter(name="viewerUsers")
    def viewer_users(self) -> Optional[Sequence['outputs.VmwareAdminClusterAuthorizationViewerUser']]:
        """
        Users that will be granted the cluster-admin role on the cluster, providing
        full access to the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "viewer_users")


@pulumi.output_type
class VmwareAdminClusterAuthorizationViewerUser(dict):
    def __init__(__self__, *,
                 username: builtins.str):
        """
        :param builtins.str username: The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        pulumi.set(__self__, "username", username)

    @property
    @pulumi.getter
    def username(self) -> builtins.str:
        """
        The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class VmwareAdminClusterAutoRepairConfig(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool):
        """
        :param builtins.bool enabled: Whether auto repair is enabled.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        Whether auto repair is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class VmwareAdminClusterControlPlaneNode(dict):
    def __init__(__self__, *,
                 cpus: Optional[builtins.int] = None,
                 memory: Optional[builtins.int] = None,
                 replicas: Optional[builtins.int] = None):
        """
        :param builtins.int cpus: The number of vCPUs for the control-plane node of the admin cluster.
        :param builtins.int memory: The number of mebibytes of memory for the control-plane node of the admin cluster.
        :param builtins.int replicas: The number of control plane nodes for this VMware admin cluster.
        """
        if cpus is not None:
            pulumi.set(__self__, "cpus", cpus)
        if memory is not None:
            pulumi.set(__self__, "memory", memory)
        if replicas is not None:
            pulumi.set(__self__, "replicas", replicas)

    @property
    @pulumi.getter
    def cpus(self) -> Optional[builtins.int]:
        """
        The number of vCPUs for the control-plane node of the admin cluster.
        """
        return pulumi.get(self, "cpus")

    @property
    @pulumi.getter
    def memory(self) -> Optional[builtins.int]:
        """
        The number of mebibytes of memory for the control-plane node of the admin cluster.
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[builtins.int]:
        """
        The number of control plane nodes for this VMware admin cluster.
        """
        return pulumi.get(self, "replicas")


@pulumi.output_type
class VmwareAdminClusterFleet(dict):
    def __init__(__self__, *,
                 membership: Optional[builtins.str] = None):
        """
        :param builtins.str membership: (Output)
               The name of the managed Fleet Membership resource associated to this cluster.
               Membership names are formatted as
               `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        if membership is not None:
            pulumi.set(__self__, "membership", membership)

    @property
    @pulumi.getter
    def membership(self) -> Optional[builtins.str]:
        """
        (Output)
        The name of the managed Fleet Membership resource associated to this cluster.
        Membership names are formatted as
        `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        return pulumi.get(self, "membership")


@pulumi.output_type
class VmwareAdminClusterLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vipConfig":
            suggest = "vip_config"
        elif key == "f5Config":
            suggest = "f5_config"
        elif key == "manualLbConfig":
            suggest = "manual_lb_config"
        elif key == "metalLbConfig":
            suggest = "metal_lb_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAdminClusterLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAdminClusterLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAdminClusterLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vip_config: 'outputs.VmwareAdminClusterLoadBalancerVipConfig',
                 f5_config: Optional['outputs.VmwareAdminClusterLoadBalancerF5Config'] = None,
                 manual_lb_config: Optional['outputs.VmwareAdminClusterLoadBalancerManualLbConfig'] = None,
                 metal_lb_config: Optional['outputs.VmwareAdminClusterLoadBalancerMetalLbConfig'] = None):
        """
        :param 'VmwareAdminClusterLoadBalancerVipConfigArgs' vip_config: Specified the VMware Load Balancer Config
               Structure is documented below.
        :param 'VmwareAdminClusterLoadBalancerF5ConfigArgs' f5_config: Configuration for F5 Big IP typed load balancers.
               Structure is documented below.
        :param 'VmwareAdminClusterLoadBalancerManualLbConfigArgs' manual_lb_config: Manually configured load balancers.
               Structure is documented below.
        :param 'VmwareAdminClusterLoadBalancerMetalLbConfigArgs' metal_lb_config: Metal LB load balancers.
               Structure is documented below.
        """
        pulumi.set(__self__, "vip_config", vip_config)
        if f5_config is not None:
            pulumi.set(__self__, "f5_config", f5_config)
        if manual_lb_config is not None:
            pulumi.set(__self__, "manual_lb_config", manual_lb_config)
        if metal_lb_config is not None:
            pulumi.set(__self__, "metal_lb_config", metal_lb_config)

    @property
    @pulumi.getter(name="vipConfig")
    def vip_config(self) -> 'outputs.VmwareAdminClusterLoadBalancerVipConfig':
        """
        Specified the VMware Load Balancer Config
        Structure is documented below.
        """
        return pulumi.get(self, "vip_config")

    @property
    @pulumi.getter(name="f5Config")
    def f5_config(self) -> Optional['outputs.VmwareAdminClusterLoadBalancerF5Config']:
        """
        Configuration for F5 Big IP typed load balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "f5_config")

    @property
    @pulumi.getter(name="manualLbConfig")
    def manual_lb_config(self) -> Optional['outputs.VmwareAdminClusterLoadBalancerManualLbConfig']:
        """
        Manually configured load balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "manual_lb_config")

    @property
    @pulumi.getter(name="metalLbConfig")
    def metal_lb_config(self) -> Optional['outputs.VmwareAdminClusterLoadBalancerMetalLbConfig']:
        """
        Metal LB load balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "metal_lb_config")


@pulumi.output_type
class VmwareAdminClusterLoadBalancerF5Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snatPool":
            suggest = "snat_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAdminClusterLoadBalancerF5Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAdminClusterLoadBalancerF5Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAdminClusterLoadBalancerF5Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[builtins.str] = None,
                 partition: Optional[builtins.str] = None,
                 snat_pool: Optional[builtins.str] = None):
        """
        :param builtins.str address: The load balancer's IP address.
        :param builtins.str partition: he preexisting partition to be used by the load balancer. T
               his partition is usually created for the admin cluster for example:
               'my-f5-admin-partition'.
        :param builtins.str snat_pool: The pool name. Only necessary, if using SNAT.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if partition is not None:
            pulumi.set(__self__, "partition", partition)
        if snat_pool is not None:
            pulumi.set(__self__, "snat_pool", snat_pool)

    @property
    @pulumi.getter
    def address(self) -> Optional[builtins.str]:
        """
        The load balancer's IP address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def partition(self) -> Optional[builtins.str]:
        """
        he preexisting partition to be used by the load balancer. T
        his partition is usually created for the admin cluster for example:
        'my-f5-admin-partition'.
        """
        return pulumi.get(self, "partition")

    @property
    @pulumi.getter(name="snatPool")
    def snat_pool(self) -> Optional[builtins.str]:
        """
        The pool name. Only necessary, if using SNAT.
        """
        return pulumi.get(self, "snat_pool")


@pulumi.output_type
class VmwareAdminClusterLoadBalancerManualLbConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addonsNodePort":
            suggest = "addons_node_port"
        elif key == "controlPlaneNodePort":
            suggest = "control_plane_node_port"
        elif key == "ingressHttpNodePort":
            suggest = "ingress_http_node_port"
        elif key == "ingressHttpsNodePort":
            suggest = "ingress_https_node_port"
        elif key == "konnectivityServerNodePort":
            suggest = "konnectivity_server_node_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAdminClusterLoadBalancerManualLbConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAdminClusterLoadBalancerManualLbConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAdminClusterLoadBalancerManualLbConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addons_node_port: Optional[builtins.int] = None,
                 control_plane_node_port: Optional[builtins.int] = None,
                 ingress_http_node_port: Optional[builtins.int] = None,
                 ingress_https_node_port: Optional[builtins.int] = None,
                 konnectivity_server_node_port: Optional[builtins.int] = None):
        """
        :param builtins.int addons_node_port: NodePort for add-ons server in the admin cluster.
        :param builtins.int control_plane_node_port: NodePort for control plane service. The Kubernetes API server in the admin
               cluster is implemented as a Service of type NodePort (ex. 30968).
        :param builtins.int ingress_http_node_port: NodePort for ingress service's http. The ingress service in the admin
               cluster is implemented as a Service of type NodePort (ex. 32527).
        :param builtins.int ingress_https_node_port: NodePort for ingress service's https. The ingress service in the admin
               cluster is implemented as a Service of type NodePort (ex. 30139).
        :param builtins.int konnectivity_server_node_port: NodePort for konnectivity server service running as a sidecar in each
               kube-apiserver pod (ex. 30564).
        """
        if addons_node_port is not None:
            pulumi.set(__self__, "addons_node_port", addons_node_port)
        if control_plane_node_port is not None:
            pulumi.set(__self__, "control_plane_node_port", control_plane_node_port)
        if ingress_http_node_port is not None:
            pulumi.set(__self__, "ingress_http_node_port", ingress_http_node_port)
        if ingress_https_node_port is not None:
            pulumi.set(__self__, "ingress_https_node_port", ingress_https_node_port)
        if konnectivity_server_node_port is not None:
            pulumi.set(__self__, "konnectivity_server_node_port", konnectivity_server_node_port)

    @property
    @pulumi.getter(name="addonsNodePort")
    def addons_node_port(self) -> Optional[builtins.int]:
        """
        NodePort for add-ons server in the admin cluster.
        """
        return pulumi.get(self, "addons_node_port")

    @property
    @pulumi.getter(name="controlPlaneNodePort")
    def control_plane_node_port(self) -> Optional[builtins.int]:
        """
        NodePort for control plane service. The Kubernetes API server in the admin
        cluster is implemented as a Service of type NodePort (ex. 30968).
        """
        return pulumi.get(self, "control_plane_node_port")

    @property
    @pulumi.getter(name="ingressHttpNodePort")
    def ingress_http_node_port(self) -> Optional[builtins.int]:
        """
        NodePort for ingress service's http. The ingress service in the admin
        cluster is implemented as a Service of type NodePort (ex. 32527).
        """
        return pulumi.get(self, "ingress_http_node_port")

    @property
    @pulumi.getter(name="ingressHttpsNodePort")
    def ingress_https_node_port(self) -> Optional[builtins.int]:
        """
        NodePort for ingress service's https. The ingress service in the admin
        cluster is implemented as a Service of type NodePort (ex. 30139).
        """
        return pulumi.get(self, "ingress_https_node_port")

    @property
    @pulumi.getter(name="konnectivityServerNodePort")
    def konnectivity_server_node_port(self) -> Optional[builtins.int]:
        """
        NodePort for konnectivity server service running as a sidecar in each
        kube-apiserver pod (ex. 30564).
        """
        return pulumi.get(self, "konnectivity_server_node_port")


@pulumi.output_type
class VmwareAdminClusterLoadBalancerMetalLbConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[builtins.bool] = None):
        """
        :param builtins.bool enabled: Metal LB is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[builtins.bool]:
        """
        Metal LB is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class VmwareAdminClusterLoadBalancerVipConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneVip":
            suggest = "control_plane_vip"
        elif key == "addonsVip":
            suggest = "addons_vip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAdminClusterLoadBalancerVipConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAdminClusterLoadBalancerVipConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAdminClusterLoadBalancerVipConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_vip: builtins.str,
                 addons_vip: Optional[builtins.str] = None):
        """
        :param builtins.str control_plane_vip: The VIP which you previously set aside for the Kubernetes
               API of this VMware Admin Cluster.
        :param builtins.str addons_vip: The VIP to configure the load balancer for add-ons.
               
               <a name="nested_load_balancer_f5_config"></a>The `f5_config` block supports:
        """
        pulumi.set(__self__, "control_plane_vip", control_plane_vip)
        if addons_vip is not None:
            pulumi.set(__self__, "addons_vip", addons_vip)

    @property
    @pulumi.getter(name="controlPlaneVip")
    def control_plane_vip(self) -> builtins.str:
        """
        The VIP which you previously set aside for the Kubernetes
        API of this VMware Admin Cluster.
        """
        return pulumi.get(self, "control_plane_vip")

    @property
    @pulumi.getter(name="addonsVip")
    def addons_vip(self) -> Optional[builtins.str]:
        """
        The VIP to configure the load balancer for add-ons.

        <a name="nested_load_balancer_f5_config"></a>The `f5_config` block supports:
        """
        return pulumi.get(self, "addons_vip")


@pulumi.output_type
class VmwareAdminClusterNetworkConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podAddressCidrBlocks":
            suggest = "pod_address_cidr_blocks"
        elif key == "serviceAddressCidrBlocks":
            suggest = "service_address_cidr_blocks"
        elif key == "dhcpIpConfig":
            suggest = "dhcp_ip_config"
        elif key == "haControlPlaneConfig":
            suggest = "ha_control_plane_config"
        elif key == "hostConfig":
            suggest = "host_config"
        elif key == "staticIpConfig":
            suggest = "static_ip_config"
        elif key == "vcenterNetwork":
            suggest = "vcenter_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAdminClusterNetworkConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAdminClusterNetworkConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAdminClusterNetworkConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_address_cidr_blocks: Sequence[builtins.str],
                 service_address_cidr_blocks: Sequence[builtins.str],
                 dhcp_ip_config: Optional['outputs.VmwareAdminClusterNetworkConfigDhcpIpConfig'] = None,
                 ha_control_plane_config: Optional['outputs.VmwareAdminClusterNetworkConfigHaControlPlaneConfig'] = None,
                 host_config: Optional['outputs.VmwareAdminClusterNetworkConfigHostConfig'] = None,
                 static_ip_config: Optional['outputs.VmwareAdminClusterNetworkConfigStaticIpConfig'] = None,
                 vcenter_network: Optional[builtins.str] = None):
        """
        :param Sequence[builtins.str] pod_address_cidr_blocks: All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges.
               Only a single range is supported. This field cannot be changed after creation.
        :param Sequence[builtins.str] service_address_cidr_blocks: All services in the cluster are assigned an RFC1918 IPv4 address
               from these ranges. Only a single range is supported.. This field
               cannot be changed after creation.
        :param 'VmwareAdminClusterNetworkConfigDhcpIpConfigArgs' dhcp_ip_config: Configuration settings for a DHCP IP configuration.
               Structure is documented below.
        :param 'VmwareAdminClusterNetworkConfigHaControlPlaneConfigArgs' ha_control_plane_config: Configuration for HA admin cluster control plane.
               Structure is documented below.
        :param 'VmwareAdminClusterNetworkConfigHostConfigArgs' host_config: Represents common network settings irrespective of the host's IP address.
               Structure is documented below.
        :param 'VmwareAdminClusterNetworkConfigStaticIpConfigArgs' static_ip_config: Configuration settings for a static IP configuration.
               Structure is documented below.
        :param builtins.str vcenter_network: vcenter_network specifies vCenter network name.
        """
        pulumi.set(__self__, "pod_address_cidr_blocks", pod_address_cidr_blocks)
        pulumi.set(__self__, "service_address_cidr_blocks", service_address_cidr_blocks)
        if dhcp_ip_config is not None:
            pulumi.set(__self__, "dhcp_ip_config", dhcp_ip_config)
        if ha_control_plane_config is not None:
            pulumi.set(__self__, "ha_control_plane_config", ha_control_plane_config)
        if host_config is not None:
            pulumi.set(__self__, "host_config", host_config)
        if static_ip_config is not None:
            pulumi.set(__self__, "static_ip_config", static_ip_config)
        if vcenter_network is not None:
            pulumi.set(__self__, "vcenter_network", vcenter_network)

    @property
    @pulumi.getter(name="podAddressCidrBlocks")
    def pod_address_cidr_blocks(self) -> Sequence[builtins.str]:
        """
        All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges.
        Only a single range is supported. This field cannot be changed after creation.
        """
        return pulumi.get(self, "pod_address_cidr_blocks")

    @property
    @pulumi.getter(name="serviceAddressCidrBlocks")
    def service_address_cidr_blocks(self) -> Sequence[builtins.str]:
        """
        All services in the cluster are assigned an RFC1918 IPv4 address
        from these ranges. Only a single range is supported.. This field
        cannot be changed after creation.
        """
        return pulumi.get(self, "service_address_cidr_blocks")

    @property
    @pulumi.getter(name="dhcpIpConfig")
    def dhcp_ip_config(self) -> Optional['outputs.VmwareAdminClusterNetworkConfigDhcpIpConfig']:
        """
        Configuration settings for a DHCP IP configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "dhcp_ip_config")

    @property
    @pulumi.getter(name="haControlPlaneConfig")
    def ha_control_plane_config(self) -> Optional['outputs.VmwareAdminClusterNetworkConfigHaControlPlaneConfig']:
        """
        Configuration for HA admin cluster control plane.
        Structure is documented below.
        """
        return pulumi.get(self, "ha_control_plane_config")

    @property
    @pulumi.getter(name="hostConfig")
    def host_config(self) -> Optional['outputs.VmwareAdminClusterNetworkConfigHostConfig']:
        """
        Represents common network settings irrespective of the host's IP address.
        Structure is documented below.
        """
        return pulumi.get(self, "host_config")

    @property
    @pulumi.getter(name="staticIpConfig")
    def static_ip_config(self) -> Optional['outputs.VmwareAdminClusterNetworkConfigStaticIpConfig']:
        """
        Configuration settings for a static IP configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "static_ip_config")

    @property
    @pulumi.getter(name="vcenterNetwork")
    def vcenter_network(self) -> Optional[builtins.str]:
        """
        vcenter_network specifies vCenter network name.
        """
        return pulumi.get(self, "vcenter_network")


@pulumi.output_type
class VmwareAdminClusterNetworkConfigDhcpIpConfig(dict):
    def __init__(__self__, *,
                 enabled: builtins.bool):
        """
        :param builtins.bool enabled: enabled is a flag to mark if DHCP IP allocation is
               used for VMware admin clusters.
        """
        pulumi.set(__self__, "enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> builtins.bool:
        """
        enabled is a flag to mark if DHCP IP allocation is
        used for VMware admin clusters.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class VmwareAdminClusterNetworkConfigHaControlPlaneConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneIpBlock":
            suggest = "control_plane_ip_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAdminClusterNetworkConfigHaControlPlaneConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAdminClusterNetworkConfigHaControlPlaneConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAdminClusterNetworkConfigHaControlPlaneConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_ip_block: Optional['outputs.VmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlock'] = None):
        """
        :param 'VmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockArgs' control_plane_ip_block: Static IP addresses for the control plane nodes.
               Structure is documented below.
        """
        if control_plane_ip_block is not None:
            pulumi.set(__self__, "control_plane_ip_block", control_plane_ip_block)

    @property
    @pulumi.getter(name="controlPlaneIpBlock")
    def control_plane_ip_block(self) -> Optional['outputs.VmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlock']:
        """
        Static IP addresses for the control plane nodes.
        Structure is documented below.
        """
        return pulumi.get(self, "control_plane_ip_block")


@pulumi.output_type
class VmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlock(dict):
    def __init__(__self__, *,
                 gateway: builtins.str,
                 ips: Sequence['outputs.VmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockIp'],
                 netmask: builtins.str):
        """
        :param builtins.str gateway: The network gateway used by the VMware Admin Cluster.
        :param Sequence['VmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockIpArgs'] ips: The node's network configurations used by the VMware Admin Cluster.
               Structure is documented below.
        :param builtins.str netmask: The netmask used by the VMware Admin Cluster.
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "netmask", netmask)

    @property
    @pulumi.getter
    def gateway(self) -> builtins.str:
        """
        The network gateway used by the VMware Admin Cluster.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def ips(self) -> Sequence['outputs.VmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockIp']:
        """
        The node's network configurations used by the VMware Admin Cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def netmask(self) -> builtins.str:
        """
        The netmask used by the VMware Admin Cluster.
        """
        return pulumi.get(self, "netmask")


@pulumi.output_type
class VmwareAdminClusterNetworkConfigHaControlPlaneConfigControlPlaneIpBlockIp(dict):
    def __init__(__self__, *,
                 ip: builtins.str,
                 hostname: Optional[builtins.str] = None):
        """
        :param builtins.str ip: IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        :param builtins.str hostname: Hostname of the machine. VM's name will be used if this field is empty.
               
               - - -
        """
        pulumi.set(__self__, "ip", ip)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter
    def ip(self) -> builtins.str:
        """
        IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[builtins.str]:
        """
        Hostname of the machine. VM's name will be used if this field is empty.

        - - -
        """
        return pulumi.get(self, "hostname")


@pulumi.output_type
class VmwareAdminClusterNetworkConfigHostConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsSearchDomains":
            suggest = "dns_search_domains"
        elif key == "dnsServers":
            suggest = "dns_servers"
        elif key == "ntpServers":
            suggest = "ntp_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAdminClusterNetworkConfigHostConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAdminClusterNetworkConfigHostConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAdminClusterNetworkConfigHostConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_search_domains: Optional[Sequence[builtins.str]] = None,
                 dns_servers: Optional[Sequence[builtins.str]] = None,
                 ntp_servers: Optional[Sequence[builtins.str]] = None):
        """
        :param Sequence[builtins.str] dns_search_domains: DNS search domains.
        :param Sequence[builtins.str] dns_servers: DNS servers.
        :param Sequence[builtins.str] ntp_servers: NTP servers.
        """
        if dns_search_domains is not None:
            pulumi.set(__self__, "dns_search_domains", dns_search_domains)
        if dns_servers is not None:
            pulumi.set(__self__, "dns_servers", dns_servers)
        if ntp_servers is not None:
            pulumi.set(__self__, "ntp_servers", ntp_servers)

    @property
    @pulumi.getter(name="dnsSearchDomains")
    def dns_search_domains(self) -> Optional[Sequence[builtins.str]]:
        """
        DNS search domains.
        """
        return pulumi.get(self, "dns_search_domains")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[builtins.str]]:
        """
        DNS servers.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter(name="ntpServers")
    def ntp_servers(self) -> Optional[Sequence[builtins.str]]:
        """
        NTP servers.
        """
        return pulumi.get(self, "ntp_servers")


@pulumi.output_type
class VmwareAdminClusterNetworkConfigStaticIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipBlocks":
            suggest = "ip_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAdminClusterNetworkConfigStaticIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAdminClusterNetworkConfigStaticIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAdminClusterNetworkConfigStaticIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_blocks: Optional[Sequence['outputs.VmwareAdminClusterNetworkConfigStaticIpConfigIpBlock']] = None):
        """
        :param Sequence['VmwareAdminClusterNetworkConfigStaticIpConfigIpBlockArgs'] ip_blocks: Represents the configuration values for static IP allocation to nodes.
               Structure is documented below.
        """
        if ip_blocks is not None:
            pulumi.set(__self__, "ip_blocks", ip_blocks)

    @property
    @pulumi.getter(name="ipBlocks")
    def ip_blocks(self) -> Optional[Sequence['outputs.VmwareAdminClusterNetworkConfigStaticIpConfigIpBlock']]:
        """
        Represents the configuration values for static IP allocation to nodes.
        Structure is documented below.
        """
        return pulumi.get(self, "ip_blocks")


@pulumi.output_type
class VmwareAdminClusterNetworkConfigStaticIpConfigIpBlock(dict):
    def __init__(__self__, *,
                 gateway: builtins.str,
                 ips: Sequence['outputs.VmwareAdminClusterNetworkConfigStaticIpConfigIpBlockIp'],
                 netmask: builtins.str):
        """
        :param builtins.str gateway: The network gateway used by the VMware Admin Cluster.
        :param Sequence['VmwareAdminClusterNetworkConfigStaticIpConfigIpBlockIpArgs'] ips: The node's network configurations used by the VMware Admin Cluster.
               Structure is documented below.
        :param builtins.str netmask: The netmask used by the VMware Admin Cluster.
        """
        pulumi.set(__self__, "gateway", gateway)
        pulumi.set(__self__, "ips", ips)
        pulumi.set(__self__, "netmask", netmask)

    @property
    @pulumi.getter
    def gateway(self) -> builtins.str:
        """
        The network gateway used by the VMware Admin Cluster.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def ips(self) -> Sequence['outputs.VmwareAdminClusterNetworkConfigStaticIpConfigIpBlockIp']:
        """
        The node's network configurations used by the VMware Admin Cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def netmask(self) -> builtins.str:
        """
        The netmask used by the VMware Admin Cluster.
        """
        return pulumi.get(self, "netmask")


@pulumi.output_type
class VmwareAdminClusterNetworkConfigStaticIpConfigIpBlockIp(dict):
    def __init__(__self__, *,
                 ip: builtins.str,
                 hostname: Optional[builtins.str] = None):
        """
        :param builtins.str ip: IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        :param builtins.str hostname: Hostname of the machine. VM's name will be used if this field is empty.
               
               - - -
        """
        pulumi.set(__self__, "ip", ip)
        if hostname is not None:
            pulumi.set(__self__, "hostname", hostname)

    @property
    @pulumi.getter
    def ip(self) -> builtins.str:
        """
        IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[builtins.str]:
        """
        Hostname of the machine. VM's name will be used if this field is empty.

        - - -
        """
        return pulumi.get(self, "hostname")


@pulumi.output_type
class VmwareAdminClusterPlatformConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "platformVersion":
            suggest = "platform_version"
        elif key == "requiredPlatformVersion":
            suggest = "required_platform_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAdminClusterPlatformConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAdminClusterPlatformConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAdminClusterPlatformConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bundles: Optional[Sequence['outputs.VmwareAdminClusterPlatformConfigBundle']] = None,
                 platform_version: Optional[builtins.str] = None,
                 required_platform_version: Optional[builtins.str] = None,
                 statuses: Optional[Sequence['outputs.VmwareAdminClusterPlatformConfigStatus']] = None):
        """
        :param Sequence['VmwareAdminClusterPlatformConfigBundleArgs'] bundles: (Output)
               The list of bundles installed in the admin cluster.
               Structure is documented below.
        :param builtins.str platform_version: (Output)
               The platform version e.g. 1.13.2.
        :param builtins.str required_platform_version: The required platform version e.g. 1.13.1.
               If the current platform version is lower than the target version,
               the platform version will be updated to the target version.
               If the target version is not installed in the platform
               (bundle versions), download the target version bundle.
        :param Sequence['VmwareAdminClusterPlatformConfigStatusArgs'] statuses: (Output)
               ResourceStatus representing detailed cluster state.
               Structure is documented below.
               
               
               <a name="nested_platform_config_bundles_bundles_status"></a>The `status` block contains:
        """
        if bundles is not None:
            pulumi.set(__self__, "bundles", bundles)
        if platform_version is not None:
            pulumi.set(__self__, "platform_version", platform_version)
        if required_platform_version is not None:
            pulumi.set(__self__, "required_platform_version", required_platform_version)
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)

    @property
    @pulumi.getter
    def bundles(self) -> Optional[Sequence['outputs.VmwareAdminClusterPlatformConfigBundle']]:
        """
        (Output)
        The list of bundles installed in the admin cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "bundles")

    @property
    @pulumi.getter(name="platformVersion")
    def platform_version(self) -> Optional[builtins.str]:
        """
        (Output)
        The platform version e.g. 1.13.2.
        """
        return pulumi.get(self, "platform_version")

    @property
    @pulumi.getter(name="requiredPlatformVersion")
    def required_platform_version(self) -> Optional[builtins.str]:
        """
        The required platform version e.g. 1.13.1.
        If the current platform version is lower than the target version,
        the platform version will be updated to the target version.
        If the target version is not installed in the platform
        (bundle versions), download the target version bundle.
        """
        return pulumi.get(self, "required_platform_version")

    @property
    @pulumi.getter
    def statuses(self) -> Optional[Sequence['outputs.VmwareAdminClusterPlatformConfigStatus']]:
        """
        (Output)
        ResourceStatus representing detailed cluster state.
        Structure is documented below.


        <a name="nested_platform_config_bundles_bundles_status"></a>The `status` block contains:
        """
        return pulumi.get(self, "statuses")


@pulumi.output_type
class VmwareAdminClusterPlatformConfigBundle(dict):
    def __init__(__self__, *,
                 statuses: Optional[Sequence['outputs.VmwareAdminClusterPlatformConfigBundleStatus']] = None,
                 version: Optional[builtins.str] = None):
        """
        :param Sequence['VmwareAdminClusterPlatformConfigBundleStatusArgs'] statuses: ResourceStatus representing detailed cluster state.
               Structure is documented below.
        :param builtins.str version: The version of the bundle.
        """
        if statuses is not None:
            pulumi.set(__self__, "statuses", statuses)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def statuses(self) -> Optional[Sequence['outputs.VmwareAdminClusterPlatformConfigBundleStatus']]:
        """
        ResourceStatus representing detailed cluster state.
        Structure is documented below.
        """
        return pulumi.get(self, "statuses")

    @property
    @pulumi.getter
    def version(self) -> Optional[builtins.str]:
        """
        The version of the bundle.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class VmwareAdminClusterPlatformConfigBundleStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAdminClusterPlatformConfigBundleStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAdminClusterPlatformConfigBundleStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAdminClusterPlatformConfigBundleStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.VmwareAdminClusterPlatformConfigBundleStatusCondition']] = None,
                 error_message: Optional[builtins.str] = None):
        """
        :param Sequence['VmwareAdminClusterPlatformConfigBundleStatusConditionArgs'] conditions: (Output)
               ResourceConditions provide a standard mechanism for higher-level status reporting from admin cluster controller.
               Structure is documented below.
        :param builtins.str error_message: (Output)
               Human-friendly representation of the error message from the admin cluster
               controller. The error message can be temporary as the admin cluster
               controller creates a cluster or node pool. If the error message persists
               for a longer period of time, it can be used to surface error message to
               indicate real problems requiring user intervention.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.VmwareAdminClusterPlatformConfigBundleStatusCondition']]:
        """
        (Output)
        ResourceConditions provide a standard mechanism for higher-level status reporting from admin cluster controller.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[builtins.str]:
        """
        (Output)
        Human-friendly representation of the error message from the admin cluster
        controller. The error message can be temporary as the admin cluster
        controller creates a cluster or node pool. If the error message persists
        for a longer period of time, it can be used to surface error message to
        indicate real problems requiring user intervention.
        """
        return pulumi.get(self, "error_message")


@pulumi.output_type
class VmwareAdminClusterPlatformConfigBundleStatusCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAdminClusterPlatformConfigBundleStatusCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAdminClusterPlatformConfigBundleStatusCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAdminClusterPlatformConfigBundleStatusCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[builtins.str] = None,
                 message: Optional[builtins.str] = None,
                 reason: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str last_transition_time: (Output)
               Last time the condition transit from one status to another.
        :param builtins.str message: (Output)
               Human-readable message indicating details about last transition.
        :param builtins.str reason: (Output)
               Machine-readable message indicating details about last transition.
        :param builtins.str state: (Output)
               The lifecycle state of the condition.
        :param builtins.str type: (Output)
               Type of the condition.
               (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[builtins.str]:
        """
        (Output)
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        (Output)
        Human-readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[builtins.str]:
        """
        (Output)
        Machine-readable message indicating details about last transition.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        (Output)
        The lifecycle state of the condition.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        (Output)
        Type of the condition.
        (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VmwareAdminClusterPlatformConfigStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAdminClusterPlatformConfigStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAdminClusterPlatformConfigStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAdminClusterPlatformConfigStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.VmwareAdminClusterPlatformConfigStatusCondition']] = None,
                 error_message: Optional[builtins.str] = None):
        """
        :param Sequence['VmwareAdminClusterPlatformConfigStatusConditionArgs'] conditions: (Output)
               ResourceConditions provide a standard mechanism for higher-level status reporting from admin cluster controller.
               Structure is documented below.
        :param builtins.str error_message: (Output)
               Human-friendly representation of the error message from the admin cluster
               controller. The error message can be temporary as the admin cluster
               controller creates a cluster or node pool. If the error message persists
               for a longer period of time, it can be used to surface error message to
               indicate real problems requiring user intervention.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.VmwareAdminClusterPlatformConfigStatusCondition']]:
        """
        (Output)
        ResourceConditions provide a standard mechanism for higher-level status reporting from admin cluster controller.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[builtins.str]:
        """
        (Output)
        Human-friendly representation of the error message from the admin cluster
        controller. The error message can be temporary as the admin cluster
        controller creates a cluster or node pool. If the error message persists
        for a longer period of time, it can be used to surface error message to
        indicate real problems requiring user intervention.
        """
        return pulumi.get(self, "error_message")


@pulumi.output_type
class VmwareAdminClusterPlatformConfigStatusCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAdminClusterPlatformConfigStatusCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAdminClusterPlatformConfigStatusCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAdminClusterPlatformConfigStatusCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[builtins.str] = None,
                 message: Optional[builtins.str] = None,
                 reason: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str last_transition_time: (Output)
               Last time the condition transit from one status to another.
        :param builtins.str message: (Output)
               Human-readable message indicating details about last transition.
        :param builtins.str reason: (Output)
               Machine-readable message indicating details about last transition.
        :param builtins.str state: (Output)
               The lifecycle state of the condition.
        :param builtins.str type: (Output)
               Type of the condition.
               (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[builtins.str]:
        """
        (Output)
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        (Output)
        Human-readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[builtins.str]:
        """
        (Output)
        Machine-readable message indicating details about last transition.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        (Output)
        The lifecycle state of the condition.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        (Output)
        Type of the condition.
        (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VmwareAdminClusterStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAdminClusterStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAdminClusterStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAdminClusterStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.VmwareAdminClusterStatusCondition']] = None,
                 error_message: Optional[builtins.str] = None):
        """
        :param Sequence['VmwareAdminClusterStatusConditionArgs'] conditions: (Output)
               ResourceConditions provide a standard mechanism for higher-level status reporting from admin cluster controller.
               Structure is documented below.
        :param builtins.str error_message: (Output)
               Human-friendly representation of the error message from the admin cluster
               controller. The error message can be temporary as the admin cluster
               controller creates a cluster or node pool. If the error message persists
               for a longer period of time, it can be used to surface error message to
               indicate real problems requiring user intervention.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if error_message is not None:
            pulumi.set(__self__, "error_message", error_message)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.VmwareAdminClusterStatusCondition']]:
        """
        (Output)
        ResourceConditions provide a standard mechanism for higher-level status reporting from admin cluster controller.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[builtins.str]:
        """
        (Output)
        Human-friendly representation of the error message from the admin cluster
        controller. The error message can be temporary as the admin cluster
        controller creates a cluster or node pool. If the error message persists
        for a longer period of time, it can be used to surface error message to
        indicate real problems requiring user intervention.
        """
        return pulumi.get(self, "error_message")


@pulumi.output_type
class VmwareAdminClusterStatusCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAdminClusterStatusCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAdminClusterStatusCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAdminClusterStatusCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[builtins.str] = None,
                 message: Optional[builtins.str] = None,
                 reason: Optional[builtins.str] = None,
                 state: Optional[builtins.str] = None,
                 type: Optional[builtins.str] = None):
        """
        :param builtins.str last_transition_time: (Output)
               Last time the condition transit from one status to another.
        :param builtins.str message: (Output)
               Human-readable message indicating details about last transition.
        :param builtins.str reason: (Output)
               Machine-readable message indicating details about last transition.
        :param builtins.str state: (Output)
               The lifecycle state of the condition.
        :param builtins.str type: (Output)
               Type of the condition.
               (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        if last_transition_time is not None:
            pulumi.set(__self__, "last_transition_time", last_transition_time)
        if message is not None:
            pulumi.set(__self__, "message", message)
        if reason is not None:
            pulumi.set(__self__, "reason", reason)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[builtins.str]:
        """
        (Output)
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[builtins.str]:
        """
        (Output)
        Human-readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[builtins.str]:
        """
        (Output)
        Machine-readable message indicating details about last transition.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def state(self) -> Optional[builtins.str]:
        """
        (Output)
        The lifecycle state of the condition.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> Optional[builtins.str]:
        """
        (Output)
        Type of the condition.
        (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VmwareAdminClusterVcenter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertData":
            suggest = "ca_cert_data"
        elif key == "dataDisk":
            suggest = "data_disk"
        elif key == "resourcePool":
            suggest = "resource_pool"
        elif key == "storagePolicyName":
            suggest = "storage_policy_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VmwareAdminClusterVcenter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VmwareAdminClusterVcenter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VmwareAdminClusterVcenter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[builtins.str] = None,
                 ca_cert_data: Optional[builtins.str] = None,
                 cluster: Optional[builtins.str] = None,
                 data_disk: Optional[builtins.str] = None,
                 datacenter: Optional[builtins.str] = None,
                 datastore: Optional[builtins.str] = None,
                 folder: Optional[builtins.str] = None,
                 resource_pool: Optional[builtins.str] = None,
                 storage_policy_name: Optional[builtins.str] = None):
        """
        :param builtins.str address: The vCenter IP address.
        :param builtins.str ca_cert_data: Contains the vCenter CA certificate public key for SSL verification.
        :param builtins.str cluster: The name of the vCenter cluster for the admin cluster.
        :param builtins.str data_disk: The name of the virtual machine disk (VMDK) for the admin cluster.
        :param builtins.str datacenter: The name of the vCenter datacenter for the admin cluster.
        :param builtins.str datastore: The name of the vCenter datastore for the admin cluster.
        :param builtins.str folder: The name of the vCenter folder for the admin cluster.
        :param builtins.str resource_pool: The name of the vCenter resource pool for the admin cluster.
        :param builtins.str storage_policy_name: The name of the vCenter storage policy for the user cluster.
        """
        if address is not None:
            pulumi.set(__self__, "address", address)
        if ca_cert_data is not None:
            pulumi.set(__self__, "ca_cert_data", ca_cert_data)
        if cluster is not None:
            pulumi.set(__self__, "cluster", cluster)
        if data_disk is not None:
            pulumi.set(__self__, "data_disk", data_disk)
        if datacenter is not None:
            pulumi.set(__self__, "datacenter", datacenter)
        if datastore is not None:
            pulumi.set(__self__, "datastore", datastore)
        if folder is not None:
            pulumi.set(__self__, "folder", folder)
        if resource_pool is not None:
            pulumi.set(__self__, "resource_pool", resource_pool)
        if storage_policy_name is not None:
            pulumi.set(__self__, "storage_policy_name", storage_policy_name)

    @property
    @pulumi.getter
    def address(self) -> Optional[builtins.str]:
        """
        The vCenter IP address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="caCertData")
    def ca_cert_data(self) -> Optional[builtins.str]:
        """
        Contains the vCenter CA certificate public key for SSL verification.
        """
        return pulumi.get(self, "ca_cert_data")

    @property
    @pulumi.getter
    def cluster(self) -> Optional[builtins.str]:
        """
        The name of the vCenter cluster for the admin cluster.
        """
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter(name="dataDisk")
    def data_disk(self) -> Optional[builtins.str]:
        """
        The name of the virtual machine disk (VMDK) for the admin cluster.
        """
        return pulumi.get(self, "data_disk")

    @property
    @pulumi.getter
    def datacenter(self) -> Optional[builtins.str]:
        """
        The name of the vCenter datacenter for the admin cluster.
        """
        return pulumi.get(self, "datacenter")

    @property
    @pulumi.getter
    def datastore(self) -> Optional[builtins.str]:
        """
        The name of the vCenter datastore for the admin cluster.
        """
        return pulumi.get(self, "datastore")

    @property
    @pulumi.getter
    def folder(self) -> Optional[builtins.str]:
        """
        The name of the vCenter folder for the admin cluster.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter(name="resourcePool")
    def resource_pool(self) -> Optional[builtins.str]:
        """
        The name of the vCenter resource pool for the admin cluster.
        """
        return pulumi.get(self, "resource_pool")

    @property
    @pulumi.getter(name="storagePolicyName")
    def storage_policy_name(self) -> Optional[builtins.str]:
        """
        The name of the vCenter storage policy for the user cluster.
        """
        return pulumi.get(self, "storage_policy_name")


