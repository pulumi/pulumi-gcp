# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities
from . import outputs

__all__ = [
    'BareMetalAdminClusterClusterOperations',
    'BareMetalAdminClusterControlPlane',
    'BareMetalAdminClusterControlPlaneApiServerArg',
    'BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfig',
    'BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig',
    'BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig',
    'BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint',
    'BareMetalAdminClusterFleet',
    'BareMetalAdminClusterLoadBalancer',
    'BareMetalAdminClusterLoadBalancerManualLbConfig',
    'BareMetalAdminClusterLoadBalancerPortConfig',
    'BareMetalAdminClusterLoadBalancerVipConfig',
    'BareMetalAdminClusterMaintenanceConfig',
    'BareMetalAdminClusterNetworkConfig',
    'BareMetalAdminClusterNetworkConfigIslandModeCidr',
    'BareMetalAdminClusterNodeAccessConfig',
    'BareMetalAdminClusterNodeConfig',
    'BareMetalAdminClusterProxy',
    'BareMetalAdminClusterSecurityConfig',
    'BareMetalAdminClusterSecurityConfigAuthorization',
    'BareMetalAdminClusterSecurityConfigAuthorizationAdminUser',
    'BareMetalAdminClusterStatus',
    'BareMetalAdminClusterStatusCondition',
    'BareMetalAdminClusterStorage',
    'BareMetalAdminClusterStorageLvpNodeMountsConfig',
    'BareMetalAdminClusterStorageLvpShareConfig',
    'BareMetalAdminClusterStorageLvpShareConfigLvpConfig',
    'BareMetalAdminClusterValidationCheck',
    'BareMetalAdminClusterValidationCheckStatus',
    'BareMetalAdminClusterValidationCheckStatusResult',
    'BareMetalClusterBinaryAuthorization',
    'BareMetalClusterClusterOperations',
    'BareMetalClusterControlPlane',
    'BareMetalClusterControlPlaneApiServerArg',
    'BareMetalClusterControlPlaneControlPlaneNodePoolConfig',
    'BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig',
    'BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig',
    'BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint',
    'BareMetalClusterFleet',
    'BareMetalClusterLoadBalancer',
    'BareMetalClusterLoadBalancerBgpLbConfig',
    'BareMetalClusterLoadBalancerBgpLbConfigAddressPool',
    'BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfig',
    'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfig',
    'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfig',
    'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfig',
    'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig',
    'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint',
    'BareMetalClusterLoadBalancerManualLbConfig',
    'BareMetalClusterLoadBalancerMetalLbConfig',
    'BareMetalClusterLoadBalancerMetalLbConfigAddressPool',
    'BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfig',
    'BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfig',
    'BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig',
    'BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint',
    'BareMetalClusterLoadBalancerPortConfig',
    'BareMetalClusterLoadBalancerVipConfig',
    'BareMetalClusterMaintenanceConfig',
    'BareMetalClusterNetworkConfig',
    'BareMetalClusterNetworkConfigIslandModeCidr',
    'BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfig',
    'BareMetalClusterNetworkConfigSrIovConfig',
    'BareMetalClusterNodeAccessConfig',
    'BareMetalClusterNodeConfig',
    'BareMetalClusterOsEnvironmentConfig',
    'BareMetalClusterProxy',
    'BareMetalClusterSecurityConfig',
    'BareMetalClusterSecurityConfigAuthorization',
    'BareMetalClusterSecurityConfigAuthorizationAdminUser',
    'BareMetalClusterStatus',
    'BareMetalClusterStatusCondition',
    'BareMetalClusterStorage',
    'BareMetalClusterStorageLvpNodeMountsConfig',
    'BareMetalClusterStorageLvpShareConfig',
    'BareMetalClusterStorageLvpShareConfigLvpConfig',
    'BareMetalClusterUpgradePolicy',
    'BareMetalClusterValidationCheck',
    'BareMetalClusterValidationCheckStatus',
    'BareMetalClusterValidationCheckStatusResult',
    'BareMetalNodePoolNodePoolConfig',
    'BareMetalNodePoolNodePoolConfigNodeConfig',
    'BareMetalNodePoolNodePoolConfigTaint',
    'BareMetalNodePoolStatus',
    'BareMetalNodePoolStatusCondition',
    'VMwareClusterAntiAffinityGroups',
    'VMwareClusterAuthorization',
    'VMwareClusterAuthorizationAdminUser',
    'VMwareClusterAutoRepairConfig',
    'VMwareClusterControlPlaneNode',
    'VMwareClusterControlPlaneNodeAutoResizeConfig',
    'VMwareClusterControlPlaneNodeVsphereConfig',
    'VMwareClusterDataplaneV2',
    'VMwareClusterFleet',
    'VMwareClusterLoadBalancer',
    'VMwareClusterLoadBalancerF5Config',
    'VMwareClusterLoadBalancerManualLbConfig',
    'VMwareClusterLoadBalancerMetalLbConfig',
    'VMwareClusterLoadBalancerMetalLbConfigAddressPool',
    'VMwareClusterLoadBalancerVipConfig',
    'VMwareClusterNetworkConfig',
    'VMwareClusterNetworkConfigControlPlaneV2Config',
    'VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlock',
    'VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIp',
    'VMwareClusterNetworkConfigDhcpIpConfig',
    'VMwareClusterNetworkConfigHostConfig',
    'VMwareClusterNetworkConfigStaticIpConfig',
    'VMwareClusterNetworkConfigStaticIpConfigIpBlock',
    'VMwareClusterNetworkConfigStaticIpConfigIpBlockIp',
    'VMwareClusterStatus',
    'VMwareClusterStatusCondition',
    'VMwareClusterStorage',
    'VMwareClusterUpgradePolicy',
    'VMwareClusterValidationCheck',
    'VMwareClusterValidationCheckStatus',
    'VMwareClusterValidationCheckStatusResult',
    'VMwareClusterVcenter',
    'VMwareNodePoolConfig',
    'VMwareNodePoolConfigTaint',
    'VMwareNodePoolConfigVsphereConfig',
    'VMwareNodePoolConfigVsphereConfigTag',
    'VMwareNodePoolNodePoolAutoscaling',
    'VMwareNodePoolStatus',
    'VMwareNodePoolStatusCondition',
]

@pulumi.output_type
class BareMetalAdminClusterClusterOperations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableApplicationLogs":
            suggest = "enable_application_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterClusterOperations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterClusterOperations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterClusterOperations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_application_logs: Optional[bool] = None):
        """
        :param bool enable_application_logs: Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        BareMetalAdminClusterClusterOperations._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_application_logs=enable_application_logs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_application_logs: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enable_application_logs is not None:
            _setter("enable_application_logs", enable_application_logs)

    @property
    @pulumi.getter(name="enableApplicationLogs")
    def enable_application_logs(self) -> Optional[bool]:
        """
        Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        return pulumi.get(self, "enable_application_logs")


@pulumi.output_type
class BareMetalAdminClusterControlPlane(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneNodePoolConfig":
            suggest = "control_plane_node_pool_config"
        elif key == "apiServerArgs":
            suggest = "api_server_args"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterControlPlane. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterControlPlane.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterControlPlane.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_node_pool_config: 'outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfig',
                 api_server_args: Optional[Sequence['outputs.BareMetalAdminClusterControlPlaneApiServerArg']] = None):
        """
        :param 'BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigArgs' control_plane_node_pool_config: Configures the node pool running the control plane. If specified the corresponding NodePool will be created for the cluster's control plane. The NodePool will have the same name and namespace as the cluster.
               Structure is documented below.
        :param Sequence['BareMetalAdminClusterControlPlaneApiServerArgArgs'] api_server_args: Customizes the default API server args. Only a subset of
               customized flags are supported. Please refer to the API server
               documentation below to know the exact format:
               https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
               Structure is documented below.
        """
        BareMetalAdminClusterControlPlane._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            control_plane_node_pool_config=control_plane_node_pool_config,
            api_server_args=api_server_args,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             control_plane_node_pool_config: 'outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfig',
             api_server_args: Optional[Sequence['outputs.BareMetalAdminClusterControlPlaneApiServerArg']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("control_plane_node_pool_config", control_plane_node_pool_config)
        if api_server_args is not None:
            _setter("api_server_args", api_server_args)

    @property
    @pulumi.getter(name="controlPlaneNodePoolConfig")
    def control_plane_node_pool_config(self) -> 'outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfig':
        """
        Configures the node pool running the control plane. If specified the corresponding NodePool will be created for the cluster's control plane. The NodePool will have the same name and namespace as the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "control_plane_node_pool_config")

    @property
    @pulumi.getter(name="apiServerArgs")
    def api_server_args(self) -> Optional[Sequence['outputs.BareMetalAdminClusterControlPlaneApiServerArg']]:
        """
        Customizes the default API server args. Only a subset of
        customized flags are supported. Please refer to the API server
        documentation below to know the exact format:
        https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
        Structure is documented below.
        """
        return pulumi.get(self, "api_server_args")


@pulumi.output_type
class BareMetalAdminClusterControlPlaneApiServerArg(dict):
    def __init__(__self__, *,
                 argument: str,
                 value: str):
        """
        :param str argument: The argument name as it appears on the API Server command line please make sure to remove the leading dashes.
        :param str value: The value of the arg as it will be passed to the API Server command line.
        """
        BareMetalAdminClusterControlPlaneApiServerArg._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            argument=argument,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             argument: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("argument", argument)
        _setter("value", value)

    @property
    @pulumi.getter
    def argument(self) -> str:
        """
        The argument name as it appears on the API Server command line please make sure to remove the leading dashes.
        """
        return pulumi.get(self, "argument")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the arg as it will be passed to the API Server command line.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodePoolConfig":
            suggest = "node_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_pool_config: 'outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig'):
        """
        :param 'BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigArgs' node_pool_config: The generic configuration for a node pool running the control plane.
               Structure is documented below.
        """
        BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            node_pool_config=node_pool_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             node_pool_config: 'outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("node_pool_config", node_pool_config)

    @property
    @pulumi.getter(name="nodePoolConfig")
    def node_pool_config(self) -> 'outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig':
        """
        The generic configuration for a node pool running the control plane.
        Structure is documented below.
        """
        return pulumi.get(self, "node_pool_config")


@pulumi.output_type
class BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeConfigs":
            suggest = "node_configs"
        elif key == "operatingSystem":
            suggest = "operating_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Mapping[str, str]] = None,
                 node_configs: Optional[Sequence['outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig']] = None,
                 operating_system: Optional[str] = None,
                 taints: Optional[Sequence['outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint']] = None):
        """
        :param Mapping[str, str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param Sequence['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfigArgs'] node_configs: The list of machine addresses in the Bare Metal Node Pool.
               Structure is documented below.
        :param str operating_system: Specifies the nodes operating system (default: LINUX).
        :param Sequence['BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaintArgs'] taints: The initial taints assigned to nodes of this node pool.
               Structure is documented below.
        """
        BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            labels=labels,
            node_configs=node_configs,
            operating_system=operating_system,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             labels: Optional[Mapping[str, str]] = None,
             node_configs: Optional[Sequence['outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig']] = None,
             operating_system: Optional[str] = None,
             taints: Optional[Sequence['outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if labels is not None:
            _setter("labels", labels)
        if node_configs is not None:
            _setter("node_configs", node_configs)
        if operating_system is not None:
            _setter("operating_system", operating_system)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeConfigs")
    def node_configs(self) -> Optional[Sequence['outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig']]:
        """
        The list of machine addresses in the Bare Metal Node Pool.
        Structure is documented below.
        """
        return pulumi.get(self, "node_configs")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[str]:
        """
        Specifies the nodes operating system (default: LINUX).
        """
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint']]:
        """
        The initial taints assigned to nodes of this node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeIp":
            suggest = "node_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Mapping[str, str]] = None,
                 node_ip: Optional[str] = None):
        """
        :param Mapping[str, str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param str node_ip: The default IPv4 address for SSH access and Kubernetes node.
               Example: 192.168.0.1
        """
        BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            labels=labels,
            node_ip=node_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             labels: Optional[Mapping[str, str]] = None,
             node_ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if labels is not None:
            _setter("labels", labels)
        if node_ip is not None:
            _setter("node_ip", node_ip)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> Optional[str]:
        """
        The default IPv4 address for SSH access and Kubernetes node.
        Example: 192.168.0.1
        """
        return pulumi.get(self, "node_ip")


@pulumi.output_type
class BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str effect: Specifies the nodes operating system (default: LINUX).
               Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        :param str key: Key associated with the effect.
        :param str value: Value associated with the effect.
        """
        BareMetalAdminClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        Specifies the nodes operating system (default: LINUX).
        Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BareMetalAdminClusterFleet(dict):
    def __init__(__self__, *,
                 membership: Optional[str] = None):
        """
        :param str membership: (Output)
               The name of the managed Hub Membership resource associated to this cluster.
               Membership names are formatted as
               `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        BareMetalAdminClusterFleet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            membership=membership,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             membership: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if membership is not None:
            _setter("membership", membership)

    @property
    @pulumi.getter
    def membership(self) -> Optional[str]:
        """
        (Output)
        The name of the managed Hub Membership resource associated to this cluster.
        Membership names are formatted as
        `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        return pulumi.get(self, "membership")


@pulumi.output_type
class BareMetalAdminClusterLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portConfig":
            suggest = "port_config"
        elif key == "vipConfig":
            suggest = "vip_config"
        elif key == "manualLbConfig":
            suggest = "manual_lb_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_config: 'outputs.BareMetalAdminClusterLoadBalancerPortConfig',
                 vip_config: 'outputs.BareMetalAdminClusterLoadBalancerVipConfig',
                 manual_lb_config: Optional['outputs.BareMetalAdminClusterLoadBalancerManualLbConfig'] = None):
        """
        :param 'BareMetalAdminClusterLoadBalancerPortConfigArgs' port_config: Specifies the load balancer ports.
               Structure is documented below.
        :param 'BareMetalAdminClusterLoadBalancerVipConfigArgs' vip_config: Specified the Bare Metal Load Balancer Config
               Structure is documented below.
        :param 'BareMetalAdminClusterLoadBalancerManualLbConfigArgs' manual_lb_config: A nested object resource
               Structure is documented below.
        """
        BareMetalAdminClusterLoadBalancer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port_config=port_config,
            vip_config=vip_config,
            manual_lb_config=manual_lb_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port_config: 'outputs.BareMetalAdminClusterLoadBalancerPortConfig',
             vip_config: 'outputs.BareMetalAdminClusterLoadBalancerVipConfig',
             manual_lb_config: Optional['outputs.BareMetalAdminClusterLoadBalancerManualLbConfig'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("port_config", port_config)
        _setter("vip_config", vip_config)
        if manual_lb_config is not None:
            _setter("manual_lb_config", manual_lb_config)

    @property
    @pulumi.getter(name="portConfig")
    def port_config(self) -> 'outputs.BareMetalAdminClusterLoadBalancerPortConfig':
        """
        Specifies the load balancer ports.
        Structure is documented below.
        """
        return pulumi.get(self, "port_config")

    @property
    @pulumi.getter(name="vipConfig")
    def vip_config(self) -> 'outputs.BareMetalAdminClusterLoadBalancerVipConfig':
        """
        Specified the Bare Metal Load Balancer Config
        Structure is documented below.
        """
        return pulumi.get(self, "vip_config")

    @property
    @pulumi.getter(name="manualLbConfig")
    def manual_lb_config(self) -> Optional['outputs.BareMetalAdminClusterLoadBalancerManualLbConfig']:
        """
        A nested object resource
        Structure is documented below.
        """
        return pulumi.get(self, "manual_lb_config")


@pulumi.output_type
class BareMetalAdminClusterLoadBalancerManualLbConfig(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Whether manual load balancing is enabled.
        """
        BareMetalAdminClusterLoadBalancerManualLbConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether manual load balancing is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class BareMetalAdminClusterLoadBalancerPortConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneLoadBalancerPort":
            suggest = "control_plane_load_balancer_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterLoadBalancerPortConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterLoadBalancerPortConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterLoadBalancerPortConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_load_balancer_port: int):
        """
        :param int control_plane_load_balancer_port: The port that control plane hosted load balancers will listen on.
        """
        BareMetalAdminClusterLoadBalancerPortConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            control_plane_load_balancer_port=control_plane_load_balancer_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             control_plane_load_balancer_port: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("control_plane_load_balancer_port", control_plane_load_balancer_port)

    @property
    @pulumi.getter(name="controlPlaneLoadBalancerPort")
    def control_plane_load_balancer_port(self) -> int:
        """
        The port that control plane hosted load balancers will listen on.
        """
        return pulumi.get(self, "control_plane_load_balancer_port")


@pulumi.output_type
class BareMetalAdminClusterLoadBalancerVipConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneVip":
            suggest = "control_plane_vip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterLoadBalancerVipConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterLoadBalancerVipConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterLoadBalancerVipConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_vip: str):
        """
        :param str control_plane_vip: The VIP which you previously set aside for the Kubernetes API of this Bare Metal Admin Cluster.
        """
        BareMetalAdminClusterLoadBalancerVipConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            control_plane_vip=control_plane_vip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             control_plane_vip: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("control_plane_vip", control_plane_vip)

    @property
    @pulumi.getter(name="controlPlaneVip")
    def control_plane_vip(self) -> str:
        """
        The VIP which you previously set aside for the Kubernetes API of this Bare Metal Admin Cluster.
        """
        return pulumi.get(self, "control_plane_vip")


@pulumi.output_type
class BareMetalAdminClusterMaintenanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maintenanceAddressCidrBlocks":
            suggest = "maintenance_address_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterMaintenanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterMaintenanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterMaintenanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maintenance_address_cidr_blocks: Sequence[str]):
        """
        :param Sequence[str] maintenance_address_cidr_blocks: All IPv4 address from these ranges will be placed into maintenance mode.
               Nodes in maintenance mode will be cordoned and drained. When both of these
               are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set
               on the node resource.
        """
        BareMetalAdminClusterMaintenanceConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maintenance_address_cidr_blocks=maintenance_address_cidr_blocks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maintenance_address_cidr_blocks: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("maintenance_address_cidr_blocks", maintenance_address_cidr_blocks)

    @property
    @pulumi.getter(name="maintenanceAddressCidrBlocks")
    def maintenance_address_cidr_blocks(self) -> Sequence[str]:
        """
        All IPv4 address from these ranges will be placed into maintenance mode.
        Nodes in maintenance mode will be cordoned and drained. When both of these
        are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set
        on the node resource.
        """
        return pulumi.get(self, "maintenance_address_cidr_blocks")


@pulumi.output_type
class BareMetalAdminClusterNetworkConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "islandModeCidr":
            suggest = "island_mode_cidr"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterNetworkConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterNetworkConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterNetworkConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 island_mode_cidr: Optional['outputs.BareMetalAdminClusterNetworkConfigIslandModeCidr'] = None):
        """
        :param 'BareMetalAdminClusterNetworkConfigIslandModeCidrArgs' island_mode_cidr: A nested object resource
               Structure is documented below.
        """
        BareMetalAdminClusterNetworkConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            island_mode_cidr=island_mode_cidr,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             island_mode_cidr: Optional['outputs.BareMetalAdminClusterNetworkConfigIslandModeCidr'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if island_mode_cidr is not None:
            _setter("island_mode_cidr", island_mode_cidr)

    @property
    @pulumi.getter(name="islandModeCidr")
    def island_mode_cidr(self) -> Optional['outputs.BareMetalAdminClusterNetworkConfigIslandModeCidr']:
        """
        A nested object resource
        Structure is documented below.
        """
        return pulumi.get(self, "island_mode_cidr")


@pulumi.output_type
class BareMetalAdminClusterNetworkConfigIslandModeCidr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podAddressCidrBlocks":
            suggest = "pod_address_cidr_blocks"
        elif key == "serviceAddressCidrBlocks":
            suggest = "service_address_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterNetworkConfigIslandModeCidr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterNetworkConfigIslandModeCidr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterNetworkConfigIslandModeCidr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_address_cidr_blocks: Sequence[str],
                 service_address_cidr_blocks: Sequence[str]):
        """
        :param Sequence[str] pod_address_cidr_blocks: All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        :param Sequence[str] service_address_cidr_blocks: All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        BareMetalAdminClusterNetworkConfigIslandModeCidr._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pod_address_cidr_blocks=pod_address_cidr_blocks,
            service_address_cidr_blocks=service_address_cidr_blocks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pod_address_cidr_blocks: Sequence[str],
             service_address_cidr_blocks: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("pod_address_cidr_blocks", pod_address_cidr_blocks)
        _setter("service_address_cidr_blocks", service_address_cidr_blocks)

    @property
    @pulumi.getter(name="podAddressCidrBlocks")
    def pod_address_cidr_blocks(self) -> Sequence[str]:
        """
        All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        return pulumi.get(self, "pod_address_cidr_blocks")

    @property
    @pulumi.getter(name="serviceAddressCidrBlocks")
    def service_address_cidr_blocks(self) -> Sequence[str]:
        """
        All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        return pulumi.get(self, "service_address_cidr_blocks")


@pulumi.output_type
class BareMetalAdminClusterNodeAccessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loginUser":
            suggest = "login_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterNodeAccessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterNodeAccessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterNodeAccessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login_user: Optional[str] = None):
        """
        :param str login_user: LoginUser is the user name used to access node machines.
               It defaults to "root" if not set.
        """
        BareMetalAdminClusterNodeAccessConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            login_user=login_user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             login_user: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if login_user is not None:
            _setter("login_user", login_user)

    @property
    @pulumi.getter(name="loginUser")
    def login_user(self) -> Optional[str]:
        """
        LoginUser is the user name used to access node machines.
        It defaults to "root" if not set.
        """
        return pulumi.get(self, "login_user")


@pulumi.output_type
class BareMetalAdminClusterNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxPodsPerNode":
            suggest = "max_pods_per_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_pods_per_node: Optional[int] = None):
        """
        :param int max_pods_per_node: The maximum number of pods a node can run. The size of the CIDR range
               assigned to the node will be derived from this parameter.
        """
        BareMetalAdminClusterNodeConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_pods_per_node=max_pods_per_node,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_pods_per_node: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if max_pods_per_node is not None:
            _setter("max_pods_per_node", max_pods_per_node)

    @property
    @pulumi.getter(name="maxPodsPerNode")
    def max_pods_per_node(self) -> Optional[int]:
        """
        The maximum number of pods a node can run. The size of the CIDR range
        assigned to the node will be derived from this parameter.
        """
        return pulumi.get(self, "max_pods_per_node")


@pulumi.output_type
class BareMetalAdminClusterProxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noProxies":
            suggest = "no_proxies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterProxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterProxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterProxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: str,
                 no_proxies: Optional[Sequence[str]] = None):
        """
        :param str uri: Specifies the address of your proxy server.
               Examples: http://domain
               WARNING: Do not provide credentials in the format
               http://(username:password@)domain these will be rejected by the server.
        :param Sequence[str] no_proxies: A list of IPs, hostnames, and domains that should skip the proxy.
               Examples: ["127.0.0.1", "example.com", ".corp", "localhost"].
        """
        BareMetalAdminClusterProxy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            no_proxies=no_proxies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: str,
             no_proxies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("uri", uri)
        if no_proxies is not None:
            _setter("no_proxies", no_proxies)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Specifies the address of your proxy server.
        Examples: http://domain
        WARNING: Do not provide credentials in the format
        http://(username:password@)domain these will be rejected by the server.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="noProxies")
    def no_proxies(self) -> Optional[Sequence[str]]:
        """
        A list of IPs, hostnames, and domains that should skip the proxy.
        Examples: ["127.0.0.1", "example.com", ".corp", "localhost"].
        """
        return pulumi.get(self, "no_proxies")


@pulumi.output_type
class BareMetalAdminClusterSecurityConfig(dict):
    def __init__(__self__, *,
                 authorization: Optional['outputs.BareMetalAdminClusterSecurityConfigAuthorization'] = None):
        """
        :param 'BareMetalAdminClusterSecurityConfigAuthorizationArgs' authorization: Configures user access to the Bare Metal User cluster.
               Structure is documented below.
        """
        BareMetalAdminClusterSecurityConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authorization=authorization,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authorization: Optional['outputs.BareMetalAdminClusterSecurityConfigAuthorization'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if authorization is not None:
            _setter("authorization", authorization)

    @property
    @pulumi.getter
    def authorization(self) -> Optional['outputs.BareMetalAdminClusterSecurityConfigAuthorization']:
        """
        Configures user access to the Bare Metal User cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "authorization")


@pulumi.output_type
class BareMetalAdminClusterSecurityConfigAuthorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsers":
            suggest = "admin_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterSecurityConfigAuthorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterSecurityConfigAuthorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterSecurityConfigAuthorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_users: Sequence['outputs.BareMetalAdminClusterSecurityConfigAuthorizationAdminUser']):
        """
        :param Sequence['BareMetalAdminClusterSecurityConfigAuthorizationAdminUserArgs'] admin_users: Users that will be granted the cluster-admin role on the cluster, providing full access to the cluster.
               Structure is documented below.
        """
        BareMetalAdminClusterSecurityConfigAuthorization._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_users=admin_users,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_users: Sequence['outputs.BareMetalAdminClusterSecurityConfigAuthorizationAdminUser'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("admin_users", admin_users)

    @property
    @pulumi.getter(name="adminUsers")
    def admin_users(self) -> Sequence['outputs.BareMetalAdminClusterSecurityConfigAuthorizationAdminUser']:
        """
        Users that will be granted the cluster-admin role on the cluster, providing full access to the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "admin_users")


@pulumi.output_type
class BareMetalAdminClusterSecurityConfigAuthorizationAdminUser(dict):
    def __init__(__self__, *,
                 username: str):
        """
        :param str username: The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        BareMetalAdminClusterSecurityConfigAuthorizationAdminUser._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("username", username)

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class BareMetalAdminClusterStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.BareMetalAdminClusterStatusCondition']] = None,
                 error_message: Optional[str] = None):
        """
        :param Sequence['BareMetalAdminClusterStatusConditionArgs'] conditions: (Output)
               ResourceConditions provide a standard mechanism for higher-level status reporting from admin cluster controller.
               Structure is documented below.
        :param str error_message: (Output)
               Human-friendly representation of the error message from the admin cluster
               controller. The error message can be temporary as the admin cluster
               controller creates a cluster or node pool. If the error message persists
               for a longer period of time, it can be used to surface error message to
               indicate real problems requiring user intervention.
        """
        BareMetalAdminClusterStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditions=conditions,
            error_message=error_message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditions: Optional[Sequence['outputs.BareMetalAdminClusterStatusCondition']] = None,
             error_message: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditions is not None:
            _setter("conditions", conditions)
        if error_message is not None:
            _setter("error_message", error_message)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.BareMetalAdminClusterStatusCondition']]:
        """
        (Output)
        ResourceConditions provide a standard mechanism for higher-level status reporting from admin cluster controller.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        """
        (Output)
        Human-friendly representation of the error message from the admin cluster
        controller. The error message can be temporary as the admin cluster
        controller creates a cluster or node pool. If the error message persists
        for a longer period of time, it can be used to surface error message to
        indicate real problems requiring user intervention.
        """
        return pulumi.get(self, "error_message")


@pulumi.output_type
class BareMetalAdminClusterStatusCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterStatusCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterStatusCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterStatusCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 state: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str last_transition_time: (Output)
               Last time the condition transit from one status to another.
        :param str message: Human-readable message indicating details about last transition.
        :param str reason: (Output)
               A human-readable message of the check failure.
        :param str state: (Output)
               The lifecycle state of the condition.
        :param str type: Type of the condition.
               (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        BareMetalAdminClusterStatusCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            last_transition_time=last_transition_time,
            message=message,
            reason=reason,
            state=state,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             last_transition_time: Optional[str] = None,
             message: Optional[str] = None,
             reason: Optional[str] = None,
             state: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if last_transition_time is not None:
            _setter("last_transition_time", last_transition_time)
        if message is not None:
            _setter("message", message)
        if reason is not None:
            _setter("reason", reason)
        if state is not None:
            _setter("state", state)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        (Output)
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Human-readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        (Output)
        A human-readable message of the check failure.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        (Output)
        The lifecycle state of the condition.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the condition.
        (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class BareMetalAdminClusterStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lvpNodeMountsConfig":
            suggest = "lvp_node_mounts_config"
        elif key == "lvpShareConfig":
            suggest = "lvp_share_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lvp_node_mounts_config: 'outputs.BareMetalAdminClusterStorageLvpNodeMountsConfig',
                 lvp_share_config: 'outputs.BareMetalAdminClusterStorageLvpShareConfig'):
        """
        :param 'BareMetalAdminClusterStorageLvpNodeMountsConfigArgs' lvp_node_mounts_config: Specifies the config for local PersistentVolumes backed
               by mounted node disks. These disks need to be formatted and mounted by the
               user, which can be done before or after cluster creation.
               Structure is documented below.
        :param 'BareMetalAdminClusterStorageLvpShareConfigArgs' lvp_share_config: Specifies the config for local PersistentVolumes backed by
               subdirectories in a shared filesystem. These subdirectores are
               automatically created during cluster creation.
               Structure is documented below.
        """
        BareMetalAdminClusterStorage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lvp_node_mounts_config=lvp_node_mounts_config,
            lvp_share_config=lvp_share_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lvp_node_mounts_config: 'outputs.BareMetalAdminClusterStorageLvpNodeMountsConfig',
             lvp_share_config: 'outputs.BareMetalAdminClusterStorageLvpShareConfig',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("lvp_node_mounts_config", lvp_node_mounts_config)
        _setter("lvp_share_config", lvp_share_config)

    @property
    @pulumi.getter(name="lvpNodeMountsConfig")
    def lvp_node_mounts_config(self) -> 'outputs.BareMetalAdminClusterStorageLvpNodeMountsConfig':
        """
        Specifies the config for local PersistentVolumes backed
        by mounted node disks. These disks need to be formatted and mounted by the
        user, which can be done before or after cluster creation.
        Structure is documented below.
        """
        return pulumi.get(self, "lvp_node_mounts_config")

    @property
    @pulumi.getter(name="lvpShareConfig")
    def lvp_share_config(self) -> 'outputs.BareMetalAdminClusterStorageLvpShareConfig':
        """
        Specifies the config for local PersistentVolumes backed by
        subdirectories in a shared filesystem. These subdirectores are
        automatically created during cluster creation.
        Structure is documented below.
        """
        return pulumi.get(self, "lvp_share_config")


@pulumi.output_type
class BareMetalAdminClusterStorageLvpNodeMountsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterStorageLvpNodeMountsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterStorageLvpNodeMountsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterStorageLvpNodeMountsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 storage_class: str):
        """
        :param str path: The host machine path.
        :param str storage_class: The StorageClass name that PVs will be created with.
        """
        BareMetalAdminClusterStorageLvpNodeMountsConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            storage_class=storage_class,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: str,
             storage_class: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("path", path)
        _setter("storage_class", storage_class)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The host machine path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> str:
        """
        The StorageClass name that PVs will be created with.
        """
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class BareMetalAdminClusterStorageLvpShareConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lvpConfig":
            suggest = "lvp_config"
        elif key == "sharedPathPvCount":
            suggest = "shared_path_pv_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterStorageLvpShareConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterStorageLvpShareConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterStorageLvpShareConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lvp_config: 'outputs.BareMetalAdminClusterStorageLvpShareConfigLvpConfig',
                 shared_path_pv_count: Optional[int] = None):
        """
        :param 'BareMetalAdminClusterStorageLvpShareConfigLvpConfigArgs' lvp_config: Defines the machine path and storage class for the LVP Share.
               Structure is documented below.
        :param int shared_path_pv_count: The number of subdirectories to create under path.
        """
        BareMetalAdminClusterStorageLvpShareConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lvp_config=lvp_config,
            shared_path_pv_count=shared_path_pv_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lvp_config: 'outputs.BareMetalAdminClusterStorageLvpShareConfigLvpConfig',
             shared_path_pv_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("lvp_config", lvp_config)
        if shared_path_pv_count is not None:
            _setter("shared_path_pv_count", shared_path_pv_count)

    @property
    @pulumi.getter(name="lvpConfig")
    def lvp_config(self) -> 'outputs.BareMetalAdminClusterStorageLvpShareConfigLvpConfig':
        """
        Defines the machine path and storage class for the LVP Share.
        Structure is documented below.
        """
        return pulumi.get(self, "lvp_config")

    @property
    @pulumi.getter(name="sharedPathPvCount")
    def shared_path_pv_count(self) -> Optional[int]:
        """
        The number of subdirectories to create under path.
        """
        return pulumi.get(self, "shared_path_pv_count")


@pulumi.output_type
class BareMetalAdminClusterStorageLvpShareConfigLvpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalAdminClusterStorageLvpShareConfigLvpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalAdminClusterStorageLvpShareConfigLvpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalAdminClusterStorageLvpShareConfigLvpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 storage_class: str):
        """
        :param str path: The host machine path.
        :param str storage_class: The StorageClass name that PVs will be created with.
        """
        BareMetalAdminClusterStorageLvpShareConfigLvpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            storage_class=storage_class,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: str,
             storage_class: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("path", path)
        _setter("storage_class", storage_class)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The host machine path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> str:
        """
        The StorageClass name that PVs will be created with.
        """
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class BareMetalAdminClusterValidationCheck(dict):
    def __init__(__self__, *,
                 options: Optional[str] = None,
                 scenario: Optional[str] = None,
                 statuses: Optional[Sequence['outputs.BareMetalAdminClusterValidationCheckStatus']] = None):
        """
        :param str options: (Output)
               Options used for the validation check.
        :param str scenario: (Output)
               The scenario when the preflight checks were run..
        :param Sequence['BareMetalAdminClusterValidationCheckStatusArgs'] statuses: (Output)
               Specifies the detailed validation check status
               Structure is documented below.
        """
        BareMetalAdminClusterValidationCheck._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            options=options,
            scenario=scenario,
            statuses=statuses,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             options: Optional[str] = None,
             scenario: Optional[str] = None,
             statuses: Optional[Sequence['outputs.BareMetalAdminClusterValidationCheckStatus']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if options is not None:
            _setter("options", options)
        if scenario is not None:
            _setter("scenario", scenario)
        if statuses is not None:
            _setter("statuses", statuses)

    @property
    @pulumi.getter
    def options(self) -> Optional[str]:
        """
        (Output)
        Options used for the validation check.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def scenario(self) -> Optional[str]:
        """
        (Output)
        The scenario when the preflight checks were run..
        """
        return pulumi.get(self, "scenario")

    @property
    @pulumi.getter
    def statuses(self) -> Optional[Sequence['outputs.BareMetalAdminClusterValidationCheckStatus']]:
        """
        (Output)
        Specifies the detailed validation check status
        Structure is documented below.
        """
        return pulumi.get(self, "statuses")


@pulumi.output_type
class BareMetalAdminClusterValidationCheckStatus(dict):
    def __init__(__self__, *,
                 results: Optional[Sequence['outputs.BareMetalAdminClusterValidationCheckStatusResult']] = None):
        """
        :param Sequence['BareMetalAdminClusterValidationCheckStatusResultArgs'] results: (Output)
               Individual checks which failed as part of the Preflight check execution.
               Structure is documented below.
        """
        BareMetalAdminClusterValidationCheckStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            results=results,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             results: Optional[Sequence['outputs.BareMetalAdminClusterValidationCheckStatusResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if results is not None:
            _setter("results", results)

    @property
    @pulumi.getter
    def results(self) -> Optional[Sequence['outputs.BareMetalAdminClusterValidationCheckStatusResult']]:
        """
        (Output)
        Individual checks which failed as part of the Preflight check execution.
        Structure is documented below.
        """
        return pulumi.get(self, "results")


@pulumi.output_type
class BareMetalAdminClusterValidationCheckStatusResult(dict):
    def __init__(__self__, *,
                 category: Optional[str] = None,
                 description: Optional[str] = None,
                 details: Optional[str] = None,
                 options: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        :param str category: (Output)
               The category of the validation.
        :param str description: A human readable description of this Bare Metal Admin Cluster.
        :param str details: (Output)
               Detailed failure information, which might be unformatted.
        :param str options: (Output)
               Options used for the validation check.
        :param str reason: (Output)
               A human-readable message of the check failure.
        """
        BareMetalAdminClusterValidationCheckStatusResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            description=description,
            details=details,
            options=options,
            reason=reason,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             description: Optional[str] = None,
             details: Optional[str] = None,
             options: Optional[str] = None,
             reason: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if description is not None:
            _setter("description", description)
        if details is not None:
            _setter("details", details)
        if options is not None:
            _setter("options", options)
        if reason is not None:
            _setter("reason", reason)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        (Output)
        The category of the validation.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A human readable description of this Bare Metal Admin Cluster.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Optional[str]:
        """
        (Output)
        Detailed failure information, which might be unformatted.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def options(self) -> Optional[str]:
        """
        (Output)
        Options used for the validation check.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        (Output)
        A human-readable message of the check failure.
        """
        return pulumi.get(self, "reason")


@pulumi.output_type
class BareMetalClusterBinaryAuthorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "evaluationMode":
            suggest = "evaluation_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterBinaryAuthorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterBinaryAuthorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterBinaryAuthorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 evaluation_mode: Optional[str] = None):
        """
        :param str evaluation_mode: Mode of operation for binauthz policy evaluation. If unspecified,
               defaults to DISABLED.
               Possible values are: `DISABLED`, `PROJECT_SINGLETON_POLICY_ENFORCE`.
        """
        BareMetalClusterBinaryAuthorization._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            evaluation_mode=evaluation_mode,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             evaluation_mode: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if evaluation_mode is not None:
            _setter("evaluation_mode", evaluation_mode)

    @property
    @pulumi.getter(name="evaluationMode")
    def evaluation_mode(self) -> Optional[str]:
        """
        Mode of operation for binauthz policy evaluation. If unspecified,
        defaults to DISABLED.
        Possible values are: `DISABLED`, `PROJECT_SINGLETON_POLICY_ENFORCE`.
        """
        return pulumi.get(self, "evaluation_mode")


@pulumi.output_type
class BareMetalClusterClusterOperations(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableApplicationLogs":
            suggest = "enable_application_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterClusterOperations. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterClusterOperations.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterClusterOperations.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_application_logs: Optional[bool] = None):
        """
        :param bool enable_application_logs: Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        BareMetalClusterClusterOperations._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enable_application_logs=enable_application_logs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enable_application_logs: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enable_application_logs is not None:
            _setter("enable_application_logs", enable_application_logs)

    @property
    @pulumi.getter(name="enableApplicationLogs")
    def enable_application_logs(self) -> Optional[bool]:
        """
        Whether collection of application logs/metrics should be enabled (in addition to system logs/metrics).
        """
        return pulumi.get(self, "enable_application_logs")


@pulumi.output_type
class BareMetalClusterControlPlane(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneNodePoolConfig":
            suggest = "control_plane_node_pool_config"
        elif key == "apiServerArgs":
            suggest = "api_server_args"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterControlPlane. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterControlPlane.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterControlPlane.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_node_pool_config: 'outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfig',
                 api_server_args: Optional[Sequence['outputs.BareMetalClusterControlPlaneApiServerArg']] = None):
        """
        :param 'BareMetalClusterControlPlaneControlPlaneNodePoolConfigArgs' control_plane_node_pool_config: Configures the node pool running the control plane. If specified the corresponding NodePool will be created for the cluster's control plane. The NodePool will have the same name and namespace as the cluster.
               Structure is documented below.
        :param Sequence['BareMetalClusterControlPlaneApiServerArgArgs'] api_server_args: Customizes the default API server args. Only a subset of
               customized flags are supported. Please refer to the API server
               documentation below to know the exact format:
               https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
               Structure is documented below.
        """
        BareMetalClusterControlPlane._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            control_plane_node_pool_config=control_plane_node_pool_config,
            api_server_args=api_server_args,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             control_plane_node_pool_config: 'outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfig',
             api_server_args: Optional[Sequence['outputs.BareMetalClusterControlPlaneApiServerArg']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("control_plane_node_pool_config", control_plane_node_pool_config)
        if api_server_args is not None:
            _setter("api_server_args", api_server_args)

    @property
    @pulumi.getter(name="controlPlaneNodePoolConfig")
    def control_plane_node_pool_config(self) -> 'outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfig':
        """
        Configures the node pool running the control plane. If specified the corresponding NodePool will be created for the cluster's control plane. The NodePool will have the same name and namespace as the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "control_plane_node_pool_config")

    @property
    @pulumi.getter(name="apiServerArgs")
    def api_server_args(self) -> Optional[Sequence['outputs.BareMetalClusterControlPlaneApiServerArg']]:
        """
        Customizes the default API server args. Only a subset of
        customized flags are supported. Please refer to the API server
        documentation below to know the exact format:
        https://kubernetes.io/docs/reference/command-line-tools-reference/kube-apiserver/
        Structure is documented below.
        """
        return pulumi.get(self, "api_server_args")


@pulumi.output_type
class BareMetalClusterControlPlaneApiServerArg(dict):
    def __init__(__self__, *,
                 argument: str,
                 value: str):
        """
        :param str argument: The argument name as it appears on the API Server command line please make sure to remove the leading dashes.
        :param str value: The value of the arg as it will be passed to the API Server command line.
        """
        BareMetalClusterControlPlaneApiServerArg._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            argument=argument,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             argument: str,
             value: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("argument", argument)
        _setter("value", value)

    @property
    @pulumi.getter
    def argument(self) -> str:
        """
        The argument name as it appears on the API Server command line please make sure to remove the leading dashes.
        """
        return pulumi.get(self, "argument")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        The value of the arg as it will be passed to the API Server command line.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BareMetalClusterControlPlaneControlPlaneNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodePoolConfig":
            suggest = "node_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterControlPlaneControlPlaneNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterControlPlaneControlPlaneNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterControlPlaneControlPlaneNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_pool_config: 'outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig'):
        """
        :param 'BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigArgs' node_pool_config: The generic configuration for a node pool running the control plane.
               Structure is documented below.
        """
        BareMetalClusterControlPlaneControlPlaneNodePoolConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            node_pool_config=node_pool_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             node_pool_config: 'outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("node_pool_config", node_pool_config)

    @property
    @pulumi.getter(name="nodePoolConfig")
    def node_pool_config(self) -> 'outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig':
        """
        The generic configuration for a node pool running the control plane.
        Structure is documented below.
        """
        return pulumi.get(self, "node_pool_config")


@pulumi.output_type
class BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeConfigs":
            suggest = "node_configs"
        elif key == "operatingSystem":
            suggest = "operating_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Mapping[str, str]] = None,
                 node_configs: Optional[Sequence['outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig']] = None,
                 operating_system: Optional[str] = None,
                 taints: Optional[Sequence['outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint']] = None):
        """
        :param Mapping[str, str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param Sequence['BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfigArgs'] node_configs: The list of machine addresses in the Bare Metal Node Pool.
               Structure is documented below.
        :param str operating_system: Specifies the nodes operating system (default: LINUX).
        :param Sequence['BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaintArgs'] taints: The initial taints assigned to nodes of this node pool.
               Structure is documented below.
        """
        BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            labels=labels,
            node_configs=node_configs,
            operating_system=operating_system,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             labels: Optional[Mapping[str, str]] = None,
             node_configs: Optional[Sequence['outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig']] = None,
             operating_system: Optional[str] = None,
             taints: Optional[Sequence['outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if labels is not None:
            _setter("labels", labels)
        if node_configs is not None:
            _setter("node_configs", node_configs)
        if operating_system is not None:
            _setter("operating_system", operating_system)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeConfigs")
    def node_configs(self) -> Optional[Sequence['outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig']]:
        """
        The list of machine addresses in the Bare Metal Node Pool.
        Structure is documented below.
        """
        return pulumi.get(self, "node_configs")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[str]:
        """
        Specifies the nodes operating system (default: LINUX).
        """
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint']]:
        """
        The initial taints assigned to nodes of this node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeIp":
            suggest = "node_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Mapping[str, str]] = None,
                 node_ip: Optional[str] = None):
        """
        :param Mapping[str, str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param str node_ip: The default IPv4 address for SSH access and Kubernetes node.
               Example: 192.168.0.1
        """
        BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigNodeConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            labels=labels,
            node_ip=node_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             labels: Optional[Mapping[str, str]] = None,
             node_ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if labels is not None:
            _setter("labels", labels)
        if node_ip is not None:
            _setter("node_ip", node_ip)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> Optional[str]:
        """
        The default IPv4 address for SSH access and Kubernetes node.
        Example: 192.168.0.1
        """
        return pulumi.get(self, "node_ip")


@pulumi.output_type
class BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str effect: Specifies the nodes operating system (default: LINUX).
               Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        :param str key: Key associated with the effect.
        :param str value: Value associated with the effect.
        """
        BareMetalClusterControlPlaneControlPlaneNodePoolConfigNodePoolConfigTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        Specifies the nodes operating system (default: LINUX).
        Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BareMetalClusterFleet(dict):
    def __init__(__self__, *,
                 membership: Optional[str] = None):
        """
        :param str membership: (Output)
               The name of the managed Hub Membership resource associated to this cluster.
               Membership names are formatted as
               `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        BareMetalClusterFleet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            membership=membership,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             membership: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if membership is not None:
            _setter("membership", membership)

    @property
    @pulumi.getter
    def membership(self) -> Optional[str]:
        """
        (Output)
        The name of the managed Hub Membership resource associated to this cluster.
        Membership names are formatted as
        `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        return pulumi.get(self, "membership")


@pulumi.output_type
class BareMetalClusterLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "portConfig":
            suggest = "port_config"
        elif key == "vipConfig":
            suggest = "vip_config"
        elif key == "bgpLbConfig":
            suggest = "bgp_lb_config"
        elif key == "manualLbConfig":
            suggest = "manual_lb_config"
        elif key == "metalLbConfig":
            suggest = "metal_lb_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 port_config: 'outputs.BareMetalClusterLoadBalancerPortConfig',
                 vip_config: 'outputs.BareMetalClusterLoadBalancerVipConfig',
                 bgp_lb_config: Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfig'] = None,
                 manual_lb_config: Optional['outputs.BareMetalClusterLoadBalancerManualLbConfig'] = None,
                 metal_lb_config: Optional['outputs.BareMetalClusterLoadBalancerMetalLbConfig'] = None):
        """
        :param 'BareMetalClusterLoadBalancerPortConfigArgs' port_config: Specifies the load balancer ports.
               Structure is documented below.
        :param 'BareMetalClusterLoadBalancerVipConfigArgs' vip_config: Specified the Bare Metal Load Balancer Config
               Structure is documented below.
        :param 'BareMetalClusterLoadBalancerBgpLbConfigArgs' bgp_lb_config: Configuration for BGP typed load balancers.
               Structure is documented below.
        :param 'BareMetalClusterLoadBalancerManualLbConfigArgs' manual_lb_config: A nested object resource
               Structure is documented below.
        :param 'BareMetalClusterLoadBalancerMetalLbConfigArgs' metal_lb_config: A nested object resource
               Structure is documented below.
        """
        BareMetalClusterLoadBalancer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            port_config=port_config,
            vip_config=vip_config,
            bgp_lb_config=bgp_lb_config,
            manual_lb_config=manual_lb_config,
            metal_lb_config=metal_lb_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             port_config: 'outputs.BareMetalClusterLoadBalancerPortConfig',
             vip_config: 'outputs.BareMetalClusterLoadBalancerVipConfig',
             bgp_lb_config: Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfig'] = None,
             manual_lb_config: Optional['outputs.BareMetalClusterLoadBalancerManualLbConfig'] = None,
             metal_lb_config: Optional['outputs.BareMetalClusterLoadBalancerMetalLbConfig'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("port_config", port_config)
        _setter("vip_config", vip_config)
        if bgp_lb_config is not None:
            _setter("bgp_lb_config", bgp_lb_config)
        if manual_lb_config is not None:
            _setter("manual_lb_config", manual_lb_config)
        if metal_lb_config is not None:
            _setter("metal_lb_config", metal_lb_config)

    @property
    @pulumi.getter(name="portConfig")
    def port_config(self) -> 'outputs.BareMetalClusterLoadBalancerPortConfig':
        """
        Specifies the load balancer ports.
        Structure is documented below.
        """
        return pulumi.get(self, "port_config")

    @property
    @pulumi.getter(name="vipConfig")
    def vip_config(self) -> 'outputs.BareMetalClusterLoadBalancerVipConfig':
        """
        Specified the Bare Metal Load Balancer Config
        Structure is documented below.
        """
        return pulumi.get(self, "vip_config")

    @property
    @pulumi.getter(name="bgpLbConfig")
    def bgp_lb_config(self) -> Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfig']:
        """
        Configuration for BGP typed load balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "bgp_lb_config")

    @property
    @pulumi.getter(name="manualLbConfig")
    def manual_lb_config(self) -> Optional['outputs.BareMetalClusterLoadBalancerManualLbConfig']:
        """
        A nested object resource
        Structure is documented below.
        """
        return pulumi.get(self, "manual_lb_config")

    @property
    @pulumi.getter(name="metalLbConfig")
    def metal_lb_config(self) -> Optional['outputs.BareMetalClusterLoadBalancerMetalLbConfig']:
        """
        A nested object resource
        Structure is documented below.
        """
        return pulumi.get(self, "metal_lb_config")


@pulumi.output_type
class BareMetalClusterLoadBalancerBgpLbConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPools":
            suggest = "address_pools"
        elif key == "bgpPeerConfigs":
            suggest = "bgp_peer_configs"
        elif key == "loadBalancerNodePoolConfig":
            suggest = "load_balancer_node_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerBgpLbConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_pools: Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigAddressPool'],
                 asn: int,
                 bgp_peer_configs: Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfig'],
                 load_balancer_node_pool_config: Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfig'] = None):
        """
        :param Sequence['BareMetalClusterLoadBalancerBgpLbConfigAddressPoolArgs'] address_pools: AddressPools is a list of non-overlapping IP pools used by load balancer
               typed services. All addresses must be routable to load balancer nodes.
               IngressVIP must be included in the pools.
               Structure is documented below.
        :param int asn: BGP autonomous system number (ASN) of the cluster.
               This field can be updated after cluster creation.
        :param Sequence['BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfigArgs'] bgp_peer_configs: The list of BGP peers that the cluster will connect to.
               At least one peer must be configured for each control plane node.
               Control plane nodes will connect to these peers to advertise the control
               plane VIP. The Services load balancer also uses these peers by default.
               This field can be updated after cluster creation.
               Structure is documented below.
        :param 'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigArgs' load_balancer_node_pool_config: Specifies the node pool running data plane load balancing. L2 connectivity
               is required among nodes in this pool. If missing, the control plane node
               pool is used for data plane load balancing.
               Structure is documented below.
        """
        BareMetalClusterLoadBalancerBgpLbConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address_pools=address_pools,
            asn=asn,
            bgp_peer_configs=bgp_peer_configs,
            load_balancer_node_pool_config=load_balancer_node_pool_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address_pools: Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigAddressPool'],
             asn: int,
             bgp_peer_configs: Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfig'],
             load_balancer_node_pool_config: Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfig'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("address_pools", address_pools)
        _setter("asn", asn)
        _setter("bgp_peer_configs", bgp_peer_configs)
        if load_balancer_node_pool_config is not None:
            _setter("load_balancer_node_pool_config", load_balancer_node_pool_config)

    @property
    @pulumi.getter(name="addressPools")
    def address_pools(self) -> Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigAddressPool']:
        """
        AddressPools is a list of non-overlapping IP pools used by load balancer
        typed services. All addresses must be routable to load balancer nodes.
        IngressVIP must be included in the pools.
        Structure is documented below.
        """
        return pulumi.get(self, "address_pools")

    @property
    @pulumi.getter
    def asn(self) -> int:
        """
        BGP autonomous system number (ASN) of the cluster.
        This field can be updated after cluster creation.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="bgpPeerConfigs")
    def bgp_peer_configs(self) -> Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfig']:
        """
        The list of BGP peers that the cluster will connect to.
        At least one peer must be configured for each control plane node.
        Control plane nodes will connect to these peers to advertise the control
        plane VIP. The Services load balancer also uses these peers by default.
        This field can be updated after cluster creation.
        Structure is documented below.
        """
        return pulumi.get(self, "bgp_peer_configs")

    @property
    @pulumi.getter(name="loadBalancerNodePoolConfig")
    def load_balancer_node_pool_config(self) -> Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfig']:
        """
        Specifies the node pool running data plane load balancing. L2 connectivity
        is required among nodes in this pool. If missing, the control plane node
        pool is used for data plane load balancing.
        Structure is documented below.
        """
        return pulumi.get(self, "load_balancer_node_pool_config")


@pulumi.output_type
class BareMetalClusterLoadBalancerBgpLbConfigAddressPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avoidBuggyIps":
            suggest = "avoid_buggy_ips"
        elif key == "manualAssign":
            suggest = "manual_assign"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerBgpLbConfigAddressPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigAddressPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigAddressPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Sequence[str],
                 pool: str,
                 avoid_buggy_ips: Optional[bool] = None,
                 manual_assign: Optional[str] = None):
        """
        :param Sequence[str] addresses: The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        :param str pool: The name of the address pool.
        :param bool avoid_buggy_ips: If true, avoid using IPs ending in .0 or .255.
               This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        :param str manual_assign: If true, prevent IP addresses from being automatically assigned.
        """
        BareMetalClusterLoadBalancerBgpLbConfigAddressPool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            addresses=addresses,
            pool=pool,
            avoid_buggy_ips=avoid_buggy_ips,
            manual_assign=manual_assign,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             addresses: Sequence[str],
             pool: str,
             avoid_buggy_ips: Optional[bool] = None,
             manual_assign: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("addresses", addresses)
        _setter("pool", pool)
        if avoid_buggy_ips is not None:
            _setter("avoid_buggy_ips", avoid_buggy_ips)
        if manual_assign is not None:
            _setter("manual_assign", manual_assign)

    @property
    @pulumi.getter
    def addresses(self) -> Sequence[str]:
        """
        The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def pool(self) -> str:
        """
        The name of the address pool.
        """
        return pulumi.get(self, "pool")

    @property
    @pulumi.getter(name="avoidBuggyIps")
    def avoid_buggy_ips(self) -> Optional[bool]:
        """
        If true, avoid using IPs ending in .0 or .255.
        This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        """
        return pulumi.get(self, "avoid_buggy_ips")

    @property
    @pulumi.getter(name="manualAssign")
    def manual_assign(self) -> Optional[str]:
        """
        If true, prevent IP addresses from being automatically assigned.
        """
        return pulumi.get(self, "manual_assign")


@pulumi.output_type
class BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "controlPlaneNodes":
            suggest = "control_plane_nodes"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 asn: int,
                 ip_address: str,
                 control_plane_nodes: Optional[Sequence[str]] = None):
        """
        :param int asn: BGP autonomous system number (ASN) for the network that contains the
               external peer device.
        :param str ip_address: The IP address of the external peer device.
        :param Sequence[str] control_plane_nodes: The IP address of the control plane node that connects to the external
               peer.
               If you don't specify any control plane nodes, all control plane nodes
               can connect to the external peer. If you specify one or more IP addresses,
               only the nodes specified participate in peering sessions.
        """
        BareMetalClusterLoadBalancerBgpLbConfigBgpPeerConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            asn=asn,
            ip_address=ip_address,
            control_plane_nodes=control_plane_nodes,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             asn: int,
             ip_address: str,
             control_plane_nodes: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("asn", asn)
        _setter("ip_address", ip_address)
        if control_plane_nodes is not None:
            _setter("control_plane_nodes", control_plane_nodes)

    @property
    @pulumi.getter
    def asn(self) -> int:
        """
        BGP autonomous system number (ASN) for the network that contains the
        external peer device.
        """
        return pulumi.get(self, "asn")

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> str:
        """
        The IP address of the external peer device.
        """
        return pulumi.get(self, "ip_address")

    @property
    @pulumi.getter(name="controlPlaneNodes")
    def control_plane_nodes(self) -> Optional[Sequence[str]]:
        """
        The IP address of the control plane node that connects to the external
        peer.
        If you don't specify any control plane nodes, all control plane nodes
        can connect to the external peer. If you specify one or more IP addresses,
        only the nodes specified participate in peering sessions.
        """
        return pulumi.get(self, "control_plane_nodes")


@pulumi.output_type
class BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodePoolConfig":
            suggest = "node_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_pool_config: Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfig'] = None):
        """
        :param 'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigArgs' node_pool_config: The generic configuration for a node pool running a load balancer.
               Structure is documented below.
        """
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            node_pool_config=node_pool_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             node_pool_config: Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfig'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if node_pool_config is not None:
            _setter("node_pool_config", node_pool_config)

    @property
    @pulumi.getter(name="nodePoolConfig")
    def node_pool_config(self) -> Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfig']:
        """
        The generic configuration for a node pool running a load balancer.
        Structure is documented below.
        """
        return pulumi.get(self, "node_pool_config")


@pulumi.output_type
class BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kubeletConfig":
            suggest = "kubelet_config"
        elif key == "nodeConfigs":
            suggest = "node_configs"
        elif key == "operatingSystem":
            suggest = "operating_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kubelet_config: Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfig'] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 node_configs: Optional[Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig']] = None,
                 operating_system: Optional[str] = None,
                 taints: Optional[Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint']] = None):
        """
        :param 'BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfigArgs' kubelet_config: The modifiable kubelet configurations for the baremetal machines.
               Structure is documented below.
        :param Mapping[str, str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param Sequence['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfigArgs'] node_configs: The list of machine addresses in the Bare Metal Node Pool.
               Structure is documented below.
        :param str operating_system: Specifies the nodes operating system (default: LINUX).
        :param Sequence['BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaintArgs'] taints: The initial taints assigned to nodes of this node pool.
               Structure is documented below.
        """
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            kubelet_config=kubelet_config,
            labels=labels,
            node_configs=node_configs,
            operating_system=operating_system,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             kubelet_config: Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfig'] = None,
             labels: Optional[Mapping[str, str]] = None,
             node_configs: Optional[Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig']] = None,
             operating_system: Optional[str] = None,
             taints: Optional[Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if kubelet_config is not None:
            _setter("kubelet_config", kubelet_config)
        if labels is not None:
            _setter("labels", labels)
        if node_configs is not None:
            _setter("node_configs", node_configs)
        if operating_system is not None:
            _setter("operating_system", operating_system)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter(name="kubeletConfig")
    def kubelet_config(self) -> Optional['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfig']:
        """
        The modifiable kubelet configurations for the baremetal machines.
        Structure is documented below.
        """
        return pulumi.get(self, "kubelet_config")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeConfigs")
    def node_configs(self) -> Optional[Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig']]:
        """
        The list of machine addresses in the Bare Metal Node Pool.
        Structure is documented below.
        """
        return pulumi.get(self, "node_configs")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[str]:
        """
        Specifies the nodes operating system (default: LINUX).
        """
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint']]:
        """
        The initial taints assigned to nodes of this node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "registryBurst":
            suggest = "registry_burst"
        elif key == "registryPullQps":
            suggest = "registry_pull_qps"
        elif key == "serializeImagePullsDisabled":
            suggest = "serialize_image_pulls_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 registry_burst: Optional[int] = None,
                 registry_pull_qps: Optional[int] = None,
                 serialize_image_pulls_disabled: Optional[bool] = None):
        """
        :param int registry_burst: The maximum size of bursty pulls, temporarily allows pulls to burst to this
               number, while still not exceeding registry_pull_qps.
               The value must not be a negative number.
               Updating this field may impact scalability by changing the amount of
               traffic produced by image pulls.
               Defaults to 10.
        :param int registry_pull_qps: The limit of registry pulls per second.
               Setting this value to 0 means no limit.
               Updating this field may impact scalability by changing the amount of
               traffic produced by image pulls.
               Defaults to 5.
        :param bool serialize_image_pulls_disabled: Prevents the Kubelet from pulling multiple images at a time.
               We recommend *not* changing the default value on nodes that run docker
               daemon with version  < 1.9 or an Another Union File System (Aufs) storage
               backend. Issue https://github.com/kubernetes/kubernetes/issues/10959 has
               more details.
        """
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigKubeletConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            registry_burst=registry_burst,
            registry_pull_qps=registry_pull_qps,
            serialize_image_pulls_disabled=serialize_image_pulls_disabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             registry_burst: Optional[int] = None,
             registry_pull_qps: Optional[int] = None,
             serialize_image_pulls_disabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if registry_burst is not None:
            _setter("registry_burst", registry_burst)
        if registry_pull_qps is not None:
            _setter("registry_pull_qps", registry_pull_qps)
        if serialize_image_pulls_disabled is not None:
            _setter("serialize_image_pulls_disabled", serialize_image_pulls_disabled)

    @property
    @pulumi.getter(name="registryBurst")
    def registry_burst(self) -> Optional[int]:
        """
        The maximum size of bursty pulls, temporarily allows pulls to burst to this
        number, while still not exceeding registry_pull_qps.
        The value must not be a negative number.
        Updating this field may impact scalability by changing the amount of
        traffic produced by image pulls.
        Defaults to 10.
        """
        return pulumi.get(self, "registry_burst")

    @property
    @pulumi.getter(name="registryPullQps")
    def registry_pull_qps(self) -> Optional[int]:
        """
        The limit of registry pulls per second.
        Setting this value to 0 means no limit.
        Updating this field may impact scalability by changing the amount of
        traffic produced by image pulls.
        Defaults to 5.
        """
        return pulumi.get(self, "registry_pull_qps")

    @property
    @pulumi.getter(name="serializeImagePullsDisabled")
    def serialize_image_pulls_disabled(self) -> Optional[bool]:
        """
        Prevents the Kubelet from pulling multiple images at a time.
        We recommend *not* changing the default value on nodes that run docker
        daemon with version  < 1.9 or an Another Union File System (Aufs) storage
        backend. Issue https://github.com/kubernetes/kubernetes/issues/10959 has
        more details.
        """
        return pulumi.get(self, "serialize_image_pulls_disabled")


@pulumi.output_type
class BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeIp":
            suggest = "node_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Mapping[str, str]] = None,
                 node_ip: Optional[str] = None):
        """
        :param Mapping[str, str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param str node_ip: The default IPv4 address for SSH access and Kubernetes node.
               Example: 192.168.0.1
        """
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            labels=labels,
            node_ip=node_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             labels: Optional[Mapping[str, str]] = None,
             node_ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if labels is not None:
            _setter("labels", labels)
        if node_ip is not None:
            _setter("node_ip", node_ip)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> Optional[str]:
        """
        The default IPv4 address for SSH access and Kubernetes node.
        Example: 192.168.0.1
        """
        return pulumi.get(self, "node_ip")


@pulumi.output_type
class BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str effect: Specifies the nodes operating system (default: LINUX).
               Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        :param str key: Key associated with the effect.
        :param str value: Value associated with the effect.
        """
        BareMetalClusterLoadBalancerBgpLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        Specifies the nodes operating system (default: LINUX).
        Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BareMetalClusterLoadBalancerManualLbConfig(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Whether manual load balancing is enabled.
        """
        BareMetalClusterLoadBalancerManualLbConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether manual load balancing is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class BareMetalClusterLoadBalancerMetalLbConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPools":
            suggest = "address_pools"
        elif key == "loadBalancerNodePoolConfig":
            suggest = "load_balancer_node_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerMetalLbConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_pools: Sequence['outputs.BareMetalClusterLoadBalancerMetalLbConfigAddressPool'],
                 load_balancer_node_pool_config: Optional['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfig'] = None):
        """
        :param Sequence['BareMetalClusterLoadBalancerMetalLbConfigAddressPoolArgs'] address_pools: AddressPools is a list of non-overlapping IP pools used by load balancer
               typed services. All addresses must be routable to load balancer nodes.
               IngressVIP must be included in the pools.
               Structure is documented below.
        :param 'BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigArgs' load_balancer_node_pool_config: Specifies the load balancer's node pool configuration.
               Structure is documented below.
        """
        BareMetalClusterLoadBalancerMetalLbConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address_pools=address_pools,
            load_balancer_node_pool_config=load_balancer_node_pool_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address_pools: Sequence['outputs.BareMetalClusterLoadBalancerMetalLbConfigAddressPool'],
             load_balancer_node_pool_config: Optional['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfig'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("address_pools", address_pools)
        if load_balancer_node_pool_config is not None:
            _setter("load_balancer_node_pool_config", load_balancer_node_pool_config)

    @property
    @pulumi.getter(name="addressPools")
    def address_pools(self) -> Sequence['outputs.BareMetalClusterLoadBalancerMetalLbConfigAddressPool']:
        """
        AddressPools is a list of non-overlapping IP pools used by load balancer
        typed services. All addresses must be routable to load balancer nodes.
        IngressVIP must be included in the pools.
        Structure is documented below.
        """
        return pulumi.get(self, "address_pools")

    @property
    @pulumi.getter(name="loadBalancerNodePoolConfig")
    def load_balancer_node_pool_config(self) -> Optional['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfig']:
        """
        Specifies the load balancer's node pool configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "load_balancer_node_pool_config")


@pulumi.output_type
class BareMetalClusterLoadBalancerMetalLbConfigAddressPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avoidBuggyIps":
            suggest = "avoid_buggy_ips"
        elif key == "manualAssign":
            suggest = "manual_assign"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerMetalLbConfigAddressPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfigAddressPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfigAddressPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Sequence[str],
                 pool: str,
                 avoid_buggy_ips: Optional[bool] = None,
                 manual_assign: Optional[bool] = None):
        """
        :param Sequence[str] addresses: The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        :param str pool: The name of the address pool.
        :param bool avoid_buggy_ips: If true, avoid using IPs ending in .0 or .255.
               This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        :param bool manual_assign: If true, prevent IP addresses from being automatically assigned.
        """
        BareMetalClusterLoadBalancerMetalLbConfigAddressPool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            addresses=addresses,
            pool=pool,
            avoid_buggy_ips=avoid_buggy_ips,
            manual_assign=manual_assign,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             addresses: Sequence[str],
             pool: str,
             avoid_buggy_ips: Optional[bool] = None,
             manual_assign: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("addresses", addresses)
        _setter("pool", pool)
        if avoid_buggy_ips is not None:
            _setter("avoid_buggy_ips", avoid_buggy_ips)
        if manual_assign is not None:
            _setter("manual_assign", manual_assign)

    @property
    @pulumi.getter
    def addresses(self) -> Sequence[str]:
        """
        The addresses that are part of this pool. Each address must be either in the CIDR form (1.2.3.0/24) or range form (1.2.3.1-1.2.3.5).
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def pool(self) -> str:
        """
        The name of the address pool.
        """
        return pulumi.get(self, "pool")

    @property
    @pulumi.getter(name="avoidBuggyIps")
    def avoid_buggy_ips(self) -> Optional[bool]:
        """
        If true, avoid using IPs ending in .0 or .255.
        This avoids buggy consumer devices mistakenly dropping IPv4 traffic for those special IP addresses.
        """
        return pulumi.get(self, "avoid_buggy_ips")

    @property
    @pulumi.getter(name="manualAssign")
    def manual_assign(self) -> Optional[bool]:
        """
        If true, prevent IP addresses from being automatically assigned.
        """
        return pulumi.get(self, "manual_assign")


@pulumi.output_type
class BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodePoolConfig":
            suggest = "node_pool_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_pool_config: Optional['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfig'] = None):
        """
        :param 'BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigArgs' node_pool_config: The generic configuration for a node pool running a load balancer.
               Structure is documented below.
        """
        BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            node_pool_config=node_pool_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             node_pool_config: Optional['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfig'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if node_pool_config is not None:
            _setter("node_pool_config", node_pool_config)

    @property
    @pulumi.getter(name="nodePoolConfig")
    def node_pool_config(self) -> Optional['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfig']:
        """
        The generic configuration for a node pool running a load balancer.
        Structure is documented below.
        """
        return pulumi.get(self, "node_pool_config")


@pulumi.output_type
class BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeConfigs":
            suggest = "node_configs"
        elif key == "operatingSystem":
            suggest = "operating_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Mapping[str, str]] = None,
                 node_configs: Optional[Sequence['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig']] = None,
                 operating_system: Optional[str] = None,
                 taints: Optional[Sequence['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint']] = None):
        """
        :param Mapping[str, str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param Sequence['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfigArgs'] node_configs: The list of machine addresses in the Bare Metal Node Pool.
               Structure is documented below.
        :param str operating_system: Specifies the nodes operating system (default: LINUX).
        :param Sequence['BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaintArgs'] taints: The initial taints assigned to nodes of this node pool.
               Structure is documented below.
        """
        BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            labels=labels,
            node_configs=node_configs,
            operating_system=operating_system,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             labels: Optional[Mapping[str, str]] = None,
             node_configs: Optional[Sequence['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig']] = None,
             operating_system: Optional[str] = None,
             taints: Optional[Sequence['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if labels is not None:
            _setter("labels", labels)
        if node_configs is not None:
            _setter("node_configs", node_configs)
        if operating_system is not None:
            _setter("operating_system", operating_system)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeConfigs")
    def node_configs(self) -> Optional[Sequence['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig']]:
        """
        The list of machine addresses in the Bare Metal Node Pool.
        Structure is documented below.
        """
        return pulumi.get(self, "node_configs")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[str]:
        """
        Specifies the nodes operating system (default: LINUX).
        """
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint']]:
        """
        The initial taints assigned to nodes of this node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeIp":
            suggest = "node_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Mapping[str, str]] = None,
                 node_ip: Optional[str] = None):
        """
        :param Mapping[str, str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param str node_ip: The default IPv4 address for SSH access and Kubernetes node.
               Example: 192.168.0.1
        """
        BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigNodeConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            labels=labels,
            node_ip=node_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             labels: Optional[Mapping[str, str]] = None,
             node_ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if labels is not None:
            _setter("labels", labels)
        if node_ip is not None:
            _setter("node_ip", node_ip)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> Optional[str]:
        """
        The default IPv4 address for SSH access and Kubernetes node.
        Example: 192.168.0.1
        """
        return pulumi.get(self, "node_ip")


@pulumi.output_type
class BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str effect: Specifies the nodes operating system (default: LINUX).
               Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        :param str key: Key associated with the effect.
        :param str value: Value associated with the effect.
        """
        BareMetalClusterLoadBalancerMetalLbConfigLoadBalancerNodePoolConfigNodePoolConfigTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        Specifies the nodes operating system (default: LINUX).
        Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BareMetalClusterLoadBalancerPortConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneLoadBalancerPort":
            suggest = "control_plane_load_balancer_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerPortConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerPortConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerPortConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_load_balancer_port: int):
        """
        :param int control_plane_load_balancer_port: The port that control plane hosted load balancers will listen on.
        """
        BareMetalClusterLoadBalancerPortConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            control_plane_load_balancer_port=control_plane_load_balancer_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             control_plane_load_balancer_port: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("control_plane_load_balancer_port", control_plane_load_balancer_port)

    @property
    @pulumi.getter(name="controlPlaneLoadBalancerPort")
    def control_plane_load_balancer_port(self) -> int:
        """
        The port that control plane hosted load balancers will listen on.
        """
        return pulumi.get(self, "control_plane_load_balancer_port")


@pulumi.output_type
class BareMetalClusterLoadBalancerVipConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneVip":
            suggest = "control_plane_vip"
        elif key == "ingressVip":
            suggest = "ingress_vip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterLoadBalancerVipConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterLoadBalancerVipConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterLoadBalancerVipConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_vip: str,
                 ingress_vip: str):
        """
        :param str control_plane_vip: The VIP which you previously set aside for the Kubernetes API of this Bare Metal User Cluster.
        :param str ingress_vip: The VIP which you previously set aside for ingress traffic into this Bare Metal User Cluster.
        """
        BareMetalClusterLoadBalancerVipConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            control_plane_vip=control_plane_vip,
            ingress_vip=ingress_vip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             control_plane_vip: str,
             ingress_vip: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("control_plane_vip", control_plane_vip)
        _setter("ingress_vip", ingress_vip)

    @property
    @pulumi.getter(name="controlPlaneVip")
    def control_plane_vip(self) -> str:
        """
        The VIP which you previously set aside for the Kubernetes API of this Bare Metal User Cluster.
        """
        return pulumi.get(self, "control_plane_vip")

    @property
    @pulumi.getter(name="ingressVip")
    def ingress_vip(self) -> str:
        """
        The VIP which you previously set aside for ingress traffic into this Bare Metal User Cluster.
        """
        return pulumi.get(self, "ingress_vip")


@pulumi.output_type
class BareMetalClusterMaintenanceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maintenanceAddressCidrBlocks":
            suggest = "maintenance_address_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterMaintenanceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterMaintenanceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterMaintenanceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 maintenance_address_cidr_blocks: Sequence[str]):
        """
        :param Sequence[str] maintenance_address_cidr_blocks: All IPv4 address from these ranges will be placed into maintenance mode.
               Nodes in maintenance mode will be cordoned and drained. When both of these
               are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set
               on the node resource.
        """
        BareMetalClusterMaintenanceConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            maintenance_address_cidr_blocks=maintenance_address_cidr_blocks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             maintenance_address_cidr_blocks: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("maintenance_address_cidr_blocks", maintenance_address_cidr_blocks)

    @property
    @pulumi.getter(name="maintenanceAddressCidrBlocks")
    def maintenance_address_cidr_blocks(self) -> Sequence[str]:
        """
        All IPv4 address from these ranges will be placed into maintenance mode.
        Nodes in maintenance mode will be cordoned and drained. When both of these
        are true, the "baremetal.cluster.gke.io/maintenance" annotation will be set
        on the node resource.
        """
        return pulumi.get(self, "maintenance_address_cidr_blocks")


@pulumi.output_type
class BareMetalClusterNetworkConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedNetworking":
            suggest = "advanced_networking"
        elif key == "islandModeCidr":
            suggest = "island_mode_cidr"
        elif key == "multipleNetworkInterfacesConfig":
            suggest = "multiple_network_interfaces_config"
        elif key == "srIovConfig":
            suggest = "sr_iov_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterNetworkConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterNetworkConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterNetworkConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_networking: Optional[bool] = None,
                 island_mode_cidr: Optional['outputs.BareMetalClusterNetworkConfigIslandModeCidr'] = None,
                 multiple_network_interfaces_config: Optional['outputs.BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfig'] = None,
                 sr_iov_config: Optional['outputs.BareMetalClusterNetworkConfigSrIovConfig'] = None):
        """
        :param bool advanced_networking: Enables the use of advanced Anthos networking features, such as Bundled
               Load Balancing with BGP or the egress NAT gateway.
               Setting configuration for advanced networking features will automatically
               set this flag.
        :param 'BareMetalClusterNetworkConfigIslandModeCidrArgs' island_mode_cidr: A nested object resource
               Structure is documented below.
        :param 'BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfigArgs' multiple_network_interfaces_config: Configuration for multiple network interfaces.
               Structure is documented below.
        :param 'BareMetalClusterNetworkConfigSrIovConfigArgs' sr_iov_config: Configuration for SR-IOV.
               Structure is documented below.
        """
        BareMetalClusterNetworkConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            advanced_networking=advanced_networking,
            island_mode_cidr=island_mode_cidr,
            multiple_network_interfaces_config=multiple_network_interfaces_config,
            sr_iov_config=sr_iov_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             advanced_networking: Optional[bool] = None,
             island_mode_cidr: Optional['outputs.BareMetalClusterNetworkConfigIslandModeCidr'] = None,
             multiple_network_interfaces_config: Optional['outputs.BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfig'] = None,
             sr_iov_config: Optional['outputs.BareMetalClusterNetworkConfigSrIovConfig'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if advanced_networking is not None:
            _setter("advanced_networking", advanced_networking)
        if island_mode_cidr is not None:
            _setter("island_mode_cidr", island_mode_cidr)
        if multiple_network_interfaces_config is not None:
            _setter("multiple_network_interfaces_config", multiple_network_interfaces_config)
        if sr_iov_config is not None:
            _setter("sr_iov_config", sr_iov_config)

    @property
    @pulumi.getter(name="advancedNetworking")
    def advanced_networking(self) -> Optional[bool]:
        """
        Enables the use of advanced Anthos networking features, such as Bundled
        Load Balancing with BGP or the egress NAT gateway.
        Setting configuration for advanced networking features will automatically
        set this flag.
        """
        return pulumi.get(self, "advanced_networking")

    @property
    @pulumi.getter(name="islandModeCidr")
    def island_mode_cidr(self) -> Optional['outputs.BareMetalClusterNetworkConfigIslandModeCidr']:
        """
        A nested object resource
        Structure is documented below.
        """
        return pulumi.get(self, "island_mode_cidr")

    @property
    @pulumi.getter(name="multipleNetworkInterfacesConfig")
    def multiple_network_interfaces_config(self) -> Optional['outputs.BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfig']:
        """
        Configuration for multiple network interfaces.
        Structure is documented below.
        """
        return pulumi.get(self, "multiple_network_interfaces_config")

    @property
    @pulumi.getter(name="srIovConfig")
    def sr_iov_config(self) -> Optional['outputs.BareMetalClusterNetworkConfigSrIovConfig']:
        """
        Configuration for SR-IOV.
        Structure is documented below.
        """
        return pulumi.get(self, "sr_iov_config")


@pulumi.output_type
class BareMetalClusterNetworkConfigIslandModeCidr(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podAddressCidrBlocks":
            suggest = "pod_address_cidr_blocks"
        elif key == "serviceAddressCidrBlocks":
            suggest = "service_address_cidr_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterNetworkConfigIslandModeCidr. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterNetworkConfigIslandModeCidr.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterNetworkConfigIslandModeCidr.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_address_cidr_blocks: Sequence[str],
                 service_address_cidr_blocks: Sequence[str]):
        """
        :param Sequence[str] pod_address_cidr_blocks: All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        :param Sequence[str] service_address_cidr_blocks: All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        BareMetalClusterNetworkConfigIslandModeCidr._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pod_address_cidr_blocks=pod_address_cidr_blocks,
            service_address_cidr_blocks=service_address_cidr_blocks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pod_address_cidr_blocks: Sequence[str],
             service_address_cidr_blocks: Sequence[str],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("pod_address_cidr_blocks", pod_address_cidr_blocks)
        _setter("service_address_cidr_blocks", service_address_cidr_blocks)

    @property
    @pulumi.getter(name="podAddressCidrBlocks")
    def pod_address_cidr_blocks(self) -> Sequence[str]:
        """
        All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        return pulumi.get(self, "pod_address_cidr_blocks")

    @property
    @pulumi.getter(name="serviceAddressCidrBlocks")
    def service_address_cidr_blocks(self) -> Sequence[str]:
        """
        All services in the cluster are assigned an RFC1918 IPv4 address from these ranges. This field cannot be changed after creation.
        """
        return pulumi.get(self, "service_address_cidr_blocks")


@pulumi.output_type
class BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Whether to enable multiple network interfaces for your pods.
               When set network_config.advanced_networking is automatically
               set to true.
        """
        BareMetalClusterNetworkConfigMultipleNetworkInterfacesConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether to enable multiple network interfaces for your pods.
        When set network_config.advanced_networking is automatically
        set to true.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class BareMetalClusterNetworkConfigSrIovConfig(dict):
    def __init__(__self__, *,
                 enabled: Optional[bool] = None):
        """
        :param bool enabled: Whether to install the SR-IOV operator.
        """
        BareMetalClusterNetworkConfigSrIovConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if enabled is not None:
            _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[bool]:
        """
        Whether to install the SR-IOV operator.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class BareMetalClusterNodeAccessConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "loginUser":
            suggest = "login_user"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterNodeAccessConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterNodeAccessConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterNodeAccessConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 login_user: Optional[str] = None):
        """
        :param str login_user: LoginUser is the user name used to access node machines.
               It defaults to "root" if not set.
        """
        BareMetalClusterNodeAccessConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            login_user=login_user,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             login_user: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if login_user is not None:
            _setter("login_user", login_user)

    @property
    @pulumi.getter(name="loginUser")
    def login_user(self) -> Optional[str]:
        """
        LoginUser is the user name used to access node machines.
        It defaults to "root" if not set.
        """
        return pulumi.get(self, "login_user")


@pulumi.output_type
class BareMetalClusterNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "containerRuntime":
            suggest = "container_runtime"
        elif key == "maxPodsPerNode":
            suggest = "max_pods_per_node"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 container_runtime: Optional[str] = None,
                 max_pods_per_node: Optional[int] = None):
        """
        :param str container_runtime: The available runtimes that can be used to run containers in a Bare Metal User Cluster.
               Possible values are: `CONTAINER_RUNTIME_UNSPECIFIED`, `DOCKER`, `CONTAINERD`.
        :param int max_pods_per_node: The maximum number of pods a node can run. The size of the CIDR range
               assigned to the node will be derived from this parameter.
        """
        BareMetalClusterNodeConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            container_runtime=container_runtime,
            max_pods_per_node=max_pods_per_node,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             container_runtime: Optional[str] = None,
             max_pods_per_node: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if container_runtime is not None:
            _setter("container_runtime", container_runtime)
        if max_pods_per_node is not None:
            _setter("max_pods_per_node", max_pods_per_node)

    @property
    @pulumi.getter(name="containerRuntime")
    def container_runtime(self) -> Optional[str]:
        """
        The available runtimes that can be used to run containers in a Bare Metal User Cluster.
        Possible values are: `CONTAINER_RUNTIME_UNSPECIFIED`, `DOCKER`, `CONTAINERD`.
        """
        return pulumi.get(self, "container_runtime")

    @property
    @pulumi.getter(name="maxPodsPerNode")
    def max_pods_per_node(self) -> Optional[int]:
        """
        The maximum number of pods a node can run. The size of the CIDR range
        assigned to the node will be derived from this parameter.
        """
        return pulumi.get(self, "max_pods_per_node")


@pulumi.output_type
class BareMetalClusterOsEnvironmentConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "packageRepoExcluded":
            suggest = "package_repo_excluded"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterOsEnvironmentConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterOsEnvironmentConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterOsEnvironmentConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 package_repo_excluded: bool):
        """
        :param bool package_repo_excluded: Whether the package repo should not be included when initializing
               bare metal machines.
        """
        BareMetalClusterOsEnvironmentConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            package_repo_excluded=package_repo_excluded,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             package_repo_excluded: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("package_repo_excluded", package_repo_excluded)

    @property
    @pulumi.getter(name="packageRepoExcluded")
    def package_repo_excluded(self) -> bool:
        """
        Whether the package repo should not be included when initializing
        bare metal machines.
        """
        return pulumi.get(self, "package_repo_excluded")


@pulumi.output_type
class BareMetalClusterProxy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "noProxies":
            suggest = "no_proxies"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterProxy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterProxy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterProxy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 uri: str,
                 no_proxies: Optional[Sequence[str]] = None):
        """
        :param str uri: Specifies the address of your proxy server.
               Examples: http://domain
               WARNING: Do not provide credentials in the format
               http://(username:password@)domain these will be rejected by the server.
        :param Sequence[str] no_proxies: A list of IPs, hostnames, and domains that should skip the proxy.
               Examples: ["127.0.0.1", "example.com", ".corp", "localhost"].
        """
        BareMetalClusterProxy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            uri=uri,
            no_proxies=no_proxies,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             uri: str,
             no_proxies: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("uri", uri)
        if no_proxies is not None:
            _setter("no_proxies", no_proxies)

    @property
    @pulumi.getter
    def uri(self) -> str:
        """
        Specifies the address of your proxy server.
        Examples: http://domain
        WARNING: Do not provide credentials in the format
        http://(username:password@)domain these will be rejected by the server.
        """
        return pulumi.get(self, "uri")

    @property
    @pulumi.getter(name="noProxies")
    def no_proxies(self) -> Optional[Sequence[str]]:
        """
        A list of IPs, hostnames, and domains that should skip the proxy.
        Examples: ["127.0.0.1", "example.com", ".corp", "localhost"].
        """
        return pulumi.get(self, "no_proxies")


@pulumi.output_type
class BareMetalClusterSecurityConfig(dict):
    def __init__(__self__, *,
                 authorization: Optional['outputs.BareMetalClusterSecurityConfigAuthorization'] = None):
        """
        :param 'BareMetalClusterSecurityConfigAuthorizationArgs' authorization: Configures user access to the Bare Metal User cluster.
               Structure is documented below.
        """
        BareMetalClusterSecurityConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            authorization=authorization,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             authorization: Optional['outputs.BareMetalClusterSecurityConfigAuthorization'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if authorization is not None:
            _setter("authorization", authorization)

    @property
    @pulumi.getter
    def authorization(self) -> Optional['outputs.BareMetalClusterSecurityConfigAuthorization']:
        """
        Configures user access to the Bare Metal User cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "authorization")


@pulumi.output_type
class BareMetalClusterSecurityConfigAuthorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsers":
            suggest = "admin_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterSecurityConfigAuthorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterSecurityConfigAuthorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterSecurityConfigAuthorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_users: Sequence['outputs.BareMetalClusterSecurityConfigAuthorizationAdminUser']):
        """
        :param Sequence['BareMetalClusterSecurityConfigAuthorizationAdminUserArgs'] admin_users: Users that will be granted the cluster-admin role on the cluster, providing full access to the cluster.
               Structure is documented below.
        """
        BareMetalClusterSecurityConfigAuthorization._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_users=admin_users,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_users: Sequence['outputs.BareMetalClusterSecurityConfigAuthorizationAdminUser'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("admin_users", admin_users)

    @property
    @pulumi.getter(name="adminUsers")
    def admin_users(self) -> Sequence['outputs.BareMetalClusterSecurityConfigAuthorizationAdminUser']:
        """
        Users that will be granted the cluster-admin role on the cluster, providing full access to the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "admin_users")


@pulumi.output_type
class BareMetalClusterSecurityConfigAuthorizationAdminUser(dict):
    def __init__(__self__, *,
                 username: str):
        """
        :param str username: The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        BareMetalClusterSecurityConfigAuthorizationAdminUser._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("username", username)

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class BareMetalClusterStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.BareMetalClusterStatusCondition']] = None,
                 error_message: Optional[str] = None):
        """
        :param Sequence['BareMetalClusterStatusConditionArgs'] conditions: (Output)
               ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
               Structure is documented below.
        :param str error_message: (Output)
               Human-friendly representation of the error message from the user cluster
               controller. The error message can be temporary as the user cluster
               controller creates a cluster or node pool. If the error message persists
               for a longer period of time, it can be used to surface error message to
               indicate real problems requiring user intervention.
        """
        BareMetalClusterStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditions=conditions,
            error_message=error_message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditions: Optional[Sequence['outputs.BareMetalClusterStatusCondition']] = None,
             error_message: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditions is not None:
            _setter("conditions", conditions)
        if error_message is not None:
            _setter("error_message", error_message)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.BareMetalClusterStatusCondition']]:
        """
        (Output)
        ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        """
        (Output)
        Human-friendly representation of the error message from the user cluster
        controller. The error message can be temporary as the user cluster
        controller creates a cluster or node pool. If the error message persists
        for a longer period of time, it can be used to surface error message to
        indicate real problems requiring user intervention.
        """
        return pulumi.get(self, "error_message")


@pulumi.output_type
class BareMetalClusterStatusCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterStatusCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterStatusCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterStatusCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 state: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str last_transition_time: (Output)
               Last time the condition transit from one status to another.
        :param str message: Human-readable message indicating details about last transition.
        :param str reason: (Output)
               A human-readable message of the check failure.
        :param str state: (Output)
               The lifecycle state of the condition.
        :param str type: Type of the condition.
               (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        BareMetalClusterStatusCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            last_transition_time=last_transition_time,
            message=message,
            reason=reason,
            state=state,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             last_transition_time: Optional[str] = None,
             message: Optional[str] = None,
             reason: Optional[str] = None,
             state: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if last_transition_time is not None:
            _setter("last_transition_time", last_transition_time)
        if message is not None:
            _setter("message", message)
        if reason is not None:
            _setter("reason", reason)
        if state is not None:
            _setter("state", state)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        (Output)
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Human-readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        (Output)
        A human-readable message of the check failure.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        (Output)
        The lifecycle state of the condition.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the condition.
        (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class BareMetalClusterStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lvpNodeMountsConfig":
            suggest = "lvp_node_mounts_config"
        elif key == "lvpShareConfig":
            suggest = "lvp_share_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lvp_node_mounts_config: 'outputs.BareMetalClusterStorageLvpNodeMountsConfig',
                 lvp_share_config: 'outputs.BareMetalClusterStorageLvpShareConfig'):
        """
        :param 'BareMetalClusterStorageLvpNodeMountsConfigArgs' lvp_node_mounts_config: Specifies the config for local PersistentVolumes backed
               by mounted node disks. These disks need to be formatted and mounted by the
               user, which can be done before or after cluster creation.
               Structure is documented below.
        :param 'BareMetalClusterStorageLvpShareConfigArgs' lvp_share_config: Specifies the config for local PersistentVolumes backed by
               subdirectories in a shared filesystem. These subdirectores are
               automatically created during cluster creation.
               Structure is documented below.
        """
        BareMetalClusterStorage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lvp_node_mounts_config=lvp_node_mounts_config,
            lvp_share_config=lvp_share_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lvp_node_mounts_config: 'outputs.BareMetalClusterStorageLvpNodeMountsConfig',
             lvp_share_config: 'outputs.BareMetalClusterStorageLvpShareConfig',
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("lvp_node_mounts_config", lvp_node_mounts_config)
        _setter("lvp_share_config", lvp_share_config)

    @property
    @pulumi.getter(name="lvpNodeMountsConfig")
    def lvp_node_mounts_config(self) -> 'outputs.BareMetalClusterStorageLvpNodeMountsConfig':
        """
        Specifies the config for local PersistentVolumes backed
        by mounted node disks. These disks need to be formatted and mounted by the
        user, which can be done before or after cluster creation.
        Structure is documented below.
        """
        return pulumi.get(self, "lvp_node_mounts_config")

    @property
    @pulumi.getter(name="lvpShareConfig")
    def lvp_share_config(self) -> 'outputs.BareMetalClusterStorageLvpShareConfig':
        """
        Specifies the config for local PersistentVolumes backed by
        subdirectories in a shared filesystem. These subdirectores are
        automatically created during cluster creation.
        Structure is documented below.
        """
        return pulumi.get(self, "lvp_share_config")


@pulumi.output_type
class BareMetalClusterStorageLvpNodeMountsConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterStorageLvpNodeMountsConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterStorageLvpNodeMountsConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterStorageLvpNodeMountsConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 storage_class: str):
        """
        :param str path: The host machine path.
        :param str storage_class: The StorageClass name that PVs will be created with.
               
               - - -
        """
        BareMetalClusterStorageLvpNodeMountsConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            storage_class=storage_class,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: str,
             storage_class: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("path", path)
        _setter("storage_class", storage_class)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The host machine path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> str:
        """
        The StorageClass name that PVs will be created with.

        - - -
        """
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class BareMetalClusterStorageLvpShareConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lvpConfig":
            suggest = "lvp_config"
        elif key == "sharedPathPvCount":
            suggest = "shared_path_pv_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterStorageLvpShareConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterStorageLvpShareConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterStorageLvpShareConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 lvp_config: 'outputs.BareMetalClusterStorageLvpShareConfigLvpConfig',
                 shared_path_pv_count: Optional[int] = None):
        """
        :param 'BareMetalClusterStorageLvpShareConfigLvpConfigArgs' lvp_config: Defines the machine path and storage class for the LVP Share.
               Structure is documented below.
        :param int shared_path_pv_count: The number of subdirectories to create under path.
        """
        BareMetalClusterStorageLvpShareConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            lvp_config=lvp_config,
            shared_path_pv_count=shared_path_pv_count,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             lvp_config: 'outputs.BareMetalClusterStorageLvpShareConfigLvpConfig',
             shared_path_pv_count: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("lvp_config", lvp_config)
        if shared_path_pv_count is not None:
            _setter("shared_path_pv_count", shared_path_pv_count)

    @property
    @pulumi.getter(name="lvpConfig")
    def lvp_config(self) -> 'outputs.BareMetalClusterStorageLvpShareConfigLvpConfig':
        """
        Defines the machine path and storage class for the LVP Share.
        Structure is documented below.
        """
        return pulumi.get(self, "lvp_config")

    @property
    @pulumi.getter(name="sharedPathPvCount")
    def shared_path_pv_count(self) -> Optional[int]:
        """
        The number of subdirectories to create under path.
        """
        return pulumi.get(self, "shared_path_pv_count")


@pulumi.output_type
class BareMetalClusterStorageLvpShareConfigLvpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storageClass":
            suggest = "storage_class"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalClusterStorageLvpShareConfigLvpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalClusterStorageLvpShareConfigLvpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalClusterStorageLvpShareConfigLvpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 path: str,
                 storage_class: str):
        """
        :param str path: The host machine path.
        :param str storage_class: The StorageClass name that PVs will be created with.
        """
        BareMetalClusterStorageLvpShareConfigLvpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            path=path,
            storage_class=storage_class,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             path: str,
             storage_class: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("path", path)
        _setter("storage_class", storage_class)

    @property
    @pulumi.getter
    def path(self) -> str:
        """
        The host machine path.
        """
        return pulumi.get(self, "path")

    @property
    @pulumi.getter(name="storageClass")
    def storage_class(self) -> str:
        """
        The StorageClass name that PVs will be created with.
        """
        return pulumi.get(self, "storage_class")


@pulumi.output_type
class BareMetalClusterUpgradePolicy(dict):
    def __init__(__self__, *,
                 policy: Optional[str] = None):
        """
        :param str policy: Specifies which upgrade policy to use.
               Possible values are: `SERIAL`, `CONCURRENT`.
        """
        BareMetalClusterUpgradePolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            policy=policy,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             policy: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if policy is not None:
            _setter("policy", policy)

    @property
    @pulumi.getter
    def policy(self) -> Optional[str]:
        """
        Specifies which upgrade policy to use.
        Possible values are: `SERIAL`, `CONCURRENT`.
        """
        return pulumi.get(self, "policy")


@pulumi.output_type
class BareMetalClusterValidationCheck(dict):
    def __init__(__self__, *,
                 options: Optional[str] = None,
                 scenario: Optional[str] = None,
                 statuses: Optional[Sequence['outputs.BareMetalClusterValidationCheckStatus']] = None):
        """
        :param str options: (Output)
               Options used for the validation check.
        :param str scenario: (Output)
               The scenario when the preflight checks were run..
        :param Sequence['BareMetalClusterValidationCheckStatusArgs'] statuses: (Output)
               Specifies the detailed validation check status
               Structure is documented below.
        """
        BareMetalClusterValidationCheck._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            options=options,
            scenario=scenario,
            statuses=statuses,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             options: Optional[str] = None,
             scenario: Optional[str] = None,
             statuses: Optional[Sequence['outputs.BareMetalClusterValidationCheckStatus']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if options is not None:
            _setter("options", options)
        if scenario is not None:
            _setter("scenario", scenario)
        if statuses is not None:
            _setter("statuses", statuses)

    @property
    @pulumi.getter
    def options(self) -> Optional[str]:
        """
        (Output)
        Options used for the validation check.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def scenario(self) -> Optional[str]:
        """
        (Output)
        The scenario when the preflight checks were run..
        """
        return pulumi.get(self, "scenario")

    @property
    @pulumi.getter
    def statuses(self) -> Optional[Sequence['outputs.BareMetalClusterValidationCheckStatus']]:
        """
        (Output)
        Specifies the detailed validation check status
        Structure is documented below.
        """
        return pulumi.get(self, "statuses")


@pulumi.output_type
class BareMetalClusterValidationCheckStatus(dict):
    def __init__(__self__, *,
                 results: Optional[Sequence['outputs.BareMetalClusterValidationCheckStatusResult']] = None):
        """
        :param Sequence['BareMetalClusterValidationCheckStatusResultArgs'] results: (Output)
               Individual checks which failed as part of the Preflight check execution.
               Structure is documented below.
        """
        BareMetalClusterValidationCheckStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            results=results,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             results: Optional[Sequence['outputs.BareMetalClusterValidationCheckStatusResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if results is not None:
            _setter("results", results)

    @property
    @pulumi.getter
    def results(self) -> Optional[Sequence['outputs.BareMetalClusterValidationCheckStatusResult']]:
        """
        (Output)
        Individual checks which failed as part of the Preflight check execution.
        Structure is documented below.
        """
        return pulumi.get(self, "results")


@pulumi.output_type
class BareMetalClusterValidationCheckStatusResult(dict):
    def __init__(__self__, *,
                 category: Optional[str] = None,
                 description: Optional[str] = None,
                 details: Optional[str] = None,
                 options: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        :param str category: (Output)
               The category of the validation.
        :param str description: A human readable description of this Bare Metal User Cluster.
        :param str details: (Output)
               Detailed failure information, which might be unformatted.
        :param str options: (Output)
               Options used for the validation check.
        :param str reason: (Output)
               A human-readable message of the check failure.
        """
        BareMetalClusterValidationCheckStatusResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            description=description,
            details=details,
            options=options,
            reason=reason,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             description: Optional[str] = None,
             details: Optional[str] = None,
             options: Optional[str] = None,
             reason: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if description is not None:
            _setter("description", description)
        if details is not None:
            _setter("details", details)
        if options is not None:
            _setter("options", options)
        if reason is not None:
            _setter("reason", reason)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        (Output)
        The category of the validation.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A human readable description of this Bare Metal User Cluster.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Optional[str]:
        """
        (Output)
        Detailed failure information, which might be unformatted.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def options(self) -> Optional[str]:
        """
        (Output)
        Options used for the validation check.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        (Output)
        A human-readable message of the check failure.
        """
        return pulumi.get(self, "reason")


@pulumi.output_type
class BareMetalNodePoolNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeConfigs":
            suggest = "node_configs"
        elif key == "operatingSystem":
            suggest = "operating_system"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalNodePoolNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalNodePoolNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalNodePoolNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_configs: Sequence['outputs.BareMetalNodePoolNodePoolConfigNodeConfig'],
                 labels: Optional[Mapping[str, str]] = None,
                 operating_system: Optional[str] = None,
                 taints: Optional[Sequence['outputs.BareMetalNodePoolNodePoolConfigTaint']] = None):
        """
        :param Sequence['BareMetalNodePoolNodePoolConfigNodeConfigArgs'] node_configs: The list of machine addresses in the Bare Metal Node Pool.
               Structure is documented below.
        :param Mapping[str, str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param str operating_system: Specifies the nodes operating system (default: LINUX).
        :param Sequence['BareMetalNodePoolNodePoolConfigTaintArgs'] taints: The initial taints assigned to nodes of this node pool.
               Structure is documented below.
        """
        BareMetalNodePoolNodePoolConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            node_configs=node_configs,
            labels=labels,
            operating_system=operating_system,
            taints=taints,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             node_configs: Sequence['outputs.BareMetalNodePoolNodePoolConfigNodeConfig'],
             labels: Optional[Mapping[str, str]] = None,
             operating_system: Optional[str] = None,
             taints: Optional[Sequence['outputs.BareMetalNodePoolNodePoolConfigTaint']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("node_configs", node_configs)
        if labels is not None:
            _setter("labels", labels)
        if operating_system is not None:
            _setter("operating_system", operating_system)
        if taints is not None:
            _setter("taints", taints)

    @property
    @pulumi.getter(name="nodeConfigs")
    def node_configs(self) -> Sequence['outputs.BareMetalNodePoolNodePoolConfigNodeConfig']:
        """
        The list of machine addresses in the Bare Metal Node Pool.
        Structure is documented below.
        """
        return pulumi.get(self, "node_configs")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="operatingSystem")
    def operating_system(self) -> Optional[str]:
        """
        Specifies the nodes operating system (default: LINUX).
        """
        return pulumi.get(self, "operating_system")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.BareMetalNodePoolNodePoolConfigTaint']]:
        """
        The initial taints assigned to nodes of this node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "taints")


@pulumi.output_type
class BareMetalNodePoolNodePoolConfigNodeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeIp":
            suggest = "node_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalNodePoolNodePoolConfigNodeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalNodePoolNodePoolConfigNodeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalNodePoolNodePoolConfigNodeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 labels: Optional[Mapping[str, str]] = None,
                 node_ip: Optional[str] = None):
        """
        :param Mapping[str, str] labels: The map of Kubernetes labels (key/value pairs) to be applied to
               each node. These will added in addition to any default label(s)
               that Kubernetes may apply to the node. In case of conflict in
               label keys, the applied set may differ depending on the Kubernetes
               version -- it's best to assume the behavior is undefined and
               conflicts should be avoided. For more information, including usage
               and the valid values, see:
               http://kubernetes.io/v1.1/docs/user-guide/labels.html
               An object containing a list of "key": value pairs.
               Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        :param str node_ip: The default IPv4 address for SSH access and Kubernetes node.
               Example: 192.168.0.1
        """
        BareMetalNodePoolNodePoolConfigNodeConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            labels=labels,
            node_ip=node_ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             labels: Optional[Mapping[str, str]] = None,
             node_ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if labels is not None:
            _setter("labels", labels)
        if node_ip is not None:
            _setter("node_ip", node_ip)

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to
        each node. These will added in addition to any default label(s)
        that Kubernetes may apply to the node. In case of conflict in
        label keys, the applied set may differ depending on the Kubernetes
        version -- it's best to assume the behavior is undefined and
        conflicts should be avoided. For more information, including usage
        and the valid values, see:
        http://kubernetes.io/v1.1/docs/user-guide/labels.html
        An object containing a list of "key": value pairs.
        Example: { "name": "wrench", "mass": "1.3kg", "count": "3" }.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="nodeIp")
    def node_ip(self) -> Optional[str]:
        """
        The default IPv4 address for SSH access and Kubernetes node.
        Example: 192.168.0.1
        """
        return pulumi.get(self, "node_ip")


@pulumi.output_type
class BareMetalNodePoolNodePoolConfigTaint(dict):
    def __init__(__self__, *,
                 effect: Optional[str] = None,
                 key: Optional[str] = None,
                 value: Optional[str] = None):
        """
        :param str effect: Specifies the nodes operating system (default: LINUX).
               Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
               
               - - -
        :param str key: Key associated with the effect.
        :param str value: Value associated with the effect.
        """
        BareMetalNodePoolNodePoolConfigTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            effect=effect,
            key=key,
            value=value,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             effect: Optional[str] = None,
             key: Optional[str] = None,
             value: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if effect is not None:
            _setter("effect", effect)
        if key is not None:
            _setter("key", key)
        if value is not None:
            _setter("value", value)

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        Specifies the nodes operating system (default: LINUX).
        Possible values are: `EFFECT_UNSPECIFIED`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.

        - - -
        """
        return pulumi.get(self, "effect")

    @property
    @pulumi.getter
    def key(self) -> Optional[str]:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> Optional[str]:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class BareMetalNodePoolStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalNodePoolStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalNodePoolStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalNodePoolStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.BareMetalNodePoolStatusCondition']] = None,
                 error_message: Optional[str] = None):
        """
        :param Sequence['BareMetalNodePoolStatusConditionArgs'] conditions: (Output)
               ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
               Structure is documented below.
        :param str error_message: (Output)
               Human-friendly representation of the error message from the user cluster
               controller. The error message can be temporary as the user cluster
               controller creates a cluster or node pool. If the error message persists
               for a longer period of time, it can be used to surface error message to
               indicate real problems requiring user intervention.
        """
        BareMetalNodePoolStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditions=conditions,
            error_message=error_message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditions: Optional[Sequence['outputs.BareMetalNodePoolStatusCondition']] = None,
             error_message: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditions is not None:
            _setter("conditions", conditions)
        if error_message is not None:
            _setter("error_message", error_message)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.BareMetalNodePoolStatusCondition']]:
        """
        (Output)
        ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        """
        (Output)
        Human-friendly representation of the error message from the user cluster
        controller. The error message can be temporary as the user cluster
        controller creates a cluster or node pool. If the error message persists
        for a longer period of time, it can be used to surface error message to
        indicate real problems requiring user intervention.
        """
        return pulumi.get(self, "error_message")


@pulumi.output_type
class BareMetalNodePoolStatusCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in BareMetalNodePoolStatusCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        BareMetalNodePoolStatusCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        BareMetalNodePoolStatusCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 state: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str last_transition_time: (Output)
               Last time the condition transit from one status to another.
        :param str message: Human-readable message indicating details about last transition.
        :param str reason: Machine-readable message indicating details about last transition.
        :param str state: (Output)
               The lifecycle state of the condition.
        :param str type: Type of the condition.
               (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        BareMetalNodePoolStatusCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            last_transition_time=last_transition_time,
            message=message,
            reason=reason,
            state=state,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             last_transition_time: Optional[str] = None,
             message: Optional[str] = None,
             reason: Optional[str] = None,
             state: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if last_transition_time is not None:
            _setter("last_transition_time", last_transition_time)
        if message is not None:
            _setter("message", message)
        if reason is not None:
            _setter("reason", reason)
        if state is not None:
            _setter("state", state)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        (Output)
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        Human-readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        Machine-readable message indicating details about last transition.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        (Output)
        The lifecycle state of the condition.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        Type of the condition.
        (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VMwareClusterAntiAffinityGroups(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "aagConfigDisabled":
            suggest = "aag_config_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterAntiAffinityGroups. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterAntiAffinityGroups.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterAntiAffinityGroups.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 aag_config_disabled: bool):
        """
        :param bool aag_config_disabled: Spread nodes across at least three physical hosts (requires at least three
               hosts).
               Enabled by default.
        """
        VMwareClusterAntiAffinityGroups._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            aag_config_disabled=aag_config_disabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             aag_config_disabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("aag_config_disabled", aag_config_disabled)

    @property
    @pulumi.getter(name="aagConfigDisabled")
    def aag_config_disabled(self) -> bool:
        """
        Spread nodes across at least three physical hosts (requires at least three
        hosts).
        Enabled by default.
        """
        return pulumi.get(self, "aag_config_disabled")


@pulumi.output_type
class VMwareClusterAuthorization(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "adminUsers":
            suggest = "admin_users"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterAuthorization. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterAuthorization.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterAuthorization.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 admin_users: Optional[Sequence['outputs.VMwareClusterAuthorizationAdminUser']] = None):
        """
        :param Sequence['VMwareClusterAuthorizationAdminUserArgs'] admin_users: Users that will be granted the cluster-admin role on the cluster, providing
               full access to the cluster.
               Structure is documented below.
        """
        VMwareClusterAuthorization._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            admin_users=admin_users,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             admin_users: Optional[Sequence['outputs.VMwareClusterAuthorizationAdminUser']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if admin_users is not None:
            _setter("admin_users", admin_users)

    @property
    @pulumi.getter(name="adminUsers")
    def admin_users(self) -> Optional[Sequence['outputs.VMwareClusterAuthorizationAdminUser']]:
        """
        Users that will be granted the cluster-admin role on the cluster, providing
        full access to the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "admin_users")


@pulumi.output_type
class VMwareClusterAuthorizationAdminUser(dict):
    def __init__(__self__, *,
                 username: str):
        """
        :param str username: The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        VMwareClusterAuthorizationAdminUser._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            username=username,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             username: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("username", username)

    @property
    @pulumi.getter
    def username(self) -> str:
        """
        The name of the user, e.g. `my-gcp-id@gmail.com`.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class VMwareClusterAutoRepairConfig(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Whether auto repair is enabled.
        """
        VMwareClusterAutoRepairConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether auto repair is enabled.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class VMwareClusterControlPlaneNode(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoResizeConfig":
            suggest = "auto_resize_config"
        elif key == "vsphereConfigs":
            suggest = "vsphere_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterControlPlaneNode. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterControlPlaneNode.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterControlPlaneNode.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 auto_resize_config: Optional['outputs.VMwareClusterControlPlaneNodeAutoResizeConfig'] = None,
                 cpus: Optional[int] = None,
                 memory: Optional[int] = None,
                 replicas: Optional[int] = None,
                 vsphere_configs: Optional[Sequence['outputs.VMwareClusterControlPlaneNodeVsphereConfig']] = None):
        """
        :param 'VMwareClusterControlPlaneNodeAutoResizeConfigArgs' auto_resize_config: AutoResizeConfig provides auto resizing configurations.
               Structure is documented below.
        :param int cpus: The number of CPUs for each admin cluster node that serve as control planes
               for this VMware User Cluster. (default: 4 CPUs)
        :param int memory: The megabytes of memory for each admin cluster node that serves as a
               control plane for this VMware User Cluster (default: 8192 MB memory).
        :param int replicas: The number of control plane nodes for this VMware User Cluster.
               (default: 1 replica).
        :param Sequence['VMwareClusterControlPlaneNodeVsphereConfigArgs'] vsphere_configs: (Output)
               Vsphere-specific config.
               Structure is documented below.
        """
        VMwareClusterControlPlaneNode._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            auto_resize_config=auto_resize_config,
            cpus=cpus,
            memory=memory,
            replicas=replicas,
            vsphere_configs=vsphere_configs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             auto_resize_config: Optional['outputs.VMwareClusterControlPlaneNodeAutoResizeConfig'] = None,
             cpus: Optional[int] = None,
             memory: Optional[int] = None,
             replicas: Optional[int] = None,
             vsphere_configs: Optional[Sequence['outputs.VMwareClusterControlPlaneNodeVsphereConfig']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if auto_resize_config is not None:
            _setter("auto_resize_config", auto_resize_config)
        if cpus is not None:
            _setter("cpus", cpus)
        if memory is not None:
            _setter("memory", memory)
        if replicas is not None:
            _setter("replicas", replicas)
        if vsphere_configs is not None:
            _setter("vsphere_configs", vsphere_configs)

    @property
    @pulumi.getter(name="autoResizeConfig")
    def auto_resize_config(self) -> Optional['outputs.VMwareClusterControlPlaneNodeAutoResizeConfig']:
        """
        AutoResizeConfig provides auto resizing configurations.
        Structure is documented below.
        """
        return pulumi.get(self, "auto_resize_config")

    @property
    @pulumi.getter
    def cpus(self) -> Optional[int]:
        """
        The number of CPUs for each admin cluster node that serve as control planes
        for this VMware User Cluster. (default: 4 CPUs)
        """
        return pulumi.get(self, "cpus")

    @property
    @pulumi.getter
    def memory(self) -> Optional[int]:
        """
        The megabytes of memory for each admin cluster node that serves as a
        control plane for this VMware User Cluster (default: 8192 MB memory).
        """
        return pulumi.get(self, "memory")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        The number of control plane nodes for this VMware User Cluster.
        (default: 1 replica).
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter(name="vsphereConfigs")
    def vsphere_configs(self) -> Optional[Sequence['outputs.VMwareClusterControlPlaneNodeVsphereConfig']]:
        """
        (Output)
        Vsphere-specific config.
        Structure is documented below.
        """
        return pulumi.get(self, "vsphere_configs")


@pulumi.output_type
class VMwareClusterControlPlaneNodeAutoResizeConfig(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: Whether to enable control plane node auto resizing.
               
               <a name="nested_vsphere_config"></a>The `vsphere_config` block contains:
        """
        VMwareClusterControlPlaneNodeAutoResizeConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        Whether to enable control plane node auto resizing.

        <a name="nested_vsphere_config"></a>The `vsphere_config` block contains:
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class VMwareClusterControlPlaneNodeVsphereConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "storagePolicyName":
            suggest = "storage_policy_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterControlPlaneNodeVsphereConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterControlPlaneNodeVsphereConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterControlPlaneNodeVsphereConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datastore: Optional[str] = None,
                 storage_policy_name: Optional[str] = None):
        """
        :param str datastore: (Output)
               The Vsphere datastore used by the Control Plane Node.
        :param str storage_policy_name: (Output)
               The Vsphere storage policy used by the control plane Node.
               
               - - -
        """
        VMwareClusterControlPlaneNodeVsphereConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            datastore=datastore,
            storage_policy_name=storage_policy_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             datastore: Optional[str] = None,
             storage_policy_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if datastore is not None:
            _setter("datastore", datastore)
        if storage_policy_name is not None:
            _setter("storage_policy_name", storage_policy_name)

    @property
    @pulumi.getter
    def datastore(self) -> Optional[str]:
        """
        (Output)
        The Vsphere datastore used by the Control Plane Node.
        """
        return pulumi.get(self, "datastore")

    @property
    @pulumi.getter(name="storagePolicyName")
    def storage_policy_name(self) -> Optional[str]:
        """
        (Output)
        The Vsphere storage policy used by the control plane Node.

        - - -
        """
        return pulumi.get(self, "storage_policy_name")


@pulumi.output_type
class VMwareClusterDataplaneV2(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "advancedNetworking":
            suggest = "advanced_networking"
        elif key == "dataplaneV2Enabled":
            suggest = "dataplane_v2_enabled"
        elif key == "windowsDataplaneV2Enabled":
            suggest = "windows_dataplane_v2_enabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterDataplaneV2. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterDataplaneV2.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterDataplaneV2.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 advanced_networking: Optional[bool] = None,
                 dataplane_v2_enabled: Optional[bool] = None,
                 windows_dataplane_v2_enabled: Optional[bool] = None):
        """
        :param bool advanced_networking: Enable advanced networking which requires dataplane_v2_enabled to be set true.
        :param bool dataplane_v2_enabled: Enables Dataplane V2.
        :param bool windows_dataplane_v2_enabled: Enable Dataplane V2 for clusters with Windows nodes.
        """
        VMwareClusterDataplaneV2._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            advanced_networking=advanced_networking,
            dataplane_v2_enabled=dataplane_v2_enabled,
            windows_dataplane_v2_enabled=windows_dataplane_v2_enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             advanced_networking: Optional[bool] = None,
             dataplane_v2_enabled: Optional[bool] = None,
             windows_dataplane_v2_enabled: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if advanced_networking is not None:
            _setter("advanced_networking", advanced_networking)
        if dataplane_v2_enabled is not None:
            _setter("dataplane_v2_enabled", dataplane_v2_enabled)
        if windows_dataplane_v2_enabled is not None:
            _setter("windows_dataplane_v2_enabled", windows_dataplane_v2_enabled)

    @property
    @pulumi.getter(name="advancedNetworking")
    def advanced_networking(self) -> Optional[bool]:
        """
        Enable advanced networking which requires dataplane_v2_enabled to be set true.
        """
        return pulumi.get(self, "advanced_networking")

    @property
    @pulumi.getter(name="dataplaneV2Enabled")
    def dataplane_v2_enabled(self) -> Optional[bool]:
        """
        Enables Dataplane V2.
        """
        return pulumi.get(self, "dataplane_v2_enabled")

    @property
    @pulumi.getter(name="windowsDataplaneV2Enabled")
    def windows_dataplane_v2_enabled(self) -> Optional[bool]:
        """
        Enable Dataplane V2 for clusters with Windows nodes.
        """
        return pulumi.get(self, "windows_dataplane_v2_enabled")


@pulumi.output_type
class VMwareClusterFleet(dict):
    def __init__(__self__, *,
                 membership: Optional[str] = None):
        """
        :param str membership: (Output)
               The name of the managed Hub Membership resource associated to this cluster.
               Membership names are formatted as
               `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        VMwareClusterFleet._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            membership=membership,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             membership: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if membership is not None:
            _setter("membership", membership)

    @property
    @pulumi.getter
    def membership(self) -> Optional[str]:
        """
        (Output)
        The name of the managed Hub Membership resource associated to this cluster.
        Membership names are formatted as
        `projects/<project-number>/locations/<location>/memberships/<cluster-id>`.
        """
        return pulumi.get(self, "membership")


@pulumi.output_type
class VMwareClusterLoadBalancer(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "f5Config":
            suggest = "f5_config"
        elif key == "manualLbConfig":
            suggest = "manual_lb_config"
        elif key == "metalLbConfig":
            suggest = "metal_lb_config"
        elif key == "vipConfig":
            suggest = "vip_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterLoadBalancer. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterLoadBalancer.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterLoadBalancer.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 f5_config: Optional['outputs.VMwareClusterLoadBalancerF5Config'] = None,
                 manual_lb_config: Optional['outputs.VMwareClusterLoadBalancerManualLbConfig'] = None,
                 metal_lb_config: Optional['outputs.VMwareClusterLoadBalancerMetalLbConfig'] = None,
                 vip_config: Optional['outputs.VMwareClusterLoadBalancerVipConfig'] = None):
        """
        :param 'VMwareClusterLoadBalancerF5ConfigArgs' f5_config: Configuration for F5 Big IP typed load balancers.
               Structure is documented below.
        :param 'VMwareClusterLoadBalancerManualLbConfigArgs' manual_lb_config: Manually configured load balancers.
               Structure is documented below.
        :param 'VMwareClusterLoadBalancerMetalLbConfigArgs' metal_lb_config: Configuration for MetalLB typed load balancers.
               Structure is documented below.
        :param 'VMwareClusterLoadBalancerVipConfigArgs' vip_config: The VIPs used by the load balancer.
               Structure is documented below.
        """
        VMwareClusterLoadBalancer._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            f5_config=f5_config,
            manual_lb_config=manual_lb_config,
            metal_lb_config=metal_lb_config,
            vip_config=vip_config,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             f5_config: Optional['outputs.VMwareClusterLoadBalancerF5Config'] = None,
             manual_lb_config: Optional['outputs.VMwareClusterLoadBalancerManualLbConfig'] = None,
             metal_lb_config: Optional['outputs.VMwareClusterLoadBalancerMetalLbConfig'] = None,
             vip_config: Optional['outputs.VMwareClusterLoadBalancerVipConfig'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if f5_config is not None:
            _setter("f5_config", f5_config)
        if manual_lb_config is not None:
            _setter("manual_lb_config", manual_lb_config)
        if metal_lb_config is not None:
            _setter("metal_lb_config", metal_lb_config)
        if vip_config is not None:
            _setter("vip_config", vip_config)

    @property
    @pulumi.getter(name="f5Config")
    def f5_config(self) -> Optional['outputs.VMwareClusterLoadBalancerF5Config']:
        """
        Configuration for F5 Big IP typed load balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "f5_config")

    @property
    @pulumi.getter(name="manualLbConfig")
    def manual_lb_config(self) -> Optional['outputs.VMwareClusterLoadBalancerManualLbConfig']:
        """
        Manually configured load balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "manual_lb_config")

    @property
    @pulumi.getter(name="metalLbConfig")
    def metal_lb_config(self) -> Optional['outputs.VMwareClusterLoadBalancerMetalLbConfig']:
        """
        Configuration for MetalLB typed load balancers.
        Structure is documented below.
        """
        return pulumi.get(self, "metal_lb_config")

    @property
    @pulumi.getter(name="vipConfig")
    def vip_config(self) -> Optional['outputs.VMwareClusterLoadBalancerVipConfig']:
        """
        The VIPs used by the load balancer.
        Structure is documented below.
        """
        return pulumi.get(self, "vip_config")


@pulumi.output_type
class VMwareClusterLoadBalancerF5Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "snatPool":
            suggest = "snat_pool"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterLoadBalancerF5Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterLoadBalancerF5Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterLoadBalancerF5Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 partition: Optional[str] = None,
                 snat_pool: Optional[str] = None):
        """
        :param str address: The load balancer's IP address.
        :param str partition: he preexisting partition to be used by the load balancer. T
               his partition is usually created for the admin cluster for example:
               'my-f5-admin-partition'.
        :param str snat_pool: The pool name. Only necessary, if using SNAT.
        """
        VMwareClusterLoadBalancerF5Config._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            partition=partition,
            snat_pool=snat_pool,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             partition: Optional[str] = None,
             snat_pool: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if address is not None:
            _setter("address", address)
        if partition is not None:
            _setter("partition", partition)
        if snat_pool is not None:
            _setter("snat_pool", snat_pool)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The load balancer's IP address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter
    def partition(self) -> Optional[str]:
        """
        he preexisting partition to be used by the load balancer. T
        his partition is usually created for the admin cluster for example:
        'my-f5-admin-partition'.
        """
        return pulumi.get(self, "partition")

    @property
    @pulumi.getter(name="snatPool")
    def snat_pool(self) -> Optional[str]:
        """
        The pool name. Only necessary, if using SNAT.
        """
        return pulumi.get(self, "snat_pool")


@pulumi.output_type
class VMwareClusterLoadBalancerManualLbConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneNodePort":
            suggest = "control_plane_node_port"
        elif key == "ingressHttpNodePort":
            suggest = "ingress_http_node_port"
        elif key == "ingressHttpsNodePort":
            suggest = "ingress_https_node_port"
        elif key == "konnectivityServerNodePort":
            suggest = "konnectivity_server_node_port"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterLoadBalancerManualLbConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterLoadBalancerManualLbConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterLoadBalancerManualLbConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_node_port: Optional[int] = None,
                 ingress_http_node_port: Optional[int] = None,
                 ingress_https_node_port: Optional[int] = None,
                 konnectivity_server_node_port: Optional[int] = None):
        """
        :param int control_plane_node_port: NodePort for control plane service. The Kubernetes API server in the admin
               cluster is implemented as a Service of type NodePort (ex. 30968).
        :param int ingress_http_node_port: NodePort for ingress service's http. The ingress service in the admin
               cluster is implemented as a Service of type NodePort (ex. 32527).
        :param int ingress_https_node_port: NodePort for ingress service's https. The ingress service in the admin
               cluster is implemented as a Service of type NodePort (ex. 30139).
        :param int konnectivity_server_node_port: NodePort for konnectivity server service running as a sidecar in each
               kube-apiserver pod (ex. 30564).
        """
        VMwareClusterLoadBalancerManualLbConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            control_plane_node_port=control_plane_node_port,
            ingress_http_node_port=ingress_http_node_port,
            ingress_https_node_port=ingress_https_node_port,
            konnectivity_server_node_port=konnectivity_server_node_port,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             control_plane_node_port: Optional[int] = None,
             ingress_http_node_port: Optional[int] = None,
             ingress_https_node_port: Optional[int] = None,
             konnectivity_server_node_port: Optional[int] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if control_plane_node_port is not None:
            _setter("control_plane_node_port", control_plane_node_port)
        if ingress_http_node_port is not None:
            _setter("ingress_http_node_port", ingress_http_node_port)
        if ingress_https_node_port is not None:
            _setter("ingress_https_node_port", ingress_https_node_port)
        if konnectivity_server_node_port is not None:
            _setter("konnectivity_server_node_port", konnectivity_server_node_port)

    @property
    @pulumi.getter(name="controlPlaneNodePort")
    def control_plane_node_port(self) -> Optional[int]:
        """
        NodePort for control plane service. The Kubernetes API server in the admin
        cluster is implemented as a Service of type NodePort (ex. 30968).
        """
        return pulumi.get(self, "control_plane_node_port")

    @property
    @pulumi.getter(name="ingressHttpNodePort")
    def ingress_http_node_port(self) -> Optional[int]:
        """
        NodePort for ingress service's http. The ingress service in the admin
        cluster is implemented as a Service of type NodePort (ex. 32527).
        """
        return pulumi.get(self, "ingress_http_node_port")

    @property
    @pulumi.getter(name="ingressHttpsNodePort")
    def ingress_https_node_port(self) -> Optional[int]:
        """
        NodePort for ingress service's https. The ingress service in the admin
        cluster is implemented as a Service of type NodePort (ex. 30139).
        """
        return pulumi.get(self, "ingress_https_node_port")

    @property
    @pulumi.getter(name="konnectivityServerNodePort")
    def konnectivity_server_node_port(self) -> Optional[int]:
        """
        NodePort for konnectivity server service running as a sidecar in each
        kube-apiserver pod (ex. 30564).
        """
        return pulumi.get(self, "konnectivity_server_node_port")


@pulumi.output_type
class VMwareClusterLoadBalancerMetalLbConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "addressPools":
            suggest = "address_pools"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterLoadBalancerMetalLbConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterLoadBalancerMetalLbConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterLoadBalancerMetalLbConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address_pools: Sequence['outputs.VMwareClusterLoadBalancerMetalLbConfigAddressPool']):
        """
        :param Sequence['VMwareClusterLoadBalancerMetalLbConfigAddressPoolArgs'] address_pools: AddressPools is a list of non-overlapping IP pools used by load balancer
               typed services. All addresses must be routable to load balancer nodes.
               IngressVIP must be included in the pools.
               Structure is documented below.
        """
        VMwareClusterLoadBalancerMetalLbConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address_pools=address_pools,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address_pools: Sequence['outputs.VMwareClusterLoadBalancerMetalLbConfigAddressPool'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("address_pools", address_pools)

    @property
    @pulumi.getter(name="addressPools")
    def address_pools(self) -> Sequence['outputs.VMwareClusterLoadBalancerMetalLbConfigAddressPool']:
        """
        AddressPools is a list of non-overlapping IP pools used by load balancer
        typed services. All addresses must be routable to load balancer nodes.
        IngressVIP must be included in the pools.
        Structure is documented below.
        """
        return pulumi.get(self, "address_pools")


@pulumi.output_type
class VMwareClusterLoadBalancerMetalLbConfigAddressPool(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avoidBuggyIps":
            suggest = "avoid_buggy_ips"
        elif key == "manualAssign":
            suggest = "manual_assign"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterLoadBalancerMetalLbConfigAddressPool. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterLoadBalancerMetalLbConfigAddressPool.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterLoadBalancerMetalLbConfigAddressPool.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 addresses: Sequence[str],
                 pool: str,
                 avoid_buggy_ips: Optional[bool] = None,
                 manual_assign: Optional[bool] = None):
        """
        :param Sequence[str] addresses: The addresses that are part of this pool. Each address
               must be either in the CIDR form (1.2.3.0/24) or range
               form (1.2.3.1-1.2.3.5).
        :param str pool: The name of the address pool.
        :param bool avoid_buggy_ips: If true, avoid using IPs ending in .0 or .255.
               This avoids buggy consumer devices mistakenly dropping IPv4 traffic for
               those special IP addresses.
        :param bool manual_assign: If true, prevent IP addresses from being automatically assigned.
               
               <a name="nested_dataplane_v2"></a>The `dataplane_v2` block supports:
        """
        VMwareClusterLoadBalancerMetalLbConfigAddressPool._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            addresses=addresses,
            pool=pool,
            avoid_buggy_ips=avoid_buggy_ips,
            manual_assign=manual_assign,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             addresses: Sequence[str],
             pool: str,
             avoid_buggy_ips: Optional[bool] = None,
             manual_assign: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("addresses", addresses)
        _setter("pool", pool)
        if avoid_buggy_ips is not None:
            _setter("avoid_buggy_ips", avoid_buggy_ips)
        if manual_assign is not None:
            _setter("manual_assign", manual_assign)

    @property
    @pulumi.getter
    def addresses(self) -> Sequence[str]:
        """
        The addresses that are part of this pool. Each address
        must be either in the CIDR form (1.2.3.0/24) or range
        form (1.2.3.1-1.2.3.5).
        """
        return pulumi.get(self, "addresses")

    @property
    @pulumi.getter
    def pool(self) -> str:
        """
        The name of the address pool.
        """
        return pulumi.get(self, "pool")

    @property
    @pulumi.getter(name="avoidBuggyIps")
    def avoid_buggy_ips(self) -> Optional[bool]:
        """
        If true, avoid using IPs ending in .0 or .255.
        This avoids buggy consumer devices mistakenly dropping IPv4 traffic for
        those special IP addresses.
        """
        return pulumi.get(self, "avoid_buggy_ips")

    @property
    @pulumi.getter(name="manualAssign")
    def manual_assign(self) -> Optional[bool]:
        """
        If true, prevent IP addresses from being automatically assigned.

        <a name="nested_dataplane_v2"></a>The `dataplane_v2` block supports:
        """
        return pulumi.get(self, "manual_assign")


@pulumi.output_type
class VMwareClusterLoadBalancerVipConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneVip":
            suggest = "control_plane_vip"
        elif key == "ingressVip":
            suggest = "ingress_vip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterLoadBalancerVipConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterLoadBalancerVipConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterLoadBalancerVipConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_vip: Optional[str] = None,
                 ingress_vip: Optional[str] = None):
        """
        :param str control_plane_vip: The VIP which you previously set aside for the Kubernetes API of this cluster.
        :param str ingress_vip: The VIP which you previously set aside for ingress traffic into this cluster.
               
               <a name="nested_f5_config"></a>The `f5_config` block supports:
        """
        VMwareClusterLoadBalancerVipConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            control_plane_vip=control_plane_vip,
            ingress_vip=ingress_vip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             control_plane_vip: Optional[str] = None,
             ingress_vip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if control_plane_vip is not None:
            _setter("control_plane_vip", control_plane_vip)
        if ingress_vip is not None:
            _setter("ingress_vip", ingress_vip)

    @property
    @pulumi.getter(name="controlPlaneVip")
    def control_plane_vip(self) -> Optional[str]:
        """
        The VIP which you previously set aside for the Kubernetes API of this cluster.
        """
        return pulumi.get(self, "control_plane_vip")

    @property
    @pulumi.getter(name="ingressVip")
    def ingress_vip(self) -> Optional[str]:
        """
        The VIP which you previously set aside for ingress traffic into this cluster.

        <a name="nested_f5_config"></a>The `f5_config` block supports:
        """
        return pulumi.get(self, "ingress_vip")


@pulumi.output_type
class VMwareClusterNetworkConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "podAddressCidrBlocks":
            suggest = "pod_address_cidr_blocks"
        elif key == "serviceAddressCidrBlocks":
            suggest = "service_address_cidr_blocks"
        elif key == "controlPlaneV2Config":
            suggest = "control_plane_v2_config"
        elif key == "dhcpIpConfig":
            suggest = "dhcp_ip_config"
        elif key == "hostConfig":
            suggest = "host_config"
        elif key == "staticIpConfig":
            suggest = "static_ip_config"
        elif key == "vcenterNetwork":
            suggest = "vcenter_network"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterNetworkConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterNetworkConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterNetworkConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 pod_address_cidr_blocks: Sequence[str],
                 service_address_cidr_blocks: Sequence[str],
                 control_plane_v2_config: Optional['outputs.VMwareClusterNetworkConfigControlPlaneV2Config'] = None,
                 dhcp_ip_config: Optional['outputs.VMwareClusterNetworkConfigDhcpIpConfig'] = None,
                 host_config: Optional['outputs.VMwareClusterNetworkConfigHostConfig'] = None,
                 static_ip_config: Optional['outputs.VMwareClusterNetworkConfigStaticIpConfig'] = None,
                 vcenter_network: Optional[str] = None):
        """
        :param Sequence[str] pod_address_cidr_blocks: All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges.
               Only a single range is supported. This field cannot be changed after creation.
        :param Sequence[str] service_address_cidr_blocks: All services in the cluster are assigned an RFC1918 IPv4 address
               from these ranges. Only a single range is supported.. This field
               cannot be changed after creation.
        :param 'VMwareClusterNetworkConfigControlPlaneV2ConfigArgs' control_plane_v2_config: Configuration for control plane V2 mode.
               Structure is documented below.
        :param 'VMwareClusterNetworkConfigDhcpIpConfigArgs' dhcp_ip_config: Configuration settings for a DHCP IP configuration.
               Structure is documented below.
        :param 'VMwareClusterNetworkConfigHostConfigArgs' host_config: Represents common network settings irrespective of the host's IP address.
               Structure is documented below.
        :param 'VMwareClusterNetworkConfigStaticIpConfigArgs' static_ip_config: Configuration settings for a static IP configuration.
               Structure is documented below.
        :param str vcenter_network: (Output)
               vcenter_network specifies vCenter network name. Inherited from the admin cluster.
        """
        VMwareClusterNetworkConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            pod_address_cidr_blocks=pod_address_cidr_blocks,
            service_address_cidr_blocks=service_address_cidr_blocks,
            control_plane_v2_config=control_plane_v2_config,
            dhcp_ip_config=dhcp_ip_config,
            host_config=host_config,
            static_ip_config=static_ip_config,
            vcenter_network=vcenter_network,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             pod_address_cidr_blocks: Sequence[str],
             service_address_cidr_blocks: Sequence[str],
             control_plane_v2_config: Optional['outputs.VMwareClusterNetworkConfigControlPlaneV2Config'] = None,
             dhcp_ip_config: Optional['outputs.VMwareClusterNetworkConfigDhcpIpConfig'] = None,
             host_config: Optional['outputs.VMwareClusterNetworkConfigHostConfig'] = None,
             static_ip_config: Optional['outputs.VMwareClusterNetworkConfigStaticIpConfig'] = None,
             vcenter_network: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("pod_address_cidr_blocks", pod_address_cidr_blocks)
        _setter("service_address_cidr_blocks", service_address_cidr_blocks)
        if control_plane_v2_config is not None:
            _setter("control_plane_v2_config", control_plane_v2_config)
        if dhcp_ip_config is not None:
            _setter("dhcp_ip_config", dhcp_ip_config)
        if host_config is not None:
            _setter("host_config", host_config)
        if static_ip_config is not None:
            _setter("static_ip_config", static_ip_config)
        if vcenter_network is not None:
            _setter("vcenter_network", vcenter_network)

    @property
    @pulumi.getter(name="podAddressCidrBlocks")
    def pod_address_cidr_blocks(self) -> Sequence[str]:
        """
        All pods in the cluster are assigned an RFC1918 IPv4 address from these ranges.
        Only a single range is supported. This field cannot be changed after creation.
        """
        return pulumi.get(self, "pod_address_cidr_blocks")

    @property
    @pulumi.getter(name="serviceAddressCidrBlocks")
    def service_address_cidr_blocks(self) -> Sequence[str]:
        """
        All services in the cluster are assigned an RFC1918 IPv4 address
        from these ranges. Only a single range is supported.. This field
        cannot be changed after creation.
        """
        return pulumi.get(self, "service_address_cidr_blocks")

    @property
    @pulumi.getter(name="controlPlaneV2Config")
    def control_plane_v2_config(self) -> Optional['outputs.VMwareClusterNetworkConfigControlPlaneV2Config']:
        """
        Configuration for control plane V2 mode.
        Structure is documented below.
        """
        return pulumi.get(self, "control_plane_v2_config")

    @property
    @pulumi.getter(name="dhcpIpConfig")
    def dhcp_ip_config(self) -> Optional['outputs.VMwareClusterNetworkConfigDhcpIpConfig']:
        """
        Configuration settings for a DHCP IP configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "dhcp_ip_config")

    @property
    @pulumi.getter(name="hostConfig")
    def host_config(self) -> Optional['outputs.VMwareClusterNetworkConfigHostConfig']:
        """
        Represents common network settings irrespective of the host's IP address.
        Structure is documented below.
        """
        return pulumi.get(self, "host_config")

    @property
    @pulumi.getter(name="staticIpConfig")
    def static_ip_config(self) -> Optional['outputs.VMwareClusterNetworkConfigStaticIpConfig']:
        """
        Configuration settings for a static IP configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "static_ip_config")

    @property
    @pulumi.getter(name="vcenterNetwork")
    def vcenter_network(self) -> Optional[str]:
        """
        (Output)
        vcenter_network specifies vCenter network name. Inherited from the admin cluster.
        """
        return pulumi.get(self, "vcenter_network")


@pulumi.output_type
class VMwareClusterNetworkConfigControlPlaneV2Config(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneIpBlock":
            suggest = "control_plane_ip_block"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterNetworkConfigControlPlaneV2Config. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterNetworkConfigControlPlaneV2Config.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterNetworkConfigControlPlaneV2Config.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_ip_block: Optional['outputs.VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlock'] = None):
        """
        :param 'VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockArgs' control_plane_ip_block: Static IP addresses for the control plane nodes.
               Structure is documented below.
        """
        VMwareClusterNetworkConfigControlPlaneV2Config._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            control_plane_ip_block=control_plane_ip_block,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             control_plane_ip_block: Optional['outputs.VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlock'] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if control_plane_ip_block is not None:
            _setter("control_plane_ip_block", control_plane_ip_block)

    @property
    @pulumi.getter(name="controlPlaneIpBlock")
    def control_plane_ip_block(self) -> Optional['outputs.VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlock']:
        """
        Static IP addresses for the control plane nodes.
        Structure is documented below.
        """
        return pulumi.get(self, "control_plane_ip_block")


@pulumi.output_type
class VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlock(dict):
    def __init__(__self__, *,
                 gateway: Optional[str] = None,
                 ips: Optional[Sequence['outputs.VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIp']] = None,
                 netmask: Optional[str] = None):
        """
        :param str gateway: The network gateway used by the VMware User Cluster.
        :param Sequence['VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIpArgs'] ips: The node's network configurations used by the VMware User Cluster.
               Structure is documented below.
        :param str netmask: The netmask used by the VMware User Cluster.
        """
        VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlock._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gateway=gateway,
            ips=ips,
            netmask=netmask,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gateway: Optional[str] = None,
             ips: Optional[Sequence['outputs.VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIp']] = None,
             netmask: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if gateway is not None:
            _setter("gateway", gateway)
        if ips is not None:
            _setter("ips", ips)
        if netmask is not None:
            _setter("netmask", netmask)

    @property
    @pulumi.getter
    def gateway(self) -> Optional[str]:
        """
        The network gateway used by the VMware User Cluster.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def ips(self) -> Optional[Sequence['outputs.VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIp']]:
        """
        The node's network configurations used by the VMware User Cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def netmask(self) -> Optional[str]:
        """
        The netmask used by the VMware User Cluster.
        """
        return pulumi.get(self, "netmask")


@pulumi.output_type
class VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIp(dict):
    def __init__(__self__, *,
                 hostname: Optional[str] = None,
                 ip: Optional[str] = None):
        """
        :param str hostname: Hostname of the machine. VM's name will be used if this field is empty.
        :param str ip: IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        """
        VMwareClusterNetworkConfigControlPlaneV2ConfigControlPlaneIpBlockIp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            hostname=hostname,
            ip=ip,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             hostname: Optional[str] = None,
             ip: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if hostname is not None:
            _setter("hostname", hostname)
        if ip is not None:
            _setter("ip", ip)

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname of the machine. VM's name will be used if this field is empty.
        """
        return pulumi.get(self, "hostname")

    @property
    @pulumi.getter
    def ip(self) -> Optional[str]:
        """
        IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        """
        return pulumi.get(self, "ip")


@pulumi.output_type
class VMwareClusterNetworkConfigDhcpIpConfig(dict):
    def __init__(__self__, *,
                 enabled: bool):
        """
        :param bool enabled: enabled is a flag to mark if DHCP IP allocation is
               used for VMware user clusters.
        """
        VMwareClusterNetworkConfigDhcpIpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            enabled=enabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             enabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("enabled", enabled)

    @property
    @pulumi.getter
    def enabled(self) -> bool:
        """
        enabled is a flag to mark if DHCP IP allocation is
        used for VMware user clusters.
        """
        return pulumi.get(self, "enabled")


@pulumi.output_type
class VMwareClusterNetworkConfigHostConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dnsSearchDomains":
            suggest = "dns_search_domains"
        elif key == "dnsServers":
            suggest = "dns_servers"
        elif key == "ntpServers":
            suggest = "ntp_servers"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterNetworkConfigHostConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterNetworkConfigHostConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterNetworkConfigHostConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dns_search_domains: Optional[Sequence[str]] = None,
                 dns_servers: Optional[Sequence[str]] = None,
                 ntp_servers: Optional[Sequence[str]] = None):
        """
        :param Sequence[str] dns_search_domains: DNS search domains.
               
               <a name="nested_control_plane_v2_config"></a>The `control_plane_v2_config` block supports:
        :param Sequence[str] dns_servers: DNS servers.
        :param Sequence[str] ntp_servers: NTP servers.
        """
        VMwareClusterNetworkConfigHostConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            dns_search_domains=dns_search_domains,
            dns_servers=dns_servers,
            ntp_servers=ntp_servers,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             dns_search_domains: Optional[Sequence[str]] = None,
             dns_servers: Optional[Sequence[str]] = None,
             ntp_servers: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if dns_search_domains is not None:
            _setter("dns_search_domains", dns_search_domains)
        if dns_servers is not None:
            _setter("dns_servers", dns_servers)
        if ntp_servers is not None:
            _setter("ntp_servers", ntp_servers)

    @property
    @pulumi.getter(name="dnsSearchDomains")
    def dns_search_domains(self) -> Optional[Sequence[str]]:
        """
        DNS search domains.

        <a name="nested_control_plane_v2_config"></a>The `control_plane_v2_config` block supports:
        """
        return pulumi.get(self, "dns_search_domains")

    @property
    @pulumi.getter(name="dnsServers")
    def dns_servers(self) -> Optional[Sequence[str]]:
        """
        DNS servers.
        """
        return pulumi.get(self, "dns_servers")

    @property
    @pulumi.getter(name="ntpServers")
    def ntp_servers(self) -> Optional[Sequence[str]]:
        """
        NTP servers.
        """
        return pulumi.get(self, "ntp_servers")


@pulumi.output_type
class VMwareClusterNetworkConfigStaticIpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipBlocks":
            suggest = "ip_blocks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterNetworkConfigStaticIpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterNetworkConfigStaticIpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterNetworkConfigStaticIpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_blocks: Sequence['outputs.VMwareClusterNetworkConfigStaticIpConfigIpBlock']):
        """
        :param Sequence['VMwareClusterNetworkConfigStaticIpConfigIpBlockArgs'] ip_blocks: Represents the configuration values for static IP allocation to nodes.
               Structure is documented below.
        """
        VMwareClusterNetworkConfigStaticIpConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip_blocks=ip_blocks,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip_blocks: Sequence['outputs.VMwareClusterNetworkConfigStaticIpConfigIpBlock'],
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ip_blocks", ip_blocks)

    @property
    @pulumi.getter(name="ipBlocks")
    def ip_blocks(self) -> Sequence['outputs.VMwareClusterNetworkConfigStaticIpConfigIpBlock']:
        """
        Represents the configuration values for static IP allocation to nodes.
        Structure is documented below.
        """
        return pulumi.get(self, "ip_blocks")


@pulumi.output_type
class VMwareClusterNetworkConfigStaticIpConfigIpBlock(dict):
    def __init__(__self__, *,
                 gateway: str,
                 ips: Sequence['outputs.VMwareClusterNetworkConfigStaticIpConfigIpBlockIp'],
                 netmask: str):
        """
        :param str gateway: The network gateway used by the VMware User Cluster.
        :param Sequence['VMwareClusterNetworkConfigStaticIpConfigIpBlockIpArgs'] ips: The node's network configurations used by the VMware User Cluster.
               Structure is documented below.
        :param str netmask: The netmask used by the VMware User Cluster.
        """
        VMwareClusterNetworkConfigStaticIpConfigIpBlock._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            gateway=gateway,
            ips=ips,
            netmask=netmask,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             gateway: str,
             ips: Sequence['outputs.VMwareClusterNetworkConfigStaticIpConfigIpBlockIp'],
             netmask: str,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("gateway", gateway)
        _setter("ips", ips)
        _setter("netmask", netmask)

    @property
    @pulumi.getter
    def gateway(self) -> str:
        """
        The network gateway used by the VMware User Cluster.
        """
        return pulumi.get(self, "gateway")

    @property
    @pulumi.getter
    def ips(self) -> Sequence['outputs.VMwareClusterNetworkConfigStaticIpConfigIpBlockIp']:
        """
        The node's network configurations used by the VMware User Cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "ips")

    @property
    @pulumi.getter
    def netmask(self) -> str:
        """
        The netmask used by the VMware User Cluster.
        """
        return pulumi.get(self, "netmask")


@pulumi.output_type
class VMwareClusterNetworkConfigStaticIpConfigIpBlockIp(dict):
    def __init__(__self__, *,
                 ip: str,
                 hostname: Optional[str] = None):
        """
        :param str ip: IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        :param str hostname: Hostname of the machine. VM's name will be used if this field is empty.
        """
        VMwareClusterNetworkConfigStaticIpConfigIpBlockIp._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            ip=ip,
            hostname=hostname,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             ip: str,
             hostname: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("ip", ip)
        if hostname is not None:
            _setter("hostname", hostname)

    @property
    @pulumi.getter
    def ip(self) -> str:
        """
        IP could be an IP address (like 1.2.3.4) or a CIDR (like 1.2.3.0/24).
        """
        return pulumi.get(self, "ip")

    @property
    @pulumi.getter
    def hostname(self) -> Optional[str]:
        """
        Hostname of the machine. VM's name will be used if this field is empty.
        """
        return pulumi.get(self, "hostname")


@pulumi.output_type
class VMwareClusterStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.VMwareClusterStatusCondition']] = None,
                 error_message: Optional[str] = None):
        """
        :param Sequence['VMwareClusterStatusConditionArgs'] conditions: (Output)
               ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
               Structure is documented below.
        :param str error_message: (Output)
               Human-friendly representation of the error message from the user cluster
               controller. The error message can be temporary as the user cluster
               controller creates a cluster or node pool. If the error message persists
               for a longer period of time, it can be used to surface error message to
               indicate real problems requiring user intervention.
        """
        VMwareClusterStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditions=conditions,
            error_message=error_message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditions: Optional[Sequence['outputs.VMwareClusterStatusCondition']] = None,
             error_message: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditions is not None:
            _setter("conditions", conditions)
        if error_message is not None:
            _setter("error_message", error_message)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.VMwareClusterStatusCondition']]:
        """
        (Output)
        ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        """
        (Output)
        Human-friendly representation of the error message from the user cluster
        controller. The error message can be temporary as the user cluster
        controller creates a cluster or node pool. If the error message persists
        for a longer period of time, it can be used to surface error message to
        indicate real problems requiring user intervention.
        """
        return pulumi.get(self, "error_message")


@pulumi.output_type
class VMwareClusterStatusCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterStatusCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterStatusCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterStatusCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 state: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str last_transition_time: (Output)
               Last time the condition transit from one status to another.
        :param str message: (Output)
               Human-readable message indicating details about last transition.
        :param str reason: (Output)
               Machine-readable message indicating details about last transition.
        :param str state: (Output)
               The lifecycle state of the condition.
        :param str type: (Output)
               Type of the condition.
               (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        VMwareClusterStatusCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            last_transition_time=last_transition_time,
            message=message,
            reason=reason,
            state=state,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             last_transition_time: Optional[str] = None,
             message: Optional[str] = None,
             reason: Optional[str] = None,
             state: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if last_transition_time is not None:
            _setter("last_transition_time", last_transition_time)
        if message is not None:
            _setter("message", message)
        if reason is not None:
            _setter("reason", reason)
        if state is not None:
            _setter("state", state)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        (Output)
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        (Output)
        Human-readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        (Output)
        Machine-readable message indicating details about last transition.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        (Output)
        The lifecycle state of the condition.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        (Output)
        Type of the condition.
        (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class VMwareClusterStorage(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "vsphereCsiDisabled":
            suggest = "vsphere_csi_disabled"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterStorage. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterStorage.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterStorage.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 vsphere_csi_disabled: bool):
        """
        :param bool vsphere_csi_disabled: Whether or not to deploy vSphere CSI components in the VMware User Cluster.
               Enabled by default.
        """
        VMwareClusterStorage._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            vsphere_csi_disabled=vsphere_csi_disabled,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             vsphere_csi_disabled: bool,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("vsphere_csi_disabled", vsphere_csi_disabled)

    @property
    @pulumi.getter(name="vsphereCsiDisabled")
    def vsphere_csi_disabled(self) -> bool:
        """
        Whether or not to deploy vSphere CSI components in the VMware User Cluster.
        Enabled by default.
        """
        return pulumi.get(self, "vsphere_csi_disabled")


@pulumi.output_type
class VMwareClusterUpgradePolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "controlPlaneOnly":
            suggest = "control_plane_only"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterUpgradePolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterUpgradePolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterUpgradePolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 control_plane_only: Optional[bool] = None):
        """
        :param bool control_plane_only: Controls whether the upgrade applies to the control plane only.
        """
        VMwareClusterUpgradePolicy._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            control_plane_only=control_plane_only,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             control_plane_only: Optional[bool] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if control_plane_only is not None:
            _setter("control_plane_only", control_plane_only)

    @property
    @pulumi.getter(name="controlPlaneOnly")
    def control_plane_only(self) -> Optional[bool]:
        """
        Controls whether the upgrade applies to the control plane only.
        """
        return pulumi.get(self, "control_plane_only")


@pulumi.output_type
class VMwareClusterValidationCheck(dict):
    def __init__(__self__, *,
                 options: Optional[str] = None,
                 scenario: Optional[str] = None,
                 statuses: Optional[Sequence['outputs.VMwareClusterValidationCheckStatus']] = None):
        """
        :param str options: (Output)
               Options used for the validation check.
        :param str scenario: (Output)
               The scenario when the preflight checks were run..
        :param Sequence['VMwareClusterValidationCheckStatusArgs'] statuses: (Output)
               Specifies the detailed validation check status
               Structure is documented below.
        """
        VMwareClusterValidationCheck._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            options=options,
            scenario=scenario,
            statuses=statuses,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             options: Optional[str] = None,
             scenario: Optional[str] = None,
             statuses: Optional[Sequence['outputs.VMwareClusterValidationCheckStatus']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if options is not None:
            _setter("options", options)
        if scenario is not None:
            _setter("scenario", scenario)
        if statuses is not None:
            _setter("statuses", statuses)

    @property
    @pulumi.getter
    def options(self) -> Optional[str]:
        """
        (Output)
        Options used for the validation check.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def scenario(self) -> Optional[str]:
        """
        (Output)
        The scenario when the preflight checks were run..
        """
        return pulumi.get(self, "scenario")

    @property
    @pulumi.getter
    def statuses(self) -> Optional[Sequence['outputs.VMwareClusterValidationCheckStatus']]:
        """
        (Output)
        Specifies the detailed validation check status
        Structure is documented below.
        """
        return pulumi.get(self, "statuses")


@pulumi.output_type
class VMwareClusterValidationCheckStatus(dict):
    def __init__(__self__, *,
                 results: Optional[Sequence['outputs.VMwareClusterValidationCheckStatusResult']] = None):
        """
        :param Sequence['VMwareClusterValidationCheckStatusResultArgs'] results: (Output)
               Individual checks which failed as part of the Preflight check execution.
               Structure is documented below.
        """
        VMwareClusterValidationCheckStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            results=results,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             results: Optional[Sequence['outputs.VMwareClusterValidationCheckStatusResult']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if results is not None:
            _setter("results", results)

    @property
    @pulumi.getter
    def results(self) -> Optional[Sequence['outputs.VMwareClusterValidationCheckStatusResult']]:
        """
        (Output)
        Individual checks which failed as part of the Preflight check execution.
        Structure is documented below.
        """
        return pulumi.get(self, "results")


@pulumi.output_type
class VMwareClusterValidationCheckStatusResult(dict):
    def __init__(__self__, *,
                 category: Optional[str] = None,
                 description: Optional[str] = None,
                 details: Optional[str] = None,
                 options: Optional[str] = None,
                 reason: Optional[str] = None):
        """
        :param str category: (Output)
               The category of the validation.
        :param str description: A human readable description of this VMware User Cluster.
        :param str details: (Output)
               Detailed failure information, which might be unformatted.
        :param str options: (Output)
               Options used for the validation check.
        :param str reason: (Output)
               Machine-readable message indicating details about last transition.
        """
        VMwareClusterValidationCheckStatusResult._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            description=description,
            details=details,
            options=options,
            reason=reason,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             description: Optional[str] = None,
             details: Optional[str] = None,
             options: Optional[str] = None,
             reason: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if description is not None:
            _setter("description", description)
        if details is not None:
            _setter("details", details)
        if options is not None:
            _setter("options", options)
        if reason is not None:
            _setter("reason", reason)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        (Output)
        The category of the validation.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def description(self) -> Optional[str]:
        """
        A human readable description of this VMware User Cluster.
        """
        return pulumi.get(self, "description")

    @property
    @pulumi.getter
    def details(self) -> Optional[str]:
        """
        (Output)
        Detailed failure information, which might be unformatted.
        """
        return pulumi.get(self, "details")

    @property
    @pulumi.getter
    def options(self) -> Optional[str]:
        """
        (Output)
        Options used for the validation check.
        """
        return pulumi.get(self, "options")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        (Output)
        Machine-readable message indicating details about last transition.
        """
        return pulumi.get(self, "reason")


@pulumi.output_type
class VMwareClusterVcenter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertData":
            suggest = "ca_cert_data"
        elif key == "resourcePool":
            suggest = "resource_pool"
        elif key == "storagePolicyName":
            suggest = "storage_policy_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareClusterVcenter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareClusterVcenter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareClusterVcenter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 address: Optional[str] = None,
                 ca_cert_data: Optional[str] = None,
                 cluster: Optional[str] = None,
                 datacenter: Optional[str] = None,
                 datastore: Optional[str] = None,
                 folder: Optional[str] = None,
                 resource_pool: Optional[str] = None,
                 storage_policy_name: Optional[str] = None):
        """
        :param str address: The load balancer's IP address.
        :param str ca_cert_data: (Output)
               Contains the vCenter CA certificate public key for SSL verification.
        :param str cluster: (Output)
               The name of the vCenter cluster for the user cluster.
        :param str datacenter: (Output)
               The name of the vCenter datacenter for the user cluster.
        :param str datastore: (Output)
               The Vsphere datastore used by the Control Plane Node.
        :param str folder: (Output)
               The name of the vCenter folder for the user cluster.
        :param str resource_pool: (Output)
               The name of the vCenter resource pool for the user cluster.
        :param str storage_policy_name: (Output)
               The Vsphere storage policy used by the control plane Node.
               
               - - -
        """
        VMwareClusterVcenter._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            address=address,
            ca_cert_data=ca_cert_data,
            cluster=cluster,
            datacenter=datacenter,
            datastore=datastore,
            folder=folder,
            resource_pool=resource_pool,
            storage_policy_name=storage_policy_name,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             address: Optional[str] = None,
             ca_cert_data: Optional[str] = None,
             cluster: Optional[str] = None,
             datacenter: Optional[str] = None,
             datastore: Optional[str] = None,
             folder: Optional[str] = None,
             resource_pool: Optional[str] = None,
             storage_policy_name: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if address is not None:
            _setter("address", address)
        if ca_cert_data is not None:
            _setter("ca_cert_data", ca_cert_data)
        if cluster is not None:
            _setter("cluster", cluster)
        if datacenter is not None:
            _setter("datacenter", datacenter)
        if datastore is not None:
            _setter("datastore", datastore)
        if folder is not None:
            _setter("folder", folder)
        if resource_pool is not None:
            _setter("resource_pool", resource_pool)
        if storage_policy_name is not None:
            _setter("storage_policy_name", storage_policy_name)

    @property
    @pulumi.getter
    def address(self) -> Optional[str]:
        """
        The load balancer's IP address.
        """
        return pulumi.get(self, "address")

    @property
    @pulumi.getter(name="caCertData")
    def ca_cert_data(self) -> Optional[str]:
        """
        (Output)
        Contains the vCenter CA certificate public key for SSL verification.
        """
        return pulumi.get(self, "ca_cert_data")

    @property
    @pulumi.getter
    def cluster(self) -> Optional[str]:
        """
        (Output)
        The name of the vCenter cluster for the user cluster.
        """
        return pulumi.get(self, "cluster")

    @property
    @pulumi.getter
    def datacenter(self) -> Optional[str]:
        """
        (Output)
        The name of the vCenter datacenter for the user cluster.
        """
        return pulumi.get(self, "datacenter")

    @property
    @pulumi.getter
    def datastore(self) -> Optional[str]:
        """
        (Output)
        The Vsphere datastore used by the Control Plane Node.
        """
        return pulumi.get(self, "datastore")

    @property
    @pulumi.getter
    def folder(self) -> Optional[str]:
        """
        (Output)
        The name of the vCenter folder for the user cluster.
        """
        return pulumi.get(self, "folder")

    @property
    @pulumi.getter(name="resourcePool")
    def resource_pool(self) -> Optional[str]:
        """
        (Output)
        The name of the vCenter resource pool for the user cluster.
        """
        return pulumi.get(self, "resource_pool")

    @property
    @pulumi.getter(name="storagePolicyName")
    def storage_policy_name(self) -> Optional[str]:
        """
        (Output)
        The Vsphere storage policy used by the control plane Node.

        - - -
        """
        return pulumi.get(self, "storage_policy_name")


@pulumi.output_type
class VMwareNodePoolConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageType":
            suggest = "image_type"
        elif key == "bootDiskSizeGb":
            suggest = "boot_disk_size_gb"
        elif key == "enableLoadBalancer":
            suggest = "enable_load_balancer"
        elif key == "memoryMb":
            suggest = "memory_mb"
        elif key == "vsphereConfigs":
            suggest = "vsphere_configs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareNodePoolConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareNodePoolConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareNodePoolConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 image_type: str,
                 boot_disk_size_gb: Optional[int] = None,
                 cpus: Optional[int] = None,
                 enable_load_balancer: Optional[bool] = None,
                 image: Optional[str] = None,
                 labels: Optional[Mapping[str, str]] = None,
                 memory_mb: Optional[int] = None,
                 replicas: Optional[int] = None,
                 taints: Optional[Sequence['outputs.VMwareNodePoolConfigTaint']] = None,
                 vsphere_configs: Optional[Sequence['outputs.VMwareNodePoolConfigVsphereConfig']] = None):
        """
        :param str image_type: The OS image to be used for each node in a node pool.
               Currently `cos`, `ubuntu`, `ubuntu_containerd` and `windows` are supported.
        :param int boot_disk_size_gb: VMware disk size to be used during creation.
        :param int cpus: The number of CPUs for each node in the node pool.
        :param bool enable_load_balancer: Allow node pool traffic to be load balanced. Only works for clusters with
               MetalLB load balancers.
        :param str image: The OS image name in vCenter, only valid when using Windows.
        :param Mapping[str, str] labels: The map of Kubernetes labels (key/value pairs) to be applied to each node.
               These will added in addition to any default label(s) that
               Kubernetes may apply to the node.
               In case of conflict in label keys, the applied set may differ depending on
               the Kubernetes version -- it's best to assume the behavior is undefined
               and conflicts should be avoided.
        :param int memory_mb: The megabytes of memory for each node in the node pool.
        :param int replicas: The number of nodes in the node pool.
        :param Sequence['VMwareNodePoolConfigTaintArgs'] taints: The initial taints assigned to nodes of this node pool.
               Structure is documented below.
        :param Sequence['VMwareNodePoolConfigVsphereConfigArgs'] vsphere_configs: (Output)
               Specifies the vSphere config for node pool.
               Structure is documented below.
        """
        VMwareNodePoolConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            image_type=image_type,
            boot_disk_size_gb=boot_disk_size_gb,
            cpus=cpus,
            enable_load_balancer=enable_load_balancer,
            image=image,
            labels=labels,
            memory_mb=memory_mb,
            replicas=replicas,
            taints=taints,
            vsphere_configs=vsphere_configs,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             image_type: str,
             boot_disk_size_gb: Optional[int] = None,
             cpus: Optional[int] = None,
             enable_load_balancer: Optional[bool] = None,
             image: Optional[str] = None,
             labels: Optional[Mapping[str, str]] = None,
             memory_mb: Optional[int] = None,
             replicas: Optional[int] = None,
             taints: Optional[Sequence['outputs.VMwareNodePoolConfigTaint']] = None,
             vsphere_configs: Optional[Sequence['outputs.VMwareNodePoolConfigVsphereConfig']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("image_type", image_type)
        if boot_disk_size_gb is not None:
            _setter("boot_disk_size_gb", boot_disk_size_gb)
        if cpus is not None:
            _setter("cpus", cpus)
        if enable_load_balancer is not None:
            _setter("enable_load_balancer", enable_load_balancer)
        if image is not None:
            _setter("image", image)
        if labels is not None:
            _setter("labels", labels)
        if memory_mb is not None:
            _setter("memory_mb", memory_mb)
        if replicas is not None:
            _setter("replicas", replicas)
        if taints is not None:
            _setter("taints", taints)
        if vsphere_configs is not None:
            _setter("vsphere_configs", vsphere_configs)

    @property
    @pulumi.getter(name="imageType")
    def image_type(self) -> str:
        """
        The OS image to be used for each node in a node pool.
        Currently `cos`, `ubuntu`, `ubuntu_containerd` and `windows` are supported.
        """
        return pulumi.get(self, "image_type")

    @property
    @pulumi.getter(name="bootDiskSizeGb")
    def boot_disk_size_gb(self) -> Optional[int]:
        """
        VMware disk size to be used during creation.
        """
        return pulumi.get(self, "boot_disk_size_gb")

    @property
    @pulumi.getter
    def cpus(self) -> Optional[int]:
        """
        The number of CPUs for each node in the node pool.
        """
        return pulumi.get(self, "cpus")

    @property
    @pulumi.getter(name="enableLoadBalancer")
    def enable_load_balancer(self) -> Optional[bool]:
        """
        Allow node pool traffic to be load balanced. Only works for clusters with
        MetalLB load balancers.
        """
        return pulumi.get(self, "enable_load_balancer")

    @property
    @pulumi.getter
    def image(self) -> Optional[str]:
        """
        The OS image name in vCenter, only valid when using Windows.
        """
        return pulumi.get(self, "image")

    @property
    @pulumi.getter
    def labels(self) -> Optional[Mapping[str, str]]:
        """
        The map of Kubernetes labels (key/value pairs) to be applied to each node.
        These will added in addition to any default label(s) that
        Kubernetes may apply to the node.
        In case of conflict in label keys, the applied set may differ depending on
        the Kubernetes version -- it's best to assume the behavior is undefined
        and conflicts should be avoided.
        """
        return pulumi.get(self, "labels")

    @property
    @pulumi.getter(name="memoryMb")
    def memory_mb(self) -> Optional[int]:
        """
        The megabytes of memory for each node in the node pool.
        """
        return pulumi.get(self, "memory_mb")

    @property
    @pulumi.getter
    def replicas(self) -> Optional[int]:
        """
        The number of nodes in the node pool.
        """
        return pulumi.get(self, "replicas")

    @property
    @pulumi.getter
    def taints(self) -> Optional[Sequence['outputs.VMwareNodePoolConfigTaint']]:
        """
        The initial taints assigned to nodes of this node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "taints")

    @property
    @pulumi.getter(name="vsphereConfigs")
    def vsphere_configs(self) -> Optional[Sequence['outputs.VMwareNodePoolConfigVsphereConfig']]:
        """
        (Output)
        Specifies the vSphere config for node pool.
        Structure is documented below.
        """
        return pulumi.get(self, "vsphere_configs")


@pulumi.output_type
class VMwareNodePoolConfigTaint(dict):
    def __init__(__self__, *,
                 key: str,
                 value: str,
                 effect: Optional[str] = None):
        """
        :param str key: Key associated with the effect.
        :param str value: Value associated with the effect.
        :param str effect: Available taint effects.
               Possible values are: `EFFECT_UNSPECIFIED`, `NO_SCHEDULE`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.
               
               <a name="nested_vsphere_config"></a>The `vsphere_config` block contains:
        """
        VMwareNodePoolConfigTaint._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            key=key,
            value=value,
            effect=effect,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             key: str,
             value: str,
             effect: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("key", key)
        _setter("value", value)
        if effect is not None:
            _setter("effect", effect)

    @property
    @pulumi.getter
    def key(self) -> str:
        """
        Key associated with the effect.
        """
        return pulumi.get(self, "key")

    @property
    @pulumi.getter
    def value(self) -> str:
        """
        Value associated with the effect.
        """
        return pulumi.get(self, "value")

    @property
    @pulumi.getter
    def effect(self) -> Optional[str]:
        """
        Available taint effects.
        Possible values are: `EFFECT_UNSPECIFIED`, `NO_SCHEDULE`, `PREFER_NO_SCHEDULE`, `NO_EXECUTE`.

        <a name="nested_vsphere_config"></a>The `vsphere_config` block contains:
        """
        return pulumi.get(self, "effect")


@pulumi.output_type
class VMwareNodePoolConfigVsphereConfig(dict):
    def __init__(__self__, *,
                 datastore: Optional[str] = None,
                 tags: Optional[Sequence['outputs.VMwareNodePoolConfigVsphereConfigTag']] = None):
        """
        :param str datastore: (Output)
               The name of the vCenter datastore. Inherited from the user cluster.
        :param Sequence['VMwareNodePoolConfigVsphereConfigTagArgs'] tags: (Output)
               Tags to apply to VMs.
               Structure is documented below.
               
               
               <a name="nested_tags"></a>The `tags` block contains:
        """
        VMwareNodePoolConfigVsphereConfig._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            datastore=datastore,
            tags=tags,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             datastore: Optional[str] = None,
             tags: Optional[Sequence['outputs.VMwareNodePoolConfigVsphereConfigTag']] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if datastore is not None:
            _setter("datastore", datastore)
        if tags is not None:
            _setter("tags", tags)

    @property
    @pulumi.getter
    def datastore(self) -> Optional[str]:
        """
        (Output)
        The name of the vCenter datastore. Inherited from the user cluster.
        """
        return pulumi.get(self, "datastore")

    @property
    @pulumi.getter
    def tags(self) -> Optional[Sequence['outputs.VMwareNodePoolConfigVsphereConfigTag']]:
        """
        (Output)
        Tags to apply to VMs.
        Structure is documented below.


        <a name="nested_tags"></a>The `tags` block contains:
        """
        return pulumi.get(self, "tags")


@pulumi.output_type
class VMwareNodePoolConfigVsphereConfigTag(dict):
    def __init__(__self__, *,
                 category: Optional[str] = None,
                 tag: Optional[str] = None):
        """
        :param str category: (Output)
               The Vsphere tag category.
        :param str tag: (Output)
               The Vsphere tag name.
               
               - - -
        """
        VMwareNodePoolConfigVsphereConfigTag._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            category=category,
            tag=tag,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             category: Optional[str] = None,
             tag: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if category is not None:
            _setter("category", category)
        if tag is not None:
            _setter("tag", tag)

    @property
    @pulumi.getter
    def category(self) -> Optional[str]:
        """
        (Output)
        The Vsphere tag category.
        """
        return pulumi.get(self, "category")

    @property
    @pulumi.getter
    def tag(self) -> Optional[str]:
        """
        (Output)
        The Vsphere tag name.

        - - -
        """
        return pulumi.get(self, "tag")


@pulumi.output_type
class VMwareNodePoolNodePoolAutoscaling(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "maxReplicas":
            suggest = "max_replicas"
        elif key == "minReplicas":
            suggest = "min_replicas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareNodePoolNodePoolAutoscaling. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareNodePoolNodePoolAutoscaling.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareNodePoolNodePoolAutoscaling.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 max_replicas: int,
                 min_replicas: int):
        """
        :param int max_replicas: Maximum number of replicas in the NodePool.
        :param int min_replicas: Minimum number of replicas in the NodePool.
        """
        VMwareNodePoolNodePoolAutoscaling._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            max_replicas=max_replicas,
            min_replicas=min_replicas,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             max_replicas: int,
             min_replicas: int,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("max_replicas", max_replicas)
        _setter("min_replicas", min_replicas)

    @property
    @pulumi.getter(name="maxReplicas")
    def max_replicas(self) -> int:
        """
        Maximum number of replicas in the NodePool.
        """
        return pulumi.get(self, "max_replicas")

    @property
    @pulumi.getter(name="minReplicas")
    def min_replicas(self) -> int:
        """
        Minimum number of replicas in the NodePool.
        """
        return pulumi.get(self, "min_replicas")


@pulumi.output_type
class VMwareNodePoolStatus(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "errorMessage":
            suggest = "error_message"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareNodePoolStatus. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareNodePoolStatus.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareNodePoolStatus.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 conditions: Optional[Sequence['outputs.VMwareNodePoolStatusCondition']] = None,
                 error_message: Optional[str] = None):
        """
        :param Sequence['VMwareNodePoolStatusConditionArgs'] conditions: (Output)
               ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
               Structure is documented below.
        :param str error_message: (Output)
               Human-friendly representation of the error message from the user cluster
               controller. The error message can be temporary as the user cluster
               controller creates a cluster or node pool. If the error message persists
               for a longer period of time, it can be used to surface error message to
               indicate real problems requiring user intervention.
        """
        VMwareNodePoolStatus._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            conditions=conditions,
            error_message=error_message,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             conditions: Optional[Sequence['outputs.VMwareNodePoolStatusCondition']] = None,
             error_message: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if conditions is not None:
            _setter("conditions", conditions)
        if error_message is not None:
            _setter("error_message", error_message)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[Sequence['outputs.VMwareNodePoolStatusCondition']]:
        """
        (Output)
        ResourceConditions provide a standard mechanism for higher-level status reporting from user cluster controller.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @property
    @pulumi.getter(name="errorMessage")
    def error_message(self) -> Optional[str]:
        """
        (Output)
        Human-friendly representation of the error message from the user cluster
        controller. The error message can be temporary as the user cluster
        controller creates a cluster or node pool. If the error message persists
        for a longer period of time, it can be used to surface error message to
        indicate real problems requiring user intervention.
        """
        return pulumi.get(self, "error_message")


@pulumi.output_type
class VMwareNodePoolStatusCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "lastTransitionTime":
            suggest = "last_transition_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in VMwareNodePoolStatusCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        VMwareNodePoolStatusCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        VMwareNodePoolStatusCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 last_transition_time: Optional[str] = None,
                 message: Optional[str] = None,
                 reason: Optional[str] = None,
                 state: Optional[str] = None,
                 type: Optional[str] = None):
        """
        :param str last_transition_time: (Output)
               Last time the condition transit from one status to another.
        :param str message: (Output)
               Human-readable message indicating details about last transition.
        :param str reason: (Output)
               Machine-readable message indicating details about last transition.
        :param str state: (Output)
               The lifecycle state of the condition.
        :param str type: (Output)
               Type of the condition.
               (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        VMwareNodePoolStatusCondition._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            last_transition_time=last_transition_time,
            message=message,
            reason=reason,
            state=state,
            type=type,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             last_transition_time: Optional[str] = None,
             message: Optional[str] = None,
             reason: Optional[str] = None,
             state: Optional[str] = None,
             type: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if last_transition_time is not None:
            _setter("last_transition_time", last_transition_time)
        if message is not None:
            _setter("message", message)
        if reason is not None:
            _setter("reason", reason)
        if state is not None:
            _setter("state", state)
        if type is not None:
            _setter("type", type)

    @property
    @pulumi.getter(name="lastTransitionTime")
    def last_transition_time(self) -> Optional[str]:
        """
        (Output)
        Last time the condition transit from one status to another.
        """
        return pulumi.get(self, "last_transition_time")

    @property
    @pulumi.getter
    def message(self) -> Optional[str]:
        """
        (Output)
        Human-readable message indicating details about last transition.
        """
        return pulumi.get(self, "message")

    @property
    @pulumi.getter
    def reason(self) -> Optional[str]:
        """
        (Output)
        Machine-readable message indicating details about last transition.
        """
        return pulumi.get(self, "reason")

    @property
    @pulumi.getter
    def state(self) -> Optional[str]:
        """
        (Output)
        The lifecycle state of the condition.
        """
        return pulumi.get(self, "state")

    @property
    @pulumi.getter
    def type(self) -> Optional[str]:
        """
        (Output)
        Type of the condition.
        (e.g., ClusterRunning, NodePoolRunning or ServerSidePreflightReady)
        """
        return pulumi.get(self, "type")


