# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'AclConfigIdpConfig',
    'AclConfigIdpConfigExternalIdpConfig',
    'AssistantCustomerPolicy',
    'AssistantCustomerPolicyBannedPhrase',
    'AssistantCustomerPolicyModelArmorConfig',
    'AssistantGenerationConfig',
    'AssistantGenerationConfigSystemInstruction',
    'ChatEngineChatEngineConfig',
    'ChatEngineChatEngineConfigAgentCreationConfig',
    'ChatEngineChatEngineMetadata',
    'ChatEngineCommonConfig',
    'CmekConfigSingleRegionKey',
    'ControlBoostAction',
    'ControlBoostActionInterpolationBoostSpec',
    'ControlBoostActionInterpolationBoostSpecControlPoint',
    'ControlCondition',
    'ControlConditionActiveTimeRange',
    'ControlConditionQueryTerm',
    'ControlFilterAction',
    'ControlPromoteAction',
    'ControlPromoteActionSearchLinkPromotion',
    'ControlRedirectAction',
    'ControlSynonymsAction',
    'DataConnectorEntity',
    'DataConnectorError',
    'DataStoreAdvancedSiteSearchConfig',
    'DataStoreDocumentProcessingConfig',
    'DataStoreDocumentProcessingConfigChunkingConfig',
    'DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfig',
    'DataStoreDocumentProcessingConfigDefaultParsingConfig',
    'DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfig',
    'DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfig',
    'DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfig',
    'DataStoreDocumentProcessingConfigParsingConfigOverride',
    'DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfig',
    'DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfig',
    'DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfig',
    'LicenseConfigEndDate',
    'LicenseConfigStartDate',
    'RecommendationEngineCommonConfig',
    'RecommendationEngineMediaRecommendationEngineConfig',
    'RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfig',
    'RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfig',
    'RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfig',
    'RecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfig',
    'SearchEngineCommonConfig',
    'SearchEngineSearchEngineConfig',
    'TargetSiteFailureReason',
    'TargetSiteFailureReasonQuotaFailure',
    'TargetSiteSiteVerificationInfo',
    'WidgetConfigAccessSettings',
    'WidgetConfigHomepageSetting',
    'WidgetConfigHomepageSettingShortcut',
    'WidgetConfigHomepageSettingShortcutIcon',
    'WidgetConfigUiBranding',
    'WidgetConfigUiBrandingLogo',
    'WidgetConfigUiSettings',
    'WidgetConfigUiSettingsDataStoreUiConfig',
    'WidgetConfigUiSettingsDataStoreUiConfigFacetField',
    'WidgetConfigUiSettingsDataStoreUiConfigFieldsUiComponentsMap',
    'WidgetConfigUiSettingsGenerativeAnswerConfig',
]

@pulumi.output_type
class AclConfigIdpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalIdpConfig":
            suggest = "external_idp_config"
        elif key == "idpType":
            suggest = "idp_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AclConfigIdpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AclConfigIdpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AclConfigIdpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_idp_config: Optional['outputs.AclConfigIdpConfigExternalIdpConfig'] = None,
                 idp_type: Optional[_builtins.str] = None):
        """
        :param 'AclConfigIdpConfigExternalIdpConfigArgs' external_idp_config: External third party identity provider config.
               Structure is documented below.
        :param _builtins.str idp_type: Identity provider type.
               Possible values are: `GSUITE`, `THIRD_PARTY`.
        """
        if external_idp_config is not None:
            pulumi.set(__self__, "external_idp_config", external_idp_config)
        if idp_type is not None:
            pulumi.set(__self__, "idp_type", idp_type)

    @_builtins.property
    @pulumi.getter(name="externalIdpConfig")
    def external_idp_config(self) -> Optional['outputs.AclConfigIdpConfigExternalIdpConfig']:
        """
        External third party identity provider config.
        Structure is documented below.
        """
        return pulumi.get(self, "external_idp_config")

    @_builtins.property
    @pulumi.getter(name="idpType")
    def idp_type(self) -> Optional[_builtins.str]:
        """
        Identity provider type.
        Possible values are: `GSUITE`, `THIRD_PARTY`.
        """
        return pulumi.get(self, "idp_type")


@pulumi.output_type
class AclConfigIdpConfigExternalIdpConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "workforcePoolName":
            suggest = "workforce_pool_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AclConfigIdpConfigExternalIdpConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AclConfigIdpConfigExternalIdpConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AclConfigIdpConfigExternalIdpConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 workforce_pool_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str workforce_pool_name: Workforce pool name: "locations/global/workforcePools/pool_id"
        """
        if workforce_pool_name is not None:
            pulumi.set(__self__, "workforce_pool_name", workforce_pool_name)

    @_builtins.property
    @pulumi.getter(name="workforcePoolName")
    def workforce_pool_name(self) -> Optional[_builtins.str]:
        """
        Workforce pool name: "locations/global/workforcePools/pool_id"
        """
        return pulumi.get(self, "workforce_pool_name")


@pulumi.output_type
class AssistantCustomerPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "bannedPhrases":
            suggest = "banned_phrases"
        elif key == "modelArmorConfig":
            suggest = "model_armor_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssistantCustomerPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssistantCustomerPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssistantCustomerPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 banned_phrases: Optional[Sequence['outputs.AssistantCustomerPolicyBannedPhrase']] = None,
                 model_armor_config: Optional['outputs.AssistantCustomerPolicyModelArmorConfig'] = None):
        """
        :param Sequence['AssistantCustomerPolicyBannedPhraseArgs'] banned_phrases: List of banned phrases.
               Structure is documented below.
        :param 'AssistantCustomerPolicyModelArmorConfigArgs' model_armor_config: Model Armor configuration to be used for sanitizing user prompts and assistant responses.
               Structure is documented below.
        """
        if banned_phrases is not None:
            pulumi.set(__self__, "banned_phrases", banned_phrases)
        if model_armor_config is not None:
            pulumi.set(__self__, "model_armor_config", model_armor_config)

    @_builtins.property
    @pulumi.getter(name="bannedPhrases")
    def banned_phrases(self) -> Optional[Sequence['outputs.AssistantCustomerPolicyBannedPhrase']]:
        """
        List of banned phrases.
        Structure is documented below.
        """
        return pulumi.get(self, "banned_phrases")

    @_builtins.property
    @pulumi.getter(name="modelArmorConfig")
    def model_armor_config(self) -> Optional['outputs.AssistantCustomerPolicyModelArmorConfig']:
        """
        Model Armor configuration to be used for sanitizing user prompts and assistant responses.
        Structure is documented below.
        """
        return pulumi.get(self, "model_armor_config")


@pulumi.output_type
class AssistantCustomerPolicyBannedPhrase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ignoreDiacritics":
            suggest = "ignore_diacritics"
        elif key == "matchType":
            suggest = "match_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssistantCustomerPolicyBannedPhrase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssistantCustomerPolicyBannedPhrase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssistantCustomerPolicyBannedPhrase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 phrase: _builtins.str,
                 ignore_diacritics: Optional[_builtins.bool] = None,
                 match_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str phrase: The raw string content to be banned.
        :param _builtins.bool ignore_diacritics: If true, diacritical marks (e.g., accents, umlauts) are ignored when
               matching banned phrases. For example, "cafe" would match "café".
        :param _builtins.str match_type: Match type for the banned phrase.
               The supported values: 'SIMPLE_STRING_MATCH', 'WORD_BOUNDARY_STRING_MATCH'.
        """
        pulumi.set(__self__, "phrase", phrase)
        if ignore_diacritics is not None:
            pulumi.set(__self__, "ignore_diacritics", ignore_diacritics)
        if match_type is not None:
            pulumi.set(__self__, "match_type", match_type)

    @_builtins.property
    @pulumi.getter
    def phrase(self) -> _builtins.str:
        """
        The raw string content to be banned.
        """
        return pulumi.get(self, "phrase")

    @_builtins.property
    @pulumi.getter(name="ignoreDiacritics")
    def ignore_diacritics(self) -> Optional[_builtins.bool]:
        """
        If true, diacritical marks (e.g., accents, umlauts) are ignored when
        matching banned phrases. For example, "cafe" would match "café".
        """
        return pulumi.get(self, "ignore_diacritics")

    @_builtins.property
    @pulumi.getter(name="matchType")
    def match_type(self) -> Optional[_builtins.str]:
        """
        Match type for the banned phrase.
        The supported values: 'SIMPLE_STRING_MATCH', 'WORD_BOUNDARY_STRING_MATCH'.
        """
        return pulumi.get(self, "match_type")


@pulumi.output_type
class AssistantCustomerPolicyModelArmorConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "responseTemplate":
            suggest = "response_template"
        elif key == "userPromptTemplate":
            suggest = "user_prompt_template"
        elif key == "failureMode":
            suggest = "failure_mode"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssistantCustomerPolicyModelArmorConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssistantCustomerPolicyModelArmorConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssistantCustomerPolicyModelArmorConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 response_template: _builtins.str,
                 user_prompt_template: _builtins.str,
                 failure_mode: Optional[_builtins.str] = None):
        """
        :param _builtins.str response_template: The resource name of the Model Armor template for sanitizing assistant
               responses. Format:
               `projects/{project}/locations/{location}/templates/{template_id}`
               If not specified, no sanitization will be applied to the assistant
               response.
        :param _builtins.str user_prompt_template: The resource name of the Model Armor template for sanitizing user
               prompts. Format:
               `projects/{project}/locations/{location}/templates/{template_id}`
               If not specified, no sanitization will be applied to the user prompt.
        :param _builtins.str failure_mode: Defines the failure mode for Model Armor sanitization.
               The supported values: 'FAIL_OPEN', 'FAIL_CLOSED'.
        """
        pulumi.set(__self__, "response_template", response_template)
        pulumi.set(__self__, "user_prompt_template", user_prompt_template)
        if failure_mode is not None:
            pulumi.set(__self__, "failure_mode", failure_mode)

    @_builtins.property
    @pulumi.getter(name="responseTemplate")
    def response_template(self) -> _builtins.str:
        """
        The resource name of the Model Armor template for sanitizing assistant
        responses. Format:
        `projects/{project}/locations/{location}/templates/{template_id}`
        If not specified, no sanitization will be applied to the assistant
        response.
        """
        return pulumi.get(self, "response_template")

    @_builtins.property
    @pulumi.getter(name="userPromptTemplate")
    def user_prompt_template(self) -> _builtins.str:
        """
        The resource name of the Model Armor template for sanitizing user
        prompts. Format:
        `projects/{project}/locations/{location}/templates/{template_id}`
        If not specified, no sanitization will be applied to the user prompt.
        """
        return pulumi.get(self, "user_prompt_template")

    @_builtins.property
    @pulumi.getter(name="failureMode")
    def failure_mode(self) -> Optional[_builtins.str]:
        """
        Defines the failure mode for Model Armor sanitization.
        The supported values: 'FAIL_OPEN', 'FAIL_CLOSED'.
        """
        return pulumi.get(self, "failure_mode")


@pulumi.output_type
class AssistantGenerationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultLanguage":
            suggest = "default_language"
        elif key == "systemInstruction":
            suggest = "system_instruction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssistantGenerationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssistantGenerationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssistantGenerationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_language: Optional[_builtins.str] = None,
                 system_instruction: Optional['outputs.AssistantGenerationConfigSystemInstruction'] = None):
        """
        :param _builtins.str default_language: The default language to use for the generation of the assistant response.
               Use an ISO 639-1 language code such as `en`.
               If not specified, the language will be automatically detected.
        :param 'AssistantGenerationConfigSystemInstructionArgs' system_instruction: System instruction, also known as the prompt preamble for LLM calls.
               See also https://cloud.google.com/vertex-ai/generative-ai/docs/learn/prompts/system-instructions
               Structure is documented below.
        """
        if default_language is not None:
            pulumi.set(__self__, "default_language", default_language)
        if system_instruction is not None:
            pulumi.set(__self__, "system_instruction", system_instruction)

    @_builtins.property
    @pulumi.getter(name="defaultLanguage")
    def default_language(self) -> Optional[_builtins.str]:
        """
        The default language to use for the generation of the assistant response.
        Use an ISO 639-1 language code such as `en`.
        If not specified, the language will be automatically detected.
        """
        return pulumi.get(self, "default_language")

    @_builtins.property
    @pulumi.getter(name="systemInstruction")
    def system_instruction(self) -> Optional['outputs.AssistantGenerationConfigSystemInstruction']:
        """
        System instruction, also known as the prompt preamble for LLM calls.
        See also https://cloud.google.com/vertex-ai/generative-ai/docs/learn/prompts/system-instructions
        Structure is documented below.
        """
        return pulumi.get(self, "system_instruction")


@pulumi.output_type
class AssistantGenerationConfigSystemInstruction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "additionalSystemInstruction":
            suggest = "additional_system_instruction"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in AssistantGenerationConfigSystemInstruction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        AssistantGenerationConfigSystemInstruction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        AssistantGenerationConfigSystemInstruction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 additional_system_instruction: Optional[_builtins.str] = None):
        """
        :param _builtins.str additional_system_instruction: Additional system instruction that will be added to the default system instruction.
        """
        if additional_system_instruction is not None:
            pulumi.set(__self__, "additional_system_instruction", additional_system_instruction)

    @_builtins.property
    @pulumi.getter(name="additionalSystemInstruction")
    def additional_system_instruction(self) -> Optional[_builtins.str]:
        """
        Additional system instruction that will be added to the default system instruction.
        """
        return pulumi.get(self, "additional_system_instruction")


@pulumi.output_type
class ChatEngineChatEngineConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "agentCreationConfig":
            suggest = "agent_creation_config"
        elif key == "allowCrossRegion":
            suggest = "allow_cross_region"
        elif key == "dialogflowAgentToLink":
            suggest = "dialogflow_agent_to_link"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChatEngineChatEngineConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChatEngineChatEngineConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChatEngineChatEngineConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 agent_creation_config: Optional['outputs.ChatEngineChatEngineConfigAgentCreationConfig'] = None,
                 allow_cross_region: Optional[_builtins.bool] = None,
                 dialogflow_agent_to_link: Optional[_builtins.str] = None):
        """
        :param 'ChatEngineChatEngineConfigAgentCreationConfigArgs' agent_creation_config: The configuration to generate the Dialogflow agent that is associated to this Engine.
               Exactly one of `agent_creation_config` or `dialogflow_agent_to_link` must be set.
               Structure is documented below.
        :param _builtins.bool allow_cross_region: If the flag set to true, we allow the agent and engine are in
               different locations, otherwise the agent and engine are required to be
               in the same location. The flag is set to false by default.
               Note that the `allow_cross_region` are one-time consumed by and passed
               to EngineService.CreateEngine. It means they cannot be retrieved using
               EngineService.GetEngine or EngineService.ListEngines API after engine
               creation.
        :param _builtins.str dialogflow_agent_to_link: The resource name of an existing Dialogflow agent to link to this Chat Engine. Format: `projects/<Project_ID>/locations/<Location_ID>/agents/<Agent_ID>`.
               Exactly one of `agent_creation_config` or `dialogflow_agent_to_link` must be set.
        """
        if agent_creation_config is not None:
            pulumi.set(__self__, "agent_creation_config", agent_creation_config)
        if allow_cross_region is not None:
            pulumi.set(__self__, "allow_cross_region", allow_cross_region)
        if dialogflow_agent_to_link is not None:
            pulumi.set(__self__, "dialogflow_agent_to_link", dialogflow_agent_to_link)

    @_builtins.property
    @pulumi.getter(name="agentCreationConfig")
    def agent_creation_config(self) -> Optional['outputs.ChatEngineChatEngineConfigAgentCreationConfig']:
        """
        The configuration to generate the Dialogflow agent that is associated to this Engine.
        Exactly one of `agent_creation_config` or `dialogflow_agent_to_link` must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "agent_creation_config")

    @_builtins.property
    @pulumi.getter(name="allowCrossRegion")
    def allow_cross_region(self) -> Optional[_builtins.bool]:
        """
        If the flag set to true, we allow the agent and engine are in
        different locations, otherwise the agent and engine are required to be
        in the same location. The flag is set to false by default.
        Note that the `allow_cross_region` are one-time consumed by and passed
        to EngineService.CreateEngine. It means they cannot be retrieved using
        EngineService.GetEngine or EngineService.ListEngines API after engine
        creation.
        """
        return pulumi.get(self, "allow_cross_region")

    @_builtins.property
    @pulumi.getter(name="dialogflowAgentToLink")
    def dialogflow_agent_to_link(self) -> Optional[_builtins.str]:
        """
        The resource name of an existing Dialogflow agent to link to this Chat Engine. Format: `projects/<Project_ID>/locations/<Location_ID>/agents/<Agent_ID>`.
        Exactly one of `agent_creation_config` or `dialogflow_agent_to_link` must be set.
        """
        return pulumi.get(self, "dialogflow_agent_to_link")


@pulumi.output_type
class ChatEngineChatEngineConfigAgentCreationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "defaultLanguageCode":
            suggest = "default_language_code"
        elif key == "timeZone":
            suggest = "time_zone"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChatEngineChatEngineConfigAgentCreationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChatEngineChatEngineConfigAgentCreationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChatEngineChatEngineConfigAgentCreationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 default_language_code: _builtins.str,
                 time_zone: _builtins.str,
                 business: Optional[_builtins.str] = None,
                 location: Optional[_builtins.str] = None):
        """
        :param _builtins.str default_language_code: The default language of the agent as a language tag. See [Language Support](https://cloud.google.com/dialogflow/docs/reference/language) for a list of the currently supported language codes.
        :param _builtins.str time_zone: The time zone of the agent from the [time zone database](https://www.iana.org/time-zones), e.g., America/New_York, Europe/Paris.
        :param _builtins.str business: Name of the company, organization or other entity that the agent represents. Used for knowledge connector LLM prompt and for knowledge search.
        :param _builtins.str location: Agent location for Agent creation, currently supported values: global/us/eu, it needs to be the same region as the Chat Engine.
        """
        pulumi.set(__self__, "default_language_code", default_language_code)
        pulumi.set(__self__, "time_zone", time_zone)
        if business is not None:
            pulumi.set(__self__, "business", business)
        if location is not None:
            pulumi.set(__self__, "location", location)

    @_builtins.property
    @pulumi.getter(name="defaultLanguageCode")
    def default_language_code(self) -> _builtins.str:
        """
        The default language of the agent as a language tag. See [Language Support](https://cloud.google.com/dialogflow/docs/reference/language) for a list of the currently supported language codes.
        """
        return pulumi.get(self, "default_language_code")

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> _builtins.str:
        """
        The time zone of the agent from the [time zone database](https://www.iana.org/time-zones), e.g., America/New_York, Europe/Paris.
        """
        return pulumi.get(self, "time_zone")

    @_builtins.property
    @pulumi.getter
    def business(self) -> Optional[_builtins.str]:
        """
        Name of the company, organization or other entity that the agent represents. Used for knowledge connector LLM prompt and for knowledge search.
        """
        return pulumi.get(self, "business")

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[_builtins.str]:
        """
        Agent location for Agent creation, currently supported values: global/us/eu, it needs to be the same region as the Chat Engine.
        """
        return pulumi.get(self, "location")


@pulumi.output_type
class ChatEngineChatEngineMetadata(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dialogflowAgent":
            suggest = "dialogflow_agent"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChatEngineChatEngineMetadata. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChatEngineChatEngineMetadata.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChatEngineChatEngineMetadata.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dialogflow_agent: Optional[_builtins.str] = None):
        """
        :param _builtins.str dialogflow_agent: (Output)
               The resource name of a Dialogflow agent, that this Chat Engine refers to.
        """
        if dialogflow_agent is not None:
            pulumi.set(__self__, "dialogflow_agent", dialogflow_agent)

    @_builtins.property
    @pulumi.getter(name="dialogflowAgent")
    def dialogflow_agent(self) -> Optional[_builtins.str]:
        """
        (Output)
        The resource name of a Dialogflow agent, that this Chat Engine refers to.
        """
        return pulumi.get(self, "dialogflow_agent")


@pulumi.output_type
class ChatEngineCommonConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "companyName":
            suggest = "company_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ChatEngineCommonConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ChatEngineCommonConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ChatEngineCommonConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 company_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str company_name: The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.
        """
        if company_name is not None:
            pulumi.set(__self__, "company_name", company_name)

    @_builtins.property
    @pulumi.getter(name="companyName")
    def company_name(self) -> Optional[_builtins.str]:
        """
        The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.
        """
        return pulumi.get(self, "company_name")


@pulumi.output_type
class CmekConfigSingleRegionKey(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "kmsKey":
            suggest = "kms_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in CmekConfigSingleRegionKey. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        CmekConfigSingleRegionKey.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        CmekConfigSingleRegionKey.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 kms_key: _builtins.str):
        """
        :param _builtins.str kms_key: Single-regional kms key resource name which will be used to encrypt
               resources
               `projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{keyId}`.
        """
        pulumi.set(__self__, "kms_key", kms_key)

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> _builtins.str:
        """
        Single-regional kms key resource name which will be used to encrypt
        resources
        `projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{keyId}`.
        """
        return pulumi.get(self, "kms_key")


@pulumi.output_type
class ControlBoostAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStore":
            suggest = "data_store"
        elif key == "fixedBoost":
            suggest = "fixed_boost"
        elif key == "interpolationBoostSpec":
            suggest = "interpolation_boost_spec"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ControlBoostAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ControlBoostAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ControlBoostAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_store: _builtins.str,
                 filter: _builtins.str,
                 fixed_boost: Optional[_builtins.float] = None,
                 interpolation_boost_spec: Optional['outputs.ControlBoostActionInterpolationBoostSpec'] = None):
        """
        :param _builtins.str data_store: The data store to boost.
        :param _builtins.str filter: The filter to apply to the search results.
        :param _builtins.float fixed_boost: The fixed boost value to apply to the search results. Positive values will increase the relevance of the results, while negative values will decrease the relevance. The value must be between -100 and 100.
        :param 'ControlBoostActionInterpolationBoostSpecArgs' interpolation_boost_spec: The interpolation boost specification to apply to the search results.
               Structure is documented below.
        """
        pulumi.set(__self__, "data_store", data_store)
        pulumi.set(__self__, "filter", filter)
        if fixed_boost is not None:
            pulumi.set(__self__, "fixed_boost", fixed_boost)
        if interpolation_boost_spec is not None:
            pulumi.set(__self__, "interpolation_boost_spec", interpolation_boost_spec)

    @_builtins.property
    @pulumi.getter(name="dataStore")
    def data_store(self) -> _builtins.str:
        """
        The data store to boost.
        """
        return pulumi.get(self, "data_store")

    @_builtins.property
    @pulumi.getter
    def filter(self) -> _builtins.str:
        """
        The filter to apply to the search results.
        """
        return pulumi.get(self, "filter")

    @_builtins.property
    @pulumi.getter(name="fixedBoost")
    def fixed_boost(self) -> Optional[_builtins.float]:
        """
        The fixed boost value to apply to the search results. Positive values will increase the relevance of the results, while negative values will decrease the relevance. The value must be between -100 and 100.
        """
        return pulumi.get(self, "fixed_boost")

    @_builtins.property
    @pulumi.getter(name="interpolationBoostSpec")
    def interpolation_boost_spec(self) -> Optional['outputs.ControlBoostActionInterpolationBoostSpec']:
        """
        The interpolation boost specification to apply to the search results.
        Structure is documented below.
        """
        return pulumi.get(self, "interpolation_boost_spec")


@pulumi.output_type
class ControlBoostActionInterpolationBoostSpec(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeType":
            suggest = "attribute_type"
        elif key == "controlPoint":
            suggest = "control_point"
        elif key == "fieldName":
            suggest = "field_name"
        elif key == "interpolationType":
            suggest = "interpolation_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ControlBoostActionInterpolationBoostSpec. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ControlBoostActionInterpolationBoostSpec.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ControlBoostActionInterpolationBoostSpec.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_type: Optional[_builtins.str] = None,
                 control_point: Optional['outputs.ControlBoostActionInterpolationBoostSpecControlPoint'] = None,
                 field_name: Optional[_builtins.str] = None,
                 interpolation_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str attribute_type: The attribute type to be used to determine the boost amount.
               Possible values are: `NUMERICAL`, `FRESHNESS`.
        :param 'ControlBoostActionInterpolationBoostSpecControlPointArgs' control_point: The control points used to define the curve.
               Structure is documented below.
        :param _builtins.str field_name: The name of the field whose value will be used to determine the boost amount.
        :param _builtins.str interpolation_type: The interpolation type to be applied to connect the control points.
               Possible values are: `LINEAR`.
        """
        if attribute_type is not None:
            pulumi.set(__self__, "attribute_type", attribute_type)
        if control_point is not None:
            pulumi.set(__self__, "control_point", control_point)
        if field_name is not None:
            pulumi.set(__self__, "field_name", field_name)
        if interpolation_type is not None:
            pulumi.set(__self__, "interpolation_type", interpolation_type)

    @_builtins.property
    @pulumi.getter(name="attributeType")
    def attribute_type(self) -> Optional[_builtins.str]:
        """
        The attribute type to be used to determine the boost amount.
        Possible values are: `NUMERICAL`, `FRESHNESS`.
        """
        return pulumi.get(self, "attribute_type")

    @_builtins.property
    @pulumi.getter(name="controlPoint")
    def control_point(self) -> Optional['outputs.ControlBoostActionInterpolationBoostSpecControlPoint']:
        """
        The control points used to define the curve.
        Structure is documented below.
        """
        return pulumi.get(self, "control_point")

    @_builtins.property
    @pulumi.getter(name="fieldName")
    def field_name(self) -> Optional[_builtins.str]:
        """
        The name of the field whose value will be used to determine the boost amount.
        """
        return pulumi.get(self, "field_name")

    @_builtins.property
    @pulumi.getter(name="interpolationType")
    def interpolation_type(self) -> Optional[_builtins.str]:
        """
        The interpolation type to be applied to connect the control points.
        Possible values are: `LINEAR`.
        """
        return pulumi.get(self, "interpolation_type")


@pulumi.output_type
class ControlBoostActionInterpolationBoostSpecControlPoint(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "attributeValue":
            suggest = "attribute_value"
        elif key == "boostAmount":
            suggest = "boost_amount"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ControlBoostActionInterpolationBoostSpecControlPoint. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ControlBoostActionInterpolationBoostSpecControlPoint.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ControlBoostActionInterpolationBoostSpecControlPoint.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 attribute_value: Optional[_builtins.str] = None,
                 boost_amount: Optional[_builtins.float] = None):
        """
        :param _builtins.str attribute_value: The attribute value of the control point.
        :param _builtins.float boost_amount: The value between -1 to 1 by which to boost the score if the attributeValue
               evaluates to the value specified above.
        """
        if attribute_value is not None:
            pulumi.set(__self__, "attribute_value", attribute_value)
        if boost_amount is not None:
            pulumi.set(__self__, "boost_amount", boost_amount)

    @_builtins.property
    @pulumi.getter(name="attributeValue")
    def attribute_value(self) -> Optional[_builtins.str]:
        """
        The attribute value of the control point.
        """
        return pulumi.get(self, "attribute_value")

    @_builtins.property
    @pulumi.getter(name="boostAmount")
    def boost_amount(self) -> Optional[_builtins.float]:
        """
        The value between -1 to 1 by which to boost the score if the attributeValue
        evaluates to the value specified above.
        """
        return pulumi.get(self, "boost_amount")


@pulumi.output_type
class ControlCondition(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "activeTimeRanges":
            suggest = "active_time_ranges"
        elif key == "queryRegex":
            suggest = "query_regex"
        elif key == "queryTerms":
            suggest = "query_terms"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ControlCondition. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ControlCondition.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ControlCondition.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 active_time_ranges: Optional[Sequence['outputs.ControlConditionActiveTimeRange']] = None,
                 query_regex: Optional[_builtins.str] = None,
                 query_terms: Optional[Sequence['outputs.ControlConditionQueryTerm']] = None):
        """
        :param Sequence['ControlConditionActiveTimeRangeArgs'] active_time_ranges: The time range when the condition is active.
               Structure is documented below.
        :param _builtins.str query_regex: The regular expression that the query must match for this condition to be met.
        :param Sequence['ControlConditionQueryTermArgs'] query_terms: The query terms that must be present in the search request for this condition to be met.
               Structure is documented below.
        """
        if active_time_ranges is not None:
            pulumi.set(__self__, "active_time_ranges", active_time_ranges)
        if query_regex is not None:
            pulumi.set(__self__, "query_regex", query_regex)
        if query_terms is not None:
            pulumi.set(__self__, "query_terms", query_terms)

    @_builtins.property
    @pulumi.getter(name="activeTimeRanges")
    def active_time_ranges(self) -> Optional[Sequence['outputs.ControlConditionActiveTimeRange']]:
        """
        The time range when the condition is active.
        Structure is documented below.
        """
        return pulumi.get(self, "active_time_ranges")

    @_builtins.property
    @pulumi.getter(name="queryRegex")
    def query_regex(self) -> Optional[_builtins.str]:
        """
        The regular expression that the query must match for this condition to be met.
        """
        return pulumi.get(self, "query_regex")

    @_builtins.property
    @pulumi.getter(name="queryTerms")
    def query_terms(self) -> Optional[Sequence['outputs.ControlConditionQueryTerm']]:
        """
        The query terms that must be present in the search request for this condition to be met.
        Structure is documented below.
        """
        return pulumi.get(self, "query_terms")


@pulumi.output_type
class ControlConditionActiveTimeRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "endTime":
            suggest = "end_time"
        elif key == "startTime":
            suggest = "start_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ControlConditionActiveTimeRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ControlConditionActiveTimeRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ControlConditionActiveTimeRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 end_time: Optional[_builtins.str] = None,
                 start_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str end_time: The end time of the active time range.
        :param _builtins.str start_time: The start time of the active time range.
        """
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[_builtins.str]:
        """
        The end time of the active time range.
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[_builtins.str]:
        """
        The start time of the active time range.
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class ControlConditionQueryTerm(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fullMatch":
            suggest = "full_match"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ControlConditionQueryTerm. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ControlConditionQueryTerm.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ControlConditionQueryTerm.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 full_match: Optional[_builtins.bool] = None,
                 value: Optional[_builtins.str] = None):
        """
        :param _builtins.bool full_match: If true, the query term must be an exact match. Otherwise, the query term can be a partial match.
        :param _builtins.str value: The value of the query term.
        """
        if full_match is not None:
            pulumi.set(__self__, "full_match", full_match)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter(name="fullMatch")
    def full_match(self) -> Optional[_builtins.bool]:
        """
        If true, the query term must be an exact match. Otherwise, the query term can be a partial match.
        """
        return pulumi.get(self, "full_match")

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[_builtins.str]:
        """
        The value of the query term.
        """
        return pulumi.get(self, "value")


@pulumi.output_type
class ControlFilterAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStore":
            suggest = "data_store"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ControlFilterAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ControlFilterAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ControlFilterAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_store: _builtins.str,
                 filter: _builtins.str):
        """
        :param _builtins.str data_store: The data store to filter.
        :param _builtins.str filter: The filter to apply to the search results.
        """
        pulumi.set(__self__, "data_store", data_store)
        pulumi.set(__self__, "filter", filter)

    @_builtins.property
    @pulumi.getter(name="dataStore")
    def data_store(self) -> _builtins.str:
        """
        The data store to filter.
        """
        return pulumi.get(self, "data_store")

    @_builtins.property
    @pulumi.getter
    def filter(self) -> _builtins.str:
        """
        The filter to apply to the search results.
        """
        return pulumi.get(self, "filter")


@pulumi.output_type
class ControlPromoteAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStore":
            suggest = "data_store"
        elif key == "searchLinkPromotion":
            suggest = "search_link_promotion"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ControlPromoteAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ControlPromoteAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ControlPromoteAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_store: _builtins.str,
                 search_link_promotion: 'outputs.ControlPromoteActionSearchLinkPromotion'):
        """
        :param _builtins.str data_store: The data store to promote.
        :param 'ControlPromoteActionSearchLinkPromotionArgs' search_link_promotion: The search link promotion to apply to the search results.
               Structure is documented below.
        """
        pulumi.set(__self__, "data_store", data_store)
        pulumi.set(__self__, "search_link_promotion", search_link_promotion)

    @_builtins.property
    @pulumi.getter(name="dataStore")
    def data_store(self) -> _builtins.str:
        """
        The data store to promote.
        """
        return pulumi.get(self, "data_store")

    @_builtins.property
    @pulumi.getter(name="searchLinkPromotion")
    def search_link_promotion(self) -> 'outputs.ControlPromoteActionSearchLinkPromotion':
        """
        The search link promotion to apply to the search results.
        Structure is documented below.
        """
        return pulumi.get(self, "search_link_promotion")


@pulumi.output_type
class ControlPromoteActionSearchLinkPromotion(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "imageUri":
            suggest = "image_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ControlPromoteActionSearchLinkPromotion. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ControlPromoteActionSearchLinkPromotion.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ControlPromoteActionSearchLinkPromotion.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 title: _builtins.str,
                 description: Optional[_builtins.str] = None,
                 document: Optional[_builtins.str] = None,
                 enabled: Optional[_builtins.bool] = None,
                 image_uri: Optional[_builtins.str] = None,
                 uri: Optional[_builtins.str] = None):
        """
        :param _builtins.str title: The title of the promoted link.
        :param _builtins.str description: The description of the promoted link.
        :param _builtins.str document: The document to promote.
        :param _builtins.bool enabled: Return promotions for basic site search.
        :param _builtins.str image_uri: The image URI of the promoted link.
        :param _builtins.str uri: The URI to promote.
        """
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)
        if document is not None:
            pulumi.set(__self__, "document", document)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if image_uri is not None:
            pulumi.set(__self__, "image_uri", image_uri)
        if uri is not None:
            pulumi.set(__self__, "uri", uri)

    @_builtins.property
    @pulumi.getter
    def title(self) -> _builtins.str:
        """
        The title of the promoted link.
        """
        return pulumi.get(self, "title")

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[_builtins.str]:
        """
        The description of the promoted link.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter
    def document(self) -> Optional[_builtins.str]:
        """
        The document to promote.
        """
        return pulumi.get(self, "document")

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        Return promotions for basic site search.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter(name="imageUri")
    def image_uri(self) -> Optional[_builtins.str]:
        """
        The image URI of the promoted link.
        """
        return pulumi.get(self, "image_uri")

    @_builtins.property
    @pulumi.getter
    def uri(self) -> Optional[_builtins.str]:
        """
        The URI to promote.
        """
        return pulumi.get(self, "uri")


@pulumi.output_type
class ControlRedirectAction(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "redirectUri":
            suggest = "redirect_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ControlRedirectAction. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ControlRedirectAction.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ControlRedirectAction.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 redirect_uri: _builtins.str):
        """
        :param _builtins.str redirect_uri: The URI to redirect to.
        """
        pulumi.set(__self__, "redirect_uri", redirect_uri)

    @_builtins.property
    @pulumi.getter(name="redirectUri")
    def redirect_uri(self) -> _builtins.str:
        """
        The URI to redirect to.
        """
        return pulumi.get(self, "redirect_uri")


@pulumi.output_type
class ControlSynonymsAction(dict):
    def __init__(__self__, *,
                 synonyms: Optional[Sequence[_builtins.str]] = None):
        """
        :param Sequence[_builtins.str] synonyms: The synonyms to apply to the search results.
        """
        if synonyms is not None:
            pulumi.set(__self__, "synonyms", synonyms)

    @_builtins.property
    @pulumi.getter
    def synonyms(self) -> Optional[Sequence[_builtins.str]]:
        """
        The synonyms to apply to the search results.
        """
        return pulumi.get(self, "synonyms")


@pulumi.output_type
class DataConnectorEntity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStore":
            suggest = "data_store"
        elif key == "entityName":
            suggest = "entity_name"
        elif key == "keyPropertyMappings":
            suggest = "key_property_mappings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataConnectorEntity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataConnectorEntity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataConnectorEntity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_store: Optional[_builtins.str] = None,
                 entity_name: Optional[_builtins.str] = None,
                 key_property_mappings: Optional[Mapping[str, _builtins.str]] = None,
                 params: Optional[_builtins.str] = None):
        """
        :param _builtins.str data_store: (Output)
               The full resource name of the associated data store for the source
               entity.
               Format: `projects/*/locations/*/collections/*/dataStores/*`.
               When the connector is initialized by the DataConnectorService.SetUpDataConnector
               method, a DataStore is automatically created for each source entity.
        :param _builtins.str entity_name: The name of the entity. Supported values by data source:
               * Salesforce: `Lead`, `Opportunity`, `Contact`, `Account`, `Case`, `Contract`, `Campaign`
               * Jira: project, issue, attachment, comment, worklog
               * Confluence: `Content`, `Space`
        :param Mapping[str, _builtins.str] key_property_mappings: Attributes for indexing.
               Key: Field name.
               Value: The key property to map a field to, such as `title`, and
               `description`. Supported key properties:
        :param _builtins.str params: The parameters for the entity to facilitate data ingestion.
        """
        if data_store is not None:
            pulumi.set(__self__, "data_store", data_store)
        if entity_name is not None:
            pulumi.set(__self__, "entity_name", entity_name)
        if key_property_mappings is not None:
            pulumi.set(__self__, "key_property_mappings", key_property_mappings)
        if params is not None:
            pulumi.set(__self__, "params", params)

    @_builtins.property
    @pulumi.getter(name="dataStore")
    def data_store(self) -> Optional[_builtins.str]:
        """
        (Output)
        The full resource name of the associated data store for the source
        entity.
        Format: `projects/*/locations/*/collections/*/dataStores/*`.
        When the connector is initialized by the DataConnectorService.SetUpDataConnector
        method, a DataStore is automatically created for each source entity.
        """
        return pulumi.get(self, "data_store")

    @_builtins.property
    @pulumi.getter(name="entityName")
    def entity_name(self) -> Optional[_builtins.str]:
        """
        The name of the entity. Supported values by data source:
        * Salesforce: `Lead`, `Opportunity`, `Contact`, `Account`, `Case`, `Contract`, `Campaign`
        * Jira: project, issue, attachment, comment, worklog
        * Confluence: `Content`, `Space`
        """
        return pulumi.get(self, "entity_name")

    @_builtins.property
    @pulumi.getter(name="keyPropertyMappings")
    def key_property_mappings(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Attributes for indexing.
        Key: Field name.
        Value: The key property to map a field to, such as `title`, and
        `description`. Supported key properties:
        """
        return pulumi.get(self, "key_property_mappings")

    @_builtins.property
    @pulumi.getter
    def params(self) -> Optional[_builtins.str]:
        """
        The parameters for the entity to facilitate data ingestion.
        """
        return pulumi.get(self, "params")


@pulumi.output_type
class DataConnectorError(dict):
    def __init__(__self__, *,
                 code: Optional[_builtins.int] = None,
                 message: Optional[_builtins.str] = None):
        """
        :param _builtins.int code: (Output)
               The status code, which should be an enum value of google.rpc.Code.
        :param _builtins.str message: (Output)
               A developer-facing error message, which should be in English.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def code(self) -> Optional[_builtins.int]:
        """
        (Output)
        The status code, which should be an enum value of google.rpc.Code.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        (Output)
        A developer-facing error message, which should be in English.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class DataStoreAdvancedSiteSearchConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableAutomaticRefresh":
            suggest = "disable_automatic_refresh"
        elif key == "disableInitialIndex":
            suggest = "disable_initial_index"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataStoreAdvancedSiteSearchConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataStoreAdvancedSiteSearchConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataStoreAdvancedSiteSearchConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_automatic_refresh: Optional[_builtins.bool] = None,
                 disable_initial_index: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool disable_automatic_refresh: If set true, automatic refresh is disabled for the DataStore.
        :param _builtins.bool disable_initial_index: If set true, initial indexing is disabled for the DataStore.
        """
        if disable_automatic_refresh is not None:
            pulumi.set(__self__, "disable_automatic_refresh", disable_automatic_refresh)
        if disable_initial_index is not None:
            pulumi.set(__self__, "disable_initial_index", disable_initial_index)

    @_builtins.property
    @pulumi.getter(name="disableAutomaticRefresh")
    def disable_automatic_refresh(self) -> Optional[_builtins.bool]:
        """
        If set true, automatic refresh is disabled for the DataStore.
        """
        return pulumi.get(self, "disable_automatic_refresh")

    @_builtins.property
    @pulumi.getter(name="disableInitialIndex")
    def disable_initial_index(self) -> Optional[_builtins.bool]:
        """
        If set true, initial indexing is disabled for the DataStore.
        """
        return pulumi.get(self, "disable_initial_index")


@pulumi.output_type
class DataStoreDocumentProcessingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkingConfig":
            suggest = "chunking_config"
        elif key == "defaultParsingConfig":
            suggest = "default_parsing_config"
        elif key == "parsingConfigOverrides":
            suggest = "parsing_config_overrides"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataStoreDocumentProcessingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataStoreDocumentProcessingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataStoreDocumentProcessingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunking_config: Optional['outputs.DataStoreDocumentProcessingConfigChunkingConfig'] = None,
                 default_parsing_config: Optional['outputs.DataStoreDocumentProcessingConfigDefaultParsingConfig'] = None,
                 name: Optional[_builtins.str] = None,
                 parsing_config_overrides: Optional[Sequence['outputs.DataStoreDocumentProcessingConfigParsingConfigOverride']] = None):
        """
        :param 'DataStoreDocumentProcessingConfigChunkingConfigArgs' chunking_config: Whether chunking mode is enabled.
               Structure is documented below.
        :param 'DataStoreDocumentProcessingConfigDefaultParsingConfigArgs' default_parsing_config: Configurations for default Document parser. If not specified, this resource
               will be configured to use a default DigitalParsingConfig, and the default parsing
               config will be applied to all file types for Document parsing.
               Structure is documented below.
        :param _builtins.str name: (Output)
               The full resource name of the Document Processing Config. Format:
               `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/documentProcessingConfig`.
        :param Sequence['DataStoreDocumentProcessingConfigParsingConfigOverrideArgs'] parsing_config_overrides: Map from file type to override the default parsing configuration based on the file type. Supported keys:
        """
        if chunking_config is not None:
            pulumi.set(__self__, "chunking_config", chunking_config)
        if default_parsing_config is not None:
            pulumi.set(__self__, "default_parsing_config", default_parsing_config)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parsing_config_overrides is not None:
            pulumi.set(__self__, "parsing_config_overrides", parsing_config_overrides)

    @_builtins.property
    @pulumi.getter(name="chunkingConfig")
    def chunking_config(self) -> Optional['outputs.DataStoreDocumentProcessingConfigChunkingConfig']:
        """
        Whether chunking mode is enabled.
        Structure is documented below.
        """
        return pulumi.get(self, "chunking_config")

    @_builtins.property
    @pulumi.getter(name="defaultParsingConfig")
    def default_parsing_config(self) -> Optional['outputs.DataStoreDocumentProcessingConfigDefaultParsingConfig']:
        """
        Configurations for default Document parser. If not specified, this resource
        will be configured to use a default DigitalParsingConfig, and the default parsing
        config will be applied to all file types for Document parsing.
        Structure is documented below.
        """
        return pulumi.get(self, "default_parsing_config")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        (Output)
        The full resource name of the Document Processing Config. Format:
        `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/documentProcessingConfig`.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="parsingConfigOverrides")
    def parsing_config_overrides(self) -> Optional[Sequence['outputs.DataStoreDocumentProcessingConfigParsingConfigOverride']]:
        """
        Map from file type to override the default parsing configuration based on the file type. Supported keys:
        """
        return pulumi.get(self, "parsing_config_overrides")


@pulumi.output_type
class DataStoreDocumentProcessingConfigChunkingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "layoutBasedChunkingConfig":
            suggest = "layout_based_chunking_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataStoreDocumentProcessingConfigChunkingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataStoreDocumentProcessingConfigChunkingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataStoreDocumentProcessingConfigChunkingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 layout_based_chunking_config: Optional['outputs.DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfig'] = None):
        """
        :param 'DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgs' layout_based_chunking_config: Configuration for the layout based chunking.
               Structure is documented below.
        """
        if layout_based_chunking_config is not None:
            pulumi.set(__self__, "layout_based_chunking_config", layout_based_chunking_config)

    @_builtins.property
    @pulumi.getter(name="layoutBasedChunkingConfig")
    def layout_based_chunking_config(self) -> Optional['outputs.DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfig']:
        """
        Configuration for the layout based chunking.
        Structure is documented below.
        """
        return pulumi.get(self, "layout_based_chunking_config")


@pulumi.output_type
class DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "chunkSize":
            suggest = "chunk_size"
        elif key == "includeAncestorHeadings":
            suggest = "include_ancestor_headings"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 chunk_size: Optional[_builtins.int] = None,
                 include_ancestor_headings: Optional[_builtins.bool] = None):
        """
        :param _builtins.int chunk_size: The token size limit for each chunk.
               Supported values: 100-500 (inclusive). Default value: 500.
        :param _builtins.bool include_ancestor_headings: Whether to include appending different levels of headings to chunks from the middle of the document to prevent context loss.
               Default value: False.
        """
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if include_ancestor_headings is not None:
            pulumi.set(__self__, "include_ancestor_headings", include_ancestor_headings)

    @_builtins.property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[_builtins.int]:
        """
        The token size limit for each chunk.
        Supported values: 100-500 (inclusive). Default value: 500.
        """
        return pulumi.get(self, "chunk_size")

    @_builtins.property
    @pulumi.getter(name="includeAncestorHeadings")
    def include_ancestor_headings(self) -> Optional[_builtins.bool]:
        """
        Whether to include appending different levels of headings to chunks from the middle of the document to prevent context loss.
        Default value: False.
        """
        return pulumi.get(self, "include_ancestor_headings")


@pulumi.output_type
class DataStoreDocumentProcessingConfigDefaultParsingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "digitalParsingConfig":
            suggest = "digital_parsing_config"
        elif key == "layoutParsingConfig":
            suggest = "layout_parsing_config"
        elif key == "ocrParsingConfig":
            suggest = "ocr_parsing_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataStoreDocumentProcessingConfigDefaultParsingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataStoreDocumentProcessingConfigDefaultParsingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataStoreDocumentProcessingConfigDefaultParsingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 digital_parsing_config: Optional['outputs.DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfig'] = None,
                 layout_parsing_config: Optional['outputs.DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfig'] = None,
                 ocr_parsing_config: Optional['outputs.DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfig'] = None):
        """
        :param 'DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgs' digital_parsing_config: Configurations applied to digital parser.
        :param 'DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgs' layout_parsing_config: Configurations applied to layout parser.
               Structure is documented below.
        :param 'DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgs' ocr_parsing_config: Configurations applied to OCR parser. Currently it only applies to PDFs.
               Structure is documented below.
        """
        if digital_parsing_config is not None:
            pulumi.set(__self__, "digital_parsing_config", digital_parsing_config)
        if layout_parsing_config is not None:
            pulumi.set(__self__, "layout_parsing_config", layout_parsing_config)
        if ocr_parsing_config is not None:
            pulumi.set(__self__, "ocr_parsing_config", ocr_parsing_config)

    @_builtins.property
    @pulumi.getter(name="digitalParsingConfig")
    def digital_parsing_config(self) -> Optional['outputs.DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfig']:
        """
        Configurations applied to digital parser.
        """
        return pulumi.get(self, "digital_parsing_config")

    @_builtins.property
    @pulumi.getter(name="layoutParsingConfig")
    def layout_parsing_config(self) -> Optional['outputs.DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfig']:
        """
        Configurations applied to layout parser.
        Structure is documented below.
        """
        return pulumi.get(self, "layout_parsing_config")

    @_builtins.property
    @pulumi.getter(name="ocrParsingConfig")
    def ocr_parsing_config(self) -> Optional['outputs.DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfig']:
        """
        Configurations applied to OCR parser. Currently it only applies to PDFs.
        Structure is documented below.
        """
        return pulumi.get(self, "ocr_parsing_config")


@pulumi.output_type
class DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableImageAnnotation":
            suggest = "enable_image_annotation"
        elif key == "enableTableAnnotation":
            suggest = "enable_table_annotation"
        elif key == "excludeHtmlClasses":
            suggest = "exclude_html_classes"
        elif key == "excludeHtmlElements":
            suggest = "exclude_html_elements"
        elif key == "excludeHtmlIds":
            suggest = "exclude_html_ids"
        elif key == "structuredContentTypes":
            suggest = "structured_content_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_image_annotation: Optional[_builtins.bool] = None,
                 enable_table_annotation: Optional[_builtins.bool] = None,
                 exclude_html_classes: Optional[Sequence[_builtins.str]] = None,
                 exclude_html_elements: Optional[Sequence[_builtins.str]] = None,
                 exclude_html_ids: Optional[Sequence[_builtins.str]] = None,
                 structured_content_types: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool enable_image_annotation: If true, the LLM based annotation is added to the image during parsing.
        :param _builtins.bool enable_table_annotation: If true, the LLM based annotation is added to the table during parsing.
        :param Sequence[_builtins.str] exclude_html_classes: List of HTML classes to exclude from the parsed content.
        :param Sequence[_builtins.str] exclude_html_elements: List of HTML elements to exclude from the parsed content.
        :param Sequence[_builtins.str] exclude_html_ids: List of HTML ids to exclude from the parsed content.
        :param Sequence[_builtins.str] structured_content_types: Contains the required structure types to extract from the document. Supported values: `shareholder-structure`.
        """
        if enable_image_annotation is not None:
            pulumi.set(__self__, "enable_image_annotation", enable_image_annotation)
        if enable_table_annotation is not None:
            pulumi.set(__self__, "enable_table_annotation", enable_table_annotation)
        if exclude_html_classes is not None:
            pulumi.set(__self__, "exclude_html_classes", exclude_html_classes)
        if exclude_html_elements is not None:
            pulumi.set(__self__, "exclude_html_elements", exclude_html_elements)
        if exclude_html_ids is not None:
            pulumi.set(__self__, "exclude_html_ids", exclude_html_ids)
        if structured_content_types is not None:
            pulumi.set(__self__, "structured_content_types", structured_content_types)

    @_builtins.property
    @pulumi.getter(name="enableImageAnnotation")
    def enable_image_annotation(self) -> Optional[_builtins.bool]:
        """
        If true, the LLM based annotation is added to the image during parsing.
        """
        return pulumi.get(self, "enable_image_annotation")

    @_builtins.property
    @pulumi.getter(name="enableTableAnnotation")
    def enable_table_annotation(self) -> Optional[_builtins.bool]:
        """
        If true, the LLM based annotation is added to the table during parsing.
        """
        return pulumi.get(self, "enable_table_annotation")

    @_builtins.property
    @pulumi.getter(name="excludeHtmlClasses")
    def exclude_html_classes(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of HTML classes to exclude from the parsed content.
        """
        return pulumi.get(self, "exclude_html_classes")

    @_builtins.property
    @pulumi.getter(name="excludeHtmlElements")
    def exclude_html_elements(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of HTML elements to exclude from the parsed content.
        """
        return pulumi.get(self, "exclude_html_elements")

    @_builtins.property
    @pulumi.getter(name="excludeHtmlIds")
    def exclude_html_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of HTML ids to exclude from the parsed content.
        """
        return pulumi.get(self, "exclude_html_ids")

    @_builtins.property
    @pulumi.getter(name="structuredContentTypes")
    def structured_content_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        Contains the required structure types to extract from the document. Supported values: `shareholder-structure`.
        """
        return pulumi.get(self, "structured_content_types")


@pulumi.output_type
class DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useNativeText":
            suggest = "use_native_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 use_native_text: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool use_native_text: If true, will use native text instead of OCR text on pages containing native text.
        """
        if use_native_text is not None:
            pulumi.set(__self__, "use_native_text", use_native_text)

    @_builtins.property
    @pulumi.getter(name="useNativeText")
    def use_native_text(self) -> Optional[_builtins.bool]:
        """
        If true, will use native text instead of OCR text on pages containing native text.
        """
        return pulumi.get(self, "use_native_text")


@pulumi.output_type
class DataStoreDocumentProcessingConfigParsingConfigOverride(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileType":
            suggest = "file_type"
        elif key == "digitalParsingConfig":
            suggest = "digital_parsing_config"
        elif key == "layoutParsingConfig":
            suggest = "layout_parsing_config"
        elif key == "ocrParsingConfig":
            suggest = "ocr_parsing_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataStoreDocumentProcessingConfigParsingConfigOverride. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataStoreDocumentProcessingConfigParsingConfigOverride.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataStoreDocumentProcessingConfigParsingConfigOverride.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_type: _builtins.str,
                 digital_parsing_config: Optional['outputs.DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfig'] = None,
                 layout_parsing_config: Optional['outputs.DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfig'] = None,
                 ocr_parsing_config: Optional['outputs.DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfig'] = None):
        """
        :param _builtins.str file_type: The identifier for this object. Format specified above.
        :param 'DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgs' digital_parsing_config: Configurations applied to digital parser.
        :param 'DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgs' layout_parsing_config: Configurations applied to layout parser.
               Structure is documented below.
        :param 'DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgs' ocr_parsing_config: Configurations applied to OCR parser. Currently it only applies to PDFs.
               Structure is documented below.
        """
        pulumi.set(__self__, "file_type", file_type)
        if digital_parsing_config is not None:
            pulumi.set(__self__, "digital_parsing_config", digital_parsing_config)
        if layout_parsing_config is not None:
            pulumi.set(__self__, "layout_parsing_config", layout_parsing_config)
        if ocr_parsing_config is not None:
            pulumi.set(__self__, "ocr_parsing_config", ocr_parsing_config)

    @_builtins.property
    @pulumi.getter(name="fileType")
    def file_type(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "file_type")

    @_builtins.property
    @pulumi.getter(name="digitalParsingConfig")
    def digital_parsing_config(self) -> Optional['outputs.DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfig']:
        """
        Configurations applied to digital parser.
        """
        return pulumi.get(self, "digital_parsing_config")

    @_builtins.property
    @pulumi.getter(name="layoutParsingConfig")
    def layout_parsing_config(self) -> Optional['outputs.DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfig']:
        """
        Configurations applied to layout parser.
        Structure is documented below.
        """
        return pulumi.get(self, "layout_parsing_config")

    @_builtins.property
    @pulumi.getter(name="ocrParsingConfig")
    def ocr_parsing_config(self) -> Optional['outputs.DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfig']:
        """
        Configurations applied to OCR parser. Currently it only applies to PDFs.
        Structure is documented below.
        """
        return pulumi.get(self, "ocr_parsing_config")


@pulumi.output_type
class DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfig(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "enableImageAnnotation":
            suggest = "enable_image_annotation"
        elif key == "enableTableAnnotation":
            suggest = "enable_table_annotation"
        elif key == "excludeHtmlClasses":
            suggest = "exclude_html_classes"
        elif key == "excludeHtmlElements":
            suggest = "exclude_html_elements"
        elif key == "excludeHtmlIds":
            suggest = "exclude_html_ids"
        elif key == "structuredContentTypes":
            suggest = "structured_content_types"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 enable_image_annotation: Optional[_builtins.bool] = None,
                 enable_table_annotation: Optional[_builtins.bool] = None,
                 exclude_html_classes: Optional[Sequence[_builtins.str]] = None,
                 exclude_html_elements: Optional[Sequence[_builtins.str]] = None,
                 exclude_html_ids: Optional[Sequence[_builtins.str]] = None,
                 structured_content_types: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.bool enable_image_annotation: If true, the LLM based annotation is added to the image during parsing.
        :param _builtins.bool enable_table_annotation: If true, the LLM based annotation is added to the table during parsing.
        :param Sequence[_builtins.str] exclude_html_classes: List of HTML classes to exclude from the parsed content.
        :param Sequence[_builtins.str] exclude_html_elements: List of HTML elements to exclude from the parsed content.
        :param Sequence[_builtins.str] exclude_html_ids: List of HTML ids to exclude from the parsed content.
        :param Sequence[_builtins.str] structured_content_types: Contains the required structure types to extract from the document. Supported values: `shareholder-structure`.
        """
        if enable_image_annotation is not None:
            pulumi.set(__self__, "enable_image_annotation", enable_image_annotation)
        if enable_table_annotation is not None:
            pulumi.set(__self__, "enable_table_annotation", enable_table_annotation)
        if exclude_html_classes is not None:
            pulumi.set(__self__, "exclude_html_classes", exclude_html_classes)
        if exclude_html_elements is not None:
            pulumi.set(__self__, "exclude_html_elements", exclude_html_elements)
        if exclude_html_ids is not None:
            pulumi.set(__self__, "exclude_html_ids", exclude_html_ids)
        if structured_content_types is not None:
            pulumi.set(__self__, "structured_content_types", structured_content_types)

    @_builtins.property
    @pulumi.getter(name="enableImageAnnotation")
    def enable_image_annotation(self) -> Optional[_builtins.bool]:
        """
        If true, the LLM based annotation is added to the image during parsing.
        """
        return pulumi.get(self, "enable_image_annotation")

    @_builtins.property
    @pulumi.getter(name="enableTableAnnotation")
    def enable_table_annotation(self) -> Optional[_builtins.bool]:
        """
        If true, the LLM based annotation is added to the table during parsing.
        """
        return pulumi.get(self, "enable_table_annotation")

    @_builtins.property
    @pulumi.getter(name="excludeHtmlClasses")
    def exclude_html_classes(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of HTML classes to exclude from the parsed content.
        """
        return pulumi.get(self, "exclude_html_classes")

    @_builtins.property
    @pulumi.getter(name="excludeHtmlElements")
    def exclude_html_elements(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of HTML elements to exclude from the parsed content.
        """
        return pulumi.get(self, "exclude_html_elements")

    @_builtins.property
    @pulumi.getter(name="excludeHtmlIds")
    def exclude_html_ids(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of HTML ids to exclude from the parsed content.
        """
        return pulumi.get(self, "exclude_html_ids")

    @_builtins.property
    @pulumi.getter(name="structuredContentTypes")
    def structured_content_types(self) -> Optional[Sequence[_builtins.str]]:
        """
        Contains the required structure types to extract from the document. Supported values: `shareholder-structure`.
        """
        return pulumi.get(self, "structured_content_types")


@pulumi.output_type
class DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "useNativeText":
            suggest = "use_native_text"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 use_native_text: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool use_native_text: If true, will use native text instead of OCR text on pages containing native text.
        """
        if use_native_text is not None:
            pulumi.set(__self__, "use_native_text", use_native_text)

    @_builtins.property
    @pulumi.getter(name="useNativeText")
    def use_native_text(self) -> Optional[_builtins.bool]:
        """
        If true, will use native text instead of OCR text on pages containing native text.
        """
        return pulumi.get(self, "use_native_text")


@pulumi.output_type
class LicenseConfigEndDate(dict):
    def __init__(__self__, *,
                 day: Optional[_builtins.int] = None,
                 month: Optional[_builtins.int] = None,
                 year: Optional[_builtins.int] = None):
        """
        :param _builtins.int day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
        :param _builtins.int month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param _builtins.int year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @_builtins.property
    @pulumi.getter
    def day(self) -> Optional[_builtins.int]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def month(self) -> Optional[_builtins.int]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @_builtins.property
    @pulumi.getter
    def year(self) -> Optional[_builtins.int]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")


@pulumi.output_type
class LicenseConfigStartDate(dict):
    def __init__(__self__, *,
                 day: Optional[_builtins.int] = None,
                 month: Optional[_builtins.int] = None,
                 year: Optional[_builtins.int] = None):
        """
        :param _builtins.int day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
        :param _builtins.int month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param _builtins.int year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @_builtins.property
    @pulumi.getter
    def day(self) -> Optional[_builtins.int]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
        """
        return pulumi.get(self, "day")

    @_builtins.property
    @pulumi.getter
    def month(self) -> Optional[_builtins.int]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @_builtins.property
    @pulumi.getter
    def year(self) -> Optional[_builtins.int]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")


@pulumi.output_type
class RecommendationEngineCommonConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "companyName":
            suggest = "company_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecommendationEngineCommonConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecommendationEngineCommonConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecommendationEngineCommonConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 company_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str company_name: The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.cd
        """
        if company_name is not None:
            pulumi.set(__self__, "company_name", company_name)

    @_builtins.property
    @pulumi.getter(name="companyName")
    def company_name(self) -> Optional[_builtins.str]:
        """
        The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.cd
        """
        return pulumi.get(self, "company_name")


@pulumi.output_type
class RecommendationEngineMediaRecommendationEngineConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "engineFeaturesConfig":
            suggest = "engine_features_config"
        elif key == "optimizationObjective":
            suggest = "optimization_objective"
        elif key == "optimizationObjectiveConfig":
            suggest = "optimization_objective_config"
        elif key == "trainingState":
            suggest = "training_state"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecommendationEngineMediaRecommendationEngineConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecommendationEngineMediaRecommendationEngineConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecommendationEngineMediaRecommendationEngineConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 engine_features_config: Optional['outputs.RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfig'] = None,
                 optimization_objective: Optional[_builtins.str] = None,
                 optimization_objective_config: Optional['outputs.RecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfig'] = None,
                 training_state: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param 'RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigArgs' engine_features_config: More feature configs of the selected engine type.
               Structure is documented below.
        :param _builtins.str optimization_objective: The optimization objective. e.g., `cvr`.
               This field together with MediaRecommendationEngineConfig.type describes
               engine metadata to use to control engine training and serving.
               Currently supported values: `ctr`, `cvr`.
               If not specified, we choose default based on engine type. Default depends on type of recommendation:
               `recommended-for-you` => `ctr`
               `others-you-may-like` => `ctr`
        :param 'RecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfigArgs' optimization_objective_config: Name and value of the custom threshold for cvr optimization_objective.
               For target_field `watch-time`, target_field_value must be an integer
               value indicating the media progress time in seconds between (0, 86400]
               (excludes 0, includes 86400) (e.g., 90).
               For target_field `watch-percentage`, the target_field_value must be a
               valid float value between (0, 1.0] (excludes 0, includes 1.0) (e.g., 0.5).
               Structure is documented below.
        :param _builtins.str training_state: The training state that the engine is in (e.g. `TRAINING` or `PAUSED`).
               Since part of the cost of running the service
               is frequency of training - this can be used to determine when to train
               engine in order to control cost. If not specified: the default value for
               `CreateEngine` method is `TRAINING`. The default value for
               `UpdateEngine` method is to keep the state the same as before.
               Possible values are: `PAUSED`, `TRAINING`.
        :param _builtins.str type: The type of engine. e.g., `recommended-for-you`.
               This field together with MediaRecommendationEngineConfig.optimizationObjective describes
               engine metadata to use to control engine training and serving.
               Currently supported values: `recommended-for-you`, `others-you-may-like`,
               `more-like-this`, `most-popular-items`.
        """
        if engine_features_config is not None:
            pulumi.set(__self__, "engine_features_config", engine_features_config)
        if optimization_objective is not None:
            pulumi.set(__self__, "optimization_objective", optimization_objective)
        if optimization_objective_config is not None:
            pulumi.set(__self__, "optimization_objective_config", optimization_objective_config)
        if training_state is not None:
            pulumi.set(__self__, "training_state", training_state)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="engineFeaturesConfig")
    def engine_features_config(self) -> Optional['outputs.RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfig']:
        """
        More feature configs of the selected engine type.
        Structure is documented below.
        """
        return pulumi.get(self, "engine_features_config")

    @_builtins.property
    @pulumi.getter(name="optimizationObjective")
    def optimization_objective(self) -> Optional[_builtins.str]:
        """
        The optimization objective. e.g., `cvr`.
        This field together with MediaRecommendationEngineConfig.type describes
        engine metadata to use to control engine training and serving.
        Currently supported values: `ctr`, `cvr`.
        If not specified, we choose default based on engine type. Default depends on type of recommendation:
        `recommended-for-you` => `ctr`
        `others-you-may-like` => `ctr`
        """
        return pulumi.get(self, "optimization_objective")

    @_builtins.property
    @pulumi.getter(name="optimizationObjectiveConfig")
    def optimization_objective_config(self) -> Optional['outputs.RecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfig']:
        """
        Name and value of the custom threshold for cvr optimization_objective.
        For target_field `watch-time`, target_field_value must be an integer
        value indicating the media progress time in seconds between (0, 86400]
        (excludes 0, includes 86400) (e.g., 90).
        For target_field `watch-percentage`, the target_field_value must be a
        valid float value between (0, 1.0] (excludes 0, includes 1.0) (e.g., 0.5).
        Structure is documented below.
        """
        return pulumi.get(self, "optimization_objective_config")

    @_builtins.property
    @pulumi.getter(name="trainingState")
    def training_state(self) -> Optional[_builtins.str]:
        """
        The training state that the engine is in (e.g. `TRAINING` or `PAUSED`).
        Since part of the cost of running the service
        is frequency of training - this can be used to determine when to train
        engine in order to control cost. If not specified: the default value for
        `CreateEngine` method is `TRAINING`. The default value for
        `UpdateEngine` method is to keep the state the same as before.
        Possible values are: `PAUSED`, `TRAINING`.
        """
        return pulumi.get(self, "training_state")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        The type of engine. e.g., `recommended-for-you`.
        This field together with MediaRecommendationEngineConfig.optimizationObjective describes
        engine metadata to use to control engine training and serving.
        Currently supported values: `recommended-for-you`, `others-you-may-like`,
        `more-like-this`, `most-popular-items`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mostPopularConfig":
            suggest = "most_popular_config"
        elif key == "recommendedForYouConfig":
            suggest = "recommended_for_you_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 most_popular_config: Optional['outputs.RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfig'] = None,
                 recommended_for_you_config: Optional['outputs.RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfig'] = None):
        """
        :param 'RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfigArgs' most_popular_config: Feature configurations that are required for creating a Most Popular engine.
               Structure is documented below.
        :param 'RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfigArgs' recommended_for_you_config: Additional feature configurations for creating a `recommended-for-you` engine.
               Structure is documented below.
        """
        if most_popular_config is not None:
            pulumi.set(__self__, "most_popular_config", most_popular_config)
        if recommended_for_you_config is not None:
            pulumi.set(__self__, "recommended_for_you_config", recommended_for_you_config)

    @_builtins.property
    @pulumi.getter(name="mostPopularConfig")
    def most_popular_config(self) -> Optional['outputs.RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfig']:
        """
        Feature configurations that are required for creating a Most Popular engine.
        Structure is documented below.
        """
        return pulumi.get(self, "most_popular_config")

    @_builtins.property
    @pulumi.getter(name="recommendedForYouConfig")
    def recommended_for_you_config(self) -> Optional['outputs.RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfig']:
        """
        Additional feature configurations for creating a `recommended-for-you` engine.
        Structure is documented below.
        """
        return pulumi.get(self, "recommended_for_you_config")


@pulumi.output_type
class RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "timeWindowDays":
            suggest = "time_window_days"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 time_window_days: Optional[_builtins.int] = None):
        """
        :param _builtins.int time_window_days: The time window of which the engine is queried at training and
               prediction time. Positive integers only. The value translates to the
               last X days of events. Currently required for the `most-popular-items`
               engine.
        """
        if time_window_days is not None:
            pulumi.set(__self__, "time_window_days", time_window_days)

    @_builtins.property
    @pulumi.getter(name="timeWindowDays")
    def time_window_days(self) -> Optional[_builtins.int]:
        """
        The time window of which the engine is queried at training and
        prediction time. Positive integers only. The value translates to the
        last X days of events. Currently required for the `most-popular-items`
        engine.
        """
        return pulumi.get(self, "time_window_days")


@pulumi.output_type
class RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "contextEventType":
            suggest = "context_event_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 context_event_type: Optional[_builtins.str] = None):
        """
        :param _builtins.str context_event_type: The type of event with which the engine is queried at prediction time.
               If set to `generic`, only `view-item`, `media-play`,and
               `media-complete` will be used as `context-event` in engine training. If
               set to `view-home-page`, `view-home-page` will also be used as
               `context-events` in addition to `view-item`, `media-play`, and
               `media-complete`. Currently supported for the `recommended-for-you`
               engine. Currently supported values: `view-home-page`, `generic`.
        """
        if context_event_type is not None:
            pulumi.set(__self__, "context_event_type", context_event_type)

    @_builtins.property
    @pulumi.getter(name="contextEventType")
    def context_event_type(self) -> Optional[_builtins.str]:
        """
        The type of event with which the engine is queried at prediction time.
        If set to `generic`, only `view-item`, `media-play`,and
        `media-complete` will be used as `context-event` in engine training. If
        set to `view-home-page`, `view-home-page` will also be used as
        `context-events` in addition to `view-item`, `media-play`, and
        `media-complete`. Currently supported for the `recommended-for-you`
        engine. Currently supported values: `view-home-page`, `generic`.
        """
        return pulumi.get(self, "context_event_type")


@pulumi.output_type
class RecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "targetField":
            suggest = "target_field"
        elif key == "targetFieldValueFloat":
            suggest = "target_field_value_float"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in RecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        RecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        RecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 target_field: Optional[_builtins.str] = None,
                 target_field_value_float: Optional[_builtins.float] = None):
        """
        :param _builtins.str target_field: The name of the field to target. Currently supported values: `watch-percentage`, `watch-time`.
        :param _builtins.float target_field_value_float: The threshold to be applied to the target (e.g., 0.5).
        """
        if target_field is not None:
            pulumi.set(__self__, "target_field", target_field)
        if target_field_value_float is not None:
            pulumi.set(__self__, "target_field_value_float", target_field_value_float)

    @_builtins.property
    @pulumi.getter(name="targetField")
    def target_field(self) -> Optional[_builtins.str]:
        """
        The name of the field to target. Currently supported values: `watch-percentage`, `watch-time`.
        """
        return pulumi.get(self, "target_field")

    @_builtins.property
    @pulumi.getter(name="targetFieldValueFloat")
    def target_field_value_float(self) -> Optional[_builtins.float]:
        """
        The threshold to be applied to the target (e.g., 0.5).
        """
        return pulumi.get(self, "target_field_value_float")


@pulumi.output_type
class SearchEngineCommonConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "companyName":
            suggest = "company_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SearchEngineCommonConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SearchEngineCommonConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SearchEngineCommonConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 company_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str company_name: The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.cd
        """
        if company_name is not None:
            pulumi.set(__self__, "company_name", company_name)

    @_builtins.property
    @pulumi.getter(name="companyName")
    def company_name(self) -> Optional[_builtins.str]:
        """
        The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.cd
        """
        return pulumi.get(self, "company_name")


@pulumi.output_type
class SearchEngineSearchEngineConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "searchAddOns":
            suggest = "search_add_ons"
        elif key == "searchTier":
            suggest = "search_tier"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SearchEngineSearchEngineConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SearchEngineSearchEngineConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SearchEngineSearchEngineConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 search_add_ons: Optional[Sequence[_builtins.str]] = None,
                 search_tier: Optional[_builtins.str] = None):
        """
        :param Sequence[_builtins.str] search_add_ons: The add-on that this search engine enables.
               Each value may be one of: `SEARCH_ADD_ON_LLM`.
        :param _builtins.str search_tier: The search feature tier of this engine. Defaults to SearchTier.SEARCH_TIER_STANDARD if not specified.
               Default value is `SEARCH_TIER_STANDARD`.
               Possible values are: `SEARCH_TIER_STANDARD`, `SEARCH_TIER_ENTERPRISE`.
        """
        if search_add_ons is not None:
            pulumi.set(__self__, "search_add_ons", search_add_ons)
        if search_tier is not None:
            pulumi.set(__self__, "search_tier", search_tier)

    @_builtins.property
    @pulumi.getter(name="searchAddOns")
    def search_add_ons(self) -> Optional[Sequence[_builtins.str]]:
        """
        The add-on that this search engine enables.
        Each value may be one of: `SEARCH_ADD_ON_LLM`.
        """
        return pulumi.get(self, "search_add_ons")

    @_builtins.property
    @pulumi.getter(name="searchTier")
    def search_tier(self) -> Optional[_builtins.str]:
        """
        The search feature tier of this engine. Defaults to SearchTier.SEARCH_TIER_STANDARD if not specified.
        Default value is `SEARCH_TIER_STANDARD`.
        Possible values are: `SEARCH_TIER_STANDARD`, `SEARCH_TIER_ENTERPRISE`.
        """
        return pulumi.get(self, "search_tier")


@pulumi.output_type
class TargetSiteFailureReason(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "quotaFailure":
            suggest = "quota_failure"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetSiteFailureReason. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetSiteFailureReason.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetSiteFailureReason.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 quota_failure: Optional['outputs.TargetSiteFailureReasonQuotaFailure'] = None):
        """
        :param 'TargetSiteFailureReasonQuotaFailureArgs' quota_failure: Site verification state indicating the ownership and validity.
               Structure is documented below.
        """
        if quota_failure is not None:
            pulumi.set(__self__, "quota_failure", quota_failure)

    @_builtins.property
    @pulumi.getter(name="quotaFailure")
    def quota_failure(self) -> Optional['outputs.TargetSiteFailureReasonQuotaFailure']:
        """
        Site verification state indicating the ownership and validity.
        Structure is documented below.
        """
        return pulumi.get(self, "quota_failure")


@pulumi.output_type
class TargetSiteFailureReasonQuotaFailure(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "totalRequiredQuota":
            suggest = "total_required_quota"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetSiteFailureReasonQuotaFailure. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetSiteFailureReasonQuotaFailure.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetSiteFailureReasonQuotaFailure.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 total_required_quota: Optional[_builtins.int] = None):
        """
        :param _builtins.int total_required_quota: This number is an estimation on how much total quota this project
               needs to successfully complete indexing.
        """
        if total_required_quota is not None:
            pulumi.set(__self__, "total_required_quota", total_required_quota)

    @_builtins.property
    @pulumi.getter(name="totalRequiredQuota")
    def total_required_quota(self) -> Optional[_builtins.int]:
        """
        This number is an estimation on how much total quota this project
        needs to successfully complete indexing.
        """
        return pulumi.get(self, "total_required_quota")


@pulumi.output_type
class TargetSiteSiteVerificationInfo(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "siteVerificationState":
            suggest = "site_verification_state"
        elif key == "verifyTime":
            suggest = "verify_time"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in TargetSiteSiteVerificationInfo. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        TargetSiteSiteVerificationInfo.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        TargetSiteSiteVerificationInfo.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 site_verification_state: Optional[_builtins.str] = None,
                 verify_time: Optional[_builtins.str] = None):
        """
        :param _builtins.str site_verification_state: Site verification state indicating the ownership and validity.
               Possible values are: `VERIFIED`, `UNVERIFIED`, `EXEMPTED`.
        :param _builtins.str verify_time: Latest site verification time.
        """
        if site_verification_state is not None:
            pulumi.set(__self__, "site_verification_state", site_verification_state)
        if verify_time is not None:
            pulumi.set(__self__, "verify_time", verify_time)

    @_builtins.property
    @pulumi.getter(name="siteVerificationState")
    def site_verification_state(self) -> Optional[_builtins.str]:
        """
        Site verification state indicating the ownership and validity.
        Possible values are: `VERIFIED`, `UNVERIFIED`, `EXEMPTED`.
        """
        return pulumi.get(self, "site_verification_state")

    @_builtins.property
    @pulumi.getter(name="verifyTime")
    def verify_time(self) -> Optional[_builtins.str]:
        """
        Latest site verification time.
        """
        return pulumi.get(self, "verify_time")


@pulumi.output_type
class WidgetConfigAccessSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowPublicAccess":
            suggest = "allow_public_access"
        elif key == "allowlistedDomains":
            suggest = "allowlisted_domains"
        elif key == "enableWebApp":
            suggest = "enable_web_app"
        elif key == "languageCode":
            suggest = "language_code"
        elif key == "workforceIdentityPoolProvider":
            suggest = "workforce_identity_pool_provider"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WidgetConfigAccessSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WidgetConfigAccessSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WidgetConfigAccessSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_public_access: Optional[_builtins.bool] = None,
                 allowlisted_domains: Optional[Sequence[_builtins.str]] = None,
                 enable_web_app: Optional[_builtins.bool] = None,
                 language_code: Optional[_builtins.str] = None,
                 workforce_identity_pool_provider: Optional[_builtins.str] = None):
        """
        :param _builtins.bool allow_public_access: Whether public unauthenticated access is allowed.
        :param Sequence[_builtins.str] allowlisted_domains: List of domains that are allowed to integrate the search widget.
        :param _builtins.bool enable_web_app: Whether web app access is enabled.
        :param _builtins.str language_code: Language code for user interface. Use language tags defined by
               [BCP47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). If unset, the
               default language code is "en-US".
        :param _builtins.str workforce_identity_pool_provider: The workforce identity pool provider used to access the widget.
        """
        if allow_public_access is not None:
            pulumi.set(__self__, "allow_public_access", allow_public_access)
        if allowlisted_domains is not None:
            pulumi.set(__self__, "allowlisted_domains", allowlisted_domains)
        if enable_web_app is not None:
            pulumi.set(__self__, "enable_web_app", enable_web_app)
        if language_code is not None:
            pulumi.set(__self__, "language_code", language_code)
        if workforce_identity_pool_provider is not None:
            pulumi.set(__self__, "workforce_identity_pool_provider", workforce_identity_pool_provider)

    @_builtins.property
    @pulumi.getter(name="allowPublicAccess")
    def allow_public_access(self) -> Optional[_builtins.bool]:
        """
        Whether public unauthenticated access is allowed.
        """
        return pulumi.get(self, "allow_public_access")

    @_builtins.property
    @pulumi.getter(name="allowlistedDomains")
    def allowlisted_domains(self) -> Optional[Sequence[_builtins.str]]:
        """
        List of domains that are allowed to integrate the search widget.
        """
        return pulumi.get(self, "allowlisted_domains")

    @_builtins.property
    @pulumi.getter(name="enableWebApp")
    def enable_web_app(self) -> Optional[_builtins.bool]:
        """
        Whether web app access is enabled.
        """
        return pulumi.get(self, "enable_web_app")

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[_builtins.str]:
        """
        Language code for user interface. Use language tags defined by
        [BCP47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). If unset, the
        default language code is "en-US".
        """
        return pulumi.get(self, "language_code")

    @_builtins.property
    @pulumi.getter(name="workforceIdentityPoolProvider")
    def workforce_identity_pool_provider(self) -> Optional[_builtins.str]:
        """
        The workforce identity pool provider used to access the widget.
        """
        return pulumi.get(self, "workforce_identity_pool_provider")


@pulumi.output_type
class WidgetConfigHomepageSetting(dict):
    def __init__(__self__, *,
                 shortcuts: Optional[Sequence['outputs.WidgetConfigHomepageSettingShortcut']] = None):
        """
        :param Sequence['WidgetConfigHomepageSettingShortcutArgs'] shortcuts: The shortcuts to display on the homepage.
               Structure is documented below.
        """
        if shortcuts is not None:
            pulumi.set(__self__, "shortcuts", shortcuts)

    @_builtins.property
    @pulumi.getter
    def shortcuts(self) -> Optional[Sequence['outputs.WidgetConfigHomepageSettingShortcut']]:
        """
        The shortcuts to display on the homepage.
        Structure is documented below.
        """
        return pulumi.get(self, "shortcuts")


@pulumi.output_type
class WidgetConfigHomepageSettingShortcut(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationUri":
            suggest = "destination_uri"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WidgetConfigHomepageSettingShortcut. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WidgetConfigHomepageSettingShortcut.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WidgetConfigHomepageSettingShortcut.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_uri: Optional[_builtins.str] = None,
                 icon: Optional['outputs.WidgetConfigHomepageSettingShortcutIcon'] = None,
                 title: Optional[_builtins.str] = None):
        """
        :param _builtins.str destination_uri: Destination URL of shortcut.
        :param 'WidgetConfigHomepageSettingShortcutIconArgs' icon: Icon URL of shortcut.
               Structure is documented below.
        :param _builtins.str title: Title of the shortcut.
        """
        if destination_uri is not None:
            pulumi.set(__self__, "destination_uri", destination_uri)
        if icon is not None:
            pulumi.set(__self__, "icon", icon)
        if title is not None:
            pulumi.set(__self__, "title", title)

    @_builtins.property
    @pulumi.getter(name="destinationUri")
    def destination_uri(self) -> Optional[_builtins.str]:
        """
        Destination URL of shortcut.
        """
        return pulumi.get(self, "destination_uri")

    @_builtins.property
    @pulumi.getter
    def icon(self) -> Optional['outputs.WidgetConfigHomepageSettingShortcutIcon']:
        """
        Icon URL of shortcut.
        Structure is documented below.
        """
        return pulumi.get(self, "icon")

    @_builtins.property
    @pulumi.getter
    def title(self) -> Optional[_builtins.str]:
        """
        Title of the shortcut.
        """
        return pulumi.get(self, "title")


@pulumi.output_type
class WidgetConfigHomepageSettingShortcutIcon(dict):
    def __init__(__self__, *,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: Image URL.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Image URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class WidgetConfigUiBranding(dict):
    def __init__(__self__, *,
                 logo: Optional['outputs.WidgetConfigUiBrandingLogo'] = None):
        """
        :param 'WidgetConfigUiBrandingLogoArgs' logo: Logo image.
               Structure is documented below.
        """
        if logo is not None:
            pulumi.set(__self__, "logo", logo)

    @_builtins.property
    @pulumi.getter
    def logo(self) -> Optional['outputs.WidgetConfigUiBrandingLogo']:
        """
        Logo image.
        Structure is documented below.
        """
        return pulumi.get(self, "logo")


@pulumi.output_type
class WidgetConfigUiBrandingLogo(dict):
    def __init__(__self__, *,
                 url: Optional[_builtins.str] = None):
        """
        :param _builtins.str url: Image URL.
        """
        if url is not None:
            pulumi.set(__self__, "url", url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> Optional[_builtins.str]:
        """
        Image URL.
        """
        return pulumi.get(self, "url")


@pulumi.output_type
class WidgetConfigUiSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataStoreUiConfigs":
            suggest = "data_store_ui_configs"
        elif key == "defaultSearchRequestOrderBy":
            suggest = "default_search_request_order_by"
        elif key == "disableUserEventsCollection":
            suggest = "disable_user_events_collection"
        elif key == "enableAutocomplete":
            suggest = "enable_autocomplete"
        elif key == "enableCreateAgentButton":
            suggest = "enable_create_agent_button"
        elif key == "enablePeopleSearch":
            suggest = "enable_people_search"
        elif key == "enableQualityFeedback":
            suggest = "enable_quality_feedback"
        elif key == "enableSafeSearch":
            suggest = "enable_safe_search"
        elif key == "enableSearchAsYouType":
            suggest = "enable_search_as_you_type"
        elif key == "enableVisualContentSummary":
            suggest = "enable_visual_content_summary"
        elif key == "generativeAnswerConfig":
            suggest = "generative_answer_config"
        elif key == "interactionType":
            suggest = "interaction_type"
        elif key == "resultDescriptionType":
            suggest = "result_description_type"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WidgetConfigUiSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WidgetConfigUiSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WidgetConfigUiSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 data_store_ui_configs: Optional[Sequence['outputs.WidgetConfigUiSettingsDataStoreUiConfig']] = None,
                 default_search_request_order_by: Optional[_builtins.str] = None,
                 disable_user_events_collection: Optional[_builtins.bool] = None,
                 enable_autocomplete: Optional[_builtins.bool] = None,
                 enable_create_agent_button: Optional[_builtins.bool] = None,
                 enable_people_search: Optional[_builtins.bool] = None,
                 enable_quality_feedback: Optional[_builtins.bool] = None,
                 enable_safe_search: Optional[_builtins.bool] = None,
                 enable_search_as_you_type: Optional[_builtins.bool] = None,
                 enable_visual_content_summary: Optional[_builtins.bool] = None,
                 generative_answer_config: Optional['outputs.WidgetConfigUiSettingsGenerativeAnswerConfig'] = None,
                 interaction_type: Optional[_builtins.str] = None,
                 result_description_type: Optional[_builtins.str] = None):
        """
        :param Sequence['WidgetConfigUiSettingsDataStoreUiConfigArgs'] data_store_ui_configs: Per data store configuration.
               Structure is documented below.
        :param _builtins.str default_search_request_order_by: The default ordering for search results if specified.
               Used to set SearchRequest#orderBy on applicable requests.
        :param _builtins.bool disable_user_events_collection: If set to true, the widget will not collect user events.
        :param _builtins.bool enable_autocomplete: Whether or not to enable autocomplete.
        :param _builtins.bool enable_create_agent_button: If set to true, the widget will enable the create agent button.
        :param _builtins.bool enable_people_search: If set to true, the widget will enable people search.
        :param _builtins.bool enable_quality_feedback: Turn on or off collecting the search result quality feedback from end users.
        :param _builtins.bool enable_safe_search: Whether to enable safe search.
        :param _builtins.bool enable_search_as_you_type: Whether to enable search-as-you-type behavior for the search widget.
        :param _builtins.bool enable_visual_content_summary: If set to true, the widget will enable visual content summary on applicable
               search requests. Only used by healthcare search.
        :param 'WidgetConfigUiSettingsGenerativeAnswerConfigArgs' generative_answer_config: Describes generative answer configuration.
               Structure is documented below.
        :param _builtins.str interaction_type: Describes widget (or web app) interaction type
               Possible values are: `SEARCH_ONLY`, `SEARCH_WITH_ANSWER`, `SEARCH_WITH_FOLLOW_UPS`.
        :param _builtins.str result_description_type: Controls whether result extract is display and how (snippet or extractive answer).
               Default to no result if unspecified.
               Possible values are: `SNIPPET`, `EXTRACTIVE_ANSWER`.
        """
        if data_store_ui_configs is not None:
            pulumi.set(__self__, "data_store_ui_configs", data_store_ui_configs)
        if default_search_request_order_by is not None:
            pulumi.set(__self__, "default_search_request_order_by", default_search_request_order_by)
        if disable_user_events_collection is not None:
            pulumi.set(__self__, "disable_user_events_collection", disable_user_events_collection)
        if enable_autocomplete is not None:
            pulumi.set(__self__, "enable_autocomplete", enable_autocomplete)
        if enable_create_agent_button is not None:
            pulumi.set(__self__, "enable_create_agent_button", enable_create_agent_button)
        if enable_people_search is not None:
            pulumi.set(__self__, "enable_people_search", enable_people_search)
        if enable_quality_feedback is not None:
            pulumi.set(__self__, "enable_quality_feedback", enable_quality_feedback)
        if enable_safe_search is not None:
            pulumi.set(__self__, "enable_safe_search", enable_safe_search)
        if enable_search_as_you_type is not None:
            pulumi.set(__self__, "enable_search_as_you_type", enable_search_as_you_type)
        if enable_visual_content_summary is not None:
            pulumi.set(__self__, "enable_visual_content_summary", enable_visual_content_summary)
        if generative_answer_config is not None:
            pulumi.set(__self__, "generative_answer_config", generative_answer_config)
        if interaction_type is not None:
            pulumi.set(__self__, "interaction_type", interaction_type)
        if result_description_type is not None:
            pulumi.set(__self__, "result_description_type", result_description_type)

    @_builtins.property
    @pulumi.getter(name="dataStoreUiConfigs")
    def data_store_ui_configs(self) -> Optional[Sequence['outputs.WidgetConfigUiSettingsDataStoreUiConfig']]:
        """
        Per data store configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "data_store_ui_configs")

    @_builtins.property
    @pulumi.getter(name="defaultSearchRequestOrderBy")
    def default_search_request_order_by(self) -> Optional[_builtins.str]:
        """
        The default ordering for search results if specified.
        Used to set SearchRequest#orderBy on applicable requests.
        """
        return pulumi.get(self, "default_search_request_order_by")

    @_builtins.property
    @pulumi.getter(name="disableUserEventsCollection")
    def disable_user_events_collection(self) -> Optional[_builtins.bool]:
        """
        If set to true, the widget will not collect user events.
        """
        return pulumi.get(self, "disable_user_events_collection")

    @_builtins.property
    @pulumi.getter(name="enableAutocomplete")
    def enable_autocomplete(self) -> Optional[_builtins.bool]:
        """
        Whether or not to enable autocomplete.
        """
        return pulumi.get(self, "enable_autocomplete")

    @_builtins.property
    @pulumi.getter(name="enableCreateAgentButton")
    def enable_create_agent_button(self) -> Optional[_builtins.bool]:
        """
        If set to true, the widget will enable the create agent button.
        """
        return pulumi.get(self, "enable_create_agent_button")

    @_builtins.property
    @pulumi.getter(name="enablePeopleSearch")
    def enable_people_search(self) -> Optional[_builtins.bool]:
        """
        If set to true, the widget will enable people search.
        """
        return pulumi.get(self, "enable_people_search")

    @_builtins.property
    @pulumi.getter(name="enableQualityFeedback")
    def enable_quality_feedback(self) -> Optional[_builtins.bool]:
        """
        Turn on or off collecting the search result quality feedback from end users.
        """
        return pulumi.get(self, "enable_quality_feedback")

    @_builtins.property
    @pulumi.getter(name="enableSafeSearch")
    def enable_safe_search(self) -> Optional[_builtins.bool]:
        """
        Whether to enable safe search.
        """
        return pulumi.get(self, "enable_safe_search")

    @_builtins.property
    @pulumi.getter(name="enableSearchAsYouType")
    def enable_search_as_you_type(self) -> Optional[_builtins.bool]:
        """
        Whether to enable search-as-you-type behavior for the search widget.
        """
        return pulumi.get(self, "enable_search_as_you_type")

    @_builtins.property
    @pulumi.getter(name="enableVisualContentSummary")
    def enable_visual_content_summary(self) -> Optional[_builtins.bool]:
        """
        If set to true, the widget will enable visual content summary on applicable
        search requests. Only used by healthcare search.
        """
        return pulumi.get(self, "enable_visual_content_summary")

    @_builtins.property
    @pulumi.getter(name="generativeAnswerConfig")
    def generative_answer_config(self) -> Optional['outputs.WidgetConfigUiSettingsGenerativeAnswerConfig']:
        """
        Describes generative answer configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "generative_answer_config")

    @_builtins.property
    @pulumi.getter(name="interactionType")
    def interaction_type(self) -> Optional[_builtins.str]:
        """
        Describes widget (or web app) interaction type
        Possible values are: `SEARCH_ONLY`, `SEARCH_WITH_ANSWER`, `SEARCH_WITH_FOLLOW_UPS`.
        """
        return pulumi.get(self, "interaction_type")

    @_builtins.property
    @pulumi.getter(name="resultDescriptionType")
    def result_description_type(self) -> Optional[_builtins.str]:
        """
        Controls whether result extract is display and how (snippet or extractive answer).
        Default to no result if unspecified.
        Possible values are: `SNIPPET`, `EXTRACTIVE_ANSWER`.
        """
        return pulumi.get(self, "result_description_type")


@pulumi.output_type
class WidgetConfigUiSettingsDataStoreUiConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "facetFields":
            suggest = "facet_fields"
        elif key == "fieldsUiComponentsMaps":
            suggest = "fields_ui_components_maps"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WidgetConfigUiSettingsDataStoreUiConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WidgetConfigUiSettingsDataStoreUiConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WidgetConfigUiSettingsDataStoreUiConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 facet_fields: Optional[Sequence['outputs.WidgetConfigUiSettingsDataStoreUiConfigFacetField']] = None,
                 fields_ui_components_maps: Optional[Sequence['outputs.WidgetConfigUiSettingsDataStoreUiConfigFieldsUiComponentsMap']] = None,
                 name: Optional[_builtins.str] = None):
        """
        :param Sequence['WidgetConfigUiSettingsDataStoreUiConfigFacetFieldArgs'] facet_fields: Structure is documented below.
        :param Sequence['WidgetConfigUiSettingsDataStoreUiConfigFieldsUiComponentsMapArgs'] fields_ui_components_maps: 'The key is the UI component. Currently supported `title`, `thumbnail`,
               `url`, `custom1`, `custom2`, `custom3`. The value is the name of
               the field along with its device visibility. The 3 custom fields are optional
               and can be added or removed.
               `title`, `thumbnail`, `url` are required UI components that cannot be removed.
               Structure is documented below.
        :param _builtins.str name: The name of the data store. It should be data store resource name. Format:
               `projects/{project}/locations/{location}/collections/{collectionId}/dataStores/{dataStoreId}`.
               For APIs under `WidgetService`, such as [WidgetService.LookUpWidgetConfig][],
               the project number and location part is erased in this field.
        """
        if facet_fields is not None:
            pulumi.set(__self__, "facet_fields", facet_fields)
        if fields_ui_components_maps is not None:
            pulumi.set(__self__, "fields_ui_components_maps", fields_ui_components_maps)
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter(name="facetFields")
    def facet_fields(self) -> Optional[Sequence['outputs.WidgetConfigUiSettingsDataStoreUiConfigFacetField']]:
        """
        Structure is documented below.
        """
        return pulumi.get(self, "facet_fields")

    @_builtins.property
    @pulumi.getter(name="fieldsUiComponentsMaps")
    def fields_ui_components_maps(self) -> Optional[Sequence['outputs.WidgetConfigUiSettingsDataStoreUiConfigFieldsUiComponentsMap']]:
        """
        'The key is the UI component. Currently supported `title`, `thumbnail`,
        `url`, `custom1`, `custom2`, `custom3`. The value is the name of
        the field along with its device visibility. The 3 custom fields are optional
        and can be added or removed.
        `title`, `thumbnail`, `url` are required UI components that cannot be removed.
        Structure is documented below.
        """
        return pulumi.get(self, "fields_ui_components_maps")

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        The name of the data store. It should be data store resource name. Format:
        `projects/{project}/locations/{location}/collections/{collectionId}/dataStores/{dataStoreId}`.
        For APIs under `WidgetService`, such as [WidgetService.LookUpWidgetConfig][],
        the project number and location part is erased in this field.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class WidgetConfigUiSettingsDataStoreUiConfigFacetField(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "displayName":
            suggest = "display_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WidgetConfigUiSettingsDataStoreUiConfigFacetField. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WidgetConfigUiSettingsDataStoreUiConfigFacetField.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WidgetConfigUiSettingsDataStoreUiConfigFacetField.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: _builtins.str,
                 display_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str field: Registered field name. The format is `field.abc`.
        :param _builtins.str display_name: The field name that end users will see.
        """
        pulumi.set(__self__, "field", field)
        if display_name is not None:
            pulumi.set(__self__, "display_name", display_name)

    @_builtins.property
    @pulumi.getter
    def field(self) -> _builtins.str:
        """
        Registered field name. The format is `field.abc`.
        """
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter(name="displayName")
    def display_name(self) -> Optional[_builtins.str]:
        """
        The field name that end users will see.
        """
        return pulumi.get(self, "display_name")


@pulumi.output_type
class WidgetConfigUiSettingsDataStoreUiConfigFieldsUiComponentsMap(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "uiComponent":
            suggest = "ui_component"
        elif key == "deviceVisibilities":
            suggest = "device_visibilities"
        elif key == "displayTemplate":
            suggest = "display_template"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WidgetConfigUiSettingsDataStoreUiConfigFieldsUiComponentsMap. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WidgetConfigUiSettingsDataStoreUiConfigFieldsUiComponentsMap.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WidgetConfigUiSettingsDataStoreUiConfigFieldsUiComponentsMap.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 field: _builtins.str,
                 ui_component: _builtins.str,
                 device_visibilities: Optional[Sequence[_builtins.str]] = None,
                 display_template: Optional[_builtins.str] = None):
        """
        :param _builtins.str field: Registered field name. The format is `field.abc`.
        :param _builtins.str ui_component: The identifier for this object. Format specified above.
        :param Sequence[_builtins.str] device_visibilities: Each value may be one of: `MOBILE`, `DESKTOP`.
        :param _builtins.str display_template: The template to customize how the field is displayed.
               An example value would be a string that looks like: "Price: {value}".
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "ui_component", ui_component)
        if device_visibilities is not None:
            pulumi.set(__self__, "device_visibilities", device_visibilities)
        if display_template is not None:
            pulumi.set(__self__, "display_template", display_template)

    @_builtins.property
    @pulumi.getter
    def field(self) -> _builtins.str:
        """
        Registered field name. The format is `field.abc`.
        """
        return pulumi.get(self, "field")

    @_builtins.property
    @pulumi.getter(name="uiComponent")
    def ui_component(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "ui_component")

    @_builtins.property
    @pulumi.getter(name="deviceVisibilities")
    def device_visibilities(self) -> Optional[Sequence[_builtins.str]]:
        """
        Each value may be one of: `MOBILE`, `DESKTOP`.
        """
        return pulumi.get(self, "device_visibilities")

    @_builtins.property
    @pulumi.getter(name="displayTemplate")
    def display_template(self) -> Optional[_builtins.str]:
        """
        The template to customize how the field is displayed.
        An example value would be a string that looks like: "Price: {value}".
        """
        return pulumi.get(self, "display_template")


@pulumi.output_type
class WidgetConfigUiSettingsGenerativeAnswerConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "disableRelatedQuestions":
            suggest = "disable_related_questions"
        elif key == "ignoreAdversarialQuery":
            suggest = "ignore_adversarial_query"
        elif key == "ignoreLowRelevantContent":
            suggest = "ignore_low_relevant_content"
        elif key == "ignoreNonAnswerSeekingQuery":
            suggest = "ignore_non_answer_seeking_query"
        elif key == "imageSource":
            suggest = "image_source"
        elif key == "languageCode":
            suggest = "language_code"
        elif key == "maxRephraseSteps":
            suggest = "max_rephrase_steps"
        elif key == "modelPromptPreamble":
            suggest = "model_prompt_preamble"
        elif key == "modelVersion":
            suggest = "model_version"
        elif key == "resultCount":
            suggest = "result_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in WidgetConfigUiSettingsGenerativeAnswerConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        WidgetConfigUiSettingsGenerativeAnswerConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        WidgetConfigUiSettingsGenerativeAnswerConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 disable_related_questions: Optional[_builtins.bool] = None,
                 ignore_adversarial_query: Optional[_builtins.bool] = None,
                 ignore_low_relevant_content: Optional[_builtins.bool] = None,
                 ignore_non_answer_seeking_query: Optional[_builtins.bool] = None,
                 image_source: Optional[_builtins.str] = None,
                 language_code: Optional[_builtins.str] = None,
                 max_rephrase_steps: Optional[_builtins.int] = None,
                 model_prompt_preamble: Optional[_builtins.str] = None,
                 model_version: Optional[_builtins.str] = None,
                 result_count: Optional[_builtins.int] = None):
        """
        :param _builtins.bool disable_related_questions: Whether generated answer contains suggested related questions.
        :param _builtins.bool ignore_adversarial_query: Specifies whether to filter out queries that are adversarial.
        :param _builtins.bool ignore_low_relevant_content: Specifies whether to filter out queries that are not relevant to the content.
        :param _builtins.bool ignore_non_answer_seeking_query: Specifies whether to filter out queries that are not answer-seeking.
               The default value is `false`. No answer is returned if the search query
               is classified as a non-answer seeking query.
               If this field is set to `true`, we skip generating answers for
               non-answer seeking queries and return fallback messages instead.
        :param _builtins.str image_source: Source of image returned in the answer.
               Possible values are: `ALL_AVAILABLE_SOURCES`, `CORPUS_IMAGE_ONLY`, `FIGURE_GENERATION_ONLY`.
        :param _builtins.str language_code: Language code for Summary. Use language tags defined by
               [BCP47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). Note: This
               is an experimental feature.
        :param _builtins.int max_rephrase_steps: Max rephrase steps. The max number is 5 steps. If not set or
               set to < 1, it will be set to 1 by default.
        :param _builtins.str model_prompt_preamble: Text at the beginning of the prompt that instructs the model that generates the answer.
        :param _builtins.str model_version: The model version used to generate the answer.
        :param _builtins.int result_count: The number of top results to generate the answer from. Up to 10.
        """
        if disable_related_questions is not None:
            pulumi.set(__self__, "disable_related_questions", disable_related_questions)
        if ignore_adversarial_query is not None:
            pulumi.set(__self__, "ignore_adversarial_query", ignore_adversarial_query)
        if ignore_low_relevant_content is not None:
            pulumi.set(__self__, "ignore_low_relevant_content", ignore_low_relevant_content)
        if ignore_non_answer_seeking_query is not None:
            pulumi.set(__self__, "ignore_non_answer_seeking_query", ignore_non_answer_seeking_query)
        if image_source is not None:
            pulumi.set(__self__, "image_source", image_source)
        if language_code is not None:
            pulumi.set(__self__, "language_code", language_code)
        if max_rephrase_steps is not None:
            pulumi.set(__self__, "max_rephrase_steps", max_rephrase_steps)
        if model_prompt_preamble is not None:
            pulumi.set(__self__, "model_prompt_preamble", model_prompt_preamble)
        if model_version is not None:
            pulumi.set(__self__, "model_version", model_version)
        if result_count is not None:
            pulumi.set(__self__, "result_count", result_count)

    @_builtins.property
    @pulumi.getter(name="disableRelatedQuestions")
    def disable_related_questions(self) -> Optional[_builtins.bool]:
        """
        Whether generated answer contains suggested related questions.
        """
        return pulumi.get(self, "disable_related_questions")

    @_builtins.property
    @pulumi.getter(name="ignoreAdversarialQuery")
    def ignore_adversarial_query(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to filter out queries that are adversarial.
        """
        return pulumi.get(self, "ignore_adversarial_query")

    @_builtins.property
    @pulumi.getter(name="ignoreLowRelevantContent")
    def ignore_low_relevant_content(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to filter out queries that are not relevant to the content.
        """
        return pulumi.get(self, "ignore_low_relevant_content")

    @_builtins.property
    @pulumi.getter(name="ignoreNonAnswerSeekingQuery")
    def ignore_non_answer_seeking_query(self) -> Optional[_builtins.bool]:
        """
        Specifies whether to filter out queries that are not answer-seeking.
        The default value is `false`. No answer is returned if the search query
        is classified as a non-answer seeking query.
        If this field is set to `true`, we skip generating answers for
        non-answer seeking queries and return fallback messages instead.
        """
        return pulumi.get(self, "ignore_non_answer_seeking_query")

    @_builtins.property
    @pulumi.getter(name="imageSource")
    def image_source(self) -> Optional[_builtins.str]:
        """
        Source of image returned in the answer.
        Possible values are: `ALL_AVAILABLE_SOURCES`, `CORPUS_IMAGE_ONLY`, `FIGURE_GENERATION_ONLY`.
        """
        return pulumi.get(self, "image_source")

    @_builtins.property
    @pulumi.getter(name="languageCode")
    def language_code(self) -> Optional[_builtins.str]:
        """
        Language code for Summary. Use language tags defined by
        [BCP47](https://www.rfc-editor.org/rfc/bcp/bcp47.txt). Note: This
        is an experimental feature.
        """
        return pulumi.get(self, "language_code")

    @_builtins.property
    @pulumi.getter(name="maxRephraseSteps")
    def max_rephrase_steps(self) -> Optional[_builtins.int]:
        """
        Max rephrase steps. The max number is 5 steps. If not set or
        set to < 1, it will be set to 1 by default.
        """
        return pulumi.get(self, "max_rephrase_steps")

    @_builtins.property
    @pulumi.getter(name="modelPromptPreamble")
    def model_prompt_preamble(self) -> Optional[_builtins.str]:
        """
        Text at the beginning of the prompt that instructs the model that generates the answer.
        """
        return pulumi.get(self, "model_prompt_preamble")

    @_builtins.property
    @pulumi.getter(name="modelVersion")
    def model_version(self) -> Optional[_builtins.str]:
        """
        The model version used to generate the answer.
        """
        return pulumi.get(self, "model_version")

    @_builtins.property
    @pulumi.getter(name="resultCount")
    def result_count(self) -> Optional[_builtins.int]:
        """
        The number of top results to generate the answer from. Up to 10.
        """
        return pulumi.get(self, "result_count")


