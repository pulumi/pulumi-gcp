# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ChatEngineChatEngineConfigArgs',
    'ChatEngineChatEngineConfigArgsDict',
    'ChatEngineChatEngineConfigAgentCreationConfigArgs',
    'ChatEngineChatEngineConfigAgentCreationConfigArgsDict',
    'ChatEngineChatEngineMetadataArgs',
    'ChatEngineChatEngineMetadataArgsDict',
    'ChatEngineCommonConfigArgs',
    'ChatEngineCommonConfigArgsDict',
    'DataStoreDocumentProcessingConfigArgs',
    'DataStoreDocumentProcessingConfigArgsDict',
    'DataStoreDocumentProcessingConfigChunkingConfigArgs',
    'DataStoreDocumentProcessingConfigChunkingConfigArgsDict',
    'DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgs',
    'DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgsDict',
    'DataStoreDocumentProcessingConfigDefaultParsingConfigArgs',
    'DataStoreDocumentProcessingConfigDefaultParsingConfigArgsDict',
    'DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgs',
    'DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgsDict',
    'DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgs',
    'DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgsDict',
    'DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgs',
    'DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgsDict',
    'DataStoreDocumentProcessingConfigParsingConfigOverrideArgs',
    'DataStoreDocumentProcessingConfigParsingConfigOverrideArgsDict',
    'DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgs',
    'DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgsDict',
    'DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgs',
    'DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgsDict',
    'DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgs',
    'DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgsDict',
    'SearchEngineCommonConfigArgs',
    'SearchEngineCommonConfigArgsDict',
    'SearchEngineSearchEngineConfigArgs',
    'SearchEngineSearchEngineConfigArgsDict',
    'TargetSiteFailureReasonArgs',
    'TargetSiteFailureReasonArgsDict',
    'TargetSiteFailureReasonQuotaFailureArgs',
    'TargetSiteFailureReasonQuotaFailureArgsDict',
    'TargetSiteSiteVerificationInfoArgs',
    'TargetSiteSiteVerificationInfoArgsDict',
]

MYPY = False

if not MYPY:
    class ChatEngineChatEngineConfigArgsDict(TypedDict):
        agent_creation_config: pulumi.Input['ChatEngineChatEngineConfigAgentCreationConfigArgsDict']
        """
        The configuration to generate the Dialogflow agent that is associated to this Engine.
        Structure is documented below.
        """
elif False:
    ChatEngineChatEngineConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChatEngineChatEngineConfigArgs:
    def __init__(__self__, *,
                 agent_creation_config: pulumi.Input['ChatEngineChatEngineConfigAgentCreationConfigArgs']):
        """
        :param pulumi.Input['ChatEngineChatEngineConfigAgentCreationConfigArgs'] agent_creation_config: The configuration to generate the Dialogflow agent that is associated to this Engine.
               Structure is documented below.
        """
        pulumi.set(__self__, "agent_creation_config", agent_creation_config)

    @property
    @pulumi.getter(name="agentCreationConfig")
    def agent_creation_config(self) -> pulumi.Input['ChatEngineChatEngineConfigAgentCreationConfigArgs']:
        """
        The configuration to generate the Dialogflow agent that is associated to this Engine.
        Structure is documented below.
        """
        return pulumi.get(self, "agent_creation_config")

    @agent_creation_config.setter
    def agent_creation_config(self, value: pulumi.Input['ChatEngineChatEngineConfigAgentCreationConfigArgs']):
        pulumi.set(self, "agent_creation_config", value)


if not MYPY:
    class ChatEngineChatEngineConfigAgentCreationConfigArgsDict(TypedDict):
        default_language_code: pulumi.Input[str]
        """
        The default language of the agent as a language tag. See [Language Support](https://cloud.google.com/dialogflow/docs/reference/language) for a list of the currently supported language codes.
        """
        time_zone: pulumi.Input[str]
        """
        The time zone of the agent from the [time zone database](https://www.iana.org/time-zones), e.g., America/New_York, Europe/Paris.
        """
        business: NotRequired[pulumi.Input[str]]
        """
        Name of the company, organization or other entity that the agent represents. Used for knowledge connector LLM prompt and for knowledge search.
        """
        location: NotRequired[pulumi.Input[str]]
        """
        Agent location for Agent creation, currently supported values: global/us/eu, it needs to be the same region as the Chat Engine.

        - - -
        """
elif False:
    ChatEngineChatEngineConfigAgentCreationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChatEngineChatEngineConfigAgentCreationConfigArgs:
    def __init__(__self__, *,
                 default_language_code: pulumi.Input[str],
                 time_zone: pulumi.Input[str],
                 business: Optional[pulumi.Input[str]] = None,
                 location: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] default_language_code: The default language of the agent as a language tag. See [Language Support](https://cloud.google.com/dialogflow/docs/reference/language) for a list of the currently supported language codes.
        :param pulumi.Input[str] time_zone: The time zone of the agent from the [time zone database](https://www.iana.org/time-zones), e.g., America/New_York, Europe/Paris.
        :param pulumi.Input[str] business: Name of the company, organization or other entity that the agent represents. Used for knowledge connector LLM prompt and for knowledge search.
        :param pulumi.Input[str] location: Agent location for Agent creation, currently supported values: global/us/eu, it needs to be the same region as the Chat Engine.
               
               - - -
        """
        pulumi.set(__self__, "default_language_code", default_language_code)
        pulumi.set(__self__, "time_zone", time_zone)
        if business is not None:
            pulumi.set(__self__, "business", business)
        if location is not None:
            pulumi.set(__self__, "location", location)

    @property
    @pulumi.getter(name="defaultLanguageCode")
    def default_language_code(self) -> pulumi.Input[str]:
        """
        The default language of the agent as a language tag. See [Language Support](https://cloud.google.com/dialogflow/docs/reference/language) for a list of the currently supported language codes.
        """
        return pulumi.get(self, "default_language_code")

    @default_language_code.setter
    def default_language_code(self, value: pulumi.Input[str]):
        pulumi.set(self, "default_language_code", value)

    @property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[str]:
        """
        The time zone of the agent from the [time zone database](https://www.iana.org/time-zones), e.g., America/New_York, Europe/Paris.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[str]):
        pulumi.set(self, "time_zone", value)

    @property
    @pulumi.getter
    def business(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the company, organization or other entity that the agent represents. Used for knowledge connector LLM prompt and for knowledge search.
        """
        return pulumi.get(self, "business")

    @business.setter
    def business(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "business", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        Agent location for Agent creation, currently supported values: global/us/eu, it needs to be the same region as the Chat Engine.

        - - -
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)


if not MYPY:
    class ChatEngineChatEngineMetadataArgsDict(TypedDict):
        dialogflow_agent: NotRequired[pulumi.Input[str]]
        """
        (Output)
        The resource name of a Dialogflow agent, that this Chat Engine refers to.
        """
elif False:
    ChatEngineChatEngineMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChatEngineChatEngineMetadataArgs:
    def __init__(__self__, *,
                 dialogflow_agent: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dialogflow_agent: (Output)
               The resource name of a Dialogflow agent, that this Chat Engine refers to.
        """
        if dialogflow_agent is not None:
            pulumi.set(__self__, "dialogflow_agent", dialogflow_agent)

    @property
    @pulumi.getter(name="dialogflowAgent")
    def dialogflow_agent(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The resource name of a Dialogflow agent, that this Chat Engine refers to.
        """
        return pulumi.get(self, "dialogflow_agent")

    @dialogflow_agent.setter
    def dialogflow_agent(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dialogflow_agent", value)


if not MYPY:
    class ChatEngineCommonConfigArgsDict(TypedDict):
        company_name: NotRequired[pulumi.Input[str]]
        """
        The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.
        """
elif False:
    ChatEngineCommonConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChatEngineCommonConfigArgs:
    def __init__(__self__, *,
                 company_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] company_name: The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.
        """
        if company_name is not None:
            pulumi.set(__self__, "company_name", company_name)

    @property
    @pulumi.getter(name="companyName")
    def company_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.
        """
        return pulumi.get(self, "company_name")

    @company_name.setter
    def company_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "company_name", value)


if not MYPY:
    class DataStoreDocumentProcessingConfigArgsDict(TypedDict):
        chunking_config: NotRequired[pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigArgsDict']]
        """
        Whether chunking mode is enabled.
        Structure is documented below.
        """
        default_parsing_config: NotRequired[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigArgsDict']]
        """
        Configurations for default Document parser. If not specified, this resource
        will be configured to use a default DigitalParsingConfig, and the default parsing
        config will be applied to all file types for Document parsing.
        Structure is documented below.
        """
        name: NotRequired[pulumi.Input[str]]
        """
        (Output)
        The full resource name of the Document Processing Config. Format:
        `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/documentProcessingConfig`.
        """
        parsing_config_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideArgsDict']]]]
        """
        Map from file type to override the default parsing configuration based on the file type. Supported keys:
        """
elif False:
    DataStoreDocumentProcessingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigArgs:
    def __init__(__self__, *,
                 chunking_config: Optional[pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigArgs']] = None,
                 default_parsing_config: Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigArgs']] = None,
                 name: Optional[pulumi.Input[str]] = None,
                 parsing_config_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideArgs']]]] = None):
        """
        :param pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigArgs'] chunking_config: Whether chunking mode is enabled.
               Structure is documented below.
        :param pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigArgs'] default_parsing_config: Configurations for default Document parser. If not specified, this resource
               will be configured to use a default DigitalParsingConfig, and the default parsing
               config will be applied to all file types for Document parsing.
               Structure is documented below.
        :param pulumi.Input[str] name: (Output)
               The full resource name of the Document Processing Config. Format:
               `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/documentProcessingConfig`.
        :param pulumi.Input[Sequence[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideArgs']]] parsing_config_overrides: Map from file type to override the default parsing configuration based on the file type. Supported keys:
        """
        if chunking_config is not None:
            pulumi.set(__self__, "chunking_config", chunking_config)
        if default_parsing_config is not None:
            pulumi.set(__self__, "default_parsing_config", default_parsing_config)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parsing_config_overrides is not None:
            pulumi.set(__self__, "parsing_config_overrides", parsing_config_overrides)

    @property
    @pulumi.getter(name="chunkingConfig")
    def chunking_config(self) -> Optional[pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigArgs']]:
        """
        Whether chunking mode is enabled.
        Structure is documented below.
        """
        return pulumi.get(self, "chunking_config")

    @chunking_config.setter
    def chunking_config(self, value: Optional[pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigArgs']]):
        pulumi.set(self, "chunking_config", value)

    @property
    @pulumi.getter(name="defaultParsingConfig")
    def default_parsing_config(self) -> Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigArgs']]:
        """
        Configurations for default Document parser. If not specified, this resource
        will be configured to use a default DigitalParsingConfig, and the default parsing
        config will be applied to all file types for Document parsing.
        Structure is documented below.
        """
        return pulumi.get(self, "default_parsing_config")

    @default_parsing_config.setter
    def default_parsing_config(self, value: Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigArgs']]):
        pulumi.set(self, "default_parsing_config", value)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The full resource name of the Document Processing Config. Format:
        `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/documentProcessingConfig`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="parsingConfigOverrides")
    def parsing_config_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideArgs']]]]:
        """
        Map from file type to override the default parsing configuration based on the file type. Supported keys:
        """
        return pulumi.get(self, "parsing_config_overrides")

    @parsing_config_overrides.setter
    def parsing_config_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideArgs']]]]):
        pulumi.set(self, "parsing_config_overrides", value)


if not MYPY:
    class DataStoreDocumentProcessingConfigChunkingConfigArgsDict(TypedDict):
        layout_based_chunking_config: NotRequired[pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgsDict']]
        """
        Configuration for the layout based chunking.
        Structure is documented below.
        """
elif False:
    DataStoreDocumentProcessingConfigChunkingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigChunkingConfigArgs:
    def __init__(__self__, *,
                 layout_based_chunking_config: Optional[pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgs']] = None):
        """
        :param pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgs'] layout_based_chunking_config: Configuration for the layout based chunking.
               Structure is documented below.
        """
        if layout_based_chunking_config is not None:
            pulumi.set(__self__, "layout_based_chunking_config", layout_based_chunking_config)

    @property
    @pulumi.getter(name="layoutBasedChunkingConfig")
    def layout_based_chunking_config(self) -> Optional[pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgs']]:
        """
        Configuration for the layout based chunking.
        Structure is documented below.
        """
        return pulumi.get(self, "layout_based_chunking_config")

    @layout_based_chunking_config.setter
    def layout_based_chunking_config(self, value: Optional[pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgs']]):
        pulumi.set(self, "layout_based_chunking_config", value)


if not MYPY:
    class DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgsDict(TypedDict):
        chunk_size: NotRequired[pulumi.Input[int]]
        """
        The token size limit for each chunk.
        Supported values: 100-500 (inclusive). Default value: 500.
        """
        include_ancestor_headings: NotRequired[pulumi.Input[bool]]
        """
        Whether to include appending different levels of headings to chunks from the middle of the document to prevent context loss.
        Default value: False.
        """
elif False:
    DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgs:
    def __init__(__self__, *,
                 chunk_size: Optional[pulumi.Input[int]] = None,
                 include_ancestor_headings: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[int] chunk_size: The token size limit for each chunk.
               Supported values: 100-500 (inclusive). Default value: 500.
        :param pulumi.Input[bool] include_ancestor_headings: Whether to include appending different levels of headings to chunks from the middle of the document to prevent context loss.
               Default value: False.
        """
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if include_ancestor_headings is not None:
            pulumi.set(__self__, "include_ancestor_headings", include_ancestor_headings)

    @property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[pulumi.Input[int]]:
        """
        The token size limit for each chunk.
        Supported values: 100-500 (inclusive). Default value: 500.
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "chunk_size", value)

    @property
    @pulumi.getter(name="includeAncestorHeadings")
    def include_ancestor_headings(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether to include appending different levels of headings to chunks from the middle of the document to prevent context loss.
        Default value: False.
        """
        return pulumi.get(self, "include_ancestor_headings")

    @include_ancestor_headings.setter
    def include_ancestor_headings(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_ancestor_headings", value)


if not MYPY:
    class DataStoreDocumentProcessingConfigDefaultParsingConfigArgsDict(TypedDict):
        digital_parsing_config: NotRequired[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgsDict']]
        """
        Configurations applied to digital parser.
        """
        layout_parsing_config: NotRequired[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgsDict']]
        """
        Configurations applied to layout parser.
        """
        ocr_parsing_config: NotRequired[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgsDict']]
        """
        Configurations applied to OCR parser. Currently it only applies to PDFs.
        Structure is documented below.
        """
elif False:
    DataStoreDocumentProcessingConfigDefaultParsingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigDefaultParsingConfigArgs:
    def __init__(__self__, *,
                 digital_parsing_config: Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgs']] = None,
                 layout_parsing_config: Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgs']] = None,
                 ocr_parsing_config: Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgs']] = None):
        """
        :param pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgs'] digital_parsing_config: Configurations applied to digital parser.
        :param pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgs'] layout_parsing_config: Configurations applied to layout parser.
        :param pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgs'] ocr_parsing_config: Configurations applied to OCR parser. Currently it only applies to PDFs.
               Structure is documented below.
        """
        if digital_parsing_config is not None:
            pulumi.set(__self__, "digital_parsing_config", digital_parsing_config)
        if layout_parsing_config is not None:
            pulumi.set(__self__, "layout_parsing_config", layout_parsing_config)
        if ocr_parsing_config is not None:
            pulumi.set(__self__, "ocr_parsing_config", ocr_parsing_config)

    @property
    @pulumi.getter(name="digitalParsingConfig")
    def digital_parsing_config(self) -> Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgs']]:
        """
        Configurations applied to digital parser.
        """
        return pulumi.get(self, "digital_parsing_config")

    @digital_parsing_config.setter
    def digital_parsing_config(self, value: Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgs']]):
        pulumi.set(self, "digital_parsing_config", value)

    @property
    @pulumi.getter(name="layoutParsingConfig")
    def layout_parsing_config(self) -> Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgs']]:
        """
        Configurations applied to layout parser.
        """
        return pulumi.get(self, "layout_parsing_config")

    @layout_parsing_config.setter
    def layout_parsing_config(self, value: Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgs']]):
        pulumi.set(self, "layout_parsing_config", value)

    @property
    @pulumi.getter(name="ocrParsingConfig")
    def ocr_parsing_config(self) -> Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgs']]:
        """
        Configurations applied to OCR parser. Currently it only applies to PDFs.
        Structure is documented below.
        """
        return pulumi.get(self, "ocr_parsing_config")

    @ocr_parsing_config.setter
    def ocr_parsing_config(self, value: Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgs']]):
        pulumi.set(self, "ocr_parsing_config", value)


if not MYPY:
    class DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgsDict(TypedDict):
        pass
elif False:
    DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgsDict(TypedDict):
        pass
elif False:
    DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgsDict(TypedDict):
        use_native_text: NotRequired[pulumi.Input[bool]]
        """
        If true, will use native text instead of OCR text on pages containing native text.
        """
elif False:
    DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgs:
    def __init__(__self__, *,
                 use_native_text: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] use_native_text: If true, will use native text instead of OCR text on pages containing native text.
        """
        if use_native_text is not None:
            pulumi.set(__self__, "use_native_text", use_native_text)

    @property
    @pulumi.getter(name="useNativeText")
    def use_native_text(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, will use native text instead of OCR text on pages containing native text.
        """
        return pulumi.get(self, "use_native_text")

    @use_native_text.setter
    def use_native_text(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_native_text", value)


if not MYPY:
    class DataStoreDocumentProcessingConfigParsingConfigOverrideArgsDict(TypedDict):
        file_type: pulumi.Input[str]
        """
        The identifier for this object. Format specified above.
        """
        digital_parsing_config: NotRequired[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgsDict']]
        """
        Configurations applied to digital parser.
        """
        layout_parsing_config: NotRequired[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgsDict']]
        """
        Configurations applied to layout parser.
        """
        ocr_parsing_config: NotRequired[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgsDict']]
        """
        Configurations applied to OCR parser. Currently it only applies to PDFs.
        Structure is documented below.
        """
elif False:
    DataStoreDocumentProcessingConfigParsingConfigOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigParsingConfigOverrideArgs:
    def __init__(__self__, *,
                 file_type: pulumi.Input[str],
                 digital_parsing_config: Optional[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgs']] = None,
                 layout_parsing_config: Optional[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgs']] = None,
                 ocr_parsing_config: Optional[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgs']] = None):
        """
        :param pulumi.Input[str] file_type: The identifier for this object. Format specified above.
        :param pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgs'] digital_parsing_config: Configurations applied to digital parser.
        :param pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgs'] layout_parsing_config: Configurations applied to layout parser.
        :param pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgs'] ocr_parsing_config: Configurations applied to OCR parser. Currently it only applies to PDFs.
               Structure is documented below.
        """
        pulumi.set(__self__, "file_type", file_type)
        if digital_parsing_config is not None:
            pulumi.set(__self__, "digital_parsing_config", digital_parsing_config)
        if layout_parsing_config is not None:
            pulumi.set(__self__, "layout_parsing_config", layout_parsing_config)
        if ocr_parsing_config is not None:
            pulumi.set(__self__, "ocr_parsing_config", ocr_parsing_config)

    @property
    @pulumi.getter(name="fileType")
    def file_type(self) -> pulumi.Input[str]:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "file_type")

    @file_type.setter
    def file_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "file_type", value)

    @property
    @pulumi.getter(name="digitalParsingConfig")
    def digital_parsing_config(self) -> Optional[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgs']]:
        """
        Configurations applied to digital parser.
        """
        return pulumi.get(self, "digital_parsing_config")

    @digital_parsing_config.setter
    def digital_parsing_config(self, value: Optional[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgs']]):
        pulumi.set(self, "digital_parsing_config", value)

    @property
    @pulumi.getter(name="layoutParsingConfig")
    def layout_parsing_config(self) -> Optional[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgs']]:
        """
        Configurations applied to layout parser.
        """
        return pulumi.get(self, "layout_parsing_config")

    @layout_parsing_config.setter
    def layout_parsing_config(self, value: Optional[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgs']]):
        pulumi.set(self, "layout_parsing_config", value)

    @property
    @pulumi.getter(name="ocrParsingConfig")
    def ocr_parsing_config(self) -> Optional[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgs']]:
        """
        Configurations applied to OCR parser. Currently it only applies to PDFs.
        Structure is documented below.
        """
        return pulumi.get(self, "ocr_parsing_config")

    @ocr_parsing_config.setter
    def ocr_parsing_config(self, value: Optional[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgs']]):
        pulumi.set(self, "ocr_parsing_config", value)


if not MYPY:
    class DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgsDict(TypedDict):
        pass
elif False:
    DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgsDict(TypedDict):
        pass
elif False:
    DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgsDict(TypedDict):
        use_native_text: NotRequired[pulumi.Input[bool]]
        """
        If true, will use native text instead of OCR text on pages containing native text.
        """
elif False:
    DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgs:
    def __init__(__self__, *,
                 use_native_text: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[bool] use_native_text: If true, will use native text instead of OCR text on pages containing native text.
        """
        if use_native_text is not None:
            pulumi.set(__self__, "use_native_text", use_native_text)

    @property
    @pulumi.getter(name="useNativeText")
    def use_native_text(self) -> Optional[pulumi.Input[bool]]:
        """
        If true, will use native text instead of OCR text on pages containing native text.
        """
        return pulumi.get(self, "use_native_text")

    @use_native_text.setter
    def use_native_text(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "use_native_text", value)


if not MYPY:
    class SearchEngineCommonConfigArgsDict(TypedDict):
        company_name: NotRequired[pulumi.Input[str]]
        """
        The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.cd
        """
elif False:
    SearchEngineCommonConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SearchEngineCommonConfigArgs:
    def __init__(__self__, *,
                 company_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] company_name: The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.cd
        """
        if company_name is not None:
            pulumi.set(__self__, "company_name", company_name)

    @property
    @pulumi.getter(name="companyName")
    def company_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.cd
        """
        return pulumi.get(self, "company_name")

    @company_name.setter
    def company_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "company_name", value)


if not MYPY:
    class SearchEngineSearchEngineConfigArgsDict(TypedDict):
        search_add_ons: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The add-on that this search engine enables.
        Each value may be one of: `SEARCH_ADD_ON_LLM`.

        - - -
        """
        search_tier: NotRequired[pulumi.Input[str]]
        """
        The search feature tier of this engine. Defaults to SearchTier.SEARCH_TIER_STANDARD if not specified.
        Default value is `SEARCH_TIER_STANDARD`.
        Possible values are: `SEARCH_TIER_STANDARD`, `SEARCH_TIER_ENTERPRISE`.
        """
elif False:
    SearchEngineSearchEngineConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SearchEngineSearchEngineConfigArgs:
    def __init__(__self__, *,
                 search_add_ons: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 search_tier: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] search_add_ons: The add-on that this search engine enables.
               Each value may be one of: `SEARCH_ADD_ON_LLM`.
               
               - - -
        :param pulumi.Input[str] search_tier: The search feature tier of this engine. Defaults to SearchTier.SEARCH_TIER_STANDARD if not specified.
               Default value is `SEARCH_TIER_STANDARD`.
               Possible values are: `SEARCH_TIER_STANDARD`, `SEARCH_TIER_ENTERPRISE`.
        """
        if search_add_ons is not None:
            pulumi.set(__self__, "search_add_ons", search_add_ons)
        if search_tier is not None:
            pulumi.set(__self__, "search_tier", search_tier)

    @property
    @pulumi.getter(name="searchAddOns")
    def search_add_ons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The add-on that this search engine enables.
        Each value may be one of: `SEARCH_ADD_ON_LLM`.

        - - -
        """
        return pulumi.get(self, "search_add_ons")

    @search_add_ons.setter
    def search_add_ons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "search_add_ons", value)

    @property
    @pulumi.getter(name="searchTier")
    def search_tier(self) -> Optional[pulumi.Input[str]]:
        """
        The search feature tier of this engine. Defaults to SearchTier.SEARCH_TIER_STANDARD if not specified.
        Default value is `SEARCH_TIER_STANDARD`.
        Possible values are: `SEARCH_TIER_STANDARD`, `SEARCH_TIER_ENTERPRISE`.
        """
        return pulumi.get(self, "search_tier")

    @search_tier.setter
    def search_tier(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "search_tier", value)


if not MYPY:
    class TargetSiteFailureReasonArgsDict(TypedDict):
        quota_failure: NotRequired[pulumi.Input['TargetSiteFailureReasonQuotaFailureArgsDict']]
        """
        Site verification state indicating the ownership and validity.
        Structure is documented below.
        """
elif False:
    TargetSiteFailureReasonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetSiteFailureReasonArgs:
    def __init__(__self__, *,
                 quota_failure: Optional[pulumi.Input['TargetSiteFailureReasonQuotaFailureArgs']] = None):
        """
        :param pulumi.Input['TargetSiteFailureReasonQuotaFailureArgs'] quota_failure: Site verification state indicating the ownership and validity.
               Structure is documented below.
        """
        if quota_failure is not None:
            pulumi.set(__self__, "quota_failure", quota_failure)

    @property
    @pulumi.getter(name="quotaFailure")
    def quota_failure(self) -> Optional[pulumi.Input['TargetSiteFailureReasonQuotaFailureArgs']]:
        """
        Site verification state indicating the ownership and validity.
        Structure is documented below.
        """
        return pulumi.get(self, "quota_failure")

    @quota_failure.setter
    def quota_failure(self, value: Optional[pulumi.Input['TargetSiteFailureReasonQuotaFailureArgs']]):
        pulumi.set(self, "quota_failure", value)


if not MYPY:
    class TargetSiteFailureReasonQuotaFailureArgsDict(TypedDict):
        total_required_quota: NotRequired[pulumi.Input[int]]
        """
        This number is an estimation on how much total quota this project
        needs to successfully complete indexing.
        """
elif False:
    TargetSiteFailureReasonQuotaFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetSiteFailureReasonQuotaFailureArgs:
    def __init__(__self__, *,
                 total_required_quota: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] total_required_quota: This number is an estimation on how much total quota this project
               needs to successfully complete indexing.
        """
        if total_required_quota is not None:
            pulumi.set(__self__, "total_required_quota", total_required_quota)

    @property
    @pulumi.getter(name="totalRequiredQuota")
    def total_required_quota(self) -> Optional[pulumi.Input[int]]:
        """
        This number is an estimation on how much total quota this project
        needs to successfully complete indexing.
        """
        return pulumi.get(self, "total_required_quota")

    @total_required_quota.setter
    def total_required_quota(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "total_required_quota", value)


if not MYPY:
    class TargetSiteSiteVerificationInfoArgsDict(TypedDict):
        site_verification_state: NotRequired[pulumi.Input[str]]
        """
        Site verification state indicating the ownership and validity.
        Possible values are: `VERIFIED`, `UNVERIFIED`, `EXEMPTED`.
        """
        verify_time: NotRequired[pulumi.Input[str]]
        """
        Latest site verification time.
        """
elif False:
    TargetSiteSiteVerificationInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetSiteSiteVerificationInfoArgs:
    def __init__(__self__, *,
                 site_verification_state: Optional[pulumi.Input[str]] = None,
                 verify_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] site_verification_state: Site verification state indicating the ownership and validity.
               Possible values are: `VERIFIED`, `UNVERIFIED`, `EXEMPTED`.
        :param pulumi.Input[str] verify_time: Latest site verification time.
        """
        if site_verification_state is not None:
            pulumi.set(__self__, "site_verification_state", site_verification_state)
        if verify_time is not None:
            pulumi.set(__self__, "verify_time", verify_time)

    @property
    @pulumi.getter(name="siteVerificationState")
    def site_verification_state(self) -> Optional[pulumi.Input[str]]:
        """
        Site verification state indicating the ownership and validity.
        Possible values are: `VERIFIED`, `UNVERIFIED`, `EXEMPTED`.
        """
        return pulumi.get(self, "site_verification_state")

    @site_verification_state.setter
    def site_verification_state(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "site_verification_state", value)

    @property
    @pulumi.getter(name="verifyTime")
    def verify_time(self) -> Optional[pulumi.Input[str]]:
        """
        Latest site verification time.
        """
        return pulumi.get(self, "verify_time")

    @verify_time.setter
    def verify_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "verify_time", value)


