# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ChatEngineChatEngineConfigArgs',
    'ChatEngineChatEngineConfigArgsDict',
    'ChatEngineChatEngineConfigAgentCreationConfigArgs',
    'ChatEngineChatEngineConfigAgentCreationConfigArgsDict',
    'ChatEngineChatEngineMetadataArgs',
    'ChatEngineChatEngineMetadataArgsDict',
    'ChatEngineCommonConfigArgs',
    'ChatEngineCommonConfigArgsDict',
    'CmekConfigSingleRegionKeyArgs',
    'CmekConfigSingleRegionKeyArgsDict',
    'DataStoreAdvancedSiteSearchConfigArgs',
    'DataStoreAdvancedSiteSearchConfigArgsDict',
    'DataStoreDocumentProcessingConfigArgs',
    'DataStoreDocumentProcessingConfigArgsDict',
    'DataStoreDocumentProcessingConfigChunkingConfigArgs',
    'DataStoreDocumentProcessingConfigChunkingConfigArgsDict',
    'DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgs',
    'DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgsDict',
    'DataStoreDocumentProcessingConfigDefaultParsingConfigArgs',
    'DataStoreDocumentProcessingConfigDefaultParsingConfigArgsDict',
    'DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgs',
    'DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgsDict',
    'DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgs',
    'DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgsDict',
    'DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgs',
    'DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgsDict',
    'DataStoreDocumentProcessingConfigParsingConfigOverrideArgs',
    'DataStoreDocumentProcessingConfigParsingConfigOverrideArgsDict',
    'DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgs',
    'DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgsDict',
    'DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgs',
    'DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgsDict',
    'DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgs',
    'DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgsDict',
    'RecommendationEngineCommonConfigArgs',
    'RecommendationEngineCommonConfigArgsDict',
    'RecommendationEngineMediaRecommendationEngineConfigArgs',
    'RecommendationEngineMediaRecommendationEngineConfigArgsDict',
    'RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigArgs',
    'RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigArgsDict',
    'RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfigArgs',
    'RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfigArgsDict',
    'RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfigArgs',
    'RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfigArgsDict',
    'RecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfigArgs',
    'RecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfigArgsDict',
    'SearchEngineCommonConfigArgs',
    'SearchEngineCommonConfigArgsDict',
    'SearchEngineSearchEngineConfigArgs',
    'SearchEngineSearchEngineConfigArgsDict',
    'TargetSiteFailureReasonArgs',
    'TargetSiteFailureReasonArgsDict',
    'TargetSiteFailureReasonQuotaFailureArgs',
    'TargetSiteFailureReasonQuotaFailureArgsDict',
    'TargetSiteSiteVerificationInfoArgs',
    'TargetSiteSiteVerificationInfoArgsDict',
]

MYPY = False

if not MYPY:
    class ChatEngineChatEngineConfigArgsDict(TypedDict):
        agent_creation_config: NotRequired[pulumi.Input['ChatEngineChatEngineConfigAgentCreationConfigArgsDict']]
        """
        The configuration to generate the Dialogflow agent that is associated to this Engine.
        Exactly one of `agent_creation_config` or `dialogflow_agent_to_link` must be set.
        Structure is documented below.
        """
        allow_cross_region: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If the flag set to true, we allow the agent and engine are in
        different locations, otherwise the agent and engine are required to be
        in the same location. The flag is set to false by default.
        Note that the `allow_cross_region` are one-time consumed by and passed
        to EngineService.CreateEngine. It means they cannot be retrieved using
        EngineService.GetEngine or EngineService.ListEngines API after engine
        creation.
        """
        dialogflow_agent_to_link: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource name of an existing Dialogflow agent to link to this Chat Engine. Format: `projects/<Project_ID>/locations/<Location_ID>/agents/<Agent_ID>`.
        Exactly one of `agent_creation_config` or `dialogflow_agent_to_link` must be set.
        """
elif False:
    ChatEngineChatEngineConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChatEngineChatEngineConfigArgs:
    def __init__(__self__, *,
                 agent_creation_config: Optional[pulumi.Input['ChatEngineChatEngineConfigAgentCreationConfigArgs']] = None,
                 allow_cross_region: Optional[pulumi.Input[_builtins.bool]] = None,
                 dialogflow_agent_to_link: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['ChatEngineChatEngineConfigAgentCreationConfigArgs'] agent_creation_config: The configuration to generate the Dialogflow agent that is associated to this Engine.
               Exactly one of `agent_creation_config` or `dialogflow_agent_to_link` must be set.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] allow_cross_region: If the flag set to true, we allow the agent and engine are in
               different locations, otherwise the agent and engine are required to be
               in the same location. The flag is set to false by default.
               Note that the `allow_cross_region` are one-time consumed by and passed
               to EngineService.CreateEngine. It means they cannot be retrieved using
               EngineService.GetEngine or EngineService.ListEngines API after engine
               creation.
        :param pulumi.Input[_builtins.str] dialogflow_agent_to_link: The resource name of an existing Dialogflow agent to link to this Chat Engine. Format: `projects/<Project_ID>/locations/<Location_ID>/agents/<Agent_ID>`.
               Exactly one of `agent_creation_config` or `dialogflow_agent_to_link` must be set.
        """
        if agent_creation_config is not None:
            pulumi.set(__self__, "agent_creation_config", agent_creation_config)
        if allow_cross_region is not None:
            pulumi.set(__self__, "allow_cross_region", allow_cross_region)
        if dialogflow_agent_to_link is not None:
            pulumi.set(__self__, "dialogflow_agent_to_link", dialogflow_agent_to_link)

    @_builtins.property
    @pulumi.getter(name="agentCreationConfig")
    def agent_creation_config(self) -> Optional[pulumi.Input['ChatEngineChatEngineConfigAgentCreationConfigArgs']]:
        """
        The configuration to generate the Dialogflow agent that is associated to this Engine.
        Exactly one of `agent_creation_config` or `dialogflow_agent_to_link` must be set.
        Structure is documented below.
        """
        return pulumi.get(self, "agent_creation_config")

    @agent_creation_config.setter
    def agent_creation_config(self, value: Optional[pulumi.Input['ChatEngineChatEngineConfigAgentCreationConfigArgs']]):
        pulumi.set(self, "agent_creation_config", value)

    @_builtins.property
    @pulumi.getter(name="allowCrossRegion")
    def allow_cross_region(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If the flag set to true, we allow the agent and engine are in
        different locations, otherwise the agent and engine are required to be
        in the same location. The flag is set to false by default.
        Note that the `allow_cross_region` are one-time consumed by and passed
        to EngineService.CreateEngine. It means they cannot be retrieved using
        EngineService.GetEngine or EngineService.ListEngines API after engine
        creation.
        """
        return pulumi.get(self, "allow_cross_region")

    @allow_cross_region.setter
    def allow_cross_region(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "allow_cross_region", value)

    @_builtins.property
    @pulumi.getter(name="dialogflowAgentToLink")
    def dialogflow_agent_to_link(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource name of an existing Dialogflow agent to link to this Chat Engine. Format: `projects/<Project_ID>/locations/<Location_ID>/agents/<Agent_ID>`.
        Exactly one of `agent_creation_config` or `dialogflow_agent_to_link` must be set.
        """
        return pulumi.get(self, "dialogflow_agent_to_link")

    @dialogflow_agent_to_link.setter
    def dialogflow_agent_to_link(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dialogflow_agent_to_link", value)


if not MYPY:
    class ChatEngineChatEngineConfigAgentCreationConfigArgsDict(TypedDict):
        default_language_code: pulumi.Input[_builtins.str]
        """
        The default language of the agent as a language tag. See [Language Support](https://cloud.google.com/dialogflow/docs/reference/language) for a list of the currently supported language codes.
        """
        time_zone: pulumi.Input[_builtins.str]
        """
        The time zone of the agent from the [time zone database](https://www.iana.org/time-zones), e.g., America/New_York, Europe/Paris.
        """
        business: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the company, organization or other entity that the agent represents. Used for knowledge connector LLM prompt and for knowledge search.
        """
        location: NotRequired[pulumi.Input[_builtins.str]]
        """
        Agent location for Agent creation, currently supported values: global/us/eu, it needs to be the same region as the Chat Engine.
        """
elif False:
    ChatEngineChatEngineConfigAgentCreationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChatEngineChatEngineConfigAgentCreationConfigArgs:
    def __init__(__self__, *,
                 default_language_code: pulumi.Input[_builtins.str],
                 time_zone: pulumi.Input[_builtins.str],
                 business: Optional[pulumi.Input[_builtins.str]] = None,
                 location: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] default_language_code: The default language of the agent as a language tag. See [Language Support](https://cloud.google.com/dialogflow/docs/reference/language) for a list of the currently supported language codes.
        :param pulumi.Input[_builtins.str] time_zone: The time zone of the agent from the [time zone database](https://www.iana.org/time-zones), e.g., America/New_York, Europe/Paris.
        :param pulumi.Input[_builtins.str] business: Name of the company, organization or other entity that the agent represents. Used for knowledge connector LLM prompt and for knowledge search.
        :param pulumi.Input[_builtins.str] location: Agent location for Agent creation, currently supported values: global/us/eu, it needs to be the same region as the Chat Engine.
        """
        pulumi.set(__self__, "default_language_code", default_language_code)
        pulumi.set(__self__, "time_zone", time_zone)
        if business is not None:
            pulumi.set(__self__, "business", business)
        if location is not None:
            pulumi.set(__self__, "location", location)

    @_builtins.property
    @pulumi.getter(name="defaultLanguageCode")
    def default_language_code(self) -> pulumi.Input[_builtins.str]:
        """
        The default language of the agent as a language tag. See [Language Support](https://cloud.google.com/dialogflow/docs/reference/language) for a list of the currently supported language codes.
        """
        return pulumi.get(self, "default_language_code")

    @default_language_code.setter
    def default_language_code(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "default_language_code", value)

    @_builtins.property
    @pulumi.getter(name="timeZone")
    def time_zone(self) -> pulumi.Input[_builtins.str]:
        """
        The time zone of the agent from the [time zone database](https://www.iana.org/time-zones), e.g., America/New_York, Europe/Paris.
        """
        return pulumi.get(self, "time_zone")

    @time_zone.setter
    def time_zone(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "time_zone", value)

    @_builtins.property
    @pulumi.getter
    def business(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the company, organization or other entity that the agent represents. Used for knowledge connector LLM prompt and for knowledge search.
        """
        return pulumi.get(self, "business")

    @business.setter
    def business(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "business", value)

    @_builtins.property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Agent location for Agent creation, currently supported values: global/us/eu, it needs to be the same region as the Chat Engine.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "location", value)


if not MYPY:
    class ChatEngineChatEngineMetadataArgsDict(TypedDict):
        dialogflow_agent: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The resource name of a Dialogflow agent, that this Chat Engine refers to.
        """
elif False:
    ChatEngineChatEngineMetadataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChatEngineChatEngineMetadataArgs:
    def __init__(__self__, *,
                 dialogflow_agent: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] dialogflow_agent: (Output)
               The resource name of a Dialogflow agent, that this Chat Engine refers to.
        """
        if dialogflow_agent is not None:
            pulumi.set(__self__, "dialogflow_agent", dialogflow_agent)

    @_builtins.property
    @pulumi.getter(name="dialogflowAgent")
    def dialogflow_agent(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The resource name of a Dialogflow agent, that this Chat Engine refers to.
        """
        return pulumi.get(self, "dialogflow_agent")

    @dialogflow_agent.setter
    def dialogflow_agent(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "dialogflow_agent", value)


if not MYPY:
    class ChatEngineCommonConfigArgsDict(TypedDict):
        company_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.
        """
elif False:
    ChatEngineCommonConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ChatEngineCommonConfigArgs:
    def __init__(__self__, *,
                 company_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] company_name: The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.
        """
        if company_name is not None:
            pulumi.set(__self__, "company_name", company_name)

    @_builtins.property
    @pulumi.getter(name="companyName")
    def company_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.
        """
        return pulumi.get(self, "company_name")

    @company_name.setter
    def company_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "company_name", value)


if not MYPY:
    class CmekConfigSingleRegionKeyArgsDict(TypedDict):
        kms_key: pulumi.Input[_builtins.str]
        """
        Single-regional kms key resource name which will be used to encrypt
        resources
        `projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{keyId}`.
        """
elif False:
    CmekConfigSingleRegionKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class CmekConfigSingleRegionKeyArgs:
    def __init__(__self__, *,
                 kms_key: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] kms_key: Single-regional kms key resource name which will be used to encrypt
               resources
               `projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{keyId}`.
        """
        pulumi.set(__self__, "kms_key", kms_key)

    @_builtins.property
    @pulumi.getter(name="kmsKey")
    def kms_key(self) -> pulumi.Input[_builtins.str]:
        """
        Single-regional kms key resource name which will be used to encrypt
        resources
        `projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{keyId}`.
        """
        return pulumi.get(self, "kms_key")

    @kms_key.setter
    def kms_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "kms_key", value)


if not MYPY:
    class DataStoreAdvancedSiteSearchConfigArgsDict(TypedDict):
        disable_automatic_refresh: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set true, automatic refresh is disabled for the DataStore.
        """
        disable_initial_index: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If set true, initial indexing is disabled for the DataStore.
        """
elif False:
    DataStoreAdvancedSiteSearchConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreAdvancedSiteSearchConfigArgs:
    def __init__(__self__, *,
                 disable_automatic_refresh: Optional[pulumi.Input[_builtins.bool]] = None,
                 disable_initial_index: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] disable_automatic_refresh: If set true, automatic refresh is disabled for the DataStore.
        :param pulumi.Input[_builtins.bool] disable_initial_index: If set true, initial indexing is disabled for the DataStore.
        """
        if disable_automatic_refresh is not None:
            pulumi.set(__self__, "disable_automatic_refresh", disable_automatic_refresh)
        if disable_initial_index is not None:
            pulumi.set(__self__, "disable_initial_index", disable_initial_index)

    @_builtins.property
    @pulumi.getter(name="disableAutomaticRefresh")
    def disable_automatic_refresh(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set true, automatic refresh is disabled for the DataStore.
        """
        return pulumi.get(self, "disable_automatic_refresh")

    @disable_automatic_refresh.setter
    def disable_automatic_refresh(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_automatic_refresh", value)

    @_builtins.property
    @pulumi.getter(name="disableInitialIndex")
    def disable_initial_index(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If set true, initial indexing is disabled for the DataStore.
        """
        return pulumi.get(self, "disable_initial_index")

    @disable_initial_index.setter
    def disable_initial_index(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "disable_initial_index", value)


if not MYPY:
    class DataStoreDocumentProcessingConfigArgsDict(TypedDict):
        chunking_config: NotRequired[pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigArgsDict']]
        """
        Whether chunking mode is enabled.
        Structure is documented below.
        """
        default_parsing_config: NotRequired[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigArgsDict']]
        """
        Configurations for default Document parser. If not specified, this resource
        will be configured to use a default DigitalParsingConfig, and the default parsing
        config will be applied to all file types for Document parsing.
        Structure is documented below.
        """
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The full resource name of the Document Processing Config. Format:
        `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/documentProcessingConfig`.
        """
        parsing_config_overrides: NotRequired[pulumi.Input[Sequence[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideArgsDict']]]]
        """
        Map from file type to override the default parsing configuration based on the file type. Supported keys:
        """
elif False:
    DataStoreDocumentProcessingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigArgs:
    def __init__(__self__, *,
                 chunking_config: Optional[pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigArgs']] = None,
                 default_parsing_config: Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigArgs']] = None,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 parsing_config_overrides: Optional[pulumi.Input[Sequence[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideArgs']]]] = None):
        """
        :param pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigArgs'] chunking_config: Whether chunking mode is enabled.
               Structure is documented below.
        :param pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigArgs'] default_parsing_config: Configurations for default Document parser. If not specified, this resource
               will be configured to use a default DigitalParsingConfig, and the default parsing
               config will be applied to all file types for Document parsing.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] name: (Output)
               The full resource name of the Document Processing Config. Format:
               `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/documentProcessingConfig`.
        :param pulumi.Input[Sequence[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideArgs']]] parsing_config_overrides: Map from file type to override the default parsing configuration based on the file type. Supported keys:
        """
        if chunking_config is not None:
            pulumi.set(__self__, "chunking_config", chunking_config)
        if default_parsing_config is not None:
            pulumi.set(__self__, "default_parsing_config", default_parsing_config)
        if name is not None:
            pulumi.set(__self__, "name", name)
        if parsing_config_overrides is not None:
            pulumi.set(__self__, "parsing_config_overrides", parsing_config_overrides)

    @_builtins.property
    @pulumi.getter(name="chunkingConfig")
    def chunking_config(self) -> Optional[pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigArgs']]:
        """
        Whether chunking mode is enabled.
        Structure is documented below.
        """
        return pulumi.get(self, "chunking_config")

    @chunking_config.setter
    def chunking_config(self, value: Optional[pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigArgs']]):
        pulumi.set(self, "chunking_config", value)

    @_builtins.property
    @pulumi.getter(name="defaultParsingConfig")
    def default_parsing_config(self) -> Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigArgs']]:
        """
        Configurations for default Document parser. If not specified, this resource
        will be configured to use a default DigitalParsingConfig, and the default parsing
        config will be applied to all file types for Document parsing.
        Structure is documented below.
        """
        return pulumi.get(self, "default_parsing_config")

    @default_parsing_config.setter
    def default_parsing_config(self, value: Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigArgs']]):
        pulumi.set(self, "default_parsing_config", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The full resource name of the Document Processing Config. Format:
        `projects/{project}/locations/{location}/collections/{collection_id}/dataStores/{data_store_id}/documentProcessingConfig`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter(name="parsingConfigOverrides")
    def parsing_config_overrides(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideArgs']]]]:
        """
        Map from file type to override the default parsing configuration based on the file type. Supported keys:
        """
        return pulumi.get(self, "parsing_config_overrides")

    @parsing_config_overrides.setter
    def parsing_config_overrides(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideArgs']]]]):
        pulumi.set(self, "parsing_config_overrides", value)


if not MYPY:
    class DataStoreDocumentProcessingConfigChunkingConfigArgsDict(TypedDict):
        layout_based_chunking_config: NotRequired[pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgsDict']]
        """
        Configuration for the layout based chunking.
        Structure is documented below.
        """
elif False:
    DataStoreDocumentProcessingConfigChunkingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigChunkingConfigArgs:
    def __init__(__self__, *,
                 layout_based_chunking_config: Optional[pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgs']] = None):
        """
        :param pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgs'] layout_based_chunking_config: Configuration for the layout based chunking.
               Structure is documented below.
        """
        if layout_based_chunking_config is not None:
            pulumi.set(__self__, "layout_based_chunking_config", layout_based_chunking_config)

    @_builtins.property
    @pulumi.getter(name="layoutBasedChunkingConfig")
    def layout_based_chunking_config(self) -> Optional[pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgs']]:
        """
        Configuration for the layout based chunking.
        Structure is documented below.
        """
        return pulumi.get(self, "layout_based_chunking_config")

    @layout_based_chunking_config.setter
    def layout_based_chunking_config(self, value: Optional[pulumi.Input['DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgs']]):
        pulumi.set(self, "layout_based_chunking_config", value)


if not MYPY:
    class DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgsDict(TypedDict):
        chunk_size: NotRequired[pulumi.Input[_builtins.int]]
        """
        The token size limit for each chunk.
        Supported values: 100-500 (inclusive). Default value: 500.
        """
        include_ancestor_headings: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to include appending different levels of headings to chunks from the middle of the document to prevent context loss.
        Default value: False.
        """
elif False:
    DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigChunkingConfigLayoutBasedChunkingConfigArgs:
    def __init__(__self__, *,
                 chunk_size: Optional[pulumi.Input[_builtins.int]] = None,
                 include_ancestor_headings: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.int] chunk_size: The token size limit for each chunk.
               Supported values: 100-500 (inclusive). Default value: 500.
        :param pulumi.Input[_builtins.bool] include_ancestor_headings: Whether to include appending different levels of headings to chunks from the middle of the document to prevent context loss.
               Default value: False.
        """
        if chunk_size is not None:
            pulumi.set(__self__, "chunk_size", chunk_size)
        if include_ancestor_headings is not None:
            pulumi.set(__self__, "include_ancestor_headings", include_ancestor_headings)

    @_builtins.property
    @pulumi.getter(name="chunkSize")
    def chunk_size(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The token size limit for each chunk.
        Supported values: 100-500 (inclusive). Default value: 500.
        """
        return pulumi.get(self, "chunk_size")

    @chunk_size.setter
    def chunk_size(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "chunk_size", value)

    @_builtins.property
    @pulumi.getter(name="includeAncestorHeadings")
    def include_ancestor_headings(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to include appending different levels of headings to chunks from the middle of the document to prevent context loss.
        Default value: False.
        """
        return pulumi.get(self, "include_ancestor_headings")

    @include_ancestor_headings.setter
    def include_ancestor_headings(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "include_ancestor_headings", value)


if not MYPY:
    class DataStoreDocumentProcessingConfigDefaultParsingConfigArgsDict(TypedDict):
        digital_parsing_config: NotRequired[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgsDict']]
        """
        Configurations applied to digital parser.
        """
        layout_parsing_config: NotRequired[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgsDict']]
        """
        Configurations applied to layout parser.
        Structure is documented below.
        """
        ocr_parsing_config: NotRequired[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgsDict']]
        """
        Configurations applied to OCR parser. Currently it only applies to PDFs.
        Structure is documented below.
        """
elif False:
    DataStoreDocumentProcessingConfigDefaultParsingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigDefaultParsingConfigArgs:
    def __init__(__self__, *,
                 digital_parsing_config: Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgs']] = None,
                 layout_parsing_config: Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgs']] = None,
                 ocr_parsing_config: Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgs']] = None):
        """
        :param pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgs'] digital_parsing_config: Configurations applied to digital parser.
        :param pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgs'] layout_parsing_config: Configurations applied to layout parser.
               Structure is documented below.
        :param pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgs'] ocr_parsing_config: Configurations applied to OCR parser. Currently it only applies to PDFs.
               Structure is documented below.
        """
        if digital_parsing_config is not None:
            pulumi.set(__self__, "digital_parsing_config", digital_parsing_config)
        if layout_parsing_config is not None:
            pulumi.set(__self__, "layout_parsing_config", layout_parsing_config)
        if ocr_parsing_config is not None:
            pulumi.set(__self__, "ocr_parsing_config", ocr_parsing_config)

    @_builtins.property
    @pulumi.getter(name="digitalParsingConfig")
    def digital_parsing_config(self) -> Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgs']]:
        """
        Configurations applied to digital parser.
        """
        return pulumi.get(self, "digital_parsing_config")

    @digital_parsing_config.setter
    def digital_parsing_config(self, value: Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgs']]):
        pulumi.set(self, "digital_parsing_config", value)

    @_builtins.property
    @pulumi.getter(name="layoutParsingConfig")
    def layout_parsing_config(self) -> Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgs']]:
        """
        Configurations applied to layout parser.
        Structure is documented below.
        """
        return pulumi.get(self, "layout_parsing_config")

    @layout_parsing_config.setter
    def layout_parsing_config(self, value: Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgs']]):
        pulumi.set(self, "layout_parsing_config", value)

    @_builtins.property
    @pulumi.getter(name="ocrParsingConfig")
    def ocr_parsing_config(self) -> Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgs']]:
        """
        Configurations applied to OCR parser. Currently it only applies to PDFs.
        Structure is documented below.
        """
        return pulumi.get(self, "ocr_parsing_config")

    @ocr_parsing_config.setter
    def ocr_parsing_config(self, value: Optional[pulumi.Input['DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgs']]):
        pulumi.set(self, "ocr_parsing_config", value)


if not MYPY:
    class DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgsDict(TypedDict):
        pass
elif False:
    DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigDefaultParsingConfigDigitalParsingConfigArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgsDict(TypedDict):
        enable_image_annotation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the LLM based annotation is added to the image during parsing.
        """
        enable_table_annotation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the LLM based annotation is added to the table during parsing.
        """
        exclude_html_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of HTML classes to exclude from the parsed content.
        """
        exclude_html_elements: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of HTML elements to exclude from the parsed content.
        """
        exclude_html_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of HTML ids to exclude from the parsed content.
        """
        structured_content_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Contains the required structure types to extract from the document. Supported values: `shareholder-structure`.
        """
elif False:
    DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigDefaultParsingConfigLayoutParsingConfigArgs:
    def __init__(__self__, *,
                 enable_image_annotation: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_table_annotation: Optional[pulumi.Input[_builtins.bool]] = None,
                 exclude_html_classes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 exclude_html_elements: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 exclude_html_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 structured_content_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_image_annotation: If true, the LLM based annotation is added to the image during parsing.
        :param pulumi.Input[_builtins.bool] enable_table_annotation: If true, the LLM based annotation is added to the table during parsing.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_html_classes: List of HTML classes to exclude from the parsed content.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_html_elements: List of HTML elements to exclude from the parsed content.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_html_ids: List of HTML ids to exclude from the parsed content.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] structured_content_types: Contains the required structure types to extract from the document. Supported values: `shareholder-structure`.
        """
        if enable_image_annotation is not None:
            pulumi.set(__self__, "enable_image_annotation", enable_image_annotation)
        if enable_table_annotation is not None:
            pulumi.set(__self__, "enable_table_annotation", enable_table_annotation)
        if exclude_html_classes is not None:
            pulumi.set(__self__, "exclude_html_classes", exclude_html_classes)
        if exclude_html_elements is not None:
            pulumi.set(__self__, "exclude_html_elements", exclude_html_elements)
        if exclude_html_ids is not None:
            pulumi.set(__self__, "exclude_html_ids", exclude_html_ids)
        if structured_content_types is not None:
            pulumi.set(__self__, "structured_content_types", structured_content_types)

    @_builtins.property
    @pulumi.getter(name="enableImageAnnotation")
    def enable_image_annotation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the LLM based annotation is added to the image during parsing.
        """
        return pulumi.get(self, "enable_image_annotation")

    @enable_image_annotation.setter
    def enable_image_annotation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_image_annotation", value)

    @_builtins.property
    @pulumi.getter(name="enableTableAnnotation")
    def enable_table_annotation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the LLM based annotation is added to the table during parsing.
        """
        return pulumi.get(self, "enable_table_annotation")

    @enable_table_annotation.setter
    def enable_table_annotation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_table_annotation", value)

    @_builtins.property
    @pulumi.getter(name="excludeHtmlClasses")
    def exclude_html_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of HTML classes to exclude from the parsed content.
        """
        return pulumi.get(self, "exclude_html_classes")

    @exclude_html_classes.setter
    def exclude_html_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_html_classes", value)

    @_builtins.property
    @pulumi.getter(name="excludeHtmlElements")
    def exclude_html_elements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of HTML elements to exclude from the parsed content.
        """
        return pulumi.get(self, "exclude_html_elements")

    @exclude_html_elements.setter
    def exclude_html_elements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_html_elements", value)

    @_builtins.property
    @pulumi.getter(name="excludeHtmlIds")
    def exclude_html_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of HTML ids to exclude from the parsed content.
        """
        return pulumi.get(self, "exclude_html_ids")

    @exclude_html_ids.setter
    def exclude_html_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_html_ids", value)

    @_builtins.property
    @pulumi.getter(name="structuredContentTypes")
    def structured_content_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Contains the required structure types to extract from the document. Supported values: `shareholder-structure`.
        """
        return pulumi.get(self, "structured_content_types")

    @structured_content_types.setter
    def structured_content_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "structured_content_types", value)


if not MYPY:
    class DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgsDict(TypedDict):
        use_native_text: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, will use native text instead of OCR text on pages containing native text.
        """
elif False:
    DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigDefaultParsingConfigOcrParsingConfigArgs:
    def __init__(__self__, *,
                 use_native_text: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] use_native_text: If true, will use native text instead of OCR text on pages containing native text.
        """
        if use_native_text is not None:
            pulumi.set(__self__, "use_native_text", use_native_text)

    @_builtins.property
    @pulumi.getter(name="useNativeText")
    def use_native_text(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, will use native text instead of OCR text on pages containing native text.
        """
        return pulumi.get(self, "use_native_text")

    @use_native_text.setter
    def use_native_text(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_native_text", value)


if not MYPY:
    class DataStoreDocumentProcessingConfigParsingConfigOverrideArgsDict(TypedDict):
        file_type: pulumi.Input[_builtins.str]
        """
        The identifier for this object. Format specified above.
        """
        digital_parsing_config: NotRequired[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgsDict']]
        """
        Configurations applied to digital parser.
        """
        layout_parsing_config: NotRequired[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgsDict']]
        """
        Configurations applied to layout parser.
        Structure is documented below.
        """
        ocr_parsing_config: NotRequired[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgsDict']]
        """
        Configurations applied to OCR parser. Currently it only applies to PDFs.
        Structure is documented below.
        """
elif False:
    DataStoreDocumentProcessingConfigParsingConfigOverrideArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigParsingConfigOverrideArgs:
    def __init__(__self__, *,
                 file_type: pulumi.Input[_builtins.str],
                 digital_parsing_config: Optional[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgs']] = None,
                 layout_parsing_config: Optional[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgs']] = None,
                 ocr_parsing_config: Optional[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] file_type: The identifier for this object. Format specified above.
        :param pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgs'] digital_parsing_config: Configurations applied to digital parser.
        :param pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgs'] layout_parsing_config: Configurations applied to layout parser.
               Structure is documented below.
        :param pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgs'] ocr_parsing_config: Configurations applied to OCR parser. Currently it only applies to PDFs.
               Structure is documented below.
        """
        pulumi.set(__self__, "file_type", file_type)
        if digital_parsing_config is not None:
            pulumi.set(__self__, "digital_parsing_config", digital_parsing_config)
        if layout_parsing_config is not None:
            pulumi.set(__self__, "layout_parsing_config", layout_parsing_config)
        if ocr_parsing_config is not None:
            pulumi.set(__self__, "ocr_parsing_config", ocr_parsing_config)

    @_builtins.property
    @pulumi.getter(name="fileType")
    def file_type(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "file_type")

    @file_type.setter
    def file_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "file_type", value)

    @_builtins.property
    @pulumi.getter(name="digitalParsingConfig")
    def digital_parsing_config(self) -> Optional[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgs']]:
        """
        Configurations applied to digital parser.
        """
        return pulumi.get(self, "digital_parsing_config")

    @digital_parsing_config.setter
    def digital_parsing_config(self, value: Optional[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgs']]):
        pulumi.set(self, "digital_parsing_config", value)

    @_builtins.property
    @pulumi.getter(name="layoutParsingConfig")
    def layout_parsing_config(self) -> Optional[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgs']]:
        """
        Configurations applied to layout parser.
        Structure is documented below.
        """
        return pulumi.get(self, "layout_parsing_config")

    @layout_parsing_config.setter
    def layout_parsing_config(self, value: Optional[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgs']]):
        pulumi.set(self, "layout_parsing_config", value)

    @_builtins.property
    @pulumi.getter(name="ocrParsingConfig")
    def ocr_parsing_config(self) -> Optional[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgs']]:
        """
        Configurations applied to OCR parser. Currently it only applies to PDFs.
        Structure is documented below.
        """
        return pulumi.get(self, "ocr_parsing_config")

    @ocr_parsing_config.setter
    def ocr_parsing_config(self, value: Optional[pulumi.Input['DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgs']]):
        pulumi.set(self, "ocr_parsing_config", value)


if not MYPY:
    class DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgsDict(TypedDict):
        pass
elif False:
    DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigParsingConfigOverrideDigitalParsingConfigArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgsDict(TypedDict):
        enable_image_annotation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the LLM based annotation is added to the image during parsing.
        """
        enable_table_annotation: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, the LLM based annotation is added to the table during parsing.
        """
        exclude_html_classes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of HTML classes to exclude from the parsed content.
        """
        exclude_html_elements: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of HTML elements to exclude from the parsed content.
        """
        exclude_html_ids: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of HTML ids to exclude from the parsed content.
        """
        structured_content_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Contains the required structure types to extract from the document. Supported values: `shareholder-structure`.
        """
elif False:
    DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigParsingConfigOverrideLayoutParsingConfigArgs:
    def __init__(__self__, *,
                 enable_image_annotation: Optional[pulumi.Input[_builtins.bool]] = None,
                 enable_table_annotation: Optional[pulumi.Input[_builtins.bool]] = None,
                 exclude_html_classes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 exclude_html_elements: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 exclude_html_ids: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 structured_content_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.bool] enable_image_annotation: If true, the LLM based annotation is added to the image during parsing.
        :param pulumi.Input[_builtins.bool] enable_table_annotation: If true, the LLM based annotation is added to the table during parsing.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_html_classes: List of HTML classes to exclude from the parsed content.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_html_elements: List of HTML elements to exclude from the parsed content.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] exclude_html_ids: List of HTML ids to exclude from the parsed content.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] structured_content_types: Contains the required structure types to extract from the document. Supported values: `shareholder-structure`.
        """
        if enable_image_annotation is not None:
            pulumi.set(__self__, "enable_image_annotation", enable_image_annotation)
        if enable_table_annotation is not None:
            pulumi.set(__self__, "enable_table_annotation", enable_table_annotation)
        if exclude_html_classes is not None:
            pulumi.set(__self__, "exclude_html_classes", exclude_html_classes)
        if exclude_html_elements is not None:
            pulumi.set(__self__, "exclude_html_elements", exclude_html_elements)
        if exclude_html_ids is not None:
            pulumi.set(__self__, "exclude_html_ids", exclude_html_ids)
        if structured_content_types is not None:
            pulumi.set(__self__, "structured_content_types", structured_content_types)

    @_builtins.property
    @pulumi.getter(name="enableImageAnnotation")
    def enable_image_annotation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the LLM based annotation is added to the image during parsing.
        """
        return pulumi.get(self, "enable_image_annotation")

    @enable_image_annotation.setter
    def enable_image_annotation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_image_annotation", value)

    @_builtins.property
    @pulumi.getter(name="enableTableAnnotation")
    def enable_table_annotation(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, the LLM based annotation is added to the table during parsing.
        """
        return pulumi.get(self, "enable_table_annotation")

    @enable_table_annotation.setter
    def enable_table_annotation(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enable_table_annotation", value)

    @_builtins.property
    @pulumi.getter(name="excludeHtmlClasses")
    def exclude_html_classes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of HTML classes to exclude from the parsed content.
        """
        return pulumi.get(self, "exclude_html_classes")

    @exclude_html_classes.setter
    def exclude_html_classes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_html_classes", value)

    @_builtins.property
    @pulumi.getter(name="excludeHtmlElements")
    def exclude_html_elements(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of HTML elements to exclude from the parsed content.
        """
        return pulumi.get(self, "exclude_html_elements")

    @exclude_html_elements.setter
    def exclude_html_elements(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_html_elements", value)

    @_builtins.property
    @pulumi.getter(name="excludeHtmlIds")
    def exclude_html_ids(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of HTML ids to exclude from the parsed content.
        """
        return pulumi.get(self, "exclude_html_ids")

    @exclude_html_ids.setter
    def exclude_html_ids(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "exclude_html_ids", value)

    @_builtins.property
    @pulumi.getter(name="structuredContentTypes")
    def structured_content_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Contains the required structure types to extract from the document. Supported values: `shareholder-structure`.
        """
        return pulumi.get(self, "structured_content_types")

    @structured_content_types.setter
    def structured_content_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "structured_content_types", value)


if not MYPY:
    class DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgsDict(TypedDict):
        use_native_text: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, will use native text instead of OCR text on pages containing native text.
        """
elif False:
    DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DataStoreDocumentProcessingConfigParsingConfigOverrideOcrParsingConfigArgs:
    def __init__(__self__, *,
                 use_native_text: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] use_native_text: If true, will use native text instead of OCR text on pages containing native text.
        """
        if use_native_text is not None:
            pulumi.set(__self__, "use_native_text", use_native_text)

    @_builtins.property
    @pulumi.getter(name="useNativeText")
    def use_native_text(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, will use native text instead of OCR text on pages containing native text.
        """
        return pulumi.get(self, "use_native_text")

    @use_native_text.setter
    def use_native_text(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "use_native_text", value)


if not MYPY:
    class RecommendationEngineCommonConfigArgsDict(TypedDict):
        company_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.cd
        """
elif False:
    RecommendationEngineCommonConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecommendationEngineCommonConfigArgs:
    def __init__(__self__, *,
                 company_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] company_name: The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.cd
        """
        if company_name is not None:
            pulumi.set(__self__, "company_name", company_name)

    @_builtins.property
    @pulumi.getter(name="companyName")
    def company_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.cd
        """
        return pulumi.get(self, "company_name")

    @company_name.setter
    def company_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "company_name", value)


if not MYPY:
    class RecommendationEngineMediaRecommendationEngineConfigArgsDict(TypedDict):
        engine_features_config: NotRequired[pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigArgsDict']]
        """
        More feature configs of the selected engine type.
        Structure is documented below.
        """
        optimization_objective: NotRequired[pulumi.Input[_builtins.str]]
        """
        The optimization objective. e.g., `cvr`.
        This field together with MediaRecommendationEngineConfig.type describes
        engine metadata to use to control engine training and serving.
        Currently supported values: `ctr`, `cvr`.
        If not specified, we choose default based on engine type. Default depends on type of recommendation:
        `recommended-for-you` => `ctr`
        `others-you-may-like` => `ctr`
        """
        optimization_objective_config: NotRequired[pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfigArgsDict']]
        """
        Name and value of the custom threshold for cvr optimization_objective.
        For target_field `watch-time`, target_field_value must be an integer
        value indicating the media progress time in seconds between (0, 86400]
        (excludes 0, includes 86400) (e.g., 90).
        For target_field `watch-percentage`, the target_field_value must be a
        valid float value between (0, 1.0] (excludes 0, includes 1.0) (e.g., 0.5).
        Structure is documented below.
        """
        training_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        The training state that the engine is in (e.g. `TRAINING` or `PAUSED`).
        Since part of the cost of running the service
        is frequency of training - this can be used to determine when to train
        engine in order to control cost. If not specified: the default value for
        `CreateEngine` method is `TRAINING`. The default value for
        `UpdateEngine` method is to keep the state the same as before.
        Possible values are: `PAUSED`, `TRAINING`.
        """
        type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of engine. e.g., `recommended-for-you`.
        This field together with MediaRecommendationEngineConfig.optimizationObjective describes
        engine metadata to use to control engine training and serving.
        Currently supported values: `recommended-for-you`, `others-you-may-like`,
        `more-like-this`, `most-popular-items`.
        """
elif False:
    RecommendationEngineMediaRecommendationEngineConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecommendationEngineMediaRecommendationEngineConfigArgs:
    def __init__(__self__, *,
                 engine_features_config: Optional[pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigArgs']] = None,
                 optimization_objective: Optional[pulumi.Input[_builtins.str]] = None,
                 optimization_objective_config: Optional[pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfigArgs']] = None,
                 training_state: Optional[pulumi.Input[_builtins.str]] = None,
                 type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigArgs'] engine_features_config: More feature configs of the selected engine type.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] optimization_objective: The optimization objective. e.g., `cvr`.
               This field together with MediaRecommendationEngineConfig.type describes
               engine metadata to use to control engine training and serving.
               Currently supported values: `ctr`, `cvr`.
               If not specified, we choose default based on engine type. Default depends on type of recommendation:
               `recommended-for-you` => `ctr`
               `others-you-may-like` => `ctr`
        :param pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfigArgs'] optimization_objective_config: Name and value of the custom threshold for cvr optimization_objective.
               For target_field `watch-time`, target_field_value must be an integer
               value indicating the media progress time in seconds between (0, 86400]
               (excludes 0, includes 86400) (e.g., 90).
               For target_field `watch-percentage`, the target_field_value must be a
               valid float value between (0, 1.0] (excludes 0, includes 1.0) (e.g., 0.5).
               Structure is documented below.
        :param pulumi.Input[_builtins.str] training_state: The training state that the engine is in (e.g. `TRAINING` or `PAUSED`).
               Since part of the cost of running the service
               is frequency of training - this can be used to determine when to train
               engine in order to control cost. If not specified: the default value for
               `CreateEngine` method is `TRAINING`. The default value for
               `UpdateEngine` method is to keep the state the same as before.
               Possible values are: `PAUSED`, `TRAINING`.
        :param pulumi.Input[_builtins.str] type: The type of engine. e.g., `recommended-for-you`.
               This field together with MediaRecommendationEngineConfig.optimizationObjective describes
               engine metadata to use to control engine training and serving.
               Currently supported values: `recommended-for-you`, `others-you-may-like`,
               `more-like-this`, `most-popular-items`.
        """
        if engine_features_config is not None:
            pulumi.set(__self__, "engine_features_config", engine_features_config)
        if optimization_objective is not None:
            pulumi.set(__self__, "optimization_objective", optimization_objective)
        if optimization_objective_config is not None:
            pulumi.set(__self__, "optimization_objective_config", optimization_objective_config)
        if training_state is not None:
            pulumi.set(__self__, "training_state", training_state)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="engineFeaturesConfig")
    def engine_features_config(self) -> Optional[pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigArgs']]:
        """
        More feature configs of the selected engine type.
        Structure is documented below.
        """
        return pulumi.get(self, "engine_features_config")

    @engine_features_config.setter
    def engine_features_config(self, value: Optional[pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigArgs']]):
        pulumi.set(self, "engine_features_config", value)

    @_builtins.property
    @pulumi.getter(name="optimizationObjective")
    def optimization_objective(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The optimization objective. e.g., `cvr`.
        This field together with MediaRecommendationEngineConfig.type describes
        engine metadata to use to control engine training and serving.
        Currently supported values: `ctr`, `cvr`.
        If not specified, we choose default based on engine type. Default depends on type of recommendation:
        `recommended-for-you` => `ctr`
        `others-you-may-like` => `ctr`
        """
        return pulumi.get(self, "optimization_objective")

    @optimization_objective.setter
    def optimization_objective(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "optimization_objective", value)

    @_builtins.property
    @pulumi.getter(name="optimizationObjectiveConfig")
    def optimization_objective_config(self) -> Optional[pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfigArgs']]:
        """
        Name and value of the custom threshold for cvr optimization_objective.
        For target_field `watch-time`, target_field_value must be an integer
        value indicating the media progress time in seconds between (0, 86400]
        (excludes 0, includes 86400) (e.g., 90).
        For target_field `watch-percentage`, the target_field_value must be a
        valid float value between (0, 1.0] (excludes 0, includes 1.0) (e.g., 0.5).
        Structure is documented below.
        """
        return pulumi.get(self, "optimization_objective_config")

    @optimization_objective_config.setter
    def optimization_objective_config(self, value: Optional[pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfigArgs']]):
        pulumi.set(self, "optimization_objective_config", value)

    @_builtins.property
    @pulumi.getter(name="trainingState")
    def training_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The training state that the engine is in (e.g. `TRAINING` or `PAUSED`).
        Since part of the cost of running the service
        is frequency of training - this can be used to determine when to train
        engine in order to control cost. If not specified: the default value for
        `CreateEngine` method is `TRAINING`. The default value for
        `UpdateEngine` method is to keep the state the same as before.
        Possible values are: `PAUSED`, `TRAINING`.
        """
        return pulumi.get(self, "training_state")

    @training_state.setter
    def training_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "training_state", value)

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of engine. e.g., `recommended-for-you`.
        This field together with MediaRecommendationEngineConfig.optimizationObjective describes
        engine metadata to use to control engine training and serving.
        Currently supported values: `recommended-for-you`, `others-you-may-like`,
        `more-like-this`, `most-popular-items`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigArgsDict(TypedDict):
        most_popular_config: NotRequired[pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfigArgsDict']]
        """
        Feature configurations that are required for creating a Most Popular engine.
        Structure is documented below.
        """
        recommended_for_you_config: NotRequired[pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfigArgsDict']]
        """
        Additional feature configurations for creating a `recommended-for-you` engine.
        Structure is documented below.
        """
elif False:
    RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigArgs:
    def __init__(__self__, *,
                 most_popular_config: Optional[pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfigArgs']] = None,
                 recommended_for_you_config: Optional[pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfigArgs']] = None):
        """
        :param pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfigArgs'] most_popular_config: Feature configurations that are required for creating a Most Popular engine.
               Structure is documented below.
        :param pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfigArgs'] recommended_for_you_config: Additional feature configurations for creating a `recommended-for-you` engine.
               Structure is documented below.
        """
        if most_popular_config is not None:
            pulumi.set(__self__, "most_popular_config", most_popular_config)
        if recommended_for_you_config is not None:
            pulumi.set(__self__, "recommended_for_you_config", recommended_for_you_config)

    @_builtins.property
    @pulumi.getter(name="mostPopularConfig")
    def most_popular_config(self) -> Optional[pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfigArgs']]:
        """
        Feature configurations that are required for creating a Most Popular engine.
        Structure is documented below.
        """
        return pulumi.get(self, "most_popular_config")

    @most_popular_config.setter
    def most_popular_config(self, value: Optional[pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfigArgs']]):
        pulumi.set(self, "most_popular_config", value)

    @_builtins.property
    @pulumi.getter(name="recommendedForYouConfig")
    def recommended_for_you_config(self) -> Optional[pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfigArgs']]:
        """
        Additional feature configurations for creating a `recommended-for-you` engine.
        Structure is documented below.
        """
        return pulumi.get(self, "recommended_for_you_config")

    @recommended_for_you_config.setter
    def recommended_for_you_config(self, value: Optional[pulumi.Input['RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfigArgs']]):
        pulumi.set(self, "recommended_for_you_config", value)


if not MYPY:
    class RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfigArgsDict(TypedDict):
        time_window_days: NotRequired[pulumi.Input[_builtins.int]]
        """
        The time window of which the engine is queried at training and
        prediction time. Positive integers only. The value translates to the
        last X days of events. Currently required for the `most-popular-items`
        engine.
        """
elif False:
    RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigMostPopularConfigArgs:
    def __init__(__self__, *,
                 time_window_days: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] time_window_days: The time window of which the engine is queried at training and
               prediction time. Positive integers only. The value translates to the
               last X days of events. Currently required for the `most-popular-items`
               engine.
        """
        if time_window_days is not None:
            pulumi.set(__self__, "time_window_days", time_window_days)

    @_builtins.property
    @pulumi.getter(name="timeWindowDays")
    def time_window_days(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The time window of which the engine is queried at training and
        prediction time. Positive integers only. The value translates to the
        last X days of events. Currently required for the `most-popular-items`
        engine.
        """
        return pulumi.get(self, "time_window_days")

    @time_window_days.setter
    def time_window_days(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "time_window_days", value)


if not MYPY:
    class RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfigArgsDict(TypedDict):
        context_event_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of event with which the engine is queried at prediction time.
        If set to `generic`, only `view-item`, `media-play`,and
        `media-complete` will be used as `context-event` in engine training. If
        set to `view-home-page`, `view-home-page` will also be used as
        `context-events` in addition to `view-item`, `media-play`, and
        `media-complete`. Currently supported for the `recommended-for-you`
        engine. Currently supported values: `view-home-page`, `generic`.
        """
elif False:
    RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecommendationEngineMediaRecommendationEngineConfigEngineFeaturesConfigRecommendedForYouConfigArgs:
    def __init__(__self__, *,
                 context_event_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] context_event_type: The type of event with which the engine is queried at prediction time.
               If set to `generic`, only `view-item`, `media-play`,and
               `media-complete` will be used as `context-event` in engine training. If
               set to `view-home-page`, `view-home-page` will also be used as
               `context-events` in addition to `view-item`, `media-play`, and
               `media-complete`. Currently supported for the `recommended-for-you`
               engine. Currently supported values: `view-home-page`, `generic`.
        """
        if context_event_type is not None:
            pulumi.set(__self__, "context_event_type", context_event_type)

    @_builtins.property
    @pulumi.getter(name="contextEventType")
    def context_event_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of event with which the engine is queried at prediction time.
        If set to `generic`, only `view-item`, `media-play`,and
        `media-complete` will be used as `context-event` in engine training. If
        set to `view-home-page`, `view-home-page` will also be used as
        `context-events` in addition to `view-item`, `media-play`, and
        `media-complete`. Currently supported for the `recommended-for-you`
        engine. Currently supported values: `view-home-page`, `generic`.
        """
        return pulumi.get(self, "context_event_type")

    @context_event_type.setter
    def context_event_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "context_event_type", value)


if not MYPY:
    class RecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfigArgsDict(TypedDict):
        target_field: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the field to target. Currently supported values: `watch-percentage`, `watch-time`.
        """
        target_field_value_float: NotRequired[pulumi.Input[_builtins.float]]
        """
        The threshold to be applied to the target (e.g., 0.5).
        """
elif False:
    RecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class RecommendationEngineMediaRecommendationEngineConfigOptimizationObjectiveConfigArgs:
    def __init__(__self__, *,
                 target_field: Optional[pulumi.Input[_builtins.str]] = None,
                 target_field_value_float: Optional[pulumi.Input[_builtins.float]] = None):
        """
        :param pulumi.Input[_builtins.str] target_field: The name of the field to target. Currently supported values: `watch-percentage`, `watch-time`.
        :param pulumi.Input[_builtins.float] target_field_value_float: The threshold to be applied to the target (e.g., 0.5).
        """
        if target_field is not None:
            pulumi.set(__self__, "target_field", target_field)
        if target_field_value_float is not None:
            pulumi.set(__self__, "target_field_value_float", target_field_value_float)

    @_builtins.property
    @pulumi.getter(name="targetField")
    def target_field(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the field to target. Currently supported values: `watch-percentage`, `watch-time`.
        """
        return pulumi.get(self, "target_field")

    @target_field.setter
    def target_field(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "target_field", value)

    @_builtins.property
    @pulumi.getter(name="targetFieldValueFloat")
    def target_field_value_float(self) -> Optional[pulumi.Input[_builtins.float]]:
        """
        The threshold to be applied to the target (e.g., 0.5).
        """
        return pulumi.get(self, "target_field_value_float")

    @target_field_value_float.setter
    def target_field_value_float(self, value: Optional[pulumi.Input[_builtins.float]]):
        pulumi.set(self, "target_field_value_float", value)


if not MYPY:
    class SearchEngineCommonConfigArgsDict(TypedDict):
        company_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.cd
        """
elif False:
    SearchEngineCommonConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SearchEngineCommonConfigArgs:
    def __init__(__self__, *,
                 company_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] company_name: The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.cd
        """
        if company_name is not None:
            pulumi.set(__self__, "company_name", company_name)

    @_builtins.property
    @pulumi.getter(name="companyName")
    def company_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The name of the company, business or entity that is associated with the engine. Setting this may help improve LLM related features.cd
        """
        return pulumi.get(self, "company_name")

    @company_name.setter
    def company_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "company_name", value)


if not MYPY:
    class SearchEngineSearchEngineConfigArgsDict(TypedDict):
        search_add_ons: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The add-on that this search engine enables.
        Each value may be one of: `SEARCH_ADD_ON_LLM`.
        """
        search_tier: NotRequired[pulumi.Input[_builtins.str]]
        """
        The search feature tier of this engine. Defaults to SearchTier.SEARCH_TIER_STANDARD if not specified.
        Default value is `SEARCH_TIER_STANDARD`.
        Possible values are: `SEARCH_TIER_STANDARD`, `SEARCH_TIER_ENTERPRISE`.
        """
elif False:
    SearchEngineSearchEngineConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SearchEngineSearchEngineConfigArgs:
    def __init__(__self__, *,
                 search_add_ons: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 search_tier: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] search_add_ons: The add-on that this search engine enables.
               Each value may be one of: `SEARCH_ADD_ON_LLM`.
        :param pulumi.Input[_builtins.str] search_tier: The search feature tier of this engine. Defaults to SearchTier.SEARCH_TIER_STANDARD if not specified.
               Default value is `SEARCH_TIER_STANDARD`.
               Possible values are: `SEARCH_TIER_STANDARD`, `SEARCH_TIER_ENTERPRISE`.
        """
        if search_add_ons is not None:
            pulumi.set(__self__, "search_add_ons", search_add_ons)
        if search_tier is not None:
            pulumi.set(__self__, "search_tier", search_tier)

    @_builtins.property
    @pulumi.getter(name="searchAddOns")
    def search_add_ons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The add-on that this search engine enables.
        Each value may be one of: `SEARCH_ADD_ON_LLM`.
        """
        return pulumi.get(self, "search_add_ons")

    @search_add_ons.setter
    def search_add_ons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "search_add_ons", value)

    @_builtins.property
    @pulumi.getter(name="searchTier")
    def search_tier(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The search feature tier of this engine. Defaults to SearchTier.SEARCH_TIER_STANDARD if not specified.
        Default value is `SEARCH_TIER_STANDARD`.
        Possible values are: `SEARCH_TIER_STANDARD`, `SEARCH_TIER_ENTERPRISE`.
        """
        return pulumi.get(self, "search_tier")

    @search_tier.setter
    def search_tier(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "search_tier", value)


if not MYPY:
    class TargetSiteFailureReasonArgsDict(TypedDict):
        quota_failure: NotRequired[pulumi.Input['TargetSiteFailureReasonQuotaFailureArgsDict']]
        """
        Site verification state indicating the ownership and validity.
        Structure is documented below.
        """
elif False:
    TargetSiteFailureReasonArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetSiteFailureReasonArgs:
    def __init__(__self__, *,
                 quota_failure: Optional[pulumi.Input['TargetSiteFailureReasonQuotaFailureArgs']] = None):
        """
        :param pulumi.Input['TargetSiteFailureReasonQuotaFailureArgs'] quota_failure: Site verification state indicating the ownership and validity.
               Structure is documented below.
        """
        if quota_failure is not None:
            pulumi.set(__self__, "quota_failure", quota_failure)

    @_builtins.property
    @pulumi.getter(name="quotaFailure")
    def quota_failure(self) -> Optional[pulumi.Input['TargetSiteFailureReasonQuotaFailureArgs']]:
        """
        Site verification state indicating the ownership and validity.
        Structure is documented below.
        """
        return pulumi.get(self, "quota_failure")

    @quota_failure.setter
    def quota_failure(self, value: Optional[pulumi.Input['TargetSiteFailureReasonQuotaFailureArgs']]):
        pulumi.set(self, "quota_failure", value)


if not MYPY:
    class TargetSiteFailureReasonQuotaFailureArgsDict(TypedDict):
        total_required_quota: NotRequired[pulumi.Input[_builtins.int]]
        """
        This number is an estimation on how much total quota this project
        needs to successfully complete indexing.
        """
elif False:
    TargetSiteFailureReasonQuotaFailureArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetSiteFailureReasonQuotaFailureArgs:
    def __init__(__self__, *,
                 total_required_quota: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] total_required_quota: This number is an estimation on how much total quota this project
               needs to successfully complete indexing.
        """
        if total_required_quota is not None:
            pulumi.set(__self__, "total_required_quota", total_required_quota)

    @_builtins.property
    @pulumi.getter(name="totalRequiredQuota")
    def total_required_quota(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        This number is an estimation on how much total quota this project
        needs to successfully complete indexing.
        """
        return pulumi.get(self, "total_required_quota")

    @total_required_quota.setter
    def total_required_quota(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "total_required_quota", value)


if not MYPY:
    class TargetSiteSiteVerificationInfoArgsDict(TypedDict):
        site_verification_state: NotRequired[pulumi.Input[_builtins.str]]
        """
        Site verification state indicating the ownership and validity.
        Possible values are: `VERIFIED`, `UNVERIFIED`, `EXEMPTED`.
        """
        verify_time: NotRequired[pulumi.Input[_builtins.str]]
        """
        Latest site verification time.
        """
elif False:
    TargetSiteSiteVerificationInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetSiteSiteVerificationInfoArgs:
    def __init__(__self__, *,
                 site_verification_state: Optional[pulumi.Input[_builtins.str]] = None,
                 verify_time: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] site_verification_state: Site verification state indicating the ownership and validity.
               Possible values are: `VERIFIED`, `UNVERIFIED`, `EXEMPTED`.
        :param pulumi.Input[_builtins.str] verify_time: Latest site verification time.
        """
        if site_verification_state is not None:
            pulumi.set(__self__, "site_verification_state", site_verification_state)
        if verify_time is not None:
            pulumi.set(__self__, "verify_time", verify_time)

    @_builtins.property
    @pulumi.getter(name="siteVerificationState")
    def site_verification_state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Site verification state indicating the ownership and validity.
        Possible values are: `VERIFIED`, `UNVERIFIED`, `EXEMPTED`.
        """
        return pulumi.get(self, "site_verification_state")

    @site_verification_state.setter
    def site_verification_state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "site_verification_state", value)

    @_builtins.property
    @pulumi.getter(name="verifyTime")
    def verify_time(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Latest site verification time.
        """
        return pulumi.get(self, "verify_time")

    @verify_time.setter
    def verify_time(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "verify_time", value)


