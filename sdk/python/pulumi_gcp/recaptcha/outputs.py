# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Callable, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'EnterpriseKeyAndroidSettings',
    'EnterpriseKeyIosSettings',
    'EnterpriseKeyTestingOptions',
    'EnterpriseKeyWebSettings',
]

@pulumi.output_type
class EnterpriseKeyAndroidSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowAllPackageNames":
            suggest = "allow_all_package_names"
        elif key == "allowedPackageNames":
            suggest = "allowed_package_names"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnterpriseKeyAndroidSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnterpriseKeyAndroidSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnterpriseKeyAndroidSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_all_package_names: Optional[bool] = None,
                 allowed_package_names: Optional[Sequence[str]] = None):
        """
        :param bool allow_all_package_names: If set to true, it means allowed_package_names will not be enforced.
        :param Sequence[str] allowed_package_names: Android package names of apps allowed to use the key. Example: 'com.companyname.appname'
        """
        EnterpriseKeyAndroidSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_all_package_names=allow_all_package_names,
            allowed_package_names=allowed_package_names,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_all_package_names: Optional[bool] = None,
             allowed_package_names: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if allow_all_package_names is not None:
            _setter("allow_all_package_names", allow_all_package_names)
        if allowed_package_names is not None:
            _setter("allowed_package_names", allowed_package_names)

    @property
    @pulumi.getter(name="allowAllPackageNames")
    def allow_all_package_names(self) -> Optional[bool]:
        """
        If set to true, it means allowed_package_names will not be enforced.
        """
        return pulumi.get(self, "allow_all_package_names")

    @property
    @pulumi.getter(name="allowedPackageNames")
    def allowed_package_names(self) -> Optional[Sequence[str]]:
        """
        Android package names of apps allowed to use the key. Example: 'com.companyname.appname'
        """
        return pulumi.get(self, "allowed_package_names")


@pulumi.output_type
class EnterpriseKeyIosSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "allowAllBundleIds":
            suggest = "allow_all_bundle_ids"
        elif key == "allowedBundleIds":
            suggest = "allowed_bundle_ids"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnterpriseKeyIosSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnterpriseKeyIosSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnterpriseKeyIosSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 allow_all_bundle_ids: Optional[bool] = None,
                 allowed_bundle_ids: Optional[Sequence[str]] = None):
        """
        :param bool allow_all_bundle_ids: If set to true, it means allowed_bundle_ids will not be enforced.
        :param Sequence[str] allowed_bundle_ids: iOS bundle ids of apps allowed to use the key. Example: 'com.companyname.productname.appname'
        """
        EnterpriseKeyIosSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            allow_all_bundle_ids=allow_all_bundle_ids,
            allowed_bundle_ids=allowed_bundle_ids,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             allow_all_bundle_ids: Optional[bool] = None,
             allowed_bundle_ids: Optional[Sequence[str]] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if allow_all_bundle_ids is not None:
            _setter("allow_all_bundle_ids", allow_all_bundle_ids)
        if allowed_bundle_ids is not None:
            _setter("allowed_bundle_ids", allowed_bundle_ids)

    @property
    @pulumi.getter(name="allowAllBundleIds")
    def allow_all_bundle_ids(self) -> Optional[bool]:
        """
        If set to true, it means allowed_bundle_ids will not be enforced.
        """
        return pulumi.get(self, "allow_all_bundle_ids")

    @property
    @pulumi.getter(name="allowedBundleIds")
    def allowed_bundle_ids(self) -> Optional[Sequence[str]]:
        """
        iOS bundle ids of apps allowed to use the key. Example: 'com.companyname.productname.appname'
        """
        return pulumi.get(self, "allowed_bundle_ids")


@pulumi.output_type
class EnterpriseKeyTestingOptions(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "testingChallenge":
            suggest = "testing_challenge"
        elif key == "testingScore":
            suggest = "testing_score"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnterpriseKeyTestingOptions. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnterpriseKeyTestingOptions.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnterpriseKeyTestingOptions.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 testing_challenge: Optional[str] = None,
                 testing_score: Optional[float] = None):
        """
        :param str testing_challenge: For challenge-based keys only (CHECKBOX, INVISIBLE), all challenge requests for this site will return nocaptcha if NOCAPTCHA, or an unsolvable challenge if UNSOLVABLE_CHALLENGE. Possible values: TESTING_CHALLENGE_UNSPECIFIED, NOCAPTCHA, UNSOLVABLE_CHALLENGE
        :param float testing_score: All assessments for this Key will return this score. Must be between 0 (likely not legitimate) and 1 (likely legitimate) inclusive.
        """
        EnterpriseKeyTestingOptions._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            testing_challenge=testing_challenge,
            testing_score=testing_score,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             testing_challenge: Optional[str] = None,
             testing_score: Optional[float] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        if testing_challenge is not None:
            _setter("testing_challenge", testing_challenge)
        if testing_score is not None:
            _setter("testing_score", testing_score)

    @property
    @pulumi.getter(name="testingChallenge")
    def testing_challenge(self) -> Optional[str]:
        """
        For challenge-based keys only (CHECKBOX, INVISIBLE), all challenge requests for this site will return nocaptcha if NOCAPTCHA, or an unsolvable challenge if UNSOLVABLE_CHALLENGE. Possible values: TESTING_CHALLENGE_UNSPECIFIED, NOCAPTCHA, UNSOLVABLE_CHALLENGE
        """
        return pulumi.get(self, "testing_challenge")

    @property
    @pulumi.getter(name="testingScore")
    def testing_score(self) -> Optional[float]:
        """
        All assessments for this Key will return this score. Must be between 0 (likely not legitimate) and 1 (likely legitimate) inclusive.
        """
        return pulumi.get(self, "testing_score")


@pulumi.output_type
class EnterpriseKeyWebSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "integrationType":
            suggest = "integration_type"
        elif key == "allowAllDomains":
            suggest = "allow_all_domains"
        elif key == "allowAmpTraffic":
            suggest = "allow_amp_traffic"
        elif key == "allowedDomains":
            suggest = "allowed_domains"
        elif key == "challengeSecurityPreference":
            suggest = "challenge_security_preference"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in EnterpriseKeyWebSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        EnterpriseKeyWebSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        EnterpriseKeyWebSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 integration_type: str,
                 allow_all_domains: Optional[bool] = None,
                 allow_amp_traffic: Optional[bool] = None,
                 allowed_domains: Optional[Sequence[str]] = None,
                 challenge_security_preference: Optional[str] = None):
        """
        :param str integration_type: Required. Describes how this key is integrated with the website. Possible values: SCORE, CHECKBOX, INVISIBLE
        :param bool allow_all_domains: If set to true, it means allowed_domains will not be enforced.
        :param bool allow_amp_traffic: If set to true, the key can be used on AMP (Accelerated Mobile Pages) websites. This is supported only for the SCORE integration type.
        :param Sequence[str] allowed_domains: Domains or subdomains of websites allowed to use the key. All subdomains of an allowed domain are automatically allowed. A valid domain requires a host and must not include any path, port, query or fragment. Examples: 'example.com' or 'subdomain.example.com'
        :param str challenge_security_preference: Settings for the frequency and difficulty at which this key triggers captcha challenges. This should only be specified for IntegrationTypes CHECKBOX and INVISIBLE. Possible values: CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED, USABILITY, BALANCE, SECURITY
        """
        EnterpriseKeyWebSettings._configure(
            lambda key, value: pulumi.set(__self__, key, value),
            integration_type=integration_type,
            allow_all_domains=allow_all_domains,
            allow_amp_traffic=allow_amp_traffic,
            allowed_domains=allowed_domains,
            challenge_security_preference=challenge_security_preference,
        )
    @staticmethod
    def _configure(
             _setter: Callable[[Any, Any], None],
             integration_type: str,
             allow_all_domains: Optional[bool] = None,
             allow_amp_traffic: Optional[bool] = None,
             allowed_domains: Optional[Sequence[str]] = None,
             challenge_security_preference: Optional[str] = None,
             opts: Optional[pulumi.ResourceOptions]=None):
        _setter("integration_type", integration_type)
        if allow_all_domains is not None:
            _setter("allow_all_domains", allow_all_domains)
        if allow_amp_traffic is not None:
            _setter("allow_amp_traffic", allow_amp_traffic)
        if allowed_domains is not None:
            _setter("allowed_domains", allowed_domains)
        if challenge_security_preference is not None:
            _setter("challenge_security_preference", challenge_security_preference)

    @property
    @pulumi.getter(name="integrationType")
    def integration_type(self) -> str:
        """
        Required. Describes how this key is integrated with the website. Possible values: SCORE, CHECKBOX, INVISIBLE
        """
        return pulumi.get(self, "integration_type")

    @property
    @pulumi.getter(name="allowAllDomains")
    def allow_all_domains(self) -> Optional[bool]:
        """
        If set to true, it means allowed_domains will not be enforced.
        """
        return pulumi.get(self, "allow_all_domains")

    @property
    @pulumi.getter(name="allowAmpTraffic")
    def allow_amp_traffic(self) -> Optional[bool]:
        """
        If set to true, the key can be used on AMP (Accelerated Mobile Pages) websites. This is supported only for the SCORE integration type.
        """
        return pulumi.get(self, "allow_amp_traffic")

    @property
    @pulumi.getter(name="allowedDomains")
    def allowed_domains(self) -> Optional[Sequence[str]]:
        """
        Domains or subdomains of websites allowed to use the key. All subdomains of an allowed domain are automatically allowed. A valid domain requires a host and must not include any path, port, query or fragment. Examples: 'example.com' or 'subdomain.example.com'
        """
        return pulumi.get(self, "allowed_domains")

    @property
    @pulumi.getter(name="challengeSecurityPreference")
    def challenge_security_preference(self) -> Optional[str]:
        """
        Settings for the frequency and difficulty at which this key triggers captcha challenges. This should only be specified for IntegrationTypes CHECKBOX and INVISIBLE. Possible values: CHALLENGE_SECURITY_PREFERENCE_UNSPECIFIED, USABILITY, BALANCE, SECURITY
        """
        return pulumi.get(self, "challenge_security_preference")


