# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AuthorizedViewSubsetViewArgs',
    'AuthorizedViewSubsetViewArgsDict',
    'AuthorizedViewSubsetViewFamilySubsetArgs',
    'AuthorizedViewSubsetViewFamilySubsetArgsDict',
    'GCPolicyMaxAgeArgs',
    'GCPolicyMaxAgeArgsDict',
    'GCPolicyMaxVersionArgs',
    'GCPolicyMaxVersionArgsDict',
    'InstanceClusterArgs',
    'InstanceClusterArgsDict',
    'InstanceClusterAutoscalingConfigArgs',
    'InstanceClusterAutoscalingConfigArgsDict',
    'InstanceIamBindingConditionArgs',
    'InstanceIamBindingConditionArgsDict',
    'InstanceIamMemberConditionArgs',
    'InstanceIamMemberConditionArgsDict',
    'TableAutomatedBackupPolicyArgs',
    'TableAutomatedBackupPolicyArgsDict',
    'TableColumnFamilyArgs',
    'TableColumnFamilyArgsDict',
    'TableIamBindingConditionArgs',
    'TableIamBindingConditionArgsDict',
    'TableIamMemberConditionArgs',
    'TableIamMemberConditionArgsDict',
]

MYPY = False

if not MYPY:
    class AuthorizedViewSubsetViewArgsDict(TypedDict):
        family_subsets: NotRequired[pulumi.Input[Sequence[pulumi.Input['AuthorizedViewSubsetViewFamilySubsetArgsDict']]]]
        """
        A group of column family subsets to be included in the authorized view. This can be specified multiple times. Structure is documented below.

        -----
        """
        row_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of Base64-encoded row prefixes to be included in the authorized view. To provide access to all rows, include the empty string as a prefix ("").
        """
elif False:
    AuthorizedViewSubsetViewArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizedViewSubsetViewArgs:
    def __init__(__self__, *,
                 family_subsets: Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizedViewSubsetViewFamilySubsetArgs']]]] = None,
                 row_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['AuthorizedViewSubsetViewFamilySubsetArgs']]] family_subsets: A group of column family subsets to be included in the authorized view. This can be specified multiple times. Structure is documented below.
               
               -----
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] row_prefixes: A list of Base64-encoded row prefixes to be included in the authorized view. To provide access to all rows, include the empty string as a prefix ("").
        """
        if family_subsets is not None:
            pulumi.set(__self__, "family_subsets", family_subsets)
        if row_prefixes is not None:
            pulumi.set(__self__, "row_prefixes", row_prefixes)

    @property
    @pulumi.getter(name="familySubsets")
    def family_subsets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizedViewSubsetViewFamilySubsetArgs']]]]:
        """
        A group of column family subsets to be included in the authorized view. This can be specified multiple times. Structure is documented below.

        -----
        """
        return pulumi.get(self, "family_subsets")

    @family_subsets.setter
    def family_subsets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['AuthorizedViewSubsetViewFamilySubsetArgs']]]]):
        pulumi.set(self, "family_subsets", value)

    @property
    @pulumi.getter(name="rowPrefixes")
    def row_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of Base64-encoded row prefixes to be included in the authorized view. To provide access to all rows, include the empty string as a prefix ("").
        """
        return pulumi.get(self, "row_prefixes")

    @row_prefixes.setter
    def row_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "row_prefixes", value)


if not MYPY:
    class AuthorizedViewSubsetViewFamilySubsetArgsDict(TypedDict):
        family_name: pulumi.Input[builtins.str]
        """
        Name of the column family to be included in the authorized view. The specified column family must exist in the parent table of this authorized view.
        """
        qualifier_prefixes: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of Base64-encoded prefixes for qualifiers of the column family to be included in the authorized view.
        Every qualifier starting with one of these prefixes is included in the authorized view. To provide access to all qualifiers, include the empty string as a prefix ("").
        """
        qualifiers: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A list of Base64-encoded individual exact column qualifiers of the column family to be included in the authorized view.
        """
elif False:
    AuthorizedViewSubsetViewFamilySubsetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AuthorizedViewSubsetViewFamilySubsetArgs:
    def __init__(__self__, *,
                 family_name: pulumi.Input[builtins.str],
                 qualifier_prefixes: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 qualifiers: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] family_name: Name of the column family to be included in the authorized view. The specified column family must exist in the parent table of this authorized view.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] qualifier_prefixes: A list of Base64-encoded prefixes for qualifiers of the column family to be included in the authorized view.
               Every qualifier starting with one of these prefixes is included in the authorized view. To provide access to all qualifiers, include the empty string as a prefix ("").
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] qualifiers: A list of Base64-encoded individual exact column qualifiers of the column family to be included in the authorized view.
        """
        pulumi.set(__self__, "family_name", family_name)
        if qualifier_prefixes is not None:
            pulumi.set(__self__, "qualifier_prefixes", qualifier_prefixes)
        if qualifiers is not None:
            pulumi.set(__self__, "qualifiers", qualifiers)

    @property
    @pulumi.getter(name="familyName")
    def family_name(self) -> pulumi.Input[builtins.str]:
        """
        Name of the column family to be included in the authorized view. The specified column family must exist in the parent table of this authorized view.
        """
        return pulumi.get(self, "family_name")

    @family_name.setter
    def family_name(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "family_name", value)

    @property
    @pulumi.getter(name="qualifierPrefixes")
    def qualifier_prefixes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of Base64-encoded prefixes for qualifiers of the column family to be included in the authorized view.
        Every qualifier starting with one of these prefixes is included in the authorized view. To provide access to all qualifiers, include the empty string as a prefix ("").
        """
        return pulumi.get(self, "qualifier_prefixes")

    @qualifier_prefixes.setter
    def qualifier_prefixes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "qualifier_prefixes", value)

    @property
    @pulumi.getter
    def qualifiers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A list of Base64-encoded individual exact column qualifiers of the column family to be included in the authorized view.
        """
        return pulumi.get(self, "qualifiers")

    @qualifiers.setter
    def qualifiers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "qualifiers", value)


if not MYPY:
    class GCPolicyMaxAgeArgsDict(TypedDict):
        days: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of days before applying GC policy.
        """
        duration: NotRequired[pulumi.Input[builtins.str]]
        """
        Duration before applying GC policy (ex. "8h"). This is required when `days` isn't set

        -----
        """
elif False:
    GCPolicyMaxAgeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GCPolicyMaxAgeArgs:
    def __init__(__self__, *,
                 days: Optional[pulumi.Input[builtins.int]] = None,
                 duration: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.int] days: Number of days before applying GC policy.
        :param pulumi.Input[builtins.str] duration: Duration before applying GC policy (ex. "8h"). This is required when `days` isn't set
               
               -----
        """
        if days is not None:
            warnings.warn("""Deprecated in favor of duration""", DeprecationWarning)
            pulumi.log.warn("""days is deprecated: Deprecated in favor of duration""")
        if days is not None:
            pulumi.set(__self__, "days", days)
        if duration is not None:
            pulumi.set(__self__, "duration", duration)

    @property
    @pulumi.getter
    @_utilities.deprecated("""Deprecated in favor of duration""")
    def days(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of days before applying GC policy.
        """
        return pulumi.get(self, "days")

    @days.setter
    def days(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "days", value)

    @property
    @pulumi.getter
    def duration(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Duration before applying GC policy (ex. "8h"). This is required when `days` isn't set

        -----
        """
        return pulumi.get(self, "duration")

    @duration.setter
    def duration(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "duration", value)


if not MYPY:
    class GCPolicyMaxVersionArgsDict(TypedDict):
        number: pulumi.Input[builtins.int]
        """
        Number of version before applying the GC policy.

        -----
        `gc_rules` include 2 fields:
        """
elif False:
    GCPolicyMaxVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class GCPolicyMaxVersionArgs:
    def __init__(__self__, *,
                 number: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.int] number: Number of version before applying the GC policy.
               
               -----
               `gc_rules` include 2 fields:
        """
        pulumi.set(__self__, "number", number)

    @property
    @pulumi.getter
    def number(self) -> pulumi.Input[builtins.int]:
        """
        Number of version before applying the GC policy.

        -----
        `gc_rules` include 2 fields:
        """
        return pulumi.get(self, "number")

    @number.setter
    def number(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "number", value)


if not MYPY:
    class InstanceClusterArgsDict(TypedDict):
        cluster_id: pulumi.Input[builtins.str]
        """
        The ID of the Cloud Bigtable cluster. Must be 6-30 characters and must only contain hyphens, lowercase letters and numbers.
        """
        autoscaling_config: NotRequired[pulumi.Input['InstanceClusterAutoscalingConfigArgsDict']]
        """
        [Autoscaling](https://cloud.google.com/bigtable/docs/autoscaling#parameters) config for the cluster, contains the following arguments:
        """
        kms_key_name: NotRequired[pulumi.Input[builtins.str]]
        """
        Describes the Cloud KMS encryption key that will be used to protect the destination Bigtable cluster. The requirements for this key are: 1) The Cloud Bigtable service account associated with the project that contains this cluster must be granted the `cloudkms.cryptoKeyEncrypterDecrypter` role on the CMEK key. 2) Only regional keys can be used and the region of the CMEK key must match the region of the cluster.
        """
        node_scaling_factor: NotRequired[pulumi.Input[builtins.str]]
        """
        The node scaling factor for this cluster. One of `"NodeScalingFactor1X"` or `"NodeScalingFactor2X"`. Defaults to `"NodeScalingFactor1X"`. If `"NodeScalingFactor2X"` is specified, then `num_nodes`, `min_nodes`, and `max_nodes` would need to be specified in increments of 2. This value cannot be updated after the cluster is created.

        > **Note**: Removing the field entirely from the config will cause the provider to default to the backend value.

        !> **Warning**: Modifying this field will cause the provider to delete/recreate the entire resource.

        !> **Warning:** Modifying the `storage_type`, `zone` or `kms_key_name` of an existing cluster (by
        `cluster_id`) will cause the provider to delete/recreate the entire
        `bigtable.Instance` resource. If these values are changing, use a new
        `cluster_id`.
        """
        num_nodes: NotRequired[pulumi.Input[builtins.int]]
        """
        The number of nodes in the cluster.
        If no value is set, Cloud Bigtable automatically allocates nodes based on your data footprint and optimized for 50% storage utilization.
        """
        state: NotRequired[pulumi.Input[builtins.str]]
        """
        describes the current state of the cluster.
        """
        storage_type: NotRequired[pulumi.Input[builtins.str]]
        """
        The storage type to use. One of `"SSD"` or
        `"HDD"`. Defaults to `"SSD"`.
        """
        zone: NotRequired[pulumi.Input[builtins.str]]
        """
        The zone to create the Cloud Bigtable cluster in. If it not
        specified, the provider zone is used. Each cluster must have a different zone in the same region. Zones that support
        Bigtable instances are noted on the [Cloud Bigtable locations page](https://cloud.google.com/bigtable/docs/locations).
        """
elif False:
    InstanceClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceClusterArgs:
    def __init__(__self__, *,
                 cluster_id: pulumi.Input[builtins.str],
                 autoscaling_config: Optional[pulumi.Input['InstanceClusterAutoscalingConfigArgs']] = None,
                 kms_key_name: Optional[pulumi.Input[builtins.str]] = None,
                 node_scaling_factor: Optional[pulumi.Input[builtins.str]] = None,
                 num_nodes: Optional[pulumi.Input[builtins.int]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 storage_type: Optional[pulumi.Input[builtins.str]] = None,
                 zone: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] cluster_id: The ID of the Cloud Bigtable cluster. Must be 6-30 characters and must only contain hyphens, lowercase letters and numbers.
        :param pulumi.Input['InstanceClusterAutoscalingConfigArgs'] autoscaling_config: [Autoscaling](https://cloud.google.com/bigtable/docs/autoscaling#parameters) config for the cluster, contains the following arguments:
        :param pulumi.Input[builtins.str] kms_key_name: Describes the Cloud KMS encryption key that will be used to protect the destination Bigtable cluster. The requirements for this key are: 1) The Cloud Bigtable service account associated with the project that contains this cluster must be granted the `cloudkms.cryptoKeyEncrypterDecrypter` role on the CMEK key. 2) Only regional keys can be used and the region of the CMEK key must match the region of the cluster.
        :param pulumi.Input[builtins.str] node_scaling_factor: The node scaling factor for this cluster. One of `"NodeScalingFactor1X"` or `"NodeScalingFactor2X"`. Defaults to `"NodeScalingFactor1X"`. If `"NodeScalingFactor2X"` is specified, then `num_nodes`, `min_nodes`, and `max_nodes` would need to be specified in increments of 2. This value cannot be updated after the cluster is created.
               
               > **Note**: Removing the field entirely from the config will cause the provider to default to the backend value.
               
               !> **Warning**: Modifying this field will cause the provider to delete/recreate the entire resource.
               
               !> **Warning:** Modifying the `storage_type`, `zone` or `kms_key_name` of an existing cluster (by
               `cluster_id`) will cause the provider to delete/recreate the entire
               `bigtable.Instance` resource. If these values are changing, use a new
               `cluster_id`.
        :param pulumi.Input[builtins.int] num_nodes: The number of nodes in the cluster.
               If no value is set, Cloud Bigtable automatically allocates nodes based on your data footprint and optimized for 50% storage utilization.
        :param pulumi.Input[builtins.str] state: describes the current state of the cluster.
        :param pulumi.Input[builtins.str] storage_type: The storage type to use. One of `"SSD"` or
               `"HDD"`. Defaults to `"SSD"`.
        :param pulumi.Input[builtins.str] zone: The zone to create the Cloud Bigtable cluster in. If it not
               specified, the provider zone is used. Each cluster must have a different zone in the same region. Zones that support
               Bigtable instances are noted on the [Cloud Bigtable locations page](https://cloud.google.com/bigtable/docs/locations).
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        if autoscaling_config is not None:
            pulumi.set(__self__, "autoscaling_config", autoscaling_config)
        if kms_key_name is not None:
            pulumi.set(__self__, "kms_key_name", kms_key_name)
        if node_scaling_factor is not None:
            pulumi.set(__self__, "node_scaling_factor", node_scaling_factor)
        if num_nodes is not None:
            pulumi.set(__self__, "num_nodes", num_nodes)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if storage_type is not None:
            pulumi.set(__self__, "storage_type", storage_type)
        if zone is not None:
            pulumi.set(__self__, "zone", zone)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> pulumi.Input[builtins.str]:
        """
        The ID of the Cloud Bigtable cluster. Must be 6-30 characters and must only contain hyphens, lowercase letters and numbers.
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="autoscalingConfig")
    def autoscaling_config(self) -> Optional[pulumi.Input['InstanceClusterAutoscalingConfigArgs']]:
        """
        [Autoscaling](https://cloud.google.com/bigtable/docs/autoscaling#parameters) config for the cluster, contains the following arguments:
        """
        return pulumi.get(self, "autoscaling_config")

    @autoscaling_config.setter
    def autoscaling_config(self, value: Optional[pulumi.Input['InstanceClusterAutoscalingConfigArgs']]):
        pulumi.set(self, "autoscaling_config", value)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Describes the Cloud KMS encryption key that will be used to protect the destination Bigtable cluster. The requirements for this key are: 1) The Cloud Bigtable service account associated with the project that contains this cluster must be granted the `cloudkms.cryptoKeyEncrypterDecrypter` role on the CMEK key. 2) Only regional keys can be used and the region of the CMEK key must match the region of the cluster.
        """
        return pulumi.get(self, "kms_key_name")

    @kms_key_name.setter
    def kms_key_name(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "kms_key_name", value)

    @property
    @pulumi.getter(name="nodeScalingFactor")
    def node_scaling_factor(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The node scaling factor for this cluster. One of `"NodeScalingFactor1X"` or `"NodeScalingFactor2X"`. Defaults to `"NodeScalingFactor1X"`. If `"NodeScalingFactor2X"` is specified, then `num_nodes`, `min_nodes`, and `max_nodes` would need to be specified in increments of 2. This value cannot be updated after the cluster is created.

        > **Note**: Removing the field entirely from the config will cause the provider to default to the backend value.

        !> **Warning**: Modifying this field will cause the provider to delete/recreate the entire resource.

        !> **Warning:** Modifying the `storage_type`, `zone` or `kms_key_name` of an existing cluster (by
        `cluster_id`) will cause the provider to delete/recreate the entire
        `bigtable.Instance` resource. If these values are changing, use a new
        `cluster_id`.
        """
        return pulumi.get(self, "node_scaling_factor")

    @node_scaling_factor.setter
    def node_scaling_factor(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "node_scaling_factor", value)

    @property
    @pulumi.getter(name="numNodes")
    def num_nodes(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The number of nodes in the cluster.
        If no value is set, Cloud Bigtable automatically allocates nodes based on your data footprint and optimized for 50% storage utilization.
        """
        return pulumi.get(self, "num_nodes")

    @num_nodes.setter
    def num_nodes(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "num_nodes", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        describes the current state of the cluster.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter(name="storageType")
    def storage_type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The storage type to use. One of `"SSD"` or
        `"HDD"`. Defaults to `"SSD"`.
        """
        return pulumi.get(self, "storage_type")

    @storage_type.setter
    def storage_type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "storage_type", value)

    @property
    @pulumi.getter
    def zone(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The zone to create the Cloud Bigtable cluster in. If it not
        specified, the provider zone is used. Each cluster must have a different zone in the same region. Zones that support
        Bigtable instances are noted on the [Cloud Bigtable locations page](https://cloud.google.com/bigtable/docs/locations).
        """
        return pulumi.get(self, "zone")

    @zone.setter
    def zone(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "zone", value)


if not MYPY:
    class InstanceClusterAutoscalingConfigArgsDict(TypedDict):
        cpu_target: pulumi.Input[builtins.int]
        """
        The target CPU utilization for autoscaling, in percentage. Must be between 10 and 80.
        """
        max_nodes: pulumi.Input[builtins.int]
        """
        The maximum number of nodes for autoscaling.
        """
        min_nodes: pulumi.Input[builtins.int]
        """
        The minimum number of nodes for autoscaling.
        """
        storage_target: NotRequired[pulumi.Input[builtins.int]]
        """
        The target storage utilization for autoscaling, in GB, for each node in a cluster. This number is limited between 2560 (2.5TiB) and 5120 (5TiB) for a SSD cluster and between 8192 (8TiB) and 16384 (16 TiB) for an HDD cluster. If not set, whatever is already set for the cluster will not change, or if the cluster is just being created, it will use the default value of 2560 for SSD clusters and 8192 for HDD clusters.

        !> **Warning**: Only one of `autoscaling_config` or `num_nodes` should be set for a cluster. If both are set, `num_nodes` is ignored. If none is set, autoscaling will be disabled and sized to the current node count.
        """
elif False:
    InstanceClusterAutoscalingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceClusterAutoscalingConfigArgs:
    def __init__(__self__, *,
                 cpu_target: pulumi.Input[builtins.int],
                 max_nodes: pulumi.Input[builtins.int],
                 min_nodes: pulumi.Input[builtins.int],
                 storage_target: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] cpu_target: The target CPU utilization for autoscaling, in percentage. Must be between 10 and 80.
        :param pulumi.Input[builtins.int] max_nodes: The maximum number of nodes for autoscaling.
        :param pulumi.Input[builtins.int] min_nodes: The minimum number of nodes for autoscaling.
        :param pulumi.Input[builtins.int] storage_target: The target storage utilization for autoscaling, in GB, for each node in a cluster. This number is limited between 2560 (2.5TiB) and 5120 (5TiB) for a SSD cluster and between 8192 (8TiB) and 16384 (16 TiB) for an HDD cluster. If not set, whatever is already set for the cluster will not change, or if the cluster is just being created, it will use the default value of 2560 for SSD clusters and 8192 for HDD clusters.
               
               !> **Warning**: Only one of `autoscaling_config` or `num_nodes` should be set for a cluster. If both are set, `num_nodes` is ignored. If none is set, autoscaling will be disabled and sized to the current node count.
        """
        pulumi.set(__self__, "cpu_target", cpu_target)
        pulumi.set(__self__, "max_nodes", max_nodes)
        pulumi.set(__self__, "min_nodes", min_nodes)
        if storage_target is not None:
            pulumi.set(__self__, "storage_target", storage_target)

    @property
    @pulumi.getter(name="cpuTarget")
    def cpu_target(self) -> pulumi.Input[builtins.int]:
        """
        The target CPU utilization for autoscaling, in percentage. Must be between 10 and 80.
        """
        return pulumi.get(self, "cpu_target")

    @cpu_target.setter
    def cpu_target(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "cpu_target", value)

    @property
    @pulumi.getter(name="maxNodes")
    def max_nodes(self) -> pulumi.Input[builtins.int]:
        """
        The maximum number of nodes for autoscaling.
        """
        return pulumi.get(self, "max_nodes")

    @max_nodes.setter
    def max_nodes(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "max_nodes", value)

    @property
    @pulumi.getter(name="minNodes")
    def min_nodes(self) -> pulumi.Input[builtins.int]:
        """
        The minimum number of nodes for autoscaling.
        """
        return pulumi.get(self, "min_nodes")

    @min_nodes.setter
    def min_nodes(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "min_nodes", value)

    @property
    @pulumi.getter(name="storageTarget")
    def storage_target(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        The target storage utilization for autoscaling, in GB, for each node in a cluster. This number is limited between 2560 (2.5TiB) and 5120 (5TiB) for a SSD cluster and between 8192 (8TiB) and 16384 (16 TiB) for an HDD cluster. If not set, whatever is already set for the cluster will not change, or if the cluster is just being created, it will use the default value of 2560 for SSD clusters and 8192 for HDD clusters.

        !> **Warning**: Only one of `autoscaling_config` or `num_nodes` should be set for a cluster. If both are set, `num_nodes` is ignored. If none is set, autoscaling will be disabled and sized to the current node count.
        """
        return pulumi.get(self, "storage_target")

    @storage_target.setter
    def storage_target(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "storage_target", value)


if not MYPY:
    class InstanceIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        title: pulumi.Input[builtins.str]
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.

        For `bigtable.InstanceIamPolicy` only:
        """
elif False:
    InstanceIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] expression: Textual representation of an expression in Common Expression Language syntax.
        :param pulumi.Input[builtins.str] title: A title for the expression, i.e. a short string describing its purpose.
        :param pulumi.Input[builtins.str] description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
               
               For `bigtable.InstanceIamPolicy` only:
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.

        For `bigtable.InstanceIamPolicy` only:
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class InstanceIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        title: pulumi.Input[builtins.str]
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        description: NotRequired[pulumi.Input[builtins.str]]
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.

        For `bigtable.InstanceIamPolicy` only:
        """
elif False:
    InstanceIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] expression: Textual representation of an expression in Common Expression Language syntax.
        :param pulumi.Input[builtins.str] title: A title for the expression, i.e. a short string describing its purpose.
        :param pulumi.Input[builtins.str] description: An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.
               
               For `bigtable.InstanceIamPolicy` only:
        """
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        """
        Textual representation of an expression in Common Expression Language syntax.
        """
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        """
        A title for the expression, i.e. a short string describing its purpose.
        """
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An optional description of the expression. This is a longer text which describes the expression, e.g. when hovered over it in a UI.

        For `bigtable.InstanceIamPolicy` only:
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class TableAutomatedBackupPolicyArgsDict(TypedDict):
        frequency: NotRequired[pulumi.Input[builtins.str]]
        """
        How frequently automated backups should occur.
        """
        retention_period: NotRequired[pulumi.Input[builtins.str]]
        """
        How long the automated backups should be retained.
        """
elif False:
    TableAutomatedBackupPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableAutomatedBackupPolicyArgs:
    def __init__(__self__, *,
                 frequency: Optional[pulumi.Input[builtins.str]] = None,
                 retention_period: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] frequency: How frequently automated backups should occur.
        :param pulumi.Input[builtins.str] retention_period: How long the automated backups should be retained.
        """
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if retention_period is not None:
            pulumi.set(__self__, "retention_period", retention_period)

    @property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        How frequently automated backups should occur.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter(name="retentionPeriod")
    def retention_period(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        How long the automated backups should be retained.
        """
        return pulumi.get(self, "retention_period")

    @retention_period.setter
    def retention_period(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "retention_period", value)


if not MYPY:
    class TableColumnFamilyArgsDict(TypedDict):
        family: pulumi.Input[builtins.str]
        """
        The name of the column family.
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        The type of the column family.
        """
elif False:
    TableColumnFamilyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableColumnFamilyArgs:
    def __init__(__self__, *,
                 family: pulumi.Input[builtins.str],
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] family: The name of the column family.
        :param pulumi.Input[builtins.str] type: The type of the column family.
        """
        pulumi.set(__self__, "family", family)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def family(self) -> pulumi.Input[builtins.str]:
        """
        The name of the column family.
        """
        return pulumi.get(self, "family")

    @family.setter
    def family(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "family", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The type of the column family.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class TableIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    TableIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class TableIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    TableIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TableIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


