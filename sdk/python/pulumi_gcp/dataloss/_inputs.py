# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'PreventionDeidentifyTemplateDeidentifyConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllInfoTypesArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllInfoTypesArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllTextArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllTextArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformRedactionColorArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformRedactionColorArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeSensitivityScoreArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeSensitivityScoreArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionFieldArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionFieldArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueDateValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueDateValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueTimeValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueTimeValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationFieldArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationFieldArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceWithInfoTypeConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceWithInfoTypeConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigContextArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigContextArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationRedactConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationRedactConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationTimePartConfigArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationTimePartConfigArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionFieldArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionFieldArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueDateValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueDateValueArgsDict',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueTimeValueArgs',
    'PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueTimeValueArgsDict',
    'PreventionDiscoveryConfigActionArgs',
    'PreventionDiscoveryConfigActionArgsDict',
    'PreventionDiscoveryConfigActionExportDataArgs',
    'PreventionDiscoveryConfigActionExportDataArgsDict',
    'PreventionDiscoveryConfigActionExportDataProfileTableArgs',
    'PreventionDiscoveryConfigActionExportDataProfileTableArgsDict',
    'PreventionDiscoveryConfigActionPubSubNotificationArgs',
    'PreventionDiscoveryConfigActionPubSubNotificationArgsDict',
    'PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionArgs',
    'PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionArgsDict',
    'PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsArgs',
    'PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsArgsDict',
    'PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsConditionArgs',
    'PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsConditionArgsDict',
    'PreventionDiscoveryConfigActionTagResourcesArgs',
    'PreventionDiscoveryConfigActionTagResourcesArgsDict',
    'PreventionDiscoveryConfigActionTagResourcesTagConditionArgs',
    'PreventionDiscoveryConfigActionTagResourcesTagConditionArgsDict',
    'PreventionDiscoveryConfigActionTagResourcesTagConditionSensitivityScoreArgs',
    'PreventionDiscoveryConfigActionTagResourcesTagConditionSensitivityScoreArgsDict',
    'PreventionDiscoveryConfigActionTagResourcesTagConditionTagArgs',
    'PreventionDiscoveryConfigActionTagResourcesTagConditionTagArgsDict',
    'PreventionDiscoveryConfigErrorArgs',
    'PreventionDiscoveryConfigErrorArgsDict',
    'PreventionDiscoveryConfigErrorDetailsArgs',
    'PreventionDiscoveryConfigErrorDetailsArgsDict',
    'PreventionDiscoveryConfigOrgConfigArgs',
    'PreventionDiscoveryConfigOrgConfigArgsDict',
    'PreventionDiscoveryConfigOrgConfigLocationArgs',
    'PreventionDiscoveryConfigOrgConfigLocationArgsDict',
    'PreventionDiscoveryConfigTargetArgs',
    'PreventionDiscoveryConfigTargetArgsDict',
    'PreventionDiscoveryConfigTargetBigQueryTargetArgs',
    'PreventionDiscoveryConfigTargetBigQueryTargetArgsDict',
    'PreventionDiscoveryConfigTargetBigQueryTargetCadenceArgs',
    'PreventionDiscoveryConfigTargetBigQueryTargetCadenceArgsDict',
    'PreventionDiscoveryConfigTargetBigQueryTargetCadenceInspectTemplateModifiedCadenceArgs',
    'PreventionDiscoveryConfigTargetBigQueryTargetCadenceInspectTemplateModifiedCadenceArgsDict',
    'PreventionDiscoveryConfigTargetBigQueryTargetCadenceSchemaModifiedCadenceArgs',
    'PreventionDiscoveryConfigTargetBigQueryTargetCadenceSchemaModifiedCadenceArgsDict',
    'PreventionDiscoveryConfigTargetBigQueryTargetCadenceTableModifiedCadenceArgs',
    'PreventionDiscoveryConfigTargetBigQueryTargetCadenceTableModifiedCadenceArgsDict',
    'PreventionDiscoveryConfigTargetBigQueryTargetConditionsArgs',
    'PreventionDiscoveryConfigTargetBigQueryTargetConditionsArgsDict',
    'PreventionDiscoveryConfigTargetBigQueryTargetConditionsOrConditionsArgs',
    'PreventionDiscoveryConfigTargetBigQueryTargetConditionsOrConditionsArgsDict',
    'PreventionDiscoveryConfigTargetBigQueryTargetConditionsTypesArgs',
    'PreventionDiscoveryConfigTargetBigQueryTargetConditionsTypesArgsDict',
    'PreventionDiscoveryConfigTargetBigQueryTargetDisabledArgs',
    'PreventionDiscoveryConfigTargetBigQueryTargetDisabledArgsDict',
    'PreventionDiscoveryConfigTargetBigQueryTargetFilterArgs',
    'PreventionDiscoveryConfigTargetBigQueryTargetFilterArgsDict',
    'PreventionDiscoveryConfigTargetBigQueryTargetFilterOtherTablesArgs',
    'PreventionDiscoveryConfigTargetBigQueryTargetFilterOtherTablesArgsDict',
    'PreventionDiscoveryConfigTargetBigQueryTargetFilterTableReferenceArgs',
    'PreventionDiscoveryConfigTargetBigQueryTargetFilterTableReferenceArgsDict',
    'PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesArgs',
    'PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesArgsDict',
    'PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesArgs',
    'PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesArgsDict',
    'PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesPatternArgs',
    'PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesPatternArgsDict',
    'PreventionDiscoveryConfigTargetCloudSqlTargetArgs',
    'PreventionDiscoveryConfigTargetCloudSqlTargetArgsDict',
    'PreventionDiscoveryConfigTargetCloudSqlTargetConditionsArgs',
    'PreventionDiscoveryConfigTargetCloudSqlTargetConditionsArgsDict',
    'PreventionDiscoveryConfigTargetCloudSqlTargetDisabledArgs',
    'PreventionDiscoveryConfigTargetCloudSqlTargetDisabledArgsDict',
    'PreventionDiscoveryConfigTargetCloudSqlTargetFilterArgs',
    'PreventionDiscoveryConfigTargetCloudSqlTargetFilterArgsDict',
    'PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionArgs',
    'PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionArgsDict',
    'PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesArgs',
    'PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesArgsDict',
    'PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesPatternArgs',
    'PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesPatternArgsDict',
    'PreventionDiscoveryConfigTargetCloudSqlTargetFilterDatabaseResourceReferenceArgs',
    'PreventionDiscoveryConfigTargetCloudSqlTargetFilterDatabaseResourceReferenceArgsDict',
    'PreventionDiscoveryConfigTargetCloudSqlTargetFilterOthersArgs',
    'PreventionDiscoveryConfigTargetCloudSqlTargetFilterOthersArgsDict',
    'PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceArgs',
    'PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceArgsDict',
    'PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceInspectTemplateModifiedCadenceArgs',
    'PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceInspectTemplateModifiedCadenceArgsDict',
    'PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceSchemaModifiedCadenceArgs',
    'PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceSchemaModifiedCadenceArgsDict',
    'PreventionDiscoveryConfigTargetCloudStorageTargetArgs',
    'PreventionDiscoveryConfigTargetCloudStorageTargetArgsDict',
    'PreventionDiscoveryConfigTargetCloudStorageTargetConditionsArgs',
    'PreventionDiscoveryConfigTargetCloudStorageTargetConditionsArgsDict',
    'PreventionDiscoveryConfigTargetCloudStorageTargetConditionsCloudStorageConditionsArgs',
    'PreventionDiscoveryConfigTargetCloudStorageTargetConditionsCloudStorageConditionsArgsDict',
    'PreventionDiscoveryConfigTargetCloudStorageTargetDisabledArgs',
    'PreventionDiscoveryConfigTargetCloudStorageTargetDisabledArgsDict',
    'PreventionDiscoveryConfigTargetCloudStorageTargetFilterArgs',
    'PreventionDiscoveryConfigTargetCloudStorageTargetFilterArgsDict',
    'PreventionDiscoveryConfigTargetCloudStorageTargetFilterCloudStorageResourceReferenceArgs',
    'PreventionDiscoveryConfigTargetCloudStorageTargetFilterCloudStorageResourceReferenceArgsDict',
    'PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionArgs',
    'PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionArgsDict',
    'PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesArgs',
    'PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesArgsDict',
    'PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternArgs',
    'PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternArgsDict',
    'PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternCloudStorageRegexArgs',
    'PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternCloudStorageRegexArgsDict',
    'PreventionDiscoveryConfigTargetCloudStorageTargetFilterOthersArgs',
    'PreventionDiscoveryConfigTargetCloudStorageTargetFilterOthersArgsDict',
    'PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceArgs',
    'PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceArgsDict',
    'PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceInspectTemplateModifiedCadenceArgs',
    'PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceInspectTemplateModifiedCadenceArgsDict',
    'PreventionDiscoveryConfigTargetSecretsTargetArgs',
    'PreventionDiscoveryConfigTargetSecretsTargetArgsDict',
    'PreventionInspectTemplateInspectConfigArgs',
    'PreventionInspectTemplateInspectConfigArgsDict',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeArgs',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeArgsDict',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryArgs',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryArgsDict',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgs',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgsDict',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryWordListArgs',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryWordListArgsDict',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeArgs',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeArgsDict',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgs',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgsDict',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeRegexArgs',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeRegexArgsDict',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeSensitivityScoreArgs',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeSensitivityScoreArgsDict',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeStoredTypeArgs',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeStoredTypeArgsDict',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeSurrogateTypeArgs',
    'PreventionInspectTemplateInspectConfigCustomInfoTypeSurrogateTypeArgsDict',
    'PreventionInspectTemplateInspectConfigInfoTypeArgs',
    'PreventionInspectTemplateInspectConfigInfoTypeArgsDict',
    'PreventionInspectTemplateInspectConfigInfoTypeSensitivityScoreArgs',
    'PreventionInspectTemplateInspectConfigInfoTypeSensitivityScoreArgsDict',
    'PreventionInspectTemplateInspectConfigLimitsArgs',
    'PreventionInspectTemplateInspectConfigLimitsArgsDict',
    'PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeArgs',
    'PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeArgsDict',
    'PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgs',
    'PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgsDict',
    'PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgs',
    'PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgsDict',
    'PreventionInspectTemplateInspectConfigRuleSetArgs',
    'PreventionInspectTemplateInspectConfigRuleSetArgsDict',
    'PreventionInspectTemplateInspectConfigRuleSetInfoTypeArgs',
    'PreventionInspectTemplateInspectConfigRuleSetInfoTypeArgsDict',
    'PreventionInspectTemplateInspectConfigRuleSetInfoTypeSensitivityScoreArgs',
    'PreventionInspectTemplateInspectConfigRuleSetInfoTypeSensitivityScoreArgsDict',
    'PreventionInspectTemplateInspectConfigRuleSetRuleArgs',
    'PreventionInspectTemplateInspectConfigRuleSetRuleArgsDict',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleArgs',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleArgsDict',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryArgs',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryArgsDict',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgs',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgsDict',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgs',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgsDict',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgs',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgsDict',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgs',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgsDict',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgs',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgsDict',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgs',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgsDict',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgs',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgsDict',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgs',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgsDict',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleRegexArgs',
    'PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleRegexArgsDict',
    'PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleArgs',
    'PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleArgsDict',
    'PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgs',
    'PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgsDict',
    'PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgs',
    'PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgsDict',
    'PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleProximityArgs',
    'PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleProximityArgsDict',
    'PreventionJobTriggerInspectJobArgs',
    'PreventionJobTriggerInspectJobArgsDict',
    'PreventionJobTriggerInspectJobActionArgs',
    'PreventionJobTriggerInspectJobActionArgsDict',
    'PreventionJobTriggerInspectJobActionDeidentifyArgs',
    'PreventionJobTriggerInspectJobActionDeidentifyArgsDict',
    'PreventionJobTriggerInspectJobActionDeidentifyTransformationConfigArgs',
    'PreventionJobTriggerInspectJobActionDeidentifyTransformationConfigArgsDict',
    'PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigArgs',
    'PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigArgsDict',
    'PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigTableArgs',
    'PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigTableArgsDict',
    'PreventionJobTriggerInspectJobActionJobNotificationEmailsArgs',
    'PreventionJobTriggerInspectJobActionJobNotificationEmailsArgsDict',
    'PreventionJobTriggerInspectJobActionPubSubArgs',
    'PreventionJobTriggerInspectJobActionPubSubArgsDict',
    'PreventionJobTriggerInspectJobActionPublishFindingsToCloudDataCatalogArgs',
    'PreventionJobTriggerInspectJobActionPublishFindingsToCloudDataCatalogArgsDict',
    'PreventionJobTriggerInspectJobActionPublishSummaryToCsccArgs',
    'PreventionJobTriggerInspectJobActionPublishSummaryToCsccArgsDict',
    'PreventionJobTriggerInspectJobActionPublishToStackdriverArgs',
    'PreventionJobTriggerInspectJobActionPublishToStackdriverArgsDict',
    'PreventionJobTriggerInspectJobActionSaveFindingsArgs',
    'PreventionJobTriggerInspectJobActionSaveFindingsArgsDict',
    'PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigArgs',
    'PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigArgsDict',
    'PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigTableArgs',
    'PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigTableArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigArgs',
    'PreventionJobTriggerInspectJobInspectConfigArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeArgs',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryArgs',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgs',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryWordListArgs',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryWordListArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeArgs',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgs',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeRegexArgs',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeRegexArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSensitivityScoreArgs',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSensitivityScoreArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeStoredTypeArgs',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeStoredTypeArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSurrogateTypeArgs',
    'PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSurrogateTypeArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigInfoTypeArgs',
    'PreventionJobTriggerInspectJobInspectConfigInfoTypeArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigInfoTypeSensitivityScoreArgs',
    'PreventionJobTriggerInspectJobInspectConfigInfoTypeSensitivityScoreArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigLimitsArgs',
    'PreventionJobTriggerInspectJobInspectConfigLimitsArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeArgs',
    'PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgs',
    'PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgs',
    'PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetArgs',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeArgs',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeSensitivityScoreArgs',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeSensitivityScoreArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleArgs',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleArgs',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryArgs',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgs',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgs',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgs',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgs',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgs',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgs',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgs',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgs',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleRegexArgs',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleRegexArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleArgs',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgs',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgs',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgsDict',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleProximityArgs',
    'PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleProximityArgsDict',
    'PreventionJobTriggerInspectJobStorageConfigArgs',
    'PreventionJobTriggerInspectJobStorageConfigArgsDict',
    'PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsArgs',
    'PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsArgsDict',
    'PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsExcludedFieldArgs',
    'PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsExcludedFieldArgsDict',
    'PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIdentifyingFieldArgs',
    'PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIdentifyingFieldArgsDict',
    'PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIncludedFieldArgs',
    'PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIncludedFieldArgsDict',
    'PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsTableReferenceArgs',
    'PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsTableReferenceArgsDict',
    'PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsArgs',
    'PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsArgsDict',
    'PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetArgs',
    'PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetArgsDict',
    'PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetArgs',
    'PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetArgsDict',
    'PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsArgs',
    'PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsArgsDict',
    'PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsKindArgs',
    'PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsKindArgsDict',
    'PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsPartitionIdArgs',
    'PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsPartitionIdArgsDict',
    'PreventionJobTriggerInspectJobStorageConfigHybridOptionsArgs',
    'PreventionJobTriggerInspectJobStorageConfigHybridOptionsArgsDict',
    'PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsArgs',
    'PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsArgsDict',
    'PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFieldArgs',
    'PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFieldArgsDict',
    'PreventionJobTriggerInspectJobStorageConfigTimespanConfigArgs',
    'PreventionJobTriggerInspectJobStorageConfigTimespanConfigArgsDict',
    'PreventionJobTriggerInspectJobStorageConfigTimespanConfigTimestampFieldArgs',
    'PreventionJobTriggerInspectJobStorageConfigTimespanConfigTimestampFieldArgsDict',
    'PreventionJobTriggerTriggerArgs',
    'PreventionJobTriggerTriggerArgsDict',
    'PreventionJobTriggerTriggerManualArgs',
    'PreventionJobTriggerTriggerManualArgsDict',
    'PreventionJobTriggerTriggerScheduleArgs',
    'PreventionJobTriggerTriggerScheduleArgsDict',
    'PreventionStoredInfoTypeDictionaryArgs',
    'PreventionStoredInfoTypeDictionaryArgsDict',
    'PreventionStoredInfoTypeDictionaryCloudStoragePathArgs',
    'PreventionStoredInfoTypeDictionaryCloudStoragePathArgsDict',
    'PreventionStoredInfoTypeDictionaryWordListArgs',
    'PreventionStoredInfoTypeDictionaryWordListArgsDict',
    'PreventionStoredInfoTypeLargeCustomDictionaryArgs',
    'PreventionStoredInfoTypeLargeCustomDictionaryArgsDict',
    'PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldArgs',
    'PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldArgsDict',
    'PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldFieldArgs',
    'PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldFieldArgsDict',
    'PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldTableArgs',
    'PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldTableArgsDict',
    'PreventionStoredInfoTypeLargeCustomDictionaryCloudStorageFileSetArgs',
    'PreventionStoredInfoTypeLargeCustomDictionaryCloudStorageFileSetArgsDict',
    'PreventionStoredInfoTypeLargeCustomDictionaryOutputPathArgs',
    'PreventionStoredInfoTypeLargeCustomDictionaryOutputPathArgsDict',
    'PreventionStoredInfoTypeRegexArgs',
    'PreventionStoredInfoTypeRegexArgsDict',
]

MYPY = False

if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigArgsDict(TypedDict):
        image_transformations: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsArgsDict']]
        """
        Treat the dataset as an image and redact.
        Structure is documented below.
        """
        info_type_transformations: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsArgsDict']]
        """
        Treat the dataset as free-form text and apply the same free text transformation everywhere
        Structure is documented below.
        """
        record_transformations: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsArgsDict']]
        """
        Treat the dataset as structured. Transformations can be applied to specific locations within structured datasets, such as transforming a column within a table.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigArgs:
    def __init__(__self__, *,
                 image_transformations: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsArgs']] = None,
                 info_type_transformations: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsArgs']] = None,
                 record_transformations: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsArgs'] image_transformations: Treat the dataset as an image and redact.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsArgs'] info_type_transformations: Treat the dataset as free-form text and apply the same free text transformation everywhere
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsArgs'] record_transformations: Treat the dataset as structured. Transformations can be applied to specific locations within structured datasets, such as transforming a column within a table.
               Structure is documented below.
        """
        if image_transformations is not None:
            pulumi.set(__self__, "image_transformations", image_transformations)
        if info_type_transformations is not None:
            pulumi.set(__self__, "info_type_transformations", info_type_transformations)
        if record_transformations is not None:
            pulumi.set(__self__, "record_transformations", record_transformations)

    @property
    @pulumi.getter(name="imageTransformations")
    def image_transformations(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsArgs']]:
        """
        Treat the dataset as an image and redact.
        Structure is documented below.
        """
        return pulumi.get(self, "image_transformations")

    @image_transformations.setter
    def image_transformations(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsArgs']]):
        pulumi.set(self, "image_transformations", value)

    @property
    @pulumi.getter(name="infoTypeTransformations")
    def info_type_transformations(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsArgs']]:
        """
        Treat the dataset as free-form text and apply the same free text transformation everywhere
        Structure is documented below.
        """
        return pulumi.get(self, "info_type_transformations")

    @info_type_transformations.setter
    def info_type_transformations(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsArgs']]):
        pulumi.set(self, "info_type_transformations", value)

    @property
    @pulumi.getter(name="recordTransformations")
    def record_transformations(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsArgs']]:
        """
        Treat the dataset as structured. Transformations can be applied to specific locations within structured datasets, such as transforming a column within a table.
        Structure is documented below.
        """
        return pulumi.get(self, "record_transformations")

    @record_transformations.setter
    def record_transformations(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsArgs']]):
        pulumi.set(self, "record_transformations", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsArgsDict(TypedDict):
        transforms: pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformArgsDict']]]
        """
        For determination of how redaction of images should occur.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsArgs:
    def __init__(__self__, *,
                 transforms: pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformArgs']]] transforms: For determination of how redaction of images should occur.
               Structure is documented below.
        """
        pulumi.set(__self__, "transforms", transforms)

    @property
    @pulumi.getter
    def transforms(self) -> pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformArgs']]]:
        """
        For determination of how redaction of images should occur.
        Structure is documented below.
        """
        return pulumi.get(self, "transforms")

    @transforms.setter
    def transforms(self, value: pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformArgs']]]):
        pulumi.set(self, "transforms", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformArgsDict(TypedDict):
        all_info_types: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllInfoTypesArgsDict']]
        """
        Apply transformation to all findings not specified in other ImageTransformation's selectedInfoTypes.
        """
        all_text: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllTextArgsDict']]
        """
        Apply transformation to all text that doesn't match an infoType.
        """
        redaction_color: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformRedactionColorArgsDict']]
        """
        The color to use when redacting content from an image. If not specified, the default is black.
        Structure is documented below.
        """
        selected_info_types: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesArgsDict']]
        """
        Apply transformation to the selected infoTypes.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformArgs:
    def __init__(__self__, *,
                 all_info_types: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllInfoTypesArgs']] = None,
                 all_text: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllTextArgs']] = None,
                 redaction_color: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformRedactionColorArgs']] = None,
                 selected_info_types: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllInfoTypesArgs'] all_info_types: Apply transformation to all findings not specified in other ImageTransformation's selectedInfoTypes.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllTextArgs'] all_text: Apply transformation to all text that doesn't match an infoType.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformRedactionColorArgs'] redaction_color: The color to use when redacting content from an image. If not specified, the default is black.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesArgs'] selected_info_types: Apply transformation to the selected infoTypes.
               Structure is documented below.
        """
        if all_info_types is not None:
            pulumi.set(__self__, "all_info_types", all_info_types)
        if all_text is not None:
            pulumi.set(__self__, "all_text", all_text)
        if redaction_color is not None:
            pulumi.set(__self__, "redaction_color", redaction_color)
        if selected_info_types is not None:
            pulumi.set(__self__, "selected_info_types", selected_info_types)

    @property
    @pulumi.getter(name="allInfoTypes")
    def all_info_types(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllInfoTypesArgs']]:
        """
        Apply transformation to all findings not specified in other ImageTransformation's selectedInfoTypes.
        """
        return pulumi.get(self, "all_info_types")

    @all_info_types.setter
    def all_info_types(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllInfoTypesArgs']]):
        pulumi.set(self, "all_info_types", value)

    @property
    @pulumi.getter(name="allText")
    def all_text(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllTextArgs']]:
        """
        Apply transformation to all text that doesn't match an infoType.
        """
        return pulumi.get(self, "all_text")

    @all_text.setter
    def all_text(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllTextArgs']]):
        pulumi.set(self, "all_text", value)

    @property
    @pulumi.getter(name="redactionColor")
    def redaction_color(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformRedactionColorArgs']]:
        """
        The color to use when redacting content from an image. If not specified, the default is black.
        Structure is documented below.
        """
        return pulumi.get(self, "redaction_color")

    @redaction_color.setter
    def redaction_color(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformRedactionColorArgs']]):
        pulumi.set(self, "redaction_color", value)

    @property
    @pulumi.getter(name="selectedInfoTypes")
    def selected_info_types(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesArgs']]:
        """
        Apply transformation to the selected infoTypes.
        Structure is documented below.
        """
        return pulumi.get(self, "selected_info_types")

    @selected_info_types.setter
    def selected_info_types(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesArgs']]):
        pulumi.set(self, "selected_info_types", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllInfoTypesArgsDict(TypedDict):
        pass
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllInfoTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllInfoTypesArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllTextArgsDict(TypedDict):
        pass
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllTextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformAllTextArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformRedactionColorArgsDict(TypedDict):
        blue: NotRequired[pulumi.Input[float]]
        """
        The amount of blue in the color as a value in the interval [0, 1].
        """
        green: NotRequired[pulumi.Input[float]]
        """
        The amount of green in the color as a value in the interval [0, 1].
        """
        red: NotRequired[pulumi.Input[float]]
        """
        The amount of red in the color as a value in the interval [0, 1].
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformRedactionColorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformRedactionColorArgs:
    def __init__(__self__, *,
                 blue: Optional[pulumi.Input[float]] = None,
                 green: Optional[pulumi.Input[float]] = None,
                 red: Optional[pulumi.Input[float]] = None):
        """
        :param pulumi.Input[float] blue: The amount of blue in the color as a value in the interval [0, 1].
        :param pulumi.Input[float] green: The amount of green in the color as a value in the interval [0, 1].
        :param pulumi.Input[float] red: The amount of red in the color as a value in the interval [0, 1].
        """
        if blue is not None:
            pulumi.set(__self__, "blue", blue)
        if green is not None:
            pulumi.set(__self__, "green", green)
        if red is not None:
            pulumi.set(__self__, "red", red)

    @property
    @pulumi.getter
    def blue(self) -> Optional[pulumi.Input[float]]:
        """
        The amount of blue in the color as a value in the interval [0, 1].
        """
        return pulumi.get(self, "blue")

    @blue.setter
    def blue(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "blue", value)

    @property
    @pulumi.getter
    def green(self) -> Optional[pulumi.Input[float]]:
        """
        The amount of green in the color as a value in the interval [0, 1].
        """
        return pulumi.get(self, "green")

    @green.setter
    def green(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "green", value)

    @property
    @pulumi.getter
    def red(self) -> Optional[pulumi.Input[float]]:
        """
        The amount of red in the color as a value in the interval [0, 1].
        """
        return pulumi.get(self, "red")

    @red.setter
    def red(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "red", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesArgsDict(TypedDict):
        info_types: pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeArgsDict']]]
        """
        InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
        all findings that correspond to infoTypes that were requested in InspectConfig.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesArgs:
    def __init__(__self__, *,
                 info_types: pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeArgs']]] info_types: InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
               all findings that correspond to infoTypes that were requested in InspectConfig.
               Structure is documented below.
        """
        pulumi.set(__self__, "info_types", info_types)

    @property
    @pulumi.getter(name="infoTypes")
    def info_types(self) -> pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeArgs']]]:
        """
        InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
        all findings that correspond to infoTypes that were requested in InspectConfig.
        Structure is documented below.
        """
        return pulumi.get(self, "info_types")

    @info_types.setter
    def info_types(self, value: pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeArgs']]]):
        pulumi.set(self, "info_types", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the information type.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version name for this InfoType.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 sensitivity_score: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeSensitivityScoreArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the information type.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input[str] version: Version name for this InfoType.
        """
        pulumi.set(__self__, "name", name)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the information type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version name for this InfoType.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigImageTransformationsTransformSelectedInfoTypesInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsArgsDict(TypedDict):
        transformations: pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationArgsDict']]]
        """
        Transformation for each infoType. Cannot specify more than one for a given infoType.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsArgs:
    def __init__(__self__, *,
                 transformations: pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationArgs']]] transformations: Transformation for each infoType. Cannot specify more than one for a given infoType.
               Structure is documented below.
        """
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationArgs']]]:
        """
        Transformation for each infoType. Cannot specify more than one for a given infoType.
        Structure is documented below.
        """
        return pulumi.get(self, "transformations")

    @transformations.setter
    def transformations(self, value: pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationArgs']]]):
        pulumi.set(self, "transformations", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationArgsDict(TypedDict):
        primitive_transformation: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationArgsDict']
        """
        Apply the transformation to the entire field.
        The `primitive_transformation` block must only contain one argument, corresponding to the type of transformation.
        Structure is documented below.
        """
        info_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeArgsDict']]]]
        """
        InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
        all findings that correspond to infoTypes that were requested in InspectConfig.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationArgs:
    def __init__(__self__, *,
                 primitive_transformation: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationArgs'],
                 info_types: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeArgs']]]] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationArgs'] primitive_transformation: Apply the transformation to the entire field.
               The `primitive_transformation` block must only contain one argument, corresponding to the type of transformation.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeArgs']]] info_types: InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
               all findings that correspond to infoTypes that were requested in InspectConfig.
               Structure is documented below.
        """
        pulumi.set(__self__, "primitive_transformation", primitive_transformation)
        if info_types is not None:
            pulumi.set(__self__, "info_types", info_types)

    @property
    @pulumi.getter(name="primitiveTransformation")
    def primitive_transformation(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationArgs']:
        """
        Apply the transformation to the entire field.
        The `primitive_transformation` block must only contain one argument, corresponding to the type of transformation.
        Structure is documented below.
        """
        return pulumi.get(self, "primitive_transformation")

    @primitive_transformation.setter
    def primitive_transformation(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationArgs']):
        pulumi.set(self, "primitive_transformation", value)

    @property
    @pulumi.getter(name="infoTypes")
    def info_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeArgs']]]]:
        """
        InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
        all findings that correspond to infoTypes that were requested in InspectConfig.
        Structure is documented below.
        """
        return pulumi.get(self, "info_types")

    @info_types.setter
    def info_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeArgs']]]]):
        pulumi.set(self, "info_types", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the information type.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version name for this InfoType.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 sensitivity_score: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the information type.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input[str] version: Version name for this InfoType.
        """
        pulumi.set(__self__, "name", name)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the information type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version name for this InfoType.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationArgsDict(TypedDict):
        bucketing_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgsDict']]
        """
        Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 > LOW 31-65 > MEDIUM 66-100 > HIGH
        This can be used on data of type: number, long, string, timestamp.
        If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
        See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
        Structure is documented below.
        """
        character_mask_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgsDict']]
        """
        Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. This can be used on data of any type (numbers, longs, and so on) and when de-identifying structured data we'll attempt to preserve the original data's type. (This allows you to take a long like 123 and modify it to a string like **3).
        Structure is documented below.
        """
        crypto_deterministic_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgsDict']]
        """
        Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC [https://tools.ietf.org/html/rfc5297](https://tools.ietf.org/html/rfc5297).
        Structure is documented below.
        """
        crypto_hash_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgsDict']]
        """
        Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
        Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
        Currently, only string and integer values can be hashed.
        See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
        Structure is documented below.
        """
        crypto_replace_ffx_fpe_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgsDict']]
        """
        Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the `content.reidentify` API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See [https://cloud.google.com/dlp/docs/pseudonymization](https://cloud.google.com/dlp/docs/pseudonymization) to learn more.
        Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
        Structure is documented below.
        """
        date_shift_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgsDict']]
        """
        Shifts dates by random number of days, with option to be consistent for the same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting to learn more.
        Structure is documented below.
        """
        fixed_size_bucketing_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgsDict']]
        """
        Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
        The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
        This can be used on data of type: double, long.
        If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
        See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
        Structure is documented below.
        """
        redact_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgsDict']]
        """
        Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
        """
        replace_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgsDict']]
        """
        Replace each input value with a given value.
        Structure is documented below.
        """
        replace_dictionary_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgsDict']]
        """
        Replace with a value randomly drawn (with replacement) from a dictionary.
        Structure is documented below.
        """
        replace_with_info_type_config: NotRequired[pulumi.Input[bool]]
        """
        Replace each matching finding with the name of the info type.
        """
        time_part_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgsDict']]
        """
        For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationArgs:
    def __init__(__self__, *,
                 bucketing_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgs']] = None,
                 character_mask_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgs']] = None,
                 crypto_deterministic_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgs']] = None,
                 crypto_hash_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgs']] = None,
                 crypto_replace_ffx_fpe_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs']] = None,
                 date_shift_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgs']] = None,
                 fixed_size_bucketing_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs']] = None,
                 redact_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgs']] = None,
                 replace_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgs']] = None,
                 replace_dictionary_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgs']] = None,
                 replace_with_info_type_config: Optional[pulumi.Input[bool]] = None,
                 time_part_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgs'] bucketing_config: Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 > LOW 31-65 > MEDIUM 66-100 > HIGH
               This can be used on data of type: number, long, string, timestamp.
               If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
               See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgs'] character_mask_config: Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. This can be used on data of any type (numbers, longs, and so on) and when de-identifying structured data we'll attempt to preserve the original data's type. (This allows you to take a long like 123 and modify it to a string like **3).
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgs'] crypto_deterministic_config: Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC [https://tools.ietf.org/html/rfc5297](https://tools.ietf.org/html/rfc5297).
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgs'] crypto_hash_config: Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
               Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
               Currently, only string and integer values can be hashed.
               See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs'] crypto_replace_ffx_fpe_config: Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the `content.reidentify` API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See [https://cloud.google.com/dlp/docs/pseudonymization](https://cloud.google.com/dlp/docs/pseudonymization) to learn more.
               Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgs'] date_shift_config: Shifts dates by random number of days, with option to be consistent for the same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting to learn more.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs'] fixed_size_bucketing_config: Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
               The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
               This can be used on data of type: double, long.
               If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
               See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgs'] redact_config: Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgs'] replace_config: Replace each input value with a given value.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgs'] replace_dictionary_config: Replace with a value randomly drawn (with replacement) from a dictionary.
               Structure is documented below.
        :param pulumi.Input[bool] replace_with_info_type_config: Replace each matching finding with the name of the info type.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgs'] time_part_config: For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
               Structure is documented below.
        """
        if bucketing_config is not None:
            pulumi.set(__self__, "bucketing_config", bucketing_config)
        if character_mask_config is not None:
            pulumi.set(__self__, "character_mask_config", character_mask_config)
        if crypto_deterministic_config is not None:
            pulumi.set(__self__, "crypto_deterministic_config", crypto_deterministic_config)
        if crypto_hash_config is not None:
            pulumi.set(__self__, "crypto_hash_config", crypto_hash_config)
        if crypto_replace_ffx_fpe_config is not None:
            pulumi.set(__self__, "crypto_replace_ffx_fpe_config", crypto_replace_ffx_fpe_config)
        if date_shift_config is not None:
            pulumi.set(__self__, "date_shift_config", date_shift_config)
        if fixed_size_bucketing_config is not None:
            pulumi.set(__self__, "fixed_size_bucketing_config", fixed_size_bucketing_config)
        if redact_config is not None:
            pulumi.set(__self__, "redact_config", redact_config)
        if replace_config is not None:
            pulumi.set(__self__, "replace_config", replace_config)
        if replace_dictionary_config is not None:
            pulumi.set(__self__, "replace_dictionary_config", replace_dictionary_config)
        if replace_with_info_type_config is not None:
            pulumi.set(__self__, "replace_with_info_type_config", replace_with_info_type_config)
        if time_part_config is not None:
            pulumi.set(__self__, "time_part_config", time_part_config)

    @property
    @pulumi.getter(name="bucketingConfig")
    def bucketing_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgs']]:
        """
        Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 > LOW 31-65 > MEDIUM 66-100 > HIGH
        This can be used on data of type: number, long, string, timestamp.
        If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
        See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
        Structure is documented below.
        """
        return pulumi.get(self, "bucketing_config")

    @bucketing_config.setter
    def bucketing_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgs']]):
        pulumi.set(self, "bucketing_config", value)

    @property
    @pulumi.getter(name="characterMaskConfig")
    def character_mask_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgs']]:
        """
        Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. This can be used on data of any type (numbers, longs, and so on) and when de-identifying structured data we'll attempt to preserve the original data's type. (This allows you to take a long like 123 and modify it to a string like **3).
        Structure is documented below.
        """
        return pulumi.get(self, "character_mask_config")

    @character_mask_config.setter
    def character_mask_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgs']]):
        pulumi.set(self, "character_mask_config", value)

    @property
    @pulumi.getter(name="cryptoDeterministicConfig")
    def crypto_deterministic_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgs']]:
        """
        Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC [https://tools.ietf.org/html/rfc5297](https://tools.ietf.org/html/rfc5297).
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_deterministic_config")

    @crypto_deterministic_config.setter
    def crypto_deterministic_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgs']]):
        pulumi.set(self, "crypto_deterministic_config", value)

    @property
    @pulumi.getter(name="cryptoHashConfig")
    def crypto_hash_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgs']]:
        """
        Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
        Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
        Currently, only string and integer values can be hashed.
        See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_hash_config")

    @crypto_hash_config.setter
    def crypto_hash_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgs']]):
        pulumi.set(self, "crypto_hash_config", value)

    @property
    @pulumi.getter(name="cryptoReplaceFfxFpeConfig")
    def crypto_replace_ffx_fpe_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs']]:
        """
        Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the `content.reidentify` API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See [https://cloud.google.com/dlp/docs/pseudonymization](https://cloud.google.com/dlp/docs/pseudonymization) to learn more.
        Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_replace_ffx_fpe_config")

    @crypto_replace_ffx_fpe_config.setter
    def crypto_replace_ffx_fpe_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs']]):
        pulumi.set(self, "crypto_replace_ffx_fpe_config", value)

    @property
    @pulumi.getter(name="dateShiftConfig")
    def date_shift_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgs']]:
        """
        Shifts dates by random number of days, with option to be consistent for the same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting to learn more.
        Structure is documented below.
        """
        return pulumi.get(self, "date_shift_config")

    @date_shift_config.setter
    def date_shift_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgs']]):
        pulumi.set(self, "date_shift_config", value)

    @property
    @pulumi.getter(name="fixedSizeBucketingConfig")
    def fixed_size_bucketing_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs']]:
        """
        Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
        The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
        This can be used on data of type: double, long.
        If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
        See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
        Structure is documented below.
        """
        return pulumi.get(self, "fixed_size_bucketing_config")

    @fixed_size_bucketing_config.setter
    def fixed_size_bucketing_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs']]):
        pulumi.set(self, "fixed_size_bucketing_config", value)

    @property
    @pulumi.getter(name="redactConfig")
    def redact_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgs']]:
        """
        Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
        """
        return pulumi.get(self, "redact_config")

    @redact_config.setter
    def redact_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgs']]):
        pulumi.set(self, "redact_config", value)

    @property
    @pulumi.getter(name="replaceConfig")
    def replace_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgs']]:
        """
        Replace each input value with a given value.
        Structure is documented below.
        """
        return pulumi.get(self, "replace_config")

    @replace_config.setter
    def replace_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgs']]):
        pulumi.set(self, "replace_config", value)

    @property
    @pulumi.getter(name="replaceDictionaryConfig")
    def replace_dictionary_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgs']]:
        """
        Replace with a value randomly drawn (with replacement) from a dictionary.
        Structure is documented below.
        """
        return pulumi.get(self, "replace_dictionary_config")

    @replace_dictionary_config.setter
    def replace_dictionary_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgs']]):
        pulumi.set(self, "replace_dictionary_config", value)

    @property
    @pulumi.getter(name="replaceWithInfoTypeConfig")
    def replace_with_info_type_config(self) -> Optional[pulumi.Input[bool]]:
        """
        Replace each matching finding with the name of the info type.
        """
        return pulumi.get(self, "replace_with_info_type_config")

    @replace_with_info_type_config.setter
    def replace_with_info_type_config(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "replace_with_info_type_config", value)

    @property
    @pulumi.getter(name="timePartConfig")
    def time_part_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgs']]:
        """
        For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
        Structure is documented below.
        """
        return pulumi.get(self, "time_part_config")

    @time_part_config.setter
    def time_part_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgs']]):
        pulumi.set(self, "time_part_config", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgsDict(TypedDict):
        buckets: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgsDict']]]]
        """
        Set of buckets. Ranges must be non-overlapping.
        Bucket is represented as a range, along with replacement values.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgs:
    def __init__(__self__, *,
                 buckets: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgs']]] buckets: Set of buckets. Ranges must be non-overlapping.
               Bucket is represented as a range, along with replacement values.
               Structure is documented below.
        """
        if buckets is not None:
            pulumi.set(__self__, "buckets", buckets)

    @property
    @pulumi.getter
    def buckets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgs']]]]:
        """
        Set of buckets. Ranges must be non-overlapping.
        Bucket is represented as a range, along with replacement values.
        Structure is documented below.
        """
        return pulumi.get(self, "buckets")

    @buckets.setter
    def buckets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgs']]]]):
        pulumi.set(self, "buckets", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgsDict(TypedDict):
        replacement_value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgsDict']
        """
        Replacement value for this bucket.
        The `replacement_value` block must only contain one argument.
        Structure is documented below.
        """
        max: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgsDict']]
        """
        Upper bound of the range, exclusive; type must match min.
        The `max` block must only contain one argument. See the `bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
        min: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgsDict']]
        """
        Lower bound of the range, inclusive. Type should be the same as max if used.
        The `min` block must only contain one argument. See the `bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgs:
    def __init__(__self__, *,
                 replacement_value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgs'],
                 max: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgs']] = None,
                 min: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgs'] replacement_value: Replacement value for this bucket.
               The `replacement_value` block must only contain one argument.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgs'] max: Upper bound of the range, exclusive; type must match min.
               The `max` block must only contain one argument. See the `bucketing_config` block description for more information about choosing a data type.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgs'] min: Lower bound of the range, inclusive. Type should be the same as max if used.
               The `min` block must only contain one argument. See the `bucketing_config` block description for more information about choosing a data type.
               Structure is documented below.
        """
        pulumi.set(__self__, "replacement_value", replacement_value)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgs']:
        """
        Replacement value for this bucket.
        The `replacement_value` block must only contain one argument.
        Structure is documented below.
        """
        return pulumi.get(self, "replacement_value")

    @replacement_value.setter
    def replacement_value(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgs']):
        pulumi.set(self, "replacement_value", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgs']]:
        """
        Upper bound of the range, exclusive; type must match min.
        The `max` block must only contain one argument. See the `bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgs']]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgs']]:
        """
        Lower bound of the range, inclusive. Type should be the same as max if used.
        The `min` block must only contain one argument. See the `bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgs']]):
        pulumi.set(self, "min", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgsDict(TypedDict):
        date_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgsDict']]
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        day_of_week_value: NotRequired[pulumi.Input[str]]
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        An integer value (int64 format)
        """
        string_value: NotRequired[pulumi.Input[str]]
        """
        A string value.
        """
        time_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgsDict']]
        """
        Represents a time of day.
        Structure is documented below.
        """
        timestamp_value: NotRequired[pulumi.Input[str]]
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgs:
    def __init__(__self__, *,
                 date_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgs']] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None,
                 string_value: Optional[pulumi.Input[str]] = None,
                 time_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgs']] = None,
                 timestamp_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgs'] date_value: Represents a whole or partial calendar date.
               Structure is documented below.
        :param pulumi.Input[str] day_of_week_value: Represents a day of the week.
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[str] integer_value: An integer value (int64 format)
        :param pulumi.Input[str] string_value: A string value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgs'] time_value: Represents a time of day.
               Structure is documented below.
        :param pulumi.Input[str] timestamp_value: A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if time_value is not None:
            pulumi.set(__self__, "time_value", time_value)
        if timestamp_value is not None:
            pulumi.set(__self__, "timestamp_value", timestamp_value)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgs']]:
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgs']]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        A string value.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)

    @property
    @pulumi.getter(name="timeValue")
    def time_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgs']]:
        """
        Represents a time of day.
        Structure is documented below.
        """
        return pulumi.get(self, "time_value")

    @time_value.setter
    def time_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgs']]):
        pulumi.set(self, "time_value", value)

    @property
    @pulumi.getter(name="timestampValue")
    def timestamp_value(self) -> Optional[pulumi.Input[str]]:
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "timestamp_value")

    @timestamp_value.setter
    def timestamp_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
               
               - - -
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgsDict(TypedDict):
        date_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgsDict']]
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        day_of_week_value: NotRequired[pulumi.Input[str]]
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        An integer value (int64 format)
        """
        string_value: NotRequired[pulumi.Input[str]]
        """
        A string value.
        """
        time_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgsDict']]
        """
        Represents a time of day.
        Structure is documented below.
        """
        timestamp_value: NotRequired[pulumi.Input[str]]
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgs:
    def __init__(__self__, *,
                 date_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgs']] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None,
                 string_value: Optional[pulumi.Input[str]] = None,
                 time_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgs']] = None,
                 timestamp_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgs'] date_value: Represents a whole or partial calendar date.
               Structure is documented below.
        :param pulumi.Input[str] day_of_week_value: Represents a day of the week.
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[str] integer_value: An integer value (int64 format)
        :param pulumi.Input[str] string_value: A string value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgs'] time_value: Represents a time of day.
               Structure is documented below.
        :param pulumi.Input[str] timestamp_value: A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if time_value is not None:
            pulumi.set(__self__, "time_value", time_value)
        if timestamp_value is not None:
            pulumi.set(__self__, "timestamp_value", timestamp_value)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgs']]:
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgs']]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        A string value.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)

    @property
    @pulumi.getter(name="timeValue")
    def time_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgs']]:
        """
        Represents a time of day.
        Structure is documented below.
        """
        return pulumi.get(self, "time_value")

    @time_value.setter
    def time_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgs']]):
        pulumi.set(self, "time_value", value)

    @property
    @pulumi.getter(name="timestampValue")
    def timestamp_value(self) -> Optional[pulumi.Input[str]]:
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "timestamp_value")

    @timestamp_value.setter
    def timestamp_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
               
               - - -
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgsDict(TypedDict):
        date_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgsDict']]
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        day_of_week_value: NotRequired[pulumi.Input[str]]
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        An integer value (int64 format)
        """
        string_value: NotRequired[pulumi.Input[str]]
        """
        A string value.
        """
        time_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgsDict']]
        """
        Represents a time of day.
        Structure is documented below.
        """
        timestamp_value: NotRequired[pulumi.Input[str]]
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgs:
    def __init__(__self__, *,
                 date_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgs']] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None,
                 string_value: Optional[pulumi.Input[str]] = None,
                 time_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgs']] = None,
                 timestamp_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgs'] date_value: Represents a whole or partial calendar date.
               Structure is documented below.
        :param pulumi.Input[str] day_of_week_value: Represents a day of the week.
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[str] integer_value: An integer value (int64 format)
        :param pulumi.Input[str] string_value: A string value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgs'] time_value: Represents a time of day.
               Structure is documented below.
        :param pulumi.Input[str] timestamp_value: A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if time_value is not None:
            pulumi.set(__self__, "time_value", time_value)
        if timestamp_value is not None:
            pulumi.set(__self__, "timestamp_value", timestamp_value)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgs']]:
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgs']]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        A string value.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)

    @property
    @pulumi.getter(name="timeValue")
    def time_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgs']]:
        """
        Represents a time of day.
        Structure is documented below.
        """
        return pulumi.get(self, "time_value")

    @time_value.setter
    def time_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgs']]):
        pulumi.set(self, "time_value", value)

    @property
    @pulumi.getter(name="timestampValue")
    def timestamp_value(self) -> Optional[pulumi.Input[str]]:
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "timestamp_value")

    @timestamp_value.setter
    def timestamp_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
               
               - - -
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgsDict(TypedDict):
        characters_to_ignores: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgsDict']]]]
        """
        Characters to skip when doing de-identification of a value. These will be left alone and skipped.
        Structure is documented below.
        """
        masking_character: NotRequired[pulumi.Input[str]]
        """
        Character to use to mask the sensitive valuesfor example, * for an alphabetic string such as a name, or 0 for a numeric string
        such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to * for
        strings, and 0 for digits.
        """
        number_to_mask: NotRequired[pulumi.Input[int]]
        """
        Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.
        If number_to_mask is negative, this denotes inverse masking. Cloud DLP masks all but a number of characters. For example, suppose you have the following values:
        """
        reverse_order: NotRequired[pulumi.Input[bool]]
        """
        Mask characters in reverse order. For example, if masking_character is 0, number_to_mask is 14, and reverse_order is `false`, then the
        input string `1234-5678-9012-3456` is masked as `00000000000000-3456`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgs:
    def __init__(__self__, *,
                 characters_to_ignores: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgs']]]] = None,
                 masking_character: Optional[pulumi.Input[str]] = None,
                 number_to_mask: Optional[pulumi.Input[int]] = None,
                 reverse_order: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgs']]] characters_to_ignores: Characters to skip when doing de-identification of a value. These will be left alone and skipped.
               Structure is documented below.
        :param pulumi.Input[str] masking_character: Character to use to mask the sensitive valuesfor example, * for an alphabetic string such as a name, or 0 for a numeric string
               such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to * for
               strings, and 0 for digits.
        :param pulumi.Input[int] number_to_mask: Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.
               If number_to_mask is negative, this denotes inverse masking. Cloud DLP masks all but a number of characters. For example, suppose you have the following values:
        :param pulumi.Input[bool] reverse_order: Mask characters in reverse order. For example, if masking_character is 0, number_to_mask is 14, and reverse_order is `false`, then the
               input string `1234-5678-9012-3456` is masked as `00000000000000-3456`.
        """
        if characters_to_ignores is not None:
            pulumi.set(__self__, "characters_to_ignores", characters_to_ignores)
        if masking_character is not None:
            pulumi.set(__self__, "masking_character", masking_character)
        if number_to_mask is not None:
            pulumi.set(__self__, "number_to_mask", number_to_mask)
        if reverse_order is not None:
            pulumi.set(__self__, "reverse_order", reverse_order)

    @property
    @pulumi.getter(name="charactersToIgnores")
    def characters_to_ignores(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgs']]]]:
        """
        Characters to skip when doing de-identification of a value. These will be left alone and skipped.
        Structure is documented below.
        """
        return pulumi.get(self, "characters_to_ignores")

    @characters_to_ignores.setter
    def characters_to_ignores(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgs']]]]):
        pulumi.set(self, "characters_to_ignores", value)

    @property
    @pulumi.getter(name="maskingCharacter")
    def masking_character(self) -> Optional[pulumi.Input[str]]:
        """
        Character to use to mask the sensitive valuesfor example, * for an alphabetic string such as a name, or 0 for a numeric string
        such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to * for
        strings, and 0 for digits.
        """
        return pulumi.get(self, "masking_character")

    @masking_character.setter
    def masking_character(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "masking_character", value)

    @property
    @pulumi.getter(name="numberToMask")
    def number_to_mask(self) -> Optional[pulumi.Input[int]]:
        """
        Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.
        If number_to_mask is negative, this denotes inverse masking. Cloud DLP masks all but a number of characters. For example, suppose you have the following values:
        """
        return pulumi.get(self, "number_to_mask")

    @number_to_mask.setter
    def number_to_mask(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_to_mask", value)

    @property
    @pulumi.getter(name="reverseOrder")
    def reverse_order(self) -> Optional[pulumi.Input[bool]]:
        """
        Mask characters in reverse order. For example, if masking_character is 0, number_to_mask is 14, and reverse_order is `false`, then the
        input string `1234-5678-9012-3456` is masked as `00000000000000-3456`.
        """
        return pulumi.get(self, "reverse_order")

    @reverse_order.setter
    def reverse_order(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reverse_order", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgsDict(TypedDict):
        characters_to_skip: NotRequired[pulumi.Input[str]]
        """
        Characters to not transform when masking. Only one of this or `common_characters_to_ignore` must be specified.
        """
        common_characters_to_ignore: NotRequired[pulumi.Input[str]]
        """
        Common characters to not transform when masking. Useful to avoid removing punctuation. Only one of this or `characters_to_skip` must be specified.
        Possible values are: `NUMERIC`, `ALPHA_UPPER_CASE`, `ALPHA_LOWER_CASE`, `PUNCTUATION`, `WHITESPACE`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgs:
    def __init__(__self__, *,
                 characters_to_skip: Optional[pulumi.Input[str]] = None,
                 common_characters_to_ignore: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] characters_to_skip: Characters to not transform when masking. Only one of this or `common_characters_to_ignore` must be specified.
        :param pulumi.Input[str] common_characters_to_ignore: Common characters to not transform when masking. Useful to avoid removing punctuation. Only one of this or `characters_to_skip` must be specified.
               Possible values are: `NUMERIC`, `ALPHA_UPPER_CASE`, `ALPHA_LOWER_CASE`, `PUNCTUATION`, `WHITESPACE`.
        """
        if characters_to_skip is not None:
            pulumi.set(__self__, "characters_to_skip", characters_to_skip)
        if common_characters_to_ignore is not None:
            pulumi.set(__self__, "common_characters_to_ignore", common_characters_to_ignore)

    @property
    @pulumi.getter(name="charactersToSkip")
    def characters_to_skip(self) -> Optional[pulumi.Input[str]]:
        """
        Characters to not transform when masking. Only one of this or `common_characters_to_ignore` must be specified.
        """
        return pulumi.get(self, "characters_to_skip")

    @characters_to_skip.setter
    def characters_to_skip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "characters_to_skip", value)

    @property
    @pulumi.getter(name="commonCharactersToIgnore")
    def common_characters_to_ignore(self) -> Optional[pulumi.Input[str]]:
        """
        Common characters to not transform when masking. Useful to avoid removing punctuation. Only one of this or `characters_to_skip` must be specified.
        Possible values are: `NUMERIC`, `ALPHA_UPPER_CASE`, `ALPHA_LOWER_CASE`, `PUNCTUATION`, `WHITESPACE`.
        """
        return pulumi.get(self, "common_characters_to_ignore")

    @common_characters_to_ignore.setter
    def common_characters_to_ignore(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_characters_to_ignore", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgsDict(TypedDict):
        context: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgsDict']]
        """
        A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well.
        If the context is not set, plaintext would be used as is for encryption. If the context is set but:
        1. there is no record present when transforming a given value or
        2. the field is not present when transforming a given value,
        plaintext would be used as is for encryption.
        Note that case (1) is expected when an InfoTypeTransformation is applied to both structured and unstructured ContentItems.
        Structure is documented below.
        """
        crypto_key: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgsDict']]
        """
        The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.
        Structure is documented below.
        """
        surrogate_info_type: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgsDict']]
        """
        The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate}
        For example, if the name of custom info type is 'MY\\_TOKEN\\_INFO\\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\\_TOKEN\\_INFO\\_TYPE(3):abc'
        This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text.
        Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text.
        In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either
        *   reverse a surrogate that does not correspond to an actual identifier
        *   be unable to parse the surrogate and result in an error
        Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\\_TOKEN\\_TYPE.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgs:
    def __init__(__self__, *,
                 context: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgs']] = None,
                 crypto_key: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgs']] = None,
                 surrogate_info_type: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgs'] context: A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well.
               If the context is not set, plaintext would be used as is for encryption. If the context is set but:
               1. there is no record present when transforming a given value or
               2. the field is not present when transforming a given value,
               plaintext would be used as is for encryption.
               Note that case (1) is expected when an InfoTypeTransformation is applied to both structured and unstructured ContentItems.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgs'] crypto_key: The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgs'] surrogate_info_type: The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate}
               For example, if the name of custom info type is 'MY\\_TOKEN\\_INFO\\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\\_TOKEN\\_INFO\\_TYPE(3):abc'
               This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text.
               Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text.
               In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either
               *   reverse a surrogate that does not correspond to an actual identifier
               *   be unable to parse the surrogate and result in an error
               Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\\_TOKEN\\_TYPE.
               Structure is documented below.
        """
        if context is not None:
            pulumi.set(__self__, "context", context)
        if crypto_key is not None:
            pulumi.set(__self__, "crypto_key", crypto_key)
        if surrogate_info_type is not None:
            pulumi.set(__self__, "surrogate_info_type", surrogate_info_type)

    @property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgs']]:
        """
        A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well.
        If the context is not set, plaintext would be used as is for encryption. If the context is set but:
        1. there is no record present when transforming a given value or
        2. the field is not present when transforming a given value,
        plaintext would be used as is for encryption.
        Note that case (1) is expected when an InfoTypeTransformation is applied to both structured and unstructured ContentItems.
        Structure is documented below.
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgs']]):
        pulumi.set(self, "context", value)

    @property
    @pulumi.getter(name="cryptoKey")
    def crypto_key(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgs']]:
        """
        The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_key")

    @crypto_key.setter
    def crypto_key(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgs']]):
        pulumi.set(self, "crypto_key", value)

    @property
    @pulumi.getter(name="surrogateInfoType")
    def surrogate_info_type(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgs']]:
        """
        The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate}
        For example, if the name of custom info type is 'MY\\_TOKEN\\_INFO\\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\\_TOKEN\\_INFO\\_TYPE(3):abc'
        This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text.
        Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text.
        In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either
        *   reverse a surrogate that does not correspond to an actual identifier
        *   be unable to parse the surrogate and result in an error
        Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\\_TOKEN\\_TYPE.
        Structure is documented below.
        """
        return pulumi.get(self, "surrogate_info_type")

    @surrogate_info_type.setter
    def surrogate_info_type(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgs']]):
        pulumi.set(self, "surrogate_info_type", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name describing the field.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name describing the field.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name describing the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgsDict(TypedDict):
        kms_wrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgsDict']]
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        transient: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgsDict']]
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        unwrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgsDict']]
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgs:
    def __init__(__self__, *,
                 kms_wrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgs']] = None,
                 transient: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgs']] = None,
                 unwrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgs'] kms_wrapped: KMS wrapped key.
               Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
               For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
               Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgs'] transient: Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgs'] unwrapped: Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
               Structure is documented below.
        """
        if kms_wrapped is not None:
            pulumi.set(__self__, "kms_wrapped", kms_wrapped)
        if transient is not None:
            pulumi.set(__self__, "transient", transient)
        if unwrapped is not None:
            pulumi.set(__self__, "unwrapped", unwrapped)

    @property
    @pulumi.getter(name="kmsWrapped")
    def kms_wrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgs']]:
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        return pulumi.get(self, "kms_wrapped")

    @kms_wrapped.setter
    def kms_wrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgs']]):
        pulumi.set(self, "kms_wrapped", value)

    @property
    @pulumi.getter
    def transient(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgs']]:
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "transient")

    @transient.setter
    def transient(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgs']]):
        pulumi.set(self, "transient", value)

    @property
    @pulumi.getter
    def unwrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgs']]:
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "unwrapped")

    @unwrapped.setter
    def unwrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgs']]):
        pulumi.set(self, "unwrapped", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgsDict(TypedDict):
        crypto_key_name: pulumi.Input[str]
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        wrapped_key: pulumi.Input[str]
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgs:
    def __init__(__self__, *,
                 crypto_key_name: pulumi.Input[str],
                 wrapped_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] crypto_key_name: The resource name of the KMS CryptoKey to use for unwrapping.
        :param pulumi.Input[str] wrapped_key: The wrapped data crypto key.
               A base64-encoded string.
        """
        pulumi.set(__self__, "crypto_key_name", crypto_key_name)
        pulumi.set(__self__, "wrapped_key", wrapped_key)

    @property
    @pulumi.getter(name="cryptoKeyName")
    def crypto_key_name(self) -> pulumi.Input[str]:
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        return pulumi.get(self, "crypto_key_name")

    @crypto_key_name.setter
    def crypto_key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "crypto_key_name", value)

    @property
    @pulumi.getter(name="wrappedKey")
    def wrapped_key(self) -> pulumi.Input[str]:
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
        return pulumi.get(self, "wrapped_key")

    @wrapped_key.setter
    def wrapped_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "wrapped_key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: A 128/192/256 bit key.
               A base64-encoded string.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Optional version name for this InfoType.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 sensitivity_score: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input[str] version: Optional version name for this InfoType.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Optional version name for this InfoType.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgsDict(TypedDict):
        crypto_key: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgsDict']]
        """
        The key used by the encryption function.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgs:
    def __init__(__self__, *,
                 crypto_key: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgs'] crypto_key: The key used by the encryption function.
               Structure is documented below.
        """
        if crypto_key is not None:
            pulumi.set(__self__, "crypto_key", crypto_key)

    @property
    @pulumi.getter(name="cryptoKey")
    def crypto_key(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgs']]:
        """
        The key used by the encryption function.
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_key")

    @crypto_key.setter
    def crypto_key(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgs']]):
        pulumi.set(self, "crypto_key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgsDict(TypedDict):
        kms_wrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgsDict']]
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        transient: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgsDict']]
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        unwrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgsDict']]
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgs:
    def __init__(__self__, *,
                 kms_wrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgs']] = None,
                 transient: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgs']] = None,
                 unwrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgs'] kms_wrapped: KMS wrapped key.
               Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
               For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
               Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgs'] transient: Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgs'] unwrapped: Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
               Structure is documented below.
        """
        if kms_wrapped is not None:
            pulumi.set(__self__, "kms_wrapped", kms_wrapped)
        if transient is not None:
            pulumi.set(__self__, "transient", transient)
        if unwrapped is not None:
            pulumi.set(__self__, "unwrapped", unwrapped)

    @property
    @pulumi.getter(name="kmsWrapped")
    def kms_wrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgs']]:
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        return pulumi.get(self, "kms_wrapped")

    @kms_wrapped.setter
    def kms_wrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgs']]):
        pulumi.set(self, "kms_wrapped", value)

    @property
    @pulumi.getter
    def transient(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgs']]:
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "transient")

    @transient.setter
    def transient(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgs']]):
        pulumi.set(self, "transient", value)

    @property
    @pulumi.getter
    def unwrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgs']]:
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "unwrapped")

    @unwrapped.setter
    def unwrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgs']]):
        pulumi.set(self, "unwrapped", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgsDict(TypedDict):
        crypto_key_name: pulumi.Input[str]
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        wrapped_key: pulumi.Input[str]
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgs:
    def __init__(__self__, *,
                 crypto_key_name: pulumi.Input[str],
                 wrapped_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] crypto_key_name: The resource name of the KMS CryptoKey to use for unwrapping.
        :param pulumi.Input[str] wrapped_key: The wrapped data crypto key.
               A base64-encoded string.
        """
        pulumi.set(__self__, "crypto_key_name", crypto_key_name)
        pulumi.set(__self__, "wrapped_key", wrapped_key)

    @property
    @pulumi.getter(name="cryptoKeyName")
    def crypto_key_name(self) -> pulumi.Input[str]:
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        return pulumi.get(self, "crypto_key_name")

    @crypto_key_name.setter
    def crypto_key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "crypto_key_name", value)

    @property
    @pulumi.getter(name="wrappedKey")
    def wrapped_key(self) -> pulumi.Input[str]:
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
        return pulumi.get(self, "wrapped_key")

    @wrapped_key.setter
    def wrapped_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "wrapped_key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: A 128/192/256 bit key.
               A base64-encoded string.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgsDict(TypedDict):
        common_alphabet: NotRequired[pulumi.Input[str]]
        """
        Common alphabets. Only one of this, `custom_alphabet` or `radix` must be specified.
        Possible values are: `NUMERIC`, `HEXADECIMAL`, `UPPER_CASE_ALPHA_NUMERIC`, `ALPHA_NUMERIC`.
        """
        context: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgsDict']]
        """
        The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used.
        If the context is set but:
        1.  there is no record present when transforming a given value or
        2.  the field is not present when transforming a given value,
        a default tweak will be used.
        Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string.
        The tweak is constructed as a sequence of bytes in big endian byte order such that:
        *   a 64 bit integer is encoded followed by a single byte of value 1
        *   a string is encoded in UTF-8 format followed by a single byte of value 2
        Structure is documented below.
        """
        crypto_key: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgsDict']]
        """
        The key used by the encryption algorithm.
        Structure is documented below.
        """
        custom_alphabet: NotRequired[pulumi.Input[str]]
        """
        This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range \\[2, 95\\]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
        ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/``. Only one of this, `common_alphabet` or `radix` must be specified.
        """
        radix: NotRequired[pulumi.Input[int]]
        """
        The native way to select the alphabet. Must be in the range \\[2, 95\\]. Only one of this, `custom_alphabet` or `common_alphabet` must be specified.
        """
        surrogate_info_type: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgsDict']]
        """
        The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info\\_type\\_name(surrogate\\_character\\_count):surrogate
        For example, if the name of custom infoType is 'MY\\_TOKEN\\_INFO\\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\\_TOKEN\\_INFO\\_TYPE(3):abc'
        This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text.
        In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\\_TOKEN\\_TYPE
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs:
    def __init__(__self__, *,
                 common_alphabet: Optional[pulumi.Input[str]] = None,
                 context: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgs']] = None,
                 crypto_key: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgs']] = None,
                 custom_alphabet: Optional[pulumi.Input[str]] = None,
                 radix: Optional[pulumi.Input[int]] = None,
                 surrogate_info_type: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgs']] = None):
        """
        :param pulumi.Input[str] common_alphabet: Common alphabets. Only one of this, `custom_alphabet` or `radix` must be specified.
               Possible values are: `NUMERIC`, `HEXADECIMAL`, `UPPER_CASE_ALPHA_NUMERIC`, `ALPHA_NUMERIC`.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgs'] context: The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used.
               If the context is set but:
               1.  there is no record present when transforming a given value or
               2.  the field is not present when transforming a given value,
               a default tweak will be used.
               Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string.
               The tweak is constructed as a sequence of bytes in big endian byte order such that:
               *   a 64 bit integer is encoded followed by a single byte of value 1
               *   a string is encoded in UTF-8 format followed by a single byte of value 2
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgs'] crypto_key: The key used by the encryption algorithm.
               Structure is documented below.
        :param pulumi.Input[str] custom_alphabet: This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range \\[2, 95\\]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
               ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/``. Only one of this, `common_alphabet` or `radix` must be specified.
        :param pulumi.Input[int] radix: The native way to select the alphabet. Must be in the range \\[2, 95\\]. Only one of this, `custom_alphabet` or `common_alphabet` must be specified.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgs'] surrogate_info_type: The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info\\_type\\_name(surrogate\\_character\\_count):surrogate
               For example, if the name of custom infoType is 'MY\\_TOKEN\\_INFO\\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\\_TOKEN\\_INFO\\_TYPE(3):abc'
               This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text.
               In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\\_TOKEN\\_TYPE
               Structure is documented below.
        """
        if common_alphabet is not None:
            pulumi.set(__self__, "common_alphabet", common_alphabet)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if crypto_key is not None:
            pulumi.set(__self__, "crypto_key", crypto_key)
        if custom_alphabet is not None:
            pulumi.set(__self__, "custom_alphabet", custom_alphabet)
        if radix is not None:
            pulumi.set(__self__, "radix", radix)
        if surrogate_info_type is not None:
            pulumi.set(__self__, "surrogate_info_type", surrogate_info_type)

    @property
    @pulumi.getter(name="commonAlphabet")
    def common_alphabet(self) -> Optional[pulumi.Input[str]]:
        """
        Common alphabets. Only one of this, `custom_alphabet` or `radix` must be specified.
        Possible values are: `NUMERIC`, `HEXADECIMAL`, `UPPER_CASE_ALPHA_NUMERIC`, `ALPHA_NUMERIC`.
        """
        return pulumi.get(self, "common_alphabet")

    @common_alphabet.setter
    def common_alphabet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_alphabet", value)

    @property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgs']]:
        """
        The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used.
        If the context is set but:
        1.  there is no record present when transforming a given value or
        2.  the field is not present when transforming a given value,
        a default tweak will be used.
        Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string.
        The tweak is constructed as a sequence of bytes in big endian byte order such that:
        *   a 64 bit integer is encoded followed by a single byte of value 1
        *   a string is encoded in UTF-8 format followed by a single byte of value 2
        Structure is documented below.
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgs']]):
        pulumi.set(self, "context", value)

    @property
    @pulumi.getter(name="cryptoKey")
    def crypto_key(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgs']]:
        """
        The key used by the encryption algorithm.
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_key")

    @crypto_key.setter
    def crypto_key(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgs']]):
        pulumi.set(self, "crypto_key", value)

    @property
    @pulumi.getter(name="customAlphabet")
    def custom_alphabet(self) -> Optional[pulumi.Input[str]]:
        """
        This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range \\[2, 95\\]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
        ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/``. Only one of this, `common_alphabet` or `radix` must be specified.
        """
        return pulumi.get(self, "custom_alphabet")

    @custom_alphabet.setter
    def custom_alphabet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_alphabet", value)

    @property
    @pulumi.getter
    def radix(self) -> Optional[pulumi.Input[int]]:
        """
        The native way to select the alphabet. Must be in the range \\[2, 95\\]. Only one of this, `custom_alphabet` or `common_alphabet` must be specified.
        """
        return pulumi.get(self, "radix")

    @radix.setter
    def radix(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "radix", value)

    @property
    @pulumi.getter(name="surrogateInfoType")
    def surrogate_info_type(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgs']]:
        """
        The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info\\_type\\_name(surrogate\\_character\\_count):surrogate
        For example, if the name of custom infoType is 'MY\\_TOKEN\\_INFO\\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\\_TOKEN\\_INFO\\_TYPE(3):abc'
        This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text.
        In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\\_TOKEN\\_TYPE
        Structure is documented below.
        """
        return pulumi.get(self, "surrogate_info_type")

    @surrogate_info_type.setter
    def surrogate_info_type(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgs']]):
        pulumi.set(self, "surrogate_info_type", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name describing the field.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name describing the field.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name describing the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgsDict(TypedDict):
        kms_wrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgsDict']]
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        transient: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgsDict']]
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        unwrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgsDict']]
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgs:
    def __init__(__self__, *,
                 kms_wrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgs']] = None,
                 transient: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgs']] = None,
                 unwrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgs'] kms_wrapped: KMS wrapped key.
               Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
               For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
               Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgs'] transient: Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgs'] unwrapped: Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
               Structure is documented below.
        """
        if kms_wrapped is not None:
            pulumi.set(__self__, "kms_wrapped", kms_wrapped)
        if transient is not None:
            pulumi.set(__self__, "transient", transient)
        if unwrapped is not None:
            pulumi.set(__self__, "unwrapped", unwrapped)

    @property
    @pulumi.getter(name="kmsWrapped")
    def kms_wrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgs']]:
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        return pulumi.get(self, "kms_wrapped")

    @kms_wrapped.setter
    def kms_wrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgs']]):
        pulumi.set(self, "kms_wrapped", value)

    @property
    @pulumi.getter
    def transient(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgs']]:
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "transient")

    @transient.setter
    def transient(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgs']]):
        pulumi.set(self, "transient", value)

    @property
    @pulumi.getter
    def unwrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgs']]:
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "unwrapped")

    @unwrapped.setter
    def unwrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgs']]):
        pulumi.set(self, "unwrapped", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgsDict(TypedDict):
        crypto_key_name: pulumi.Input[str]
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        wrapped_key: pulumi.Input[str]
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgs:
    def __init__(__self__, *,
                 crypto_key_name: pulumi.Input[str],
                 wrapped_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] crypto_key_name: The resource name of the KMS CryptoKey to use for unwrapping.
        :param pulumi.Input[str] wrapped_key: The wrapped data crypto key.
               A base64-encoded string.
        """
        pulumi.set(__self__, "crypto_key_name", crypto_key_name)
        pulumi.set(__self__, "wrapped_key", wrapped_key)

    @property
    @pulumi.getter(name="cryptoKeyName")
    def crypto_key_name(self) -> pulumi.Input[str]:
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        return pulumi.get(self, "crypto_key_name")

    @crypto_key_name.setter
    def crypto_key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "crypto_key_name", value)

    @property
    @pulumi.getter(name="wrappedKey")
    def wrapped_key(self) -> pulumi.Input[str]:
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
        return pulumi.get(self, "wrapped_key")

    @wrapped_key.setter
    def wrapped_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "wrapped_key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: A 128/192/256 bit key.
               A base64-encoded string.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Optional version name for this InfoType.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 sensitivity_score: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input[str] version: Optional version name for this InfoType.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Optional version name for this InfoType.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgsDict(TypedDict):
        lower_bound_days: pulumi.Input[int]
        """
        For example, -5 means shift date to at most 5 days back in the past.
        """
        upper_bound_days: pulumi.Input[int]
        """
        Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
        For example, 3 means shift date to at most 3 days into the future.
        """
        context: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgsDict']]
        """
        Points to the field that contains the context, for example, an entity id.
        If set, must also set cryptoKey. If set, shift will be consistent for the given context.
        Structure is documented below.
        """
        crypto_key: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgsDict']]
        """
        Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and cryptoKey. If set, must also set context. Can only be applied to table items.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgs:
    def __init__(__self__, *,
                 lower_bound_days: pulumi.Input[int],
                 upper_bound_days: pulumi.Input[int],
                 context: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgs']] = None,
                 crypto_key: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgs']] = None):
        """
        :param pulumi.Input[int] lower_bound_days: For example, -5 means shift date to at most 5 days back in the past.
        :param pulumi.Input[int] upper_bound_days: Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
               For example, 3 means shift date to at most 3 days into the future.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgs'] context: Points to the field that contains the context, for example, an entity id.
               If set, must also set cryptoKey. If set, shift will be consistent for the given context.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgs'] crypto_key: Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and cryptoKey. If set, must also set context. Can only be applied to table items.
               Structure is documented below.
        """
        pulumi.set(__self__, "lower_bound_days", lower_bound_days)
        pulumi.set(__self__, "upper_bound_days", upper_bound_days)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if crypto_key is not None:
            pulumi.set(__self__, "crypto_key", crypto_key)

    @property
    @pulumi.getter(name="lowerBoundDays")
    def lower_bound_days(self) -> pulumi.Input[int]:
        """
        For example, -5 means shift date to at most 5 days back in the past.
        """
        return pulumi.get(self, "lower_bound_days")

    @lower_bound_days.setter
    def lower_bound_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "lower_bound_days", value)

    @property
    @pulumi.getter(name="upperBoundDays")
    def upper_bound_days(self) -> pulumi.Input[int]:
        """
        Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
        For example, 3 means shift date to at most 3 days into the future.
        """
        return pulumi.get(self, "upper_bound_days")

    @upper_bound_days.setter
    def upper_bound_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "upper_bound_days", value)

    @property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgs']]:
        """
        Points to the field that contains the context, for example, an entity id.
        If set, must also set cryptoKey. If set, shift will be consistent for the given context.
        Structure is documented below.
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgs']]):
        pulumi.set(self, "context", value)

    @property
    @pulumi.getter(name="cryptoKey")
    def crypto_key(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgs']]:
        """
        Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and cryptoKey. If set, must also set context. Can only be applied to table items.
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_key")

    @crypto_key.setter
    def crypto_key(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgs']]):
        pulumi.set(self, "crypto_key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name describing the field.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name describing the field.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name describing the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgsDict(TypedDict):
        kms_wrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgsDict']]
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        transient: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgsDict']]
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        unwrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgsDict']]
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgs:
    def __init__(__self__, *,
                 kms_wrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgs']] = None,
                 transient: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgs']] = None,
                 unwrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgs'] kms_wrapped: KMS wrapped key.
               Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
               For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
               Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgs'] transient: Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgs'] unwrapped: Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
               Structure is documented below.
        """
        if kms_wrapped is not None:
            pulumi.set(__self__, "kms_wrapped", kms_wrapped)
        if transient is not None:
            pulumi.set(__self__, "transient", transient)
        if unwrapped is not None:
            pulumi.set(__self__, "unwrapped", unwrapped)

    @property
    @pulumi.getter(name="kmsWrapped")
    def kms_wrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgs']]:
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        return pulumi.get(self, "kms_wrapped")

    @kms_wrapped.setter
    def kms_wrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgs']]):
        pulumi.set(self, "kms_wrapped", value)

    @property
    @pulumi.getter
    def transient(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgs']]:
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "transient")

    @transient.setter
    def transient(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgs']]):
        pulumi.set(self, "transient", value)

    @property
    @pulumi.getter
    def unwrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgs']]:
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "unwrapped")

    @unwrapped.setter
    def unwrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgs']]):
        pulumi.set(self, "unwrapped", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgsDict(TypedDict):
        crypto_key_name: pulumi.Input[str]
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        wrapped_key: pulumi.Input[str]
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgs:
    def __init__(__self__, *,
                 crypto_key_name: pulumi.Input[str],
                 wrapped_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] crypto_key_name: The resource name of the KMS CryptoKey to use for unwrapping.
        :param pulumi.Input[str] wrapped_key: The wrapped data crypto key.
               A base64-encoded string.
        """
        pulumi.set(__self__, "crypto_key_name", crypto_key_name)
        pulumi.set(__self__, "wrapped_key", wrapped_key)

    @property
    @pulumi.getter(name="cryptoKeyName")
    def crypto_key_name(self) -> pulumi.Input[str]:
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        return pulumi.get(self, "crypto_key_name")

    @crypto_key_name.setter
    def crypto_key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "crypto_key_name", value)

    @property
    @pulumi.getter(name="wrappedKey")
    def wrapped_key(self) -> pulumi.Input[str]:
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
        return pulumi.get(self, "wrapped_key")

    @wrapped_key.setter
    def wrapped_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "wrapped_key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: A 128/192/256 bit key.
               A base64-encoded string.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgsDict(TypedDict):
        bucket_size: pulumi.Input[float]
        """
        Size of each bucket (except for minimum and maximum buckets).
        So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
        Precision up to 2 decimals works.
        """
        lower_bound: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgsDict']
        """
        Lower bound value of buckets.
        All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
        The `lower_bound` block must only contain one argument. See the `fixed_size_bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
        upper_bound: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgsDict']
        """
        Upper bound value of buckets.
        All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
        The `upper_bound` block must only contain one argument. See the `fixed_size_bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs:
    def __init__(__self__, *,
                 bucket_size: pulumi.Input[float],
                 lower_bound: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgs'],
                 upper_bound: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgs']):
        """
        :param pulumi.Input[float] bucket_size: Size of each bucket (except for minimum and maximum buckets).
               So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
               Precision up to 2 decimals works.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgs'] lower_bound: Lower bound value of buckets.
               All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
               The `lower_bound` block must only contain one argument. See the `fixed_size_bucketing_config` block description for more information about choosing a data type.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgs'] upper_bound: Upper bound value of buckets.
               All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
               The `upper_bound` block must only contain one argument. See the `fixed_size_bucketing_config` block description for more information about choosing a data type.
               Structure is documented below.
        """
        pulumi.set(__self__, "bucket_size", bucket_size)
        pulumi.set(__self__, "lower_bound", lower_bound)
        pulumi.set(__self__, "upper_bound", upper_bound)

    @property
    @pulumi.getter(name="bucketSize")
    def bucket_size(self) -> pulumi.Input[float]:
        """
        Size of each bucket (except for minimum and maximum buckets).
        So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
        Precision up to 2 decimals works.
        """
        return pulumi.get(self, "bucket_size")

    @bucket_size.setter
    def bucket_size(self, value: pulumi.Input[float]):
        pulumi.set(self, "bucket_size", value)

    @property
    @pulumi.getter(name="lowerBound")
    def lower_bound(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgs']:
        """
        Lower bound value of buckets.
        All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
        The `lower_bound` block must only contain one argument. See the `fixed_size_bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
        return pulumi.get(self, "lower_bound")

    @lower_bound.setter
    def lower_bound(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgs']):
        pulumi.set(self, "lower_bound", value)

    @property
    @pulumi.getter(name="upperBound")
    def upper_bound(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgs']:
        """
        Upper bound value of buckets.
        All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
        The `upper_bound` block must only contain one argument. See the `fixed_size_bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
        return pulumi.get(self, "upper_bound")

    @upper_bound.setter
    def upper_bound(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgs']):
        pulumi.set(self, "upper_bound", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgsDict(TypedDict):
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        An integer value (int64 format)
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgs:
    def __init__(__self__, *,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[str] integer_value: An integer value (int64 format)
        """
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgsDict(TypedDict):
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        An integer value (int64 format)
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgs:
    def __init__(__self__, *,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[str] integer_value: An integer value (int64 format)
        """
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgsDict(TypedDict):
        pass
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgsDict(TypedDict):
        new_value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgsDict']
        """
        Replace each input value with a given value.
        The `new_value` block must only contain one argument. For example when replacing the contents of a string-type field, only `string_value` should be set.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgs:
    def __init__(__self__, *,
                 new_value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgs']):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgs'] new_value: Replace each input value with a given value.
               The `new_value` block must only contain one argument. For example when replacing the contents of a string-type field, only `string_value` should be set.
               Structure is documented below.
        """
        pulumi.set(__self__, "new_value", new_value)

    @property
    @pulumi.getter(name="newValue")
    def new_value(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgs']:
        """
        Replace each input value with a given value.
        The `new_value` block must only contain one argument. For example when replacing the contents of a string-type field, only `string_value` should be set.
        Structure is documented below.
        """
        return pulumi.get(self, "new_value")

    @new_value.setter
    def new_value(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgs']):
        pulumi.set(self, "new_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgsDict(TypedDict):
        boolean_value: NotRequired[pulumi.Input[bool]]
        """
        A boolean value.
        """
        date_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgsDict']]
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        day_of_week_value: NotRequired[pulumi.Input[str]]
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[int]]
        """
        An integer value (int64 format)
        """
        string_value: NotRequired[pulumi.Input[str]]
        """
        A string value.
        """
        time_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgsDict']]
        """
        Represents a time of day.
        Structure is documented below.
        """
        timestamp_value: NotRequired[pulumi.Input[str]]
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
        Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgs:
    def __init__(__self__, *,
                 boolean_value: Optional[pulumi.Input[bool]] = None,
                 date_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgs']] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[int]] = None,
                 string_value: Optional[pulumi.Input[str]] = None,
                 time_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgs']] = None,
                 timestamp_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] boolean_value: A boolean value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgs'] date_value: Represents a whole or partial calendar date.
               Structure is documented below.
        :param pulumi.Input[str] day_of_week_value: Represents a day of the week.
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[int] integer_value: An integer value (int64 format)
        :param pulumi.Input[str] string_value: A string value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgs'] time_value: Represents a time of day.
               Structure is documented below.
        :param pulumi.Input[str] timestamp_value: A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
               Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        if boolean_value is not None:
            pulumi.set(__self__, "boolean_value", boolean_value)
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if time_value is not None:
            pulumi.set(__self__, "time_value", time_value)
        if timestamp_value is not None:
            pulumi.set(__self__, "timestamp_value", timestamp_value)

    @property
    @pulumi.getter(name="booleanValue")
    def boolean_value(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value.
        """
        return pulumi.get(self, "boolean_value")

    @boolean_value.setter
    def boolean_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean_value", value)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgs']]:
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgs']]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[int]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "integer_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        A string value.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)

    @property
    @pulumi.getter(name="timeValue")
    def time_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgs']]:
        """
        Represents a time of day.
        Structure is documented below.
        """
        return pulumi.get(self, "time_value")

    @time_value.setter
    def time_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgs']]):
        pulumi.set(self, "time_value", value)

    @property
    @pulumi.getter(name="timestampValue")
    def timestamp_value(self) -> Optional[pulumi.Input[str]]:
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
        Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "timestamp_value")

    @timestamp_value.setter
    def timestamp_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
               
               - - -
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgsDict(TypedDict):
        word_list: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgsDict']
        """
        A list of words to select from for random replacement. The [limits](https://cloud.google.com/dlp/limits) page contains details about the size limits of dictionaries.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgs:
    def __init__(__self__, *,
                 word_list: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgs']):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgs'] word_list: A list of words to select from for random replacement. The [limits](https://cloud.google.com/dlp/limits) page contains details about the size limits of dictionaries.
               Structure is documented below.
        """
        pulumi.set(__self__, "word_list", word_list)

    @property
    @pulumi.getter(name="wordList")
    def word_list(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgs']:
        """
        A list of words to select from for random replacement. The [limits](https://cloud.google.com/dlp/limits) page contains details about the size limits of dictionaries.
        Structure is documented below.
        """
        return pulumi.get(self, "word_list")

    @word_list.setter
    def word_list(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgs']):
        pulumi.set(self, "word_list", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgsDict(TypedDict):
        words: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgs:
    def __init__(__self__, *,
                 words: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] words: Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
        pulumi.set(__self__, "words", words)

    @property
    @pulumi.getter
    def words(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
        return pulumi.get(self, "words")

    @words.setter
    def words(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "words", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgsDict(TypedDict):
        part_to_extract: NotRequired[pulumi.Input[str]]
        """
        The part of the time to keep.
        Possible values are: `YEAR`, `MONTH`, `DAY_OF_MONTH`, `DAY_OF_WEEK`, `WEEK_OF_YEAR`, `HOUR_OF_DAY`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgs:
    def __init__(__self__, *,
                 part_to_extract: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] part_to_extract: The part of the time to keep.
               Possible values are: `YEAR`, `MONTH`, `DAY_OF_MONTH`, `DAY_OF_WEEK`, `WEEK_OF_YEAR`, `HOUR_OF_DAY`.
        """
        if part_to_extract is not None:
            pulumi.set(__self__, "part_to_extract", part_to_extract)

    @property
    @pulumi.getter(name="partToExtract")
    def part_to_extract(self) -> Optional[pulumi.Input[str]]:
        """
        The part of the time to keep.
        Possible values are: `YEAR`, `MONTH`, `DAY_OF_MONTH`, `DAY_OF_WEEK`, `WEEK_OF_YEAR`, `HOUR_OF_DAY`.
        """
        return pulumi.get(self, "part_to_extract")

    @part_to_extract.setter
    def part_to_extract(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "part_to_extract", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsArgsDict(TypedDict):
        field_transformations: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgsDict']]]]
        """
        Transform the record by applying various field transformations.
        Structure is documented below.
        """
        record_suppressions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionArgsDict']]]]
        """
        Configuration defining which records get suppressed entirely. Records that match any suppression rule are omitted from the output.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsArgs:
    def __init__(__self__, *,
                 field_transformations: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgs']]]] = None,
                 record_suppressions: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgs']]] field_transformations: Transform the record by applying various field transformations.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionArgs']]] record_suppressions: Configuration defining which records get suppressed entirely. Records that match any suppression rule are omitted from the output.
               Structure is documented below.
        """
        if field_transformations is not None:
            pulumi.set(__self__, "field_transformations", field_transformations)
        if record_suppressions is not None:
            pulumi.set(__self__, "record_suppressions", record_suppressions)

    @property
    @pulumi.getter(name="fieldTransformations")
    def field_transformations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgs']]]]:
        """
        Transform the record by applying various field transformations.
        Structure is documented below.
        """
        return pulumi.get(self, "field_transformations")

    @field_transformations.setter
    def field_transformations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgs']]]]):
        pulumi.set(self, "field_transformations", value)

    @property
    @pulumi.getter(name="recordSuppressions")
    def record_suppressions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionArgs']]]]:
        """
        Configuration defining which records get suppressed entirely. Records that match any suppression rule are omitted from the output.
        Structure is documented below.
        """
        return pulumi.get(self, "record_suppressions")

    @record_suppressions.setter
    def record_suppressions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionArgs']]]]):
        pulumi.set(self, "record_suppressions", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgsDict(TypedDict):
        fields: pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationFieldArgsDict']]]
        """
        Input field(s) to apply the transformation to. When you have columns that reference their position within a list, omit the index from the FieldId.
        FieldId name matching ignores the index. For example, instead of "contact.nums[0].type", use "contact.nums.type".
        Structure is documented below.
        """
        condition: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionArgsDict']]
        """
        Only apply the transformation if the condition evaluates to true for the given RecordCondition. The conditions are allowed to reference fields that are not used in the actual transformation.
        Example Use Cases:
        - Apply a different bucket transformation to an age column if the zip code column for the same record is within a specific range.
        - Redact a field if the date of birth field is greater than 85.
        Structure is documented below.
        """
        info_type_transformations: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsArgsDict']]
        """
        Treat the contents of the field as free text, and selectively transform content that matches an InfoType.
        Only one of `primitive_transformation` or `info_type_transformations` must be specified.
        Structure is documented below.
        """
        primitive_transformation: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgsDict']]
        """
        Apply the transformation to the entire field.
        The `primitive_transformation` block must only contain one argument, corresponding to the type of transformation.
        Only one of `primitive_transformation` or `info_type_transformations` must be specified.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationArgs:
    def __init__(__self__, *,
                 fields: pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationFieldArgs']]],
                 condition: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionArgs']] = None,
                 info_type_transformations: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsArgs']] = None,
                 primitive_transformation: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationFieldArgs']]] fields: Input field(s) to apply the transformation to. When you have columns that reference their position within a list, omit the index from the FieldId.
               FieldId name matching ignores the index. For example, instead of "contact.nums[0].type", use "contact.nums.type".
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionArgs'] condition: Only apply the transformation if the condition evaluates to true for the given RecordCondition. The conditions are allowed to reference fields that are not used in the actual transformation.
               Example Use Cases:
               - Apply a different bucket transformation to an age column if the zip code column for the same record is within a specific range.
               - Redact a field if the date of birth field is greater than 85.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsArgs'] info_type_transformations: Treat the contents of the field as free text, and selectively transform content that matches an InfoType.
               Only one of `primitive_transformation` or `info_type_transformations` must be specified.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs'] primitive_transformation: Apply the transformation to the entire field.
               The `primitive_transformation` block must only contain one argument, corresponding to the type of transformation.
               Only one of `primitive_transformation` or `info_type_transformations` must be specified.
               Structure is documented below.
        """
        pulumi.set(__self__, "fields", fields)
        if condition is not None:
            pulumi.set(__self__, "condition", condition)
        if info_type_transformations is not None:
            pulumi.set(__self__, "info_type_transformations", info_type_transformations)
        if primitive_transformation is not None:
            pulumi.set(__self__, "primitive_transformation", primitive_transformation)

    @property
    @pulumi.getter
    def fields(self) -> pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationFieldArgs']]]:
        """
        Input field(s) to apply the transformation to. When you have columns that reference their position within a list, omit the index from the FieldId.
        FieldId name matching ignores the index. For example, instead of "contact.nums[0].type", use "contact.nums.type".
        Structure is documented below.
        """
        return pulumi.get(self, "fields")

    @fields.setter
    def fields(self, value: pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationFieldArgs']]]):
        pulumi.set(self, "fields", value)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionArgs']]:
        """
        Only apply the transformation if the condition evaluates to true for the given RecordCondition. The conditions are allowed to reference fields that are not used in the actual transformation.
        Example Use Cases:
        - Apply a different bucket transformation to an age column if the zip code column for the same record is within a specific range.
        - Redact a field if the date of birth field is greater than 85.
        Structure is documented below.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionArgs']]):
        pulumi.set(self, "condition", value)

    @property
    @pulumi.getter(name="infoTypeTransformations")
    def info_type_transformations(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsArgs']]:
        """
        Treat the contents of the field as free text, and selectively transform content that matches an InfoType.
        Only one of `primitive_transformation` or `info_type_transformations` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "info_type_transformations")

    @info_type_transformations.setter
    def info_type_transformations(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsArgs']]):
        pulumi.set(self, "info_type_transformations", value)

    @property
    @pulumi.getter(name="primitiveTransformation")
    def primitive_transformation(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs']]:
        """
        Apply the transformation to the entire field.
        The `primitive_transformation` block must only contain one argument, corresponding to the type of transformation.
        Only one of `primitive_transformation` or `info_type_transformations` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "primitive_transformation")

    @primitive_transformation.setter
    def primitive_transformation(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs']]):
        pulumi.set(self, "primitive_transformation", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionArgsDict(TypedDict):
        expressions: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsArgsDict']]
        """
        An expression, consisting of an operator and conditions.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionArgs:
    def __init__(__self__, *,
                 expressions: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsArgs'] expressions: An expression, consisting of an operator and conditions.
               Structure is documented below.
        """
        if expressions is not None:
            pulumi.set(__self__, "expressions", expressions)

    @property
    @pulumi.getter
    def expressions(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsArgs']]:
        """
        An expression, consisting of an operator and conditions.
        Structure is documented below.
        """
        return pulumi.get(self, "expressions")

    @expressions.setter
    def expressions(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsArgs']]):
        pulumi.set(self, "expressions", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsArgsDict(TypedDict):
        conditions: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsArgsDict']]
        """
        Conditions to apply to the expression.
        Structure is documented below.
        """
        logical_operator: NotRequired[pulumi.Input[str]]
        """
        The operator to apply to the result of conditions. Default and currently only supported value is AND.
        Default value is `AND`.
        Possible values are: `AND`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsArgs']] = None,
                 logical_operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsArgs'] conditions: Conditions to apply to the expression.
               Structure is documented below.
        :param pulumi.Input[str] logical_operator: The operator to apply to the result of conditions. Default and currently only supported value is AND.
               Default value is `AND`.
               Possible values are: `AND`.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if logical_operator is not None:
            pulumi.set(__self__, "logical_operator", logical_operator)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsArgs']]:
        """
        Conditions to apply to the expression.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsArgs']]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="logicalOperator")
    def logical_operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to apply to the result of conditions. Default and currently only supported value is AND.
        Default value is `AND`.
        Possible values are: `AND`.
        """
        return pulumi.get(self, "logical_operator")

    @logical_operator.setter
    def logical_operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logical_operator", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsArgsDict(TypedDict):
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionArgsDict']]]]
        """
        A collection of conditions.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionArgs']]] conditions: A collection of conditions.
               Structure is documented below.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionArgs']]]]:
        """
        A collection of conditions.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionArgs']]]]):
        pulumi.set(self, "conditions", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionArgsDict(TypedDict):
        field: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionFieldArgsDict']
        """
        Field within the record this condition is evaluated against.
        Structure is documented below.
        """
        operator: pulumi.Input[str]
        """
        Operator used to compare the field or infoType to the value.
        Possible values are: `EQUAL_TO`, `NOT_EQUAL_TO`, `GREATER_THAN`, `LESS_THAN`, `GREATER_THAN_OR_EQUALS`, `LESS_THAN_OR_EQUALS`, `EXISTS`.
        """
        value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueArgsDict']]
        """
        Value to compare against. [Mandatory, except for EXISTS tests.]
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionFieldArgs'],
                 operator: pulumi.Input[str],
                 value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionFieldArgs'] field: Field within the record this condition is evaluated against.
               Structure is documented below.
        :param pulumi.Input[str] operator: Operator used to compare the field or infoType to the value.
               Possible values are: `EQUAL_TO`, `NOT_EQUAL_TO`, `GREATER_THAN`, `LESS_THAN`, `GREATER_THAN_OR_EQUALS`, `LESS_THAN_OR_EQUALS`, `EXISTS`.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueArgs'] value: Value to compare against. [Mandatory, except for EXISTS tests.]
               Structure is documented below.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def field(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionFieldArgs']:
        """
        Field within the record this condition is evaluated against.
        Structure is documented below.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionFieldArgs']):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Operator used to compare the field or infoType to the value.
        Possible values are: `EQUAL_TO`, `NOT_EQUAL_TO`, `GREATER_THAN`, `LESS_THAN`, `GREATER_THAN_OR_EQUALS`, `LESS_THAN_OR_EQUALS`, `EXISTS`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueArgs']]:
        """
        Value to compare against. [Mandatory, except for EXISTS tests.]
        Structure is documented below.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueArgs']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionFieldArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name describing the field.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionFieldArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name describing the field.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name describing the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueArgsDict(TypedDict):
        boolean_value: NotRequired[pulumi.Input[bool]]
        """
        A boolean value.
        """
        date_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueDateValueArgsDict']]
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        day_of_week_value: NotRequired[pulumi.Input[str]]
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        An integer value (int64 format)
        """
        string_value: NotRequired[pulumi.Input[str]]
        """
        A string value.
        """
        time_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueTimeValueArgsDict']]
        """
        Represents a time of day.
        Structure is documented below.
        """
        timestamp_value: NotRequired[pulumi.Input[str]]
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueArgs:
    def __init__(__self__, *,
                 boolean_value: Optional[pulumi.Input[bool]] = None,
                 date_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueDateValueArgs']] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None,
                 string_value: Optional[pulumi.Input[str]] = None,
                 time_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueTimeValueArgs']] = None,
                 timestamp_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] boolean_value: A boolean value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueDateValueArgs'] date_value: Represents a whole or partial calendar date.
               Structure is documented below.
        :param pulumi.Input[str] day_of_week_value: Represents a day of the week.
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[str] integer_value: An integer value (int64 format)
        :param pulumi.Input[str] string_value: A string value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueTimeValueArgs'] time_value: Represents a time of day.
               Structure is documented below.
        :param pulumi.Input[str] timestamp_value: A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        if boolean_value is not None:
            pulumi.set(__self__, "boolean_value", boolean_value)
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if time_value is not None:
            pulumi.set(__self__, "time_value", time_value)
        if timestamp_value is not None:
            pulumi.set(__self__, "timestamp_value", timestamp_value)

    @property
    @pulumi.getter(name="booleanValue")
    def boolean_value(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value.
        """
        return pulumi.get(self, "boolean_value")

    @boolean_value.setter
    def boolean_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean_value", value)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueDateValueArgs']]:
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueDateValueArgs']]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        A string value.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)

    @property
    @pulumi.getter(name="timeValue")
    def time_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueTimeValueArgs']]:
        """
        Represents a time of day.
        Structure is documented below.
        """
        return pulumi.get(self, "time_value")

    @time_value.setter
    def time_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueTimeValueArgs']]):
        pulumi.set(self, "time_value", value)

    @property
    @pulumi.getter(name="timestampValue")
    def timestamp_value(self) -> Optional[pulumi.Input[str]]:
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "timestamp_value")

    @timestamp_value.setter
    def timestamp_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueDateValueArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueDateValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueDateValueArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
               
               - - -
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueTimeValueArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueTimeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationConditionExpressionsConditionsConditionValueTimeValueArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationFieldArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name describing the field.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationFieldArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name describing the field.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name describing the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsArgsDict(TypedDict):
        transformations: pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationArgsDict']]]
        """
        Transformation for each infoType. Cannot specify more than one for a given infoType.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsArgs:
    def __init__(__self__, *,
                 transformations: pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationArgs']]] transformations: Transformation for each infoType. Cannot specify more than one for a given infoType.
               Structure is documented below.
        """
        pulumi.set(__self__, "transformations", transformations)

    @property
    @pulumi.getter
    def transformations(self) -> pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationArgs']]]:
        """
        Transformation for each infoType. Cannot specify more than one for a given infoType.
        Structure is documented below.
        """
        return pulumi.get(self, "transformations")

    @transformations.setter
    def transformations(self, value: pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationArgs']]]):
        pulumi.set(self, "transformations", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationArgsDict(TypedDict):
        primitive_transformation: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationArgsDict']
        """
        Apply the transformation to the entire field.
        The `primitive_transformation` block must only contain one argument, corresponding to the type of transformation.
        Structure is documented below.
        """
        info_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeArgsDict']]]]
        """
        InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
        all findings that correspond to infoTypes that were requested in InspectConfig.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationArgs:
    def __init__(__self__, *,
                 primitive_transformation: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationArgs'],
                 info_types: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeArgs']]]] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationArgs'] primitive_transformation: Apply the transformation to the entire field.
               The `primitive_transformation` block must only contain one argument, corresponding to the type of transformation.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeArgs']]] info_types: InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
               all findings that correspond to infoTypes that were requested in InspectConfig.
               Structure is documented below.
        """
        pulumi.set(__self__, "primitive_transformation", primitive_transformation)
        if info_types is not None:
            pulumi.set(__self__, "info_types", info_types)

    @property
    @pulumi.getter(name="primitiveTransformation")
    def primitive_transformation(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationArgs']:
        """
        Apply the transformation to the entire field.
        The `primitive_transformation` block must only contain one argument, corresponding to the type of transformation.
        Structure is documented below.
        """
        return pulumi.get(self, "primitive_transformation")

    @primitive_transformation.setter
    def primitive_transformation(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationArgs']):
        pulumi.set(self, "primitive_transformation", value)

    @property
    @pulumi.getter(name="infoTypes")
    def info_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeArgs']]]]:
        """
        InfoTypes to apply the transformation to. Leaving this empty will apply the transformation to apply to
        all findings that correspond to infoTypes that were requested in InspectConfig.
        Structure is documented below.
        """
        return pulumi.get(self, "info_types")

    @info_types.setter
    def info_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeArgs']]]]):
        pulumi.set(self, "info_types", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the information type.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version name for this InfoType.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 sensitivity_score: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the information type.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input[str] version: Version name for this InfoType.
        """
        pulumi.set(__self__, "name", name)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the information type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version name for this InfoType.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationArgsDict(TypedDict):
        bucketing_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgsDict']]
        """
        Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 > LOW 31-65 > MEDIUM 66-100 > HIGH
        This can be used on data of type: number, long, string, timestamp.
        If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
        See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
        Structure is documented below.
        """
        character_mask_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgsDict']]
        """
        Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. This can be used on data of any type (numbers, longs, and so on) and when de-identifying structured data we'll attempt to preserve the original data's type. (This allows you to take a long like 123 and modify it to a string like **3).
        Structure is documented below.
        """
        crypto_deterministic_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgsDict']]
        """
        Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC [https://tools.ietf.org/html/rfc5297](https://tools.ietf.org/html/rfc5297).
        Structure is documented below.
        """
        crypto_hash_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgsDict']]
        """
        Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
        Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
        Currently, only string and integer values can be hashed.
        See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
        Structure is documented below.
        """
        crypto_replace_ffx_fpe_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgsDict']]
        """
        Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the `content.reidentify` API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See [https://cloud.google.com/dlp/docs/pseudonymization](https://cloud.google.com/dlp/docs/pseudonymization) to learn more.
        Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
        Structure is documented below.
        """
        date_shift_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgsDict']]
        """
        Shifts dates by random number of days, with option to be consistent for the same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting to learn more.
        Structure is documented below.
        """
        fixed_size_bucketing_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgsDict']]
        """
        Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
        The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
        This can be used on data of type: double, long.
        If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
        See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
        Structure is documented below.
        """
        redact_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgsDict']]
        """
        Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
        """
        replace_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgsDict']]
        """
        Replace each input value with a given value.
        Structure is documented below.
        """
        replace_dictionary_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgsDict']]
        """
        Replace with a value randomly drawn (with replacement) from a dictionary.
        Structure is documented below.
        """
        replace_with_info_type_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceWithInfoTypeConfigArgsDict']]
        """
        Replace each matching finding with the name of the info type.
        """
        time_part_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgsDict']]
        """
        For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationArgs:
    def __init__(__self__, *,
                 bucketing_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgs']] = None,
                 character_mask_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgs']] = None,
                 crypto_deterministic_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgs']] = None,
                 crypto_hash_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgs']] = None,
                 crypto_replace_ffx_fpe_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs']] = None,
                 date_shift_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgs']] = None,
                 fixed_size_bucketing_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs']] = None,
                 redact_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgs']] = None,
                 replace_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgs']] = None,
                 replace_dictionary_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgs']] = None,
                 replace_with_info_type_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceWithInfoTypeConfigArgs']] = None,
                 time_part_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgs'] bucketing_config: Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 > LOW 31-65 > MEDIUM 66-100 > HIGH
               This can be used on data of type: number, long, string, timestamp.
               If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
               See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgs'] character_mask_config: Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. This can be used on data of any type (numbers, longs, and so on) and when de-identifying structured data we'll attempt to preserve the original data's type. (This allows you to take a long like 123 and modify it to a string like **3).
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgs'] crypto_deterministic_config: Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC [https://tools.ietf.org/html/rfc5297](https://tools.ietf.org/html/rfc5297).
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgs'] crypto_hash_config: Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
               Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
               Currently, only string and integer values can be hashed.
               See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs'] crypto_replace_ffx_fpe_config: Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the `content.reidentify` API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See [https://cloud.google.com/dlp/docs/pseudonymization](https://cloud.google.com/dlp/docs/pseudonymization) to learn more.
               Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgs'] date_shift_config: Shifts dates by random number of days, with option to be consistent for the same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting to learn more.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs'] fixed_size_bucketing_config: Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
               The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
               This can be used on data of type: double, long.
               If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
               See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgs'] redact_config: Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgs'] replace_config: Replace each input value with a given value.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgs'] replace_dictionary_config: Replace with a value randomly drawn (with replacement) from a dictionary.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceWithInfoTypeConfigArgs'] replace_with_info_type_config: Replace each matching finding with the name of the info type.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgs'] time_part_config: For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
               Structure is documented below.
        """
        if bucketing_config is not None:
            pulumi.set(__self__, "bucketing_config", bucketing_config)
        if character_mask_config is not None:
            pulumi.set(__self__, "character_mask_config", character_mask_config)
        if crypto_deterministic_config is not None:
            pulumi.set(__self__, "crypto_deterministic_config", crypto_deterministic_config)
        if crypto_hash_config is not None:
            pulumi.set(__self__, "crypto_hash_config", crypto_hash_config)
        if crypto_replace_ffx_fpe_config is not None:
            pulumi.set(__self__, "crypto_replace_ffx_fpe_config", crypto_replace_ffx_fpe_config)
        if date_shift_config is not None:
            pulumi.set(__self__, "date_shift_config", date_shift_config)
        if fixed_size_bucketing_config is not None:
            pulumi.set(__self__, "fixed_size_bucketing_config", fixed_size_bucketing_config)
        if redact_config is not None:
            pulumi.set(__self__, "redact_config", redact_config)
        if replace_config is not None:
            pulumi.set(__self__, "replace_config", replace_config)
        if replace_dictionary_config is not None:
            pulumi.set(__self__, "replace_dictionary_config", replace_dictionary_config)
        if replace_with_info_type_config is not None:
            pulumi.set(__self__, "replace_with_info_type_config", replace_with_info_type_config)
        if time_part_config is not None:
            pulumi.set(__self__, "time_part_config", time_part_config)

    @property
    @pulumi.getter(name="bucketingConfig")
    def bucketing_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgs']]:
        """
        Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 > LOW 31-65 > MEDIUM 66-100 > HIGH
        This can be used on data of type: number, long, string, timestamp.
        If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
        See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
        Structure is documented below.
        """
        return pulumi.get(self, "bucketing_config")

    @bucketing_config.setter
    def bucketing_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgs']]):
        pulumi.set(self, "bucketing_config", value)

    @property
    @pulumi.getter(name="characterMaskConfig")
    def character_mask_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgs']]:
        """
        Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. This can be used on data of any type (numbers, longs, and so on) and when de-identifying structured data we'll attempt to preserve the original data's type. (This allows you to take a long like 123 and modify it to a string like **3).
        Structure is documented below.
        """
        return pulumi.get(self, "character_mask_config")

    @character_mask_config.setter
    def character_mask_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgs']]):
        pulumi.set(self, "character_mask_config", value)

    @property
    @pulumi.getter(name="cryptoDeterministicConfig")
    def crypto_deterministic_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgs']]:
        """
        Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC [https://tools.ietf.org/html/rfc5297](https://tools.ietf.org/html/rfc5297).
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_deterministic_config")

    @crypto_deterministic_config.setter
    def crypto_deterministic_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgs']]):
        pulumi.set(self, "crypto_deterministic_config", value)

    @property
    @pulumi.getter(name="cryptoHashConfig")
    def crypto_hash_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgs']]:
        """
        Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
        Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
        Currently, only string and integer values can be hashed.
        See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_hash_config")

    @crypto_hash_config.setter
    def crypto_hash_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgs']]):
        pulumi.set(self, "crypto_hash_config", value)

    @property
    @pulumi.getter(name="cryptoReplaceFfxFpeConfig")
    def crypto_replace_ffx_fpe_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs']]:
        """
        Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the `content.reidentify` API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See [https://cloud.google.com/dlp/docs/pseudonymization](https://cloud.google.com/dlp/docs/pseudonymization) to learn more.
        Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_replace_ffx_fpe_config")

    @crypto_replace_ffx_fpe_config.setter
    def crypto_replace_ffx_fpe_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs']]):
        pulumi.set(self, "crypto_replace_ffx_fpe_config", value)

    @property
    @pulumi.getter(name="dateShiftConfig")
    def date_shift_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgs']]:
        """
        Shifts dates by random number of days, with option to be consistent for the same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting to learn more.
        Structure is documented below.
        """
        return pulumi.get(self, "date_shift_config")

    @date_shift_config.setter
    def date_shift_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgs']]):
        pulumi.set(self, "date_shift_config", value)

    @property
    @pulumi.getter(name="fixedSizeBucketingConfig")
    def fixed_size_bucketing_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs']]:
        """
        Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
        The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
        This can be used on data of type: double, long.
        If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
        See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
        Structure is documented below.
        """
        return pulumi.get(self, "fixed_size_bucketing_config")

    @fixed_size_bucketing_config.setter
    def fixed_size_bucketing_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs']]):
        pulumi.set(self, "fixed_size_bucketing_config", value)

    @property
    @pulumi.getter(name="redactConfig")
    def redact_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgs']]:
        """
        Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
        """
        return pulumi.get(self, "redact_config")

    @redact_config.setter
    def redact_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgs']]):
        pulumi.set(self, "redact_config", value)

    @property
    @pulumi.getter(name="replaceConfig")
    def replace_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgs']]:
        """
        Replace each input value with a given value.
        Structure is documented below.
        """
        return pulumi.get(self, "replace_config")

    @replace_config.setter
    def replace_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgs']]):
        pulumi.set(self, "replace_config", value)

    @property
    @pulumi.getter(name="replaceDictionaryConfig")
    def replace_dictionary_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgs']]:
        """
        Replace with a value randomly drawn (with replacement) from a dictionary.
        Structure is documented below.
        """
        return pulumi.get(self, "replace_dictionary_config")

    @replace_dictionary_config.setter
    def replace_dictionary_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgs']]):
        pulumi.set(self, "replace_dictionary_config", value)

    @property
    @pulumi.getter(name="replaceWithInfoTypeConfig")
    def replace_with_info_type_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceWithInfoTypeConfigArgs']]:
        """
        Replace each matching finding with the name of the info type.
        """
        return pulumi.get(self, "replace_with_info_type_config")

    @replace_with_info_type_config.setter
    def replace_with_info_type_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceWithInfoTypeConfigArgs']]):
        pulumi.set(self, "replace_with_info_type_config", value)

    @property
    @pulumi.getter(name="timePartConfig")
    def time_part_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgs']]:
        """
        For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
        Structure is documented below.
        """
        return pulumi.get(self, "time_part_config")

    @time_part_config.setter
    def time_part_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgs']]):
        pulumi.set(self, "time_part_config", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgsDict(TypedDict):
        buckets: pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgsDict']]]
        """
        Set of buckets. Ranges must be non-overlapping.
        Bucket is represented as a range, along with replacement values.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigArgs:
    def __init__(__self__, *,
                 buckets: pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgs']]] buckets: Set of buckets. Ranges must be non-overlapping.
               Bucket is represented as a range, along with replacement values.
               Structure is documented below.
        """
        pulumi.set(__self__, "buckets", buckets)

    @property
    @pulumi.getter
    def buckets(self) -> pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgs']]]:
        """
        Set of buckets. Ranges must be non-overlapping.
        Bucket is represented as a range, along with replacement values.
        Structure is documented below.
        """
        return pulumi.get(self, "buckets")

    @buckets.setter
    def buckets(self, value: pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgs']]]):
        pulumi.set(self, "buckets", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgsDict(TypedDict):
        replacement_value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgsDict']
        """
        Replacement value for this bucket.
        The `replacement_value` block must only contain one argument.
        Structure is documented below.
        """
        max: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgsDict']]
        """
        Upper bound of the range, exclusive; type must match min.
        The `max` block must only contain one argument. See the `bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
        min: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgsDict']]
        """
        Lower bound of the range, inclusive. Type should be the same as max if used.
        The `min` block must only contain one argument. See the `bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketArgs:
    def __init__(__self__, *,
                 replacement_value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgs'],
                 max: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgs']] = None,
                 min: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgs'] replacement_value: Replacement value for this bucket.
               The `replacement_value` block must only contain one argument.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgs'] max: Upper bound of the range, exclusive; type must match min.
               The `max` block must only contain one argument. See the `bucketing_config` block description for more information about choosing a data type.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgs'] min: Lower bound of the range, inclusive. Type should be the same as max if used.
               The `min` block must only contain one argument. See the `bucketing_config` block description for more information about choosing a data type.
               Structure is documented below.
        """
        pulumi.set(__self__, "replacement_value", replacement_value)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgs']:
        """
        Replacement value for this bucket.
        The `replacement_value` block must only contain one argument.
        Structure is documented below.
        """
        return pulumi.get(self, "replacement_value")

    @replacement_value.setter
    def replacement_value(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgs']):
        pulumi.set(self, "replacement_value", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgs']]:
        """
        Upper bound of the range, exclusive; type must match min.
        The `max` block must only contain one argument. See the `bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgs']]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgs']]:
        """
        Lower bound of the range, inclusive. Type should be the same as max if used.
        The `min` block must only contain one argument. See the `bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgs']]):
        pulumi.set(self, "min", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgsDict(TypedDict):
        date_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgsDict']]
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        day_of_week_value: NotRequired[pulumi.Input[str]]
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        An integer value (int64 format)
        """
        string_value: NotRequired[pulumi.Input[str]]
        """
        A string value.
        """
        time_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgsDict']]
        """
        Represents a time of day.
        Structure is documented below.
        """
        timestamp_value: NotRequired[pulumi.Input[str]]
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxArgs:
    def __init__(__self__, *,
                 date_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgs']] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None,
                 string_value: Optional[pulumi.Input[str]] = None,
                 time_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgs']] = None,
                 timestamp_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgs'] date_value: Represents a whole or partial calendar date.
               Structure is documented below.
        :param pulumi.Input[str] day_of_week_value: Represents a day of the week.
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[str] integer_value: An integer value (int64 format)
        :param pulumi.Input[str] string_value: A string value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgs'] time_value: Represents a time of day.
               Structure is documented below.
        :param pulumi.Input[str] timestamp_value: A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if time_value is not None:
            pulumi.set(__self__, "time_value", time_value)
        if timestamp_value is not None:
            pulumi.set(__self__, "timestamp_value", timestamp_value)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgs']]:
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgs']]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        A string value.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)

    @property
    @pulumi.getter(name="timeValue")
    def time_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgs']]:
        """
        Represents a time of day.
        Structure is documented below.
        """
        return pulumi.get(self, "time_value")

    @time_value.setter
    def time_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgs']]):
        pulumi.set(self, "time_value", value)

    @property
    @pulumi.getter(name="timestampValue")
    def timestamp_value(self) -> Optional[pulumi.Input[str]]:
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "timestamp_value")

    @timestamp_value.setter
    def timestamp_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
               
               - - -
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgsDict(TypedDict):
        date_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgsDict']]
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        day_of_week_value: NotRequired[pulumi.Input[str]]
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        An integer value (int64 format)
        """
        string_value: NotRequired[pulumi.Input[str]]
        """
        A string value.
        """
        time_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgsDict']]
        """
        Represents a time of day.
        Structure is documented below.
        """
        timestamp_value: NotRequired[pulumi.Input[str]]
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinArgs:
    def __init__(__self__, *,
                 date_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgs']] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None,
                 string_value: Optional[pulumi.Input[str]] = None,
                 time_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgs']] = None,
                 timestamp_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgs'] date_value: Represents a whole or partial calendar date.
               Structure is documented below.
        :param pulumi.Input[str] day_of_week_value: Represents a day of the week.
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[str] integer_value: An integer value (int64 format)
        :param pulumi.Input[str] string_value: A string value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgs'] time_value: Represents a time of day.
               Structure is documented below.
        :param pulumi.Input[str] timestamp_value: A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if time_value is not None:
            pulumi.set(__self__, "time_value", time_value)
        if timestamp_value is not None:
            pulumi.set(__self__, "timestamp_value", timestamp_value)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgs']]:
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgs']]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        A string value.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)

    @property
    @pulumi.getter(name="timeValue")
    def time_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgs']]:
        """
        Represents a time of day.
        Structure is documented below.
        """
        return pulumi.get(self, "time_value")

    @time_value.setter
    def time_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgs']]):
        pulumi.set(self, "time_value", value)

    @property
    @pulumi.getter(name="timestampValue")
    def timestamp_value(self) -> Optional[pulumi.Input[str]]:
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "timestamp_value")

    @timestamp_value.setter
    def timestamp_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
               
               - - -
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgsDict(TypedDict):
        date_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgsDict']]
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        day_of_week_value: NotRequired[pulumi.Input[str]]
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        An integer value (int64 format)
        """
        string_value: NotRequired[pulumi.Input[str]]
        """
        A string value.
        """
        time_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgsDict']]
        """
        Represents a time of day.
        Structure is documented below.
        """
        timestamp_value: NotRequired[pulumi.Input[str]]
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgs:
    def __init__(__self__, *,
                 date_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgs']] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None,
                 string_value: Optional[pulumi.Input[str]] = None,
                 time_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgs']] = None,
                 timestamp_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgs'] date_value: Represents a whole or partial calendar date.
               Structure is documented below.
        :param pulumi.Input[str] day_of_week_value: Represents a day of the week.
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[str] integer_value: An integer value (int64 format)
        :param pulumi.Input[str] string_value: A string value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgs'] time_value: Represents a time of day.
               Structure is documented below.
        :param pulumi.Input[str] timestamp_value: A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if time_value is not None:
            pulumi.set(__self__, "time_value", time_value)
        if timestamp_value is not None:
            pulumi.set(__self__, "timestamp_value", timestamp_value)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgs']]:
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgs']]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        A string value.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)

    @property
    @pulumi.getter(name="timeValue")
    def time_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgs']]:
        """
        Represents a time of day.
        Structure is documented below.
        """
        return pulumi.get(self, "time_value")

    @time_value.setter
    def time_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgs']]):
        pulumi.set(self, "time_value", value)

    @property
    @pulumi.getter(name="timestampValue")
    def timestamp_value(self) -> Optional[pulumi.Input[str]]:
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "timestamp_value")

    @timestamp_value.setter
    def timestamp_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
               
               - - -
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgsDict(TypedDict):
        characters_to_ignores: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgsDict']]]]
        """
        Characters to skip when doing de-identification of a value. These will be left alone and skipped.
        Structure is documented below.
        """
        masking_character: NotRequired[pulumi.Input[str]]
        """
        Character to use to mask the sensitive valuesfor example, * for an alphabetic string such as a name, or 0 for a numeric string
        such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to * for
        strings, and 0 for digits.
        """
        number_to_mask: NotRequired[pulumi.Input[int]]
        """
        Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.
        If number_to_mask is negative, this denotes inverse masking. Cloud DLP masks all but a number of characters. For example, suppose you have the following values:
        """
        reverse_order: NotRequired[pulumi.Input[bool]]
        """
        Mask characters in reverse order. For example, if masking_character is 0, number_to_mask is 14, and reverse_order is `false`, then the
        input string `1234-5678-9012-3456` is masked as `00000000000000-3456`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigArgs:
    def __init__(__self__, *,
                 characters_to_ignores: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgs']]]] = None,
                 masking_character: Optional[pulumi.Input[str]] = None,
                 number_to_mask: Optional[pulumi.Input[int]] = None,
                 reverse_order: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgs']]] characters_to_ignores: Characters to skip when doing de-identification of a value. These will be left alone and skipped.
               Structure is documented below.
        :param pulumi.Input[str] masking_character: Character to use to mask the sensitive valuesfor example, * for an alphabetic string such as a name, or 0 for a numeric string
               such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to * for
               strings, and 0 for digits.
        :param pulumi.Input[int] number_to_mask: Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.
               If number_to_mask is negative, this denotes inverse masking. Cloud DLP masks all but a number of characters. For example, suppose you have the following values:
        :param pulumi.Input[bool] reverse_order: Mask characters in reverse order. For example, if masking_character is 0, number_to_mask is 14, and reverse_order is `false`, then the
               input string `1234-5678-9012-3456` is masked as `00000000000000-3456`.
        """
        if characters_to_ignores is not None:
            pulumi.set(__self__, "characters_to_ignores", characters_to_ignores)
        if masking_character is not None:
            pulumi.set(__self__, "masking_character", masking_character)
        if number_to_mask is not None:
            pulumi.set(__self__, "number_to_mask", number_to_mask)
        if reverse_order is not None:
            pulumi.set(__self__, "reverse_order", reverse_order)

    @property
    @pulumi.getter(name="charactersToIgnores")
    def characters_to_ignores(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgs']]]]:
        """
        Characters to skip when doing de-identification of a value. These will be left alone and skipped.
        Structure is documented below.
        """
        return pulumi.get(self, "characters_to_ignores")

    @characters_to_ignores.setter
    def characters_to_ignores(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgs']]]]):
        pulumi.set(self, "characters_to_ignores", value)

    @property
    @pulumi.getter(name="maskingCharacter")
    def masking_character(self) -> Optional[pulumi.Input[str]]:
        """
        Character to use to mask the sensitive valuesfor example, * for an alphabetic string such as a name, or 0 for a numeric string
        such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to * for
        strings, and 0 for digits.
        """
        return pulumi.get(self, "masking_character")

    @masking_character.setter
    def masking_character(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "masking_character", value)

    @property
    @pulumi.getter(name="numberToMask")
    def number_to_mask(self) -> Optional[pulumi.Input[int]]:
        """
        Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.
        If number_to_mask is negative, this denotes inverse masking. Cloud DLP masks all but a number of characters. For example, suppose you have the following values:
        """
        return pulumi.get(self, "number_to_mask")

    @number_to_mask.setter
    def number_to_mask(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_to_mask", value)

    @property
    @pulumi.getter(name="reverseOrder")
    def reverse_order(self) -> Optional[pulumi.Input[bool]]:
        """
        Mask characters in reverse order. For example, if masking_character is 0, number_to_mask is 14, and reverse_order is `false`, then the
        input string `1234-5678-9012-3456` is masked as `00000000000000-3456`.
        """
        return pulumi.get(self, "reverse_order")

    @reverse_order.setter
    def reverse_order(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reverse_order", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgsDict(TypedDict):
        characters_to_skip: NotRequired[pulumi.Input[str]]
        """
        Characters to not transform when masking. Only one of this or `common_characters_to_ignore` must be specified.
        """
        common_characters_to_ignore: NotRequired[pulumi.Input[str]]
        """
        Common characters to not transform when masking. Useful to avoid removing punctuation. Only one of this or `characters_to_skip` must be specified.
        Possible values are: `NUMERIC`, `ALPHA_UPPER_CASE`, `ALPHA_LOWER_CASE`, `PUNCTUATION`, `WHITESPACE`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgs:
    def __init__(__self__, *,
                 characters_to_skip: Optional[pulumi.Input[str]] = None,
                 common_characters_to_ignore: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] characters_to_skip: Characters to not transform when masking. Only one of this or `common_characters_to_ignore` must be specified.
        :param pulumi.Input[str] common_characters_to_ignore: Common characters to not transform when masking. Useful to avoid removing punctuation. Only one of this or `characters_to_skip` must be specified.
               Possible values are: `NUMERIC`, `ALPHA_UPPER_CASE`, `ALPHA_LOWER_CASE`, `PUNCTUATION`, `WHITESPACE`.
        """
        if characters_to_skip is not None:
            pulumi.set(__self__, "characters_to_skip", characters_to_skip)
        if common_characters_to_ignore is not None:
            pulumi.set(__self__, "common_characters_to_ignore", common_characters_to_ignore)

    @property
    @pulumi.getter(name="charactersToSkip")
    def characters_to_skip(self) -> Optional[pulumi.Input[str]]:
        """
        Characters to not transform when masking. Only one of this or `common_characters_to_ignore` must be specified.
        """
        return pulumi.get(self, "characters_to_skip")

    @characters_to_skip.setter
    def characters_to_skip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "characters_to_skip", value)

    @property
    @pulumi.getter(name="commonCharactersToIgnore")
    def common_characters_to_ignore(self) -> Optional[pulumi.Input[str]]:
        """
        Common characters to not transform when masking. Useful to avoid removing punctuation. Only one of this or `characters_to_skip` must be specified.
        Possible values are: `NUMERIC`, `ALPHA_UPPER_CASE`, `ALPHA_LOWER_CASE`, `PUNCTUATION`, `WHITESPACE`.
        """
        return pulumi.get(self, "common_characters_to_ignore")

    @common_characters_to_ignore.setter
    def common_characters_to_ignore(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_characters_to_ignore", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgsDict(TypedDict):
        crypto_key: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgsDict']
        """
        The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.
        Structure is documented below.
        """
        surrogate_info_type: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgsDict']
        """
        The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate}
        For example, if the name of custom info type is 'MY\\_TOKEN\\_INFO\\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\\_TOKEN\\_INFO\\_TYPE(3):abc'
        This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text.
        Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text.
        In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either
        *   reverse a surrogate that does not correspond to an actual identifier
        *   be unable to parse the surrogate and result in an error
        Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\\_TOKEN\\_TYPE.
        Structure is documented below.
        """
        context: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgsDict']]
        """
        A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well.
        If the context is not set, plaintext would be used as is for encryption. If the context is set but:
        1. there is no record present when transforming a given value or
        2. the field is not present when transforming a given value,
        plaintext would be used as is for encryption.
        Note that case (1) is expected when an InfoTypeTransformation is applied to both structured and unstructured ContentItems.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigArgs:
    def __init__(__self__, *,
                 crypto_key: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgs'],
                 surrogate_info_type: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgs'],
                 context: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgs'] crypto_key: The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgs'] surrogate_info_type: The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate}
               For example, if the name of custom info type is 'MY\\_TOKEN\\_INFO\\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\\_TOKEN\\_INFO\\_TYPE(3):abc'
               This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text.
               Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text.
               In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either
               *   reverse a surrogate that does not correspond to an actual identifier
               *   be unable to parse the surrogate and result in an error
               Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\\_TOKEN\\_TYPE.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgs'] context: A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well.
               If the context is not set, plaintext would be used as is for encryption. If the context is set but:
               1. there is no record present when transforming a given value or
               2. the field is not present when transforming a given value,
               plaintext would be used as is for encryption.
               Note that case (1) is expected when an InfoTypeTransformation is applied to both structured and unstructured ContentItems.
               Structure is documented below.
        """
        pulumi.set(__self__, "crypto_key", crypto_key)
        pulumi.set(__self__, "surrogate_info_type", surrogate_info_type)
        if context is not None:
            pulumi.set(__self__, "context", context)

    @property
    @pulumi.getter(name="cryptoKey")
    def crypto_key(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgs']:
        """
        The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_key")

    @crypto_key.setter
    def crypto_key(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgs']):
        pulumi.set(self, "crypto_key", value)

    @property
    @pulumi.getter(name="surrogateInfoType")
    def surrogate_info_type(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgs']:
        """
        The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate}
        For example, if the name of custom info type is 'MY\\_TOKEN\\_INFO\\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\\_TOKEN\\_INFO\\_TYPE(3):abc'
        This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text.
        Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text.
        In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either
        *   reverse a surrogate that does not correspond to an actual identifier
        *   be unable to parse the surrogate and result in an error
        Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\\_TOKEN\\_TYPE.
        Structure is documented below.
        """
        return pulumi.get(self, "surrogate_info_type")

    @surrogate_info_type.setter
    def surrogate_info_type(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgs']):
        pulumi.set(self, "surrogate_info_type", value)

    @property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgs']]:
        """
        A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well.
        If the context is not set, plaintext would be used as is for encryption. If the context is set but:
        1. there is no record present when transforming a given value or
        2. the field is not present when transforming a given value,
        plaintext would be used as is for encryption.
        Note that case (1) is expected when an InfoTypeTransformation is applied to both structured and unstructured ContentItems.
        Structure is documented below.
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgs']]):
        pulumi.set(self, "context", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name describing the field.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name describing the field.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name describing the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgsDict(TypedDict):
        kms_wrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgsDict']]
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        transient: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgsDict']]
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        unwrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgsDict']]
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgs:
    def __init__(__self__, *,
                 kms_wrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgs']] = None,
                 transient: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgs']] = None,
                 unwrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgs'] kms_wrapped: KMS wrapped key.
               Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
               For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
               Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgs'] transient: Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgs'] unwrapped: Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
               Structure is documented below.
        """
        if kms_wrapped is not None:
            pulumi.set(__self__, "kms_wrapped", kms_wrapped)
        if transient is not None:
            pulumi.set(__self__, "transient", transient)
        if unwrapped is not None:
            pulumi.set(__self__, "unwrapped", unwrapped)

    @property
    @pulumi.getter(name="kmsWrapped")
    def kms_wrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgs']]:
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        return pulumi.get(self, "kms_wrapped")

    @kms_wrapped.setter
    def kms_wrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgs']]):
        pulumi.set(self, "kms_wrapped", value)

    @property
    @pulumi.getter
    def transient(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgs']]:
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "transient")

    @transient.setter
    def transient(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgs']]):
        pulumi.set(self, "transient", value)

    @property
    @pulumi.getter
    def unwrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgs']]:
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "unwrapped")

    @unwrapped.setter
    def unwrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgs']]):
        pulumi.set(self, "unwrapped", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgsDict(TypedDict):
        crypto_key_name: pulumi.Input[str]
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        wrapped_key: pulumi.Input[str]
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgs:
    def __init__(__self__, *,
                 crypto_key_name: pulumi.Input[str],
                 wrapped_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] crypto_key_name: The resource name of the KMS CryptoKey to use for unwrapping.
        :param pulumi.Input[str] wrapped_key: The wrapped data crypto key.
               A base64-encoded string.
        """
        pulumi.set(__self__, "crypto_key_name", crypto_key_name)
        pulumi.set(__self__, "wrapped_key", wrapped_key)

    @property
    @pulumi.getter(name="cryptoKeyName")
    def crypto_key_name(self) -> pulumi.Input[str]:
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        return pulumi.get(self, "crypto_key_name")

    @crypto_key_name.setter
    def crypto_key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "crypto_key_name", value)

    @property
    @pulumi.getter(name="wrappedKey")
    def wrapped_key(self) -> pulumi.Input[str]:
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
        return pulumi.get(self, "wrapped_key")

    @wrapped_key.setter
    def wrapped_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "wrapped_key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: A 128/192/256 bit key.
               A base64-encoded string.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Optional version name for this InfoType.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 sensitivity_score: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input[str] version: Optional version name for this InfoType.
        """
        pulumi.set(__self__, "name", name)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Optional version name for this InfoType.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgsDict(TypedDict):
        crypto_key: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgsDict']
        """
        The key used by the encryption function.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigArgs:
    def __init__(__self__, *,
                 crypto_key: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgs']):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgs'] crypto_key: The key used by the encryption function.
               Structure is documented below.
        """
        pulumi.set(__self__, "crypto_key", crypto_key)

    @property
    @pulumi.getter(name="cryptoKey")
    def crypto_key(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgs']:
        """
        The key used by the encryption function.
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_key")

    @crypto_key.setter
    def crypto_key(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgs']):
        pulumi.set(self, "crypto_key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgsDict(TypedDict):
        kms_wrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgsDict']]
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        transient: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgsDict']]
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        unwrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgsDict']]
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgs:
    def __init__(__self__, *,
                 kms_wrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgs']] = None,
                 transient: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgs']] = None,
                 unwrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgs'] kms_wrapped: KMS wrapped key.
               Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
               For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
               Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgs'] transient: Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgs'] unwrapped: Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
               Structure is documented below.
        """
        if kms_wrapped is not None:
            pulumi.set(__self__, "kms_wrapped", kms_wrapped)
        if transient is not None:
            pulumi.set(__self__, "transient", transient)
        if unwrapped is not None:
            pulumi.set(__self__, "unwrapped", unwrapped)

    @property
    @pulumi.getter(name="kmsWrapped")
    def kms_wrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgs']]:
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        return pulumi.get(self, "kms_wrapped")

    @kms_wrapped.setter
    def kms_wrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgs']]):
        pulumi.set(self, "kms_wrapped", value)

    @property
    @pulumi.getter
    def transient(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgs']]:
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "transient")

    @transient.setter
    def transient(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgs']]):
        pulumi.set(self, "transient", value)

    @property
    @pulumi.getter
    def unwrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgs']]:
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "unwrapped")

    @unwrapped.setter
    def unwrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgs']]):
        pulumi.set(self, "unwrapped", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgsDict(TypedDict):
        crypto_key_name: pulumi.Input[str]
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        wrapped_key: pulumi.Input[str]
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgs:
    def __init__(__self__, *,
                 crypto_key_name: pulumi.Input[str],
                 wrapped_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] crypto_key_name: The resource name of the KMS CryptoKey to use for unwrapping.
        :param pulumi.Input[str] wrapped_key: The wrapped data crypto key.
               A base64-encoded string.
        """
        pulumi.set(__self__, "crypto_key_name", crypto_key_name)
        pulumi.set(__self__, "wrapped_key", wrapped_key)

    @property
    @pulumi.getter(name="cryptoKeyName")
    def crypto_key_name(self) -> pulumi.Input[str]:
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        return pulumi.get(self, "crypto_key_name")

    @crypto_key_name.setter
    def crypto_key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "crypto_key_name", value)

    @property
    @pulumi.getter(name="wrappedKey")
    def wrapped_key(self) -> pulumi.Input[str]:
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
        return pulumi.get(self, "wrapped_key")

    @wrapped_key.setter
    def wrapped_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "wrapped_key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: A 128/192/256 bit key.
               A base64-encoded string.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgsDict(TypedDict):
        crypto_key: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgsDict']
        """
        The key used by the encryption algorithm.
        Structure is documented below.
        """
        common_alphabet: NotRequired[pulumi.Input[str]]
        """
        Common alphabets. Only one of this, `custom_alphabet` or `radix` must be specified.
        Possible values are: `NUMERIC`, `HEXADECIMAL`, `UPPER_CASE_ALPHA_NUMERIC`, `ALPHA_NUMERIC`.
        """
        context: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgsDict']]
        """
        The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used.
        If the context is set but:
        1.  there is no record present when transforming a given value or
        2.  the field is not present when transforming a given value,
        a default tweak will be used.
        Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string.
        The tweak is constructed as a sequence of bytes in big endian byte order such that:
        *   a 64 bit integer is encoded followed by a single byte of value 1
        *   a string is encoded in UTF-8 format followed by a single byte of value 2
        Structure is documented below.
        """
        custom_alphabet: NotRequired[pulumi.Input[str]]
        """
        This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range \\[2, 95\\]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
        ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/``. Only one of this, `common_alphabet` or `radix` must be specified.
        """
        radix: NotRequired[pulumi.Input[int]]
        """
        The native way to select the alphabet. Must be in the range \\[2, 95\\]. Only one of this, `custom_alphabet` or `common_alphabet` must be specified.
        """
        surrogate_info_type: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgsDict']]
        """
        The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info\\_type\\_name(surrogate\\_character\\_count):surrogate
        For example, if the name of custom infoType is 'MY\\_TOKEN\\_INFO\\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\\_TOKEN\\_INFO\\_TYPE(3):abc'
        This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text.
        In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\\_TOKEN\\_TYPE
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs:
    def __init__(__self__, *,
                 crypto_key: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgs'],
                 common_alphabet: Optional[pulumi.Input[str]] = None,
                 context: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgs']] = None,
                 custom_alphabet: Optional[pulumi.Input[str]] = None,
                 radix: Optional[pulumi.Input[int]] = None,
                 surrogate_info_type: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgs'] crypto_key: The key used by the encryption algorithm.
               Structure is documented below.
        :param pulumi.Input[str] common_alphabet: Common alphabets. Only one of this, `custom_alphabet` or `radix` must be specified.
               Possible values are: `NUMERIC`, `HEXADECIMAL`, `UPPER_CASE_ALPHA_NUMERIC`, `ALPHA_NUMERIC`.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgs'] context: The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used.
               If the context is set but:
               1.  there is no record present when transforming a given value or
               2.  the field is not present when transforming a given value,
               a default tweak will be used.
               Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string.
               The tweak is constructed as a sequence of bytes in big endian byte order such that:
               *   a 64 bit integer is encoded followed by a single byte of value 1
               *   a string is encoded in UTF-8 format followed by a single byte of value 2
               Structure is documented below.
        :param pulumi.Input[str] custom_alphabet: This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range \\[2, 95\\]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
               ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/``. Only one of this, `common_alphabet` or `radix` must be specified.
        :param pulumi.Input[int] radix: The native way to select the alphabet. Must be in the range \\[2, 95\\]. Only one of this, `custom_alphabet` or `common_alphabet` must be specified.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgs'] surrogate_info_type: The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info\\_type\\_name(surrogate\\_character\\_count):surrogate
               For example, if the name of custom infoType is 'MY\\_TOKEN\\_INFO\\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\\_TOKEN\\_INFO\\_TYPE(3):abc'
               This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text.
               In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\\_TOKEN\\_TYPE
               Structure is documented below.
        """
        pulumi.set(__self__, "crypto_key", crypto_key)
        if common_alphabet is not None:
            pulumi.set(__self__, "common_alphabet", common_alphabet)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if custom_alphabet is not None:
            pulumi.set(__self__, "custom_alphabet", custom_alphabet)
        if radix is not None:
            pulumi.set(__self__, "radix", radix)
        if surrogate_info_type is not None:
            pulumi.set(__self__, "surrogate_info_type", surrogate_info_type)

    @property
    @pulumi.getter(name="cryptoKey")
    def crypto_key(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgs']:
        """
        The key used by the encryption algorithm.
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_key")

    @crypto_key.setter
    def crypto_key(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgs']):
        pulumi.set(self, "crypto_key", value)

    @property
    @pulumi.getter(name="commonAlphabet")
    def common_alphabet(self) -> Optional[pulumi.Input[str]]:
        """
        Common alphabets. Only one of this, `custom_alphabet` or `radix` must be specified.
        Possible values are: `NUMERIC`, `HEXADECIMAL`, `UPPER_CASE_ALPHA_NUMERIC`, `ALPHA_NUMERIC`.
        """
        return pulumi.get(self, "common_alphabet")

    @common_alphabet.setter
    def common_alphabet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_alphabet", value)

    @property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgs']]:
        """
        The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used.
        If the context is set but:
        1.  there is no record present when transforming a given value or
        2.  the field is not present when transforming a given value,
        a default tweak will be used.
        Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string.
        The tweak is constructed as a sequence of bytes in big endian byte order such that:
        *   a 64 bit integer is encoded followed by a single byte of value 1
        *   a string is encoded in UTF-8 format followed by a single byte of value 2
        Structure is documented below.
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgs']]):
        pulumi.set(self, "context", value)

    @property
    @pulumi.getter(name="customAlphabet")
    def custom_alphabet(self) -> Optional[pulumi.Input[str]]:
        """
        This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range \\[2, 95\\]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
        ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/``. Only one of this, `common_alphabet` or `radix` must be specified.
        """
        return pulumi.get(self, "custom_alphabet")

    @custom_alphabet.setter
    def custom_alphabet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_alphabet", value)

    @property
    @pulumi.getter
    def radix(self) -> Optional[pulumi.Input[int]]:
        """
        The native way to select the alphabet. Must be in the range \\[2, 95\\]. Only one of this, `custom_alphabet` or `common_alphabet` must be specified.
        """
        return pulumi.get(self, "radix")

    @radix.setter
    def radix(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "radix", value)

    @property
    @pulumi.getter(name="surrogateInfoType")
    def surrogate_info_type(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgs']]:
        """
        The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info\\_type\\_name(surrogate\\_character\\_count):surrogate
        For example, if the name of custom infoType is 'MY\\_TOKEN\\_INFO\\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\\_TOKEN\\_INFO\\_TYPE(3):abc'
        This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text.
        In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\\_TOKEN\\_TYPE
        Structure is documented below.
        """
        return pulumi.get(self, "surrogate_info_type")

    @surrogate_info_type.setter
    def surrogate_info_type(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgs']]):
        pulumi.set(self, "surrogate_info_type", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name describing the field.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name describing the field.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name describing the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgsDict(TypedDict):
        kms_wrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgsDict']]
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        transient: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgsDict']]
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        unwrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgsDict']]
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgs:
    def __init__(__self__, *,
                 kms_wrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgs']] = None,
                 transient: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgs']] = None,
                 unwrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgs'] kms_wrapped: KMS wrapped key.
               Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
               For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
               Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgs'] transient: Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgs'] unwrapped: Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
               Structure is documented below.
        """
        if kms_wrapped is not None:
            pulumi.set(__self__, "kms_wrapped", kms_wrapped)
        if transient is not None:
            pulumi.set(__self__, "transient", transient)
        if unwrapped is not None:
            pulumi.set(__self__, "unwrapped", unwrapped)

    @property
    @pulumi.getter(name="kmsWrapped")
    def kms_wrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgs']]:
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        return pulumi.get(self, "kms_wrapped")

    @kms_wrapped.setter
    def kms_wrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgs']]):
        pulumi.set(self, "kms_wrapped", value)

    @property
    @pulumi.getter
    def transient(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgs']]:
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "transient")

    @transient.setter
    def transient(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgs']]):
        pulumi.set(self, "transient", value)

    @property
    @pulumi.getter
    def unwrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgs']]:
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "unwrapped")

    @unwrapped.setter
    def unwrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgs']]):
        pulumi.set(self, "unwrapped", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgsDict(TypedDict):
        crypto_key_name: pulumi.Input[str]
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        wrapped_key: pulumi.Input[str]
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgs:
    def __init__(__self__, *,
                 crypto_key_name: pulumi.Input[str],
                 wrapped_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] crypto_key_name: The resource name of the KMS CryptoKey to use for unwrapping.
        :param pulumi.Input[str] wrapped_key: The wrapped data crypto key.
               A base64-encoded string.
        """
        pulumi.set(__self__, "crypto_key_name", crypto_key_name)
        pulumi.set(__self__, "wrapped_key", wrapped_key)

    @property
    @pulumi.getter(name="cryptoKeyName")
    def crypto_key_name(self) -> pulumi.Input[str]:
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        return pulumi.get(self, "crypto_key_name")

    @crypto_key_name.setter
    def crypto_key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "crypto_key_name", value)

    @property
    @pulumi.getter(name="wrappedKey")
    def wrapped_key(self) -> pulumi.Input[str]:
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
        return pulumi.get(self, "wrapped_key")

    @wrapped_key.setter
    def wrapped_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "wrapped_key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: A 128/192/256 bit key.
               A base64-encoded string.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Optional version name for this InfoType.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 sensitivity_score: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input[str] version: Optional version name for this InfoType.
        """
        pulumi.set(__self__, "name", name)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Optional version name for this InfoType.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgsDict(TypedDict):
        lower_bound_days: pulumi.Input[int]
        """
        For example, -5 means shift date to at most 5 days back in the past.
        """
        upper_bound_days: pulumi.Input[int]
        """
        Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
        For example, 3 means shift date to at most 3 days into the future.
        """
        context: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgsDict']]
        """
        Points to the field that contains the context, for example, an entity id.
        If set, must also set cryptoKey. If set, shift will be consistent for the given context.
        Structure is documented below.
        """
        crypto_key: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgsDict']]
        """
        Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and cryptoKey. If set, must also set context. Can only be applied to table items.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigArgs:
    def __init__(__self__, *,
                 lower_bound_days: pulumi.Input[int],
                 upper_bound_days: pulumi.Input[int],
                 context: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgs']] = None,
                 crypto_key: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgs']] = None):
        """
        :param pulumi.Input[int] lower_bound_days: For example, -5 means shift date to at most 5 days back in the past.
        :param pulumi.Input[int] upper_bound_days: Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
               For example, 3 means shift date to at most 3 days into the future.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgs'] context: Points to the field that contains the context, for example, an entity id.
               If set, must also set cryptoKey. If set, shift will be consistent for the given context.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgs'] crypto_key: Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and cryptoKey. If set, must also set context. Can only be applied to table items.
               Structure is documented below.
        """
        pulumi.set(__self__, "lower_bound_days", lower_bound_days)
        pulumi.set(__self__, "upper_bound_days", upper_bound_days)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if crypto_key is not None:
            pulumi.set(__self__, "crypto_key", crypto_key)

    @property
    @pulumi.getter(name="lowerBoundDays")
    def lower_bound_days(self) -> pulumi.Input[int]:
        """
        For example, -5 means shift date to at most 5 days back in the past.
        """
        return pulumi.get(self, "lower_bound_days")

    @lower_bound_days.setter
    def lower_bound_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "lower_bound_days", value)

    @property
    @pulumi.getter(name="upperBoundDays")
    def upper_bound_days(self) -> pulumi.Input[int]:
        """
        Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
        For example, 3 means shift date to at most 3 days into the future.
        """
        return pulumi.get(self, "upper_bound_days")

    @upper_bound_days.setter
    def upper_bound_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "upper_bound_days", value)

    @property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgs']]:
        """
        Points to the field that contains the context, for example, an entity id.
        If set, must also set cryptoKey. If set, shift will be consistent for the given context.
        Structure is documented below.
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgs']]):
        pulumi.set(self, "context", value)

    @property
    @pulumi.getter(name="cryptoKey")
    def crypto_key(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgs']]:
        """
        Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and cryptoKey. If set, must also set context. Can only be applied to table items.
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_key")

    @crypto_key.setter
    def crypto_key(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgs']]):
        pulumi.set(self, "crypto_key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name describing the field.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigContextArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name describing the field.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name describing the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgsDict(TypedDict):
        kms_wrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgsDict']]
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        transient: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgsDict']]
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        unwrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgsDict']]
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgs:
    def __init__(__self__, *,
                 kms_wrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgs']] = None,
                 transient: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgs']] = None,
                 unwrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgs'] kms_wrapped: KMS wrapped key.
               Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
               For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
               Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgs'] transient: Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgs'] unwrapped: Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
               Structure is documented below.
        """
        if kms_wrapped is not None:
            pulumi.set(__self__, "kms_wrapped", kms_wrapped)
        if transient is not None:
            pulumi.set(__self__, "transient", transient)
        if unwrapped is not None:
            pulumi.set(__self__, "unwrapped", unwrapped)

    @property
    @pulumi.getter(name="kmsWrapped")
    def kms_wrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgs']]:
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        return pulumi.get(self, "kms_wrapped")

    @kms_wrapped.setter
    def kms_wrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgs']]):
        pulumi.set(self, "kms_wrapped", value)

    @property
    @pulumi.getter
    def transient(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgs']]:
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "transient")

    @transient.setter
    def transient(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgs']]):
        pulumi.set(self, "transient", value)

    @property
    @pulumi.getter
    def unwrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgs']]:
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "unwrapped")

    @unwrapped.setter
    def unwrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgs']]):
        pulumi.set(self, "unwrapped", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgsDict(TypedDict):
        crypto_key_name: pulumi.Input[str]
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        wrapped_key: pulumi.Input[str]
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgs:
    def __init__(__self__, *,
                 crypto_key_name: pulumi.Input[str],
                 wrapped_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] crypto_key_name: The resource name of the KMS CryptoKey to use for unwrapping.
        :param pulumi.Input[str] wrapped_key: The wrapped data crypto key.
               A base64-encoded string.
        """
        pulumi.set(__self__, "crypto_key_name", crypto_key_name)
        pulumi.set(__self__, "wrapped_key", wrapped_key)

    @property
    @pulumi.getter(name="cryptoKeyName")
    def crypto_key_name(self) -> pulumi.Input[str]:
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        return pulumi.get(self, "crypto_key_name")

    @crypto_key_name.setter
    def crypto_key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "crypto_key_name", value)

    @property
    @pulumi.getter(name="wrappedKey")
    def wrapped_key(self) -> pulumi.Input[str]:
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
        return pulumi.get(self, "wrapped_key")

    @wrapped_key.setter
    def wrapped_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "wrapped_key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: A 128/192/256 bit key.
               A base64-encoded string.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgsDict(TypedDict):
        bucket_size: pulumi.Input[float]
        """
        Size of each bucket (except for minimum and maximum buckets).
        So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
        Precision up to 2 decimals works.
        """
        lower_bound: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgsDict']
        """
        Lower bound value of buckets.
        All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
        The `lower_bound` block must only contain one argument. See the `fixed_size_bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
        upper_bound: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgsDict']
        """
        Upper bound value of buckets.
        All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
        The `upper_bound` block must only contain one argument. See the `fixed_size_bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs:
    def __init__(__self__, *,
                 bucket_size: pulumi.Input[float],
                 lower_bound: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgs'],
                 upper_bound: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgs']):
        """
        :param pulumi.Input[float] bucket_size: Size of each bucket (except for minimum and maximum buckets).
               So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
               Precision up to 2 decimals works.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgs'] lower_bound: Lower bound value of buckets.
               All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
               The `lower_bound` block must only contain one argument. See the `fixed_size_bucketing_config` block description for more information about choosing a data type.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgs'] upper_bound: Upper bound value of buckets.
               All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
               The `upper_bound` block must only contain one argument. See the `fixed_size_bucketing_config` block description for more information about choosing a data type.
               Structure is documented below.
        """
        pulumi.set(__self__, "bucket_size", bucket_size)
        pulumi.set(__self__, "lower_bound", lower_bound)
        pulumi.set(__self__, "upper_bound", upper_bound)

    @property
    @pulumi.getter(name="bucketSize")
    def bucket_size(self) -> pulumi.Input[float]:
        """
        Size of each bucket (except for minimum and maximum buckets).
        So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
        Precision up to 2 decimals works.
        """
        return pulumi.get(self, "bucket_size")

    @bucket_size.setter
    def bucket_size(self, value: pulumi.Input[float]):
        pulumi.set(self, "bucket_size", value)

    @property
    @pulumi.getter(name="lowerBound")
    def lower_bound(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgs']:
        """
        Lower bound value of buckets.
        All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
        The `lower_bound` block must only contain one argument. See the `fixed_size_bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
        return pulumi.get(self, "lower_bound")

    @lower_bound.setter
    def lower_bound(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgs']):
        pulumi.set(self, "lower_bound", value)

    @property
    @pulumi.getter(name="upperBound")
    def upper_bound(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgs']:
        """
        Upper bound value of buckets.
        All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
        The `upper_bound` block must only contain one argument. See the `fixed_size_bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
        return pulumi.get(self, "upper_bound")

    @upper_bound.setter
    def upper_bound(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgs']):
        pulumi.set(self, "upper_bound", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgsDict(TypedDict):
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        An integer value (int64 format)
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgs:
    def __init__(__self__, *,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[str] integer_value: An integer value (int64 format)
        """
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgsDict(TypedDict):
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        An integer value (int64 format)
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgs:
    def __init__(__self__, *,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[str] integer_value: An integer value (int64 format)
        """
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgsDict(TypedDict):
        pass
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationRedactConfigArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgsDict(TypedDict):
        new_value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgsDict']
        """
        Replace each input value with a given value.
        The `new_value` block must only contain one argument. For example when replacing the contents of a string-type field, only `string_value` should be set.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigArgs:
    def __init__(__self__, *,
                 new_value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgs']):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgs'] new_value: Replace each input value with a given value.
               The `new_value` block must only contain one argument. For example when replacing the contents of a string-type field, only `string_value` should be set.
               Structure is documented below.
        """
        pulumi.set(__self__, "new_value", new_value)

    @property
    @pulumi.getter(name="newValue")
    def new_value(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgs']:
        """
        Replace each input value with a given value.
        The `new_value` block must only contain one argument. For example when replacing the contents of a string-type field, only `string_value` should be set.
        Structure is documented below.
        """
        return pulumi.get(self, "new_value")

    @new_value.setter
    def new_value(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgs']):
        pulumi.set(self, "new_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgsDict(TypedDict):
        boolean_value: NotRequired[pulumi.Input[bool]]
        """
        A boolean value.
        """
        date_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgsDict']]
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        day_of_week_value: NotRequired[pulumi.Input[str]]
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        An integer value (int64 format)
        """
        string_value: NotRequired[pulumi.Input[str]]
        """
        A string value.
        """
        time_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgsDict']]
        """
        Represents a time of day.
        Structure is documented below.
        """
        timestamp_value: NotRequired[pulumi.Input[str]]
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
        Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueArgs:
    def __init__(__self__, *,
                 boolean_value: Optional[pulumi.Input[bool]] = None,
                 date_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgs']] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None,
                 string_value: Optional[pulumi.Input[str]] = None,
                 time_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgs']] = None,
                 timestamp_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] boolean_value: A boolean value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgs'] date_value: Represents a whole or partial calendar date.
               Structure is documented below.
        :param pulumi.Input[str] day_of_week_value: Represents a day of the week.
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[str] integer_value: An integer value (int64 format)
        :param pulumi.Input[str] string_value: A string value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgs'] time_value: Represents a time of day.
               Structure is documented below.
        :param pulumi.Input[str] timestamp_value: A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
               Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        if boolean_value is not None:
            pulumi.set(__self__, "boolean_value", boolean_value)
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if time_value is not None:
            pulumi.set(__self__, "time_value", time_value)
        if timestamp_value is not None:
            pulumi.set(__self__, "timestamp_value", timestamp_value)

    @property
    @pulumi.getter(name="booleanValue")
    def boolean_value(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value.
        """
        return pulumi.get(self, "boolean_value")

    @boolean_value.setter
    def boolean_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean_value", value)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgs']]:
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgs']]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        A string value.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)

    @property
    @pulumi.getter(name="timeValue")
    def time_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgs']]:
        """
        Represents a time of day.
        Structure is documented below.
        """
        return pulumi.get(self, "time_value")

    @time_value.setter
    def time_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgs']]):
        pulumi.set(self, "time_value", value)

    @property
    @pulumi.getter(name="timestampValue")
    def timestamp_value(self) -> Optional[pulumi.Input[str]]:
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
        Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "timestamp_value")

    @timestamp_value.setter
    def timestamp_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
               
               - - -
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgsDict(TypedDict):
        word_list: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgsDict']
        """
        A list of words to select from for random replacement. The [limits](https://cloud.google.com/dlp/limits) page contains details about the size limits of dictionaries.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigArgs:
    def __init__(__self__, *,
                 word_list: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgs']):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgs'] word_list: A list of words to select from for random replacement. The [limits](https://cloud.google.com/dlp/limits) page contains details about the size limits of dictionaries.
               Structure is documented below.
        """
        pulumi.set(__self__, "word_list", word_list)

    @property
    @pulumi.getter(name="wordList")
    def word_list(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgs']:
        """
        A list of words to select from for random replacement. The [limits](https://cloud.google.com/dlp/limits) page contains details about the size limits of dictionaries.
        Structure is documented below.
        """
        return pulumi.get(self, "word_list")

    @word_list.setter
    def word_list(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgs']):
        pulumi.set(self, "word_list", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgsDict(TypedDict):
        words: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgs:
    def __init__(__self__, *,
                 words: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] words: Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
        pulumi.set(__self__, "words", words)

    @property
    @pulumi.getter
    def words(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
        return pulumi.get(self, "words")

    @words.setter
    def words(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "words", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceWithInfoTypeConfigArgsDict(TypedDict):
        pass
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceWithInfoTypeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationReplaceWithInfoTypeConfigArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgsDict(TypedDict):
        part_to_extract: pulumi.Input[str]
        """
        The part of the time to keep.
        Possible values are: `YEAR`, `MONTH`, `DAY_OF_MONTH`, `DAY_OF_WEEK`, `WEEK_OF_YEAR`, `HOUR_OF_DAY`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationInfoTypeTransformationsTransformationPrimitiveTransformationTimePartConfigArgs:
    def __init__(__self__, *,
                 part_to_extract: pulumi.Input[str]):
        """
        :param pulumi.Input[str] part_to_extract: The part of the time to keep.
               Possible values are: `YEAR`, `MONTH`, `DAY_OF_MONTH`, `DAY_OF_WEEK`, `WEEK_OF_YEAR`, `HOUR_OF_DAY`.
        """
        pulumi.set(__self__, "part_to_extract", part_to_extract)

    @property
    @pulumi.getter(name="partToExtract")
    def part_to_extract(self) -> pulumi.Input[str]:
        """
        The part of the time to keep.
        Possible values are: `YEAR`, `MONTH`, `DAY_OF_MONTH`, `DAY_OF_WEEK`, `WEEK_OF_YEAR`, `HOUR_OF_DAY`.
        """
        return pulumi.get(self, "part_to_extract")

    @part_to_extract.setter
    def part_to_extract(self, value: pulumi.Input[str]):
        pulumi.set(self, "part_to_extract", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgsDict(TypedDict):
        bucketing_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigArgsDict']]
        """
        Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 > LOW 31-65 > MEDIUM 66-100 > HIGH
        This can be used on data of type: number, long, string, timestamp.
        If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
        See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
        Structure is documented below.
        """
        character_mask_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigArgsDict']]
        """
        Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. This can be used on data of any type (numbers, longs, and so on) and when de-identifying structured data we'll attempt to preserve the original data's type. (This allows you to take a long like 123 and modify it to a string like **3).
        Structure is documented below.
        """
        crypto_deterministic_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigArgsDict']]
        """
        Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC [https://tools.ietf.org/html/rfc5297](https://tools.ietf.org/html/rfc5297).
        Structure is documented below.
        """
        crypto_hash_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigArgsDict']]
        """
        Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
        Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
        Currently, only string and integer values can be hashed.
        See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
        Structure is documented below.
        """
        crypto_replace_ffx_fpe_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgsDict']]
        """
        Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the `content.reidentify` API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See [https://cloud.google.com/dlp/docs/pseudonymization](https://cloud.google.com/dlp/docs/pseudonymization) to learn more.
        Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
        Structure is documented below.
        """
        date_shift_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigArgsDict']]
        """
        Shifts dates by random number of days, with option to be consistent for the same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting to learn more.
        Structure is documented below.
        """
        fixed_size_bucketing_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigArgsDict']]
        """
        Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
        The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
        This can be used on data of type: double, long.
        If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
        See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
        Structure is documented below.
        """
        redact_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationRedactConfigArgsDict']]
        """
        Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
        """
        replace_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigArgsDict']]
        """
        Replace each input value with a given value.
        Structure is documented below.
        """
        replace_dictionary_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigArgsDict']]
        """
        Replace with a value randomly drawn (with replacement) from a dictionary.
        Structure is documented below.
        """
        time_part_config: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationTimePartConfigArgsDict']]
        """
        For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationArgs:
    def __init__(__self__, *,
                 bucketing_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigArgs']] = None,
                 character_mask_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigArgs']] = None,
                 crypto_deterministic_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigArgs']] = None,
                 crypto_hash_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigArgs']] = None,
                 crypto_replace_ffx_fpe_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs']] = None,
                 date_shift_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigArgs']] = None,
                 fixed_size_bucketing_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs']] = None,
                 redact_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationRedactConfigArgs']] = None,
                 replace_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigArgs']] = None,
                 replace_dictionary_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigArgs']] = None,
                 time_part_config: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationTimePartConfigArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigArgs'] bucketing_config: Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 > LOW 31-65 > MEDIUM 66-100 > HIGH
               This can be used on data of type: number, long, string, timestamp.
               If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
               See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigArgs'] character_mask_config: Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. This can be used on data of any type (numbers, longs, and so on) and when de-identifying structured data we'll attempt to preserve the original data's type. (This allows you to take a long like 123 and modify it to a string like **3).
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigArgs'] crypto_deterministic_config: Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC [https://tools.ietf.org/html/rfc5297](https://tools.ietf.org/html/rfc5297).
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigArgs'] crypto_hash_config: Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
               Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
               Currently, only string and integer values can be hashed.
               See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs'] crypto_replace_ffx_fpe_config: Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the `content.reidentify` API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See [https://cloud.google.com/dlp/docs/pseudonymization](https://cloud.google.com/dlp/docs/pseudonymization) to learn more.
               Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigArgs'] date_shift_config: Shifts dates by random number of days, with option to be consistent for the same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting to learn more.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs'] fixed_size_bucketing_config: Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
               The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
               This can be used on data of type: double, long.
               If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
               See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationRedactConfigArgs'] redact_config: Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigArgs'] replace_config: Replace each input value with a given value.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigArgs'] replace_dictionary_config: Replace with a value randomly drawn (with replacement) from a dictionary.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationTimePartConfigArgs'] time_part_config: For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
               Structure is documented below.
        """
        if bucketing_config is not None:
            pulumi.set(__self__, "bucketing_config", bucketing_config)
        if character_mask_config is not None:
            pulumi.set(__self__, "character_mask_config", character_mask_config)
        if crypto_deterministic_config is not None:
            pulumi.set(__self__, "crypto_deterministic_config", crypto_deterministic_config)
        if crypto_hash_config is not None:
            pulumi.set(__self__, "crypto_hash_config", crypto_hash_config)
        if crypto_replace_ffx_fpe_config is not None:
            pulumi.set(__self__, "crypto_replace_ffx_fpe_config", crypto_replace_ffx_fpe_config)
        if date_shift_config is not None:
            pulumi.set(__self__, "date_shift_config", date_shift_config)
        if fixed_size_bucketing_config is not None:
            pulumi.set(__self__, "fixed_size_bucketing_config", fixed_size_bucketing_config)
        if redact_config is not None:
            pulumi.set(__self__, "redact_config", redact_config)
        if replace_config is not None:
            pulumi.set(__self__, "replace_config", replace_config)
        if replace_dictionary_config is not None:
            pulumi.set(__self__, "replace_dictionary_config", replace_dictionary_config)
        if time_part_config is not None:
            pulumi.set(__self__, "time_part_config", time_part_config)

    @property
    @pulumi.getter(name="bucketingConfig")
    def bucketing_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigArgs']]:
        """
        Generalization function that buckets values based on ranges. The ranges and replacement values are dynamically provided by the user for custom behavior, such as 1-30 > LOW 31-65 > MEDIUM 66-100 > HIGH
        This can be used on data of type: number, long, string, timestamp.
        If the provided value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
        See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
        Structure is documented below.
        """
        return pulumi.get(self, "bucketing_config")

    @bucketing_config.setter
    def bucketing_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigArgs']]):
        pulumi.set(self, "bucketing_config", value)

    @property
    @pulumi.getter(name="characterMaskConfig")
    def character_mask_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigArgs']]:
        """
        Partially mask a string by replacing a given number of characters with a fixed character. Masking can start from the beginning or end of the string. This can be used on data of any type (numbers, longs, and so on) and when de-identifying structured data we'll attempt to preserve the original data's type. (This allows you to take a long like 123 and modify it to a string like **3).
        Structure is documented below.
        """
        return pulumi.get(self, "character_mask_config")

    @character_mask_config.setter
    def character_mask_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigArgs']]):
        pulumi.set(self, "character_mask_config", value)

    @property
    @pulumi.getter(name="cryptoDeterministicConfig")
    def crypto_deterministic_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigArgs']]:
        """
        Pseudonymization method that generates deterministic encryption for the given input. Outputs a base64 encoded representation of the encrypted output. Uses AES-SIV based on the RFC [https://tools.ietf.org/html/rfc5297](https://tools.ietf.org/html/rfc5297).
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_deterministic_config")

    @crypto_deterministic_config.setter
    def crypto_deterministic_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigArgs']]):
        pulumi.set(self, "crypto_deterministic_config", value)

    @property
    @pulumi.getter(name="cryptoHashConfig")
    def crypto_hash_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigArgs']]:
        """
        Pseudonymization method that generates surrogates via cryptographic hashing. Uses SHA-256. The key size must be either 32 or 64 bytes.
        Outputs a base64 encoded representation of the hashed output (for example, L7k0BHmF1ha5U3NfGykjro4xWi1MPVQPjhMAZbSV9mM=).
        Currently, only string and integer values can be hashed.
        See https://cloud.google.com/dlp/docs/pseudonymization to learn more.
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_hash_config")

    @crypto_hash_config.setter
    def crypto_hash_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigArgs']]):
        pulumi.set(self, "crypto_hash_config", value)

    @property
    @pulumi.getter(name="cryptoReplaceFfxFpeConfig")
    def crypto_replace_ffx_fpe_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs']]:
        """
        Replaces an identifier with a surrogate using Format Preserving Encryption (FPE) with the FFX mode of operation; however when used in the `content.reidentify` API method, it serves the opposite function by reversing the surrogate back into the original identifier. The identifier must be encoded as ASCII. For a given crypto key and context, the same identifier will be replaced with the same surrogate. Identifiers must be at least two characters long. In the case that the identifier is the empty string, it will be skipped. See [https://cloud.google.com/dlp/docs/pseudonymization](https://cloud.google.com/dlp/docs/pseudonymization) to learn more.
        Note: We recommend using CryptoDeterministicConfig for all use cases which do not require preserving the input alphabet space and size, plus warrant referential integrity.
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_replace_ffx_fpe_config")

    @crypto_replace_ffx_fpe_config.setter
    def crypto_replace_ffx_fpe_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs']]):
        pulumi.set(self, "crypto_replace_ffx_fpe_config", value)

    @property
    @pulumi.getter(name="dateShiftConfig")
    def date_shift_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigArgs']]:
        """
        Shifts dates by random number of days, with option to be consistent for the same context. See https://cloud.google.com/dlp/docs/concepts-date-shifting to learn more.
        Structure is documented below.
        """
        return pulumi.get(self, "date_shift_config")

    @date_shift_config.setter
    def date_shift_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigArgs']]):
        pulumi.set(self, "date_shift_config", value)

    @property
    @pulumi.getter(name="fixedSizeBucketingConfig")
    def fixed_size_bucketing_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs']]:
        """
        Buckets values based on fixed size ranges. The Bucketing transformation can provide all of this functionality, but requires more configuration. This message is provided as a convenience to the user for simple bucketing strategies.
        The transformed value will be a hyphenated string of {lower_bound}-{upper_bound}. For example, if lower_bound = 10 and upper_bound = 20, all values that are within this bucket will be replaced with "10-20".
        This can be used on data of type: double, long.
        If the bound Value type differs from the type of data being transformed, we will first attempt converting the type of the data to be transformed to match the type of the bound before comparing.
        See https://cloud.google.com/dlp/docs/concepts-bucketing to learn more.
        Structure is documented below.
        """
        return pulumi.get(self, "fixed_size_bucketing_config")

    @fixed_size_bucketing_config.setter
    def fixed_size_bucketing_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs']]):
        pulumi.set(self, "fixed_size_bucketing_config", value)

    @property
    @pulumi.getter(name="redactConfig")
    def redact_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationRedactConfigArgs']]:
        """
        Redact a given value. For example, if used with an InfoTypeTransformation transforming PHONE_NUMBER, and input 'My phone number is 206-555-0123', the output would be 'My phone number is '.
        """
        return pulumi.get(self, "redact_config")

    @redact_config.setter
    def redact_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationRedactConfigArgs']]):
        pulumi.set(self, "redact_config", value)

    @property
    @pulumi.getter(name="replaceConfig")
    def replace_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigArgs']]:
        """
        Replace each input value with a given value.
        Structure is documented below.
        """
        return pulumi.get(self, "replace_config")

    @replace_config.setter
    def replace_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigArgs']]):
        pulumi.set(self, "replace_config", value)

    @property
    @pulumi.getter(name="replaceDictionaryConfig")
    def replace_dictionary_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigArgs']]:
        """
        Replace with a value randomly drawn (with replacement) from a dictionary.
        Structure is documented below.
        """
        return pulumi.get(self, "replace_dictionary_config")

    @replace_dictionary_config.setter
    def replace_dictionary_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigArgs']]):
        pulumi.set(self, "replace_dictionary_config", value)

    @property
    @pulumi.getter(name="timePartConfig")
    def time_part_config(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationTimePartConfigArgs']]:
        """
        For use with Date, Timestamp, and TimeOfDay, extract or preserve a portion of the value.
        Structure is documented below.
        """
        return pulumi.get(self, "time_part_config")

    @time_part_config.setter
    def time_part_config(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationTimePartConfigArgs']]):
        pulumi.set(self, "time_part_config", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigArgsDict(TypedDict):
        buckets: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketArgsDict']]]]
        """
        Set of buckets. Ranges must be non-overlapping.
        Bucket is represented as a range, along with replacement values.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigArgs:
    def __init__(__self__, *,
                 buckets: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketArgs']]] buckets: Set of buckets. Ranges must be non-overlapping.
               Bucket is represented as a range, along with replacement values.
               Structure is documented below.
        """
        if buckets is not None:
            pulumi.set(__self__, "buckets", buckets)

    @property
    @pulumi.getter
    def buckets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketArgs']]]]:
        """
        Set of buckets. Ranges must be non-overlapping.
        Bucket is represented as a range, along with replacement values.
        Structure is documented below.
        """
        return pulumi.get(self, "buckets")

    @buckets.setter
    def buckets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketArgs']]]]):
        pulumi.set(self, "buckets", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketArgsDict(TypedDict):
        replacement_value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgsDict']
        """
        Replacement value for this bucket.
        The `replacement_value` block must only contain one argument.
        Structure is documented below.
        """
        max: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxArgsDict']]
        """
        Upper bound of the range, exclusive; type must match min.
        The `max` block must only contain one argument. See the `bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
        min: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinArgsDict']]
        """
        Lower bound of the range, inclusive. Type should be the same as max if used.
        The `min` block must only contain one argument. See the `bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketArgs:
    def __init__(__self__, *,
                 replacement_value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgs'],
                 max: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxArgs']] = None,
                 min: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgs'] replacement_value: Replacement value for this bucket.
               The `replacement_value` block must only contain one argument.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxArgs'] max: Upper bound of the range, exclusive; type must match min.
               The `max` block must only contain one argument. See the `bucketing_config` block description for more information about choosing a data type.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinArgs'] min: Lower bound of the range, inclusive. Type should be the same as max if used.
               The `min` block must only contain one argument. See the `bucketing_config` block description for more information about choosing a data type.
               Structure is documented below.
        """
        pulumi.set(__self__, "replacement_value", replacement_value)
        if max is not None:
            pulumi.set(__self__, "max", max)
        if min is not None:
            pulumi.set(__self__, "min", min)

    @property
    @pulumi.getter(name="replacementValue")
    def replacement_value(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgs']:
        """
        Replacement value for this bucket.
        The `replacement_value` block must only contain one argument.
        Structure is documented below.
        """
        return pulumi.get(self, "replacement_value")

    @replacement_value.setter
    def replacement_value(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgs']):
        pulumi.set(self, "replacement_value", value)

    @property
    @pulumi.getter
    def max(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxArgs']]:
        """
        Upper bound of the range, exclusive; type must match min.
        The `max` block must only contain one argument. See the `bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
        return pulumi.get(self, "max")

    @max.setter
    def max(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxArgs']]):
        pulumi.set(self, "max", value)

    @property
    @pulumi.getter
    def min(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinArgs']]:
        """
        Lower bound of the range, inclusive. Type should be the same as max if used.
        The `min` block must only contain one argument. See the `bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
        return pulumi.get(self, "min")

    @min.setter
    def min(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinArgs']]):
        pulumi.set(self, "min", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxArgsDict(TypedDict):
        boolean_value: NotRequired[pulumi.Input[bool]]
        """
        A boolean value.
        """
        date_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgsDict']]
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        day_of_week_value: NotRequired[pulumi.Input[str]]
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        An integer value (int64 format)
        """
        string_value: NotRequired[pulumi.Input[str]]
        """
        A string value.
        """
        time_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgsDict']]
        """
        Represents a time of day.
        Structure is documented below.
        """
        timestamp_value: NotRequired[pulumi.Input[str]]
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxArgs:
    def __init__(__self__, *,
                 boolean_value: Optional[pulumi.Input[bool]] = None,
                 date_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgs']] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None,
                 string_value: Optional[pulumi.Input[str]] = None,
                 time_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgs']] = None,
                 timestamp_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] boolean_value: A boolean value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgs'] date_value: Represents a whole or partial calendar date.
               Structure is documented below.
        :param pulumi.Input[str] day_of_week_value: Represents a day of the week.
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[str] integer_value: An integer value (int64 format)
        :param pulumi.Input[str] string_value: A string value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgs'] time_value: Represents a time of day.
               Structure is documented below.
        :param pulumi.Input[str] timestamp_value: A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        if boolean_value is not None:
            pulumi.set(__self__, "boolean_value", boolean_value)
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if time_value is not None:
            pulumi.set(__self__, "time_value", time_value)
        if timestamp_value is not None:
            pulumi.set(__self__, "timestamp_value", timestamp_value)

    @property
    @pulumi.getter(name="booleanValue")
    def boolean_value(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value.
        """
        return pulumi.get(self, "boolean_value")

    @boolean_value.setter
    def boolean_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean_value", value)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgs']]:
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgs']]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        A string value.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)

    @property
    @pulumi.getter(name="timeValue")
    def time_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgs']]:
        """
        Represents a time of day.
        Structure is documented below.
        """
        return pulumi.get(self, "time_value")

    @time_value.setter
    def time_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgs']]):
        pulumi.set(self, "time_value", value)

    @property
    @pulumi.getter(name="timestampValue")
    def timestamp_value(self) -> Optional[pulumi.Input[str]]:
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "timestamp_value")

    @timestamp_value.setter
    def timestamp_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxDateValueArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
               
               - - -
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMaxTimeValueArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinArgsDict(TypedDict):
        boolean_value: NotRequired[pulumi.Input[bool]]
        """
        A boolean value.
        """
        date_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgsDict']]
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        day_of_week_value: NotRequired[pulumi.Input[str]]
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        An integer value (int64 format)
        """
        string_value: NotRequired[pulumi.Input[str]]
        """
        A string value.
        """
        time_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgsDict']]
        """
        Represents a time of day.
        Structure is documented below.
        """
        timestamp_value: NotRequired[pulumi.Input[str]]
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinArgs:
    def __init__(__self__, *,
                 boolean_value: Optional[pulumi.Input[bool]] = None,
                 date_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgs']] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None,
                 string_value: Optional[pulumi.Input[str]] = None,
                 time_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgs']] = None,
                 timestamp_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] boolean_value: A boolean value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgs'] date_value: Represents a whole or partial calendar date.
               Structure is documented below.
        :param pulumi.Input[str] day_of_week_value: Represents a day of the week.
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[str] integer_value: An integer value (int64 format)
        :param pulumi.Input[str] string_value: A string value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgs'] time_value: Represents a time of day.
               Structure is documented below.
        :param pulumi.Input[str] timestamp_value: A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        if boolean_value is not None:
            pulumi.set(__self__, "boolean_value", boolean_value)
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if time_value is not None:
            pulumi.set(__self__, "time_value", time_value)
        if timestamp_value is not None:
            pulumi.set(__self__, "timestamp_value", timestamp_value)

    @property
    @pulumi.getter(name="booleanValue")
    def boolean_value(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value.
        """
        return pulumi.get(self, "boolean_value")

    @boolean_value.setter
    def boolean_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean_value", value)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgs']]:
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgs']]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        A string value.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)

    @property
    @pulumi.getter(name="timeValue")
    def time_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgs']]:
        """
        Represents a time of day.
        Structure is documented below.
        """
        return pulumi.get(self, "time_value")

    @time_value.setter
    def time_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgs']]):
        pulumi.set(self, "time_value", value)

    @property
    @pulumi.getter(name="timestampValue")
    def timestamp_value(self) -> Optional[pulumi.Input[str]]:
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "timestamp_value")

    @timestamp_value.setter
    def timestamp_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinDateValueArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
               
               - - -
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketMinTimeValueArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgsDict(TypedDict):
        boolean_value: NotRequired[pulumi.Input[bool]]
        """
        A boolean value.
        """
        date_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgsDict']]
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        day_of_week_value: NotRequired[pulumi.Input[str]]
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        An integer value (int64 format)
        """
        string_value: NotRequired[pulumi.Input[str]]
        """
        A string value.
        """
        time_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgsDict']]
        """
        Represents a time of day.
        Structure is documented below.
        """
        timestamp_value: NotRequired[pulumi.Input[str]]
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueArgs:
    def __init__(__self__, *,
                 boolean_value: Optional[pulumi.Input[bool]] = None,
                 date_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgs']] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None,
                 string_value: Optional[pulumi.Input[str]] = None,
                 time_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgs']] = None,
                 timestamp_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] boolean_value: A boolean value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgs'] date_value: Represents a whole or partial calendar date.
               Structure is documented below.
        :param pulumi.Input[str] day_of_week_value: Represents a day of the week.
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[str] integer_value: An integer value (int64 format)
        :param pulumi.Input[str] string_value: A string value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgs'] time_value: Represents a time of day.
               Structure is documented below.
        :param pulumi.Input[str] timestamp_value: A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        if boolean_value is not None:
            pulumi.set(__self__, "boolean_value", boolean_value)
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if time_value is not None:
            pulumi.set(__self__, "time_value", time_value)
        if timestamp_value is not None:
            pulumi.set(__self__, "timestamp_value", timestamp_value)

    @property
    @pulumi.getter(name="booleanValue")
    def boolean_value(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value.
        """
        return pulumi.get(self, "boolean_value")

    @boolean_value.setter
    def boolean_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean_value", value)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgs']]:
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgs']]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        A string value.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)

    @property
    @pulumi.getter(name="timeValue")
    def time_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgs']]:
        """
        Represents a time of day.
        Structure is documented below.
        """
        return pulumi.get(self, "time_value")

    @time_value.setter
    def time_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgs']]):
        pulumi.set(self, "time_value", value)

    @property
    @pulumi.getter(name="timestampValue")
    def timestamp_value(self) -> Optional[pulumi.Input[str]]:
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "timestamp_value")

    @timestamp_value.setter
    def timestamp_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueDateValueArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
               
               - - -
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationBucketingConfigBucketReplacementValueTimeValueArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigArgsDict(TypedDict):
        characters_to_ignores: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgsDict']]]]
        """
        Characters to skip when doing de-identification of a value. These will be left alone and skipped.
        Structure is documented below.
        """
        masking_character: NotRequired[pulumi.Input[str]]
        """
        Character to use to mask the sensitive valuesfor example, * for an alphabetic string such as a name, or 0 for a numeric string
        such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to * for
        strings, and 0 for digits.
        """
        number_to_mask: NotRequired[pulumi.Input[int]]
        """
        Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.
        If number_to_mask is negative, this denotes inverse masking. Cloud DLP masks all but a number of characters. For example, suppose you have the following values:
        """
        reverse_order: NotRequired[pulumi.Input[bool]]
        """
        Mask characters in reverse order. For example, if masking_character is 0, number_to_mask is 14, and reverse_order is `false`, then the
        input string `1234-5678-9012-3456` is masked as `00000000000000-3456`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigArgs:
    def __init__(__self__, *,
                 characters_to_ignores: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgs']]]] = None,
                 masking_character: Optional[pulumi.Input[str]] = None,
                 number_to_mask: Optional[pulumi.Input[int]] = None,
                 reverse_order: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgs']]] characters_to_ignores: Characters to skip when doing de-identification of a value. These will be left alone and skipped.
               Structure is documented below.
        :param pulumi.Input[str] masking_character: Character to use to mask the sensitive valuesfor example, * for an alphabetic string such as a name, or 0 for a numeric string
               such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to * for
               strings, and 0 for digits.
        :param pulumi.Input[int] number_to_mask: Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.
               If number_to_mask is negative, this denotes inverse masking. Cloud DLP masks all but a number of characters. For example, suppose you have the following values:
        :param pulumi.Input[bool] reverse_order: Mask characters in reverse order. For example, if masking_character is 0, number_to_mask is 14, and reverse_order is `false`, then the
               input string `1234-5678-9012-3456` is masked as `00000000000000-3456`.
        """
        if characters_to_ignores is not None:
            pulumi.set(__self__, "characters_to_ignores", characters_to_ignores)
        if masking_character is not None:
            pulumi.set(__self__, "masking_character", masking_character)
        if number_to_mask is not None:
            pulumi.set(__self__, "number_to_mask", number_to_mask)
        if reverse_order is not None:
            pulumi.set(__self__, "reverse_order", reverse_order)

    @property
    @pulumi.getter(name="charactersToIgnores")
    def characters_to_ignores(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgs']]]]:
        """
        Characters to skip when doing de-identification of a value. These will be left alone and skipped.
        Structure is documented below.
        """
        return pulumi.get(self, "characters_to_ignores")

    @characters_to_ignores.setter
    def characters_to_ignores(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgs']]]]):
        pulumi.set(self, "characters_to_ignores", value)

    @property
    @pulumi.getter(name="maskingCharacter")
    def masking_character(self) -> Optional[pulumi.Input[str]]:
        """
        Character to use to mask the sensitive valuesfor example, * for an alphabetic string such as a name, or 0 for a numeric string
        such as ZIP code or credit card number. This string must have a length of 1. If not supplied, this value defaults to * for
        strings, and 0 for digits.
        """
        return pulumi.get(self, "masking_character")

    @masking_character.setter
    def masking_character(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "masking_character", value)

    @property
    @pulumi.getter(name="numberToMask")
    def number_to_mask(self) -> Optional[pulumi.Input[int]]:
        """
        Number of characters to mask. If not set, all matching chars will be masked. Skipped characters do not count towards this tally.
        If number_to_mask is negative, this denotes inverse masking. Cloud DLP masks all but a number of characters. For example, suppose you have the following values:
        """
        return pulumi.get(self, "number_to_mask")

    @number_to_mask.setter
    def number_to_mask(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "number_to_mask", value)

    @property
    @pulumi.getter(name="reverseOrder")
    def reverse_order(self) -> Optional[pulumi.Input[bool]]:
        """
        Mask characters in reverse order. For example, if masking_character is 0, number_to_mask is 14, and reverse_order is `false`, then the
        input string `1234-5678-9012-3456` is masked as `00000000000000-3456`.
        """
        return pulumi.get(self, "reverse_order")

    @reverse_order.setter
    def reverse_order(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "reverse_order", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgsDict(TypedDict):
        characters_to_skip: NotRequired[pulumi.Input[str]]
        """
        Characters to not transform when masking. Only one of this or `common_characters_to_ignore` must be specified.
        """
        common_characters_to_ignore: NotRequired[pulumi.Input[str]]
        """
        Common characters to not transform when masking. Useful to avoid removing punctuation. Only one of this or `characters_to_skip` must be specified.
        Possible values are: `NUMERIC`, `ALPHA_UPPER_CASE`, `ALPHA_LOWER_CASE`, `PUNCTUATION`, `WHITESPACE`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCharacterMaskConfigCharactersToIgnoreArgs:
    def __init__(__self__, *,
                 characters_to_skip: Optional[pulumi.Input[str]] = None,
                 common_characters_to_ignore: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] characters_to_skip: Characters to not transform when masking. Only one of this or `common_characters_to_ignore` must be specified.
        :param pulumi.Input[str] common_characters_to_ignore: Common characters to not transform when masking. Useful to avoid removing punctuation. Only one of this or `characters_to_skip` must be specified.
               Possible values are: `NUMERIC`, `ALPHA_UPPER_CASE`, `ALPHA_LOWER_CASE`, `PUNCTUATION`, `WHITESPACE`.
        """
        if characters_to_skip is not None:
            pulumi.set(__self__, "characters_to_skip", characters_to_skip)
        if common_characters_to_ignore is not None:
            pulumi.set(__self__, "common_characters_to_ignore", common_characters_to_ignore)

    @property
    @pulumi.getter(name="charactersToSkip")
    def characters_to_skip(self) -> Optional[pulumi.Input[str]]:
        """
        Characters to not transform when masking. Only one of this or `common_characters_to_ignore` must be specified.
        """
        return pulumi.get(self, "characters_to_skip")

    @characters_to_skip.setter
    def characters_to_skip(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "characters_to_skip", value)

    @property
    @pulumi.getter(name="commonCharactersToIgnore")
    def common_characters_to_ignore(self) -> Optional[pulumi.Input[str]]:
        """
        Common characters to not transform when masking. Useful to avoid removing punctuation. Only one of this or `characters_to_skip` must be specified.
        Possible values are: `NUMERIC`, `ALPHA_UPPER_CASE`, `ALPHA_LOWER_CASE`, `PUNCTUATION`, `WHITESPACE`.
        """
        return pulumi.get(self, "common_characters_to_ignore")

    @common_characters_to_ignore.setter
    def common_characters_to_ignore(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_characters_to_ignore", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigArgsDict(TypedDict):
        context: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgsDict']]
        """
        A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well.
        If the context is not set, plaintext would be used as is for encryption. If the context is set but:
        1. there is no record present when transforming a given value or
        2. the field is not present when transforming a given value,
        plaintext would be used as is for encryption.
        Note that case (1) is expected when an InfoTypeTransformation is applied to both structured and unstructured ContentItems.
        Structure is documented below.
        """
        crypto_key: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgsDict']]
        """
        The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.
        Structure is documented below.
        """
        surrogate_info_type: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgsDict']]
        """
        The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate}
        For example, if the name of custom info type is 'MY\\_TOKEN\\_INFO\\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\\_TOKEN\\_INFO\\_TYPE(3):abc'
        This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text.
        Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text.
        In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either
        *   reverse a surrogate that does not correspond to an actual identifier
        *   be unable to parse the surrogate and result in an error
        Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\\_TOKEN\\_TYPE.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigArgs:
    def __init__(__self__, *,
                 context: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgs']] = None,
                 crypto_key: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgs']] = None,
                 surrogate_info_type: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgs'] context: A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well.
               If the context is not set, plaintext would be used as is for encryption. If the context is set but:
               1. there is no record present when transforming a given value or
               2. the field is not present when transforming a given value,
               plaintext would be used as is for encryption.
               Note that case (1) is expected when an InfoTypeTransformation is applied to both structured and unstructured ContentItems.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgs'] crypto_key: The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgs'] surrogate_info_type: The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate}
               For example, if the name of custom info type is 'MY\\_TOKEN\\_INFO\\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\\_TOKEN\\_INFO\\_TYPE(3):abc'
               This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text.
               Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text.
               In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either
               *   reverse a surrogate that does not correspond to an actual identifier
               *   be unable to parse the surrogate and result in an error
               Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\\_TOKEN\\_TYPE.
               Structure is documented below.
        """
        if context is not None:
            pulumi.set(__self__, "context", context)
        if crypto_key is not None:
            pulumi.set(__self__, "crypto_key", crypto_key)
        if surrogate_info_type is not None:
            pulumi.set(__self__, "surrogate_info_type", surrogate_info_type)

    @property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgs']]:
        """
        A context may be used for higher security and maintaining referential integrity such that the same identifier in two different contexts will be given a distinct surrogate. The context is appended to plaintext value being encrypted. On decryption the provided context is validated against the value used during encryption. If a context was provided during encryption, same context must be provided during decryption as well.
        If the context is not set, plaintext would be used as is for encryption. If the context is set but:
        1. there is no record present when transforming a given value or
        2. the field is not present when transforming a given value,
        plaintext would be used as is for encryption.
        Note that case (1) is expected when an InfoTypeTransformation is applied to both structured and unstructured ContentItems.
        Structure is documented below.
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgs']]):
        pulumi.set(self, "context", value)

    @property
    @pulumi.getter(name="cryptoKey")
    def crypto_key(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgs']]:
        """
        The key used by the encryption function. For deterministic encryption using AES-SIV, the provided key is internally expanded to 64 bytes prior to use.
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_key")

    @crypto_key.setter
    def crypto_key(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgs']]):
        pulumi.set(self, "crypto_key", value)

    @property
    @pulumi.getter(name="surrogateInfoType")
    def surrogate_info_type(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgs']]:
        """
        The custom info type to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom info type followed by the number of characters comprising the surrogate. The following scheme defines the format: {info type name}({surrogate character count}):{surrogate}
        For example, if the name of custom info type is 'MY\\_TOKEN\\_INFO\\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\\_TOKEN\\_INFO\\_TYPE(3):abc'
        This annotation identifies the surrogate when inspecting content using the custom info type 'Surrogate'. This facilitates reversal of the surrogate when it occurs in free text.
        Note: For record transformations where the entire cell in a table is being transformed, surrogates are not mandatory. Surrogates are used to denote the location of the token and are necessary for re-identification in free form text.
        In order for inspection to work properly, the name of this info type must not occur naturally anywhere in your data; otherwise, inspection may either
        *   reverse a surrogate that does not correspond to an actual identifier
        *   be unable to parse the surrogate and result in an error
        Therefore, choose your custom info type name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\\_TOKEN\\_TYPE.
        Structure is documented below.
        """
        return pulumi.get(self, "surrogate_info_type")

    @surrogate_info_type.setter
    def surrogate_info_type(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgs']]):
        pulumi.set(self, "surrogate_info_type", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name describing the field.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigContextArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name describing the field.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name describing the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgsDict(TypedDict):
        kms_wrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgsDict']]
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        transient: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgsDict']]
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        unwrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgsDict']]
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyArgs:
    def __init__(__self__, *,
                 kms_wrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgs']] = None,
                 transient: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgs']] = None,
                 unwrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgs'] kms_wrapped: KMS wrapped key.
               Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
               For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
               Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgs'] transient: Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgs'] unwrapped: Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
               Structure is documented below.
        """
        if kms_wrapped is not None:
            pulumi.set(__self__, "kms_wrapped", kms_wrapped)
        if transient is not None:
            pulumi.set(__self__, "transient", transient)
        if unwrapped is not None:
            pulumi.set(__self__, "unwrapped", unwrapped)

    @property
    @pulumi.getter(name="kmsWrapped")
    def kms_wrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgs']]:
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        return pulumi.get(self, "kms_wrapped")

    @kms_wrapped.setter
    def kms_wrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgs']]):
        pulumi.set(self, "kms_wrapped", value)

    @property
    @pulumi.getter
    def transient(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgs']]:
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "transient")

    @transient.setter
    def transient(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgs']]):
        pulumi.set(self, "transient", value)

    @property
    @pulumi.getter
    def unwrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgs']]:
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "unwrapped")

    @unwrapped.setter
    def unwrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgs']]):
        pulumi.set(self, "unwrapped", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgsDict(TypedDict):
        crypto_key_name: pulumi.Input[str]
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        wrapped_key: pulumi.Input[str]
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyKmsWrappedArgs:
    def __init__(__self__, *,
                 crypto_key_name: pulumi.Input[str],
                 wrapped_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] crypto_key_name: The resource name of the KMS CryptoKey to use for unwrapping.
        :param pulumi.Input[str] wrapped_key: The wrapped data crypto key.
               A base64-encoded string.
        """
        pulumi.set(__self__, "crypto_key_name", crypto_key_name)
        pulumi.set(__self__, "wrapped_key", wrapped_key)

    @property
    @pulumi.getter(name="cryptoKeyName")
    def crypto_key_name(self) -> pulumi.Input[str]:
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        return pulumi.get(self, "crypto_key_name")

    @crypto_key_name.setter
    def crypto_key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "crypto_key_name", value)

    @property
    @pulumi.getter(name="wrappedKey")
    def wrapped_key(self) -> pulumi.Input[str]:
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
        return pulumi.get(self, "wrapped_key")

    @wrapped_key.setter
    def wrapped_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "wrapped_key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyTransientArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigCryptoKeyUnwrappedArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: A 128/192/256 bit key.
               A base64-encoded string.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Optional version name for this InfoType.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 sensitivity_score: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input[str] version: Optional version name for this InfoType.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Optional version name for this InfoType.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoDeterministicConfigSurrogateInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigArgsDict(TypedDict):
        crypto_key: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgsDict']]
        """
        The key used by the encryption function.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigArgs:
    def __init__(__self__, *,
                 crypto_key: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgs'] crypto_key: The key used by the encryption function.
               Structure is documented below.
        """
        if crypto_key is not None:
            pulumi.set(__self__, "crypto_key", crypto_key)

    @property
    @pulumi.getter(name="cryptoKey")
    def crypto_key(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgs']]:
        """
        The key used by the encryption function.
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_key")

    @crypto_key.setter
    def crypto_key(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgs']]):
        pulumi.set(self, "crypto_key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgsDict(TypedDict):
        kms_wrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgsDict']]
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        transient: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgsDict']]
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        unwrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgsDict']]
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyArgs:
    def __init__(__self__, *,
                 kms_wrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgs']] = None,
                 transient: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgs']] = None,
                 unwrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgs'] kms_wrapped: KMS wrapped key.
               Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
               For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
               Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgs'] transient: Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgs'] unwrapped: Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
               Structure is documented below.
        """
        if kms_wrapped is not None:
            pulumi.set(__self__, "kms_wrapped", kms_wrapped)
        if transient is not None:
            pulumi.set(__self__, "transient", transient)
        if unwrapped is not None:
            pulumi.set(__self__, "unwrapped", unwrapped)

    @property
    @pulumi.getter(name="kmsWrapped")
    def kms_wrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgs']]:
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        return pulumi.get(self, "kms_wrapped")

    @kms_wrapped.setter
    def kms_wrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgs']]):
        pulumi.set(self, "kms_wrapped", value)

    @property
    @pulumi.getter
    def transient(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgs']]:
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "transient")

    @transient.setter
    def transient(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgs']]):
        pulumi.set(self, "transient", value)

    @property
    @pulumi.getter
    def unwrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgs']]:
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "unwrapped")

    @unwrapped.setter
    def unwrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgs']]):
        pulumi.set(self, "unwrapped", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgsDict(TypedDict):
        crypto_key_name: pulumi.Input[str]
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        wrapped_key: pulumi.Input[str]
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyKmsWrappedArgs:
    def __init__(__self__, *,
                 crypto_key_name: pulumi.Input[str],
                 wrapped_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] crypto_key_name: The resource name of the KMS CryptoKey to use for unwrapping.
        :param pulumi.Input[str] wrapped_key: The wrapped data crypto key.
               A base64-encoded string.
        """
        pulumi.set(__self__, "crypto_key_name", crypto_key_name)
        pulumi.set(__self__, "wrapped_key", wrapped_key)

    @property
    @pulumi.getter(name="cryptoKeyName")
    def crypto_key_name(self) -> pulumi.Input[str]:
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        return pulumi.get(self, "crypto_key_name")

    @crypto_key_name.setter
    def crypto_key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "crypto_key_name", value)

    @property
    @pulumi.getter(name="wrappedKey")
    def wrapped_key(self) -> pulumi.Input[str]:
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
        return pulumi.get(self, "wrapped_key")

    @wrapped_key.setter
    def wrapped_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "wrapped_key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyTransientArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoHashConfigCryptoKeyUnwrappedArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: A 128/192/256 bit key.
               A base64-encoded string.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgsDict(TypedDict):
        common_alphabet: NotRequired[pulumi.Input[str]]
        """
        Common alphabets. Only one of this, `custom_alphabet` or `radix` must be specified.
        Possible values are: `NUMERIC`, `HEXADECIMAL`, `UPPER_CASE_ALPHA_NUMERIC`, `ALPHA_NUMERIC`.
        """
        context: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgsDict']]
        """
        The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used.
        If the context is set but:
        1.  there is no record present when transforming a given value or
        2.  the field is not present when transforming a given value,
        a default tweak will be used.
        Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string.
        The tweak is constructed as a sequence of bytes in big endian byte order such that:
        *   a 64 bit integer is encoded followed by a single byte of value 1
        *   a string is encoded in UTF-8 format followed by a single byte of value 2
        Structure is documented below.
        """
        crypto_key: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgsDict']]
        """
        The key used by the encryption algorithm.
        Structure is documented below.
        """
        custom_alphabet: NotRequired[pulumi.Input[str]]
        """
        This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range \\[2, 95\\]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
        ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/``. Only one of this, `common_alphabet` or `radix` must be specified.
        """
        radix: NotRequired[pulumi.Input[int]]
        """
        The native way to select the alphabet. Must be in the range \\[2, 95\\]. Only one of this, `custom_alphabet` or `common_alphabet` must be specified.
        """
        surrogate_info_type: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgsDict']]
        """
        The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info\\_type\\_name(surrogate\\_character\\_count):surrogate
        For example, if the name of custom infoType is 'MY\\_TOKEN\\_INFO\\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\\_TOKEN\\_INFO\\_TYPE(3):abc'
        This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text.
        In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\\_TOKEN\\_TYPE
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigArgs:
    def __init__(__self__, *,
                 common_alphabet: Optional[pulumi.Input[str]] = None,
                 context: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgs']] = None,
                 crypto_key: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgs']] = None,
                 custom_alphabet: Optional[pulumi.Input[str]] = None,
                 radix: Optional[pulumi.Input[int]] = None,
                 surrogate_info_type: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgs']] = None):
        """
        :param pulumi.Input[str] common_alphabet: Common alphabets. Only one of this, `custom_alphabet` or `radix` must be specified.
               Possible values are: `NUMERIC`, `HEXADECIMAL`, `UPPER_CASE_ALPHA_NUMERIC`, `ALPHA_NUMERIC`.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgs'] context: The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used.
               If the context is set but:
               1.  there is no record present when transforming a given value or
               2.  the field is not present when transforming a given value,
               a default tweak will be used.
               Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string.
               The tweak is constructed as a sequence of bytes in big endian byte order such that:
               *   a 64 bit integer is encoded followed by a single byte of value 1
               *   a string is encoded in UTF-8 format followed by a single byte of value 2
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgs'] crypto_key: The key used by the encryption algorithm.
               Structure is documented below.
        :param pulumi.Input[str] custom_alphabet: This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range \\[2, 95\\]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
               ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/``. Only one of this, `common_alphabet` or `radix` must be specified.
        :param pulumi.Input[int] radix: The native way to select the alphabet. Must be in the range \\[2, 95\\]. Only one of this, `custom_alphabet` or `common_alphabet` must be specified.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgs'] surrogate_info_type: The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info\\_type\\_name(surrogate\\_character\\_count):surrogate
               For example, if the name of custom infoType is 'MY\\_TOKEN\\_INFO\\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\\_TOKEN\\_INFO\\_TYPE(3):abc'
               This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text.
               In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\\_TOKEN\\_TYPE
               Structure is documented below.
        """
        if common_alphabet is not None:
            pulumi.set(__self__, "common_alphabet", common_alphabet)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if crypto_key is not None:
            pulumi.set(__self__, "crypto_key", crypto_key)
        if custom_alphabet is not None:
            pulumi.set(__self__, "custom_alphabet", custom_alphabet)
        if radix is not None:
            pulumi.set(__self__, "radix", radix)
        if surrogate_info_type is not None:
            pulumi.set(__self__, "surrogate_info_type", surrogate_info_type)

    @property
    @pulumi.getter(name="commonAlphabet")
    def common_alphabet(self) -> Optional[pulumi.Input[str]]:
        """
        Common alphabets. Only one of this, `custom_alphabet` or `radix` must be specified.
        Possible values are: `NUMERIC`, `HEXADECIMAL`, `UPPER_CASE_ALPHA_NUMERIC`, `ALPHA_NUMERIC`.
        """
        return pulumi.get(self, "common_alphabet")

    @common_alphabet.setter
    def common_alphabet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "common_alphabet", value)

    @property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgs']]:
        """
        The 'tweak', a context may be used for higher security since the same identifier in two different contexts won't be given the same surrogate. If the context is not set, a default tweak will be used.
        If the context is set but:
        1.  there is no record present when transforming a given value or
        2.  the field is not present when transforming a given value,
        a default tweak will be used.
        Note that case (1) is expected when an `InfoTypeTransformation` is applied to both structured and non-structured `ContentItem`s. Currently, the referenced field may be of value type integer or string.
        The tweak is constructed as a sequence of bytes in big endian byte order such that:
        *   a 64 bit integer is encoded followed by a single byte of value 1
        *   a string is encoded in UTF-8 format followed by a single byte of value 2
        Structure is documented below.
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgs']]):
        pulumi.set(self, "context", value)

    @property
    @pulumi.getter(name="cryptoKey")
    def crypto_key(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgs']]:
        """
        The key used by the encryption algorithm.
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_key")

    @crypto_key.setter
    def crypto_key(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgs']]):
        pulumi.set(self, "crypto_key", value)

    @property
    @pulumi.getter(name="customAlphabet")
    def custom_alphabet(self) -> Optional[pulumi.Input[str]]:
        """
        This is supported by mapping these to the alphanumeric characters that the FFX mode natively supports. This happens before/after encryption/decryption. Each character listed must appear only once. Number of characters must be in the range \\[2, 95\\]. This must be encoded as ASCII. The order of characters does not matter. The full list of allowed characters is:
        ``0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz ~`!@#$%^&*()_-+={[}]|:;"'<,>.?/``. Only one of this, `common_alphabet` or `radix` must be specified.
        """
        return pulumi.get(self, "custom_alphabet")

    @custom_alphabet.setter
    def custom_alphabet(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "custom_alphabet", value)

    @property
    @pulumi.getter
    def radix(self) -> Optional[pulumi.Input[int]]:
        """
        The native way to select the alphabet. Must be in the range \\[2, 95\\]. Only one of this, `custom_alphabet` or `common_alphabet` must be specified.
        """
        return pulumi.get(self, "radix")

    @radix.setter
    def radix(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "radix", value)

    @property
    @pulumi.getter(name="surrogateInfoType")
    def surrogate_info_type(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgs']]:
        """
        The custom infoType to annotate the surrogate with. This annotation will be applied to the surrogate by prefixing it with the name of the custom infoType followed by the number of characters comprising the surrogate. The following scheme defines the format: info\\_type\\_name(surrogate\\_character\\_count):surrogate
        For example, if the name of custom infoType is 'MY\\_TOKEN\\_INFO\\_TYPE' and the surrogate is 'abc', the full replacement value will be: 'MY\\_TOKEN\\_INFO\\_TYPE(3):abc'
        This annotation identifies the surrogate when inspecting content using the custom infoType [`SurrogateType`](https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#surrogatetype). This facilitates reversal of the surrogate when it occurs in free text.
        In order for inspection to work properly, the name of this infoType must not occur naturally anywhere in your data; otherwise, inspection may find a surrogate that does not correspond to an actual identifier. Therefore, choose your custom infoType name carefully after considering what your data looks like. One way to select a name that has a high chance of yielding reliable detection is to include one or more unicode characters that are highly improbable to exist in your data. For example, assuming your data is entered from a regular ASCII keyboard, the symbol with the hex code point 29DD might be used like so: MY\\_TOKEN\\_TYPE
        Structure is documented below.
        """
        return pulumi.get(self, "surrogate_info_type")

    @surrogate_info_type.setter
    def surrogate_info_type(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgs']]):
        pulumi.set(self, "surrogate_info_type", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name describing the field.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigContextArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name describing the field.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name describing the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgsDict(TypedDict):
        kms_wrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgsDict']]
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        transient: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgsDict']]
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        unwrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgsDict']]
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyArgs:
    def __init__(__self__, *,
                 kms_wrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgs']] = None,
                 transient: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgs']] = None,
                 unwrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgs'] kms_wrapped: KMS wrapped key.
               Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
               For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
               Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgs'] transient: Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgs'] unwrapped: Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
               Structure is documented below.
        """
        if kms_wrapped is not None:
            pulumi.set(__self__, "kms_wrapped", kms_wrapped)
        if transient is not None:
            pulumi.set(__self__, "transient", transient)
        if unwrapped is not None:
            pulumi.set(__self__, "unwrapped", unwrapped)

    @property
    @pulumi.getter(name="kmsWrapped")
    def kms_wrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgs']]:
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        return pulumi.get(self, "kms_wrapped")

    @kms_wrapped.setter
    def kms_wrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgs']]):
        pulumi.set(self, "kms_wrapped", value)

    @property
    @pulumi.getter
    def transient(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgs']]:
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "transient")

    @transient.setter
    def transient(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgs']]):
        pulumi.set(self, "transient", value)

    @property
    @pulumi.getter
    def unwrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgs']]:
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "unwrapped")

    @unwrapped.setter
    def unwrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgs']]):
        pulumi.set(self, "unwrapped", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgsDict(TypedDict):
        crypto_key_name: pulumi.Input[str]
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        wrapped_key: pulumi.Input[str]
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyKmsWrappedArgs:
    def __init__(__self__, *,
                 crypto_key_name: pulumi.Input[str],
                 wrapped_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] crypto_key_name: The resource name of the KMS CryptoKey to use for unwrapping.
        :param pulumi.Input[str] wrapped_key: The wrapped data crypto key.
               A base64-encoded string.
        """
        pulumi.set(__self__, "crypto_key_name", crypto_key_name)
        pulumi.set(__self__, "wrapped_key", wrapped_key)

    @property
    @pulumi.getter(name="cryptoKeyName")
    def crypto_key_name(self) -> pulumi.Input[str]:
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        return pulumi.get(self, "crypto_key_name")

    @crypto_key_name.setter
    def crypto_key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "crypto_key_name", value)

    @property
    @pulumi.getter(name="wrappedKey")
    def wrapped_key(self) -> pulumi.Input[str]:
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
        return pulumi.get(self, "wrapped_key")

    @wrapped_key.setter
    def wrapped_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "wrapped_key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyTransientArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigCryptoKeyUnwrappedArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: A 128/192/256 bit key.
               A base64-encoded string.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Optional version name for this InfoType.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None,
                 sensitivity_score: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input[str] version: Optional version name for this InfoType.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed at [https://cloud.google.com/dlp/docs/infotypes-reference](https://cloud.google.com/dlp/docs/infotypes-reference) when specifying a built-in type. When sending Cloud DLP results to Data Catalog, infoType names should conform to the pattern `[A-Za-z0-9$-_]{1,64}`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Optional version name for this InfoType.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationCryptoReplaceFfxFpeConfigSurrogateInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigArgsDict(TypedDict):
        lower_bound_days: pulumi.Input[int]
        """
        For example, -5 means shift date to at most 5 days back in the past.
        """
        upper_bound_days: pulumi.Input[int]
        """
        Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
        For example, 3 means shift date to at most 3 days into the future.
        """
        context: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigContextArgsDict']]
        """
        Points to the field that contains the context, for example, an entity id.
        If set, must also set cryptoKey. If set, shift will be consistent for the given context.
        Structure is documented below.
        """
        crypto_key: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgsDict']]
        """
        Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and cryptoKey. If set, must also set context. Can only be applied to table items.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigArgs:
    def __init__(__self__, *,
                 lower_bound_days: pulumi.Input[int],
                 upper_bound_days: pulumi.Input[int],
                 context: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigContextArgs']] = None,
                 crypto_key: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgs']] = None):
        """
        :param pulumi.Input[int] lower_bound_days: For example, -5 means shift date to at most 5 days back in the past.
        :param pulumi.Input[int] upper_bound_days: Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
               For example, 3 means shift date to at most 3 days into the future.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigContextArgs'] context: Points to the field that contains the context, for example, an entity id.
               If set, must also set cryptoKey. If set, shift will be consistent for the given context.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgs'] crypto_key: Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and cryptoKey. If set, must also set context. Can only be applied to table items.
               Structure is documented below.
        """
        pulumi.set(__self__, "lower_bound_days", lower_bound_days)
        pulumi.set(__self__, "upper_bound_days", upper_bound_days)
        if context is not None:
            pulumi.set(__self__, "context", context)
        if crypto_key is not None:
            pulumi.set(__self__, "crypto_key", crypto_key)

    @property
    @pulumi.getter(name="lowerBoundDays")
    def lower_bound_days(self) -> pulumi.Input[int]:
        """
        For example, -5 means shift date to at most 5 days back in the past.
        """
        return pulumi.get(self, "lower_bound_days")

    @lower_bound_days.setter
    def lower_bound_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "lower_bound_days", value)

    @property
    @pulumi.getter(name="upperBoundDays")
    def upper_bound_days(self) -> pulumi.Input[int]:
        """
        Range of shift in days. Actual shift will be selected at random within this range (inclusive ends). Negative means shift to earlier in time. Must not be more than 365250 days (1000 years) each direction.
        For example, 3 means shift date to at most 3 days into the future.
        """
        return pulumi.get(self, "upper_bound_days")

    @upper_bound_days.setter
    def upper_bound_days(self, value: pulumi.Input[int]):
        pulumi.set(self, "upper_bound_days", value)

    @property
    @pulumi.getter
    def context(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigContextArgs']]:
        """
        Points to the field that contains the context, for example, an entity id.
        If set, must also set cryptoKey. If set, shift will be consistent for the given context.
        Structure is documented below.
        """
        return pulumi.get(self, "context")

    @context.setter
    def context(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigContextArgs']]):
        pulumi.set(self, "context", value)

    @property
    @pulumi.getter(name="cryptoKey")
    def crypto_key(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgs']]:
        """
        Causes the shift to be computed based on this key and the context. This results in the same shift for the same context and cryptoKey. If set, must also set context. Can only be applied to table items.
        Structure is documented below.
        """
        return pulumi.get(self, "crypto_key")

    @crypto_key.setter
    def crypto_key(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgs']]):
        pulumi.set(self, "crypto_key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigContextArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name describing the field.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigContextArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigContextArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name describing the field.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name describing the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgsDict(TypedDict):
        kms_wrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgsDict']]
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        transient: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgsDict']]
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        unwrapped: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgsDict']]
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyArgs:
    def __init__(__self__, *,
                 kms_wrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgs']] = None,
                 transient: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgs']] = None,
                 unwrapped: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgs'] kms_wrapped: KMS wrapped key.
               Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
               For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
               Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgs'] transient: Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgs'] unwrapped: Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
               Structure is documented below.
        """
        if kms_wrapped is not None:
            pulumi.set(__self__, "kms_wrapped", kms_wrapped)
        if transient is not None:
            pulumi.set(__self__, "transient", transient)
        if unwrapped is not None:
            pulumi.set(__self__, "unwrapped", unwrapped)

    @property
    @pulumi.getter(name="kmsWrapped")
    def kms_wrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgs']]:
        """
        KMS wrapped key.
        Include to use an existing data crypto key wrapped by KMS. The wrapped key must be a 128-, 192-, or 256-bit key. Authorization requires the following IAM permissions when sending a request to perform a crypto transformation using a KMS-wrapped crypto key: dlp.kms.encrypt
        For more information, see [Creating a wrapped key](https://cloud.google.com/dlp/docs/create-wrapped-key). Only one of this, `transient` or `unwrapped` must be specified.
        Note: When you use Cloud KMS for cryptographic operations, [charges apply](https://cloud.google.com/kms/pricing).
        Structure is documented below.
        """
        return pulumi.get(self, "kms_wrapped")

    @kms_wrapped.setter
    def kms_wrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgs']]):
        pulumi.set(self, "kms_wrapped", value)

    @property
    @pulumi.getter
    def transient(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgs']]:
        """
        Transient crypto key. Use this to have a random data crypto key generated. It will be discarded after the request finishes. Only one of this, `unwrapped` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "transient")

    @transient.setter
    def transient(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgs']]):
        pulumi.set(self, "transient", value)

    @property
    @pulumi.getter
    def unwrapped(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgs']]:
        """
        Unwrapped crypto key. Using raw keys is prone to security risks due to accidentally leaking the key. Choose another type of key if possible. Only one of this, `transient` or `kms_wrapped` must be specified.
        Structure is documented below.
        """
        return pulumi.get(self, "unwrapped")

    @unwrapped.setter
    def unwrapped(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgs']]):
        pulumi.set(self, "unwrapped", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgsDict(TypedDict):
        crypto_key_name: pulumi.Input[str]
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        wrapped_key: pulumi.Input[str]
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyKmsWrappedArgs:
    def __init__(__self__, *,
                 crypto_key_name: pulumi.Input[str],
                 wrapped_key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] crypto_key_name: The resource name of the KMS CryptoKey to use for unwrapping.
        :param pulumi.Input[str] wrapped_key: The wrapped data crypto key.
               A base64-encoded string.
        """
        pulumi.set(__self__, "crypto_key_name", crypto_key_name)
        pulumi.set(__self__, "wrapped_key", wrapped_key)

    @property
    @pulumi.getter(name="cryptoKeyName")
    def crypto_key_name(self) -> pulumi.Input[str]:
        """
        The resource name of the KMS CryptoKey to use for unwrapping.
        """
        return pulumi.get(self, "crypto_key_name")

    @crypto_key_name.setter
    def crypto_key_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "crypto_key_name", value)

    @property
    @pulumi.getter(name="wrappedKey")
    def wrapped_key(self) -> pulumi.Input[str]:
        """
        The wrapped data crypto key.
        A base64-encoded string.
        """
        return pulumi.get(self, "wrapped_key")

    @wrapped_key.setter
    def wrapped_key(self, value: pulumi.Input[str]):
        pulumi.set(self, "wrapped_key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyTransientArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the key. This is an arbitrary string used to differentiate different keys. A unique key is generated per name: two separate `TransientCryptoKey` protos share the same generated key if their names are the same. When the data crypto key is generated, this name is not used in any way (repeating the api call will result in a different key being generated).
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgsDict(TypedDict):
        key: pulumi.Input[str]
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationDateShiftConfigCryptoKeyUnwrappedArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[str]):
        """
        :param pulumi.Input[str] key: A 128/192/256 bit key.
               A base64-encoded string.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        pulumi.set(__self__, "key", key)

    @property
    @pulumi.getter
    def key(self) -> pulumi.Input[str]:
        """
        A 128/192/256 bit key.
        A base64-encoded string.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[str]):
        pulumi.set(self, "key", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigArgsDict(TypedDict):
        bucket_size: pulumi.Input[float]
        """
        Size of each bucket (except for minimum and maximum buckets).
        So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
        Precision up to 2 decimals works.
        """
        lower_bound: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgsDict']
        """
        Lower bound value of buckets.
        All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
        The `lower_bound` block must only contain one argument. See the `fixed_size_bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
        upper_bound: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgsDict']
        """
        Upper bound value of buckets.
        All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
        The `upper_bound` block must only contain one argument. See the `fixed_size_bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigArgs:
    def __init__(__self__, *,
                 bucket_size: pulumi.Input[float],
                 lower_bound: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgs'],
                 upper_bound: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgs']):
        """
        :param pulumi.Input[float] bucket_size: Size of each bucket (except for minimum and maximum buckets).
               So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
               Precision up to 2 decimals works.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgs'] lower_bound: Lower bound value of buckets.
               All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
               The `lower_bound` block must only contain one argument. See the `fixed_size_bucketing_config` block description for more information about choosing a data type.
               Structure is documented below.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgs'] upper_bound: Upper bound value of buckets.
               All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
               The `upper_bound` block must only contain one argument. See the `fixed_size_bucketing_config` block description for more information about choosing a data type.
               Structure is documented below.
        """
        pulumi.set(__self__, "bucket_size", bucket_size)
        pulumi.set(__self__, "lower_bound", lower_bound)
        pulumi.set(__self__, "upper_bound", upper_bound)

    @property
    @pulumi.getter(name="bucketSize")
    def bucket_size(self) -> pulumi.Input[float]:
        """
        Size of each bucket (except for minimum and maximum buckets).
        So if lower_bound = 10, upper_bound = 89, and bucketSize = 10, then the following buckets would be used: -10, 10-20, 20-30, 30-40, 40-50, 50-60, 60-70, 70-80, 80-89, 89+.
        Precision up to 2 decimals works.
        """
        return pulumi.get(self, "bucket_size")

    @bucket_size.setter
    def bucket_size(self, value: pulumi.Input[float]):
        pulumi.set(self, "bucket_size", value)

    @property
    @pulumi.getter(name="lowerBound")
    def lower_bound(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgs']:
        """
        Lower bound value of buckets.
        All values less than lower_bound are grouped together into a single bucket; for example if lower_bound = 10, then all values less than 10 are replaced with the value "-10".
        The `lower_bound` block must only contain one argument. See the `fixed_size_bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
        return pulumi.get(self, "lower_bound")

    @lower_bound.setter
    def lower_bound(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgs']):
        pulumi.set(self, "lower_bound", value)

    @property
    @pulumi.getter(name="upperBound")
    def upper_bound(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgs']:
        """
        Upper bound value of buckets.
        All values greater than upper_bound are grouped together into a single bucket; for example if upper_bound = 89, then all values greater than 89 are replaced with the value "89+".
        The `upper_bound` block must only contain one argument. See the `fixed_size_bucketing_config` block description for more information about choosing a data type.
        Structure is documented below.
        """
        return pulumi.get(self, "upper_bound")

    @upper_bound.setter
    def upper_bound(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgs']):
        pulumi.set(self, "upper_bound", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgsDict(TypedDict):
        boolean_value: NotRequired[pulumi.Input[bool]]
        """
        A boolean value.
        """
        date_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValueArgsDict']]
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        day_of_week_value: NotRequired[pulumi.Input[str]]
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        An integer value (int64 format)
        """
        string_value: NotRequired[pulumi.Input[str]]
        """
        A string value.
        """
        time_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValueArgsDict']]
        """
        Represents a time of day.
        Structure is documented below.
        """
        timestamp_value: NotRequired[pulumi.Input[str]]
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundArgs:
    def __init__(__self__, *,
                 boolean_value: Optional[pulumi.Input[bool]] = None,
                 date_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValueArgs']] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None,
                 string_value: Optional[pulumi.Input[str]] = None,
                 time_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValueArgs']] = None,
                 timestamp_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] boolean_value: A boolean value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValueArgs'] date_value: Represents a whole or partial calendar date.
               Structure is documented below.
        :param pulumi.Input[str] day_of_week_value: Represents a day of the week.
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[str] integer_value: An integer value (int64 format)
        :param pulumi.Input[str] string_value: A string value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValueArgs'] time_value: Represents a time of day.
               Structure is documented below.
        :param pulumi.Input[str] timestamp_value: A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        if boolean_value is not None:
            pulumi.set(__self__, "boolean_value", boolean_value)
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if time_value is not None:
            pulumi.set(__self__, "time_value", time_value)
        if timestamp_value is not None:
            pulumi.set(__self__, "timestamp_value", timestamp_value)

    @property
    @pulumi.getter(name="booleanValue")
    def boolean_value(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value.
        """
        return pulumi.get(self, "boolean_value")

    @boolean_value.setter
    def boolean_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean_value", value)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValueArgs']]:
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValueArgs']]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        A string value.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)

    @property
    @pulumi.getter(name="timeValue")
    def time_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValueArgs']]:
        """
        Represents a time of day.
        Structure is documented below.
        """
        return pulumi.get(self, "time_value")

    @time_value.setter
    def time_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValueArgs']]):
        pulumi.set(self, "time_value", value)

    @property
    @pulumi.getter(name="timestampValue")
    def timestamp_value(self) -> Optional[pulumi.Input[str]]:
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "timestamp_value")

    @timestamp_value.setter
    def timestamp_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValueArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundDateValueArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
               
               - - -
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValueArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigLowerBoundTimeValueArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgsDict(TypedDict):
        boolean_value: NotRequired[pulumi.Input[bool]]
        """
        A boolean value.
        """
        date_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValueArgsDict']]
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        day_of_week_value: NotRequired[pulumi.Input[str]]
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        An integer value (int64 format)
        """
        string_value: NotRequired[pulumi.Input[str]]
        """
        A string value.
        """
        time_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValueArgsDict']]
        """
        Represents a time of day.
        Structure is documented below.
        """
        timestamp_value: NotRequired[pulumi.Input[str]]
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundArgs:
    def __init__(__self__, *,
                 boolean_value: Optional[pulumi.Input[bool]] = None,
                 date_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValueArgs']] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None,
                 string_value: Optional[pulumi.Input[str]] = None,
                 time_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValueArgs']] = None,
                 timestamp_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] boolean_value: A boolean value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValueArgs'] date_value: Represents a whole or partial calendar date.
               Structure is documented below.
        :param pulumi.Input[str] day_of_week_value: Represents a day of the week.
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[str] integer_value: An integer value (int64 format)
        :param pulumi.Input[str] string_value: A string value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValueArgs'] time_value: Represents a time of day.
               Structure is documented below.
        :param pulumi.Input[str] timestamp_value: A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        if boolean_value is not None:
            pulumi.set(__self__, "boolean_value", boolean_value)
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if time_value is not None:
            pulumi.set(__self__, "time_value", time_value)
        if timestamp_value is not None:
            pulumi.set(__self__, "timestamp_value", timestamp_value)

    @property
    @pulumi.getter(name="booleanValue")
    def boolean_value(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value.
        """
        return pulumi.get(self, "boolean_value")

    @boolean_value.setter
    def boolean_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean_value", value)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValueArgs']]:
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValueArgs']]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        A string value.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)

    @property
    @pulumi.getter(name="timeValue")
    def time_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValueArgs']]:
        """
        Represents a time of day.
        Structure is documented below.
        """
        return pulumi.get(self, "time_value")

    @time_value.setter
    def time_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValueArgs']]):
        pulumi.set(self, "time_value", value)

    @property
    @pulumi.getter(name="timestampValue")
    def timestamp_value(self) -> Optional[pulumi.Input[str]]:
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "timestamp_value")

    @timestamp_value.setter
    def timestamp_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValueArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundDateValueArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
               
               - - -
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValueArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationFixedSizeBucketingConfigUpperBoundTimeValueArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationRedactConfigArgsDict(TypedDict):
        pass
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationRedactConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationRedactConfigArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigArgsDict(TypedDict):
        new_value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueArgsDict']
        """
        Replace each input value with a given value.
        The `new_value` block must only contain one argument. For example when replacing the contents of a string-type field, only `string_value` should be set.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigArgs:
    def __init__(__self__, *,
                 new_value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueArgs']):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueArgs'] new_value: Replace each input value with a given value.
               The `new_value` block must only contain one argument. For example when replacing the contents of a string-type field, only `string_value` should be set.
               Structure is documented below.
        """
        pulumi.set(__self__, "new_value", new_value)

    @property
    @pulumi.getter(name="newValue")
    def new_value(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueArgs']:
        """
        Replace each input value with a given value.
        The `new_value` block must only contain one argument. For example when replacing the contents of a string-type field, only `string_value` should be set.
        Structure is documented below.
        """
        return pulumi.get(self, "new_value")

    @new_value.setter
    def new_value(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueArgs']):
        pulumi.set(self, "new_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueArgsDict(TypedDict):
        boolean_value: NotRequired[pulumi.Input[bool]]
        """
        A boolean value.
        """
        date_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgsDict']]
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        day_of_week_value: NotRequired[pulumi.Input[str]]
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        An integer value (int64 format)
        """
        string_value: NotRequired[pulumi.Input[str]]
        """
        A string value.
        """
        time_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgsDict']]
        """
        Represents a time of day.
        Structure is documented below.
        """
        timestamp_value: NotRequired[pulumi.Input[str]]
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
        Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueArgs:
    def __init__(__self__, *,
                 boolean_value: Optional[pulumi.Input[bool]] = None,
                 date_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgs']] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None,
                 string_value: Optional[pulumi.Input[str]] = None,
                 time_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgs']] = None,
                 timestamp_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] boolean_value: A boolean value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgs'] date_value: Represents a whole or partial calendar date.
               Structure is documented below.
        :param pulumi.Input[str] day_of_week_value: Represents a day of the week.
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[str] integer_value: An integer value (int64 format)
        :param pulumi.Input[str] string_value: A string value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgs'] time_value: Represents a time of day.
               Structure is documented below.
        :param pulumi.Input[str] timestamp_value: A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
               Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        if boolean_value is not None:
            pulumi.set(__self__, "boolean_value", boolean_value)
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if time_value is not None:
            pulumi.set(__self__, "time_value", time_value)
        if timestamp_value is not None:
            pulumi.set(__self__, "timestamp_value", timestamp_value)

    @property
    @pulumi.getter(name="booleanValue")
    def boolean_value(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value.
        """
        return pulumi.get(self, "boolean_value")

    @boolean_value.setter
    def boolean_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean_value", value)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgs']]:
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgs']]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        A string value.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)

    @property
    @pulumi.getter(name="timeValue")
    def time_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgs']]:
        """
        Represents a time of day.
        Structure is documented below.
        """
        return pulumi.get(self, "time_value")

    @time_value.setter
    def time_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgs']]):
        pulumi.set(self, "time_value", value)

    @property
    @pulumi.getter(name="timestampValue")
    def timestamp_value(self) -> Optional[pulumi.Input[str]]:
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits.
        Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "timestamp_value")

    @timestamp_value.setter
    def timestamp_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueDateValueArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
               
               - - -
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceConfigNewValueTimeValueArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigArgsDict(TypedDict):
        word_list: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgsDict']]
        """
        A list of words to select from for random replacement. The [limits](https://cloud.google.com/dlp/limits) page contains details about the size limits of dictionaries.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigArgs:
    def __init__(__self__, *,
                 word_list: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgs'] word_list: A list of words to select from for random replacement. The [limits](https://cloud.google.com/dlp/limits) page contains details about the size limits of dictionaries.
               Structure is documented below.
        """
        if word_list is not None:
            pulumi.set(__self__, "word_list", word_list)

    @property
    @pulumi.getter(name="wordList")
    def word_list(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgs']]:
        """
        A list of words to select from for random replacement. The [limits](https://cloud.google.com/dlp/limits) page contains details about the size limits of dictionaries.
        Structure is documented below.
        """
        return pulumi.get(self, "word_list")

    @word_list.setter
    def word_list(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgs']]):
        pulumi.set(self, "word_list", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgsDict(TypedDict):
        words: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationReplaceDictionaryConfigWordListArgs:
    def __init__(__self__, *,
                 words: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] words: Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
        pulumi.set(__self__, "words", words)

    @property
    @pulumi.getter
    def words(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Words or phrases defining the dictionary. The dictionary must contain at least one phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
        return pulumi.get(self, "words")

    @words.setter
    def words(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "words", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationTimePartConfigArgsDict(TypedDict):
        part_to_extract: NotRequired[pulumi.Input[str]]
        """
        The part of the time to keep.
        Possible values are: `YEAR`, `MONTH`, `DAY_OF_MONTH`, `DAY_OF_WEEK`, `WEEK_OF_YEAR`, `HOUR_OF_DAY`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationTimePartConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsFieldTransformationPrimitiveTransformationTimePartConfigArgs:
    def __init__(__self__, *,
                 part_to_extract: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] part_to_extract: The part of the time to keep.
               Possible values are: `YEAR`, `MONTH`, `DAY_OF_MONTH`, `DAY_OF_WEEK`, `WEEK_OF_YEAR`, `HOUR_OF_DAY`.
        """
        if part_to_extract is not None:
            pulumi.set(__self__, "part_to_extract", part_to_extract)

    @property
    @pulumi.getter(name="partToExtract")
    def part_to_extract(self) -> Optional[pulumi.Input[str]]:
        """
        The part of the time to keep.
        Possible values are: `YEAR`, `MONTH`, `DAY_OF_MONTH`, `DAY_OF_WEEK`, `WEEK_OF_YEAR`, `HOUR_OF_DAY`.
        """
        return pulumi.get(self, "part_to_extract")

    @part_to_extract.setter
    def part_to_extract(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "part_to_extract", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionArgsDict(TypedDict):
        condition: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionArgsDict']]
        """
        A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionArgs:
    def __init__(__self__, *,
                 condition: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionArgs'] condition: A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.
               Structure is documented below.
        """
        if condition is not None:
            pulumi.set(__self__, "condition", condition)

    @property
    @pulumi.getter
    def condition(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionArgs']]:
        """
        A condition that when it evaluates to true will result in the record being evaluated to be suppressed from the transformed content.
        Structure is documented below.
        """
        return pulumi.get(self, "condition")

    @condition.setter
    def condition(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionArgs']]):
        pulumi.set(self, "condition", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionArgsDict(TypedDict):
        expressions: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsArgsDict']]
        """
        An expression, consisting of an operator and conditions.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionArgs:
    def __init__(__self__, *,
                 expressions: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsArgs'] expressions: An expression, consisting of an operator and conditions.
               Structure is documented below.
        """
        if expressions is not None:
            pulumi.set(__self__, "expressions", expressions)

    @property
    @pulumi.getter
    def expressions(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsArgs']]:
        """
        An expression, consisting of an operator and conditions.
        Structure is documented below.
        """
        return pulumi.get(self, "expressions")

    @expressions.setter
    def expressions(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsArgs']]):
        pulumi.set(self, "expressions", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsArgsDict(TypedDict):
        conditions: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsArgsDict']]
        """
        Conditions to apply to the expression.
        Structure is documented below.
        """
        logical_operator: NotRequired[pulumi.Input[str]]
        """
        The operator to apply to the result of conditions. Default and currently only supported value is AND.
        Default value is `AND`.
        Possible values are: `AND`.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsArgs']] = None,
                 logical_operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsArgs'] conditions: Conditions to apply to the expression.
               Structure is documented below.
        :param pulumi.Input[str] logical_operator: The operator to apply to the result of conditions. Default and currently only supported value is AND.
               Default value is `AND`.
               Possible values are: `AND`.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if logical_operator is not None:
            pulumi.set(__self__, "logical_operator", logical_operator)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsArgs']]:
        """
        Conditions to apply to the expression.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsArgs']]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="logicalOperator")
    def logical_operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to apply to the result of conditions. Default and currently only supported value is AND.
        Default value is `AND`.
        Possible values are: `AND`.
        """
        return pulumi.get(self, "logical_operator")

    @logical_operator.setter
    def logical_operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logical_operator", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsArgsDict(TypedDict):
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionArgsDict']]]]
        """
        A collection of conditions.
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionArgs']]] conditions: A collection of conditions.
               Structure is documented below.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionArgs']]]]:
        """
        A collection of conditions.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionArgs']]]]):
        pulumi.set(self, "conditions", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionArgsDict(TypedDict):
        field: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionFieldArgsDict']
        """
        Field within the record this condition is evaluated against.
        Structure is documented below.
        """
        operator: pulumi.Input[str]
        """
        Operator used to compare the field or infoType to the value.
        Possible values are: `EQUAL_TO`, `NOT_EQUAL_TO`, `GREATER_THAN`, `LESS_THAN`, `GREATER_THAN_OR_EQUALS`, `LESS_THAN_OR_EQUALS`, `EXISTS`.
        """
        value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueArgsDict']]
        """
        Value to compare against. [Mandatory, except for EXISTS tests.]
        Structure is documented below.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionArgs:
    def __init__(__self__, *,
                 field: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionFieldArgs'],
                 operator: pulumi.Input[str],
                 value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueArgs']] = None):
        """
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionFieldArgs'] field: Field within the record this condition is evaluated against.
               Structure is documented below.
        :param pulumi.Input[str] operator: Operator used to compare the field or infoType to the value.
               Possible values are: `EQUAL_TO`, `NOT_EQUAL_TO`, `GREATER_THAN`, `LESS_THAN`, `GREATER_THAN_OR_EQUALS`, `LESS_THAN_OR_EQUALS`, `EXISTS`.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueArgs'] value: Value to compare against. [Mandatory, except for EXISTS tests.]
               Structure is documented below.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "operator", operator)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @property
    @pulumi.getter
    def field(self) -> pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionFieldArgs']:
        """
        Field within the record this condition is evaluated against.
        Structure is documented below.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionFieldArgs']):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def operator(self) -> pulumi.Input[str]:
        """
        Operator used to compare the field or infoType to the value.
        Possible values are: `EQUAL_TO`, `NOT_EQUAL_TO`, `GREATER_THAN`, `LESS_THAN`, `GREATER_THAN_OR_EQUALS`, `LESS_THAN_OR_EQUALS`, `EXISTS`.
        """
        return pulumi.get(self, "operator")

    @operator.setter
    def operator(self, value: pulumi.Input[str]):
        pulumi.set(self, "operator", value)

    @property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueArgs']]:
        """
        Value to compare against. [Mandatory, except for EXISTS tests.]
        Structure is documented below.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueArgs']]):
        pulumi.set(self, "value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionFieldArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[str]]
        """
        Name describing the field.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionFieldArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name describing the field.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[str]]:
        """
        Name describing the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueArgsDict(TypedDict):
        boolean_value: NotRequired[pulumi.Input[bool]]
        """
        A boolean value.
        """
        date_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueDateValueArgsDict']]
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        day_of_week_value: NotRequired[pulumi.Input[str]]
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        float_value: NotRequired[pulumi.Input[float]]
        """
        A float value.
        """
        integer_value: NotRequired[pulumi.Input[str]]
        """
        An integer value (int64 format)
        """
        string_value: NotRequired[pulumi.Input[str]]
        """
        A string value.
        """
        time_value: NotRequired[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueTimeValueArgsDict']]
        """
        Represents a time of day.
        Structure is documented below.
        """
        timestamp_value: NotRequired[pulumi.Input[str]]
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueArgs:
    def __init__(__self__, *,
                 boolean_value: Optional[pulumi.Input[bool]] = None,
                 date_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueDateValueArgs']] = None,
                 day_of_week_value: Optional[pulumi.Input[str]] = None,
                 float_value: Optional[pulumi.Input[float]] = None,
                 integer_value: Optional[pulumi.Input[str]] = None,
                 string_value: Optional[pulumi.Input[str]] = None,
                 time_value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueTimeValueArgs']] = None,
                 timestamp_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[bool] boolean_value: A boolean value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueDateValueArgs'] date_value: Represents a whole or partial calendar date.
               Structure is documented below.
        :param pulumi.Input[str] day_of_week_value: Represents a day of the week.
               Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        :param pulumi.Input[float] float_value: A float value.
        :param pulumi.Input[str] integer_value: An integer value (int64 format)
        :param pulumi.Input[str] string_value: A string value.
        :param pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueTimeValueArgs'] time_value: Represents a time of day.
               Structure is documented below.
        :param pulumi.Input[str] timestamp_value: A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        if boolean_value is not None:
            pulumi.set(__self__, "boolean_value", boolean_value)
        if date_value is not None:
            pulumi.set(__self__, "date_value", date_value)
        if day_of_week_value is not None:
            pulumi.set(__self__, "day_of_week_value", day_of_week_value)
        if float_value is not None:
            pulumi.set(__self__, "float_value", float_value)
        if integer_value is not None:
            pulumi.set(__self__, "integer_value", integer_value)
        if string_value is not None:
            pulumi.set(__self__, "string_value", string_value)
        if time_value is not None:
            pulumi.set(__self__, "time_value", time_value)
        if timestamp_value is not None:
            pulumi.set(__self__, "timestamp_value", timestamp_value)

    @property
    @pulumi.getter(name="booleanValue")
    def boolean_value(self) -> Optional[pulumi.Input[bool]]:
        """
        A boolean value.
        """
        return pulumi.get(self, "boolean_value")

    @boolean_value.setter
    def boolean_value(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "boolean_value", value)

    @property
    @pulumi.getter(name="dateValue")
    def date_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueDateValueArgs']]:
        """
        Represents a whole or partial calendar date.
        Structure is documented below.
        """
        return pulumi.get(self, "date_value")

    @date_value.setter
    def date_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueDateValueArgs']]):
        pulumi.set(self, "date_value", value)

    @property
    @pulumi.getter(name="dayOfWeekValue")
    def day_of_week_value(self) -> Optional[pulumi.Input[str]]:
        """
        Represents a day of the week.
        Possible values are: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "day_of_week_value")

    @day_of_week_value.setter
    def day_of_week_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "day_of_week_value", value)

    @property
    @pulumi.getter(name="floatValue")
    def float_value(self) -> Optional[pulumi.Input[float]]:
        """
        A float value.
        """
        return pulumi.get(self, "float_value")

    @float_value.setter
    def float_value(self, value: Optional[pulumi.Input[float]]):
        pulumi.set(self, "float_value", value)

    @property
    @pulumi.getter(name="integerValue")
    def integer_value(self) -> Optional[pulumi.Input[str]]:
        """
        An integer value (int64 format)
        """
        return pulumi.get(self, "integer_value")

    @integer_value.setter
    def integer_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "integer_value", value)

    @property
    @pulumi.getter(name="stringValue")
    def string_value(self) -> Optional[pulumi.Input[str]]:
        """
        A string value.
        """
        return pulumi.get(self, "string_value")

    @string_value.setter
    def string_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "string_value", value)

    @property
    @pulumi.getter(name="timeValue")
    def time_value(self) -> Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueTimeValueArgs']]:
        """
        Represents a time of day.
        Structure is documented below.
        """
        return pulumi.get(self, "time_value")

    @time_value.setter
    def time_value(self, value: Optional[pulumi.Input['PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueTimeValueArgs']]):
        pulumi.set(self, "time_value", value)

    @property
    @pulumi.getter(name="timestampValue")
    def timestamp_value(self) -> Optional[pulumi.Input[str]]:
        """
        A timestamp in RFC3339 UTC "Zulu" format, with nanosecond resolution and up to nine fractional digits. Examples: "2014-10-02T15:01:23Z" and "2014-10-02T15:01:23.045123456Z".
        """
        return pulumi.get(self, "timestamp_value")

    @timestamp_value.setter
    def timestamp_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp_value", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueDateValueArgsDict(TypedDict):
        day: NotRequired[pulumi.Input[int]]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        month: NotRequired[pulumi.Input[int]]
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        year: NotRequired[pulumi.Input[int]]
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueDateValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueDateValueArgs:
    def __init__(__self__, *,
                 day: Optional[pulumi.Input[int]] = None,
                 month: Optional[pulumi.Input[int]] = None,
                 year: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] day: Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.
               
               - - -
        :param pulumi.Input[int] month: Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        :param pulumi.Input[int] year: Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        if day is not None:
            pulumi.set(__self__, "day", day)
        if month is not None:
            pulumi.set(__self__, "month", month)
        if year is not None:
            pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> Optional[pulumi.Input[int]]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month, or 0 to specify a year by itself or a year and month where the day isn't significant.

        - - -
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> Optional[pulumi.Input[int]]:
        """
        Month of a year. Must be from 1 to 12, or 0 to specify a year without a month and day.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> Optional[pulumi.Input[int]]:
        """
        Year of the date. Must be from 1 to 9999, or 0 to specify a date without a year.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "year", value)


if not MYPY:
    class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueTimeValueArgsDict(TypedDict):
        hours: NotRequired[pulumi.Input[int]]
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        minutes: NotRequired[pulumi.Input[int]]
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        nanos: NotRequired[pulumi.Input[int]]
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        seconds: NotRequired[pulumi.Input[int]]
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
elif False:
    PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueTimeValueArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDeidentifyTemplateDeidentifyConfigRecordTransformationsRecordSuppressionConditionExpressionsConditionsConditionValueTimeValueArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Must be from 0 to 59.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Must be from 0 to 59.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Must be from 0 to 999,999,999.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Must normally be from 0 to 59. An API may allow the value 60 if it allows leap-seconds.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


if not MYPY:
    class PreventionDiscoveryConfigActionArgsDict(TypedDict):
        export_data: NotRequired[pulumi.Input['PreventionDiscoveryConfigActionExportDataArgsDict']]
        """
        Export data profiles into a provided location
        Structure is documented below.
        """
        pub_sub_notification: NotRequired[pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationArgsDict']]
        """
        Publish a message into the Pub/Sub topic.
        Structure is documented below.
        """
        tag_resources: NotRequired[pulumi.Input['PreventionDiscoveryConfigActionTagResourcesArgsDict']]
        """
        Publish a message into the Pub/Sub topic.
        Structure is documented below.
        """
elif False:
    PreventionDiscoveryConfigActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigActionArgs:
    def __init__(__self__, *,
                 export_data: Optional[pulumi.Input['PreventionDiscoveryConfigActionExportDataArgs']] = None,
                 pub_sub_notification: Optional[pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationArgs']] = None,
                 tag_resources: Optional[pulumi.Input['PreventionDiscoveryConfigActionTagResourcesArgs']] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigActionExportDataArgs'] export_data: Export data profiles into a provided location
               Structure is documented below.
        :param pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationArgs'] pub_sub_notification: Publish a message into the Pub/Sub topic.
               Structure is documented below.
        :param pulumi.Input['PreventionDiscoveryConfigActionTagResourcesArgs'] tag_resources: Publish a message into the Pub/Sub topic.
               Structure is documented below.
        """
        if export_data is not None:
            pulumi.set(__self__, "export_data", export_data)
        if pub_sub_notification is not None:
            pulumi.set(__self__, "pub_sub_notification", pub_sub_notification)
        if tag_resources is not None:
            pulumi.set(__self__, "tag_resources", tag_resources)

    @property
    @pulumi.getter(name="exportData")
    def export_data(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigActionExportDataArgs']]:
        """
        Export data profiles into a provided location
        Structure is documented below.
        """
        return pulumi.get(self, "export_data")

    @export_data.setter
    def export_data(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigActionExportDataArgs']]):
        pulumi.set(self, "export_data", value)

    @property
    @pulumi.getter(name="pubSubNotification")
    def pub_sub_notification(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationArgs']]:
        """
        Publish a message into the Pub/Sub topic.
        Structure is documented below.
        """
        return pulumi.get(self, "pub_sub_notification")

    @pub_sub_notification.setter
    def pub_sub_notification(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationArgs']]):
        pulumi.set(self, "pub_sub_notification", value)

    @property
    @pulumi.getter(name="tagResources")
    def tag_resources(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigActionTagResourcesArgs']]:
        """
        Publish a message into the Pub/Sub topic.
        Structure is documented below.
        """
        return pulumi.get(self, "tag_resources")

    @tag_resources.setter
    def tag_resources(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigActionTagResourcesArgs']]):
        pulumi.set(self, "tag_resources", value)


if not MYPY:
    class PreventionDiscoveryConfigActionExportDataArgsDict(TypedDict):
        profile_table: NotRequired[pulumi.Input['PreventionDiscoveryConfigActionExportDataProfileTableArgsDict']]
        """
        Store all table and column profiles in an existing table or a new table in an existing dataset. Each re-generation will result in a new row in BigQuery
        Structure is documented below.
        """
elif False:
    PreventionDiscoveryConfigActionExportDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigActionExportDataArgs:
    def __init__(__self__, *,
                 profile_table: Optional[pulumi.Input['PreventionDiscoveryConfigActionExportDataProfileTableArgs']] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigActionExportDataProfileTableArgs'] profile_table: Store all table and column profiles in an existing table or a new table in an existing dataset. Each re-generation will result in a new row in BigQuery
               Structure is documented below.
        """
        if profile_table is not None:
            pulumi.set(__self__, "profile_table", profile_table)

    @property
    @pulumi.getter(name="profileTable")
    def profile_table(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigActionExportDataProfileTableArgs']]:
        """
        Store all table and column profiles in an existing table or a new table in an existing dataset. Each re-generation will result in a new row in BigQuery
        Structure is documented below.
        """
        return pulumi.get(self, "profile_table")

    @profile_table.setter
    def profile_table(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigActionExportDataProfileTableArgs']]):
        pulumi.set(self, "profile_table", value)


if not MYPY:
    class PreventionDiscoveryConfigActionExportDataProfileTableArgsDict(TypedDict):
        dataset_id: NotRequired[pulumi.Input[str]]
        """
        Dataset Id of the table
        """
        project_id: NotRequired[pulumi.Input[str]]
        """
        The Google Cloud Platform project ID of the project containing the table. If omitted, the project ID is inferred from the API call.
        """
        table_id: NotRequired[pulumi.Input[str]]
        """
        Name of the table
        """
elif False:
    PreventionDiscoveryConfigActionExportDataProfileTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigActionExportDataProfileTableArgs:
    def __init__(__self__, *,
                 dataset_id: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None,
                 table_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dataset_id: Dataset Id of the table
        :param pulumi.Input[str] project_id: The Google Cloud Platform project ID of the project containing the table. If omitted, the project ID is inferred from the API call.
        :param pulumi.Input[str] table_id: Name of the table
        """
        if dataset_id is not None:
            pulumi.set(__self__, "dataset_id", dataset_id)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if table_id is not None:
            pulumi.set(__self__, "table_id", table_id)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> Optional[pulumi.Input[str]]:
        """
        Dataset Id of the table
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        The Google Cloud Platform project ID of the project containing the table. If omitted, the project ID is inferred from the API call.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="tableId")
    def table_id(self) -> Optional[pulumi.Input[str]]:
        """
        Name of the table
        """
        return pulumi.get(self, "table_id")

    @table_id.setter
    def table_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "table_id", value)


if not MYPY:
    class PreventionDiscoveryConfigActionPubSubNotificationArgsDict(TypedDict):
        detail_of_message: NotRequired[pulumi.Input[str]]
        """
        How much data to include in the pub/sub message.
        Possible values are: `TABLE_PROFILE`, `RESOURCE_NAME`.
        """
        event: NotRequired[pulumi.Input[str]]
        """
        The type of event that triggers a Pub/Sub. At most one PubSubNotification per EventType is permitted.
        Possible values are: `NEW_PROFILE`, `CHANGED_PROFILE`, `SCORE_INCREASED`, `ERROR_CHANGED`.
        """
        pubsub_condition: NotRequired[pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionArgsDict']]
        """
        Conditions for triggering pubsub
        Structure is documented below.
        """
        topic: NotRequired[pulumi.Input[str]]
        """
        Cloud Pub/Sub topic to send notifications to. Format is projects/{project}/topics/{topic}.
        """
elif False:
    PreventionDiscoveryConfigActionPubSubNotificationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigActionPubSubNotificationArgs:
    def __init__(__self__, *,
                 detail_of_message: Optional[pulumi.Input[str]] = None,
                 event: Optional[pulumi.Input[str]] = None,
                 pubsub_condition: Optional[pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionArgs']] = None,
                 topic: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] detail_of_message: How much data to include in the pub/sub message.
               Possible values are: `TABLE_PROFILE`, `RESOURCE_NAME`.
        :param pulumi.Input[str] event: The type of event that triggers a Pub/Sub. At most one PubSubNotification per EventType is permitted.
               Possible values are: `NEW_PROFILE`, `CHANGED_PROFILE`, `SCORE_INCREASED`, `ERROR_CHANGED`.
        :param pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionArgs'] pubsub_condition: Conditions for triggering pubsub
               Structure is documented below.
        :param pulumi.Input[str] topic: Cloud Pub/Sub topic to send notifications to. Format is projects/{project}/topics/{topic}.
        """
        if detail_of_message is not None:
            pulumi.set(__self__, "detail_of_message", detail_of_message)
        if event is not None:
            pulumi.set(__self__, "event", event)
        if pubsub_condition is not None:
            pulumi.set(__self__, "pubsub_condition", pubsub_condition)
        if topic is not None:
            pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter(name="detailOfMessage")
    def detail_of_message(self) -> Optional[pulumi.Input[str]]:
        """
        How much data to include in the pub/sub message.
        Possible values are: `TABLE_PROFILE`, `RESOURCE_NAME`.
        """
        return pulumi.get(self, "detail_of_message")

    @detail_of_message.setter
    def detail_of_message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "detail_of_message", value)

    @property
    @pulumi.getter
    def event(self) -> Optional[pulumi.Input[str]]:
        """
        The type of event that triggers a Pub/Sub. At most one PubSubNotification per EventType is permitted.
        Possible values are: `NEW_PROFILE`, `CHANGED_PROFILE`, `SCORE_INCREASED`, `ERROR_CHANGED`.
        """
        return pulumi.get(self, "event")

    @event.setter
    def event(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "event", value)

    @property
    @pulumi.getter(name="pubsubCondition")
    def pubsub_condition(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionArgs']]:
        """
        Conditions for triggering pubsub
        Structure is documented below.
        """
        return pulumi.get(self, "pubsub_condition")

    @pubsub_condition.setter
    def pubsub_condition(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionArgs']]):
        pulumi.set(self, "pubsub_condition", value)

    @property
    @pulumi.getter
    def topic(self) -> Optional[pulumi.Input[str]]:
        """
        Cloud Pub/Sub topic to send notifications to. Format is projects/{project}/topics/{topic}.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "topic", value)


if not MYPY:
    class PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionArgsDict(TypedDict):
        expressions: NotRequired[pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsArgsDict']]
        """
        An expression
        Structure is documented below.
        """
elif False:
    PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionArgs:
    def __init__(__self__, *,
                 expressions: Optional[pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsArgs']] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsArgs'] expressions: An expression
               Structure is documented below.
        """
        if expressions is not None:
            pulumi.set(__self__, "expressions", expressions)

    @property
    @pulumi.getter
    def expressions(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsArgs']]:
        """
        An expression
        Structure is documented below.
        """
        return pulumi.get(self, "expressions")

    @expressions.setter
    def expressions(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsArgs']]):
        pulumi.set(self, "expressions", value)


if not MYPY:
    class PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsArgsDict(TypedDict):
        conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsConditionArgsDict']]]]
        """
        Conditions to apply to the expression
        Structure is documented below.
        """
        logical_operator: NotRequired[pulumi.Input[str]]
        """
        The operator to apply to the collection of conditions
        Possible values are: `OR`, `AND`.
        """
elif False:
    PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsArgs:
    def __init__(__self__, *,
                 conditions: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsConditionArgs']]]] = None,
                 logical_operator: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsConditionArgs']]] conditions: Conditions to apply to the expression
               Structure is documented below.
        :param pulumi.Input[str] logical_operator: The operator to apply to the collection of conditions
               Possible values are: `OR`, `AND`.
        """
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if logical_operator is not None:
            pulumi.set(__self__, "logical_operator", logical_operator)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsConditionArgs']]]]:
        """
        Conditions to apply to the expression
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsConditionArgs']]]]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter(name="logicalOperator")
    def logical_operator(self) -> Optional[pulumi.Input[str]]:
        """
        The operator to apply to the collection of conditions
        Possible values are: `OR`, `AND`.
        """
        return pulumi.get(self, "logical_operator")

    @logical_operator.setter
    def logical_operator(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "logical_operator", value)


if not MYPY:
    class PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsConditionArgsDict(TypedDict):
        minimum_risk_score: NotRequired[pulumi.Input[str]]
        """
        The minimum data risk score that triggers the condition.
        Possible values are: `HIGH`, `MEDIUM_OR_HIGH`.
        """
        minimum_sensitivity_score: NotRequired[pulumi.Input[str]]
        """
        The minimum sensitivity level that triggers the condition.
        Possible values are: `HIGH`, `MEDIUM_OR_HIGH`.
        """
elif False:
    PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigActionPubSubNotificationPubsubConditionExpressionsConditionArgs:
    def __init__(__self__, *,
                 minimum_risk_score: Optional[pulumi.Input[str]] = None,
                 minimum_sensitivity_score: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] minimum_risk_score: The minimum data risk score that triggers the condition.
               Possible values are: `HIGH`, `MEDIUM_OR_HIGH`.
        :param pulumi.Input[str] minimum_sensitivity_score: The minimum sensitivity level that triggers the condition.
               Possible values are: `HIGH`, `MEDIUM_OR_HIGH`.
        """
        if minimum_risk_score is not None:
            pulumi.set(__self__, "minimum_risk_score", minimum_risk_score)
        if minimum_sensitivity_score is not None:
            pulumi.set(__self__, "minimum_sensitivity_score", minimum_sensitivity_score)

    @property
    @pulumi.getter(name="minimumRiskScore")
    def minimum_risk_score(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum data risk score that triggers the condition.
        Possible values are: `HIGH`, `MEDIUM_OR_HIGH`.
        """
        return pulumi.get(self, "minimum_risk_score")

    @minimum_risk_score.setter
    def minimum_risk_score(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_risk_score", value)

    @property
    @pulumi.getter(name="minimumSensitivityScore")
    def minimum_sensitivity_score(self) -> Optional[pulumi.Input[str]]:
        """
        The minimum sensitivity level that triggers the condition.
        Possible values are: `HIGH`, `MEDIUM_OR_HIGH`.
        """
        return pulumi.get(self, "minimum_sensitivity_score")

    @minimum_sensitivity_score.setter
    def minimum_sensitivity_score(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "minimum_sensitivity_score", value)


if not MYPY:
    class PreventionDiscoveryConfigActionTagResourcesArgsDict(TypedDict):
        lower_data_risk_to_low: NotRequired[pulumi.Input[bool]]
        """
        Whether applying a tag to a resource should lower the risk of the profile for that resource. For example, in conjunction with an [IAM deny policy](https://cloud.google.com/iam/docs/deny-overview), you can deny all principals a permission if a tag value is present, mitigating the risk of the resource. This also lowers the data risk of resources at the lower levels of the resource hierarchy. For example, reducing the data risk of a table data profile also reduces the data risk of the constituent column data profiles.
        """
        profile_generations_to_tags: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The profile generations for which the tag should be attached to resources. If you attach a tag to only new profiles, then if the sensitivity score of a profile subsequently changes, its tag doesn't change. By default, this field includes only new profiles. To include both new and updated profiles for tagging, this field should explicitly include both `PROFILE_GENERATION_NEW` and `PROFILE_GENERATION_UPDATE`.
        Each value may be one of: `PROFILE_GENERATION_NEW`, `PROFILE_GENERATION_UPDATE`.
        """
        tag_conditions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigActionTagResourcesTagConditionArgsDict']]]]
        """
        The tags to associate with different conditions.
        Structure is documented below.
        """
elif False:
    PreventionDiscoveryConfigActionTagResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigActionTagResourcesArgs:
    def __init__(__self__, *,
                 lower_data_risk_to_low: Optional[pulumi.Input[bool]] = None,
                 profile_generations_to_tags: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 tag_conditions: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigActionTagResourcesTagConditionArgs']]]] = None):
        """
        :param pulumi.Input[bool] lower_data_risk_to_low: Whether applying a tag to a resource should lower the risk of the profile for that resource. For example, in conjunction with an [IAM deny policy](https://cloud.google.com/iam/docs/deny-overview), you can deny all principals a permission if a tag value is present, mitigating the risk of the resource. This also lowers the data risk of resources at the lower levels of the resource hierarchy. For example, reducing the data risk of a table data profile also reduces the data risk of the constituent column data profiles.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] profile_generations_to_tags: The profile generations for which the tag should be attached to resources. If you attach a tag to only new profiles, then if the sensitivity score of a profile subsequently changes, its tag doesn't change. By default, this field includes only new profiles. To include both new and updated profiles for tagging, this field should explicitly include both `PROFILE_GENERATION_NEW` and `PROFILE_GENERATION_UPDATE`.
               Each value may be one of: `PROFILE_GENERATION_NEW`, `PROFILE_GENERATION_UPDATE`.
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigActionTagResourcesTagConditionArgs']]] tag_conditions: The tags to associate with different conditions.
               Structure is documented below.
        """
        if lower_data_risk_to_low is not None:
            pulumi.set(__self__, "lower_data_risk_to_low", lower_data_risk_to_low)
        if profile_generations_to_tags is not None:
            pulumi.set(__self__, "profile_generations_to_tags", profile_generations_to_tags)
        if tag_conditions is not None:
            pulumi.set(__self__, "tag_conditions", tag_conditions)

    @property
    @pulumi.getter(name="lowerDataRiskToLow")
    def lower_data_risk_to_low(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether applying a tag to a resource should lower the risk of the profile for that resource. For example, in conjunction with an [IAM deny policy](https://cloud.google.com/iam/docs/deny-overview), you can deny all principals a permission if a tag value is present, mitigating the risk of the resource. This also lowers the data risk of resources at the lower levels of the resource hierarchy. For example, reducing the data risk of a table data profile also reduces the data risk of the constituent column data profiles.
        """
        return pulumi.get(self, "lower_data_risk_to_low")

    @lower_data_risk_to_low.setter
    def lower_data_risk_to_low(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "lower_data_risk_to_low", value)

    @property
    @pulumi.getter(name="profileGenerationsToTags")
    def profile_generations_to_tags(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The profile generations for which the tag should be attached to resources. If you attach a tag to only new profiles, then if the sensitivity score of a profile subsequently changes, its tag doesn't change. By default, this field includes only new profiles. To include both new and updated profiles for tagging, this field should explicitly include both `PROFILE_GENERATION_NEW` and `PROFILE_GENERATION_UPDATE`.
        Each value may be one of: `PROFILE_GENERATION_NEW`, `PROFILE_GENERATION_UPDATE`.
        """
        return pulumi.get(self, "profile_generations_to_tags")

    @profile_generations_to_tags.setter
    def profile_generations_to_tags(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "profile_generations_to_tags", value)

    @property
    @pulumi.getter(name="tagConditions")
    def tag_conditions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigActionTagResourcesTagConditionArgs']]]]:
        """
        The tags to associate with different conditions.
        Structure is documented below.
        """
        return pulumi.get(self, "tag_conditions")

    @tag_conditions.setter
    def tag_conditions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigActionTagResourcesTagConditionArgs']]]]):
        pulumi.set(self, "tag_conditions", value)


if not MYPY:
    class PreventionDiscoveryConfigActionTagResourcesTagConditionArgsDict(TypedDict):
        sensitivity_score: NotRequired[pulumi.Input['PreventionDiscoveryConfigActionTagResourcesTagConditionSensitivityScoreArgsDict']]
        """
        Conditions attaching the tag to a resource on its profile having this sensitivity score.
        Structure is documented below.
        """
        tag: NotRequired[pulumi.Input['PreventionDiscoveryConfigActionTagResourcesTagConditionTagArgsDict']]
        """
        The tag value to attach to resources.
        Structure is documented below.
        """
elif False:
    PreventionDiscoveryConfigActionTagResourcesTagConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigActionTagResourcesTagConditionArgs:
    def __init__(__self__, *,
                 sensitivity_score: Optional[pulumi.Input['PreventionDiscoveryConfigActionTagResourcesTagConditionSensitivityScoreArgs']] = None,
                 tag: Optional[pulumi.Input['PreventionDiscoveryConfigActionTagResourcesTagConditionTagArgs']] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigActionTagResourcesTagConditionSensitivityScoreArgs'] sensitivity_score: Conditions attaching the tag to a resource on its profile having this sensitivity score.
               Structure is documented below.
        :param pulumi.Input['PreventionDiscoveryConfigActionTagResourcesTagConditionTagArgs'] tag: The tag value to attach to resources.
               Structure is documented below.
        """
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if tag is not None:
            pulumi.set(__self__, "tag", tag)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigActionTagResourcesTagConditionSensitivityScoreArgs']]:
        """
        Conditions attaching the tag to a resource on its profile having this sensitivity score.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigActionTagResourcesTagConditionSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def tag(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigActionTagResourcesTagConditionTagArgs']]:
        """
        The tag value to attach to resources.
        Structure is documented below.
        """
        return pulumi.get(self, "tag")

    @tag.setter
    def tag(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigActionTagResourcesTagConditionTagArgs']]):
        pulumi.set(self, "tag", value)


if not MYPY:
    class PreventionDiscoveryConfigActionTagResourcesTagConditionSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionDiscoveryConfigActionTagResourcesTagConditionSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigActionTagResourcesTagConditionSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionDiscoveryConfigActionTagResourcesTagConditionTagArgsDict(TypedDict):
        namespaced_value: NotRequired[pulumi.Input[str]]
        """
        The namespaced name for the tag value to attach to resources. Must be in the format `{parent_id}/{tag_key_short_name}/{short_name}`, for example, "123456/environment/prod".
        """
elif False:
    PreventionDiscoveryConfigActionTagResourcesTagConditionTagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigActionTagResourcesTagConditionTagArgs:
    def __init__(__self__, *,
                 namespaced_value: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] namespaced_value: The namespaced name for the tag value to attach to resources. Must be in the format `{parent_id}/{tag_key_short_name}/{short_name}`, for example, "123456/environment/prod".
        """
        if namespaced_value is not None:
            pulumi.set(__self__, "namespaced_value", namespaced_value)

    @property
    @pulumi.getter(name="namespacedValue")
    def namespaced_value(self) -> Optional[pulumi.Input[str]]:
        """
        The namespaced name for the tag value to attach to resources. Must be in the format `{parent_id}/{tag_key_short_name}/{short_name}`, for example, "123456/environment/prod".
        """
        return pulumi.get(self, "namespaced_value")

    @namespaced_value.setter
    def namespaced_value(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespaced_value", value)


if not MYPY:
    class PreventionDiscoveryConfigErrorArgsDict(TypedDict):
        details: NotRequired[pulumi.Input['PreventionDiscoveryConfigErrorDetailsArgsDict']]
        """
        A list of messages that carry the error details.
        """
        timestamp: NotRequired[pulumi.Input[str]]
        """
        The times the error occurred. List includes the oldest timestamp and the last 9 timestamps.
        """
elif False:
    PreventionDiscoveryConfigErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigErrorArgs:
    def __init__(__self__, *,
                 details: Optional[pulumi.Input['PreventionDiscoveryConfigErrorDetailsArgs']] = None,
                 timestamp: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigErrorDetailsArgs'] details: A list of messages that carry the error details.
        :param pulumi.Input[str] timestamp: The times the error occurred. List includes the oldest timestamp and the last 9 timestamps.
        """
        if details is not None:
            pulumi.set(__self__, "details", details)
        if timestamp is not None:
            pulumi.set(__self__, "timestamp", timestamp)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigErrorDetailsArgs']]:
        """
        A list of messages that carry the error details.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigErrorDetailsArgs']]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter
    def timestamp(self) -> Optional[pulumi.Input[str]]:
        """
        The times the error occurred. List includes the oldest timestamp and the last 9 timestamps.
        """
        return pulumi.get(self, "timestamp")

    @timestamp.setter
    def timestamp(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "timestamp", value)


if not MYPY:
    class PreventionDiscoveryConfigErrorDetailsArgsDict(TypedDict):
        code: NotRequired[pulumi.Input[int]]
        """
        The status code, which should be an enum value of google.rpc.Code.
        """
        details: NotRequired[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]]
        """
        A list of messages that carry the error details.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        """
elif False:
    PreventionDiscoveryConfigErrorDetailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigErrorDetailsArgs:
    def __init__(__self__, *,
                 code: Optional[pulumi.Input[int]] = None,
                 details: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]] = None,
                 message: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[int] code: The status code, which should be an enum value of google.rpc.Code.
        :param pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]] details: A list of messages that carry the error details.
        :param pulumi.Input[str] message: A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        """
        if code is not None:
            pulumi.set(__self__, "code", code)
        if details is not None:
            pulumi.set(__self__, "details", details)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def code(self) -> Optional[pulumi.Input[int]]:
        """
        The status code, which should be an enum value of google.rpc.Code.
        """
        return pulumi.get(self, "code")

    @code.setter
    def code(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "code", value)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]]:
        """
        A list of messages that carry the error details.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[Mapping[str, pulumi.Input[str]]]]]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the google.rpc.Status.details field, or localized by the client.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class PreventionDiscoveryConfigOrgConfigArgsDict(TypedDict):
        location: NotRequired[pulumi.Input['PreventionDiscoveryConfigOrgConfigLocationArgsDict']]
        """
        The data to scan folder org or project
        Structure is documented below.
        """
        project_id: NotRequired[pulumi.Input[str]]
        """
        The project that will run the scan. The DLP service account that exists within this project must have access to all resources that are profiled, and the cloud DLP API must be enabled.
        """
elif False:
    PreventionDiscoveryConfigOrgConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigOrgConfigArgs:
    def __init__(__self__, *,
                 location: Optional[pulumi.Input['PreventionDiscoveryConfigOrgConfigLocationArgs']] = None,
                 project_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigOrgConfigLocationArgs'] location: The data to scan folder org or project
               Structure is documented below.
        :param pulumi.Input[str] project_id: The project that will run the scan. The DLP service account that exists within this project must have access to all resources that are profiled, and the cloud DLP API must be enabled.
        """
        if location is not None:
            pulumi.set(__self__, "location", location)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigOrgConfigLocationArgs']]:
        """
        The data to scan folder org or project
        Structure is documented below.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigOrgConfigLocationArgs']]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        The project that will run the scan. The DLP service account that exists within this project must have access to all resources that are profiled, and the cloud DLP API must be enabled.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class PreventionDiscoveryConfigOrgConfigLocationArgsDict(TypedDict):
        folder_id: NotRequired[pulumi.Input[str]]
        """
        The ID for the folder within an organization to scan
        """
        organization_id: NotRequired[pulumi.Input[str]]
        """
        The ID of an organization to scan
        """
elif False:
    PreventionDiscoveryConfigOrgConfigLocationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigOrgConfigLocationArgs:
    def __init__(__self__, *,
                 folder_id: Optional[pulumi.Input[str]] = None,
                 organization_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] folder_id: The ID for the folder within an organization to scan
        :param pulumi.Input[str] organization_id: The ID of an organization to scan
        """
        if folder_id is not None:
            pulumi.set(__self__, "folder_id", folder_id)
        if organization_id is not None:
            pulumi.set(__self__, "organization_id", organization_id)

    @property
    @pulumi.getter(name="folderId")
    def folder_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID for the folder within an organization to scan
        """
        return pulumi.get(self, "folder_id")

    @folder_id.setter
    def folder_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "folder_id", value)

    @property
    @pulumi.getter(name="organizationId")
    def organization_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of an organization to scan
        """
        return pulumi.get(self, "organization_id")

    @organization_id.setter
    def organization_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "organization_id", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetArgsDict(TypedDict):
        big_query_target: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetArgsDict']]
        """
        BigQuery target for Discovery. The first target to match a table will be the one applied.
        Structure is documented below.
        """
        cloud_sql_target: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetArgsDict']]
        """
        Cloud SQL target for Discovery. The first target to match a table will be the one applied.
        Structure is documented below.
        """
        cloud_storage_target: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetArgsDict']]
        """
        Cloud Storage target for Discovery. The first target to match a bucket will be the one applied.
        Structure is documented below.
        """
        secrets_target: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetSecretsTargetArgsDict']]
        """
        Discovery target that looks for credentials and secrets stored in cloud resource metadata and reports them as vulnerabilities to Security Command Center. Only one target of this type is allowed.
        """
elif False:
    PreventionDiscoveryConfigTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetArgs:
    def __init__(__self__, *,
                 big_query_target: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetArgs']] = None,
                 cloud_sql_target: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetArgs']] = None,
                 cloud_storage_target: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetArgs']] = None,
                 secrets_target: Optional[pulumi.Input['PreventionDiscoveryConfigTargetSecretsTargetArgs']] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetArgs'] big_query_target: BigQuery target for Discovery. The first target to match a table will be the one applied.
               Structure is documented below.
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetArgs'] cloud_sql_target: Cloud SQL target for Discovery. The first target to match a table will be the one applied.
               Structure is documented below.
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetArgs'] cloud_storage_target: Cloud Storage target for Discovery. The first target to match a bucket will be the one applied.
               Structure is documented below.
        :param pulumi.Input['PreventionDiscoveryConfigTargetSecretsTargetArgs'] secrets_target: Discovery target that looks for credentials and secrets stored in cloud resource metadata and reports them as vulnerabilities to Security Command Center. Only one target of this type is allowed.
        """
        if big_query_target is not None:
            pulumi.set(__self__, "big_query_target", big_query_target)
        if cloud_sql_target is not None:
            pulumi.set(__self__, "cloud_sql_target", cloud_sql_target)
        if cloud_storage_target is not None:
            pulumi.set(__self__, "cloud_storage_target", cloud_storage_target)
        if secrets_target is not None:
            pulumi.set(__self__, "secrets_target", secrets_target)

    @property
    @pulumi.getter(name="bigQueryTarget")
    def big_query_target(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetArgs']]:
        """
        BigQuery target for Discovery. The first target to match a table will be the one applied.
        Structure is documented below.
        """
        return pulumi.get(self, "big_query_target")

    @big_query_target.setter
    def big_query_target(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetArgs']]):
        pulumi.set(self, "big_query_target", value)

    @property
    @pulumi.getter(name="cloudSqlTarget")
    def cloud_sql_target(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetArgs']]:
        """
        Cloud SQL target for Discovery. The first target to match a table will be the one applied.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_sql_target")

    @cloud_sql_target.setter
    def cloud_sql_target(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetArgs']]):
        pulumi.set(self, "cloud_sql_target", value)

    @property
    @pulumi.getter(name="cloudStorageTarget")
    def cloud_storage_target(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetArgs']]:
        """
        Cloud Storage target for Discovery. The first target to match a bucket will be the one applied.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_storage_target")

    @cloud_storage_target.setter
    def cloud_storage_target(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetArgs']]):
        pulumi.set(self, "cloud_storage_target", value)

    @property
    @pulumi.getter(name="secretsTarget")
    def secrets_target(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetSecretsTargetArgs']]:
        """
        Discovery target that looks for credentials and secrets stored in cloud resource metadata and reports them as vulnerabilities to Security Command Center. Only one target of this type is allowed.
        """
        return pulumi.get(self, "secrets_target")

    @secrets_target.setter
    def secrets_target(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetSecretsTargetArgs']]):
        pulumi.set(self, "secrets_target", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetBigQueryTargetArgsDict(TypedDict):
        cadence: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceArgsDict']]
        """
        How often and when to update profiles. New tables that match both the fiter and conditions are scanned as quickly as possible depending on system capacity.
        Structure is documented below.
        """
        conditions: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetConditionsArgsDict']]
        """
        In addition to matching the filter, these conditions must be true before a profile is generated
        Structure is documented below.
        """
        disabled: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetDisabledArgsDict']]
        """
        Tables that match this filter will not have profiles created.
        """
        filter: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterArgsDict']]
        """
        Required. The tables the discovery cadence applies to. The first target with a matching filter will be the one to apply to a table
        Structure is documented below.
        """
elif False:
    PreventionDiscoveryConfigTargetBigQueryTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetBigQueryTargetArgs:
    def __init__(__self__, *,
                 cadence: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceArgs']] = None,
                 conditions: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetConditionsArgs']] = None,
                 disabled: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetDisabledArgs']] = None,
                 filter: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterArgs']] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceArgs'] cadence: How often and when to update profiles. New tables that match both the fiter and conditions are scanned as quickly as possible depending on system capacity.
               Structure is documented below.
        :param pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetConditionsArgs'] conditions: In addition to matching the filter, these conditions must be true before a profile is generated
               Structure is documented below.
        :param pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetDisabledArgs'] disabled: Tables that match this filter will not have profiles created.
        :param pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterArgs'] filter: Required. The tables the discovery cadence applies to. The first target with a matching filter will be the one to apply to a table
               Structure is documented below.
        """
        if cadence is not None:
            pulumi.set(__self__, "cadence", cadence)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)

    @property
    @pulumi.getter
    def cadence(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceArgs']]:
        """
        How often and when to update profiles. New tables that match both the fiter and conditions are scanned as quickly as possible depending on system capacity.
        Structure is documented below.
        """
        return pulumi.get(self, "cadence")

    @cadence.setter
    def cadence(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceArgs']]):
        pulumi.set(self, "cadence", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetConditionsArgs']]:
        """
        In addition to matching the filter, these conditions must be true before a profile is generated
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetConditionsArgs']]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetDisabledArgs']]:
        """
        Tables that match this filter will not have profiles created.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetDisabledArgs']]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterArgs']]:
        """
        Required. The tables the discovery cadence applies to. The first target with a matching filter will be the one to apply to a table
        Structure is documented below.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterArgs']]):
        pulumi.set(self, "filter", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetBigQueryTargetCadenceArgsDict(TypedDict):
        inspect_template_modified_cadence: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceInspectTemplateModifiedCadenceArgsDict']]
        """
        Governs when to update data profiles when the inspection rules defined by the `InspectTemplate` change. If not set, changing the template will not cause a data profile to update.
        Structure is documented below.
        """
        schema_modified_cadence: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceSchemaModifiedCadenceArgsDict']]
        """
        Governs when to update data profiles when a schema is modified
        Structure is documented below.
        """
        table_modified_cadence: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceTableModifiedCadenceArgsDict']]
        """
        Governs when to update profile when a table is modified.
        Structure is documented below.
        """
elif False:
    PreventionDiscoveryConfigTargetBigQueryTargetCadenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetBigQueryTargetCadenceArgs:
    def __init__(__self__, *,
                 inspect_template_modified_cadence: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceInspectTemplateModifiedCadenceArgs']] = None,
                 schema_modified_cadence: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceSchemaModifiedCadenceArgs']] = None,
                 table_modified_cadence: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceTableModifiedCadenceArgs']] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceInspectTemplateModifiedCadenceArgs'] inspect_template_modified_cadence: Governs when to update data profiles when the inspection rules defined by the `InspectTemplate` change. If not set, changing the template will not cause a data profile to update.
               Structure is documented below.
        :param pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceSchemaModifiedCadenceArgs'] schema_modified_cadence: Governs when to update data profiles when a schema is modified
               Structure is documented below.
        :param pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceTableModifiedCadenceArgs'] table_modified_cadence: Governs when to update profile when a table is modified.
               Structure is documented below.
        """
        if inspect_template_modified_cadence is not None:
            pulumi.set(__self__, "inspect_template_modified_cadence", inspect_template_modified_cadence)
        if schema_modified_cadence is not None:
            pulumi.set(__self__, "schema_modified_cadence", schema_modified_cadence)
        if table_modified_cadence is not None:
            pulumi.set(__self__, "table_modified_cadence", table_modified_cadence)

    @property
    @pulumi.getter(name="inspectTemplateModifiedCadence")
    def inspect_template_modified_cadence(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceInspectTemplateModifiedCadenceArgs']]:
        """
        Governs when to update data profiles when the inspection rules defined by the `InspectTemplate` change. If not set, changing the template will not cause a data profile to update.
        Structure is documented below.
        """
        return pulumi.get(self, "inspect_template_modified_cadence")

    @inspect_template_modified_cadence.setter
    def inspect_template_modified_cadence(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceInspectTemplateModifiedCadenceArgs']]):
        pulumi.set(self, "inspect_template_modified_cadence", value)

    @property
    @pulumi.getter(name="schemaModifiedCadence")
    def schema_modified_cadence(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceSchemaModifiedCadenceArgs']]:
        """
        Governs when to update data profiles when a schema is modified
        Structure is documented below.
        """
        return pulumi.get(self, "schema_modified_cadence")

    @schema_modified_cadence.setter
    def schema_modified_cadence(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceSchemaModifiedCadenceArgs']]):
        pulumi.set(self, "schema_modified_cadence", value)

    @property
    @pulumi.getter(name="tableModifiedCadence")
    def table_modified_cadence(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceTableModifiedCadenceArgs']]:
        """
        Governs when to update profile when a table is modified.
        Structure is documented below.
        """
        return pulumi.get(self, "table_modified_cadence")

    @table_modified_cadence.setter
    def table_modified_cadence(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetCadenceTableModifiedCadenceArgs']]):
        pulumi.set(self, "table_modified_cadence", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetBigQueryTargetCadenceInspectTemplateModifiedCadenceArgsDict(TypedDict):
        frequency: NotRequired[pulumi.Input[str]]
        """
        How frequently data profiles can be updated when the template is modified. Defaults to never.
        Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
elif False:
    PreventionDiscoveryConfigTargetBigQueryTargetCadenceInspectTemplateModifiedCadenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetBigQueryTargetCadenceInspectTemplateModifiedCadenceArgs:
    def __init__(__self__, *,
                 frequency: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] frequency: How frequently data profiles can be updated when the template is modified. Defaults to never.
               Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)

    @property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input[str]]:
        """
        How frequently data profiles can be updated when the template is modified. Defaults to never.
        Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetBigQueryTargetCadenceSchemaModifiedCadenceArgsDict(TypedDict):
        frequency: NotRequired[pulumi.Input[str]]
        """
        Frequency to regenerate data profiles when the schema is modified. Defaults to monthly.
        Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
        types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The types of schema modifications to consider. Defaults to NEW_COLUMNS.
        Each value may be one of: `NEW_COLUMNS`, `REMOVED_COLUMNS`.
        """
elif False:
    PreventionDiscoveryConfigTargetBigQueryTargetCadenceSchemaModifiedCadenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetBigQueryTargetCadenceSchemaModifiedCadenceArgs:
    def __init__(__self__, *,
                 frequency: Optional[pulumi.Input[str]] = None,
                 types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] frequency: Frequency to regenerate data profiles when the schema is modified. Defaults to monthly.
               Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] types: The types of schema modifications to consider. Defaults to NEW_COLUMNS.
               Each value may be one of: `NEW_COLUMNS`, `REMOVED_COLUMNS`.
        """
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input[str]]:
        """
        Frequency to regenerate data profiles when the schema is modified. Defaults to monthly.
        Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The types of schema modifications to consider. Defaults to NEW_COLUMNS.
        Each value may be one of: `NEW_COLUMNS`, `REMOVED_COLUMNS`.
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "types", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetBigQueryTargetCadenceTableModifiedCadenceArgsDict(TypedDict):
        frequency: NotRequired[pulumi.Input[str]]
        """
        How frequently data profiles can be updated when tables are modified. Defaults to never.
        Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
        types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The type of events to consider when deciding if the table has been modified and should have the profile updated. Defaults to MODIFIED_TIMESTAMP
        Each value may be one of: `TABLE_MODIFIED_TIMESTAMP`.
        """
elif False:
    PreventionDiscoveryConfigTargetBigQueryTargetCadenceTableModifiedCadenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetBigQueryTargetCadenceTableModifiedCadenceArgs:
    def __init__(__self__, *,
                 frequency: Optional[pulumi.Input[str]] = None,
                 types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] frequency: How frequently data profiles can be updated when tables are modified. Defaults to never.
               Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] types: The type of events to consider when deciding if the table has been modified and should have the profile updated. Defaults to MODIFIED_TIMESTAMP
               Each value may be one of: `TABLE_MODIFIED_TIMESTAMP`.
        """
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input[str]]:
        """
        How frequently data profiles can be updated when tables are modified. Defaults to never.
        Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The type of events to consider when deciding if the table has been modified and should have the profile updated. Defaults to MODIFIED_TIMESTAMP
        Each value may be one of: `TABLE_MODIFIED_TIMESTAMP`.
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "types", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetBigQueryTargetConditionsArgsDict(TypedDict):
        created_after: NotRequired[pulumi.Input[str]]
        """
        File store must have been created after this date. Used to avoid backfilling. A timestamp in RFC3339 UTC "Zulu" format with nanosecond resolution and upto nine fractional digits.
        """
        or_conditions: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetConditionsOrConditionsArgsDict']]
        """
        At least one of the conditions must be true for a table to be scanned.
        Structure is documented below.
        """
        type_collection: NotRequired[pulumi.Input[str]]
        """
        Restrict discovery to categories of table types. Currently view, materialized view, snapshot and non-biglake external tables are supported.
        Possible values are: `BIG_QUERY_COLLECTION_ALL_TYPES`, `BIG_QUERY_COLLECTION_ONLY_SUPPORTED_TYPES`.
        """
        types: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetConditionsTypesArgsDict']]
        """
        Data profiles will only be generated for the database resource types specified in this field. If not specified, defaults to [DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES].
        Each value may be one of: `DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES`, `DATABASE_RESOURCE_TYPE_TABLE`.
        """
elif False:
    PreventionDiscoveryConfigTargetBigQueryTargetConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetBigQueryTargetConditionsArgs:
    def __init__(__self__, *,
                 created_after: Optional[pulumi.Input[str]] = None,
                 or_conditions: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetConditionsOrConditionsArgs']] = None,
                 type_collection: Optional[pulumi.Input[str]] = None,
                 types: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetConditionsTypesArgs']] = None):
        """
        :param pulumi.Input[str] created_after: File store must have been created after this date. Used to avoid backfilling. A timestamp in RFC3339 UTC "Zulu" format with nanosecond resolution and upto nine fractional digits.
        :param pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetConditionsOrConditionsArgs'] or_conditions: At least one of the conditions must be true for a table to be scanned.
               Structure is documented below.
        :param pulumi.Input[str] type_collection: Restrict discovery to categories of table types. Currently view, materialized view, snapshot and non-biglake external tables are supported.
               Possible values are: `BIG_QUERY_COLLECTION_ALL_TYPES`, `BIG_QUERY_COLLECTION_ONLY_SUPPORTED_TYPES`.
        :param pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetConditionsTypesArgs'] types: Data profiles will only be generated for the database resource types specified in this field. If not specified, defaults to [DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES].
               Each value may be one of: `DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES`, `DATABASE_RESOURCE_TYPE_TABLE`.
        """
        if created_after is not None:
            pulumi.set(__self__, "created_after", created_after)
        if or_conditions is not None:
            pulumi.set(__self__, "or_conditions", or_conditions)
        if type_collection is not None:
            pulumi.set(__self__, "type_collection", type_collection)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @property
    @pulumi.getter(name="createdAfter")
    def created_after(self) -> Optional[pulumi.Input[str]]:
        """
        File store must have been created after this date. Used to avoid backfilling. A timestamp in RFC3339 UTC "Zulu" format with nanosecond resolution and upto nine fractional digits.
        """
        return pulumi.get(self, "created_after")

    @created_after.setter
    def created_after(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_after", value)

    @property
    @pulumi.getter(name="orConditions")
    def or_conditions(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetConditionsOrConditionsArgs']]:
        """
        At least one of the conditions must be true for a table to be scanned.
        Structure is documented below.
        """
        return pulumi.get(self, "or_conditions")

    @or_conditions.setter
    def or_conditions(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetConditionsOrConditionsArgs']]):
        pulumi.set(self, "or_conditions", value)

    @property
    @pulumi.getter(name="typeCollection")
    def type_collection(self) -> Optional[pulumi.Input[str]]:
        """
        Restrict discovery to categories of table types. Currently view, materialized view, snapshot and non-biglake external tables are supported.
        Possible values are: `BIG_QUERY_COLLECTION_ALL_TYPES`, `BIG_QUERY_COLLECTION_ONLY_SUPPORTED_TYPES`.
        """
        return pulumi.get(self, "type_collection")

    @type_collection.setter
    def type_collection(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "type_collection", value)

    @property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetConditionsTypesArgs']]:
        """
        Data profiles will only be generated for the database resource types specified in this field. If not specified, defaults to [DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES].
        Each value may be one of: `DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES`, `DATABASE_RESOURCE_TYPE_TABLE`.
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetConditionsTypesArgs']]):
        pulumi.set(self, "types", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetBigQueryTargetConditionsOrConditionsArgsDict(TypedDict):
        min_age: NotRequired[pulumi.Input[str]]
        """
        Duration format. The minimum age a table must have before Cloud DLP can profile it. Value greater than 1.
        """
        min_row_count: NotRequired[pulumi.Input[int]]
        """
        Minimum number of rows that should be present before Cloud DLP profiles as a table.
        """
elif False:
    PreventionDiscoveryConfigTargetBigQueryTargetConditionsOrConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetBigQueryTargetConditionsOrConditionsArgs:
    def __init__(__self__, *,
                 min_age: Optional[pulumi.Input[str]] = None,
                 min_row_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] min_age: Duration format. The minimum age a table must have before Cloud DLP can profile it. Value greater than 1.
        :param pulumi.Input[int] min_row_count: Minimum number of rows that should be present before Cloud DLP profiles as a table.
        """
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)
        if min_row_count is not None:
            pulumi.set(__self__, "min_row_count", min_row_count)

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[pulumi.Input[str]]:
        """
        Duration format. The minimum age a table must have before Cloud DLP can profile it. Value greater than 1.
        """
        return pulumi.get(self, "min_age")

    @min_age.setter
    def min_age(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_age", value)

    @property
    @pulumi.getter(name="minRowCount")
    def min_row_count(self) -> Optional[pulumi.Input[int]]:
        """
        Minimum number of rows that should be present before Cloud DLP profiles as a table.
        """
        return pulumi.get(self, "min_row_count")

    @min_row_count.setter
    def min_row_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "min_row_count", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetBigQueryTargetConditionsTypesArgsDict(TypedDict):
        types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A set of BiqQuery table types
        Each value may be one of: `BIG_QUERY_TABLE_TYPE_TABLE`, `BIG_QUERY_TABLE_TYPE_EXTERNAL_BIG_LAKE`.
        """
elif False:
    PreventionDiscoveryConfigTargetBigQueryTargetConditionsTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetBigQueryTargetConditionsTypesArgs:
    def __init__(__self__, *,
                 types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] types: A set of BiqQuery table types
               Each value may be one of: `BIG_QUERY_TABLE_TYPE_TABLE`, `BIG_QUERY_TABLE_TYPE_EXTERNAL_BIG_LAKE`.
        """
        if types is not None:
            pulumi.set(__self__, "types", types)

    @property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A set of BiqQuery table types
        Each value may be one of: `BIG_QUERY_TABLE_TYPE_TABLE`, `BIG_QUERY_TABLE_TYPE_EXTERNAL_BIG_LAKE`.
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "types", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetBigQueryTargetDisabledArgsDict(TypedDict):
        pass
elif False:
    PreventionDiscoveryConfigTargetBigQueryTargetDisabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetBigQueryTargetDisabledArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionDiscoveryConfigTargetBigQueryTargetFilterArgsDict(TypedDict):
        other_tables: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterOtherTablesArgsDict']]
        """
        Catch-all. This should always be the last filter in the list because anything above it will apply first.
        """
        table_reference: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTableReferenceArgsDict']]
        """
        The table to scan. Discovery configurations including this can only include one DiscoveryTarget (the DiscoveryTarget with this TableReference).
        Structure is documented below.
        """
        tables: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesArgsDict']]
        """
        A specific set of tables for this filter to apply to. A table collection must be specified in only one filter per config.
        Structure is documented below.
        """
elif False:
    PreventionDiscoveryConfigTargetBigQueryTargetFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetBigQueryTargetFilterArgs:
    def __init__(__self__, *,
                 other_tables: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterOtherTablesArgs']] = None,
                 table_reference: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTableReferenceArgs']] = None,
                 tables: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesArgs']] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterOtherTablesArgs'] other_tables: Catch-all. This should always be the last filter in the list because anything above it will apply first.
        :param pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTableReferenceArgs'] table_reference: The table to scan. Discovery configurations including this can only include one DiscoveryTarget (the DiscoveryTarget with this TableReference).
               Structure is documented below.
        :param pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesArgs'] tables: A specific set of tables for this filter to apply to. A table collection must be specified in only one filter per config.
               Structure is documented below.
        """
        if other_tables is not None:
            pulumi.set(__self__, "other_tables", other_tables)
        if table_reference is not None:
            pulumi.set(__self__, "table_reference", table_reference)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @property
    @pulumi.getter(name="otherTables")
    def other_tables(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterOtherTablesArgs']]:
        """
        Catch-all. This should always be the last filter in the list because anything above it will apply first.
        """
        return pulumi.get(self, "other_tables")

    @other_tables.setter
    def other_tables(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterOtherTablesArgs']]):
        pulumi.set(self, "other_tables", value)

    @property
    @pulumi.getter(name="tableReference")
    def table_reference(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTableReferenceArgs']]:
        """
        The table to scan. Discovery configurations including this can only include one DiscoveryTarget (the DiscoveryTarget with this TableReference).
        Structure is documented below.
        """
        return pulumi.get(self, "table_reference")

    @table_reference.setter
    def table_reference(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTableReferenceArgs']]):
        pulumi.set(self, "table_reference", value)

    @property
    @pulumi.getter
    def tables(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesArgs']]:
        """
        A specific set of tables for this filter to apply to. A table collection must be specified in only one filter per config.
        Structure is documented below.
        """
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesArgs']]):
        pulumi.set(self, "tables", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetBigQueryTargetFilterOtherTablesArgsDict(TypedDict):
        pass
elif False:
    PreventionDiscoveryConfigTargetBigQueryTargetFilterOtherTablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetBigQueryTargetFilterOtherTablesArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionDiscoveryConfigTargetBigQueryTargetFilterTableReferenceArgsDict(TypedDict):
        dataset_id: pulumi.Input[str]
        """
        Dataset ID of the table.
        """
        table_id: pulumi.Input[str]
        """
        Name of the table.
        """
elif False:
    PreventionDiscoveryConfigTargetBigQueryTargetFilterTableReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetBigQueryTargetFilterTableReferenceArgs:
    def __init__(__self__, *,
                 dataset_id: pulumi.Input[str],
                 table_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] dataset_id: Dataset ID of the table.
        :param pulumi.Input[str] table_id: Name of the table.
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "table_id", table_id)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> pulumi.Input[str]:
        """
        Dataset ID of the table.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="tableId")
    def table_id(self) -> pulumi.Input[str]:
        """
        Name of the table.
        """
        return pulumi.get(self, "table_id")

    @table_id.setter
    def table_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_id", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesArgsDict(TypedDict):
        include_regexes: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesArgsDict']]
        """
        A collection of regular expressions to match a BQ table against.
        Structure is documented below.
        """
elif False:
    PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesArgs:
    def __init__(__self__, *,
                 include_regexes: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesArgs']] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesArgs'] include_regexes: A collection of regular expressions to match a BQ table against.
               Structure is documented below.
        """
        if include_regexes is not None:
            pulumi.set(__self__, "include_regexes", include_regexes)

    @property
    @pulumi.getter(name="includeRegexes")
    def include_regexes(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesArgs']]:
        """
        A collection of regular expressions to match a BQ table against.
        Structure is documented below.
        """
        return pulumi.get(self, "include_regexes")

    @include_regexes.setter
    def include_regexes(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesArgs']]):
        pulumi.set(self, "include_regexes", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesArgsDict(TypedDict):
        patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesPatternArgsDict']]]]
        """
        The group of regular expression patterns to match against one or more file stores. Maximum of 100 entries. The sum of all lengths of regular expressions can't exceed 10 KiB.
        Structure is documented below.
        """
elif False:
    PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesArgs:
    def __init__(__self__, *,
                 patterns: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesPatternArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesPatternArgs']]] patterns: The group of regular expression patterns to match against one or more file stores. Maximum of 100 entries. The sum of all lengths of regular expressions can't exceed 10 KiB.
               Structure is documented below.
        """
        if patterns is not None:
            pulumi.set(__self__, "patterns", patterns)

    @property
    @pulumi.getter
    def patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesPatternArgs']]]]:
        """
        The group of regular expression patterns to match against one or more file stores. Maximum of 100 entries. The sum of all lengths of regular expressions can't exceed 10 KiB.
        Structure is documented below.
        """
        return pulumi.get(self, "patterns")

    @patterns.setter
    def patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesPatternArgs']]]]):
        pulumi.set(self, "patterns", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesPatternArgsDict(TypedDict):
        dataset_id_regex: NotRequired[pulumi.Input[str]]
        """
        if unset, this property matches all datasets
        """
        project_id_regex: NotRequired[pulumi.Input[str]]
        """
        For organizations, if unset, will match all projects. Has no effect for data profile configurations created within a project.
        """
        table_id_regex: NotRequired[pulumi.Input[str]]
        """
        if unset, this property matches all tables
        """
elif False:
    PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetBigQueryTargetFilterTablesIncludeRegexesPatternArgs:
    def __init__(__self__, *,
                 dataset_id_regex: Optional[pulumi.Input[str]] = None,
                 project_id_regex: Optional[pulumi.Input[str]] = None,
                 table_id_regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dataset_id_regex: if unset, this property matches all datasets
        :param pulumi.Input[str] project_id_regex: For organizations, if unset, will match all projects. Has no effect for data profile configurations created within a project.
        :param pulumi.Input[str] table_id_regex: if unset, this property matches all tables
        """
        if dataset_id_regex is not None:
            pulumi.set(__self__, "dataset_id_regex", dataset_id_regex)
        if project_id_regex is not None:
            pulumi.set(__self__, "project_id_regex", project_id_regex)
        if table_id_regex is not None:
            pulumi.set(__self__, "table_id_regex", table_id_regex)

    @property
    @pulumi.getter(name="datasetIdRegex")
    def dataset_id_regex(self) -> Optional[pulumi.Input[str]]:
        """
        if unset, this property matches all datasets
        """
        return pulumi.get(self, "dataset_id_regex")

    @dataset_id_regex.setter
    def dataset_id_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset_id_regex", value)

    @property
    @pulumi.getter(name="projectIdRegex")
    def project_id_regex(self) -> Optional[pulumi.Input[str]]:
        """
        For organizations, if unset, will match all projects. Has no effect for data profile configurations created within a project.
        """
        return pulumi.get(self, "project_id_regex")

    @project_id_regex.setter
    def project_id_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id_regex", value)

    @property
    @pulumi.getter(name="tableIdRegex")
    def table_id_regex(self) -> Optional[pulumi.Input[str]]:
        """
        if unset, this property matches all tables
        """
        return pulumi.get(self, "table_id_regex")

    @table_id_regex.setter
    def table_id_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "table_id_regex", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudSqlTargetArgsDict(TypedDict):
        filter: pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterArgsDict']
        """
        Required. The tables the discovery cadence applies to. The first target with a matching filter will be the one to apply to a table.
        Structure is documented below.
        """
        conditions: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetConditionsArgsDict']]
        """
        In addition to matching the filter, these conditions must be true before a profile is generated.
        Structure is documented below.
        """
        disabled: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetDisabledArgsDict']]
        """
        Disable profiling for database resources that match this filter.
        """
        generation_cadence: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceArgsDict']]
        """
        How often and when to update profiles. New tables that match both the filter and conditions are scanned as quickly as possible depending on system capacity.
        Structure is documented below.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudSqlTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudSqlTargetArgs:
    def __init__(__self__, *,
                 filter: pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterArgs'],
                 conditions: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetConditionsArgs']] = None,
                 disabled: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetDisabledArgs']] = None,
                 generation_cadence: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceArgs']] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterArgs'] filter: Required. The tables the discovery cadence applies to. The first target with a matching filter will be the one to apply to a table.
               Structure is documented below.
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetConditionsArgs'] conditions: In addition to matching the filter, these conditions must be true before a profile is generated.
               Structure is documented below.
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetDisabledArgs'] disabled: Disable profiling for database resources that match this filter.
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceArgs'] generation_cadence: How often and when to update profiles. New tables that match both the filter and conditions are scanned as quickly as possible depending on system capacity.
               Structure is documented below.
        """
        pulumi.set(__self__, "filter", filter)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if generation_cadence is not None:
            pulumi.set(__self__, "generation_cadence", generation_cadence)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterArgs']:
        """
        Required. The tables the discovery cadence applies to. The first target with a matching filter will be the one to apply to a table.
        Structure is documented below.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterArgs']):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetConditionsArgs']]:
        """
        In addition to matching the filter, these conditions must be true before a profile is generated.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetConditionsArgs']]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetDisabledArgs']]:
        """
        Disable profiling for database resources that match this filter.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetDisabledArgs']]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="generationCadence")
    def generation_cadence(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceArgs']]:
        """
        How often and when to update profiles. New tables that match both the filter and conditions are scanned as quickly as possible depending on system capacity.
        Structure is documented below.
        """
        return pulumi.get(self, "generation_cadence")

    @generation_cadence.setter
    def generation_cadence(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceArgs']]):
        pulumi.set(self, "generation_cadence", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudSqlTargetConditionsArgsDict(TypedDict):
        database_engines: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Database engines that should be profiled. Optional. Defaults to ALL_SUPPORTED_DATABASE_ENGINES if unspecified.
        Each value may be one of: `ALL_SUPPORTED_DATABASE_ENGINES`, `MYSQL`, `POSTGRES`.
        """
        types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Data profiles will only be generated for the database resource types specified in this field. If not specified, defaults to [DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES].
        Each value may be one of: `DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES`, `DATABASE_RESOURCE_TYPE_TABLE`.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudSqlTargetConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudSqlTargetConditionsArgs:
    def __init__(__self__, *,
                 database_engines: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] database_engines: Database engines that should be profiled. Optional. Defaults to ALL_SUPPORTED_DATABASE_ENGINES if unspecified.
               Each value may be one of: `ALL_SUPPORTED_DATABASE_ENGINES`, `MYSQL`, `POSTGRES`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] types: Data profiles will only be generated for the database resource types specified in this field. If not specified, defaults to [DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES].
               Each value may be one of: `DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES`, `DATABASE_RESOURCE_TYPE_TABLE`.
        """
        if database_engines is not None:
            pulumi.set(__self__, "database_engines", database_engines)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @property
    @pulumi.getter(name="databaseEngines")
    def database_engines(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Database engines that should be profiled. Optional. Defaults to ALL_SUPPORTED_DATABASE_ENGINES if unspecified.
        Each value may be one of: `ALL_SUPPORTED_DATABASE_ENGINES`, `MYSQL`, `POSTGRES`.
        """
        return pulumi.get(self, "database_engines")

    @database_engines.setter
    def database_engines(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "database_engines", value)

    @property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Data profiles will only be generated for the database resource types specified in this field. If not specified, defaults to [DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES].
        Each value may be one of: `DATABASE_RESOURCE_TYPE_ALL_SUPPORTED_TYPES`, `DATABASE_RESOURCE_TYPE_TABLE`.
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "types", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudSqlTargetDisabledArgsDict(TypedDict):
        pass
elif False:
    PreventionDiscoveryConfigTargetCloudSqlTargetDisabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudSqlTargetDisabledArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudSqlTargetFilterArgsDict(TypedDict):
        collection: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionArgsDict']]
        """
        A specific set of buckets for this filter to apply to.
        Structure is documented below.
        """
        database_resource_reference: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterDatabaseResourceReferenceArgsDict']]
        """
        The database resource to scan. Targets including this can only include one target (the target with this database resource reference).
        Structure is documented below.
        """
        others: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterOthersArgsDict']]
        """
        Match discovery resources not covered by any other filter.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudSqlTargetFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudSqlTargetFilterArgs:
    def __init__(__self__, *,
                 collection: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionArgs']] = None,
                 database_resource_reference: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterDatabaseResourceReferenceArgs']] = None,
                 others: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterOthersArgs']] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionArgs'] collection: A specific set of buckets for this filter to apply to.
               Structure is documented below.
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterDatabaseResourceReferenceArgs'] database_resource_reference: The database resource to scan. Targets including this can only include one target (the target with this database resource reference).
               Structure is documented below.
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterOthersArgs'] others: Match discovery resources not covered by any other filter.
        """
        if collection is not None:
            pulumi.set(__self__, "collection", collection)
        if database_resource_reference is not None:
            pulumi.set(__self__, "database_resource_reference", database_resource_reference)
        if others is not None:
            pulumi.set(__self__, "others", others)

    @property
    @pulumi.getter
    def collection(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionArgs']]:
        """
        A specific set of buckets for this filter to apply to.
        Structure is documented below.
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionArgs']]):
        pulumi.set(self, "collection", value)

    @property
    @pulumi.getter(name="databaseResourceReference")
    def database_resource_reference(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterDatabaseResourceReferenceArgs']]:
        """
        The database resource to scan. Targets including this can only include one target (the target with this database resource reference).
        Structure is documented below.
        """
        return pulumi.get(self, "database_resource_reference")

    @database_resource_reference.setter
    def database_resource_reference(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterDatabaseResourceReferenceArgs']]):
        pulumi.set(self, "database_resource_reference", value)

    @property
    @pulumi.getter
    def others(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterOthersArgs']]:
        """
        Match discovery resources not covered by any other filter.
        """
        return pulumi.get(self, "others")

    @others.setter
    def others(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterOthersArgs']]):
        pulumi.set(self, "others", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionArgsDict(TypedDict):
        include_regexes: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesArgsDict']]
        """
        A collection of regular expressions to match a file store against.
        Structure is documented below.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionArgs:
    def __init__(__self__, *,
                 include_regexes: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesArgs']] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesArgs'] include_regexes: A collection of regular expressions to match a file store against.
               Structure is documented below.
        """
        if include_regexes is not None:
            pulumi.set(__self__, "include_regexes", include_regexes)

    @property
    @pulumi.getter(name="includeRegexes")
    def include_regexes(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesArgs']]:
        """
        A collection of regular expressions to match a file store against.
        Structure is documented below.
        """
        return pulumi.get(self, "include_regexes")

    @include_regexes.setter
    def include_regexes(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesArgs']]):
        pulumi.set(self, "include_regexes", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesArgsDict(TypedDict):
        patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesPatternArgsDict']]]]
        """
        The group of regular expression patterns to match against one or more file stores. Maximum of 100 entries. The sum of all lengths of regular expressions can't exceed 10 KiB.
        Structure is documented below.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesArgs:
    def __init__(__self__, *,
                 patterns: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesPatternArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesPatternArgs']]] patterns: The group of regular expression patterns to match against one or more file stores. Maximum of 100 entries. The sum of all lengths of regular expressions can't exceed 10 KiB.
               Structure is documented below.
        """
        if patterns is not None:
            pulumi.set(__self__, "patterns", patterns)

    @property
    @pulumi.getter
    def patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesPatternArgs']]]]:
        """
        The group of regular expression patterns to match against one or more file stores. Maximum of 100 entries. The sum of all lengths of regular expressions can't exceed 10 KiB.
        Structure is documented below.
        """
        return pulumi.get(self, "patterns")

    @patterns.setter
    def patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesPatternArgs']]]]):
        pulumi.set(self, "patterns", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesPatternArgsDict(TypedDict):
        database_regex: NotRequired[pulumi.Input[str]]
        """
        Regex to test the database name against. If empty, all databases match.
        """
        database_resource_name_regex: NotRequired[pulumi.Input[str]]
        """
        Regex to test the database resource's name against. An example of a database resource name is a table's name. Other database resource names like view names could be included in the future. If empty, all database resources match.'
        """
        instance_regex: NotRequired[pulumi.Input[str]]
        """
        Regex to test the instance name against. If empty, all instances match.
        """
        project_id_regex: NotRequired[pulumi.Input[str]]
        """
        For organizations, if unset, will match all projects. Has no effect for data profile configurations created within a project.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudSqlTargetFilterCollectionIncludeRegexesPatternArgs:
    def __init__(__self__, *,
                 database_regex: Optional[pulumi.Input[str]] = None,
                 database_resource_name_regex: Optional[pulumi.Input[str]] = None,
                 instance_regex: Optional[pulumi.Input[str]] = None,
                 project_id_regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] database_regex: Regex to test the database name against. If empty, all databases match.
        :param pulumi.Input[str] database_resource_name_regex: Regex to test the database resource's name against. An example of a database resource name is a table's name. Other database resource names like view names could be included in the future. If empty, all database resources match.'
        :param pulumi.Input[str] instance_regex: Regex to test the instance name against. If empty, all instances match.
        :param pulumi.Input[str] project_id_regex: For organizations, if unset, will match all projects. Has no effect for data profile configurations created within a project.
        """
        if database_regex is not None:
            pulumi.set(__self__, "database_regex", database_regex)
        if database_resource_name_regex is not None:
            pulumi.set(__self__, "database_resource_name_regex", database_resource_name_regex)
        if instance_regex is not None:
            pulumi.set(__self__, "instance_regex", instance_regex)
        if project_id_regex is not None:
            pulumi.set(__self__, "project_id_regex", project_id_regex)

    @property
    @pulumi.getter(name="databaseRegex")
    def database_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Regex to test the database name against. If empty, all databases match.
        """
        return pulumi.get(self, "database_regex")

    @database_regex.setter
    def database_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_regex", value)

    @property
    @pulumi.getter(name="databaseResourceNameRegex")
    def database_resource_name_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Regex to test the database resource's name against. An example of a database resource name is a table's name. Other database resource names like view names could be included in the future. If empty, all database resources match.'
        """
        return pulumi.get(self, "database_resource_name_regex")

    @database_resource_name_regex.setter
    def database_resource_name_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "database_resource_name_regex", value)

    @property
    @pulumi.getter(name="instanceRegex")
    def instance_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Regex to test the instance name against. If empty, all instances match.
        """
        return pulumi.get(self, "instance_regex")

    @instance_regex.setter
    def instance_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "instance_regex", value)

    @property
    @pulumi.getter(name="projectIdRegex")
    def project_id_regex(self) -> Optional[pulumi.Input[str]]:
        """
        For organizations, if unset, will match all projects. Has no effect for data profile configurations created within a project.
        """
        return pulumi.get(self, "project_id_regex")

    @project_id_regex.setter
    def project_id_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id_regex", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudSqlTargetFilterDatabaseResourceReferenceArgsDict(TypedDict):
        database: pulumi.Input[str]
        """
        Required. Name of a database within the instance.
        """
        database_resource: pulumi.Input[str]
        """
        Required. Name of a database resource, for example, a table within the database.
        """
        instance: pulumi.Input[str]
        """
        Required. The instance where this resource is located. For example: Cloud SQL instance ID.
        """
        project_id: pulumi.Input[str]
        """
        Required. If within a project-level config, then this must match the config's project ID.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudSqlTargetFilterDatabaseResourceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudSqlTargetFilterDatabaseResourceReferenceArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 database_resource: pulumi.Input[str],
                 instance: pulumi.Input[str],
                 project_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] database: Required. Name of a database within the instance.
        :param pulumi.Input[str] database_resource: Required. Name of a database resource, for example, a table within the database.
        :param pulumi.Input[str] instance: Required. The instance where this resource is located. For example: Cloud SQL instance ID.
        :param pulumi.Input[str] project_id: Required. If within a project-level config, then this must match the config's project ID.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "database_resource", database_resource)
        pulumi.set(__self__, "instance", instance)
        pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Required. Name of a database within the instance.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="databaseResource")
    def database_resource(self) -> pulumi.Input[str]:
        """
        Required. Name of a database resource, for example, a table within the database.
        """
        return pulumi.get(self, "database_resource")

    @database_resource.setter
    def database_resource(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_resource", value)

    @property
    @pulumi.getter
    def instance(self) -> pulumi.Input[str]:
        """
        Required. The instance where this resource is located. For example: Cloud SQL instance ID.
        """
        return pulumi.get(self, "instance")

    @instance.setter
    def instance(self, value: pulumi.Input[str]):
        pulumi.set(self, "instance", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        Required. If within a project-level config, then this must match the config's project ID.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudSqlTargetFilterOthersArgsDict(TypedDict):
        pass
elif False:
    PreventionDiscoveryConfigTargetCloudSqlTargetFilterOthersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudSqlTargetFilterOthersArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceArgsDict(TypedDict):
        inspect_template_modified_cadence: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceInspectTemplateModifiedCadenceArgsDict']]
        """
        Governs when to update data profiles when the inspection rules defined by the `InspectTemplate` change. If not set, changing the template will not cause a data profile to update.
        Structure is documented below.
        """
        refresh_frequency: NotRequired[pulumi.Input[str]]
        """
        Data changes in Cloud Storage can't trigger reprofiling. If you set this field, profiles are refreshed at this frequency regardless of whether the underlying buckets have changes. Defaults to never.
        Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
        schema_modified_cadence: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceSchemaModifiedCadenceArgsDict']]
        """
        Governs when to update data profiles when a schema is modified
        Structure is documented below.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceArgs:
    def __init__(__self__, *,
                 inspect_template_modified_cadence: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceInspectTemplateModifiedCadenceArgs']] = None,
                 refresh_frequency: Optional[pulumi.Input[str]] = None,
                 schema_modified_cadence: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceSchemaModifiedCadenceArgs']] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceInspectTemplateModifiedCadenceArgs'] inspect_template_modified_cadence: Governs when to update data profiles when the inspection rules defined by the `InspectTemplate` change. If not set, changing the template will not cause a data profile to update.
               Structure is documented below.
        :param pulumi.Input[str] refresh_frequency: Data changes in Cloud Storage can't trigger reprofiling. If you set this field, profiles are refreshed at this frequency regardless of whether the underlying buckets have changes. Defaults to never.
               Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceSchemaModifiedCadenceArgs'] schema_modified_cadence: Governs when to update data profiles when a schema is modified
               Structure is documented below.
        """
        if inspect_template_modified_cadence is not None:
            pulumi.set(__self__, "inspect_template_modified_cadence", inspect_template_modified_cadence)
        if refresh_frequency is not None:
            pulumi.set(__self__, "refresh_frequency", refresh_frequency)
        if schema_modified_cadence is not None:
            pulumi.set(__self__, "schema_modified_cadence", schema_modified_cadence)

    @property
    @pulumi.getter(name="inspectTemplateModifiedCadence")
    def inspect_template_modified_cadence(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceInspectTemplateModifiedCadenceArgs']]:
        """
        Governs when to update data profiles when the inspection rules defined by the `InspectTemplate` change. If not set, changing the template will not cause a data profile to update.
        Structure is documented below.
        """
        return pulumi.get(self, "inspect_template_modified_cadence")

    @inspect_template_modified_cadence.setter
    def inspect_template_modified_cadence(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceInspectTemplateModifiedCadenceArgs']]):
        pulumi.set(self, "inspect_template_modified_cadence", value)

    @property
    @pulumi.getter(name="refreshFrequency")
    def refresh_frequency(self) -> Optional[pulumi.Input[str]]:
        """
        Data changes in Cloud Storage can't trigger reprofiling. If you set this field, profiles are refreshed at this frequency regardless of whether the underlying buckets have changes. Defaults to never.
        Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
        return pulumi.get(self, "refresh_frequency")

    @refresh_frequency.setter
    def refresh_frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_frequency", value)

    @property
    @pulumi.getter(name="schemaModifiedCadence")
    def schema_modified_cadence(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceSchemaModifiedCadenceArgs']]:
        """
        Governs when to update data profiles when a schema is modified
        Structure is documented below.
        """
        return pulumi.get(self, "schema_modified_cadence")

    @schema_modified_cadence.setter
    def schema_modified_cadence(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceSchemaModifiedCadenceArgs']]):
        pulumi.set(self, "schema_modified_cadence", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceInspectTemplateModifiedCadenceArgsDict(TypedDict):
        frequency: pulumi.Input[str]
        """
        How frequently data profiles can be updated when the template is modified. Defaults to never.
        Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceInspectTemplateModifiedCadenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceInspectTemplateModifiedCadenceArgs:
    def __init__(__self__, *,
                 frequency: pulumi.Input[str]):
        """
        :param pulumi.Input[str] frequency: How frequently data profiles can be updated when the template is modified. Defaults to never.
               Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
        pulumi.set(__self__, "frequency", frequency)

    @property
    @pulumi.getter
    def frequency(self) -> pulumi.Input[str]:
        """
        How frequently data profiles can be updated when the template is modified. Defaults to never.
        Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: pulumi.Input[str]):
        pulumi.set(self, "frequency", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceSchemaModifiedCadenceArgsDict(TypedDict):
        frequency: NotRequired[pulumi.Input[str]]
        """
        Frequency to regenerate data profiles when the schema is modified. Defaults to monthly.
        Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
        types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        The types of schema modifications to consider. Defaults to NEW_COLUMNS.
        Each value may be one of: `NEW_COLUMNS`, `REMOVED_COLUMNS`.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceSchemaModifiedCadenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudSqlTargetGenerationCadenceSchemaModifiedCadenceArgs:
    def __init__(__self__, *,
                 frequency: Optional[pulumi.Input[str]] = None,
                 types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] frequency: Frequency to regenerate data profiles when the schema is modified. Defaults to monthly.
               Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] types: The types of schema modifications to consider. Defaults to NEW_COLUMNS.
               Each value may be one of: `NEW_COLUMNS`, `REMOVED_COLUMNS`.
        """
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)
        if types is not None:
            pulumi.set(__self__, "types", types)

    @property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input[str]]:
        """
        Frequency to regenerate data profiles when the schema is modified. Defaults to monthly.
        Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency", value)

    @property
    @pulumi.getter
    def types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The types of schema modifications to consider. Defaults to NEW_COLUMNS.
        Each value may be one of: `NEW_COLUMNS`, `REMOVED_COLUMNS`.
        """
        return pulumi.get(self, "types")

    @types.setter
    def types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "types", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudStorageTargetArgsDict(TypedDict):
        filter: pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterArgsDict']
        """
        The buckets the generation_cadence applies to. The first target with a matching filter will be the one to apply to a bucket.
        Structure is documented below.
        """
        conditions: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetConditionsArgsDict']]
        """
        In addition to matching the filter, these conditions must be true before a profile is generated.
        Structure is documented below.
        """
        disabled: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetDisabledArgsDict']]
        """
        Disable profiling for buckets that match this filter.
        """
        generation_cadence: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceArgsDict']]
        """
        How often and when to update profiles. New buckets that match both the filter and conditions are scanned as quickly as possible depending on system capacity.
        Structure is documented below.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudStorageTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudStorageTargetArgs:
    def __init__(__self__, *,
                 filter: pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterArgs'],
                 conditions: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetConditionsArgs']] = None,
                 disabled: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetDisabledArgs']] = None,
                 generation_cadence: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceArgs']] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterArgs'] filter: The buckets the generation_cadence applies to. The first target with a matching filter will be the one to apply to a bucket.
               Structure is documented below.
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetConditionsArgs'] conditions: In addition to matching the filter, these conditions must be true before a profile is generated.
               Structure is documented below.
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetDisabledArgs'] disabled: Disable profiling for buckets that match this filter.
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceArgs'] generation_cadence: How often and when to update profiles. New buckets that match both the filter and conditions are scanned as quickly as possible depending on system capacity.
               Structure is documented below.
        """
        pulumi.set(__self__, "filter", filter)
        if conditions is not None:
            pulumi.set(__self__, "conditions", conditions)
        if disabled is not None:
            pulumi.set(__self__, "disabled", disabled)
        if generation_cadence is not None:
            pulumi.set(__self__, "generation_cadence", generation_cadence)

    @property
    @pulumi.getter
    def filter(self) -> pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterArgs']:
        """
        The buckets the generation_cadence applies to. The first target with a matching filter will be the one to apply to a bucket.
        Structure is documented below.
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterArgs']):
        pulumi.set(self, "filter", value)

    @property
    @pulumi.getter
    def conditions(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetConditionsArgs']]:
        """
        In addition to matching the filter, these conditions must be true before a profile is generated.
        Structure is documented below.
        """
        return pulumi.get(self, "conditions")

    @conditions.setter
    def conditions(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetConditionsArgs']]):
        pulumi.set(self, "conditions", value)

    @property
    @pulumi.getter
    def disabled(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetDisabledArgs']]:
        """
        Disable profiling for buckets that match this filter.
        """
        return pulumi.get(self, "disabled")

    @disabled.setter
    def disabled(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetDisabledArgs']]):
        pulumi.set(self, "disabled", value)

    @property
    @pulumi.getter(name="generationCadence")
    def generation_cadence(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceArgs']]:
        """
        How often and when to update profiles. New buckets that match both the filter and conditions are scanned as quickly as possible depending on system capacity.
        Structure is documented below.
        """
        return pulumi.get(self, "generation_cadence")

    @generation_cadence.setter
    def generation_cadence(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceArgs']]):
        pulumi.set(self, "generation_cadence", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudStorageTargetConditionsArgsDict(TypedDict):
        cloud_storage_conditions: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetConditionsCloudStorageConditionsArgsDict']]
        """
        Cloud Storage conditions.
        Structure is documented below.
        """
        created_after: NotRequired[pulumi.Input[str]]
        """
        File store must have been created after this date. Used to avoid backfilling. A timestamp in RFC3339 UTC "Zulu" format with nanosecond resolution and upto nine fractional digits.
        """
        min_age: NotRequired[pulumi.Input[str]]
        """
        Duration format. Minimum age a file store must have. If set, the value must be 1 hour or greater.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudStorageTargetConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudStorageTargetConditionsArgs:
    def __init__(__self__, *,
                 cloud_storage_conditions: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetConditionsCloudStorageConditionsArgs']] = None,
                 created_after: Optional[pulumi.Input[str]] = None,
                 min_age: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetConditionsCloudStorageConditionsArgs'] cloud_storage_conditions: Cloud Storage conditions.
               Structure is documented below.
        :param pulumi.Input[str] created_after: File store must have been created after this date. Used to avoid backfilling. A timestamp in RFC3339 UTC "Zulu" format with nanosecond resolution and upto nine fractional digits.
        :param pulumi.Input[str] min_age: Duration format. Minimum age a file store must have. If set, the value must be 1 hour or greater.
        """
        if cloud_storage_conditions is not None:
            pulumi.set(__self__, "cloud_storage_conditions", cloud_storage_conditions)
        if created_after is not None:
            pulumi.set(__self__, "created_after", created_after)
        if min_age is not None:
            pulumi.set(__self__, "min_age", min_age)

    @property
    @pulumi.getter(name="cloudStorageConditions")
    def cloud_storage_conditions(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetConditionsCloudStorageConditionsArgs']]:
        """
        Cloud Storage conditions.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_storage_conditions")

    @cloud_storage_conditions.setter
    def cloud_storage_conditions(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetConditionsCloudStorageConditionsArgs']]):
        pulumi.set(self, "cloud_storage_conditions", value)

    @property
    @pulumi.getter(name="createdAfter")
    def created_after(self) -> Optional[pulumi.Input[str]]:
        """
        File store must have been created after this date. Used to avoid backfilling. A timestamp in RFC3339 UTC "Zulu" format with nanosecond resolution and upto nine fractional digits.
        """
        return pulumi.get(self, "created_after")

    @created_after.setter
    def created_after(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "created_after", value)

    @property
    @pulumi.getter(name="minAge")
    def min_age(self) -> Optional[pulumi.Input[str]]:
        """
        Duration format. Minimum age a file store must have. If set, the value must be 1 hour or greater.
        """
        return pulumi.get(self, "min_age")

    @min_age.setter
    def min_age(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_age", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudStorageTargetConditionsCloudStorageConditionsArgsDict(TypedDict):
        included_bucket_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Only objects with the specified attributes will be scanned. Defaults to [ALL_SUPPORTED_BUCKETS] if unset.
        Each value may be one of: `ALL_SUPPORTED_BUCKETS`, `AUTOCLASS_DISABLED`, `AUTOCLASS_ENABLED`.
        """
        included_object_attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        Only objects with the specified attributes will be scanned. If an object has one of the specified attributes but is inside an excluded bucket, it will not be scanned. Defaults to [ALL_SUPPORTED_OBJECTS]. A profile will be created even if no objects match the included_object_attributes.
        Each value may be one of: `ALL_SUPPORTED_OBJECTS`, `STANDARD`, `NEARLINE`, `COLDLINE`, `ARCHIVE`, `REGIONAL`, `MULTI_REGIONAL`, `DURABLE_REDUCED_AVAILABILITY`.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudStorageTargetConditionsCloudStorageConditionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudStorageTargetConditionsCloudStorageConditionsArgs:
    def __init__(__self__, *,
                 included_bucket_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 included_object_attributes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_bucket_attributes: Only objects with the specified attributes will be scanned. Defaults to [ALL_SUPPORTED_BUCKETS] if unset.
               Each value may be one of: `ALL_SUPPORTED_BUCKETS`, `AUTOCLASS_DISABLED`, `AUTOCLASS_ENABLED`.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] included_object_attributes: Only objects with the specified attributes will be scanned. If an object has one of the specified attributes but is inside an excluded bucket, it will not be scanned. Defaults to [ALL_SUPPORTED_OBJECTS]. A profile will be created even if no objects match the included_object_attributes.
               Each value may be one of: `ALL_SUPPORTED_OBJECTS`, `STANDARD`, `NEARLINE`, `COLDLINE`, `ARCHIVE`, `REGIONAL`, `MULTI_REGIONAL`, `DURABLE_REDUCED_AVAILABILITY`.
        """
        if included_bucket_attributes is not None:
            pulumi.set(__self__, "included_bucket_attributes", included_bucket_attributes)
        if included_object_attributes is not None:
            pulumi.set(__self__, "included_object_attributes", included_object_attributes)

    @property
    @pulumi.getter(name="includedBucketAttributes")
    def included_bucket_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Only objects with the specified attributes will be scanned. Defaults to [ALL_SUPPORTED_BUCKETS] if unset.
        Each value may be one of: `ALL_SUPPORTED_BUCKETS`, `AUTOCLASS_DISABLED`, `AUTOCLASS_ENABLED`.
        """
        return pulumi.get(self, "included_bucket_attributes")

    @included_bucket_attributes.setter
    def included_bucket_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_bucket_attributes", value)

    @property
    @pulumi.getter(name="includedObjectAttributes")
    def included_object_attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        Only objects with the specified attributes will be scanned. If an object has one of the specified attributes but is inside an excluded bucket, it will not be scanned. Defaults to [ALL_SUPPORTED_OBJECTS]. A profile will be created even if no objects match the included_object_attributes.
        Each value may be one of: `ALL_SUPPORTED_OBJECTS`, `STANDARD`, `NEARLINE`, `COLDLINE`, `ARCHIVE`, `REGIONAL`, `MULTI_REGIONAL`, `DURABLE_REDUCED_AVAILABILITY`.
        """
        return pulumi.get(self, "included_object_attributes")

    @included_object_attributes.setter
    def included_object_attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "included_object_attributes", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudStorageTargetDisabledArgsDict(TypedDict):
        pass
elif False:
    PreventionDiscoveryConfigTargetCloudStorageTargetDisabledArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudStorageTargetDisabledArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudStorageTargetFilterArgsDict(TypedDict):
        cloud_storage_resource_reference: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCloudStorageResourceReferenceArgsDict']]
        """
        The bucket to scan. Targets including this can only include one target (the target with this bucket). This enables profiling the contents of a single bucket, while the other options allow for easy profiling of many buckets within a project or an organization.
        Structure is documented below.
        """
        collection: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionArgsDict']]
        """
        A specific set of buckets for this filter to apply to.
        Structure is documented below.
        """
        others: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterOthersArgsDict']]
        """
        Match discovery resources not covered by any other filter.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudStorageTargetFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudStorageTargetFilterArgs:
    def __init__(__self__, *,
                 cloud_storage_resource_reference: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCloudStorageResourceReferenceArgs']] = None,
                 collection: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionArgs']] = None,
                 others: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterOthersArgs']] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCloudStorageResourceReferenceArgs'] cloud_storage_resource_reference: The bucket to scan. Targets including this can only include one target (the target with this bucket). This enables profiling the contents of a single bucket, while the other options allow for easy profiling of many buckets within a project or an organization.
               Structure is documented below.
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionArgs'] collection: A specific set of buckets for this filter to apply to.
               Structure is documented below.
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterOthersArgs'] others: Match discovery resources not covered by any other filter.
        """
        if cloud_storage_resource_reference is not None:
            pulumi.set(__self__, "cloud_storage_resource_reference", cloud_storage_resource_reference)
        if collection is not None:
            pulumi.set(__self__, "collection", collection)
        if others is not None:
            pulumi.set(__self__, "others", others)

    @property
    @pulumi.getter(name="cloudStorageResourceReference")
    def cloud_storage_resource_reference(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCloudStorageResourceReferenceArgs']]:
        """
        The bucket to scan. Targets including this can only include one target (the target with this bucket). This enables profiling the contents of a single bucket, while the other options allow for easy profiling of many buckets within a project or an organization.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_storage_resource_reference")

    @cloud_storage_resource_reference.setter
    def cloud_storage_resource_reference(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCloudStorageResourceReferenceArgs']]):
        pulumi.set(self, "cloud_storage_resource_reference", value)

    @property
    @pulumi.getter
    def collection(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionArgs']]:
        """
        A specific set of buckets for this filter to apply to.
        Structure is documented below.
        """
        return pulumi.get(self, "collection")

    @collection.setter
    def collection(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionArgs']]):
        pulumi.set(self, "collection", value)

    @property
    @pulumi.getter
    def others(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterOthersArgs']]:
        """
        Match discovery resources not covered by any other filter.
        """
        return pulumi.get(self, "others")

    @others.setter
    def others(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterOthersArgs']]):
        pulumi.set(self, "others", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudStorageTargetFilterCloudStorageResourceReferenceArgsDict(TypedDict):
        bucket_name: NotRequired[pulumi.Input[str]]
        """
        The bucket to scan.
        """
        project_id: NotRequired[pulumi.Input[str]]
        """
        If within a project-level config, then this must match the config's project id.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudStorageTargetFilterCloudStorageResourceReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudStorageTargetFilterCloudStorageResourceReferenceArgs:
    def __init__(__self__, *,
                 bucket_name: Optional[pulumi.Input[str]] = None,
                 project_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket_name: The bucket to scan.
        :param pulumi.Input[str] project_id: If within a project-level config, then this must match the config's project id.
        """
        if bucket_name is not None:
            pulumi.set(__self__, "bucket_name", bucket_name)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> Optional[pulumi.Input[str]]:
        """
        The bucket to scan.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[str]]:
        """
        If within a project-level config, then this must match the config's project id.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionArgsDict(TypedDict):
        include_regexes: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesArgsDict']]
        """
        A collection of regular expressions to match a file store against.
        Structure is documented below.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionArgs:
    def __init__(__self__, *,
                 include_regexes: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesArgs']] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesArgs'] include_regexes: A collection of regular expressions to match a file store against.
               Structure is documented below.
        """
        if include_regexes is not None:
            pulumi.set(__self__, "include_regexes", include_regexes)

    @property
    @pulumi.getter(name="includeRegexes")
    def include_regexes(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesArgs']]:
        """
        A collection of regular expressions to match a file store against.
        Structure is documented below.
        """
        return pulumi.get(self, "include_regexes")

    @include_regexes.setter
    def include_regexes(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesArgs']]):
        pulumi.set(self, "include_regexes", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesArgsDict(TypedDict):
        patterns: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternArgsDict']]]]
        """
        The group of regular expression patterns to match against one or more file stores. Maximum of 100 entries. The sum of all lengths of regular expressions can't exceed 10 KiB.
        Structure is documented below.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesArgs:
    def __init__(__self__, *,
                 patterns: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternArgs']]] patterns: The group of regular expression patterns to match against one or more file stores. Maximum of 100 entries. The sum of all lengths of regular expressions can't exceed 10 KiB.
               Structure is documented below.
        """
        if patterns is not None:
            pulumi.set(__self__, "patterns", patterns)

    @property
    @pulumi.getter
    def patterns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternArgs']]]]:
        """
        The group of regular expression patterns to match against one or more file stores. Maximum of 100 entries. The sum of all lengths of regular expressions can't exceed 10 KiB.
        Structure is documented below.
        """
        return pulumi.get(self, "patterns")

    @patterns.setter
    def patterns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternArgs']]]]):
        pulumi.set(self, "patterns", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternArgsDict(TypedDict):
        cloud_storage_regex: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternCloudStorageRegexArgsDict']]
        """
        Regex for Cloud Storage.
        Structure is documented below.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternArgs:
    def __init__(__self__, *,
                 cloud_storage_regex: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternCloudStorageRegexArgs']] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternCloudStorageRegexArgs'] cloud_storage_regex: Regex for Cloud Storage.
               Structure is documented below.
        """
        if cloud_storage_regex is not None:
            pulumi.set(__self__, "cloud_storage_regex", cloud_storage_regex)

    @property
    @pulumi.getter(name="cloudStorageRegex")
    def cloud_storage_regex(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternCloudStorageRegexArgs']]:
        """
        Regex for Cloud Storage.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_storage_regex")

    @cloud_storage_regex.setter
    def cloud_storage_regex(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternCloudStorageRegexArgs']]):
        pulumi.set(self, "cloud_storage_regex", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternCloudStorageRegexArgsDict(TypedDict):
        bucket_name_regex: NotRequired[pulumi.Input[str]]
        """
        Regex to test the bucket name against. If empty, all buckets match. Example: "marketing2021" or "(marketing)\\d{4}" will both match the bucket gs://marketing2021
        """
        project_id_regex: NotRequired[pulumi.Input[str]]
        """
        For organizations, if unset, will match all projects.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternCloudStorageRegexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudStorageTargetFilterCollectionIncludeRegexesPatternCloudStorageRegexArgs:
    def __init__(__self__, *,
                 bucket_name_regex: Optional[pulumi.Input[str]] = None,
                 project_id_regex: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket_name_regex: Regex to test the bucket name against. If empty, all buckets match. Example: "marketing2021" or "(marketing)\\d{4}" will both match the bucket gs://marketing2021
        :param pulumi.Input[str] project_id_regex: For organizations, if unset, will match all projects.
        """
        if bucket_name_regex is not None:
            pulumi.set(__self__, "bucket_name_regex", bucket_name_regex)
        if project_id_regex is not None:
            pulumi.set(__self__, "project_id_regex", project_id_regex)

    @property
    @pulumi.getter(name="bucketNameRegex")
    def bucket_name_regex(self) -> Optional[pulumi.Input[str]]:
        """
        Regex to test the bucket name against. If empty, all buckets match. Example: "marketing2021" or "(marketing)\\d{4}" will both match the bucket gs://marketing2021
        """
        return pulumi.get(self, "bucket_name_regex")

    @bucket_name_regex.setter
    def bucket_name_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "bucket_name_regex", value)

    @property
    @pulumi.getter(name="projectIdRegex")
    def project_id_regex(self) -> Optional[pulumi.Input[str]]:
        """
        For organizations, if unset, will match all projects.
        """
        return pulumi.get(self, "project_id_regex")

    @project_id_regex.setter
    def project_id_regex(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "project_id_regex", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudStorageTargetFilterOthersArgsDict(TypedDict):
        pass
elif False:
    PreventionDiscoveryConfigTargetCloudStorageTargetFilterOthersArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudStorageTargetFilterOthersArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceArgsDict(TypedDict):
        inspect_template_modified_cadence: NotRequired[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceInspectTemplateModifiedCadenceArgsDict']]
        """
        Governs when to update data profiles when the inspection rules defined by the `InspectTemplate` change. If not set, changing the template will not cause a data profile to update.
        Structure is documented below.
        """
        refresh_frequency: NotRequired[pulumi.Input[str]]
        """
        Data changes in Cloud Storage can't trigger reprofiling. If you set this field, profiles are refreshed at this frequency regardless of whether the underlying buckets have changes. Defaults to never.
        Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceArgs:
    def __init__(__self__, *,
                 inspect_template_modified_cadence: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceInspectTemplateModifiedCadenceArgs']] = None,
                 refresh_frequency: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceInspectTemplateModifiedCadenceArgs'] inspect_template_modified_cadence: Governs when to update data profiles when the inspection rules defined by the `InspectTemplate` change. If not set, changing the template will not cause a data profile to update.
               Structure is documented below.
        :param pulumi.Input[str] refresh_frequency: Data changes in Cloud Storage can't trigger reprofiling. If you set this field, profiles are refreshed at this frequency regardless of whether the underlying buckets have changes. Defaults to never.
               Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
        if inspect_template_modified_cadence is not None:
            pulumi.set(__self__, "inspect_template_modified_cadence", inspect_template_modified_cadence)
        if refresh_frequency is not None:
            pulumi.set(__self__, "refresh_frequency", refresh_frequency)

    @property
    @pulumi.getter(name="inspectTemplateModifiedCadence")
    def inspect_template_modified_cadence(self) -> Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceInspectTemplateModifiedCadenceArgs']]:
        """
        Governs when to update data profiles when the inspection rules defined by the `InspectTemplate` change. If not set, changing the template will not cause a data profile to update.
        Structure is documented below.
        """
        return pulumi.get(self, "inspect_template_modified_cadence")

    @inspect_template_modified_cadence.setter
    def inspect_template_modified_cadence(self, value: Optional[pulumi.Input['PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceInspectTemplateModifiedCadenceArgs']]):
        pulumi.set(self, "inspect_template_modified_cadence", value)

    @property
    @pulumi.getter(name="refreshFrequency")
    def refresh_frequency(self) -> Optional[pulumi.Input[str]]:
        """
        Data changes in Cloud Storage can't trigger reprofiling. If you set this field, profiles are refreshed at this frequency regardless of whether the underlying buckets have changes. Defaults to never.
        Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
        return pulumi.get(self, "refresh_frequency")

    @refresh_frequency.setter
    def refresh_frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "refresh_frequency", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceInspectTemplateModifiedCadenceArgsDict(TypedDict):
        frequency: NotRequired[pulumi.Input[str]]
        """
        How frequently data profiles can be updated when the template is modified. Defaults to never.
        Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
elif False:
    PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceInspectTemplateModifiedCadenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetCloudStorageTargetGenerationCadenceInspectTemplateModifiedCadenceArgs:
    def __init__(__self__, *,
                 frequency: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] frequency: How frequently data profiles can be updated when the template is modified. Defaults to never.
               Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
        if frequency is not None:
            pulumi.set(__self__, "frequency", frequency)

    @property
    @pulumi.getter
    def frequency(self) -> Optional[pulumi.Input[str]]:
        """
        How frequently data profiles can be updated when the template is modified. Defaults to never.
        Possible values are: `UPDATE_FREQUENCY_NEVER`, `UPDATE_FREQUENCY_DAILY`, `UPDATE_FREQUENCY_MONTHLY`.
        """
        return pulumi.get(self, "frequency")

    @frequency.setter
    def frequency(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "frequency", value)


if not MYPY:
    class PreventionDiscoveryConfigTargetSecretsTargetArgsDict(TypedDict):
        pass
elif False:
    PreventionDiscoveryConfigTargetSecretsTargetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionDiscoveryConfigTargetSecretsTargetArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionInspectTemplateInspectConfigArgsDict(TypedDict):
        content_options: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of options defining data content to scan. If empty, text, images, and other content will be included.
        Each value may be one of: `CONTENT_TEXT`, `CONTENT_IMAGE`.
        """
        custom_info_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeArgsDict']]]]
        """
        Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
        Structure is documented below.
        """
        exclude_info_types: NotRequired[pulumi.Input[bool]]
        """
        When true, excludes type information of the findings.
        """
        include_quote: NotRequired[pulumi.Input[bool]]
        """
        When true, a contextual quote from the data that triggered a finding is included in the response.
        """
        info_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigInfoTypeArgsDict']]]]
        """
        Restricts what infoTypes to look for. The values must correspond to InfoType values returned by infoTypes.list
        or listed at https://cloud.google.com/dlp/docs/infotypes-reference.
        When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run.
        By default this may be all types, but may change over time as detectors are updated.
        Structure is documented below.
        """
        limits: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigLimitsArgsDict']]
        """
        Configuration to control the number of findings returned.
        Structure is documented below.
        """
        min_likelihood: NotRequired[pulumi.Input[str]]
        """
        Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info
        Default value is `POSSIBLE`.
        Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
        """
        rule_sets: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetArgsDict']]]]
        """
        Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end,
        other rules are executed in the order they are specified for each info type.
        Structure is documented below.
        """
elif False:
    PreventionInspectTemplateInspectConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigArgs:
    def __init__(__self__, *,
                 content_options: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 custom_info_types: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeArgs']]]] = None,
                 exclude_info_types: Optional[pulumi.Input[bool]] = None,
                 include_quote: Optional[pulumi.Input[bool]] = None,
                 info_types: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigInfoTypeArgs']]]] = None,
                 limits: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigLimitsArgs']] = None,
                 min_likelihood: Optional[pulumi.Input[str]] = None,
                 rule_sets: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] content_options: List of options defining data content to scan. If empty, text, images, and other content will be included.
               Each value may be one of: `CONTENT_TEXT`, `CONTENT_IMAGE`.
        :param pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeArgs']]] custom_info_types: Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
               Structure is documented below.
        :param pulumi.Input[bool] exclude_info_types: When true, excludes type information of the findings.
        :param pulumi.Input[bool] include_quote: When true, a contextual quote from the data that triggered a finding is included in the response.
        :param pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigInfoTypeArgs']]] info_types: Restricts what infoTypes to look for. The values must correspond to InfoType values returned by infoTypes.list
               or listed at https://cloud.google.com/dlp/docs/infotypes-reference.
               When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run.
               By default this may be all types, but may change over time as detectors are updated.
               Structure is documented below.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigLimitsArgs'] limits: Configuration to control the number of findings returned.
               Structure is documented below.
        :param pulumi.Input[str] min_likelihood: Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info
               Default value is `POSSIBLE`.
               Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
        :param pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetArgs']]] rule_sets: Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end,
               other rules are executed in the order they are specified for each info type.
               Structure is documented below.
        """
        if content_options is not None:
            pulumi.set(__self__, "content_options", content_options)
        if custom_info_types is not None:
            pulumi.set(__self__, "custom_info_types", custom_info_types)
        if exclude_info_types is not None:
            pulumi.set(__self__, "exclude_info_types", exclude_info_types)
        if include_quote is not None:
            pulumi.set(__self__, "include_quote", include_quote)
        if info_types is not None:
            pulumi.set(__self__, "info_types", info_types)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if min_likelihood is not None:
            pulumi.set(__self__, "min_likelihood", min_likelihood)
        if rule_sets is not None:
            pulumi.set(__self__, "rule_sets", rule_sets)

    @property
    @pulumi.getter(name="contentOptions")
    def content_options(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of options defining data content to scan. If empty, text, images, and other content will be included.
        Each value may be one of: `CONTENT_TEXT`, `CONTENT_IMAGE`.
        """
        return pulumi.get(self, "content_options")

    @content_options.setter
    def content_options(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "content_options", value)

    @property
    @pulumi.getter(name="customInfoTypes")
    def custom_info_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeArgs']]]]:
        """
        Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
        Structure is documented below.
        """
        return pulumi.get(self, "custom_info_types")

    @custom_info_types.setter
    def custom_info_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeArgs']]]]):
        pulumi.set(self, "custom_info_types", value)

    @property
    @pulumi.getter(name="excludeInfoTypes")
    def exclude_info_types(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, excludes type information of the findings.
        """
        return pulumi.get(self, "exclude_info_types")

    @exclude_info_types.setter
    def exclude_info_types(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclude_info_types", value)

    @property
    @pulumi.getter(name="includeQuote")
    def include_quote(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, a contextual quote from the data that triggered a finding is included in the response.
        """
        return pulumi.get(self, "include_quote")

    @include_quote.setter
    def include_quote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_quote", value)

    @property
    @pulumi.getter(name="infoTypes")
    def info_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigInfoTypeArgs']]]]:
        """
        Restricts what infoTypes to look for. The values must correspond to InfoType values returned by infoTypes.list
        or listed at https://cloud.google.com/dlp/docs/infotypes-reference.
        When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run.
        By default this may be all types, but may change over time as detectors are updated.
        Structure is documented below.
        """
        return pulumi.get(self, "info_types")

    @info_types.setter
    def info_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigInfoTypeArgs']]]]):
        pulumi.set(self, "info_types", value)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigLimitsArgs']]:
        """
        Configuration to control the number of findings returned.
        Structure is documented below.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigLimitsArgs']]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter(name="minLikelihood")
    def min_likelihood(self) -> Optional[pulumi.Input[str]]:
        """
        Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info
        Default value is `POSSIBLE`.
        Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
        """
        return pulumi.get(self, "min_likelihood")

    @min_likelihood.setter
    def min_likelihood(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_likelihood", value)

    @property
    @pulumi.getter(name="ruleSets")
    def rule_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetArgs']]]]:
        """
        Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end,
        other rules are executed in the order they are specified for each info type.
        Structure is documented below.
        """
        return pulumi.get(self, "rule_sets")

    @rule_sets.setter
    def rule_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetArgs']]]]):
        pulumi.set(self, "rule_sets", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigCustomInfoTypeArgsDict(TypedDict):
        info_type: pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeArgsDict']
        """
        CustomInfoType can either be a new infoType, or an extension of built-in infoType, when the name matches one of existing
        infoTypes and that infoType is specified in `info_types` field. Specifying the latter adds findings to the
        one detected by the system. If built-in info type is not specified in `info_types` list then the name is
        treated as a custom info type.
        Structure is documented below.
        """
        dictionary: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryArgsDict']]
        """
        Dictionary which defines the rule.
        Structure is documented below.
        """
        exclusion_type: NotRequired[pulumi.Input[str]]
        """
        If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
        Possible values are: `EXCLUSION_TYPE_EXCLUDE`.
        """
        likelihood: NotRequired[pulumi.Input[str]]
        """
        Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria
        specified by the rule.
        Default value is `VERY_LIKELY`.
        Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
        """
        regex: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeRegexArgsDict']]
        """
        Regular expression which defines the rule.
        Structure is documented below.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        stored_type: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeStoredTypeArgsDict']]
        """
        A reference to a StoredInfoType to use with scanning.
        Structure is documented below.
        """
        surrogate_type: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeSurrogateTypeArgsDict']]
        """
        Message for detecting output from deidentification transformations that support reversing.
        """
elif False:
    PreventionInspectTemplateInspectConfigCustomInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigCustomInfoTypeArgs:
    def __init__(__self__, *,
                 info_type: pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeArgs'],
                 dictionary: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryArgs']] = None,
                 exclusion_type: Optional[pulumi.Input[str]] = None,
                 likelihood: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeRegexArgs']] = None,
                 sensitivity_score: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeSensitivityScoreArgs']] = None,
                 stored_type: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeStoredTypeArgs']] = None,
                 surrogate_type: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeSurrogateTypeArgs']] = None):
        """
        :param pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeArgs'] info_type: CustomInfoType can either be a new infoType, or an extension of built-in infoType, when the name matches one of existing
               infoTypes and that infoType is specified in `info_types` field. Specifying the latter adds findings to the
               one detected by the system. If built-in info type is not specified in `info_types` list then the name is
               treated as a custom info type.
               Structure is documented below.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryArgs'] dictionary: Dictionary which defines the rule.
               Structure is documented below.
        :param pulumi.Input[str] exclusion_type: If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
               Possible values are: `EXCLUSION_TYPE_EXCLUDE`.
        :param pulumi.Input[str] likelihood: Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria
               specified by the rule.
               Default value is `VERY_LIKELY`.
               Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeRegexArgs'] regex: Regular expression which defines the rule.
               Structure is documented below.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeStoredTypeArgs'] stored_type: A reference to a StoredInfoType to use with scanning.
               Structure is documented below.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeSurrogateTypeArgs'] surrogate_type: Message for detecting output from deidentification transformations that support reversing.
        """
        pulumi.set(__self__, "info_type", info_type)
        if dictionary is not None:
            pulumi.set(__self__, "dictionary", dictionary)
        if exclusion_type is not None:
            pulumi.set(__self__, "exclusion_type", exclusion_type)
        if likelihood is not None:
            pulumi.set(__self__, "likelihood", likelihood)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if stored_type is not None:
            pulumi.set(__self__, "stored_type", stored_type)
        if surrogate_type is not None:
            pulumi.set(__self__, "surrogate_type", surrogate_type)

    @property
    @pulumi.getter(name="infoType")
    def info_type(self) -> pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeArgs']:
        """
        CustomInfoType can either be a new infoType, or an extension of built-in infoType, when the name matches one of existing
        infoTypes and that infoType is specified in `info_types` field. Specifying the latter adds findings to the
        one detected by the system. If built-in info type is not specified in `info_types` list then the name is
        treated as a custom info type.
        Structure is documented below.
        """
        return pulumi.get(self, "info_type")

    @info_type.setter
    def info_type(self, value: pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeArgs']):
        pulumi.set(self, "info_type", value)

    @property
    @pulumi.getter
    def dictionary(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryArgs']]:
        """
        Dictionary which defines the rule.
        Structure is documented below.
        """
        return pulumi.get(self, "dictionary")

    @dictionary.setter
    def dictionary(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryArgs']]):
        pulumi.set(self, "dictionary", value)

    @property
    @pulumi.getter(name="exclusionType")
    def exclusion_type(self) -> Optional[pulumi.Input[str]]:
        """
        If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
        Possible values are: `EXCLUSION_TYPE_EXCLUDE`.
        """
        return pulumi.get(self, "exclusion_type")

    @exclusion_type.setter
    def exclusion_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exclusion_type", value)

    @property
    @pulumi.getter
    def likelihood(self) -> Optional[pulumi.Input[str]]:
        """
        Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria
        specified by the rule.
        Default value is `VERY_LIKELY`.
        Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
        """
        return pulumi.get(self, "likelihood")

    @likelihood.setter
    def likelihood(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "likelihood", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeRegexArgs']]:
        """
        Regular expression which defines the rule.
        Structure is documented below.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeRegexArgs']]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter(name="storedType")
    def stored_type(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeStoredTypeArgs']]:
        """
        A reference to a StoredInfoType to use with scanning.
        Structure is documented below.
        """
        return pulumi.get(self, "stored_type")

    @stored_type.setter
    def stored_type(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeStoredTypeArgs']]):
        pulumi.set(self, "stored_type", value)

    @property
    @pulumi.getter(name="surrogateType")
    def surrogate_type(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeSurrogateTypeArgs']]:
        """
        Message for detecting output from deidentification transformations that support reversing.
        """
        return pulumi.get(self, "surrogate_type")

    @surrogate_type.setter
    def surrogate_type(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeSurrogateTypeArgs']]):
        pulumi.set(self, "surrogate_type", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryArgsDict(TypedDict):
        cloud_storage_path: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgsDict']]
        """
        Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
        Structure is documented below.
        """
        word_list: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryWordListArgsDict']]
        """
        List of words or phrases to search for.
        Structure is documented below.
        """
elif False:
    PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryArgs:
    def __init__(__self__, *,
                 cloud_storage_path: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgs']] = None,
                 word_list: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryWordListArgs']] = None):
        """
        :param pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgs'] cloud_storage_path: Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
               Structure is documented below.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryWordListArgs'] word_list: List of words or phrases to search for.
               Structure is documented below.
        """
        if cloud_storage_path is not None:
            pulumi.set(__self__, "cloud_storage_path", cloud_storage_path)
        if word_list is not None:
            pulumi.set(__self__, "word_list", word_list)

    @property
    @pulumi.getter(name="cloudStoragePath")
    def cloud_storage_path(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgs']]:
        """
        Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_storage_path")

    @cloud_storage_path.setter
    def cloud_storage_path(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgs']]):
        pulumi.set(self, "cloud_storage_path", value)

    @property
    @pulumi.getter(name="wordList")
    def word_list(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryWordListArgs']]:
        """
        List of words or phrases to search for.
        Structure is documented below.
        """
        return pulumi.get(self, "word_list")

    @word_list.setter
    def word_list(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryWordListArgs']]):
        pulumi.set(self, "word_list", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgsDict(TypedDict):
        path: pulumi.Input[str]
        """
        A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
        """
elif False:
    PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str]):
        """
        :param pulumi.Input[str] path: A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
        """
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryWordListArgsDict(TypedDict):
        words: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Words or phrases defining the dictionary. The dictionary must contain at least one
        phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
elif False:
    PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryWordListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigCustomInfoTypeDictionaryWordListArgs:
    def __init__(__self__, *,
                 words: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] words: Words or phrases defining the dictionary. The dictionary must contain at least one
               phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
        pulumi.set(__self__, "words", words)

    @property
    @pulumi.getter
    def words(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Words or phrases defining the dictionary. The dictionary must contain at least one
        phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
        return pulumi.get(self, "words")

    @words.setter
    def words(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "words", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names
        listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version name for this InfoType.
        """
elif False:
    PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 sensitivity_score: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names
               listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input[str] version: Version name for this InfoType.
        """
        pulumi.set(__self__, "name", name)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names
        listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version name for this InfoType.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigCustomInfoTypeRegexArgsDict(TypedDict):
        pattern: pulumi.Input[str]
        """
        Pattern defining the regular expression.
        Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
        group_indexes: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
        """
elif False:
    PreventionInspectTemplateInspectConfigCustomInfoTypeRegexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigCustomInfoTypeRegexArgs:
    def __init__(__self__, *,
                 pattern: pulumi.Input[str],
                 group_indexes: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[str] pattern: Pattern defining the regular expression.
               Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] group_indexes: The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
        """
        pulumi.set(__self__, "pattern", pattern)
        if group_indexes is not None:
            pulumi.set(__self__, "group_indexes", group_indexes)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        Pattern defining the regular expression.
        Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter(name="groupIndexes")
    def group_indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
        """
        return pulumi.get(self, "group_indexes")

    @group_indexes.setter
    def group_indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "group_indexes", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigCustomInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionInspectTemplateInspectConfigCustomInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigCustomInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigCustomInfoTypeStoredTypeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Resource name of the requested StoredInfoType, for example `organizations/433245324/storedInfoTypes/432452342`
        or `projects/project-id/storedInfoTypes/432452342`.
        """
elif False:
    PreventionInspectTemplateInspectConfigCustomInfoTypeStoredTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigCustomInfoTypeStoredTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Resource name of the requested StoredInfoType, for example `organizations/433245324/storedInfoTypes/432452342`
               or `projects/project-id/storedInfoTypes/432452342`.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Resource name of the requested StoredInfoType, for example `organizations/433245324/storedInfoTypes/432452342`
        or `projects/project-id/storedInfoTypes/432452342`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigCustomInfoTypeSurrogateTypeArgsDict(TypedDict):
        pass
elif False:
    PreventionInspectTemplateInspectConfigCustomInfoTypeSurrogateTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigCustomInfoTypeSurrogateTypeArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionInspectTemplateInspectConfigInfoTypeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
        at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version name for this InfoType.
        """
elif False:
    PreventionInspectTemplateInspectConfigInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigInfoTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 sensitivity_score: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigInfoTypeSensitivityScoreArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
               at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input[str] version: Version name for this InfoType.
        """
        pulumi.set(__self__, "name", name)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
        at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version name for this InfoType.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionInspectTemplateInspectConfigInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigLimitsArgsDict(TypedDict):
        max_findings_per_item: pulumi.Input[int]
        """
        Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
        """
        max_findings_per_request: pulumi.Input[int]
        """
        Max number of findings that will be returned per request/job. The maximum returned is 2000.
        """
        max_findings_per_info_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeArgsDict']]]]
        """
        Configuration of findings limit given for specified infoTypes.
        Structure is documented below.
        """
elif False:
    PreventionInspectTemplateInspectConfigLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigLimitsArgs:
    def __init__(__self__, *,
                 max_findings_per_item: pulumi.Input[int],
                 max_findings_per_request: pulumi.Input[int],
                 max_findings_per_info_types: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeArgs']]]] = None):
        """
        :param pulumi.Input[int] max_findings_per_item: Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
        :param pulumi.Input[int] max_findings_per_request: Max number of findings that will be returned per request/job. The maximum returned is 2000.
        :param pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeArgs']]] max_findings_per_info_types: Configuration of findings limit given for specified infoTypes.
               Structure is documented below.
        """
        pulumi.set(__self__, "max_findings_per_item", max_findings_per_item)
        pulumi.set(__self__, "max_findings_per_request", max_findings_per_request)
        if max_findings_per_info_types is not None:
            pulumi.set(__self__, "max_findings_per_info_types", max_findings_per_info_types)

    @property
    @pulumi.getter(name="maxFindingsPerItem")
    def max_findings_per_item(self) -> pulumi.Input[int]:
        """
        Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
        """
        return pulumi.get(self, "max_findings_per_item")

    @max_findings_per_item.setter
    def max_findings_per_item(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_findings_per_item", value)

    @property
    @pulumi.getter(name="maxFindingsPerRequest")
    def max_findings_per_request(self) -> pulumi.Input[int]:
        """
        Max number of findings that will be returned per request/job. The maximum returned is 2000.
        """
        return pulumi.get(self, "max_findings_per_request")

    @max_findings_per_request.setter
    def max_findings_per_request(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_findings_per_request", value)

    @property
    @pulumi.getter(name="maxFindingsPerInfoTypes")
    def max_findings_per_info_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeArgs']]]]:
        """
        Configuration of findings limit given for specified infoTypes.
        Structure is documented below.
        """
        return pulumi.get(self, "max_findings_per_info_types")

    @max_findings_per_info_types.setter
    def max_findings_per_info_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeArgs']]]]):
        pulumi.set(self, "max_findings_per_info_types", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeArgsDict(TypedDict):
        max_findings: pulumi.Input[int]
        """
        Max findings limit for the given infoType.
        """
        info_type: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgsDict']]
        """
        Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
        not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
        specified in another InfoTypeLimit.
        Structure is documented below.
        """
elif False:
    PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeArgs:
    def __init__(__self__, *,
                 max_findings: pulumi.Input[int],
                 info_type: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgs']] = None):
        """
        :param pulumi.Input[int] max_findings: Max findings limit for the given infoType.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgs'] info_type: Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
               not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
               specified in another InfoTypeLimit.
               Structure is documented below.
        """
        pulumi.set(__self__, "max_findings", max_findings)
        if info_type is not None:
            pulumi.set(__self__, "info_type", info_type)

    @property
    @pulumi.getter(name="maxFindings")
    def max_findings(self) -> pulumi.Input[int]:
        """
        Max findings limit for the given infoType.
        """
        return pulumi.get(self, "max_findings")

    @max_findings.setter
    def max_findings(self, value: pulumi.Input[int]):
        pulumi.set(self, "max_findings", value)

    @property
    @pulumi.getter(name="infoType")
    def info_type(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgs']]:
        """
        Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
        not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
        specified in another InfoTypeLimit.
        Structure is documented below.
        """
        return pulumi.get(self, "info_type")

    @info_type.setter
    def info_type(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgs']]):
        pulumi.set(self, "info_type", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names
        listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version name for this InfoType.
        """
elif False:
    PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 sensitivity_score: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names
               listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input[str] version: Version name for this InfoType.
        """
        pulumi.set(__self__, "name", name)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names
        listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version name for this InfoType.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigRuleSetArgsDict(TypedDict):
        info_types: pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetInfoTypeArgsDict']]]
        """
        List of infoTypes this rule set is applied to.
        Structure is documented below.
        """
        rules: pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleArgsDict']]]
        """
        Set of rules to be applied to infoTypes. The rules are applied in order.
        Structure is documented below.
        """
elif False:
    PreventionInspectTemplateInspectConfigRuleSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigRuleSetArgs:
    def __init__(__self__, *,
                 info_types: pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetInfoTypeArgs']]],
                 rules: pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetInfoTypeArgs']]] info_types: List of infoTypes this rule set is applied to.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleArgs']]] rules: Set of rules to be applied to infoTypes. The rules are applied in order.
               Structure is documented below.
        """
        pulumi.set(__self__, "info_types", info_types)
        pulumi.set(__self__, "rules", rules)

    @property
    @pulumi.getter(name="infoTypes")
    def info_types(self) -> pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetInfoTypeArgs']]]:
        """
        List of infoTypes this rule set is applied to.
        Structure is documented below.
        """
        return pulumi.get(self, "info_types")

    @info_types.setter
    def info_types(self, value: pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetInfoTypeArgs']]]):
        pulumi.set(self, "info_types", value)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleArgs']]]:
        """
        Set of rules to be applied to infoTypes. The rules are applied in order.
        Structure is documented below.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleArgs']]]):
        pulumi.set(self, "rules", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigRuleSetInfoTypeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
        at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version name for this InfoType.
        """
elif False:
    PreventionInspectTemplateInspectConfigRuleSetInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigRuleSetInfoTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 sensitivity_score: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetInfoTypeSensitivityScoreArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
               at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input[str] version: Version name for this InfoType.
        """
        pulumi.set(__self__, "name", name)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
        at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version name for this InfoType.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigRuleSetInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionInspectTemplateInspectConfigRuleSetInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigRuleSetInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigRuleSetRuleArgsDict(TypedDict):
        exclusion_rule: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleArgsDict']]
        """
        The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
        Structure is documented below.
        """
        hotword_rule: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleArgsDict']]
        """
        Hotword-based detection rule.
        Structure is documented below.
        """
elif False:
    PreventionInspectTemplateInspectConfigRuleSetRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigRuleSetRuleArgs:
    def __init__(__self__, *,
                 exclusion_rule: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleArgs']] = None,
                 hotword_rule: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleArgs']] = None):
        """
        :param pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleArgs'] exclusion_rule: The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
               Structure is documented below.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleArgs'] hotword_rule: Hotword-based detection rule.
               Structure is documented below.
        """
        if exclusion_rule is not None:
            pulumi.set(__self__, "exclusion_rule", exclusion_rule)
        if hotword_rule is not None:
            pulumi.set(__self__, "hotword_rule", hotword_rule)

    @property
    @pulumi.getter(name="exclusionRule")
    def exclusion_rule(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleArgs']]:
        """
        The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
        Structure is documented below.
        """
        return pulumi.get(self, "exclusion_rule")

    @exclusion_rule.setter
    def exclusion_rule(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleArgs']]):
        pulumi.set(self, "exclusion_rule", value)

    @property
    @pulumi.getter(name="hotwordRule")
    def hotword_rule(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleArgs']]:
        """
        Hotword-based detection rule.
        Structure is documented below.
        """
        return pulumi.get(self, "hotword_rule")

    @hotword_rule.setter
    def hotword_rule(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleArgs']]):
        pulumi.set(self, "hotword_rule", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleArgsDict(TypedDict):
        matching_type: pulumi.Input[str]
        """
        How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType
        Possible values are: `MATCHING_TYPE_FULL_MATCH`, `MATCHING_TYPE_PARTIAL_MATCH`, `MATCHING_TYPE_INVERSE_MATCH`.
        """
        dictionary: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryArgsDict']]
        """
        Dictionary which defines the rule.
        Structure is documented below.
        """
        exclude_by_hotword: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgsDict']]
        """
        Drop if the hotword rule is contained in the proximate context.
        For tabular data, the context includes the column name.
        Structure is documented below.
        """
        exclude_info_types: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgsDict']]
        """
        Set of infoTypes for which findings would affect this rule.
        Structure is documented below.
        """
        regex: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleRegexArgsDict']]
        """
        Regular expression which defines the rule.
        Structure is documented below.
        """
elif False:
    PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleArgs:
    def __init__(__self__, *,
                 matching_type: pulumi.Input[str],
                 dictionary: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryArgs']] = None,
                 exclude_by_hotword: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgs']] = None,
                 exclude_info_types: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgs']] = None,
                 regex: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleRegexArgs']] = None):
        """
        :param pulumi.Input[str] matching_type: How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType
               Possible values are: `MATCHING_TYPE_FULL_MATCH`, `MATCHING_TYPE_PARTIAL_MATCH`, `MATCHING_TYPE_INVERSE_MATCH`.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryArgs'] dictionary: Dictionary which defines the rule.
               Structure is documented below.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgs'] exclude_by_hotword: Drop if the hotword rule is contained in the proximate context.
               For tabular data, the context includes the column name.
               Structure is documented below.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgs'] exclude_info_types: Set of infoTypes for which findings would affect this rule.
               Structure is documented below.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleRegexArgs'] regex: Regular expression which defines the rule.
               Structure is documented below.
        """
        pulumi.set(__self__, "matching_type", matching_type)
        if dictionary is not None:
            pulumi.set(__self__, "dictionary", dictionary)
        if exclude_by_hotword is not None:
            pulumi.set(__self__, "exclude_by_hotword", exclude_by_hotword)
        if exclude_info_types is not None:
            pulumi.set(__self__, "exclude_info_types", exclude_info_types)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter(name="matchingType")
    def matching_type(self) -> pulumi.Input[str]:
        """
        How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType
        Possible values are: `MATCHING_TYPE_FULL_MATCH`, `MATCHING_TYPE_PARTIAL_MATCH`, `MATCHING_TYPE_INVERSE_MATCH`.
        """
        return pulumi.get(self, "matching_type")

    @matching_type.setter
    def matching_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "matching_type", value)

    @property
    @pulumi.getter
    def dictionary(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryArgs']]:
        """
        Dictionary which defines the rule.
        Structure is documented below.
        """
        return pulumi.get(self, "dictionary")

    @dictionary.setter
    def dictionary(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryArgs']]):
        pulumi.set(self, "dictionary", value)

    @property
    @pulumi.getter(name="excludeByHotword")
    def exclude_by_hotword(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgs']]:
        """
        Drop if the hotword rule is contained in the proximate context.
        For tabular data, the context includes the column name.
        Structure is documented below.
        """
        return pulumi.get(self, "exclude_by_hotword")

    @exclude_by_hotword.setter
    def exclude_by_hotword(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgs']]):
        pulumi.set(self, "exclude_by_hotword", value)

    @property
    @pulumi.getter(name="excludeInfoTypes")
    def exclude_info_types(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgs']]:
        """
        Set of infoTypes for which findings would affect this rule.
        Structure is documented below.
        """
        return pulumi.get(self, "exclude_info_types")

    @exclude_info_types.setter
    def exclude_info_types(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgs']]):
        pulumi.set(self, "exclude_info_types", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleRegexArgs']]:
        """
        Regular expression which defines the rule.
        Structure is documented below.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleRegexArgs']]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryArgsDict(TypedDict):
        cloud_storage_path: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgsDict']]
        """
        Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
        Structure is documented below.
        """
        word_list: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgsDict']]
        """
        List of words or phrases to search for.
        Structure is documented below.
        """
elif False:
    PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryArgs:
    def __init__(__self__, *,
                 cloud_storage_path: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgs']] = None,
                 word_list: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgs']] = None):
        """
        :param pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgs'] cloud_storage_path: Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
               Structure is documented below.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgs'] word_list: List of words or phrases to search for.
               Structure is documented below.
        """
        if cloud_storage_path is not None:
            pulumi.set(__self__, "cloud_storage_path", cloud_storage_path)
        if word_list is not None:
            pulumi.set(__self__, "word_list", word_list)

    @property
    @pulumi.getter(name="cloudStoragePath")
    def cloud_storage_path(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgs']]:
        """
        Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_storage_path")

    @cloud_storage_path.setter
    def cloud_storage_path(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgs']]):
        pulumi.set(self, "cloud_storage_path", value)

    @property
    @pulumi.getter(name="wordList")
    def word_list(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgs']]:
        """
        List of words or phrases to search for.
        Structure is documented below.
        """
        return pulumi.get(self, "word_list")

    @word_list.setter
    def word_list(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgs']]):
        pulumi.set(self, "word_list", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgsDict(TypedDict):
        path: pulumi.Input[str]
        """
        A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
        """
elif False:
    PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str]):
        """
        :param pulumi.Input[str] path: A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
        """
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgsDict(TypedDict):
        words: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Words or phrases defining the dictionary. The dictionary must contain at least one
        phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
elif False:
    PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgs:
    def __init__(__self__, *,
                 words: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] words: Words or phrases defining the dictionary. The dictionary must contain at least one
               phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
        pulumi.set(__self__, "words", words)

    @property
    @pulumi.getter
    def words(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Words or phrases defining the dictionary. The dictionary must contain at least one
        phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
        return pulumi.get(self, "words")

    @words.setter
    def words(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "words", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgsDict(TypedDict):
        hotword_regex: pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgsDict']
        """
        Regular expression pattern defining what qualifies as a hotword.
        Structure is documented below.
        """
        proximity: pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgsDict']
        """
        Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
        exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
        used to match substrings of the finding itself. For example, the certainty of a phone number regex
        `(\\d{3}) \\d{3}-\\d{4}` could be adjusted upwards if the area code is known to be the local area code of a company
        office using the hotword regex `(xxx)`, where `xxx` is the area code in question.
        Structure is documented below.
        """
elif False:
    PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgs:
    def __init__(__self__, *,
                 hotword_regex: pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgs'],
                 proximity: pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgs']):
        """
        :param pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgs'] hotword_regex: Regular expression pattern defining what qualifies as a hotword.
               Structure is documented below.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgs'] proximity: Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
               exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
               used to match substrings of the finding itself. For example, the certainty of a phone number regex
               `(\\d{3}) \\d{3}-\\d{4}` could be adjusted upwards if the area code is known to be the local area code of a company
               office using the hotword regex `(xxx)`, where `xxx` is the area code in question.
               Structure is documented below.
        """
        pulumi.set(__self__, "hotword_regex", hotword_regex)
        pulumi.set(__self__, "proximity", proximity)

    @property
    @pulumi.getter(name="hotwordRegex")
    def hotword_regex(self) -> pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgs']:
        """
        Regular expression pattern defining what qualifies as a hotword.
        Structure is documented below.
        """
        return pulumi.get(self, "hotword_regex")

    @hotword_regex.setter
    def hotword_regex(self, value: pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgs']):
        pulumi.set(self, "hotword_regex", value)

    @property
    @pulumi.getter
    def proximity(self) -> pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgs']:
        """
        Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
        exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
        used to match substrings of the finding itself. For example, the certainty of a phone number regex
        `(\\d{3}) \\d{3}-\\d{4}` could be adjusted upwards if the area code is known to be the local area code of a company
        office using the hotword regex `(xxx)`, where `xxx` is the area code in question.
        Structure is documented below.
        """
        return pulumi.get(self, "proximity")

    @proximity.setter
    def proximity(self, value: pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgs']):
        pulumi.set(self, "proximity", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgsDict(TypedDict):
        pattern: pulumi.Input[str]
        """
        Pattern defining the regular expression. Its syntax
        (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
        group_indexes: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        The index of the submatch to extract as findings. When not specified,
        the entire match is returned. No more than 3 may be included.
        """
elif False:
    PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgs:
    def __init__(__self__, *,
                 pattern: pulumi.Input[str],
                 group_indexes: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[str] pattern: Pattern defining the regular expression. Its syntax
               (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] group_indexes: The index of the submatch to extract as findings. When not specified,
               the entire match is returned. No more than 3 may be included.
        """
        pulumi.set(__self__, "pattern", pattern)
        if group_indexes is not None:
            pulumi.set(__self__, "group_indexes", group_indexes)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        Pattern defining the regular expression. Its syntax
        (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter(name="groupIndexes")
    def group_indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The index of the submatch to extract as findings. When not specified,
        the entire match is returned. No more than 3 may be included.
        """
        return pulumi.get(self, "group_indexes")

    @group_indexes.setter
    def group_indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "group_indexes", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgsDict(TypedDict):
        window_after: NotRequired[pulumi.Input[int]]
        """
        Number of characters after the finding to consider.
        """
        window_before: NotRequired[pulumi.Input[int]]
        """
        Number of characters before the finding to consider.
        """
elif False:
    PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgs:
    def __init__(__self__, *,
                 window_after: Optional[pulumi.Input[int]] = None,
                 window_before: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] window_after: Number of characters after the finding to consider.
        :param pulumi.Input[int] window_before: Number of characters before the finding to consider.
        """
        if window_after is not None:
            pulumi.set(__self__, "window_after", window_after)
        if window_before is not None:
            pulumi.set(__self__, "window_before", window_before)

    @property
    @pulumi.getter(name="windowAfter")
    def window_after(self) -> Optional[pulumi.Input[int]]:
        """
        Number of characters after the finding to consider.
        """
        return pulumi.get(self, "window_after")

    @window_after.setter
    def window_after(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "window_after", value)

    @property
    @pulumi.getter(name="windowBefore")
    def window_before(self) -> Optional[pulumi.Input[int]]:
        """
        Number of characters before the finding to consider.
        """
        return pulumi.get(self, "window_before")

    @window_before.setter
    def window_before(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "window_before", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgsDict(TypedDict):
        info_types: pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgsDict']]]
        """
        If a finding is matched by any of the infoType detectors listed here, the finding will be excluded from the scan results.
        Structure is documented below.
        """
elif False:
    PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgs:
    def __init__(__self__, *,
                 info_types: pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgs']]] info_types: If a finding is matched by any of the infoType detectors listed here, the finding will be excluded from the scan results.
               Structure is documented below.
        """
        pulumi.set(__self__, "info_types", info_types)

    @property
    @pulumi.getter(name="infoTypes")
    def info_types(self) -> pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgs']]]:
        """
        If a finding is matched by any of the infoType detectors listed here, the finding will be excluded from the scan results.
        Structure is documented below.
        """
        return pulumi.get(self, "info_types")

    @info_types.setter
    def info_types(self, value: pulumi.Input[Sequence[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgs']]]):
        pulumi.set(self, "info_types", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
        at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version name for this InfoType.
        """
elif False:
    PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 sensitivity_score: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
               at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input[str] version: Version name for this InfoType.
        """
        pulumi.set(__self__, "name", name)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
        at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version name for this InfoType.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleRegexArgsDict(TypedDict):
        pattern: pulumi.Input[str]
        """
        Pattern defining the regular expression.
        Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
        group_indexes: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
        """
elif False:
    PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleRegexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigRuleSetRuleExclusionRuleRegexArgs:
    def __init__(__self__, *,
                 pattern: pulumi.Input[str],
                 group_indexes: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[str] pattern: Pattern defining the regular expression.
               Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] group_indexes: The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
        """
        pulumi.set(__self__, "pattern", pattern)
        if group_indexes is not None:
            pulumi.set(__self__, "group_indexes", group_indexes)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        Pattern defining the regular expression.
        Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter(name="groupIndexes")
    def group_indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
        """
        return pulumi.get(self, "group_indexes")

    @group_indexes.setter
    def group_indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "group_indexes", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleArgsDict(TypedDict):
        hotword_regex: pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgsDict']
        """
        Regular expression pattern defining what qualifies as a hotword.
        Structure is documented below.
        """
        likelihood_adjustment: pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgsDict']
        """
        Likelihood adjustment to apply to all matching findings.
        Structure is documented below.
        """
        proximity: pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleProximityArgsDict']
        """
        Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
        exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
        used to match substrings of the finding itself. For example, the certainty of a phone number regex
        `(\\d{3}) \\d{3}-\\d{4}` could be adjusted upwards if the area code is known to be the local area code of a company
        office using the hotword regex `(xxx)`, where `xxx` is the area code in question.
        Structure is documented below.
        """
elif False:
    PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleArgs:
    def __init__(__self__, *,
                 hotword_regex: pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgs'],
                 likelihood_adjustment: pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgs'],
                 proximity: pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleProximityArgs']):
        """
        :param pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgs'] hotword_regex: Regular expression pattern defining what qualifies as a hotword.
               Structure is documented below.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgs'] likelihood_adjustment: Likelihood adjustment to apply to all matching findings.
               Structure is documented below.
        :param pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleProximityArgs'] proximity: Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
               exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
               used to match substrings of the finding itself. For example, the certainty of a phone number regex
               `(\\d{3}) \\d{3}-\\d{4}` could be adjusted upwards if the area code is known to be the local area code of a company
               office using the hotword regex `(xxx)`, where `xxx` is the area code in question.
               Structure is documented below.
        """
        pulumi.set(__self__, "hotword_regex", hotword_regex)
        pulumi.set(__self__, "likelihood_adjustment", likelihood_adjustment)
        pulumi.set(__self__, "proximity", proximity)

    @property
    @pulumi.getter(name="hotwordRegex")
    def hotword_regex(self) -> pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgs']:
        """
        Regular expression pattern defining what qualifies as a hotword.
        Structure is documented below.
        """
        return pulumi.get(self, "hotword_regex")

    @hotword_regex.setter
    def hotword_regex(self, value: pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgs']):
        pulumi.set(self, "hotword_regex", value)

    @property
    @pulumi.getter(name="likelihoodAdjustment")
    def likelihood_adjustment(self) -> pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgs']:
        """
        Likelihood adjustment to apply to all matching findings.
        Structure is documented below.
        """
        return pulumi.get(self, "likelihood_adjustment")

    @likelihood_adjustment.setter
    def likelihood_adjustment(self, value: pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgs']):
        pulumi.set(self, "likelihood_adjustment", value)

    @property
    @pulumi.getter
    def proximity(self) -> pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleProximityArgs']:
        """
        Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
        exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
        used to match substrings of the finding itself. For example, the certainty of a phone number regex
        `(\\d{3}) \\d{3}-\\d{4}` could be adjusted upwards if the area code is known to be the local area code of a company
        office using the hotword regex `(xxx)`, where `xxx` is the area code in question.
        Structure is documented below.
        """
        return pulumi.get(self, "proximity")

    @proximity.setter
    def proximity(self, value: pulumi.Input['PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleProximityArgs']):
        pulumi.set(self, "proximity", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgsDict(TypedDict):
        pattern: pulumi.Input[str]
        """
        Pattern defining the regular expression. Its syntax
        (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
        group_indexes: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        The index of the submatch to extract as findings. When not specified,
        the entire match is returned. No more than 3 may be included.
        """
elif False:
    PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgs:
    def __init__(__self__, *,
                 pattern: pulumi.Input[str],
                 group_indexes: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[str] pattern: Pattern defining the regular expression. Its syntax
               (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] group_indexes: The index of the submatch to extract as findings. When not specified,
               the entire match is returned. No more than 3 may be included.
        """
        pulumi.set(__self__, "pattern", pattern)
        if group_indexes is not None:
            pulumi.set(__self__, "group_indexes", group_indexes)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        Pattern defining the regular expression. Its syntax
        (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter(name="groupIndexes")
    def group_indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The index of the submatch to extract as findings. When not specified,
        the entire match is returned. No more than 3 may be included.
        """
        return pulumi.get(self, "group_indexes")

    @group_indexes.setter
    def group_indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "group_indexes", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgsDict(TypedDict):
        fixed_likelihood: NotRequired[pulumi.Input[str]]
        """
        Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set.
        Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
        """
        relative_likelihood: NotRequired[pulumi.Input[int]]
        """
        Increase or decrease the likelihood by the specified number of levels. For example,
        if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1,
        then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY.
        Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an
        adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY
        will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
        """
elif False:
    PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgs:
    def __init__(__self__, *,
                 fixed_likelihood: Optional[pulumi.Input[str]] = None,
                 relative_likelihood: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] fixed_likelihood: Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set.
               Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
        :param pulumi.Input[int] relative_likelihood: Increase or decrease the likelihood by the specified number of levels. For example,
               if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1,
               then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY.
               Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an
               adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY
               will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
        """
        if fixed_likelihood is not None:
            pulumi.set(__self__, "fixed_likelihood", fixed_likelihood)
        if relative_likelihood is not None:
            pulumi.set(__self__, "relative_likelihood", relative_likelihood)

    @property
    @pulumi.getter(name="fixedLikelihood")
    def fixed_likelihood(self) -> Optional[pulumi.Input[str]]:
        """
        Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set.
        Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
        """
        return pulumi.get(self, "fixed_likelihood")

    @fixed_likelihood.setter
    def fixed_likelihood(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fixed_likelihood", value)

    @property
    @pulumi.getter(name="relativeLikelihood")
    def relative_likelihood(self) -> Optional[pulumi.Input[int]]:
        """
        Increase or decrease the likelihood by the specified number of levels. For example,
        if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1,
        then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY.
        Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an
        adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY
        will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
        """
        return pulumi.get(self, "relative_likelihood")

    @relative_likelihood.setter
    def relative_likelihood(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "relative_likelihood", value)


if not MYPY:
    class PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleProximityArgsDict(TypedDict):
        window_after: NotRequired[pulumi.Input[int]]
        """
        Number of characters after the finding to consider.
        """
        window_before: NotRequired[pulumi.Input[int]]
        """
        Number of characters before the finding to consider.
        """
elif False:
    PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleProximityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionInspectTemplateInspectConfigRuleSetRuleHotwordRuleProximityArgs:
    def __init__(__self__, *,
                 window_after: Optional[pulumi.Input[int]] = None,
                 window_before: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] window_after: Number of characters after the finding to consider.
        :param pulumi.Input[int] window_before: Number of characters before the finding to consider.
        """
        if window_after is not None:
            pulumi.set(__self__, "window_after", window_after)
        if window_before is not None:
            pulumi.set(__self__, "window_before", window_before)

    @property
    @pulumi.getter(name="windowAfter")
    def window_after(self) -> Optional[pulumi.Input[int]]:
        """
        Number of characters after the finding to consider.
        """
        return pulumi.get(self, "window_after")

    @window_after.setter
    def window_after(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "window_after", value)

    @property
    @pulumi.getter(name="windowBefore")
    def window_before(self) -> Optional[pulumi.Input[int]]:
        """
        Number of characters before the finding to consider.
        """
        return pulumi.get(self, "window_before")

    @window_before.setter
    def window_before(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "window_before", value)


if not MYPY:
    class PreventionJobTriggerInspectJobArgsDict(TypedDict):
        storage_config: pulumi.Input['PreventionJobTriggerInspectJobStorageConfigArgsDict']
        """
        Information on where to inspect
        Structure is documented below.
        """
        actions: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobActionArgsDict']]]]
        """
        Configuration block for the actions to execute on the completion of a job. Can be specified multiple times, but only one for each type. Each action block supports fields documented below. This argument is processed in attribute-as-blocks mode.
        Structure is documented below.
        """
        inspect_config: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigArgsDict']]
        """
        The core content of the template.
        Structure is documented below.
        """
        inspect_template_name: NotRequired[pulumi.Input[str]]
        """
        The name of the template to run when this job is triggered.
        """
elif False:
    PreventionJobTriggerInspectJobArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobArgs:
    def __init__(__self__, *,
                 storage_config: pulumi.Input['PreventionJobTriggerInspectJobStorageConfigArgs'],
                 actions: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobActionArgs']]]] = None,
                 inspect_config: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigArgs']] = None,
                 inspect_template_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PreventionJobTriggerInspectJobStorageConfigArgs'] storage_config: Information on where to inspect
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobActionArgs']]] actions: Configuration block for the actions to execute on the completion of a job. Can be specified multiple times, but only one for each type. Each action block supports fields documented below. This argument is processed in attribute-as-blocks mode.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigArgs'] inspect_config: The core content of the template.
               Structure is documented below.
        :param pulumi.Input[str] inspect_template_name: The name of the template to run when this job is triggered.
        """
        pulumi.set(__self__, "storage_config", storage_config)
        if actions is not None:
            pulumi.set(__self__, "actions", actions)
        if inspect_config is not None:
            pulumi.set(__self__, "inspect_config", inspect_config)
        if inspect_template_name is not None:
            pulumi.set(__self__, "inspect_template_name", inspect_template_name)

    @property
    @pulumi.getter(name="storageConfig")
    def storage_config(self) -> pulumi.Input['PreventionJobTriggerInspectJobStorageConfigArgs']:
        """
        Information on where to inspect
        Structure is documented below.
        """
        return pulumi.get(self, "storage_config")

    @storage_config.setter
    def storage_config(self, value: pulumi.Input['PreventionJobTriggerInspectJobStorageConfigArgs']):
        pulumi.set(self, "storage_config", value)

    @property
    @pulumi.getter
    def actions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobActionArgs']]]]:
        """
        Configuration block for the actions to execute on the completion of a job. Can be specified multiple times, but only one for each type. Each action block supports fields documented below. This argument is processed in attribute-as-blocks mode.
        Structure is documented below.
        """
        return pulumi.get(self, "actions")

    @actions.setter
    def actions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobActionArgs']]]]):
        pulumi.set(self, "actions", value)

    @property
    @pulumi.getter(name="inspectConfig")
    def inspect_config(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigArgs']]:
        """
        The core content of the template.
        Structure is documented below.
        """
        return pulumi.get(self, "inspect_config")

    @inspect_config.setter
    def inspect_config(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigArgs']]):
        pulumi.set(self, "inspect_config", value)

    @property
    @pulumi.getter(name="inspectTemplateName")
    def inspect_template_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the template to run when this job is triggered.
        """
        return pulumi.get(self, "inspect_template_name")

    @inspect_template_name.setter
    def inspect_template_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "inspect_template_name", value)


if not MYPY:
    class PreventionJobTriggerInspectJobActionArgsDict(TypedDict):
        deidentify: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyArgsDict']]
        """
        Create a de-identified copy of the requested table or files.
        Structure is documented below.
        """
        job_notification_emails: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobActionJobNotificationEmailsArgsDict']]
        """
        Sends an email when the job completes. The email goes to IAM project owners and technical Essential Contacts.
        """
        pub_sub: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobActionPubSubArgsDict']]
        """
        Publish a message into a given Pub/Sub topic when the job completes.
        Structure is documented below.
        """
        publish_findings_to_cloud_data_catalog: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobActionPublishFindingsToCloudDataCatalogArgsDict']]
        """
        Publish findings of a DlpJob to Data Catalog.
        """
        publish_summary_to_cscc: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobActionPublishSummaryToCsccArgsDict']]
        """
        Publish the result summary of a DlpJob to the Cloud Security Command Center.
        """
        publish_to_stackdriver: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobActionPublishToStackdriverArgsDict']]
        """
        Enable Stackdriver metric dlp.googleapis.com/findingCount.
        """
        save_findings: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobActionSaveFindingsArgsDict']]
        """
        If set, the detailed findings will be persisted to the specified OutputStorageConfig. Only a single instance of this action can be specified. Compatible with: Inspect, Risk
        Structure is documented below.
        """
elif False:
    PreventionJobTriggerInspectJobActionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobActionArgs:
    def __init__(__self__, *,
                 deidentify: Optional[pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyArgs']] = None,
                 job_notification_emails: Optional[pulumi.Input['PreventionJobTriggerInspectJobActionJobNotificationEmailsArgs']] = None,
                 pub_sub: Optional[pulumi.Input['PreventionJobTriggerInspectJobActionPubSubArgs']] = None,
                 publish_findings_to_cloud_data_catalog: Optional[pulumi.Input['PreventionJobTriggerInspectJobActionPublishFindingsToCloudDataCatalogArgs']] = None,
                 publish_summary_to_cscc: Optional[pulumi.Input['PreventionJobTriggerInspectJobActionPublishSummaryToCsccArgs']] = None,
                 publish_to_stackdriver: Optional[pulumi.Input['PreventionJobTriggerInspectJobActionPublishToStackdriverArgs']] = None,
                 save_findings: Optional[pulumi.Input['PreventionJobTriggerInspectJobActionSaveFindingsArgs']] = None):
        """
        :param pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyArgs'] deidentify: Create a de-identified copy of the requested table or files.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobActionJobNotificationEmailsArgs'] job_notification_emails: Sends an email when the job completes. The email goes to IAM project owners and technical Essential Contacts.
        :param pulumi.Input['PreventionJobTriggerInspectJobActionPubSubArgs'] pub_sub: Publish a message into a given Pub/Sub topic when the job completes.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobActionPublishFindingsToCloudDataCatalogArgs'] publish_findings_to_cloud_data_catalog: Publish findings of a DlpJob to Data Catalog.
        :param pulumi.Input['PreventionJobTriggerInspectJobActionPublishSummaryToCsccArgs'] publish_summary_to_cscc: Publish the result summary of a DlpJob to the Cloud Security Command Center.
        :param pulumi.Input['PreventionJobTriggerInspectJobActionPublishToStackdriverArgs'] publish_to_stackdriver: Enable Stackdriver metric dlp.googleapis.com/findingCount.
        :param pulumi.Input['PreventionJobTriggerInspectJobActionSaveFindingsArgs'] save_findings: If set, the detailed findings will be persisted to the specified OutputStorageConfig. Only a single instance of this action can be specified. Compatible with: Inspect, Risk
               Structure is documented below.
        """
        if deidentify is not None:
            pulumi.set(__self__, "deidentify", deidentify)
        if job_notification_emails is not None:
            pulumi.set(__self__, "job_notification_emails", job_notification_emails)
        if pub_sub is not None:
            pulumi.set(__self__, "pub_sub", pub_sub)
        if publish_findings_to_cloud_data_catalog is not None:
            pulumi.set(__self__, "publish_findings_to_cloud_data_catalog", publish_findings_to_cloud_data_catalog)
        if publish_summary_to_cscc is not None:
            pulumi.set(__self__, "publish_summary_to_cscc", publish_summary_to_cscc)
        if publish_to_stackdriver is not None:
            pulumi.set(__self__, "publish_to_stackdriver", publish_to_stackdriver)
        if save_findings is not None:
            pulumi.set(__self__, "save_findings", save_findings)

    @property
    @pulumi.getter
    def deidentify(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyArgs']]:
        """
        Create a de-identified copy of the requested table or files.
        Structure is documented below.
        """
        return pulumi.get(self, "deidentify")

    @deidentify.setter
    def deidentify(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyArgs']]):
        pulumi.set(self, "deidentify", value)

    @property
    @pulumi.getter(name="jobNotificationEmails")
    def job_notification_emails(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobActionJobNotificationEmailsArgs']]:
        """
        Sends an email when the job completes. The email goes to IAM project owners and technical Essential Contacts.
        """
        return pulumi.get(self, "job_notification_emails")

    @job_notification_emails.setter
    def job_notification_emails(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobActionJobNotificationEmailsArgs']]):
        pulumi.set(self, "job_notification_emails", value)

    @property
    @pulumi.getter(name="pubSub")
    def pub_sub(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobActionPubSubArgs']]:
        """
        Publish a message into a given Pub/Sub topic when the job completes.
        Structure is documented below.
        """
        return pulumi.get(self, "pub_sub")

    @pub_sub.setter
    def pub_sub(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobActionPubSubArgs']]):
        pulumi.set(self, "pub_sub", value)

    @property
    @pulumi.getter(name="publishFindingsToCloudDataCatalog")
    def publish_findings_to_cloud_data_catalog(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobActionPublishFindingsToCloudDataCatalogArgs']]:
        """
        Publish findings of a DlpJob to Data Catalog.
        """
        return pulumi.get(self, "publish_findings_to_cloud_data_catalog")

    @publish_findings_to_cloud_data_catalog.setter
    def publish_findings_to_cloud_data_catalog(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobActionPublishFindingsToCloudDataCatalogArgs']]):
        pulumi.set(self, "publish_findings_to_cloud_data_catalog", value)

    @property
    @pulumi.getter(name="publishSummaryToCscc")
    def publish_summary_to_cscc(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobActionPublishSummaryToCsccArgs']]:
        """
        Publish the result summary of a DlpJob to the Cloud Security Command Center.
        """
        return pulumi.get(self, "publish_summary_to_cscc")

    @publish_summary_to_cscc.setter
    def publish_summary_to_cscc(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobActionPublishSummaryToCsccArgs']]):
        pulumi.set(self, "publish_summary_to_cscc", value)

    @property
    @pulumi.getter(name="publishToStackdriver")
    def publish_to_stackdriver(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobActionPublishToStackdriverArgs']]:
        """
        Enable Stackdriver metric dlp.googleapis.com/findingCount.
        """
        return pulumi.get(self, "publish_to_stackdriver")

    @publish_to_stackdriver.setter
    def publish_to_stackdriver(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobActionPublishToStackdriverArgs']]):
        pulumi.set(self, "publish_to_stackdriver", value)

    @property
    @pulumi.getter(name="saveFindings")
    def save_findings(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobActionSaveFindingsArgs']]:
        """
        If set, the detailed findings will be persisted to the specified OutputStorageConfig. Only a single instance of this action can be specified. Compatible with: Inspect, Risk
        Structure is documented below.
        """
        return pulumi.get(self, "save_findings")

    @save_findings.setter
    def save_findings(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobActionSaveFindingsArgs']]):
        pulumi.set(self, "save_findings", value)


if not MYPY:
    class PreventionJobTriggerInspectJobActionDeidentifyArgsDict(TypedDict):
        cloud_storage_output: pulumi.Input[str]
        """
        User settable Cloud Storage bucket and folders to store de-identified files.
        This field must be set for cloud storage deidentification.
        The output Cloud Storage bucket must be different from the input bucket.
        De-identified files will overwrite files in the output path.
        Form of: gs://bucket/folder/ or gs://bucket
        """
        file_types_to_transforms: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of user-specified file type groups to transform. If specified, only the files with these filetypes will be transformed.
        If empty, all supported files will be transformed. Supported types may be automatically added over time.
        If a file type is set in this field that isn't supported by the Deidentify action then the job will fail and will not be successfully created/started.
        Each value may be one of: `IMAGE`, `TEXT_FILE`, `CSV`, `TSV`.
        """
        transformation_config: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyTransformationConfigArgsDict']]
        """
        User specified deidentify templates and configs for structured, unstructured, and image files.
        Structure is documented below.
        """
        transformation_details_storage_config: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigArgsDict']]
        """
        Config for storing transformation details.
        Structure is documented below.
        """
elif False:
    PreventionJobTriggerInspectJobActionDeidentifyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobActionDeidentifyArgs:
    def __init__(__self__, *,
                 cloud_storage_output: pulumi.Input[str],
                 file_types_to_transforms: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 transformation_config: Optional[pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyTransformationConfigArgs']] = None,
                 transformation_details_storage_config: Optional[pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigArgs']] = None):
        """
        :param pulumi.Input[str] cloud_storage_output: User settable Cloud Storage bucket and folders to store de-identified files.
               This field must be set for cloud storage deidentification.
               The output Cloud Storage bucket must be different from the input bucket.
               De-identified files will overwrite files in the output path.
               Form of: gs://bucket/folder/ or gs://bucket
        :param pulumi.Input[Sequence[pulumi.Input[str]]] file_types_to_transforms: List of user-specified file type groups to transform. If specified, only the files with these filetypes will be transformed.
               If empty, all supported files will be transformed. Supported types may be automatically added over time.
               If a file type is set in this field that isn't supported by the Deidentify action then the job will fail and will not be successfully created/started.
               Each value may be one of: `IMAGE`, `TEXT_FILE`, `CSV`, `TSV`.
        :param pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyTransformationConfigArgs'] transformation_config: User specified deidentify templates and configs for structured, unstructured, and image files.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigArgs'] transformation_details_storage_config: Config for storing transformation details.
               Structure is documented below.
        """
        pulumi.set(__self__, "cloud_storage_output", cloud_storage_output)
        if file_types_to_transforms is not None:
            pulumi.set(__self__, "file_types_to_transforms", file_types_to_transforms)
        if transformation_config is not None:
            pulumi.set(__self__, "transformation_config", transformation_config)
        if transformation_details_storage_config is not None:
            pulumi.set(__self__, "transformation_details_storage_config", transformation_details_storage_config)

    @property
    @pulumi.getter(name="cloudStorageOutput")
    def cloud_storage_output(self) -> pulumi.Input[str]:
        """
        User settable Cloud Storage bucket and folders to store de-identified files.
        This field must be set for cloud storage deidentification.
        The output Cloud Storage bucket must be different from the input bucket.
        De-identified files will overwrite files in the output path.
        Form of: gs://bucket/folder/ or gs://bucket
        """
        return pulumi.get(self, "cloud_storage_output")

    @cloud_storage_output.setter
    def cloud_storage_output(self, value: pulumi.Input[str]):
        pulumi.set(self, "cloud_storage_output", value)

    @property
    @pulumi.getter(name="fileTypesToTransforms")
    def file_types_to_transforms(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of user-specified file type groups to transform. If specified, only the files with these filetypes will be transformed.
        If empty, all supported files will be transformed. Supported types may be automatically added over time.
        If a file type is set in this field that isn't supported by the Deidentify action then the job will fail and will not be successfully created/started.
        Each value may be one of: `IMAGE`, `TEXT_FILE`, `CSV`, `TSV`.
        """
        return pulumi.get(self, "file_types_to_transforms")

    @file_types_to_transforms.setter
    def file_types_to_transforms(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "file_types_to_transforms", value)

    @property
    @pulumi.getter(name="transformationConfig")
    def transformation_config(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyTransformationConfigArgs']]:
        """
        User specified deidentify templates and configs for structured, unstructured, and image files.
        Structure is documented below.
        """
        return pulumi.get(self, "transformation_config")

    @transformation_config.setter
    def transformation_config(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyTransformationConfigArgs']]):
        pulumi.set(self, "transformation_config", value)

    @property
    @pulumi.getter(name="transformationDetailsStorageConfig")
    def transformation_details_storage_config(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigArgs']]:
        """
        Config for storing transformation details.
        Structure is documented below.
        """
        return pulumi.get(self, "transformation_details_storage_config")

    @transformation_details_storage_config.setter
    def transformation_details_storage_config(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigArgs']]):
        pulumi.set(self, "transformation_details_storage_config", value)


if not MYPY:
    class PreventionJobTriggerInspectJobActionDeidentifyTransformationConfigArgsDict(TypedDict):
        deidentify_template: NotRequired[pulumi.Input[str]]
        """
        If this template is specified, it will serve as the default de-identify template.
        """
        image_redact_template: NotRequired[pulumi.Input[str]]
        """
        If this template is specified, it will serve as the de-identify template for images.
        """
        structured_deidentify_template: NotRequired[pulumi.Input[str]]
        """
        If this template is specified, it will serve as the de-identify template for structured content such as delimited files and tables.
        """
elif False:
    PreventionJobTriggerInspectJobActionDeidentifyTransformationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobActionDeidentifyTransformationConfigArgs:
    def __init__(__self__, *,
                 deidentify_template: Optional[pulumi.Input[str]] = None,
                 image_redact_template: Optional[pulumi.Input[str]] = None,
                 structured_deidentify_template: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] deidentify_template: If this template is specified, it will serve as the default de-identify template.
        :param pulumi.Input[str] image_redact_template: If this template is specified, it will serve as the de-identify template for images.
        :param pulumi.Input[str] structured_deidentify_template: If this template is specified, it will serve as the de-identify template for structured content such as delimited files and tables.
        """
        if deidentify_template is not None:
            pulumi.set(__self__, "deidentify_template", deidentify_template)
        if image_redact_template is not None:
            pulumi.set(__self__, "image_redact_template", image_redact_template)
        if structured_deidentify_template is not None:
            pulumi.set(__self__, "structured_deidentify_template", structured_deidentify_template)

    @property
    @pulumi.getter(name="deidentifyTemplate")
    def deidentify_template(self) -> Optional[pulumi.Input[str]]:
        """
        If this template is specified, it will serve as the default de-identify template.
        """
        return pulumi.get(self, "deidentify_template")

    @deidentify_template.setter
    def deidentify_template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "deidentify_template", value)

    @property
    @pulumi.getter(name="imageRedactTemplate")
    def image_redact_template(self) -> Optional[pulumi.Input[str]]:
        """
        If this template is specified, it will serve as the de-identify template for images.
        """
        return pulumi.get(self, "image_redact_template")

    @image_redact_template.setter
    def image_redact_template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "image_redact_template", value)

    @property
    @pulumi.getter(name="structuredDeidentifyTemplate")
    def structured_deidentify_template(self) -> Optional[pulumi.Input[str]]:
        """
        If this template is specified, it will serve as the de-identify template for structured content such as delimited files and tables.
        """
        return pulumi.get(self, "structured_deidentify_template")

    @structured_deidentify_template.setter
    def structured_deidentify_template(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "structured_deidentify_template", value)


if not MYPY:
    class PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigArgsDict(TypedDict):
        table: pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigTableArgsDict']
        """
        The BigQuery table in which to store the output.
        Structure is documented below.
        """
elif False:
    PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigArgs:
    def __init__(__self__, *,
                 table: pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigTableArgs']):
        """
        :param pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigTableArgs'] table: The BigQuery table in which to store the output.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter
    def table(self) -> pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigTableArgs']:
        """
        The BigQuery table in which to store the output.
        Structure is documented below.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: pulumi.Input['PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigTableArgs']):
        pulumi.set(self, "table", value)


if not MYPY:
    class PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigTableArgsDict(TypedDict):
        dataset_id: pulumi.Input[str]
        """
        The ID of the dataset containing this table.
        """
        project_id: pulumi.Input[str]
        """
        The ID of the project containing this table.
        """
        table_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the table. The ID must contain only letters (a-z,
        A-Z), numbers (0-9), or underscores (_). The maximum length
        is 1,024 characters.
        """
elif False:
    PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobActionDeidentifyTransformationDetailsStorageConfigTableArgs:
    def __init__(__self__, *,
                 dataset_id: pulumi.Input[str],
                 project_id: pulumi.Input[str],
                 table_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dataset_id: The ID of the dataset containing this table.
        :param pulumi.Input[str] project_id: The ID of the project containing this table.
        :param pulumi.Input[str] table_id: The ID of the table. The ID must contain only letters (a-z,
               A-Z), numbers (0-9), or underscores (_). The maximum length
               is 1,024 characters.
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "project_id", project_id)
        if table_id is not None:
            pulumi.set(__self__, "table_id", table_id)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> pulumi.Input[str]:
        """
        The ID of the dataset containing this table.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The ID of the project containing this table.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="tableId")
    def table_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the table. The ID must contain only letters (a-z,
        A-Z), numbers (0-9), or underscores (_). The maximum length
        is 1,024 characters.
        """
        return pulumi.get(self, "table_id")

    @table_id.setter
    def table_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "table_id", value)


if not MYPY:
    class PreventionJobTriggerInspectJobActionJobNotificationEmailsArgsDict(TypedDict):
        pass
elif False:
    PreventionJobTriggerInspectJobActionJobNotificationEmailsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobActionJobNotificationEmailsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionJobTriggerInspectJobActionPubSubArgsDict(TypedDict):
        topic: pulumi.Input[str]
        """
        Cloud Pub/Sub topic to send notifications to.
        """
elif False:
    PreventionJobTriggerInspectJobActionPubSubArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobActionPubSubArgs:
    def __init__(__self__, *,
                 topic: pulumi.Input[str]):
        """
        :param pulumi.Input[str] topic: Cloud Pub/Sub topic to send notifications to.
        """
        pulumi.set(__self__, "topic", topic)

    @property
    @pulumi.getter
    def topic(self) -> pulumi.Input[str]:
        """
        Cloud Pub/Sub topic to send notifications to.
        """
        return pulumi.get(self, "topic")

    @topic.setter
    def topic(self, value: pulumi.Input[str]):
        pulumi.set(self, "topic", value)


if not MYPY:
    class PreventionJobTriggerInspectJobActionPublishFindingsToCloudDataCatalogArgsDict(TypedDict):
        pass
elif False:
    PreventionJobTriggerInspectJobActionPublishFindingsToCloudDataCatalogArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobActionPublishFindingsToCloudDataCatalogArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionJobTriggerInspectJobActionPublishSummaryToCsccArgsDict(TypedDict):
        pass
elif False:
    PreventionJobTriggerInspectJobActionPublishSummaryToCsccArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobActionPublishSummaryToCsccArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionJobTriggerInspectJobActionPublishToStackdriverArgsDict(TypedDict):
        pass
elif False:
    PreventionJobTriggerInspectJobActionPublishToStackdriverArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobActionPublishToStackdriverArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionJobTriggerInspectJobActionSaveFindingsArgsDict(TypedDict):
        output_config: pulumi.Input['PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigArgsDict']
        """
        Information on where to store output
        Structure is documented below.
        """
elif False:
    PreventionJobTriggerInspectJobActionSaveFindingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobActionSaveFindingsArgs:
    def __init__(__self__, *,
                 output_config: pulumi.Input['PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigArgs']):
        """
        :param pulumi.Input['PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigArgs'] output_config: Information on where to store output
               Structure is documented below.
        """
        pulumi.set(__self__, "output_config", output_config)

    @property
    @pulumi.getter(name="outputConfig")
    def output_config(self) -> pulumi.Input['PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigArgs']:
        """
        Information on where to store output
        Structure is documented below.
        """
        return pulumi.get(self, "output_config")

    @output_config.setter
    def output_config(self, value: pulumi.Input['PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigArgs']):
        pulumi.set(self, "output_config", value)


if not MYPY:
    class PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigArgsDict(TypedDict):
        table: pulumi.Input['PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigTableArgsDict']
        """
        Information on the location of the target BigQuery Table.
        Structure is documented below.
        """
        output_schema: NotRequired[pulumi.Input[str]]
        """
        Schema used for writing the findings for Inspect jobs. This field is only used for
        Inspect and must be unspecified for Risk jobs. Columns are derived from the Finding
        object. If appending to an existing table, any columns from the predefined schema
        that are missing will be added. No columns in the existing table will be deleted.
        If unspecified, then all available columns will be used for a new table or an (existing)
        table with no schema, and no changes will be made to an existing table that has a schema.
        Only for use with external storage.
        Possible values are: `BASIC_COLUMNS`, `GCS_COLUMNS`, `DATASTORE_COLUMNS`, `BIG_QUERY_COLUMNS`, `ALL_COLUMNS`.
        """
elif False:
    PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigArgs:
    def __init__(__self__, *,
                 table: pulumi.Input['PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigTableArgs'],
                 output_schema: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigTableArgs'] table: Information on the location of the target BigQuery Table.
               Structure is documented below.
        :param pulumi.Input[str] output_schema: Schema used for writing the findings for Inspect jobs. This field is only used for
               Inspect and must be unspecified for Risk jobs. Columns are derived from the Finding
               object. If appending to an existing table, any columns from the predefined schema
               that are missing will be added. No columns in the existing table will be deleted.
               If unspecified, then all available columns will be used for a new table or an (existing)
               table with no schema, and no changes will be made to an existing table that has a schema.
               Only for use with external storage.
               Possible values are: `BASIC_COLUMNS`, `GCS_COLUMNS`, `DATASTORE_COLUMNS`, `BIG_QUERY_COLUMNS`, `ALL_COLUMNS`.
        """
        pulumi.set(__self__, "table", table)
        if output_schema is not None:
            pulumi.set(__self__, "output_schema", output_schema)

    @property
    @pulumi.getter
    def table(self) -> pulumi.Input['PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigTableArgs']:
        """
        Information on the location of the target BigQuery Table.
        Structure is documented below.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: pulumi.Input['PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigTableArgs']):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="outputSchema")
    def output_schema(self) -> Optional[pulumi.Input[str]]:
        """
        Schema used for writing the findings for Inspect jobs. This field is only used for
        Inspect and must be unspecified for Risk jobs. Columns are derived from the Finding
        object. If appending to an existing table, any columns from the predefined schema
        that are missing will be added. No columns in the existing table will be deleted.
        If unspecified, then all available columns will be used for a new table or an (existing)
        table with no schema, and no changes will be made to an existing table that has a schema.
        Only for use with external storage.
        Possible values are: `BASIC_COLUMNS`, `GCS_COLUMNS`, `DATASTORE_COLUMNS`, `BIG_QUERY_COLUMNS`, `ALL_COLUMNS`.
        """
        return pulumi.get(self, "output_schema")

    @output_schema.setter
    def output_schema(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "output_schema", value)


if not MYPY:
    class PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigTableArgsDict(TypedDict):
        dataset_id: pulumi.Input[str]
        """
        The ID of the dataset containing this table.
        """
        project_id: pulumi.Input[str]
        """
        The ID of the project containing this table.
        """
        table_id: NotRequired[pulumi.Input[str]]
        """
        The ID of the table. The ID must contain only letters (a-z,
        A-Z), numbers (0-9), or underscores (_). The maximum length
        is 1,024 characters.
        """
elif False:
    PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobActionSaveFindingsOutputConfigTableArgs:
    def __init__(__self__, *,
                 dataset_id: pulumi.Input[str],
                 project_id: pulumi.Input[str],
                 table_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] dataset_id: The ID of the dataset containing this table.
        :param pulumi.Input[str] project_id: The ID of the project containing this table.
        :param pulumi.Input[str] table_id: The ID of the table. The ID must contain only letters (a-z,
               A-Z), numbers (0-9), or underscores (_). The maximum length
               is 1,024 characters.
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "project_id", project_id)
        if table_id is not None:
            pulumi.set(__self__, "table_id", table_id)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> pulumi.Input[str]:
        """
        The ID of the dataset containing this table.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The ID of the project containing this table.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="tableId")
    def table_id(self) -> Optional[pulumi.Input[str]]:
        """
        The ID of the table. The ID must contain only letters (a-z,
        A-Z), numbers (0-9), or underscores (_). The maximum length
        is 1,024 characters.
        """
        return pulumi.get(self, "table_id")

    @table_id.setter
    def table_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "table_id", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigArgsDict(TypedDict):
        custom_info_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeArgsDict']]]]
        """
        Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
        Structure is documented below.
        """
        exclude_info_types: NotRequired[pulumi.Input[bool]]
        """
        When true, excludes type information of the findings.
        """
        include_quote: NotRequired[pulumi.Input[bool]]
        """
        When true, a contextual quote from the data that triggered a finding is included in the response.
        """
        info_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigInfoTypeArgsDict']]]]
        """
        Restricts what infoTypes to look for. The values must correspond to InfoType values returned by infoTypes.list
        or listed at https://cloud.google.com/dlp/docs/infotypes-reference.
        When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run.
        By default this may be all types, but may change over time as detectors are updated.
        Structure is documented below.
        """
        limits: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsArgsDict']]
        """
        Configuration to control the number of findings returned.
        Structure is documented below.
        """
        min_likelihood: NotRequired[pulumi.Input[str]]
        """
        Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info
        Default value is `POSSIBLE`.
        Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
        """
        rule_sets: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetArgsDict']]]]
        """
        Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end,
        other rules are executed in the order they are specified for each info type.
        Structure is documented below.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigArgs:
    def __init__(__self__, *,
                 custom_info_types: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeArgs']]]] = None,
                 exclude_info_types: Optional[pulumi.Input[bool]] = None,
                 include_quote: Optional[pulumi.Input[bool]] = None,
                 info_types: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigInfoTypeArgs']]]] = None,
                 limits: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsArgs']] = None,
                 min_likelihood: Optional[pulumi.Input[str]] = None,
                 rule_sets: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeArgs']]] custom_info_types: Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
               Structure is documented below.
        :param pulumi.Input[bool] exclude_info_types: When true, excludes type information of the findings.
        :param pulumi.Input[bool] include_quote: When true, a contextual quote from the data that triggered a finding is included in the response.
        :param pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigInfoTypeArgs']]] info_types: Restricts what infoTypes to look for. The values must correspond to InfoType values returned by infoTypes.list
               or listed at https://cloud.google.com/dlp/docs/infotypes-reference.
               When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run.
               By default this may be all types, but may change over time as detectors are updated.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsArgs'] limits: Configuration to control the number of findings returned.
               Structure is documented below.
        :param pulumi.Input[str] min_likelihood: Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info
               Default value is `POSSIBLE`.
               Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
        :param pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetArgs']]] rule_sets: Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end,
               other rules are executed in the order they are specified for each info type.
               Structure is documented below.
        """
        if custom_info_types is not None:
            pulumi.set(__self__, "custom_info_types", custom_info_types)
        if exclude_info_types is not None:
            pulumi.set(__self__, "exclude_info_types", exclude_info_types)
        if include_quote is not None:
            pulumi.set(__self__, "include_quote", include_quote)
        if info_types is not None:
            pulumi.set(__self__, "info_types", info_types)
        if limits is not None:
            pulumi.set(__self__, "limits", limits)
        if min_likelihood is not None:
            pulumi.set(__self__, "min_likelihood", min_likelihood)
        if rule_sets is not None:
            pulumi.set(__self__, "rule_sets", rule_sets)

    @property
    @pulumi.getter(name="customInfoTypes")
    def custom_info_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeArgs']]]]:
        """
        Custom info types to be used. See https://cloud.google.com/dlp/docs/creating-custom-infotypes to learn more.
        Structure is documented below.
        """
        return pulumi.get(self, "custom_info_types")

    @custom_info_types.setter
    def custom_info_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeArgs']]]]):
        pulumi.set(self, "custom_info_types", value)

    @property
    @pulumi.getter(name="excludeInfoTypes")
    def exclude_info_types(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, excludes type information of the findings.
        """
        return pulumi.get(self, "exclude_info_types")

    @exclude_info_types.setter
    def exclude_info_types(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "exclude_info_types", value)

    @property
    @pulumi.getter(name="includeQuote")
    def include_quote(self) -> Optional[pulumi.Input[bool]]:
        """
        When true, a contextual quote from the data that triggered a finding is included in the response.
        """
        return pulumi.get(self, "include_quote")

    @include_quote.setter
    def include_quote(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "include_quote", value)

    @property
    @pulumi.getter(name="infoTypes")
    def info_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigInfoTypeArgs']]]]:
        """
        Restricts what infoTypes to look for. The values must correspond to InfoType values returned by infoTypes.list
        or listed at https://cloud.google.com/dlp/docs/infotypes-reference.
        When no InfoTypes or CustomInfoTypes are specified in a request, the system may automatically choose what detectors to run.
        By default this may be all types, but may change over time as detectors are updated.
        Structure is documented below.
        """
        return pulumi.get(self, "info_types")

    @info_types.setter
    def info_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigInfoTypeArgs']]]]):
        pulumi.set(self, "info_types", value)

    @property
    @pulumi.getter
    def limits(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsArgs']]:
        """
        Configuration to control the number of findings returned.
        Structure is documented below.
        """
        return pulumi.get(self, "limits")

    @limits.setter
    def limits(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsArgs']]):
        pulumi.set(self, "limits", value)

    @property
    @pulumi.getter(name="minLikelihood")
    def min_likelihood(self) -> Optional[pulumi.Input[str]]:
        """
        Only returns findings equal or above this threshold. See https://cloud.google.com/dlp/docs/likelihood for more info
        Default value is `POSSIBLE`.
        Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
        """
        return pulumi.get(self, "min_likelihood")

    @min_likelihood.setter
    def min_likelihood(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "min_likelihood", value)

    @property
    @pulumi.getter(name="ruleSets")
    def rule_sets(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetArgs']]]]:
        """
        Set of rules to apply to the findings for this InspectConfig. Exclusion rules, contained in the set are executed in the end,
        other rules are executed in the order they are specified for each info type.
        Structure is documented below.
        """
        return pulumi.get(self, "rule_sets")

    @rule_sets.setter
    def rule_sets(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetArgs']]]]):
        pulumi.set(self, "rule_sets", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeArgsDict(TypedDict):
        info_type: pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeArgsDict']
        """
        CustomInfoType can either be a new infoType, or an extension of built-in infoType, when the name matches one of existing
        infoTypes and that infoType is specified in `info_types` field. Specifying the latter adds findings to the
        one detected by the system. If built-in info type is not specified in `info_types` list then the name is
        treated as a custom info type.
        Structure is documented below.
        """
        dictionary: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryArgsDict']]
        """
        Dictionary which defines the rule.
        Structure is documented below.
        """
        exclusion_type: NotRequired[pulumi.Input[str]]
        """
        If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
        Possible values are: `EXCLUSION_TYPE_EXCLUDE`.
        """
        likelihood: NotRequired[pulumi.Input[str]]
        """
        Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria
        specified by the rule.
        Default value is `VERY_LIKELY`.
        Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
        """
        regex: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeRegexArgsDict']]
        """
        Regular expression which defines the rule.
        Structure is documented below.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        stored_type: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeStoredTypeArgsDict']]
        """
        A reference to a StoredInfoType to use with scanning.
        Structure is documented below.
        """
        surrogate_type: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSurrogateTypeArgsDict']]
        """
        Message for detecting output from deidentification transformations that support reversing.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeArgs:
    def __init__(__self__, *,
                 info_type: pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeArgs'],
                 dictionary: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryArgs']] = None,
                 exclusion_type: Optional[pulumi.Input[str]] = None,
                 likelihood: Optional[pulumi.Input[str]] = None,
                 regex: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeRegexArgs']] = None,
                 sensitivity_score: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSensitivityScoreArgs']] = None,
                 stored_type: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeStoredTypeArgs']] = None,
                 surrogate_type: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSurrogateTypeArgs']] = None):
        """
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeArgs'] info_type: CustomInfoType can either be a new infoType, or an extension of built-in infoType, when the name matches one of existing
               infoTypes and that infoType is specified in `info_types` field. Specifying the latter adds findings to the
               one detected by the system. If built-in info type is not specified in `info_types` list then the name is
               treated as a custom info type.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryArgs'] dictionary: Dictionary which defines the rule.
               Structure is documented below.
        :param pulumi.Input[str] exclusion_type: If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
               Possible values are: `EXCLUSION_TYPE_EXCLUDE`.
        :param pulumi.Input[str] likelihood: Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria
               specified by the rule.
               Default value is `VERY_LIKELY`.
               Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeRegexArgs'] regex: Regular expression which defines the rule.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeStoredTypeArgs'] stored_type: A reference to a StoredInfoType to use with scanning.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSurrogateTypeArgs'] surrogate_type: Message for detecting output from deidentification transformations that support reversing.
        """
        pulumi.set(__self__, "info_type", info_type)
        if dictionary is not None:
            pulumi.set(__self__, "dictionary", dictionary)
        if exclusion_type is not None:
            pulumi.set(__self__, "exclusion_type", exclusion_type)
        if likelihood is not None:
            pulumi.set(__self__, "likelihood", likelihood)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if stored_type is not None:
            pulumi.set(__self__, "stored_type", stored_type)
        if surrogate_type is not None:
            pulumi.set(__self__, "surrogate_type", surrogate_type)

    @property
    @pulumi.getter(name="infoType")
    def info_type(self) -> pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeArgs']:
        """
        CustomInfoType can either be a new infoType, or an extension of built-in infoType, when the name matches one of existing
        infoTypes and that infoType is specified in `info_types` field. Specifying the latter adds findings to the
        one detected by the system. If built-in info type is not specified in `info_types` list then the name is
        treated as a custom info type.
        Structure is documented below.
        """
        return pulumi.get(self, "info_type")

    @info_type.setter
    def info_type(self, value: pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeArgs']):
        pulumi.set(self, "info_type", value)

    @property
    @pulumi.getter
    def dictionary(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryArgs']]:
        """
        Dictionary which defines the rule.
        Structure is documented below.
        """
        return pulumi.get(self, "dictionary")

    @dictionary.setter
    def dictionary(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryArgs']]):
        pulumi.set(self, "dictionary", value)

    @property
    @pulumi.getter(name="exclusionType")
    def exclusion_type(self) -> Optional[pulumi.Input[str]]:
        """
        If set to EXCLUSION_TYPE_EXCLUDE this infoType will not cause a finding to be returned. It still can be used for rules matching.
        Possible values are: `EXCLUSION_TYPE_EXCLUDE`.
        """
        return pulumi.get(self, "exclusion_type")

    @exclusion_type.setter
    def exclusion_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "exclusion_type", value)

    @property
    @pulumi.getter
    def likelihood(self) -> Optional[pulumi.Input[str]]:
        """
        Likelihood to return for this CustomInfoType. This base value can be altered by a detection rule if the finding meets the criteria
        specified by the rule.
        Default value is `VERY_LIKELY`.
        Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
        """
        return pulumi.get(self, "likelihood")

    @likelihood.setter
    def likelihood(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "likelihood", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeRegexArgs']]:
        """
        Regular expression which defines the rule.
        Structure is documented below.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeRegexArgs']]):
        pulumi.set(self, "regex", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter(name="storedType")
    def stored_type(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeStoredTypeArgs']]:
        """
        A reference to a StoredInfoType to use with scanning.
        Structure is documented below.
        """
        return pulumi.get(self, "stored_type")

    @stored_type.setter
    def stored_type(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeStoredTypeArgs']]):
        pulumi.set(self, "stored_type", value)

    @property
    @pulumi.getter(name="surrogateType")
    def surrogate_type(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSurrogateTypeArgs']]:
        """
        Message for detecting output from deidentification transformations that support reversing.
        """
        return pulumi.get(self, "surrogate_type")

    @surrogate_type.setter
    def surrogate_type(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSurrogateTypeArgs']]):
        pulumi.set(self, "surrogate_type", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryArgsDict(TypedDict):
        cloud_storage_path: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgsDict']]
        """
        Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
        Structure is documented below.
        """
        word_list: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryWordListArgsDict']]
        """
        List of words or phrases to search for.
        Structure is documented below.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryArgs:
    def __init__(__self__, *,
                 cloud_storage_path: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgs']] = None,
                 word_list: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryWordListArgs']] = None):
        """
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgs'] cloud_storage_path: Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryWordListArgs'] word_list: List of words or phrases to search for.
               Structure is documented below.
        """
        if cloud_storage_path is not None:
            pulumi.set(__self__, "cloud_storage_path", cloud_storage_path)
        if word_list is not None:
            pulumi.set(__self__, "word_list", word_list)

    @property
    @pulumi.getter(name="cloudStoragePath")
    def cloud_storage_path(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgs']]:
        """
        Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_storage_path")

    @cloud_storage_path.setter
    def cloud_storage_path(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgs']]):
        pulumi.set(self, "cloud_storage_path", value)

    @property
    @pulumi.getter(name="wordList")
    def word_list(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryWordListArgs']]:
        """
        List of words or phrases to search for.
        Structure is documented below.
        """
        return pulumi.get(self, "word_list")

    @word_list.setter
    def word_list(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryWordListArgs']]):
        pulumi.set(self, "word_list", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgsDict(TypedDict):
        path: pulumi.Input[str]
        """
        A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryCloudStoragePathArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str]):
        """
        :param pulumi.Input[str] path: A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
        """
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryWordListArgsDict(TypedDict):
        words: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Words or phrases defining the dictionary. The dictionary must contain at least one
        phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryWordListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeDictionaryWordListArgs:
    def __init__(__self__, *,
                 words: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] words: Words or phrases defining the dictionary. The dictionary must contain at least one
               phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
        pulumi.set(__self__, "words", words)

    @property
    @pulumi.getter
    def words(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Words or phrases defining the dictionary. The dictionary must contain at least one
        phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
        return pulumi.get(self, "words")

    @words.setter
    def words(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "words", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names
        listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version of the information type to use. By default, the version is set to stable.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 sensitivity_score: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names
               listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input[str] version: Version of the information type to use. By default, the version is set to stable.
        """
        pulumi.set(__self__, "name", name)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names
        listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the information type to use. By default, the version is set to stable.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeRegexArgsDict(TypedDict):
        pattern: pulumi.Input[str]
        """
        Pattern defining the regular expression.
        Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
        group_indexes: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeRegexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeRegexArgs:
    def __init__(__self__, *,
                 pattern: pulumi.Input[str],
                 group_indexes: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[str] pattern: Pattern defining the regular expression.
               Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] group_indexes: The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
        """
        pulumi.set(__self__, "pattern", pattern)
        if group_indexes is not None:
            pulumi.set(__self__, "group_indexes", group_indexes)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        Pattern defining the regular expression.
        Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter(name="groupIndexes")
    def group_indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
        """
        return pulumi.get(self, "group_indexes")

    @group_indexes.setter
    def group_indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "group_indexes", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeStoredTypeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Resource name of the requested StoredInfoType, for example `organizations/433245324/storedInfoTypes/432452342`
        or `projects/project-id/storedInfoTypes/432452342`.
        """
        create_time: NotRequired[pulumi.Input[str]]
        """
        (Output)
        The creation timestamp of an inspectTemplate. Set by the server.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeStoredTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeStoredTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 create_time: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Resource name of the requested StoredInfoType, for example `organizations/433245324/storedInfoTypes/432452342`
               or `projects/project-id/storedInfoTypes/432452342`.
        :param pulumi.Input[str] create_time: (Output)
               The creation timestamp of an inspectTemplate. Set by the server.
        """
        pulumi.set(__self__, "name", name)
        if create_time is not None:
            pulumi.set(__self__, "create_time", create_time)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Resource name of the requested StoredInfoType, for example `organizations/433245324/storedInfoTypes/432452342`
        or `projects/project-id/storedInfoTypes/432452342`.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="createTime")
    def create_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The creation timestamp of an inspectTemplate. Set by the server.
        """
        return pulumi.get(self, "create_time")

    @create_time.setter
    def create_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "create_time", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSurrogateTypeArgsDict(TypedDict):
        pass
elif False:
    PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSurrogateTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigCustomInfoTypeSurrogateTypeArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigInfoTypeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
        at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version of the information type to use. By default, the version is set to stable.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigInfoTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 sensitivity_score: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigInfoTypeSensitivityScoreArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
               at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input[str] version: Version of the information type to use. By default, the version is set to stable.
        """
        pulumi.set(__self__, "name", name)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
        at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the information type to use. By default, the version is set to stable.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigLimitsArgsDict(TypedDict):
        max_findings_per_info_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeArgsDict']]]]
        """
        Configuration of findings limit given for specified infoTypes.
        Structure is documented below.
        """
        max_findings_per_item: NotRequired[pulumi.Input[int]]
        """
        Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
        """
        max_findings_per_request: NotRequired[pulumi.Input[int]]
        """
        Max number of findings that will be returned per request/job. The maximum returned is 2000.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigLimitsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigLimitsArgs:
    def __init__(__self__, *,
                 max_findings_per_info_types: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeArgs']]]] = None,
                 max_findings_per_item: Optional[pulumi.Input[int]] = None,
                 max_findings_per_request: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeArgs']]] max_findings_per_info_types: Configuration of findings limit given for specified infoTypes.
               Structure is documented below.
        :param pulumi.Input[int] max_findings_per_item: Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
        :param pulumi.Input[int] max_findings_per_request: Max number of findings that will be returned per request/job. The maximum returned is 2000.
        """
        if max_findings_per_info_types is not None:
            pulumi.set(__self__, "max_findings_per_info_types", max_findings_per_info_types)
        if max_findings_per_item is not None:
            pulumi.set(__self__, "max_findings_per_item", max_findings_per_item)
        if max_findings_per_request is not None:
            pulumi.set(__self__, "max_findings_per_request", max_findings_per_request)

    @property
    @pulumi.getter(name="maxFindingsPerInfoTypes")
    def max_findings_per_info_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeArgs']]]]:
        """
        Configuration of findings limit given for specified infoTypes.
        Structure is documented below.
        """
        return pulumi.get(self, "max_findings_per_info_types")

    @max_findings_per_info_types.setter
    def max_findings_per_info_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeArgs']]]]):
        pulumi.set(self, "max_findings_per_info_types", value)

    @property
    @pulumi.getter(name="maxFindingsPerItem")
    def max_findings_per_item(self) -> Optional[pulumi.Input[int]]:
        """
        Max number of findings that will be returned for each item scanned. The maximum returned is 2000.
        """
        return pulumi.get(self, "max_findings_per_item")

    @max_findings_per_item.setter
    def max_findings_per_item(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_findings_per_item", value)

    @property
    @pulumi.getter(name="maxFindingsPerRequest")
    def max_findings_per_request(self) -> Optional[pulumi.Input[int]]:
        """
        Max number of findings that will be returned per request/job. The maximum returned is 2000.
        """
        return pulumi.get(self, "max_findings_per_request")

    @max_findings_per_request.setter
    def max_findings_per_request(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_findings_per_request", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeArgsDict(TypedDict):
        info_type: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgsDict']]
        """
        Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
        not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
        specified in another InfoTypeLimit.
        Structure is documented below.
        """
        max_findings: NotRequired[pulumi.Input[int]]
        """
        Max findings limit for the given infoType.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeArgs:
    def __init__(__self__, *,
                 info_type: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgs']] = None,
                 max_findings: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgs'] info_type: Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
               not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
               specified in another InfoTypeLimit.
               Structure is documented below.
        :param pulumi.Input[int] max_findings: Max findings limit for the given infoType.
        """
        if info_type is not None:
            pulumi.set(__self__, "info_type", info_type)
        if max_findings is not None:
            pulumi.set(__self__, "max_findings", max_findings)

    @property
    @pulumi.getter(name="infoType")
    def info_type(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgs']]:
        """
        Type of information the findings limit applies to. Only one limit per infoType should be provided. If InfoTypeLimit does
        not have an infoType, the DLP API applies the limit against all infoTypes that are found but not
        specified in another InfoTypeLimit.
        Structure is documented below.
        """
        return pulumi.get(self, "info_type")

    @info_type.setter
    def info_type(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgs']]):
        pulumi.set(self, "info_type", value)

    @property
    @pulumi.getter(name="maxFindings")
    def max_findings(self) -> Optional[pulumi.Input[int]]:
        """
        Max findings limit for the given infoType.
        """
        return pulumi.get(self, "max_findings")

    @max_findings.setter
    def max_findings(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_findings", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names
        listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version of the information type to use. By default, the version is set to stable.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 sensitivity_score: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names
               listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input[str] version: Version of the information type to use. By default, the version is set to stable.
        """
        pulumi.set(__self__, "name", name)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names
        listed at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the information type to use. By default, the version is set to stable.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigLimitsMaxFindingsPerInfoTypeInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigRuleSetArgsDict(TypedDict):
        rules: pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleArgsDict']]]
        """
        Set of rules to be applied to infoTypes. The rules are applied in order.
        Structure is documented below.
        """
        info_types: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeArgsDict']]]]
        """
        List of infoTypes this rule set is applied to.
        Structure is documented below.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigRuleSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigRuleSetArgs:
    def __init__(__self__, *,
                 rules: pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleArgs']]],
                 info_types: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleArgs']]] rules: Set of rules to be applied to infoTypes. The rules are applied in order.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeArgs']]] info_types: List of infoTypes this rule set is applied to.
               Structure is documented below.
        """
        pulumi.set(__self__, "rules", rules)
        if info_types is not None:
            pulumi.set(__self__, "info_types", info_types)

    @property
    @pulumi.getter
    def rules(self) -> pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleArgs']]]:
        """
        Set of rules to be applied to infoTypes. The rules are applied in order.
        Structure is documented below.
        """
        return pulumi.get(self, "rules")

    @rules.setter
    def rules(self, value: pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleArgs']]]):
        pulumi.set(self, "rules", value)

    @property
    @pulumi.getter(name="infoTypes")
    def info_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeArgs']]]]:
        """
        List of infoTypes this rule set is applied to.
        Structure is documented below.
        """
        return pulumi.get(self, "info_types")

    @info_types.setter
    def info_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeArgs']]]]):
        pulumi.set(self, "info_types", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
        at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version of the information type to use. By default, the version is set to stable.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 sensitivity_score: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeSensitivityScoreArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
               at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input[str] version: Version of the information type to use. By default, the version is set to stable.
        """
        pulumi.set(__self__, "name", name)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
        at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the information type to use. By default, the version is set to stable.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigRuleSetInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleArgsDict(TypedDict):
        exclusion_rule: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleArgsDict']]
        """
        The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
        Structure is documented below.
        """
        hotword_rule: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleArgsDict']]
        """
        Hotword-based detection rule.
        Structure is documented below.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigRuleSetRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleArgs:
    def __init__(__self__, *,
                 exclusion_rule: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleArgs']] = None,
                 hotword_rule: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleArgs']] = None):
        """
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleArgs'] exclusion_rule: The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleArgs'] hotword_rule: Hotword-based detection rule.
               Structure is documented below.
        """
        if exclusion_rule is not None:
            pulumi.set(__self__, "exclusion_rule", exclusion_rule)
        if hotword_rule is not None:
            pulumi.set(__self__, "hotword_rule", hotword_rule)

    @property
    @pulumi.getter(name="exclusionRule")
    def exclusion_rule(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleArgs']]:
        """
        The rule that specifies conditions when findings of infoTypes specified in InspectionRuleSet are removed from results.
        Structure is documented below.
        """
        return pulumi.get(self, "exclusion_rule")

    @exclusion_rule.setter
    def exclusion_rule(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleArgs']]):
        pulumi.set(self, "exclusion_rule", value)

    @property
    @pulumi.getter(name="hotwordRule")
    def hotword_rule(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleArgs']]:
        """
        Hotword-based detection rule.
        Structure is documented below.
        """
        return pulumi.get(self, "hotword_rule")

    @hotword_rule.setter
    def hotword_rule(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleArgs']]):
        pulumi.set(self, "hotword_rule", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleArgsDict(TypedDict):
        matching_type: pulumi.Input[str]
        """
        How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType
        Possible values are: `MATCHING_TYPE_FULL_MATCH`, `MATCHING_TYPE_PARTIAL_MATCH`, `MATCHING_TYPE_INVERSE_MATCH`.
        """
        dictionary: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryArgsDict']]
        """
        Dictionary which defines the rule.
        Structure is documented below.
        """
        exclude_by_hotword: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgsDict']]
        """
        Drop if the hotword rule is contained in the proximate context.
        Structure is documented below.
        """
        exclude_info_types: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgsDict']]
        """
        Set of infoTypes for which findings would affect this rule.
        Structure is documented below.
        """
        regex: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleRegexArgsDict']]
        """
        Regular expression which defines the rule.
        Structure is documented below.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleArgs:
    def __init__(__self__, *,
                 matching_type: pulumi.Input[str],
                 dictionary: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryArgs']] = None,
                 exclude_by_hotword: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgs']] = None,
                 exclude_info_types: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgs']] = None,
                 regex: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleRegexArgs']] = None):
        """
        :param pulumi.Input[str] matching_type: How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType
               Possible values are: `MATCHING_TYPE_FULL_MATCH`, `MATCHING_TYPE_PARTIAL_MATCH`, `MATCHING_TYPE_INVERSE_MATCH`.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryArgs'] dictionary: Dictionary which defines the rule.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgs'] exclude_by_hotword: Drop if the hotword rule is contained in the proximate context.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgs'] exclude_info_types: Set of infoTypes for which findings would affect this rule.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleRegexArgs'] regex: Regular expression which defines the rule.
               Structure is documented below.
        """
        pulumi.set(__self__, "matching_type", matching_type)
        if dictionary is not None:
            pulumi.set(__self__, "dictionary", dictionary)
        if exclude_by_hotword is not None:
            pulumi.set(__self__, "exclude_by_hotword", exclude_by_hotword)
        if exclude_info_types is not None:
            pulumi.set(__self__, "exclude_info_types", exclude_info_types)
        if regex is not None:
            pulumi.set(__self__, "regex", regex)

    @property
    @pulumi.getter(name="matchingType")
    def matching_type(self) -> pulumi.Input[str]:
        """
        How the rule is applied. See the documentation for more information: https://cloud.google.com/dlp/docs/reference/rest/v2/InspectConfig#MatchingType
        Possible values are: `MATCHING_TYPE_FULL_MATCH`, `MATCHING_TYPE_PARTIAL_MATCH`, `MATCHING_TYPE_INVERSE_MATCH`.
        """
        return pulumi.get(self, "matching_type")

    @matching_type.setter
    def matching_type(self, value: pulumi.Input[str]):
        pulumi.set(self, "matching_type", value)

    @property
    @pulumi.getter
    def dictionary(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryArgs']]:
        """
        Dictionary which defines the rule.
        Structure is documented below.
        """
        return pulumi.get(self, "dictionary")

    @dictionary.setter
    def dictionary(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryArgs']]):
        pulumi.set(self, "dictionary", value)

    @property
    @pulumi.getter(name="excludeByHotword")
    def exclude_by_hotword(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgs']]:
        """
        Drop if the hotword rule is contained in the proximate context.
        Structure is documented below.
        """
        return pulumi.get(self, "exclude_by_hotword")

    @exclude_by_hotword.setter
    def exclude_by_hotword(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgs']]):
        pulumi.set(self, "exclude_by_hotword", value)

    @property
    @pulumi.getter(name="excludeInfoTypes")
    def exclude_info_types(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgs']]:
        """
        Set of infoTypes for which findings would affect this rule.
        Structure is documented below.
        """
        return pulumi.get(self, "exclude_info_types")

    @exclude_info_types.setter
    def exclude_info_types(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgs']]):
        pulumi.set(self, "exclude_info_types", value)

    @property
    @pulumi.getter
    def regex(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleRegexArgs']]:
        """
        Regular expression which defines the rule.
        Structure is documented below.
        """
        return pulumi.get(self, "regex")

    @regex.setter
    def regex(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleRegexArgs']]):
        pulumi.set(self, "regex", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryArgsDict(TypedDict):
        cloud_storage_path: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgsDict']]
        """
        Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
        Structure is documented below.
        """
        word_list: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgsDict']]
        """
        List of words or phrases to search for.
        Structure is documented below.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryArgs:
    def __init__(__self__, *,
                 cloud_storage_path: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgs']] = None,
                 word_list: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgs']] = None):
        """
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgs'] cloud_storage_path: Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgs'] word_list: List of words or phrases to search for.
               Structure is documented below.
        """
        if cloud_storage_path is not None:
            pulumi.set(__self__, "cloud_storage_path", cloud_storage_path)
        if word_list is not None:
            pulumi.set(__self__, "word_list", word_list)

    @property
    @pulumi.getter(name="cloudStoragePath")
    def cloud_storage_path(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgs']]:
        """
        Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_storage_path")

    @cloud_storage_path.setter
    def cloud_storage_path(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgs']]):
        pulumi.set(self, "cloud_storage_path", value)

    @property
    @pulumi.getter(name="wordList")
    def word_list(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgs']]:
        """
        List of words or phrases to search for.
        Structure is documented below.
        """
        return pulumi.get(self, "word_list")

    @word_list.setter
    def word_list(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgs']]):
        pulumi.set(self, "word_list", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgsDict(TypedDict):
        path: pulumi.Input[str]
        """
        A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryCloudStoragePathArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str]):
        """
        :param pulumi.Input[str] path: A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
        """
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgsDict(TypedDict):
        words: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Words or phrases defining the dictionary. The dictionary must contain at least one
        phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleDictionaryWordListArgs:
    def __init__(__self__, *,
                 words: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] words: Words or phrases defining the dictionary. The dictionary must contain at least one
               phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
        pulumi.set(__self__, "words", words)

    @property
    @pulumi.getter
    def words(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Words or phrases defining the dictionary. The dictionary must contain at least one
        phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
        return pulumi.get(self, "words")

    @words.setter
    def words(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "words", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgsDict(TypedDict):
        hotword_regex: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgsDict']]
        """
        Regular expression pattern defining what qualifies as a hotword.
        Structure is documented below.
        """
        proximity: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgsDict']]
        """
        Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
        exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
        used to match substrings of the finding itself. For example, the certainty of a phone number regex
        `(\\d{3}) \\d{3}-\\d{4}` could be adjusted upwards if the area code is known to be the local area code of a company
        office using the hotword regex `(xxx)`, where `xxx` is the area code in question.
        Structure is documented below.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordArgs:
    def __init__(__self__, *,
                 hotword_regex: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgs']] = None,
                 proximity: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgs']] = None):
        """
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgs'] hotword_regex: Regular expression pattern defining what qualifies as a hotword.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgs'] proximity: Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
               exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
               used to match substrings of the finding itself. For example, the certainty of a phone number regex
               `(\\d{3}) \\d{3}-\\d{4}` could be adjusted upwards if the area code is known to be the local area code of a company
               office using the hotword regex `(xxx)`, where `xxx` is the area code in question.
               Structure is documented below.
        """
        if hotword_regex is not None:
            pulumi.set(__self__, "hotword_regex", hotword_regex)
        if proximity is not None:
            pulumi.set(__self__, "proximity", proximity)

    @property
    @pulumi.getter(name="hotwordRegex")
    def hotword_regex(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgs']]:
        """
        Regular expression pattern defining what qualifies as a hotword.
        Structure is documented below.
        """
        return pulumi.get(self, "hotword_regex")

    @hotword_regex.setter
    def hotword_regex(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgs']]):
        pulumi.set(self, "hotword_regex", value)

    @property
    @pulumi.getter
    def proximity(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgs']]:
        """
        Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
        exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
        used to match substrings of the finding itself. For example, the certainty of a phone number regex
        `(\\d{3}) \\d{3}-\\d{4}` could be adjusted upwards if the area code is known to be the local area code of a company
        office using the hotword regex `(xxx)`, where `xxx` is the area code in question.
        Structure is documented below.
        """
        return pulumi.get(self, "proximity")

    @proximity.setter
    def proximity(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgs']]):
        pulumi.set(self, "proximity", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgsDict(TypedDict):
        group_indexes: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        The index of the submatch to extract as findings. When not specified,
        the entire match is returned. No more than 3 may be included.
        """
        pattern: NotRequired[pulumi.Input[str]]
        """
        Pattern defining the regular expression. Its syntax
        (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordHotwordRegexArgs:
    def __init__(__self__, *,
                 group_indexes: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 pattern: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] group_indexes: The index of the submatch to extract as findings. When not specified,
               the entire match is returned. No more than 3 may be included.
        :param pulumi.Input[str] pattern: Pattern defining the regular expression. Its syntax
               (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
        if group_indexes is not None:
            pulumi.set(__self__, "group_indexes", group_indexes)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter(name="groupIndexes")
    def group_indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The index of the submatch to extract as findings. When not specified,
        the entire match is returned. No more than 3 may be included.
        """
        return pulumi.get(self, "group_indexes")

    @group_indexes.setter
    def group_indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "group_indexes", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[str]]:
        """
        Pattern defining the regular expression. Its syntax
        (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pattern", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgsDict(TypedDict):
        window_after: NotRequired[pulumi.Input[int]]
        """
        Number of characters after the finding to consider. Either this or window_before must be specified
        """
        window_before: NotRequired[pulumi.Input[int]]
        """
        Number of characters before the finding to consider. Either this or window_after must be specified
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeByHotwordProximityArgs:
    def __init__(__self__, *,
                 window_after: Optional[pulumi.Input[int]] = None,
                 window_before: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] window_after: Number of characters after the finding to consider. Either this or window_before must be specified
        :param pulumi.Input[int] window_before: Number of characters before the finding to consider. Either this or window_after must be specified
        """
        if window_after is not None:
            pulumi.set(__self__, "window_after", window_after)
        if window_before is not None:
            pulumi.set(__self__, "window_before", window_before)

    @property
    @pulumi.getter(name="windowAfter")
    def window_after(self) -> Optional[pulumi.Input[int]]:
        """
        Number of characters after the finding to consider. Either this or window_before must be specified
        """
        return pulumi.get(self, "window_after")

    @window_after.setter
    def window_after(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "window_after", value)

    @property
    @pulumi.getter(name="windowBefore")
    def window_before(self) -> Optional[pulumi.Input[int]]:
        """
        Number of characters before the finding to consider. Either this or window_after must be specified
        """
        return pulumi.get(self, "window_before")

    @window_before.setter
    def window_before(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "window_before", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgsDict(TypedDict):
        info_types: pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgsDict']]]
        """
        If a finding is matched by any of the infoType detectors listed here, the finding will be excluded from the scan results.
        Structure is documented below.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesArgs:
    def __init__(__self__, *,
                 info_types: pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgs']]] info_types: If a finding is matched by any of the infoType detectors listed here, the finding will be excluded from the scan results.
               Structure is documented below.
        """
        pulumi.set(__self__, "info_types", info_types)

    @property
    @pulumi.getter(name="infoTypes")
    def info_types(self) -> pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgs']]]:
        """
        If a finding is matched by any of the infoType detectors listed here, the finding will be excluded from the scan results.
        Structure is documented below.
        """
        return pulumi.get(self, "info_types")

    @info_types.setter
    def info_types(self, value: pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgs']]]):
        pulumi.set(self, "info_types", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
        at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        sensitivity_score: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgsDict']]
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        version: NotRequired[pulumi.Input[str]]
        """
        Version of the information type to use. By default, the version is set to stable.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str],
                 sensitivity_score: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgs']] = None,
                 version: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] name: Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
               at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgs'] sensitivity_score: Optional custom sensitivity for this InfoType. This only applies to data profiling.
               Structure is documented below.
        :param pulumi.Input[str] version: Version of the information type to use. By default, the version is set to stable.
        """
        pulumi.set(__self__, "name", name)
        if sensitivity_score is not None:
            pulumi.set(__self__, "sensitivity_score", sensitivity_score)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name of the information type. Either a name of your choosing when creating a CustomInfoType, or one of the names listed
        at https://cloud.google.com/dlp/docs/infotypes-reference when specifying a built-in type.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)

    @property
    @pulumi.getter(name="sensitivityScore")
    def sensitivity_score(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgs']]:
        """
        Optional custom sensitivity for this InfoType. This only applies to data profiling.
        Structure is documented below.
        """
        return pulumi.get(self, "sensitivity_score")

    @sensitivity_score.setter
    def sensitivity_score(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgs']]):
        pulumi.set(self, "sensitivity_score", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[str]]:
        """
        Version of the information type to use. By default, the version is set to stable.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgsDict(TypedDict):
        score: pulumi.Input[str]
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleExcludeInfoTypesInfoTypeSensitivityScoreArgs:
    def __init__(__self__, *,
                 score: pulumi.Input[str]):
        """
        :param pulumi.Input[str] score: The sensitivity score applied to the resource.
               Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        pulumi.set(__self__, "score", score)

    @property
    @pulumi.getter
    def score(self) -> pulumi.Input[str]:
        """
        The sensitivity score applied to the resource.
        Possible values are: `SENSITIVITY_LOW`, `SENSITIVITY_MODERATE`, `SENSITIVITY_HIGH`.
        """
        return pulumi.get(self, "score")

    @score.setter
    def score(self, value: pulumi.Input[str]):
        pulumi.set(self, "score", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleRegexArgsDict(TypedDict):
        pattern: pulumi.Input[str]
        """
        Pattern defining the regular expression.
        Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
        group_indexes: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleRegexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleExclusionRuleRegexArgs:
    def __init__(__self__, *,
                 pattern: pulumi.Input[str],
                 group_indexes: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[str] pattern: Pattern defining the regular expression.
               Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] group_indexes: The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
        """
        pulumi.set(__self__, "pattern", pattern)
        if group_indexes is not None:
            pulumi.set(__self__, "group_indexes", group_indexes)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        Pattern defining the regular expression.
        Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter(name="groupIndexes")
    def group_indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
        """
        return pulumi.get(self, "group_indexes")

    @group_indexes.setter
    def group_indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "group_indexes", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleArgsDict(TypedDict):
        hotword_regex: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgsDict']]
        """
        Regular expression pattern defining what qualifies as a hotword.
        Structure is documented below.
        """
        likelihood_adjustment: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgsDict']]
        """
        Likelihood adjustment to apply to all matching findings.
        Structure is documented below.
        """
        proximity: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleProximityArgsDict']]
        """
        Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
        exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
        used to match substrings of the finding itself. For example, the certainty of a phone number regex
        `(\\d{3}) \\d{3}-\\d{4}` could be adjusted upwards if the area code is known to be the local area code of a company
        office using the hotword regex `(xxx)`, where `xxx` is the area code in question.
        Structure is documented below.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleArgs:
    def __init__(__self__, *,
                 hotword_regex: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgs']] = None,
                 likelihood_adjustment: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgs']] = None,
                 proximity: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleProximityArgs']] = None):
        """
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgs'] hotword_regex: Regular expression pattern defining what qualifies as a hotword.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgs'] likelihood_adjustment: Likelihood adjustment to apply to all matching findings.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleProximityArgs'] proximity: Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
               exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
               used to match substrings of the finding itself. For example, the certainty of a phone number regex
               `(\\d{3}) \\d{3}-\\d{4}` could be adjusted upwards if the area code is known to be the local area code of a company
               office using the hotword regex `(xxx)`, where `xxx` is the area code in question.
               Structure is documented below.
        """
        if hotword_regex is not None:
            pulumi.set(__self__, "hotword_regex", hotword_regex)
        if likelihood_adjustment is not None:
            pulumi.set(__self__, "likelihood_adjustment", likelihood_adjustment)
        if proximity is not None:
            pulumi.set(__self__, "proximity", proximity)

    @property
    @pulumi.getter(name="hotwordRegex")
    def hotword_regex(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgs']]:
        """
        Regular expression pattern defining what qualifies as a hotword.
        Structure is documented below.
        """
        return pulumi.get(self, "hotword_regex")

    @hotword_regex.setter
    def hotword_regex(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgs']]):
        pulumi.set(self, "hotword_regex", value)

    @property
    @pulumi.getter(name="likelihoodAdjustment")
    def likelihood_adjustment(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgs']]:
        """
        Likelihood adjustment to apply to all matching findings.
        Structure is documented below.
        """
        return pulumi.get(self, "likelihood_adjustment")

    @likelihood_adjustment.setter
    def likelihood_adjustment(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgs']]):
        pulumi.set(self, "likelihood_adjustment", value)

    @property
    @pulumi.getter
    def proximity(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleProximityArgs']]:
        """
        Proximity of the finding within which the entire hotword must reside. The total length of the window cannot
        exceed 1000 characters. Note that the finding itself will be included in the window, so that hotwords may be
        used to match substrings of the finding itself. For example, the certainty of a phone number regex
        `(\\d{3}) \\d{3}-\\d{4}` could be adjusted upwards if the area code is known to be the local area code of a company
        office using the hotword regex `(xxx)`, where `xxx` is the area code in question.
        Structure is documented below.
        """
        return pulumi.get(self, "proximity")

    @proximity.setter
    def proximity(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleProximityArgs']]):
        pulumi.set(self, "proximity", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgsDict(TypedDict):
        group_indexes: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        The index of the submatch to extract as findings. When not specified,
        the entire match is returned. No more than 3 may be included.
        """
        pattern: NotRequired[pulumi.Input[str]]
        """
        Pattern defining the regular expression. Its syntax
        (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleHotwordRegexArgs:
    def __init__(__self__, *,
                 group_indexes: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None,
                 pattern: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[int]]] group_indexes: The index of the submatch to extract as findings. When not specified,
               the entire match is returned. No more than 3 may be included.
        :param pulumi.Input[str] pattern: Pattern defining the regular expression. Its syntax
               (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
        if group_indexes is not None:
            pulumi.set(__self__, "group_indexes", group_indexes)
        if pattern is not None:
            pulumi.set(__self__, "pattern", pattern)

    @property
    @pulumi.getter(name="groupIndexes")
    def group_indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The index of the submatch to extract as findings. When not specified,
        the entire match is returned. No more than 3 may be included.
        """
        return pulumi.get(self, "group_indexes")

    @group_indexes.setter
    def group_indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "group_indexes", value)

    @property
    @pulumi.getter
    def pattern(self) -> Optional[pulumi.Input[str]]:
        """
        Pattern defining the regular expression. Its syntax
        (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "pattern", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgsDict(TypedDict):
        fixed_likelihood: NotRequired[pulumi.Input[str]]
        """
        Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set.
        Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
        """
        relative_likelihood: NotRequired[pulumi.Input[int]]
        """
        Increase or decrease the likelihood by the specified number of levels. For example,
        if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1,
        then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY.
        Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an
        adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY
        will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleLikelihoodAdjustmentArgs:
    def __init__(__self__, *,
                 fixed_likelihood: Optional[pulumi.Input[str]] = None,
                 relative_likelihood: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] fixed_likelihood: Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set.
               Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
        :param pulumi.Input[int] relative_likelihood: Increase or decrease the likelihood by the specified number of levels. For example,
               if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1,
               then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY.
               Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an
               adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY
               will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
        """
        if fixed_likelihood is not None:
            pulumi.set(__self__, "fixed_likelihood", fixed_likelihood)
        if relative_likelihood is not None:
            pulumi.set(__self__, "relative_likelihood", relative_likelihood)

    @property
    @pulumi.getter(name="fixedLikelihood")
    def fixed_likelihood(self) -> Optional[pulumi.Input[str]]:
        """
        Set the likelihood of a finding to a fixed value. Either this or relative_likelihood can be set.
        Possible values are: `VERY_UNLIKELY`, `UNLIKELY`, `POSSIBLE`, `LIKELY`, `VERY_LIKELY`.
        """
        return pulumi.get(self, "fixed_likelihood")

    @fixed_likelihood.setter
    def fixed_likelihood(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "fixed_likelihood", value)

    @property
    @pulumi.getter(name="relativeLikelihood")
    def relative_likelihood(self) -> Optional[pulumi.Input[int]]:
        """
        Increase or decrease the likelihood by the specified number of levels. For example,
        if a finding would be POSSIBLE without the detection rule and relativeLikelihood is 1,
        then it is upgraded to LIKELY, while a value of -1 would downgrade it to UNLIKELY.
        Likelihood may never drop below VERY_UNLIKELY or exceed VERY_LIKELY, so applying an
        adjustment of 1 followed by an adjustment of -1 when base likelihood is VERY_LIKELY
        will result in a final likelihood of LIKELY. Either this or fixed_likelihood can be set.
        """
        return pulumi.get(self, "relative_likelihood")

    @relative_likelihood.setter
    def relative_likelihood(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "relative_likelihood", value)


if not MYPY:
    class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleProximityArgsDict(TypedDict):
        window_after: NotRequired[pulumi.Input[int]]
        """
        Number of characters after the finding to consider. Either this or window_before must be specified
        """
        window_before: NotRequired[pulumi.Input[int]]
        """
        Number of characters before the finding to consider. Either this or window_after must be specified
        """
elif False:
    PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleProximityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobInspectConfigRuleSetRuleHotwordRuleProximityArgs:
    def __init__(__self__, *,
                 window_after: Optional[pulumi.Input[int]] = None,
                 window_before: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] window_after: Number of characters after the finding to consider. Either this or window_before must be specified
        :param pulumi.Input[int] window_before: Number of characters before the finding to consider. Either this or window_after must be specified
        """
        if window_after is not None:
            pulumi.set(__self__, "window_after", window_after)
        if window_before is not None:
            pulumi.set(__self__, "window_before", window_before)

    @property
    @pulumi.getter(name="windowAfter")
    def window_after(self) -> Optional[pulumi.Input[int]]:
        """
        Number of characters after the finding to consider. Either this or window_before must be specified
        """
        return pulumi.get(self, "window_after")

    @window_after.setter
    def window_after(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "window_after", value)

    @property
    @pulumi.getter(name="windowBefore")
    def window_before(self) -> Optional[pulumi.Input[int]]:
        """
        Number of characters before the finding to consider. Either this or window_after must be specified
        """
        return pulumi.get(self, "window_before")

    @window_before.setter
    def window_before(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "window_before", value)


if not MYPY:
    class PreventionJobTriggerInspectJobStorageConfigArgsDict(TypedDict):
        big_query_options: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsArgsDict']]
        """
        Options defining BigQuery table and row identifiers.
        Structure is documented below.
        """
        cloud_storage_options: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsArgsDict']]
        """
        Options defining a file or a set of files within a Google Cloud Storage bucket.
        Structure is documented below.
        """
        datastore_options: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsArgsDict']]
        """
        Options defining a data set within Google Cloud Datastore.
        Structure is documented below.
        """
        hybrid_options: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigHybridOptionsArgsDict']]
        """
        Configuration to control jobs where the content being inspected is outside of Google Cloud Platform.
        Structure is documented below.
        """
        timespan_config: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigTimespanConfigArgsDict']]
        """
        Configuration of the timespan of the items to include in scanning
        Structure is documented below.
        """
elif False:
    PreventionJobTriggerInspectJobStorageConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobStorageConfigArgs:
    def __init__(__self__, *,
                 big_query_options: Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsArgs']] = None,
                 cloud_storage_options: Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsArgs']] = None,
                 datastore_options: Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsArgs']] = None,
                 hybrid_options: Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigHybridOptionsArgs']] = None,
                 timespan_config: Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigTimespanConfigArgs']] = None):
        """
        :param pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsArgs'] big_query_options: Options defining BigQuery table and row identifiers.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsArgs'] cloud_storage_options: Options defining a file or a set of files within a Google Cloud Storage bucket.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsArgs'] datastore_options: Options defining a data set within Google Cloud Datastore.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobStorageConfigHybridOptionsArgs'] hybrid_options: Configuration to control jobs where the content being inspected is outside of Google Cloud Platform.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobStorageConfigTimespanConfigArgs'] timespan_config: Configuration of the timespan of the items to include in scanning
               Structure is documented below.
        """
        if big_query_options is not None:
            pulumi.set(__self__, "big_query_options", big_query_options)
        if cloud_storage_options is not None:
            pulumi.set(__self__, "cloud_storage_options", cloud_storage_options)
        if datastore_options is not None:
            pulumi.set(__self__, "datastore_options", datastore_options)
        if hybrid_options is not None:
            pulumi.set(__self__, "hybrid_options", hybrid_options)
        if timespan_config is not None:
            pulumi.set(__self__, "timespan_config", timespan_config)

    @property
    @pulumi.getter(name="bigQueryOptions")
    def big_query_options(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsArgs']]:
        """
        Options defining BigQuery table and row identifiers.
        Structure is documented below.
        """
        return pulumi.get(self, "big_query_options")

    @big_query_options.setter
    def big_query_options(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsArgs']]):
        pulumi.set(self, "big_query_options", value)

    @property
    @pulumi.getter(name="cloudStorageOptions")
    def cloud_storage_options(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsArgs']]:
        """
        Options defining a file or a set of files within a Google Cloud Storage bucket.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_storage_options")

    @cloud_storage_options.setter
    def cloud_storage_options(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsArgs']]):
        pulumi.set(self, "cloud_storage_options", value)

    @property
    @pulumi.getter(name="datastoreOptions")
    def datastore_options(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsArgs']]:
        """
        Options defining a data set within Google Cloud Datastore.
        Structure is documented below.
        """
        return pulumi.get(self, "datastore_options")

    @datastore_options.setter
    def datastore_options(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsArgs']]):
        pulumi.set(self, "datastore_options", value)

    @property
    @pulumi.getter(name="hybridOptions")
    def hybrid_options(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigHybridOptionsArgs']]:
        """
        Configuration to control jobs where the content being inspected is outside of Google Cloud Platform.
        Structure is documented below.
        """
        return pulumi.get(self, "hybrid_options")

    @hybrid_options.setter
    def hybrid_options(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigHybridOptionsArgs']]):
        pulumi.set(self, "hybrid_options", value)

    @property
    @pulumi.getter(name="timespanConfig")
    def timespan_config(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigTimespanConfigArgs']]:
        """
        Configuration of the timespan of the items to include in scanning
        Structure is documented below.
        """
        return pulumi.get(self, "timespan_config")

    @timespan_config.setter
    def timespan_config(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigTimespanConfigArgs']]):
        pulumi.set(self, "timespan_config", value)


if not MYPY:
    class PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsArgsDict(TypedDict):
        table_reference: pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsTableReferenceArgsDict']
        """
        Set of files to scan.
        Structure is documented below.
        """
        excluded_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsExcludedFieldArgsDict']]]]
        """
        References to fields excluded from scanning.
        This allows you to skip inspection of entire columns which you know have no findings.
        Structure is documented below.
        """
        identifying_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIdentifyingFieldArgsDict']]]]
        """
        Specifies the BigQuery fields that will be returned with findings.
        If not specified, no identifying fields will be returned for findings.
        Structure is documented below.
        """
        included_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIncludedFieldArgsDict']]]]
        """
        Limit scanning only to these fields.
        Structure is documented below.
        """
        rows_limit: NotRequired[pulumi.Input[int]]
        """
        Max number of rows to scan. If the table has more rows than this value, the rest of the rows are omitted.
        If not set, or if set to 0, all rows will be scanned. Only one of rowsLimit and rowsLimitPercent can be
        specified. Cannot be used in conjunction with TimespanConfig.
        """
        rows_limit_percent: NotRequired[pulumi.Input[int]]
        """
        Max percentage of rows to scan. The rest are omitted. The number of rows scanned is rounded down.
        Must be between 0 and 100, inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of
        rowsLimit and rowsLimitPercent can be specified. Cannot be used in conjunction with TimespanConfig.
        """
        sample_method: NotRequired[pulumi.Input[str]]
        """
        How to sample rows if not all rows are scanned. Meaningful only when used in conjunction with either
        rowsLimit or rowsLimitPercent. If not specified, rows are scanned in the order BigQuery reads them.
        If TimespanConfig is set, set this to an empty string to avoid using the default value.
        Default value is `TOP`.
        Possible values are: `TOP`, `RANDOM_START`.
        """
elif False:
    PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsArgs:
    def __init__(__self__, *,
                 table_reference: pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsTableReferenceArgs'],
                 excluded_fields: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsExcludedFieldArgs']]]] = None,
                 identifying_fields: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIdentifyingFieldArgs']]]] = None,
                 included_fields: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIncludedFieldArgs']]]] = None,
                 rows_limit: Optional[pulumi.Input[int]] = None,
                 rows_limit_percent: Optional[pulumi.Input[int]] = None,
                 sample_method: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsTableReferenceArgs'] table_reference: Set of files to scan.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsExcludedFieldArgs']]] excluded_fields: References to fields excluded from scanning.
               This allows you to skip inspection of entire columns which you know have no findings.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIdentifyingFieldArgs']]] identifying_fields: Specifies the BigQuery fields that will be returned with findings.
               If not specified, no identifying fields will be returned for findings.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIncludedFieldArgs']]] included_fields: Limit scanning only to these fields.
               Structure is documented below.
        :param pulumi.Input[int] rows_limit: Max number of rows to scan. If the table has more rows than this value, the rest of the rows are omitted.
               If not set, or if set to 0, all rows will be scanned. Only one of rowsLimit and rowsLimitPercent can be
               specified. Cannot be used in conjunction with TimespanConfig.
        :param pulumi.Input[int] rows_limit_percent: Max percentage of rows to scan. The rest are omitted. The number of rows scanned is rounded down.
               Must be between 0 and 100, inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of
               rowsLimit and rowsLimitPercent can be specified. Cannot be used in conjunction with TimespanConfig.
        :param pulumi.Input[str] sample_method: How to sample rows if not all rows are scanned. Meaningful only when used in conjunction with either
               rowsLimit or rowsLimitPercent. If not specified, rows are scanned in the order BigQuery reads them.
               If TimespanConfig is set, set this to an empty string to avoid using the default value.
               Default value is `TOP`.
               Possible values are: `TOP`, `RANDOM_START`.
        """
        pulumi.set(__self__, "table_reference", table_reference)
        if excluded_fields is not None:
            pulumi.set(__self__, "excluded_fields", excluded_fields)
        if identifying_fields is not None:
            pulumi.set(__self__, "identifying_fields", identifying_fields)
        if included_fields is not None:
            pulumi.set(__self__, "included_fields", included_fields)
        if rows_limit is not None:
            pulumi.set(__self__, "rows_limit", rows_limit)
        if rows_limit_percent is not None:
            pulumi.set(__self__, "rows_limit_percent", rows_limit_percent)
        if sample_method is not None:
            pulumi.set(__self__, "sample_method", sample_method)

    @property
    @pulumi.getter(name="tableReference")
    def table_reference(self) -> pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsTableReferenceArgs']:
        """
        Set of files to scan.
        Structure is documented below.
        """
        return pulumi.get(self, "table_reference")

    @table_reference.setter
    def table_reference(self, value: pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsTableReferenceArgs']):
        pulumi.set(self, "table_reference", value)

    @property
    @pulumi.getter(name="excludedFields")
    def excluded_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsExcludedFieldArgs']]]]:
        """
        References to fields excluded from scanning.
        This allows you to skip inspection of entire columns which you know have no findings.
        Structure is documented below.
        """
        return pulumi.get(self, "excluded_fields")

    @excluded_fields.setter
    def excluded_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsExcludedFieldArgs']]]]):
        pulumi.set(self, "excluded_fields", value)

    @property
    @pulumi.getter(name="identifyingFields")
    def identifying_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIdentifyingFieldArgs']]]]:
        """
        Specifies the BigQuery fields that will be returned with findings.
        If not specified, no identifying fields will be returned for findings.
        Structure is documented below.
        """
        return pulumi.get(self, "identifying_fields")

    @identifying_fields.setter
    def identifying_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIdentifyingFieldArgs']]]]):
        pulumi.set(self, "identifying_fields", value)

    @property
    @pulumi.getter(name="includedFields")
    def included_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIncludedFieldArgs']]]]:
        """
        Limit scanning only to these fields.
        Structure is documented below.
        """
        return pulumi.get(self, "included_fields")

    @included_fields.setter
    def included_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIncludedFieldArgs']]]]):
        pulumi.set(self, "included_fields", value)

    @property
    @pulumi.getter(name="rowsLimit")
    def rows_limit(self) -> Optional[pulumi.Input[int]]:
        """
        Max number of rows to scan. If the table has more rows than this value, the rest of the rows are omitted.
        If not set, or if set to 0, all rows will be scanned. Only one of rowsLimit and rowsLimitPercent can be
        specified. Cannot be used in conjunction with TimespanConfig.
        """
        return pulumi.get(self, "rows_limit")

    @rows_limit.setter
    def rows_limit(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rows_limit", value)

    @property
    @pulumi.getter(name="rowsLimitPercent")
    def rows_limit_percent(self) -> Optional[pulumi.Input[int]]:
        """
        Max percentage of rows to scan. The rest are omitted. The number of rows scanned is rounded down.
        Must be between 0 and 100, inclusively. Both 0 and 100 means no limit. Defaults to 0. Only one of
        rowsLimit and rowsLimitPercent can be specified. Cannot be used in conjunction with TimespanConfig.
        """
        return pulumi.get(self, "rows_limit_percent")

    @rows_limit_percent.setter
    def rows_limit_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "rows_limit_percent", value)

    @property
    @pulumi.getter(name="sampleMethod")
    def sample_method(self) -> Optional[pulumi.Input[str]]:
        """
        How to sample rows if not all rows are scanned. Meaningful only when used in conjunction with either
        rowsLimit or rowsLimitPercent. If not specified, rows are scanned in the order BigQuery reads them.
        If TimespanConfig is set, set this to an empty string to avoid using the default value.
        Default value is `TOP`.
        Possible values are: `TOP`, `RANDOM_START`.
        """
        return pulumi.get(self, "sample_method")

    @sample_method.setter
    def sample_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sample_method", value)


if not MYPY:
    class PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsExcludedFieldArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name describing the field excluded from scanning.
        """
elif False:
    PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsExcludedFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsExcludedFieldArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name describing the field excluded from scanning.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name describing the field excluded from scanning.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIdentifyingFieldArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name describing the field.
        """
elif False:
    PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIdentifyingFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIdentifyingFieldArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name describing the field.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name describing the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIncludedFieldArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name describing the field to which scanning is limited.
        """
elif False:
    PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIncludedFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsIncludedFieldArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name describing the field to which scanning is limited.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name describing the field to which scanning is limited.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsTableReferenceArgsDict(TypedDict):
        dataset_id: pulumi.Input[str]
        """
        The dataset ID of the table.
        """
        project_id: pulumi.Input[str]
        """
        The Google Cloud Platform project ID of the project containing the table.
        """
        table_id: pulumi.Input[str]
        """
        The name of the table.
        """
elif False:
    PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsTableReferenceArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobStorageConfigBigQueryOptionsTableReferenceArgs:
    def __init__(__self__, *,
                 dataset_id: pulumi.Input[str],
                 project_id: pulumi.Input[str],
                 table_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] dataset_id: The dataset ID of the table.
        :param pulumi.Input[str] project_id: The Google Cloud Platform project ID of the project containing the table.
        :param pulumi.Input[str] table_id: The name of the table.
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "table_id", table_id)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> pulumi.Input[str]:
        """
        The dataset ID of the table.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The Google Cloud Platform project ID of the project containing the table.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="tableId")
    def table_id(self) -> pulumi.Input[str]:
        """
        The name of the table.
        """
        return pulumi.get(self, "table_id")

    @table_id.setter
    def table_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_id", value)


if not MYPY:
    class PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsArgsDict(TypedDict):
        file_set: pulumi.Input['PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetArgsDict']
        """
        Set of files to scan.
        Structure is documented below.
        """
        bytes_limit_per_file: NotRequired[pulumi.Input[int]]
        """
        Max number of bytes to scan from a file. If a scanned file's size is bigger than this value
        then the rest of the bytes are omitted.
        """
        bytes_limit_per_file_percent: NotRequired[pulumi.Input[int]]
        """
        Max percentage of bytes to scan from a file. The rest are omitted. The number of bytes scanned is rounded down.
        Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
        """
        file_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        List of file type groups to include in the scan. If empty, all files are scanned and available data
        format processors are applied. In addition, the binary content of the selected files is always scanned as well.
        Images are scanned only as binary if the specified region does not support image inspection and no fileTypes were specified.
        Each value may be one of: `BINARY_FILE`, `TEXT_FILE`, `IMAGE`, `WORD`, `PDF`, `AVRO`, `CSV`, `TSV`, `POWERPOINT`, `EXCEL`.
        """
        files_limit_percent: NotRequired[pulumi.Input[int]]
        """
        Limits the number of files to scan to this percentage of the input FileSet. Number of files scanned is rounded down.
        Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
        """
        sample_method: NotRequired[pulumi.Input[str]]
        """
        How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile.
        If not specified, scanning would start from the top.
        Possible values are: `TOP`, `RANDOM_START`.
        """
elif False:
    PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsArgs:
    def __init__(__self__, *,
                 file_set: pulumi.Input['PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetArgs'],
                 bytes_limit_per_file: Optional[pulumi.Input[int]] = None,
                 bytes_limit_per_file_percent: Optional[pulumi.Input[int]] = None,
                 file_types: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 files_limit_percent: Optional[pulumi.Input[int]] = None,
                 sample_method: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetArgs'] file_set: Set of files to scan.
               Structure is documented below.
        :param pulumi.Input[int] bytes_limit_per_file: Max number of bytes to scan from a file. If a scanned file's size is bigger than this value
               then the rest of the bytes are omitted.
        :param pulumi.Input[int] bytes_limit_per_file_percent: Max percentage of bytes to scan from a file. The rest are omitted. The number of bytes scanned is rounded down.
               Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] file_types: List of file type groups to include in the scan. If empty, all files are scanned and available data
               format processors are applied. In addition, the binary content of the selected files is always scanned as well.
               Images are scanned only as binary if the specified region does not support image inspection and no fileTypes were specified.
               Each value may be one of: `BINARY_FILE`, `TEXT_FILE`, `IMAGE`, `WORD`, `PDF`, `AVRO`, `CSV`, `TSV`, `POWERPOINT`, `EXCEL`.
        :param pulumi.Input[int] files_limit_percent: Limits the number of files to scan to this percentage of the input FileSet. Number of files scanned is rounded down.
               Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
        :param pulumi.Input[str] sample_method: How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile.
               If not specified, scanning would start from the top.
               Possible values are: `TOP`, `RANDOM_START`.
        """
        pulumi.set(__self__, "file_set", file_set)
        if bytes_limit_per_file is not None:
            pulumi.set(__self__, "bytes_limit_per_file", bytes_limit_per_file)
        if bytes_limit_per_file_percent is not None:
            pulumi.set(__self__, "bytes_limit_per_file_percent", bytes_limit_per_file_percent)
        if file_types is not None:
            pulumi.set(__self__, "file_types", file_types)
        if files_limit_percent is not None:
            pulumi.set(__self__, "files_limit_percent", files_limit_percent)
        if sample_method is not None:
            pulumi.set(__self__, "sample_method", sample_method)

    @property
    @pulumi.getter(name="fileSet")
    def file_set(self) -> pulumi.Input['PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetArgs']:
        """
        Set of files to scan.
        Structure is documented below.
        """
        return pulumi.get(self, "file_set")

    @file_set.setter
    def file_set(self, value: pulumi.Input['PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetArgs']):
        pulumi.set(self, "file_set", value)

    @property
    @pulumi.getter(name="bytesLimitPerFile")
    def bytes_limit_per_file(self) -> Optional[pulumi.Input[int]]:
        """
        Max number of bytes to scan from a file. If a scanned file's size is bigger than this value
        then the rest of the bytes are omitted.
        """
        return pulumi.get(self, "bytes_limit_per_file")

    @bytes_limit_per_file.setter
    def bytes_limit_per_file(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bytes_limit_per_file", value)

    @property
    @pulumi.getter(name="bytesLimitPerFilePercent")
    def bytes_limit_per_file_percent(self) -> Optional[pulumi.Input[int]]:
        """
        Max percentage of bytes to scan from a file. The rest are omitted. The number of bytes scanned is rounded down.
        Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
        """
        return pulumi.get(self, "bytes_limit_per_file_percent")

    @bytes_limit_per_file_percent.setter
    def bytes_limit_per_file_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "bytes_limit_per_file_percent", value)

    @property
    @pulumi.getter(name="fileTypes")
    def file_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        List of file type groups to include in the scan. If empty, all files are scanned and available data
        format processors are applied. In addition, the binary content of the selected files is always scanned as well.
        Images are scanned only as binary if the specified region does not support image inspection and no fileTypes were specified.
        Each value may be one of: `BINARY_FILE`, `TEXT_FILE`, `IMAGE`, `WORD`, `PDF`, `AVRO`, `CSV`, `TSV`, `POWERPOINT`, `EXCEL`.
        """
        return pulumi.get(self, "file_types")

    @file_types.setter
    def file_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "file_types", value)

    @property
    @pulumi.getter(name="filesLimitPercent")
    def files_limit_percent(self) -> Optional[pulumi.Input[int]]:
        """
        Limits the number of files to scan to this percentage of the input FileSet. Number of files scanned is rounded down.
        Must be between 0 and 100, inclusively. Both 0 and 100 means no limit.
        """
        return pulumi.get(self, "files_limit_percent")

    @files_limit_percent.setter
    def files_limit_percent(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "files_limit_percent", value)

    @property
    @pulumi.getter(name="sampleMethod")
    def sample_method(self) -> Optional[pulumi.Input[str]]:
        """
        How to sample bytes if not all bytes are scanned. Meaningful only when used in conjunction with bytesLimitPerFile.
        If not specified, scanning would start from the top.
        Possible values are: `TOP`, `RANDOM_START`.
        """
        return pulumi.get(self, "sample_method")

    @sample_method.setter
    def sample_method(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "sample_method", value)


if not MYPY:
    class PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetArgsDict(TypedDict):
        regex_file_set: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetArgsDict']]
        """
        The regex-filtered set of files to scan.
        Structure is documented below.
        """
        url: NotRequired[pulumi.Input[str]]
        """
        The Cloud Storage url of the file(s) to scan, in the format `gs://<bucket>/<path>`. Trailing wildcard
        in the path is allowed.
        If the url ends in a trailing slash, the bucket or directory represented by the url will be scanned
        non-recursively (content in sub-directories will not be scanned). This means that `gs://mybucket/` is
        equivalent to `gs://mybucket/*`, and `gs://mybucket/directory/` is equivalent to `gs://mybucket/directory/*`.
        """
elif False:
    PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetArgs:
    def __init__(__self__, *,
                 regex_file_set: Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetArgs']] = None,
                 url: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetArgs'] regex_file_set: The regex-filtered set of files to scan.
               Structure is documented below.
        :param pulumi.Input[str] url: The Cloud Storage url of the file(s) to scan, in the format `gs://<bucket>/<path>`. Trailing wildcard
               in the path is allowed.
               If the url ends in a trailing slash, the bucket or directory represented by the url will be scanned
               non-recursively (content in sub-directories will not be scanned). This means that `gs://mybucket/` is
               equivalent to `gs://mybucket/*`, and `gs://mybucket/directory/` is equivalent to `gs://mybucket/directory/*`.
        """
        if regex_file_set is not None:
            pulumi.set(__self__, "regex_file_set", regex_file_set)
        if url is not None:
            pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter(name="regexFileSet")
    def regex_file_set(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetArgs']]:
        """
        The regex-filtered set of files to scan.
        Structure is documented below.
        """
        return pulumi.get(self, "regex_file_set")

    @regex_file_set.setter
    def regex_file_set(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetArgs']]):
        pulumi.set(self, "regex_file_set", value)

    @property
    @pulumi.getter
    def url(self) -> Optional[pulumi.Input[str]]:
        """
        The Cloud Storage url of the file(s) to scan, in the format `gs://<bucket>/<path>`. Trailing wildcard
        in the path is allowed.
        If the url ends in a trailing slash, the bucket or directory represented by the url will be scanned
        non-recursively (content in sub-directories will not be scanned). This means that `gs://mybucket/` is
        equivalent to `gs://mybucket/*`, and `gs://mybucket/directory/` is equivalent to `gs://mybucket/directory/*`.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "url", value)


if not MYPY:
    class PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetArgsDict(TypedDict):
        bucket_name: pulumi.Input[str]
        """
        The name of a Cloud Storage bucket.
        """
        exclude_regexes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of regular expressions matching file paths to exclude. All files in the bucket that match at
        least one of these regular expressions will be excluded from the scan.
        """
        include_regexes: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        A list of regular expressions matching file paths to include. All files in the bucket
        that match at least one of these regular expressions will be included in the set of files,
        except for those that also match an item in excludeRegex. Leaving this field empty will
        match all files by default (this is equivalent to including .* in the list)
        """
elif False:
    PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobStorageConfigCloudStorageOptionsFileSetRegexFileSetArgs:
    def __init__(__self__, *,
                 bucket_name: pulumi.Input[str],
                 exclude_regexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 include_regexes: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] bucket_name: The name of a Cloud Storage bucket.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] exclude_regexes: A list of regular expressions matching file paths to exclude. All files in the bucket that match at
               least one of these regular expressions will be excluded from the scan.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] include_regexes: A list of regular expressions matching file paths to include. All files in the bucket
               that match at least one of these regular expressions will be included in the set of files,
               except for those that also match an item in excludeRegex. Leaving this field empty will
               match all files by default (this is equivalent to including .* in the list)
        """
        pulumi.set(__self__, "bucket_name", bucket_name)
        if exclude_regexes is not None:
            pulumi.set(__self__, "exclude_regexes", exclude_regexes)
        if include_regexes is not None:
            pulumi.set(__self__, "include_regexes", include_regexes)

    @property
    @pulumi.getter(name="bucketName")
    def bucket_name(self) -> pulumi.Input[str]:
        """
        The name of a Cloud Storage bucket.
        """
        return pulumi.get(self, "bucket_name")

    @bucket_name.setter
    def bucket_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket_name", value)

    @property
    @pulumi.getter(name="excludeRegexes")
    def exclude_regexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expressions matching file paths to exclude. All files in the bucket that match at
        least one of these regular expressions will be excluded from the scan.
        """
        return pulumi.get(self, "exclude_regexes")

    @exclude_regexes.setter
    def exclude_regexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "exclude_regexes", value)

    @property
    @pulumi.getter(name="includeRegexes")
    def include_regexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        A list of regular expressions matching file paths to include. All files in the bucket
        that match at least one of these regular expressions will be included in the set of files,
        except for those that also match an item in excludeRegex. Leaving this field empty will
        match all files by default (this is equivalent to including .* in the list)
        """
        return pulumi.get(self, "include_regexes")

    @include_regexes.setter
    def include_regexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "include_regexes", value)


if not MYPY:
    class PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsArgsDict(TypedDict):
        kind: pulumi.Input['PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsKindArgsDict']
        """
        A representation of a Datastore kind.
        Structure is documented below.
        """
        partition_id: pulumi.Input['PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsPartitionIdArgsDict']
        """
        Datastore partition ID. A partition ID identifies a grouping of entities. The grouping
        is always by project and namespace, however the namespace ID may be empty.
        Structure is documented below.
        """
elif False:
    PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsArgs:
    def __init__(__self__, *,
                 kind: pulumi.Input['PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsKindArgs'],
                 partition_id: pulumi.Input['PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsPartitionIdArgs']):
        """
        :param pulumi.Input['PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsKindArgs'] kind: A representation of a Datastore kind.
               Structure is documented below.
        :param pulumi.Input['PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsPartitionIdArgs'] partition_id: Datastore partition ID. A partition ID identifies a grouping of entities. The grouping
               is always by project and namespace, however the namespace ID may be empty.
               Structure is documented below.
        """
        pulumi.set(__self__, "kind", kind)
        pulumi.set(__self__, "partition_id", partition_id)

    @property
    @pulumi.getter
    def kind(self) -> pulumi.Input['PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsKindArgs']:
        """
        A representation of a Datastore kind.
        Structure is documented below.
        """
        return pulumi.get(self, "kind")

    @kind.setter
    def kind(self, value: pulumi.Input['PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsKindArgs']):
        pulumi.set(self, "kind", value)

    @property
    @pulumi.getter(name="partitionId")
    def partition_id(self) -> pulumi.Input['PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsPartitionIdArgs']:
        """
        Datastore partition ID. A partition ID identifies a grouping of entities. The grouping
        is always by project and namespace, however the namespace ID may be empty.
        Structure is documented below.
        """
        return pulumi.get(self, "partition_id")

    @partition_id.setter
    def partition_id(self, value: pulumi.Input['PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsPartitionIdArgs']):
        pulumi.set(self, "partition_id", value)


if not MYPY:
    class PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsKindArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        The name of the Datastore kind.
        """
elif False:
    PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsKindArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsKindArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: The name of the Datastore kind.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        The name of the Datastore kind.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsPartitionIdArgsDict(TypedDict):
        project_id: pulumi.Input[str]
        """
        The ID of the project to which the entities belong.
        """
        namespace_id: NotRequired[pulumi.Input[str]]
        """
        If not empty, the ID of the namespace to which the entities belong.
        """
elif False:
    PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsPartitionIdArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobStorageConfigDatastoreOptionsPartitionIdArgs:
    def __init__(__self__, *,
                 project_id: pulumi.Input[str],
                 namespace_id: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] project_id: The ID of the project to which the entities belong.
        :param pulumi.Input[str] namespace_id: If not empty, the ID of the namespace to which the entities belong.
        """
        pulumi.set(__self__, "project_id", project_id)
        if namespace_id is not None:
            pulumi.set(__self__, "namespace_id", namespace_id)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The ID of the project to which the entities belong.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="namespaceId")
    def namespace_id(self) -> Optional[pulumi.Input[str]]:
        """
        If not empty, the ID of the namespace to which the entities belong.
        """
        return pulumi.get(self, "namespace_id")

    @namespace_id.setter
    def namespace_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "namespace_id", value)


if not MYPY:
    class PreventionJobTriggerInspectJobStorageConfigHybridOptionsArgsDict(TypedDict):
        description: NotRequired[pulumi.Input[str]]
        """
        A short description of where the data is coming from. Will be stored once in the job. 256 max length.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        To organize findings, these labels will be added to each finding.
        Label keys must be between 1 and 63 characters long and must conform to the following regular expression: `a-z?`.
        Label values must be between 0 and 63 characters long and must conform to the regular expression `(a-z?)?`.
        No more than 10 labels can be associated with a given finding.
        Examples:
        * `"environment" : "production"`
        * `"pipeline" : "etl"`
        """
        required_finding_label_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[str]]]]
        """
        These are labels that each inspection request must include within their 'finding_labels' map. Request
        may contain others, but any missing one of these will be rejected.
        Label keys must be between 1 and 63 characters long and must conform to the following regular expression: `a-z?`.
        No more than 10 keys can be required.
        """
        table_options: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsArgsDict']]
        """
        If the container is a table, additional information to make findings meaningful such as the columns that are primary keys.
        Structure is documented below.
        """
elif False:
    PreventionJobTriggerInspectJobStorageConfigHybridOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobStorageConfigHybridOptionsArgs:
    def __init__(__self__, *,
                 description: Optional[pulumi.Input[str]] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 required_finding_label_keys: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None,
                 table_options: Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsArgs']] = None):
        """
        :param pulumi.Input[str] description: A short description of where the data is coming from. Will be stored once in the job. 256 max length.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: To organize findings, these labels will be added to each finding.
               Label keys must be between 1 and 63 characters long and must conform to the following regular expression: `a-z?`.
               Label values must be between 0 and 63 characters long and must conform to the regular expression `(a-z?)?`.
               No more than 10 labels can be associated with a given finding.
               Examples:
               * `"environment" : "production"`
               * `"pipeline" : "etl"`
        :param pulumi.Input[Sequence[pulumi.Input[str]]] required_finding_label_keys: These are labels that each inspection request must include within their 'finding_labels' map. Request
               may contain others, but any missing one of these will be rejected.
               Label keys must be between 1 and 63 characters long and must conform to the following regular expression: `a-z?`.
               No more than 10 keys can be required.
        :param pulumi.Input['PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsArgs'] table_options: If the container is a table, additional information to make findings meaningful such as the columns that are primary keys.
               Structure is documented below.
        """
        if description is not None:
            pulumi.set(__self__, "description", description)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if required_finding_label_keys is not None:
            pulumi.set(__self__, "required_finding_label_keys", required_finding_label_keys)
        if table_options is not None:
            pulumi.set(__self__, "table_options", table_options)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[str]]:
        """
        A short description of where the data is coming from. Will be stored once in the job. 256 max length.
        """
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "description", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        To organize findings, these labels will be added to each finding.
        Label keys must be between 1 and 63 characters long and must conform to the following regular expression: `a-z?`.
        Label values must be between 0 and 63 characters long and must conform to the regular expression `(a-z?)?`.
        No more than 10 labels can be associated with a given finding.
        Examples:
        * `"environment" : "production"`
        * `"pipeline" : "etl"`
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter(name="requiredFindingLabelKeys")
    def required_finding_label_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        These are labels that each inspection request must include within their 'finding_labels' map. Request
        may contain others, but any missing one of these will be rejected.
        Label keys must be between 1 and 63 characters long and must conform to the following regular expression: `a-z?`.
        No more than 10 keys can be required.
        """
        return pulumi.get(self, "required_finding_label_keys")

    @required_finding_label_keys.setter
    def required_finding_label_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "required_finding_label_keys", value)

    @property
    @pulumi.getter(name="tableOptions")
    def table_options(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsArgs']]:
        """
        If the container is a table, additional information to make findings meaningful such as the columns that are primary keys.
        Structure is documented below.
        """
        return pulumi.get(self, "table_options")

    @table_options.setter
    def table_options(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsArgs']]):
        pulumi.set(self, "table_options", value)


if not MYPY:
    class PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsArgsDict(TypedDict):
        identifying_fields: NotRequired[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFieldArgsDict']]]]
        """
        The columns that are the primary keys for table objects included in ContentItem. A copy of this
        cell's value will stored alongside alongside each finding so that the finding can be traced to
        the specific row it came from. No more than 3 may be provided.
        Structure is documented below.
        """
elif False:
    PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsArgs:
    def __init__(__self__, *,
                 identifying_fields: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFieldArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFieldArgs']]] identifying_fields: The columns that are the primary keys for table objects included in ContentItem. A copy of this
               cell's value will stored alongside alongside each finding so that the finding can be traced to
               the specific row it came from. No more than 3 may be provided.
               Structure is documented below.
        """
        if identifying_fields is not None:
            pulumi.set(__self__, "identifying_fields", identifying_fields)

    @property
    @pulumi.getter(name="identifyingFields")
    def identifying_fields(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFieldArgs']]]]:
        """
        The columns that are the primary keys for table objects included in ContentItem. A copy of this
        cell's value will stored alongside alongside each finding so that the finding can be traced to
        the specific row it came from. No more than 3 may be provided.
        Structure is documented below.
        """
        return pulumi.get(self, "identifying_fields")

    @identifying_fields.setter
    def identifying_fields(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFieldArgs']]]]):
        pulumi.set(self, "identifying_fields", value)


if not MYPY:
    class PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFieldArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name describing the field.
        """
elif False:
    PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobStorageConfigHybridOptionsTableOptionsIdentifyingFieldArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name describing the field.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name describing the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionJobTriggerInspectJobStorageConfigTimespanConfigArgsDict(TypedDict):
        enable_auto_population_of_timespan_config: NotRequired[pulumi.Input[bool]]
        """
        When the job is started by a JobTrigger we will automatically figure out a valid startTime to avoid
        scanning files that have not been modified since the last time the JobTrigger executed. This will
        be based on the time of the execution of the last run of the JobTrigger or the timespan endTime
        used in the last run of the JobTrigger.
        """
        end_time: NotRequired[pulumi.Input[str]]
        """
        Exclude files, tables, or rows newer than this value. If not set, no upper time limit is applied.
        """
        start_time: NotRequired[pulumi.Input[str]]
        """
        Exclude files, tables, or rows older than this value. If not set, no lower time limit is applied.
        """
        timestamp_field: NotRequired[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigTimespanConfigTimestampFieldArgsDict']]
        """
        Specification of the field containing the timestamp of scanned items.
        Structure is documented below.
        """
elif False:
    PreventionJobTriggerInspectJobStorageConfigTimespanConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobStorageConfigTimespanConfigArgs:
    def __init__(__self__, *,
                 enable_auto_population_of_timespan_config: Optional[pulumi.Input[bool]] = None,
                 end_time: Optional[pulumi.Input[str]] = None,
                 start_time: Optional[pulumi.Input[str]] = None,
                 timestamp_field: Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigTimespanConfigTimestampFieldArgs']] = None):
        """
        :param pulumi.Input[bool] enable_auto_population_of_timespan_config: When the job is started by a JobTrigger we will automatically figure out a valid startTime to avoid
               scanning files that have not been modified since the last time the JobTrigger executed. This will
               be based on the time of the execution of the last run of the JobTrigger or the timespan endTime
               used in the last run of the JobTrigger.
        :param pulumi.Input[str] end_time: Exclude files, tables, or rows newer than this value. If not set, no upper time limit is applied.
        :param pulumi.Input[str] start_time: Exclude files, tables, or rows older than this value. If not set, no lower time limit is applied.
        :param pulumi.Input['PreventionJobTriggerInspectJobStorageConfigTimespanConfigTimestampFieldArgs'] timestamp_field: Specification of the field containing the timestamp of scanned items.
               Structure is documented below.
        """
        if enable_auto_population_of_timespan_config is not None:
            pulumi.set(__self__, "enable_auto_population_of_timespan_config", enable_auto_population_of_timespan_config)
        if end_time is not None:
            pulumi.set(__self__, "end_time", end_time)
        if start_time is not None:
            pulumi.set(__self__, "start_time", start_time)
        if timestamp_field is not None:
            pulumi.set(__self__, "timestamp_field", timestamp_field)

    @property
    @pulumi.getter(name="enableAutoPopulationOfTimespanConfig")
    def enable_auto_population_of_timespan_config(self) -> Optional[pulumi.Input[bool]]:
        """
        When the job is started by a JobTrigger we will automatically figure out a valid startTime to avoid
        scanning files that have not been modified since the last time the JobTrigger executed. This will
        be based on the time of the execution of the last run of the JobTrigger or the timespan endTime
        used in the last run of the JobTrigger.
        """
        return pulumi.get(self, "enable_auto_population_of_timespan_config")

    @enable_auto_population_of_timespan_config.setter
    def enable_auto_population_of_timespan_config(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enable_auto_population_of_timespan_config", value)

    @property
    @pulumi.getter(name="endTime")
    def end_time(self) -> Optional[pulumi.Input[str]]:
        """
        Exclude files, tables, or rows newer than this value. If not set, no upper time limit is applied.
        """
        return pulumi.get(self, "end_time")

    @end_time.setter
    def end_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "end_time", value)

    @property
    @pulumi.getter(name="startTime")
    def start_time(self) -> Optional[pulumi.Input[str]]:
        """
        Exclude files, tables, or rows older than this value. If not set, no lower time limit is applied.
        """
        return pulumi.get(self, "start_time")

    @start_time.setter
    def start_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "start_time", value)

    @property
    @pulumi.getter(name="timestampField")
    def timestamp_field(self) -> Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigTimespanConfigTimestampFieldArgs']]:
        """
        Specification of the field containing the timestamp of scanned items.
        Structure is documented below.
        """
        return pulumi.get(self, "timestamp_field")

    @timestamp_field.setter
    def timestamp_field(self, value: Optional[pulumi.Input['PreventionJobTriggerInspectJobStorageConfigTimespanConfigTimestampFieldArgs']]):
        pulumi.set(self, "timestamp_field", value)


if not MYPY:
    class PreventionJobTriggerInspectJobStorageConfigTimespanConfigTimestampFieldArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
        For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
        modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
        field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
        For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
        timestamp property does not exist or its value is empty or invalid.
        """
elif False:
    PreventionJobTriggerInspectJobStorageConfigTimespanConfigTimestampFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerInspectJobStorageConfigTimespanConfigTimestampFieldArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
               For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
               modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
               field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
               For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
               timestamp property does not exist or its value is empty or invalid.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Specification of the field containing the timestamp of scanned items. Used for data sources like Datastore and BigQuery.
        For BigQuery: Required to filter out rows based on the given start and end times. If not specified and the table was
        modified between the given start and end times, the entire table will be scanned. The valid data types of the timestamp
        field are: INTEGER, DATE, TIMESTAMP, or DATETIME BigQuery column.
        For Datastore. Valid data types of the timestamp field are: TIMESTAMP. Datastore entity will be scanned if the
        timestamp property does not exist or its value is empty or invalid.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionJobTriggerTriggerArgsDict(TypedDict):
        manual: NotRequired[pulumi.Input['PreventionJobTriggerTriggerManualArgsDict']]
        """
        For use with hybrid jobs. Jobs must be manually created and finished.
        """
        schedule: NotRequired[pulumi.Input['PreventionJobTriggerTriggerScheduleArgsDict']]
        """
        Schedule for triggered jobs
        Structure is documented below.
        """
elif False:
    PreventionJobTriggerTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerTriggerArgs:
    def __init__(__self__, *,
                 manual: Optional[pulumi.Input['PreventionJobTriggerTriggerManualArgs']] = None,
                 schedule: Optional[pulumi.Input['PreventionJobTriggerTriggerScheduleArgs']] = None):
        """
        :param pulumi.Input['PreventionJobTriggerTriggerManualArgs'] manual: For use with hybrid jobs. Jobs must be manually created and finished.
        :param pulumi.Input['PreventionJobTriggerTriggerScheduleArgs'] schedule: Schedule for triggered jobs
               Structure is documented below.
        """
        if manual is not None:
            pulumi.set(__self__, "manual", manual)
        if schedule is not None:
            pulumi.set(__self__, "schedule", schedule)

    @property
    @pulumi.getter
    def manual(self) -> Optional[pulumi.Input['PreventionJobTriggerTriggerManualArgs']]:
        """
        For use with hybrid jobs. Jobs must be manually created and finished.
        """
        return pulumi.get(self, "manual")

    @manual.setter
    def manual(self, value: Optional[pulumi.Input['PreventionJobTriggerTriggerManualArgs']]):
        pulumi.set(self, "manual", value)

    @property
    @pulumi.getter
    def schedule(self) -> Optional[pulumi.Input['PreventionJobTriggerTriggerScheduleArgs']]:
        """
        Schedule for triggered jobs
        Structure is documented below.
        """
        return pulumi.get(self, "schedule")

    @schedule.setter
    def schedule(self, value: Optional[pulumi.Input['PreventionJobTriggerTriggerScheduleArgs']]):
        pulumi.set(self, "schedule", value)


if not MYPY:
    class PreventionJobTriggerTriggerManualArgsDict(TypedDict):
        pass
elif False:
    PreventionJobTriggerTriggerManualArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerTriggerManualArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class PreventionJobTriggerTriggerScheduleArgsDict(TypedDict):
        recurrence_period_duration: NotRequired[pulumi.Input[str]]
        """
        With this option a job is started a regular periodic basis. For example: every day (86400 seconds).
        A scheduled start time will be skipped if the previous execution has not ended when its scheduled time occurs.
        This value must be set to a time duration greater than or equal to 1 day and can be no longer than 60 days.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".

        - - -
        """
elif False:
    PreventionJobTriggerTriggerScheduleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionJobTriggerTriggerScheduleArgs:
    def __init__(__self__, *,
                 recurrence_period_duration: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] recurrence_period_duration: With this option a job is started a regular periodic basis. For example: every day (86400 seconds).
               A scheduled start time will be skipped if the previous execution has not ended when its scheduled time occurs.
               This value must be set to a time duration greater than or equal to 1 day and can be no longer than 60 days.
               A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
               
               - - -
        """
        if recurrence_period_duration is not None:
            pulumi.set(__self__, "recurrence_period_duration", recurrence_period_duration)

    @property
    @pulumi.getter(name="recurrencePeriodDuration")
    def recurrence_period_duration(self) -> Optional[pulumi.Input[str]]:
        """
        With this option a job is started a regular periodic basis. For example: every day (86400 seconds).
        A scheduled start time will be skipped if the previous execution has not ended when its scheduled time occurs.
        This value must be set to a time duration greater than or equal to 1 day and can be no longer than 60 days.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".

        - - -
        """
        return pulumi.get(self, "recurrence_period_duration")

    @recurrence_period_duration.setter
    def recurrence_period_duration(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "recurrence_period_duration", value)


if not MYPY:
    class PreventionStoredInfoTypeDictionaryArgsDict(TypedDict):
        cloud_storage_path: NotRequired[pulumi.Input['PreventionStoredInfoTypeDictionaryCloudStoragePathArgsDict']]
        """
        Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
        Structure is documented below.
        """
        word_list: NotRequired[pulumi.Input['PreventionStoredInfoTypeDictionaryWordListArgsDict']]
        """
        List of words or phrases to search for.
        Structure is documented below.
        """
elif False:
    PreventionStoredInfoTypeDictionaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionStoredInfoTypeDictionaryArgs:
    def __init__(__self__, *,
                 cloud_storage_path: Optional[pulumi.Input['PreventionStoredInfoTypeDictionaryCloudStoragePathArgs']] = None,
                 word_list: Optional[pulumi.Input['PreventionStoredInfoTypeDictionaryWordListArgs']] = None):
        """
        :param pulumi.Input['PreventionStoredInfoTypeDictionaryCloudStoragePathArgs'] cloud_storage_path: Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
               Structure is documented below.
        :param pulumi.Input['PreventionStoredInfoTypeDictionaryWordListArgs'] word_list: List of words or phrases to search for.
               Structure is documented below.
        """
        if cloud_storage_path is not None:
            pulumi.set(__self__, "cloud_storage_path", cloud_storage_path)
        if word_list is not None:
            pulumi.set(__self__, "word_list", word_list)

    @property
    @pulumi.getter(name="cloudStoragePath")
    def cloud_storage_path(self) -> Optional[pulumi.Input['PreventionStoredInfoTypeDictionaryCloudStoragePathArgs']]:
        """
        Newline-delimited file of words in Cloud Storage. Only a single file is accepted.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_storage_path")

    @cloud_storage_path.setter
    def cloud_storage_path(self, value: Optional[pulumi.Input['PreventionStoredInfoTypeDictionaryCloudStoragePathArgs']]):
        pulumi.set(self, "cloud_storage_path", value)

    @property
    @pulumi.getter(name="wordList")
    def word_list(self) -> Optional[pulumi.Input['PreventionStoredInfoTypeDictionaryWordListArgs']]:
        """
        List of words or phrases to search for.
        Structure is documented below.
        """
        return pulumi.get(self, "word_list")

    @word_list.setter
    def word_list(self, value: Optional[pulumi.Input['PreventionStoredInfoTypeDictionaryWordListArgs']]):
        pulumi.set(self, "word_list", value)


if not MYPY:
    class PreventionStoredInfoTypeDictionaryCloudStoragePathArgsDict(TypedDict):
        path: pulumi.Input[str]
        """
        A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
        """
elif False:
    PreventionStoredInfoTypeDictionaryCloudStoragePathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionStoredInfoTypeDictionaryCloudStoragePathArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str]):
        """
        :param pulumi.Input[str] path: A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
        """
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)


if not MYPY:
    class PreventionStoredInfoTypeDictionaryWordListArgsDict(TypedDict):
        words: pulumi.Input[Sequence[pulumi.Input[str]]]
        """
        Words or phrases defining the dictionary. The dictionary must contain at least one
        phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
elif False:
    PreventionStoredInfoTypeDictionaryWordListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionStoredInfoTypeDictionaryWordListArgs:
    def __init__(__self__, *,
                 words: pulumi.Input[Sequence[pulumi.Input[str]]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input[str]]] words: Words or phrases defining the dictionary. The dictionary must contain at least one
               phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
        pulumi.set(__self__, "words", words)

    @property
    @pulumi.getter
    def words(self) -> pulumi.Input[Sequence[pulumi.Input[str]]]:
        """
        Words or phrases defining the dictionary. The dictionary must contain at least one
        phrase and every phrase must contain at least 2 characters that are letters or digits.
        """
        return pulumi.get(self, "words")

    @words.setter
    def words(self, value: pulumi.Input[Sequence[pulumi.Input[str]]]):
        pulumi.set(self, "words", value)


if not MYPY:
    class PreventionStoredInfoTypeLargeCustomDictionaryArgsDict(TypedDict):
        output_path: pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryOutputPathArgsDict']
        """
        Location to store dictionary artifacts in Google Cloud Storage. These files will only be accessible by project owners and the DLP API.
        If any of these artifacts are modified, the dictionary is considered invalid and can no longer be used.
        Structure is documented below.
        """
        big_query_field: NotRequired[pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldArgsDict']]
        """
        Field in a BigQuery table where each cell represents a dictionary phrase.
        Structure is documented below.
        """
        cloud_storage_file_set: NotRequired[pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryCloudStorageFileSetArgsDict']]
        """
        Set of files containing newline-delimited lists of dictionary phrases.
        Structure is documented below.
        """
elif False:
    PreventionStoredInfoTypeLargeCustomDictionaryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionStoredInfoTypeLargeCustomDictionaryArgs:
    def __init__(__self__, *,
                 output_path: pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryOutputPathArgs'],
                 big_query_field: Optional[pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldArgs']] = None,
                 cloud_storage_file_set: Optional[pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryCloudStorageFileSetArgs']] = None):
        """
        :param pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryOutputPathArgs'] output_path: Location to store dictionary artifacts in Google Cloud Storage. These files will only be accessible by project owners and the DLP API.
               If any of these artifacts are modified, the dictionary is considered invalid and can no longer be used.
               Structure is documented below.
        :param pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldArgs'] big_query_field: Field in a BigQuery table where each cell represents a dictionary phrase.
               Structure is documented below.
        :param pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryCloudStorageFileSetArgs'] cloud_storage_file_set: Set of files containing newline-delimited lists of dictionary phrases.
               Structure is documented below.
        """
        pulumi.set(__self__, "output_path", output_path)
        if big_query_field is not None:
            pulumi.set(__self__, "big_query_field", big_query_field)
        if cloud_storage_file_set is not None:
            pulumi.set(__self__, "cloud_storage_file_set", cloud_storage_file_set)

    @property
    @pulumi.getter(name="outputPath")
    def output_path(self) -> pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryOutputPathArgs']:
        """
        Location to store dictionary artifacts in Google Cloud Storage. These files will only be accessible by project owners and the DLP API.
        If any of these artifacts are modified, the dictionary is considered invalid and can no longer be used.
        Structure is documented below.
        """
        return pulumi.get(self, "output_path")

    @output_path.setter
    def output_path(self, value: pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryOutputPathArgs']):
        pulumi.set(self, "output_path", value)

    @property
    @pulumi.getter(name="bigQueryField")
    def big_query_field(self) -> Optional[pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldArgs']]:
        """
        Field in a BigQuery table where each cell represents a dictionary phrase.
        Structure is documented below.
        """
        return pulumi.get(self, "big_query_field")

    @big_query_field.setter
    def big_query_field(self, value: Optional[pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldArgs']]):
        pulumi.set(self, "big_query_field", value)

    @property
    @pulumi.getter(name="cloudStorageFileSet")
    def cloud_storage_file_set(self) -> Optional[pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryCloudStorageFileSetArgs']]:
        """
        Set of files containing newline-delimited lists of dictionary phrases.
        Structure is documented below.
        """
        return pulumi.get(self, "cloud_storage_file_set")

    @cloud_storage_file_set.setter
    def cloud_storage_file_set(self, value: Optional[pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryCloudStorageFileSetArgs']]):
        pulumi.set(self, "cloud_storage_file_set", value)


if not MYPY:
    class PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldArgsDict(TypedDict):
        field: pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldFieldArgsDict']
        """
        Designated field in the BigQuery table.
        Structure is documented below.
        """
        table: pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldTableArgsDict']
        """
        Field in a BigQuery table where each cell represents a dictionary phrase.
        Structure is documented below.
        """
elif False:
    PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldArgs:
    def __init__(__self__, *,
                 field: pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldFieldArgs'],
                 table: pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldTableArgs']):
        """
        :param pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldFieldArgs'] field: Designated field in the BigQuery table.
               Structure is documented below.
        :param pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldTableArgs'] table: Field in a BigQuery table where each cell represents a dictionary phrase.
               Structure is documented below.
        """
        pulumi.set(__self__, "field", field)
        pulumi.set(__self__, "table", table)

    @property
    @pulumi.getter
    def field(self) -> pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldFieldArgs']:
        """
        Designated field in the BigQuery table.
        Structure is documented below.
        """
        return pulumi.get(self, "field")

    @field.setter
    def field(self, value: pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldFieldArgs']):
        pulumi.set(self, "field", value)

    @property
    @pulumi.getter
    def table(self) -> pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldTableArgs']:
        """
        Field in a BigQuery table where each cell represents a dictionary phrase.
        Structure is documented below.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: pulumi.Input['PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldTableArgs']):
        pulumi.set(self, "table", value)


if not MYPY:
    class PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldFieldArgsDict(TypedDict):
        name: pulumi.Input[str]
        """
        Name describing the field.
        """
elif False:
    PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldFieldArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldFieldArgs:
    def __init__(__self__, *,
                 name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] name: Name describing the field.
        """
        pulumi.set(__self__, "name", name)

    @property
    @pulumi.getter
    def name(self) -> pulumi.Input[str]:
        """
        Name describing the field.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: pulumi.Input[str]):
        pulumi.set(self, "name", value)


if not MYPY:
    class PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldTableArgsDict(TypedDict):
        dataset_id: pulumi.Input[str]
        """
        The dataset ID of the table.
        """
        project_id: pulumi.Input[str]
        """
        The Google Cloud Platform project ID of the project containing the table.
        """
        table_id: pulumi.Input[str]
        """
        The name of the table.
        """
elif False:
    PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionStoredInfoTypeLargeCustomDictionaryBigQueryFieldTableArgs:
    def __init__(__self__, *,
                 dataset_id: pulumi.Input[str],
                 project_id: pulumi.Input[str],
                 table_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] dataset_id: The dataset ID of the table.
        :param pulumi.Input[str] project_id: The Google Cloud Platform project ID of the project containing the table.
        :param pulumi.Input[str] table_id: The name of the table.
        """
        pulumi.set(__self__, "dataset_id", dataset_id)
        pulumi.set(__self__, "project_id", project_id)
        pulumi.set(__self__, "table_id", table_id)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> pulumi.Input[str]:
        """
        The dataset ID of the table.
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset_id", value)

    @property
    @pulumi.getter(name="projectId")
    def project_id(self) -> pulumi.Input[str]:
        """
        The Google Cloud Platform project ID of the project containing the table.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "project_id", value)

    @property
    @pulumi.getter(name="tableId")
    def table_id(self) -> pulumi.Input[str]:
        """
        The name of the table.
        """
        return pulumi.get(self, "table_id")

    @table_id.setter
    def table_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "table_id", value)


if not MYPY:
    class PreventionStoredInfoTypeLargeCustomDictionaryCloudStorageFileSetArgsDict(TypedDict):
        url: pulumi.Input[str]
        """
        The url, in the format `gs://<bucket>/<path>`. Trailing wildcard in the path is allowed.
        """
elif False:
    PreventionStoredInfoTypeLargeCustomDictionaryCloudStorageFileSetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionStoredInfoTypeLargeCustomDictionaryCloudStorageFileSetArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[str]):
        """
        :param pulumi.Input[str] url: The url, in the format `gs://<bucket>/<path>`. Trailing wildcard in the path is allowed.
        """
        pulumi.set(__self__, "url", url)

    @property
    @pulumi.getter
    def url(self) -> pulumi.Input[str]:
        """
        The url, in the format `gs://<bucket>/<path>`. Trailing wildcard in the path is allowed.
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[str]):
        pulumi.set(self, "url", value)


if not MYPY:
    class PreventionStoredInfoTypeLargeCustomDictionaryOutputPathArgsDict(TypedDict):
        path: pulumi.Input[str]
        """
        A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
        """
elif False:
    PreventionStoredInfoTypeLargeCustomDictionaryOutputPathArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionStoredInfoTypeLargeCustomDictionaryOutputPathArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[str]):
        """
        :param pulumi.Input[str] path: A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
        """
        pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter
    def path(self) -> pulumi.Input[str]:
        """
        A url representing a file or path (no wildcards) in Cloud Storage. Example: `gs://[BUCKET_NAME]/dictionary.txt`
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[str]):
        pulumi.set(self, "path", value)


if not MYPY:
    class PreventionStoredInfoTypeRegexArgsDict(TypedDict):
        pattern: pulumi.Input[str]
        """
        Pattern defining the regular expression.
        Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
        group_indexes: NotRequired[pulumi.Input[Sequence[pulumi.Input[int]]]]
        """
        The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
        """
elif False:
    PreventionStoredInfoTypeRegexArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PreventionStoredInfoTypeRegexArgs:
    def __init__(__self__, *,
                 pattern: pulumi.Input[str],
                 group_indexes: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]] = None):
        """
        :param pulumi.Input[str] pattern: Pattern defining the regular expression.
               Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        :param pulumi.Input[Sequence[pulumi.Input[int]]] group_indexes: The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
        """
        pulumi.set(__self__, "pattern", pattern)
        if group_indexes is not None:
            pulumi.set(__self__, "group_indexes", group_indexes)

    @property
    @pulumi.getter
    def pattern(self) -> pulumi.Input[str]:
        """
        Pattern defining the regular expression.
        Its syntax (https://github.com/google/re2/wiki/Syntax) can be found under the google/re2 repository on GitHub.
        """
        return pulumi.get(self, "pattern")

    @pattern.setter
    def pattern(self, value: pulumi.Input[str]):
        pulumi.set(self, "pattern", value)

    @property
    @pulumi.getter(name="groupIndexes")
    def group_indexes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]:
        """
        The index of the submatch to extract as findings. When not specified, the entire match is returned. No more than 3 may be included.
        """
        return pulumi.get(self, "group_indexes")

    @group_indexes.setter
    def group_indexes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[int]]]]):
        pulumi.set(self, "group_indexes", value)


