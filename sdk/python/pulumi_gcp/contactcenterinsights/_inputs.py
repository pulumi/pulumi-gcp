# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AnalysisRuleAnnotatorSelectorArgs',
    'AnalysisRuleAnnotatorSelectorArgsDict',
    'AnalysisRuleAnnotatorSelectorQaConfigArgs',
    'AnalysisRuleAnnotatorSelectorQaConfigArgsDict',
    'AnalysisRuleAnnotatorSelectorQaConfigScorecardListArgs',
    'AnalysisRuleAnnotatorSelectorQaConfigScorecardListArgsDict',
    'AnalysisRuleAnnotatorSelectorSummarizationConfigArgs',
    'AnalysisRuleAnnotatorSelectorSummarizationConfigArgsDict',
]

MYPY = False

if not MYPY:
    class AnalysisRuleAnnotatorSelectorArgsDict(TypedDict):
        issue_models: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The issue model to run. If not provided, the most recently deployed topic
        model will be used. The provided issue model will only be used for
        inference if the issue model is deployed and if run_issue_model_annotator
        is set to true. If more than one issue model is provided, only the first
        provided issue model will be used for inference.
        """
        phrase_matchers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The list of phrase matchers to run. If not provided, all active phrase
        matchers will be used. If inactive phrase matchers are provided, they will
        not be used. Phrase matchers will be run only if
        run_phrase_matcher_annotator is set to true. Format:
        projects/{project}/locations/{location}/phraseMatchers/{phrase_matcher}
        """
        qa_config: NotRequired[pulumi.Input['AnalysisRuleAnnotatorSelectorQaConfigArgsDict']]
        """
        Configuration for the QA feature.
        Structure is documented below.
        """
        run_entity_annotator: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to run the entity annotator.
        """
        run_intent_annotator: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to run the intent annotator.
        """
        run_interruption_annotator: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to run the interruption annotator.
        """
        run_issue_model_annotator: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to run the issue model annotator. A model should have already been
        deployed for this to take effect.
        """
        run_phrase_matcher_annotator: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to run the active phrase matcher annotator(s).
        """
        run_qa_annotator: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to run the QA annotator.
        """
        run_sentiment_annotator: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to run the sentiment annotator.
        """
        run_silence_annotator: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to run the silence annotator.
        """
        run_summarization_annotator: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Whether to run the summarization annotator.
        """
        summarization_config: NotRequired[pulumi.Input['AnalysisRuleAnnotatorSelectorSummarizationConfigArgsDict']]
        """
        Configuration for summarization.
        Structure is documented below.
        """
elif False:
    AnalysisRuleAnnotatorSelectorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisRuleAnnotatorSelectorArgs:
    def __init__(__self__, *,
                 issue_models: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 phrase_matchers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 qa_config: Optional[pulumi.Input['AnalysisRuleAnnotatorSelectorQaConfigArgs']] = None,
                 run_entity_annotator: Optional[pulumi.Input[_builtins.bool]] = None,
                 run_intent_annotator: Optional[pulumi.Input[_builtins.bool]] = None,
                 run_interruption_annotator: Optional[pulumi.Input[_builtins.bool]] = None,
                 run_issue_model_annotator: Optional[pulumi.Input[_builtins.bool]] = None,
                 run_phrase_matcher_annotator: Optional[pulumi.Input[_builtins.bool]] = None,
                 run_qa_annotator: Optional[pulumi.Input[_builtins.bool]] = None,
                 run_sentiment_annotator: Optional[pulumi.Input[_builtins.bool]] = None,
                 run_silence_annotator: Optional[pulumi.Input[_builtins.bool]] = None,
                 run_summarization_annotator: Optional[pulumi.Input[_builtins.bool]] = None,
                 summarization_config: Optional[pulumi.Input['AnalysisRuleAnnotatorSelectorSummarizationConfigArgs']] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] issue_models: The issue model to run. If not provided, the most recently deployed topic
               model will be used. The provided issue model will only be used for
               inference if the issue model is deployed and if run_issue_model_annotator
               is set to true. If more than one issue model is provided, only the first
               provided issue model will be used for inference.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] phrase_matchers: The list of phrase matchers to run. If not provided, all active phrase
               matchers will be used. If inactive phrase matchers are provided, they will
               not be used. Phrase matchers will be run only if
               run_phrase_matcher_annotator is set to true. Format:
               projects/{project}/locations/{location}/phraseMatchers/{phrase_matcher}
        :param pulumi.Input['AnalysisRuleAnnotatorSelectorQaConfigArgs'] qa_config: Configuration for the QA feature.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] run_entity_annotator: Whether to run the entity annotator.
        :param pulumi.Input[_builtins.bool] run_intent_annotator: Whether to run the intent annotator.
        :param pulumi.Input[_builtins.bool] run_interruption_annotator: Whether to run the interruption annotator.
        :param pulumi.Input[_builtins.bool] run_issue_model_annotator: Whether to run the issue model annotator. A model should have already been
               deployed for this to take effect.
        :param pulumi.Input[_builtins.bool] run_phrase_matcher_annotator: Whether to run the active phrase matcher annotator(s).
        :param pulumi.Input[_builtins.bool] run_qa_annotator: Whether to run the QA annotator.
        :param pulumi.Input[_builtins.bool] run_sentiment_annotator: Whether to run the sentiment annotator.
        :param pulumi.Input[_builtins.bool] run_silence_annotator: Whether to run the silence annotator.
        :param pulumi.Input[_builtins.bool] run_summarization_annotator: Whether to run the summarization annotator.
        :param pulumi.Input['AnalysisRuleAnnotatorSelectorSummarizationConfigArgs'] summarization_config: Configuration for summarization.
               Structure is documented below.
        """
        if issue_models is not None:
            pulumi.set(__self__, "issue_models", issue_models)
        if phrase_matchers is not None:
            pulumi.set(__self__, "phrase_matchers", phrase_matchers)
        if qa_config is not None:
            pulumi.set(__self__, "qa_config", qa_config)
        if run_entity_annotator is not None:
            pulumi.set(__self__, "run_entity_annotator", run_entity_annotator)
        if run_intent_annotator is not None:
            pulumi.set(__self__, "run_intent_annotator", run_intent_annotator)
        if run_interruption_annotator is not None:
            pulumi.set(__self__, "run_interruption_annotator", run_interruption_annotator)
        if run_issue_model_annotator is not None:
            pulumi.set(__self__, "run_issue_model_annotator", run_issue_model_annotator)
        if run_phrase_matcher_annotator is not None:
            pulumi.set(__self__, "run_phrase_matcher_annotator", run_phrase_matcher_annotator)
        if run_qa_annotator is not None:
            pulumi.set(__self__, "run_qa_annotator", run_qa_annotator)
        if run_sentiment_annotator is not None:
            pulumi.set(__self__, "run_sentiment_annotator", run_sentiment_annotator)
        if run_silence_annotator is not None:
            pulumi.set(__self__, "run_silence_annotator", run_silence_annotator)
        if run_summarization_annotator is not None:
            pulumi.set(__self__, "run_summarization_annotator", run_summarization_annotator)
        if summarization_config is not None:
            pulumi.set(__self__, "summarization_config", summarization_config)

    @_builtins.property
    @pulumi.getter(name="issueModels")
    def issue_models(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The issue model to run. If not provided, the most recently deployed topic
        model will be used. The provided issue model will only be used for
        inference if the issue model is deployed and if run_issue_model_annotator
        is set to true. If more than one issue model is provided, only the first
        provided issue model will be used for inference.
        """
        return pulumi.get(self, "issue_models")

    @issue_models.setter
    def issue_models(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "issue_models", value)

    @_builtins.property
    @pulumi.getter(name="phraseMatchers")
    def phrase_matchers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The list of phrase matchers to run. If not provided, all active phrase
        matchers will be used. If inactive phrase matchers are provided, they will
        not be used. Phrase matchers will be run only if
        run_phrase_matcher_annotator is set to true. Format:
        projects/{project}/locations/{location}/phraseMatchers/{phrase_matcher}
        """
        return pulumi.get(self, "phrase_matchers")

    @phrase_matchers.setter
    def phrase_matchers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "phrase_matchers", value)

    @_builtins.property
    @pulumi.getter(name="qaConfig")
    def qa_config(self) -> Optional[pulumi.Input['AnalysisRuleAnnotatorSelectorQaConfigArgs']]:
        """
        Configuration for the QA feature.
        Structure is documented below.
        """
        return pulumi.get(self, "qa_config")

    @qa_config.setter
    def qa_config(self, value: Optional[pulumi.Input['AnalysisRuleAnnotatorSelectorQaConfigArgs']]):
        pulumi.set(self, "qa_config", value)

    @_builtins.property
    @pulumi.getter(name="runEntityAnnotator")
    def run_entity_annotator(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to run the entity annotator.
        """
        return pulumi.get(self, "run_entity_annotator")

    @run_entity_annotator.setter
    def run_entity_annotator(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "run_entity_annotator", value)

    @_builtins.property
    @pulumi.getter(name="runIntentAnnotator")
    def run_intent_annotator(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to run the intent annotator.
        """
        return pulumi.get(self, "run_intent_annotator")

    @run_intent_annotator.setter
    def run_intent_annotator(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "run_intent_annotator", value)

    @_builtins.property
    @pulumi.getter(name="runInterruptionAnnotator")
    def run_interruption_annotator(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to run the interruption annotator.
        """
        return pulumi.get(self, "run_interruption_annotator")

    @run_interruption_annotator.setter
    def run_interruption_annotator(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "run_interruption_annotator", value)

    @_builtins.property
    @pulumi.getter(name="runIssueModelAnnotator")
    def run_issue_model_annotator(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to run the issue model annotator. A model should have already been
        deployed for this to take effect.
        """
        return pulumi.get(self, "run_issue_model_annotator")

    @run_issue_model_annotator.setter
    def run_issue_model_annotator(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "run_issue_model_annotator", value)

    @_builtins.property
    @pulumi.getter(name="runPhraseMatcherAnnotator")
    def run_phrase_matcher_annotator(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to run the active phrase matcher annotator(s).
        """
        return pulumi.get(self, "run_phrase_matcher_annotator")

    @run_phrase_matcher_annotator.setter
    def run_phrase_matcher_annotator(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "run_phrase_matcher_annotator", value)

    @_builtins.property
    @pulumi.getter(name="runQaAnnotator")
    def run_qa_annotator(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to run the QA annotator.
        """
        return pulumi.get(self, "run_qa_annotator")

    @run_qa_annotator.setter
    def run_qa_annotator(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "run_qa_annotator", value)

    @_builtins.property
    @pulumi.getter(name="runSentimentAnnotator")
    def run_sentiment_annotator(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to run the sentiment annotator.
        """
        return pulumi.get(self, "run_sentiment_annotator")

    @run_sentiment_annotator.setter
    def run_sentiment_annotator(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "run_sentiment_annotator", value)

    @_builtins.property
    @pulumi.getter(name="runSilenceAnnotator")
    def run_silence_annotator(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to run the silence annotator.
        """
        return pulumi.get(self, "run_silence_annotator")

    @run_silence_annotator.setter
    def run_silence_annotator(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "run_silence_annotator", value)

    @_builtins.property
    @pulumi.getter(name="runSummarizationAnnotator")
    def run_summarization_annotator(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Whether to run the summarization annotator.
        """
        return pulumi.get(self, "run_summarization_annotator")

    @run_summarization_annotator.setter
    def run_summarization_annotator(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "run_summarization_annotator", value)

    @_builtins.property
    @pulumi.getter(name="summarizationConfig")
    def summarization_config(self) -> Optional[pulumi.Input['AnalysisRuleAnnotatorSelectorSummarizationConfigArgs']]:
        """
        Configuration for summarization.
        Structure is documented below.
        """
        return pulumi.get(self, "summarization_config")

    @summarization_config.setter
    def summarization_config(self, value: Optional[pulumi.Input['AnalysisRuleAnnotatorSelectorSummarizationConfigArgs']]):
        pulumi.set(self, "summarization_config", value)


if not MYPY:
    class AnalysisRuleAnnotatorSelectorQaConfigArgsDict(TypedDict):
        scorecard_list: NotRequired[pulumi.Input['AnalysisRuleAnnotatorSelectorQaConfigScorecardListArgsDict']]
        """
        Container for a list of scorecards.
        Structure is documented below.
        """
elif False:
    AnalysisRuleAnnotatorSelectorQaConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisRuleAnnotatorSelectorQaConfigArgs:
    def __init__(__self__, *,
                 scorecard_list: Optional[pulumi.Input['AnalysisRuleAnnotatorSelectorQaConfigScorecardListArgs']] = None):
        """
        :param pulumi.Input['AnalysisRuleAnnotatorSelectorQaConfigScorecardListArgs'] scorecard_list: Container for a list of scorecards.
               Structure is documented below.
        """
        if scorecard_list is not None:
            pulumi.set(__self__, "scorecard_list", scorecard_list)

    @_builtins.property
    @pulumi.getter(name="scorecardList")
    def scorecard_list(self) -> Optional[pulumi.Input['AnalysisRuleAnnotatorSelectorQaConfigScorecardListArgs']]:
        """
        Container for a list of scorecards.
        Structure is documented below.
        """
        return pulumi.get(self, "scorecard_list")

    @scorecard_list.setter
    def scorecard_list(self, value: Optional[pulumi.Input['AnalysisRuleAnnotatorSelectorQaConfigScorecardListArgs']]):
        pulumi.set(self, "scorecard_list", value)


if not MYPY:
    class AnalysisRuleAnnotatorSelectorQaConfigScorecardListArgsDict(TypedDict):
        qa_scorecard_revisions: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of QaScorecardRevisions.
        """
elif False:
    AnalysisRuleAnnotatorSelectorQaConfigScorecardListArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisRuleAnnotatorSelectorQaConfigScorecardListArgs:
    def __init__(__self__, *,
                 qa_scorecard_revisions: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] qa_scorecard_revisions: List of QaScorecardRevisions.
        """
        if qa_scorecard_revisions is not None:
            pulumi.set(__self__, "qa_scorecard_revisions", qa_scorecard_revisions)

    @_builtins.property
    @pulumi.getter(name="qaScorecardRevisions")
    def qa_scorecard_revisions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of QaScorecardRevisions.
        """
        return pulumi.get(self, "qa_scorecard_revisions")

    @qa_scorecard_revisions.setter
    def qa_scorecard_revisions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "qa_scorecard_revisions", value)


if not MYPY:
    class AnalysisRuleAnnotatorSelectorSummarizationConfigArgsDict(TypedDict):
        conversation_profile: NotRequired[pulumi.Input[_builtins.str]]
        """
        Resource name of the Dialogflow conversation profile.
        Format:
        projects/{project}/locations/{location}/conversationProfiles/{conversation_profile}
        """
        summarization_model: NotRequired[pulumi.Input[_builtins.str]]
        """
        Default summarization model to be used.
        Possible values:
        SUMMARIZATION_MODEL_UNSPECIFIED
        BASELINE_MODEL
        BASELINE_MODEL_V2_0
        Possible values are: `BASELINE_MODEL`, `BASELINE_MODEL_V2_0`.
        """
elif False:
    AnalysisRuleAnnotatorSelectorSummarizationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AnalysisRuleAnnotatorSelectorSummarizationConfigArgs:
    def __init__(__self__, *,
                 conversation_profile: Optional[pulumi.Input[_builtins.str]] = None,
                 summarization_model: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] conversation_profile: Resource name of the Dialogflow conversation profile.
               Format:
               projects/{project}/locations/{location}/conversationProfiles/{conversation_profile}
        :param pulumi.Input[_builtins.str] summarization_model: Default summarization model to be used.
               Possible values:
               SUMMARIZATION_MODEL_UNSPECIFIED
               BASELINE_MODEL
               BASELINE_MODEL_V2_0
               Possible values are: `BASELINE_MODEL`, `BASELINE_MODEL_V2_0`.
        """
        if conversation_profile is not None:
            pulumi.set(__self__, "conversation_profile", conversation_profile)
        if summarization_model is not None:
            pulumi.set(__self__, "summarization_model", summarization_model)

    @_builtins.property
    @pulumi.getter(name="conversationProfile")
    def conversation_profile(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Resource name of the Dialogflow conversation profile.
        Format:
        projects/{project}/locations/{location}/conversationProfiles/{conversation_profile}
        """
        return pulumi.get(self, "conversation_profile")

    @conversation_profile.setter
    def conversation_profile(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "conversation_profile", value)

    @_builtins.property
    @pulumi.getter(name="summarizationModel")
    def summarization_model(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Default summarization model to be used.
        Possible values:
        SUMMARIZATION_MODEL_UNSPECIFIED
        BASELINE_MODEL
        BASELINE_MODEL_V2_0
        Possible values are: `BASELINE_MODEL`, `BASELINE_MODEL_V2_0`.
        """
        return pulumi.get(self, "summarization_model")

    @summarization_model.setter
    def summarization_model(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "summarization_model", value)


