# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
from .. import _utilities

__all__ = [
    'BackupEncryptionConfigArgs',
    'BackupEncryptionInfoArgs',
    'ClusterAutomatedBackupPolicyArgs',
    'ClusterAutomatedBackupPolicyEncryptionConfigArgs',
    'ClusterAutomatedBackupPolicyQuantityBasedRetentionArgs',
    'ClusterAutomatedBackupPolicyTimeBasedRetentionArgs',
    'ClusterAutomatedBackupPolicyWeeklyScheduleArgs',
    'ClusterAutomatedBackupPolicyWeeklyScheduleStartTimeArgs',
    'ClusterBackupSourceArgs',
    'ClusterContinuousBackupConfigArgs',
    'ClusterContinuousBackupConfigEncryptionConfigArgs',
    'ClusterContinuousBackupInfoArgs',
    'ClusterContinuousBackupInfoEncryptionInfoArgs',
    'ClusterEncryptionConfigArgs',
    'ClusterEncryptionInfoArgs',
    'ClusterInitialUserArgs',
    'ClusterMigrationSourceArgs',
    'ClusterNetworkConfigArgs',
    'ClusterRestoreBackupSourceArgs',
    'ClusterRestoreContinuousBackupSourceArgs',
    'InstanceMachineConfigArgs',
    'InstanceReadPoolConfigArgs',
]

@pulumi.input_type
class BackupEncryptionConfigArgs:
    def __init__(__self__, *,
                 kms_key_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kms_key_name: The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
        """
        if kms_key_name is not None:
            pulumi.set(__self__, "kms_key_name", kms_key_name)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[pulumi.Input[str]]:
        """
        The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
        """
        return pulumi.get(self, "kms_key_name")

    @kms_key_name.setter
    def kms_key_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_name", value)


@pulumi.input_type
class BackupEncryptionInfoArgs:
    def __init__(__self__, *,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 kms_key_versions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] encryption_type: (Output)
               Output only. Type of encryption.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] kms_key_versions: (Output)
               Output only. Cloud KMS key versions that are being used to protect the database or the backup.
        """
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if kms_key_versions is not None:
            pulumi.set(__self__, "kms_key_versions", kms_key_versions)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Output only. Type of encryption.
        """
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter(name="kmsKeyVersions")
    def kms_key_versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Output)
        Output only. Cloud KMS key versions that are being used to protect the database or the backup.
        """
        return pulumi.get(self, "kms_key_versions")

    @kms_key_versions.setter
    def kms_key_versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "kms_key_versions", value)


@pulumi.input_type
class ClusterAutomatedBackupPolicyArgs:
    def __init__(__self__, *,
                 backup_window: Optional[pulumi.Input[str]] = None,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 encryption_config: Optional[pulumi.Input['ClusterAutomatedBackupPolicyEncryptionConfigArgs']] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 location: Optional[pulumi.Input[str]] = None,
                 quantity_based_retention: Optional[pulumi.Input['ClusterAutomatedBackupPolicyQuantityBasedRetentionArgs']] = None,
                 time_based_retention: Optional[pulumi.Input['ClusterAutomatedBackupPolicyTimeBasedRetentionArgs']] = None,
                 weekly_schedule: Optional[pulumi.Input['ClusterAutomatedBackupPolicyWeeklyScheduleArgs']] = None):
        """
        :param pulumi.Input[str] backup_window: The length of the time window during which a backup can be taken. If a backup does not succeed within this time window, it will be canceled and considered failed.
               The backup window must be at least 5 minutes long. There is no upper bound on the window. If not set, it will default to 1 hour.
               A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        :param pulumi.Input[bool] enabled: Whether automated backups are enabled.
        :param pulumi.Input['ClusterAutomatedBackupPolicyEncryptionConfigArgs'] encryption_config: EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
               Structure is documented below.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] labels: Labels to apply to backups created using this configuration.
        :param pulumi.Input[str] location: The location where the backup will be stored. Currently, the only supported option is to store the backup in the same region as the cluster.
        :param pulumi.Input['ClusterAutomatedBackupPolicyQuantityBasedRetentionArgs'] quantity_based_retention: Quantity-based Backup retention policy to retain recent backups. Conflicts with 'time_based_retention', both can't be set together.
               Structure is documented below.
        :param pulumi.Input['ClusterAutomatedBackupPolicyTimeBasedRetentionArgs'] time_based_retention: Time-based Backup retention policy. Conflicts with 'quantity_based_retention', both can't be set together.
               Structure is documented below.
        :param pulumi.Input['ClusterAutomatedBackupPolicyWeeklyScheduleArgs'] weekly_schedule: Weekly schedule for the Backup.
               Structure is documented below.
        """
        if backup_window is not None:
            pulumi.set(__self__, "backup_window", backup_window)
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if encryption_config is not None:
            pulumi.set(__self__, "encryption_config", encryption_config)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if location is not None:
            pulumi.set(__self__, "location", location)
        if quantity_based_retention is not None:
            pulumi.set(__self__, "quantity_based_retention", quantity_based_retention)
        if time_based_retention is not None:
            pulumi.set(__self__, "time_based_retention", time_based_retention)
        if weekly_schedule is not None:
            pulumi.set(__self__, "weekly_schedule", weekly_schedule)

    @property
    @pulumi.getter(name="backupWindow")
    def backup_window(self) -> Optional[pulumi.Input[str]]:
        """
        The length of the time window during which a backup can be taken. If a backup does not succeed within this time window, it will be canceled and considered failed.
        The backup window must be at least 5 minutes long. There is no upper bound on the window. If not set, it will default to 1 hour.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        return pulumi.get(self, "backup_window")

    @backup_window.setter
    def backup_window(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_window", value)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether automated backups are enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="encryptionConfig")
    def encryption_config(self) -> Optional[pulumi.Input['ClusterAutomatedBackupPolicyEncryptionConfigArgs']]:
        """
        EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
        Structure is documented below.
        """
        return pulumi.get(self, "encryption_config")

    @encryption_config.setter
    def encryption_config(self, value: Optional[pulumi.Input['ClusterAutomatedBackupPolicyEncryptionConfigArgs']]):
        pulumi.set(self, "encryption_config", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Labels to apply to backups created using this configuration.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def location(self) -> Optional[pulumi.Input[str]]:
        """
        The location where the backup will be stored. Currently, the only supported option is to store the backup in the same region as the cluster.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="quantityBasedRetention")
    def quantity_based_retention(self) -> Optional[pulumi.Input['ClusterAutomatedBackupPolicyQuantityBasedRetentionArgs']]:
        """
        Quantity-based Backup retention policy to retain recent backups. Conflicts with 'time_based_retention', both can't be set together.
        Structure is documented below.
        """
        return pulumi.get(self, "quantity_based_retention")

    @quantity_based_retention.setter
    def quantity_based_retention(self, value: Optional[pulumi.Input['ClusterAutomatedBackupPolicyQuantityBasedRetentionArgs']]):
        pulumi.set(self, "quantity_based_retention", value)

    @property
    @pulumi.getter(name="timeBasedRetention")
    def time_based_retention(self) -> Optional[pulumi.Input['ClusterAutomatedBackupPolicyTimeBasedRetentionArgs']]:
        """
        Time-based Backup retention policy. Conflicts with 'quantity_based_retention', both can't be set together.
        Structure is documented below.
        """
        return pulumi.get(self, "time_based_retention")

    @time_based_retention.setter
    def time_based_retention(self, value: Optional[pulumi.Input['ClusterAutomatedBackupPolicyTimeBasedRetentionArgs']]):
        pulumi.set(self, "time_based_retention", value)

    @property
    @pulumi.getter(name="weeklySchedule")
    def weekly_schedule(self) -> Optional[pulumi.Input['ClusterAutomatedBackupPolicyWeeklyScheduleArgs']]:
        """
        Weekly schedule for the Backup.
        Structure is documented below.
        """
        return pulumi.get(self, "weekly_schedule")

    @weekly_schedule.setter
    def weekly_schedule(self, value: Optional[pulumi.Input['ClusterAutomatedBackupPolicyWeeklyScheduleArgs']]):
        pulumi.set(self, "weekly_schedule", value)


@pulumi.input_type
class ClusterAutomatedBackupPolicyEncryptionConfigArgs:
    def __init__(__self__, *,
                 kms_key_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kms_key_name: The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
        """
        if kms_key_name is not None:
            pulumi.set(__self__, "kms_key_name", kms_key_name)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[pulumi.Input[str]]:
        """
        The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
        """
        return pulumi.get(self, "kms_key_name")

    @kms_key_name.setter
    def kms_key_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_name", value)


@pulumi.input_type
class ClusterAutomatedBackupPolicyQuantityBasedRetentionArgs:
    def __init__(__self__, *,
                 count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] count: The number of backups to retain.
        """
        if count is not None:
            pulumi.set(__self__, "count", count)

    @property
    @pulumi.getter
    def count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of backups to retain.
        """
        return pulumi.get(self, "count")

    @count.setter
    def count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "count", value)


@pulumi.input_type
class ClusterAutomatedBackupPolicyTimeBasedRetentionArgs:
    def __init__(__self__, *,
                 retention_period: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] retention_period: The retention period.
               A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        if retention_period is not None:
            pulumi.set(__self__, "retention_period", retention_period)

    @property
    @pulumi.getter(name="retentionPeriod")
    def retention_period(self) -> Optional[pulumi.Input[str]]:
        """
        The retention period.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s".
        """
        return pulumi.get(self, "retention_period")

    @retention_period.setter
    def retention_period(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "retention_period", value)


@pulumi.input_type
class ClusterAutomatedBackupPolicyWeeklyScheduleArgs:
    def __init__(__self__, *,
                 start_times: pulumi.Input[Sequence[pulumi.Input['ClusterAutomatedBackupPolicyWeeklyScheduleStartTimeArgs']]],
                 days_of_weeks: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAutomatedBackupPolicyWeeklyScheduleStartTimeArgs']]] start_times: The times during the day to start a backup. At least one start time must be provided. The start times are assumed to be in UTC and to be an exact hour (e.g., 04:00:00).
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] days_of_weeks: The days of the week to perform a backup. At least one day of the week must be provided.
               Each value may be one of: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        pulumi.set(__self__, "start_times", start_times)
        if days_of_weeks is not None:
            pulumi.set(__self__, "days_of_weeks", days_of_weeks)

    @property
    @pulumi.getter(name="startTimes")
    def start_times(self) -> pulumi.Input[Sequence[pulumi.Input['ClusterAutomatedBackupPolicyWeeklyScheduleStartTimeArgs']]]:
        """
        The times during the day to start a backup. At least one start time must be provided. The start times are assumed to be in UTC and to be an exact hour (e.g., 04:00:00).
        Structure is documented below.
        """
        return pulumi.get(self, "start_times")

    @start_times.setter
    def start_times(self, value: pulumi.Input[Sequence[pulumi.Input['ClusterAutomatedBackupPolicyWeeklyScheduleStartTimeArgs']]]):
        pulumi.set(self, "start_times", value)

    @property
    @pulumi.getter(name="daysOfWeeks")
    def days_of_weeks(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        The days of the week to perform a backup. At least one day of the week must be provided.
        Each value may be one of: `MONDAY`, `TUESDAY`, `WEDNESDAY`, `THURSDAY`, `FRIDAY`, `SATURDAY`, `SUNDAY`.
        """
        return pulumi.get(self, "days_of_weeks")

    @days_of_weeks.setter
    def days_of_weeks(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "days_of_weeks", value)


@pulumi.input_type
class ClusterAutomatedBackupPolicyWeeklyScheduleStartTimeArgs:
    def __init__(__self__, *,
                 hours: Optional[pulumi.Input[int]] = None,
                 minutes: Optional[pulumi.Input[int]] = None,
                 nanos: Optional[pulumi.Input[int]] = None,
                 seconds: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] hours: Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        :param pulumi.Input[int] minutes: Minutes of hour of day. Currently, only the value 0 is supported.
        :param pulumi.Input[int] nanos: Fractions of seconds in nanoseconds. Currently, only the value 0 is supported.
        :param pulumi.Input[int] seconds: Seconds of minutes of the time. Currently, only the value 0 is supported.
        """
        if hours is not None:
            pulumi.set(__self__, "hours", hours)
        if minutes is not None:
            pulumi.set(__self__, "minutes", minutes)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if seconds is not None:
            pulumi.set(__self__, "seconds", seconds)

    @property
    @pulumi.getter
    def hours(self) -> Optional[pulumi.Input[int]]:
        """
        Hours of day in 24 hour format. Should be from 0 to 23. An API may choose to allow the value "24:00:00" for scenarios like business closing time.
        """
        return pulumi.get(self, "hours")

    @hours.setter
    def hours(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "hours", value)

    @property
    @pulumi.getter
    def minutes(self) -> Optional[pulumi.Input[int]]:
        """
        Minutes of hour of day. Currently, only the value 0 is supported.
        """
        return pulumi.get(self, "minutes")

    @minutes.setter
    def minutes(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "minutes", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[int]]:
        """
        Fractions of seconds in nanoseconds. Currently, only the value 0 is supported.
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def seconds(self) -> Optional[pulumi.Input[int]]:
        """
        Seconds of minutes of the time. Currently, only the value 0 is supported.
        """
        return pulumi.get(self, "seconds")

    @seconds.setter
    def seconds(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "seconds", value)


@pulumi.input_type
class ClusterBackupSourceArgs:
    def __init__(__self__, *,
                 backup_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] backup_name: The name of the backup that this cluster is restored from.
        """
        if backup_name is not None:
            pulumi.set(__self__, "backup_name", backup_name)

    @property
    @pulumi.getter(name="backupName")
    def backup_name(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the backup that this cluster is restored from.
        """
        return pulumi.get(self, "backup_name")

    @backup_name.setter
    def backup_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "backup_name", value)


@pulumi.input_type
class ClusterContinuousBackupConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[bool]] = None,
                 encryption_config: Optional[pulumi.Input['ClusterContinuousBackupConfigEncryptionConfigArgs']] = None,
                 recovery_window_days: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[bool] enabled: Whether continuous backup recovery is enabled. If not set, defaults to true.
        :param pulumi.Input['ClusterContinuousBackupConfigEncryptionConfigArgs'] encryption_config: EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
               Structure is documented below.
        :param pulumi.Input[int] recovery_window_days: The numbers of days that are eligible to restore from using PITR. To support the entire recovery window, backups and logs are retained for one day more than the recovery window.
               If not set, defaults to 14 days.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if encryption_config is not None:
            pulumi.set(__self__, "encryption_config", encryption_config)
        if recovery_window_days is not None:
            pulumi.set(__self__, "recovery_window_days", recovery_window_days)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether continuous backup recovery is enabled. If not set, defaults to true.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter(name="encryptionConfig")
    def encryption_config(self) -> Optional[pulumi.Input['ClusterContinuousBackupConfigEncryptionConfigArgs']]:
        """
        EncryptionConfig describes the encryption config of a cluster or a backup that is encrypted with a CMEK (customer-managed encryption key).
        Structure is documented below.
        """
        return pulumi.get(self, "encryption_config")

    @encryption_config.setter
    def encryption_config(self, value: Optional[pulumi.Input['ClusterContinuousBackupConfigEncryptionConfigArgs']]):
        pulumi.set(self, "encryption_config", value)

    @property
    @pulumi.getter(name="recoveryWindowDays")
    def recovery_window_days(self) -> Optional[pulumi.Input[int]]:
        """
        The numbers of days that are eligible to restore from using PITR. To support the entire recovery window, backups and logs are retained for one day more than the recovery window.
        If not set, defaults to 14 days.
        """
        return pulumi.get(self, "recovery_window_days")

    @recovery_window_days.setter
    def recovery_window_days(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "recovery_window_days", value)


@pulumi.input_type
class ClusterContinuousBackupConfigEncryptionConfigArgs:
    def __init__(__self__, *,
                 kms_key_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kms_key_name: The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
        """
        if kms_key_name is not None:
            pulumi.set(__self__, "kms_key_name", kms_key_name)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[pulumi.Input[str]]:
        """
        The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
        """
        return pulumi.get(self, "kms_key_name")

    @kms_key_name.setter
    def kms_key_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_name", value)


@pulumi.input_type
class ClusterContinuousBackupInfoArgs:
    def __init__(__self__, *,
                 earliest_restorable_time: Optional[pulumi.Input[str]] = None,
                 enabled_time: Optional[pulumi.Input[str]] = None,
                 encryption_infos: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterContinuousBackupInfoEncryptionInfoArgs']]]] = None,
                 schedules: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] earliest_restorable_time: (Output)
               The earliest restorable time that can be restored to. Output only field.
        :param pulumi.Input[str] enabled_time: (Output)
               When ContinuousBackup was most recently enabled. Set to null if ContinuousBackup is not enabled.
        :param pulumi.Input[Sequence[pulumi.Input['ClusterContinuousBackupInfoEncryptionInfoArgs']]] encryption_infos: (Output)
               Output only. The encryption information for the WALs and backups required for ContinuousBackup.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] schedules: (Output)
               Days of the week on which a continuous backup is taken. Output only field. Ignored if passed into the request.
        """
        if earliest_restorable_time is not None:
            pulumi.set(__self__, "earliest_restorable_time", earliest_restorable_time)
        if enabled_time is not None:
            pulumi.set(__self__, "enabled_time", enabled_time)
        if encryption_infos is not None:
            pulumi.set(__self__, "encryption_infos", encryption_infos)
        if schedules is not None:
            pulumi.set(__self__, "schedules", schedules)

    @property
    @pulumi.getter(name="earliestRestorableTime")
    def earliest_restorable_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        The earliest restorable time that can be restored to. Output only field.
        """
        return pulumi.get(self, "earliest_restorable_time")

    @earliest_restorable_time.setter
    def earliest_restorable_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "earliest_restorable_time", value)

    @property
    @pulumi.getter(name="enabledTime")
    def enabled_time(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        When ContinuousBackup was most recently enabled. Set to null if ContinuousBackup is not enabled.
        """
        return pulumi.get(self, "enabled_time")

    @enabled_time.setter
    def enabled_time(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "enabled_time", value)

    @property
    @pulumi.getter(name="encryptionInfos")
    def encryption_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ClusterContinuousBackupInfoEncryptionInfoArgs']]]]:
        """
        (Output)
        Output only. The encryption information for the WALs and backups required for ContinuousBackup.
        Structure is documented below.
        """
        return pulumi.get(self, "encryption_infos")

    @encryption_infos.setter
    def encryption_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ClusterContinuousBackupInfoEncryptionInfoArgs']]]]):
        pulumi.set(self, "encryption_infos", value)

    @property
    @pulumi.getter
    def schedules(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Output)
        Days of the week on which a continuous backup is taken. Output only field. Ignored if passed into the request.
        """
        return pulumi.get(self, "schedules")

    @schedules.setter
    def schedules(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "schedules", value)


@pulumi.input_type
class ClusterContinuousBackupInfoEncryptionInfoArgs:
    def __init__(__self__, *,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 kms_key_versions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] encryption_type: (Output)
               Output only. Type of encryption.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] kms_key_versions: (Output)
               Output only. Cloud KMS key versions that are being used to protect the database or the backup.
        """
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if kms_key_versions is not None:
            pulumi.set(__self__, "kms_key_versions", kms_key_versions)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Output only. Type of encryption.
        """
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter(name="kmsKeyVersions")
    def kms_key_versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Output)
        Output only. Cloud KMS key versions that are being used to protect the database or the backup.
        """
        return pulumi.get(self, "kms_key_versions")

    @kms_key_versions.setter
    def kms_key_versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "kms_key_versions", value)


@pulumi.input_type
class ClusterEncryptionConfigArgs:
    def __init__(__self__, *,
                 kms_key_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] kms_key_name: The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
        """
        if kms_key_name is not None:
            pulumi.set(__self__, "kms_key_name", kms_key_name)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[pulumi.Input[str]]:
        """
        The fully-qualified resource name of the KMS key. Each Cloud KMS key is regionalized and has the following format: projects/[PROJECT]/locations/[REGION]/keyRings/[RING]/cryptoKeys/[KEY_NAME].
        """
        return pulumi.get(self, "kms_key_name")

    @kms_key_name.setter
    def kms_key_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_name", value)


@pulumi.input_type
class ClusterEncryptionInfoArgs:
    def __init__(__self__, *,
                 encryption_type: Optional[pulumi.Input[str]] = None,
                 kms_key_versions: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]] = None):
        """
        :param pulumi.Input[str] encryption_type: (Output)
               Output only. Type of encryption.
        :param pulumi.Input[Sequence[pulumi.Input[str]]] kms_key_versions: (Output)
               Output only. Cloud KMS key versions that are being used to protect the database or the backup.
        """
        if encryption_type is not None:
            pulumi.set(__self__, "encryption_type", encryption_type)
        if kms_key_versions is not None:
            pulumi.set(__self__, "kms_key_versions", kms_key_versions)

    @property
    @pulumi.getter(name="encryptionType")
    def encryption_type(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Output only. Type of encryption.
        """
        return pulumi.get(self, "encryption_type")

    @encryption_type.setter
    def encryption_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encryption_type", value)

    @property
    @pulumi.getter(name="kmsKeyVersions")
    def kms_key_versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]:
        """
        (Output)
        Output only. Cloud KMS key versions that are being used to protect the database or the backup.
        """
        return pulumi.get(self, "kms_key_versions")

    @kms_key_versions.setter
    def kms_key_versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[str]]]]):
        pulumi.set(self, "kms_key_versions", value)


@pulumi.input_type
class ClusterInitialUserArgs:
    def __init__(__self__, *,
                 password: pulumi.Input[str],
                 user: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] password: The initial password for the user.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[str] user: The database username.
        """
        pulumi.set(__self__, "password", password)
        if user is not None:
            pulumi.set(__self__, "user", user)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        The initial password for the user.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def user(self) -> Optional[pulumi.Input[str]]:
        """
        The database username.
        """
        return pulumi.get(self, "user")

    @user.setter
    def user(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "user", value)


@pulumi.input_type
class ClusterMigrationSourceArgs:
    def __init__(__self__, *,
                 host_port: Optional[pulumi.Input[str]] = None,
                 reference_id: Optional[pulumi.Input[str]] = None,
                 source_type: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] host_port: The host and port of the on-premises instance in host:port format
        :param pulumi.Input[str] reference_id: Place holder for the external source identifier(e.g DMS job name) that created the cluster.
        :param pulumi.Input[str] source_type: Type of migration source.
        """
        if host_port is not None:
            pulumi.set(__self__, "host_port", host_port)
        if reference_id is not None:
            pulumi.set(__self__, "reference_id", reference_id)
        if source_type is not None:
            pulumi.set(__self__, "source_type", source_type)

    @property
    @pulumi.getter(name="hostPort")
    def host_port(self) -> Optional[pulumi.Input[str]]:
        """
        The host and port of the on-premises instance in host:port format
        """
        return pulumi.get(self, "host_port")

    @host_port.setter
    def host_port(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "host_port", value)

    @property
    @pulumi.getter(name="referenceId")
    def reference_id(self) -> Optional[pulumi.Input[str]]:
        """
        Place holder for the external source identifier(e.g DMS job name) that created the cluster.
        """
        return pulumi.get(self, "reference_id")

    @reference_id.setter
    def reference_id(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "reference_id", value)

    @property
    @pulumi.getter(name="sourceType")
    def source_type(self) -> Optional[pulumi.Input[str]]:
        """
        Type of migration source.
        """
        return pulumi.get(self, "source_type")

    @source_type.setter
    def source_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "source_type", value)


@pulumi.input_type
class ClusterNetworkConfigArgs:
    def __init__(__self__, *,
                 allocated_ip_range: Optional[pulumi.Input[str]] = None,
                 network: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] allocated_ip_range: The name of the allocated IP range for the private IP AlloyDB cluster. For example: "google-managed-services-default".
               If set, the instance IPs for this cluster will be created in the allocated range.
        :param pulumi.Input[str] network: The resource link for the VPC network in which cluster resources are created and from which they are accessible via Private IP. The network must belong to the same project as the cluster.
               It is specified in the form: "projects/{projectNumber}/global/networks/{network_id}".
        """
        if allocated_ip_range is not None:
            pulumi.set(__self__, "allocated_ip_range", allocated_ip_range)
        if network is not None:
            pulumi.set(__self__, "network", network)

    @property
    @pulumi.getter(name="allocatedIpRange")
    def allocated_ip_range(self) -> Optional[pulumi.Input[str]]:
        """
        The name of the allocated IP range for the private IP AlloyDB cluster. For example: "google-managed-services-default".
        If set, the instance IPs for this cluster will be created in the allocated range.
        """
        return pulumi.get(self, "allocated_ip_range")

    @allocated_ip_range.setter
    def allocated_ip_range(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "allocated_ip_range", value)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[str]]:
        """
        The resource link for the VPC network in which cluster resources are created and from which they are accessible via Private IP. The network must belong to the same project as the cluster.
        It is specified in the form: "projects/{projectNumber}/global/networks/{network_id}".
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "network", value)


@pulumi.input_type
class ClusterRestoreBackupSourceArgs:
    def __init__(__self__, *,
                 backup_name: pulumi.Input[str]):
        """
        :param pulumi.Input[str] backup_name: The name of the backup that this cluster is restored from.
        """
        pulumi.set(__self__, "backup_name", backup_name)

    @property
    @pulumi.getter(name="backupName")
    def backup_name(self) -> pulumi.Input[str]:
        """
        The name of the backup that this cluster is restored from.
        """
        return pulumi.get(self, "backup_name")

    @backup_name.setter
    def backup_name(self, value: pulumi.Input[str]):
        pulumi.set(self, "backup_name", value)


@pulumi.input_type
class ClusterRestoreContinuousBackupSourceArgs:
    def __init__(__self__, *,
                 cluster: pulumi.Input[str],
                 point_in_time: pulumi.Input[str]):
        """
        :param pulumi.Input[str] cluster: The name of the source cluster that this cluster is restored from.
        :param pulumi.Input[str] point_in_time: The point in time that this cluster is restored to, in RFC 3339 format.
        """
        pulumi.set(__self__, "cluster", cluster)
        pulumi.set(__self__, "point_in_time", point_in_time)

    @property
    @pulumi.getter
    def cluster(self) -> pulumi.Input[str]:
        """
        The name of the source cluster that this cluster is restored from.
        """
        return pulumi.get(self, "cluster")

    @cluster.setter
    def cluster(self, value: pulumi.Input[str]):
        pulumi.set(self, "cluster", value)

    @property
    @pulumi.getter(name="pointInTime")
    def point_in_time(self) -> pulumi.Input[str]:
        """
        The point in time that this cluster is restored to, in RFC 3339 format.
        """
        return pulumi.get(self, "point_in_time")

    @point_in_time.setter
    def point_in_time(self, value: pulumi.Input[str]):
        pulumi.set(self, "point_in_time", value)


@pulumi.input_type
class InstanceMachineConfigArgs:
    def __init__(__self__, *,
                 cpu_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] cpu_count: The number of CPU's in the VM instance.
        """
        if cpu_count is not None:
            pulumi.set(__self__, "cpu_count", cpu_count)

    @property
    @pulumi.getter(name="cpuCount")
    def cpu_count(self) -> Optional[pulumi.Input[int]]:
        """
        The number of CPU's in the VM instance.
        """
        return pulumi.get(self, "cpu_count")

    @cpu_count.setter
    def cpu_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "cpu_count", value)


@pulumi.input_type
class InstanceReadPoolConfigArgs:
    def __init__(__self__, *,
                 node_count: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[int] node_count: Read capacity, i.e. number of nodes in a read pool instance.
        """
        if node_count is not None:
            pulumi.set(__self__, "node_count", node_count)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> Optional[pulumi.Input[int]]:
        """
        Read capacity, i.e. number of nodes in a read pool instance.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "node_count", value)


