# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'ClusterAutoscalingSettings',
    'ClusterAutoscalingSettingsAutoscalingPolicy',
    'ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholds',
    'ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholds',
    'ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholds',
    'ClusterDatastoreMountConfig',
    'ClusterDatastoreMountConfigDatastoreNetwork',
    'ClusterNodeTypeConfig',
    'DatastoreNfsDatastore',
    'DatastoreNfsDatastoreGoogleFileService',
    'DatastoreNfsDatastoreThirdPartyFileService',
    'ExternalAccessRuleDestinationIpRange',
    'ExternalAccessRuleSourceIpRange',
    'NetworkPolicyExternalIp',
    'NetworkPolicyInternetAccess',
    'NetworkVpcNetwork',
    'PrivateCloudHcx',
    'PrivateCloudManagementCluster',
    'PrivateCloudManagementClusterAutoscalingSettings',
    'PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicy',
    'PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholds',
    'PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholds',
    'PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholds',
    'PrivateCloudManagementClusterNodeTypeConfig',
    'PrivateCloudManagementClusterStretchedClusterConfig',
    'PrivateCloudNetworkConfig',
    'PrivateCloudNsx',
    'PrivateCloudVcenter',
    'SubnetDhcpAddressRange',
    'GetAnnouncementsAnnouncementResult',
    'GetClusterAutoscalingSettingResult',
    'GetClusterAutoscalingSettingAutoscalingPolicyResult',
    'GetClusterAutoscalingSettingAutoscalingPolicyConsumedMemoryThresholdResult',
    'GetClusterAutoscalingSettingAutoscalingPolicyCpuThresholdResult',
    'GetClusterAutoscalingSettingAutoscalingPolicyStorageThresholdResult',
    'GetClusterDatastoreMountConfigResult',
    'GetClusterDatastoreMountConfigDatastoreNetworkResult',
    'GetClusterNodeTypeConfigResult',
    'GetDatastoreNfsDatastoreResult',
    'GetDatastoreNfsDatastoreGoogleFileServiceResult',
    'GetDatastoreNfsDatastoreThirdPartyFileServiceResult',
    'GetExternalAccessRuleDestinationIpRangeResult',
    'GetExternalAccessRuleSourceIpRangeResult',
    'GetNetworkPolicyExternalIpResult',
    'GetNetworkPolicyInternetAccessResult',
    'GetNetworkVpcNetworkResult',
    'GetPrivateCloudHcxResult',
    'GetPrivateCloudManagementClusterResult',
    'GetPrivateCloudManagementClusterAutoscalingSettingResult',
    'GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyResult',
    'GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyConsumedMemoryThresholdResult',
    'GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyCpuThresholdResult',
    'GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyStorageThresholdResult',
    'GetPrivateCloudManagementClusterNodeTypeConfigResult',
    'GetPrivateCloudManagementClusterStretchedClusterConfigResult',
    'GetPrivateCloudNetworkConfigResult',
    'GetPrivateCloudNsxResult',
    'GetPrivateCloudVcenterResult',
    'GetSubnetDhcpAddressRangeResult',
    'GetUpgradesUpgradeResult',
    'GetUpgradesUpgradeComponentUpgradeResult',
    'GetUpgradesUpgradeScheduleResult',
    'GetUpgradesUpgradeScheduleConstraintsResult',
    'GetUpgradesUpgradeScheduleConstraintsDisallowedIntervalsResult',
    'GetUpgradesUpgradeScheduleConstraintsDisallowedIntervalsEndTimeResult',
    'GetUpgradesUpgradeScheduleConstraintsDisallowedIntervalsStartTimeResult',
    'GetUpgradesUpgradeScheduleConstraintsRescheduleDateRangeResult',
    'GetUpgradesUpgradeScheduleEditWindowResult',
    'GetUpgradesUpgradeScheduleWeeklyWindowResult',
    'GetUpgradesUpgradeScheduleWeeklyWindowStartTimeResult',
]

@pulumi.output_type
class ClusterAutoscalingSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoscalingPolicies":
            suggest = "autoscaling_policies"
        elif key == "coolDownPeriod":
            suggest = "cool_down_period"
        elif key == "maxClusterNodeCount":
            suggest = "max_cluster_node_count"
        elif key == "minClusterNodeCount":
            suggest = "min_cluster_node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAutoscalingSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAutoscalingSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAutoscalingSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscaling_policies: Sequence['outputs.ClusterAutoscalingSettingsAutoscalingPolicy'],
                 cool_down_period: Optional[_builtins.str] = None,
                 max_cluster_node_count: Optional[_builtins.int] = None,
                 min_cluster_node_count: Optional[_builtins.int] = None):
        """
        :param Sequence['ClusterAutoscalingSettingsAutoscalingPolicyArgs'] autoscaling_policies: The map with autoscaling policies applied to the cluster.
               The key is the identifier of the policy.
               It must meet the following requirements:
               * Only contains 1-63 alphanumeric characters and hyphens
               * Begins with an alphabetical character
               * Ends with a non-hyphen character
               * Not formatted as a UUID
               * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
               Currently the map must contain only one element
               that describes the autoscaling policy for compute nodes.
               Structure is documented below.
        :param _builtins.str cool_down_period: The minimum duration between consecutive autoscale operations.
               It starts once addition or removal of nodes is fully completed.
               Minimum cool down period is 30m.
               Cool down period must be in whole minutes (for example, 30m, 31m, 50m).
               Mandatory for successful addition of autoscaling settings in cluster.
        :param _builtins.int max_cluster_node_count: Maximum number of nodes of any type in a cluster.
               Mandatory for successful addition of autoscaling settings in cluster.
        :param _builtins.int min_cluster_node_count: Minimum number of nodes of any type in a cluster.
               Mandatory for successful addition of autoscaling settings in cluster.
        """
        pulumi.set(__self__, "autoscaling_policies", autoscaling_policies)
        if cool_down_period is not None:
            pulumi.set(__self__, "cool_down_period", cool_down_period)
        if max_cluster_node_count is not None:
            pulumi.set(__self__, "max_cluster_node_count", max_cluster_node_count)
        if min_cluster_node_count is not None:
            pulumi.set(__self__, "min_cluster_node_count", min_cluster_node_count)

    @_builtins.property
    @pulumi.getter(name="autoscalingPolicies")
    def autoscaling_policies(self) -> Sequence['outputs.ClusterAutoscalingSettingsAutoscalingPolicy']:
        """
        The map with autoscaling policies applied to the cluster.
        The key is the identifier of the policy.
        It must meet the following requirements:
        * Only contains 1-63 alphanumeric characters and hyphens
        * Begins with an alphabetical character
        * Ends with a non-hyphen character
        * Not formatted as a UUID
        * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
        Currently the map must contain only one element
        that describes the autoscaling policy for compute nodes.
        Structure is documented below.
        """
        return pulumi.get(self, "autoscaling_policies")

    @_builtins.property
    @pulumi.getter(name="coolDownPeriod")
    def cool_down_period(self) -> Optional[_builtins.str]:
        """
        The minimum duration between consecutive autoscale operations.
        It starts once addition or removal of nodes is fully completed.
        Minimum cool down period is 30m.
        Cool down period must be in whole minutes (for example, 30m, 31m, 50m).
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        return pulumi.get(self, "cool_down_period")

    @_builtins.property
    @pulumi.getter(name="maxClusterNodeCount")
    def max_cluster_node_count(self) -> Optional[_builtins.int]:
        """
        Maximum number of nodes of any type in a cluster.
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        return pulumi.get(self, "max_cluster_node_count")

    @_builtins.property
    @pulumi.getter(name="minClusterNodeCount")
    def min_cluster_node_count(self) -> Optional[_builtins.int]:
        """
        Minimum number of nodes of any type in a cluster.
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        return pulumi.get(self, "min_cluster_node_count")


@pulumi.output_type
class ClusterAutoscalingSettingsAutoscalingPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoscalePolicyId":
            suggest = "autoscale_policy_id"
        elif key == "nodeTypeId":
            suggest = "node_type_id"
        elif key == "scaleOutSize":
            suggest = "scale_out_size"
        elif key == "consumedMemoryThresholds":
            suggest = "consumed_memory_thresholds"
        elif key == "cpuThresholds":
            suggest = "cpu_thresholds"
        elif key == "storageThresholds":
            suggest = "storage_thresholds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAutoscalingSettingsAutoscalingPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAutoscalingSettingsAutoscalingPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAutoscalingSettingsAutoscalingPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscale_policy_id: _builtins.str,
                 node_type_id: _builtins.str,
                 scale_out_size: _builtins.int,
                 consumed_memory_thresholds: Optional['outputs.ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholds'] = None,
                 cpu_thresholds: Optional['outputs.ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholds'] = None,
                 storage_thresholds: Optional['outputs.ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholds'] = None):
        """
        :param _builtins.str autoscale_policy_id: The identifier for this object. Format specified above.
        :param _builtins.str node_type_id: The canonical identifier of the node type to add or remove.
        :param _builtins.int scale_out_size: Number of nodes to add to a cluster during a scale-out operation.
               Must be divisible by 2 for stretched clusters.
        :param 'ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgs' consumed_memory_thresholds: Utilization thresholds pertaining to amount of consumed memory.
               Structure is documented below.
        :param 'ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgs' cpu_thresholds: Utilization thresholds pertaining to CPU utilization.
               Structure is documented below.
        :param 'ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgs' storage_thresholds: Utilization thresholds pertaining to amount of consumed storage.
               Structure is documented below.
        """
        pulumi.set(__self__, "autoscale_policy_id", autoscale_policy_id)
        pulumi.set(__self__, "node_type_id", node_type_id)
        pulumi.set(__self__, "scale_out_size", scale_out_size)
        if consumed_memory_thresholds is not None:
            pulumi.set(__self__, "consumed_memory_thresholds", consumed_memory_thresholds)
        if cpu_thresholds is not None:
            pulumi.set(__self__, "cpu_thresholds", cpu_thresholds)
        if storage_thresholds is not None:
            pulumi.set(__self__, "storage_thresholds", storage_thresholds)

    @_builtins.property
    @pulumi.getter(name="autoscalePolicyId")
    def autoscale_policy_id(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "autoscale_policy_id")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> _builtins.str:
        """
        The canonical identifier of the node type to add or remove.
        """
        return pulumi.get(self, "node_type_id")

    @_builtins.property
    @pulumi.getter(name="scaleOutSize")
    def scale_out_size(self) -> _builtins.int:
        """
        Number of nodes to add to a cluster during a scale-out operation.
        Must be divisible by 2 for stretched clusters.
        """
        return pulumi.get(self, "scale_out_size")

    @_builtins.property
    @pulumi.getter(name="consumedMemoryThresholds")
    def consumed_memory_thresholds(self) -> Optional['outputs.ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholds']:
        """
        Utilization thresholds pertaining to amount of consumed memory.
        Structure is documented below.
        """
        return pulumi.get(self, "consumed_memory_thresholds")

    @_builtins.property
    @pulumi.getter(name="cpuThresholds")
    def cpu_thresholds(self) -> Optional['outputs.ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholds']:
        """
        Utilization thresholds pertaining to CPU utilization.
        Structure is documented below.
        """
        return pulumi.get(self, "cpu_thresholds")

    @_builtins.property
    @pulumi.getter(name="storageThresholds")
    def storage_thresholds(self) -> Optional['outputs.ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholds']:
        """
        Utilization thresholds pertaining to amount of consumed storage.
        Structure is documented below.
        """
        return pulumi.get(self, "storage_thresholds")


@pulumi.output_type
class ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleIn":
            suggest = "scale_in"
        elif key == "scaleOut":
            suggest = "scale_out"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scale_in: _builtins.int,
                 scale_out: _builtins.int):
        """
        :param _builtins.int scale_in: The utilization triggering the scale-in operation in percent.
        :param _builtins.int scale_out: The utilization triggering the scale-out operation in percent.
        """
        pulumi.set(__self__, "scale_in", scale_in)
        pulumi.set(__self__, "scale_out", scale_out)

    @_builtins.property
    @pulumi.getter(name="scaleIn")
    def scale_in(self) -> _builtins.int:
        """
        The utilization triggering the scale-in operation in percent.
        """
        return pulumi.get(self, "scale_in")

    @_builtins.property
    @pulumi.getter(name="scaleOut")
    def scale_out(self) -> _builtins.int:
        """
        The utilization triggering the scale-out operation in percent.
        """
        return pulumi.get(self, "scale_out")


@pulumi.output_type
class ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleIn":
            suggest = "scale_in"
        elif key == "scaleOut":
            suggest = "scale_out"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scale_in: _builtins.int,
                 scale_out: _builtins.int):
        """
        :param _builtins.int scale_in: The utilization triggering the scale-in operation in percent.
        :param _builtins.int scale_out: The utilization triggering the scale-out operation in percent.
        """
        pulumi.set(__self__, "scale_in", scale_in)
        pulumi.set(__self__, "scale_out", scale_out)

    @_builtins.property
    @pulumi.getter(name="scaleIn")
    def scale_in(self) -> _builtins.int:
        """
        The utilization triggering the scale-in operation in percent.
        """
        return pulumi.get(self, "scale_in")

    @_builtins.property
    @pulumi.getter(name="scaleOut")
    def scale_out(self) -> _builtins.int:
        """
        The utilization triggering the scale-out operation in percent.
        """
        return pulumi.get(self, "scale_out")


@pulumi.output_type
class ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleIn":
            suggest = "scale_in"
        elif key == "scaleOut":
            suggest = "scale_out"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scale_in: _builtins.int,
                 scale_out: _builtins.int):
        """
        :param _builtins.int scale_in: The utilization triggering the scale-in operation in percent.
        :param _builtins.int scale_out: The utilization triggering the scale-out operation in percent.
        """
        pulumi.set(__self__, "scale_in", scale_in)
        pulumi.set(__self__, "scale_out", scale_out)

    @_builtins.property
    @pulumi.getter(name="scaleIn")
    def scale_in(self) -> _builtins.int:
        """
        The utilization triggering the scale-in operation in percent.
        """
        return pulumi.get(self, "scale_in")

    @_builtins.property
    @pulumi.getter(name="scaleOut")
    def scale_out(self) -> _builtins.int:
        """
        The utilization triggering the scale-out operation in percent.
        """
        return pulumi.get(self, "scale_out")


@pulumi.output_type
class ClusterDatastoreMountConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datastoreNetwork":
            suggest = "datastore_network"
        elif key == "accessMode":
            suggest = "access_mode"
        elif key == "fileShare":
            suggest = "file_share"
        elif key == "ignoreColocation":
            suggest = "ignore_colocation"
        elif key == "nfsVersion":
            suggest = "nfs_version"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterDatastoreMountConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterDatastoreMountConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterDatastoreMountConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 datastore: _builtins.str,
                 datastore_network: 'outputs.ClusterDatastoreMountConfigDatastoreNetwork',
                 access_mode: Optional[_builtins.str] = None,
                 file_share: Optional[_builtins.str] = None,
                 ignore_colocation: Optional[_builtins.bool] = None,
                 nfs_version: Optional[_builtins.str] = None,
                 servers: Optional[Sequence[_builtins.str]] = None):
        """
        :param _builtins.str datastore: The resource name of the datastore to unmount.
               The datastore requested to be mounted should be in same region/zone as the
               cluster.
               Resource names are schemeless URIs that follow the conventions in
               https://cloud.google.com/apis/design/resource_names.
               For example:
               `projects/my-project/locations/us-central1/datastores/my-datastore`
        :param 'ClusterDatastoreMountConfigDatastoreNetworkArgs' datastore_network: The network configuration for the datastore.
               Structure is documented below.
        :param _builtins.str access_mode: Optional. NFS is accessed by hosts in either read or read_write mode
               Default value used will be READ_WRITE
               Possible values:
               READ_ONLY
               READ_WRITE
        :param _builtins.str file_share: (Output)
               File share name.
        :param _builtins.bool ignore_colocation: Optional. If set to true, the colocation requirement will be ignored.
               If set to false, the colocation requirement will be enforced.
               Colocation requirement is the requirement that the cluster must be in the
               same region/zone of datastore.
        :param _builtins.str nfs_version: Optional. The NFS protocol supported by the NFS volume.
               Default value used will be NFS_V3
               Possible values:
               NFS_V3
        :param Sequence[_builtins.str] servers: (Output)
               Server IP addresses of the NFS volume.
               For NFS 3, you can only provide a single
               server IP address or DNS names.
        """
        pulumi.set(__self__, "datastore", datastore)
        pulumi.set(__self__, "datastore_network", datastore_network)
        if access_mode is not None:
            pulumi.set(__self__, "access_mode", access_mode)
        if file_share is not None:
            pulumi.set(__self__, "file_share", file_share)
        if ignore_colocation is not None:
            pulumi.set(__self__, "ignore_colocation", ignore_colocation)
        if nfs_version is not None:
            pulumi.set(__self__, "nfs_version", nfs_version)
        if servers is not None:
            pulumi.set(__self__, "servers", servers)

    @_builtins.property
    @pulumi.getter
    def datastore(self) -> _builtins.str:
        """
        The resource name of the datastore to unmount.
        The datastore requested to be mounted should be in same region/zone as the
        cluster.
        Resource names are schemeless URIs that follow the conventions in
        https://cloud.google.com/apis/design/resource_names.
        For example:
        `projects/my-project/locations/us-central1/datastores/my-datastore`
        """
        return pulumi.get(self, "datastore")

    @_builtins.property
    @pulumi.getter(name="datastoreNetwork")
    def datastore_network(self) -> 'outputs.ClusterDatastoreMountConfigDatastoreNetwork':
        """
        The network configuration for the datastore.
        Structure is documented below.
        """
        return pulumi.get(self, "datastore_network")

    @_builtins.property
    @pulumi.getter(name="accessMode")
    def access_mode(self) -> Optional[_builtins.str]:
        """
        Optional. NFS is accessed by hosts in either read or read_write mode
        Default value used will be READ_WRITE
        Possible values:
        READ_ONLY
        READ_WRITE
        """
        return pulumi.get(self, "access_mode")

    @_builtins.property
    @pulumi.getter(name="fileShare")
    def file_share(self) -> Optional[_builtins.str]:
        """
        (Output)
        File share name.
        """
        return pulumi.get(self, "file_share")

    @_builtins.property
    @pulumi.getter(name="ignoreColocation")
    def ignore_colocation(self) -> Optional[_builtins.bool]:
        """
        Optional. If set to true, the colocation requirement will be ignored.
        If set to false, the colocation requirement will be enforced.
        Colocation requirement is the requirement that the cluster must be in the
        same region/zone of datastore.
        """
        return pulumi.get(self, "ignore_colocation")

    @_builtins.property
    @pulumi.getter(name="nfsVersion")
    def nfs_version(self) -> Optional[_builtins.str]:
        """
        Optional. The NFS protocol supported by the NFS volume.
        Default value used will be NFS_V3
        Possible values:
        NFS_V3
        """
        return pulumi.get(self, "nfs_version")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Optional[Sequence[_builtins.str]]:
        """
        (Output)
        Server IP addresses of the NFS volume.
        For NFS 3, you can only provide a single
        server IP address or DNS names.
        """
        return pulumi.get(self, "servers")


@pulumi.output_type
class ClusterDatastoreMountConfigDatastoreNetwork(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionCount":
            suggest = "connection_count"
        elif key == "networkPeering":
            suggest = "network_peering"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterDatastoreMountConfigDatastoreNetwork. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterDatastoreMountConfigDatastoreNetwork.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterDatastoreMountConfigDatastoreNetwork.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 subnet: _builtins.str,
                 connection_count: Optional[_builtins.int] = None,
                 mtu: Optional[_builtins.int] = None,
                 network_peering: Optional[_builtins.str] = None):
        """
        :param _builtins.str subnet: The resource name of the subnet
               Resource names are schemeless URIs that follow the conventions in
               https://cloud.google.com/apis/design/resource_names.
               e.g. projects/my-project/locations/us-central1/subnets/my-subnet
        :param _builtins.int connection_count: Optional. The number of connections of the NFS volume.
               Supported from vsphere 8.0u1. Possible values are 1-4.
               Default value is 4.
        :param _builtins.int mtu: Optional. The Maximal Transmission Unit (MTU) of the datastore.
               MTU value can range from 1330-9000. If not set, system sets
               default MTU size to 1500.
        :param _builtins.str network_peering: (Output)
               The resource name of the network peering, used to access the
               file share by clients on private cloud. Resource names are schemeless
               URIs that follow the conventions in
               https://cloud.google.com/apis/design/resource_names.
               e.g.
               projects/my-project/locations/us-central1/networkPeerings/my-network-peering
        """
        pulumi.set(__self__, "subnet", subnet)
        if connection_count is not None:
            pulumi.set(__self__, "connection_count", connection_count)
        if mtu is not None:
            pulumi.set(__self__, "mtu", mtu)
        if network_peering is not None:
            pulumi.set(__self__, "network_peering", network_peering)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        """
        The resource name of the subnet
        Resource names are schemeless URIs that follow the conventions in
        https://cloud.google.com/apis/design/resource_names.
        e.g. projects/my-project/locations/us-central1/subnets/my-subnet
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter(name="connectionCount")
    def connection_count(self) -> Optional[_builtins.int]:
        """
        Optional. The number of connections of the NFS volume.
        Supported from vsphere 8.0u1. Possible values are 1-4.
        Default value is 4.
        """
        return pulumi.get(self, "connection_count")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> Optional[_builtins.int]:
        """
        Optional. The Maximal Transmission Unit (MTU) of the datastore.
        MTU value can range from 1330-9000. If not set, system sets
        default MTU size to 1500.
        """
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter(name="networkPeering")
    def network_peering(self) -> Optional[_builtins.str]:
        """
        (Output)
        The resource name of the network peering, used to access the
        file share by clients on private cloud. Resource names are schemeless
        URIs that follow the conventions in
        https://cloud.google.com/apis/design/resource_names.
        e.g.
        projects/my-project/locations/us-central1/networkPeerings/my-network-peering
        """
        return pulumi.get(self, "network_peering")


@pulumi.output_type
class ClusterNodeTypeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeCount":
            suggest = "node_count"
        elif key == "nodeTypeId":
            suggest = "node_type_id"
        elif key == "customCoreCount":
            suggest = "custom_core_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ClusterNodeTypeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ClusterNodeTypeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ClusterNodeTypeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_count: _builtins.int,
                 node_type_id: _builtins.str,
                 custom_core_count: Optional[_builtins.int] = None):
        """
        :param _builtins.int node_count: The number of nodes of this type in the cluster.
        :param _builtins.str node_type_id: The identifier for this object. Format specified above.
        :param _builtins.int custom_core_count: Customized number of cores available to each node of the type.
               This number must always be one of `nodeType.availableCustomCoreCounts`.
               If zero is provided max value from `nodeType.availableCustomCoreCounts` will be used.
               Once the customer is created then corecount cannot be changed.
        """
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "node_type_id", node_type_id)
        if custom_core_count is not None:
            pulumi.set(__self__, "custom_core_count", custom_core_count)

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        The number of nodes of this type in the cluster.
        """
        return pulumi.get(self, "node_count")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "node_type_id")

    @_builtins.property
    @pulumi.getter(name="customCoreCount")
    def custom_core_count(self) -> Optional[_builtins.int]:
        """
        Customized number of cores available to each node of the type.
        This number must always be one of `nodeType.availableCustomCoreCounts`.
        If zero is provided max value from `nodeType.availableCustomCoreCounts` will be used.
        Once the customer is created then corecount cannot be changed.
        """
        return pulumi.get(self, "custom_core_count")


@pulumi.output_type
class DatastoreNfsDatastore(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "googleFileService":
            suggest = "google_file_service"
        elif key == "thirdPartyFileService":
            suggest = "third_party_file_service"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatastoreNfsDatastore. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatastoreNfsDatastore.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatastoreNfsDatastore.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 google_file_service: Optional['outputs.DatastoreNfsDatastoreGoogleFileService'] = None,
                 third_party_file_service: Optional['outputs.DatastoreNfsDatastoreThirdPartyFileService'] = None):
        """
        :param 'DatastoreNfsDatastoreGoogleFileServiceArgs' google_file_service: Google service file service configuration
               Structure is documented below.
        :param 'DatastoreNfsDatastoreThirdPartyFileServiceArgs' third_party_file_service: Third party file service configuration
               Structure is documented below.
        """
        if google_file_service is not None:
            pulumi.set(__self__, "google_file_service", google_file_service)
        if third_party_file_service is not None:
            pulumi.set(__self__, "third_party_file_service", third_party_file_service)

    @_builtins.property
    @pulumi.getter(name="googleFileService")
    def google_file_service(self) -> Optional['outputs.DatastoreNfsDatastoreGoogleFileService']:
        """
        Google service file service configuration
        Structure is documented below.
        """
        return pulumi.get(self, "google_file_service")

    @_builtins.property
    @pulumi.getter(name="thirdPartyFileService")
    def third_party_file_service(self) -> Optional['outputs.DatastoreNfsDatastoreThirdPartyFileService']:
        """
        Third party file service configuration
        Structure is documented below.
        """
        return pulumi.get(self, "third_party_file_service")


@pulumi.output_type
class DatastoreNfsDatastoreGoogleFileService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "filestoreInstance":
            suggest = "filestore_instance"
        elif key == "netappVolume":
            suggest = "netapp_volume"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatastoreNfsDatastoreGoogleFileService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatastoreNfsDatastoreGoogleFileService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatastoreNfsDatastoreGoogleFileService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 filestore_instance: Optional[_builtins.str] = None,
                 netapp_volume: Optional[_builtins.str] = None):
        """
        :param _builtins.str filestore_instance: Google filestore instance resource name
               e.g. projects/my-project/locations/me-west1-b/instances/my-instance
        :param _builtins.str netapp_volume: Google netapp volume resource name
               e.g. projects/my-project/locations/me-west1-b/volumes/my-volume
        """
        if filestore_instance is not None:
            pulumi.set(__self__, "filestore_instance", filestore_instance)
        if netapp_volume is not None:
            pulumi.set(__self__, "netapp_volume", netapp_volume)

    @_builtins.property
    @pulumi.getter(name="filestoreInstance")
    def filestore_instance(self) -> Optional[_builtins.str]:
        """
        Google filestore instance resource name
        e.g. projects/my-project/locations/me-west1-b/instances/my-instance
        """
        return pulumi.get(self, "filestore_instance")

    @_builtins.property
    @pulumi.getter(name="netappVolume")
    def netapp_volume(self) -> Optional[_builtins.str]:
        """
        Google netapp volume resource name
        e.g. projects/my-project/locations/me-west1-b/volumes/my-volume
        """
        return pulumi.get(self, "netapp_volume")


@pulumi.output_type
class DatastoreNfsDatastoreThirdPartyFileService(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "fileShare":
            suggest = "file_share"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in DatastoreNfsDatastoreThirdPartyFileService. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        DatastoreNfsDatastoreThirdPartyFileService.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        DatastoreNfsDatastoreThirdPartyFileService.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 file_share: _builtins.str,
                 network: _builtins.str,
                 servers: Sequence[_builtins.str]):
        """
        :param _builtins.str file_share: Required
               Mount Folder name
        :param _builtins.str network: Required to identify vpc peering used for NFS access
               network name of NFS's vpc
               e.g. projects/project-id/global/networks/my-network_id
        :param Sequence[_builtins.str] servers: Server IP addresses of the NFS file service.
               NFS v3, provide a single IP address or DNS name.
               Multiple servers can be supported in future when NFS 4.1 protocol support
               is enabled.
        """
        pulumi.set(__self__, "file_share", file_share)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "servers", servers)

    @_builtins.property
    @pulumi.getter(name="fileShare")
    def file_share(self) -> _builtins.str:
        """
        Required
        Mount Folder name
        """
        return pulumi.get(self, "file_share")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        Required to identify vpc peering used for NFS access
        network name of NFS's vpc
        e.g. projects/project-id/global/networks/my-network_id
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Sequence[_builtins.str]:
        """
        Server IP addresses of the NFS file service.
        NFS v3, provide a single IP address or DNS name.
        Multiple servers can be supported in future when NFS 4.1 protocol support
        is enabled.
        """
        return pulumi.get(self, "servers")


@pulumi.output_type
class ExternalAccessRuleDestinationIpRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "externalAddress":
            suggest = "external_address"
        elif key == "ipAddressRange":
            suggest = "ip_address_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalAccessRuleDestinationIpRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalAccessRuleDestinationIpRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalAccessRuleDestinationIpRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 external_address: Optional[_builtins.str] = None,
                 ip_address_range: Optional[_builtins.str] = None):
        """
        :param _builtins.str external_address: The name of an `ExternalAddress` resource.
        :param _builtins.str ip_address_range: An IP address range in the CIDR format.
        """
        if external_address is not None:
            pulumi.set(__self__, "external_address", external_address)
        if ip_address_range is not None:
            pulumi.set(__self__, "ip_address_range", ip_address_range)

    @_builtins.property
    @pulumi.getter(name="externalAddress")
    def external_address(self) -> Optional[_builtins.str]:
        """
        The name of an `ExternalAddress` resource.
        """
        return pulumi.get(self, "external_address")

    @_builtins.property
    @pulumi.getter(name="ipAddressRange")
    def ip_address_range(self) -> Optional[_builtins.str]:
        """
        An IP address range in the CIDR format.
        """
        return pulumi.get(self, "ip_address_range")


@pulumi.output_type
class ExternalAccessRuleSourceIpRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "ipAddress":
            suggest = "ip_address"
        elif key == "ipAddressRange":
            suggest = "ip_address_range"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ExternalAccessRuleSourceIpRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ExternalAccessRuleSourceIpRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ExternalAccessRuleSourceIpRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ip_address: Optional[_builtins.str] = None,
                 ip_address_range: Optional[_builtins.str] = None):
        """
        :param _builtins.str ip_address: A single IP address.
        :param _builtins.str ip_address_range: An IP address range in the CIDR format.
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_address_range is not None:
            pulumi.set(__self__, "ip_address_range", ip_address_range)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[_builtins.str]:
        """
        A single IP address.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="ipAddressRange")
    def ip_address_range(self) -> Optional[_builtins.str]:
        """
        An IP address range in the CIDR format.
        """
        return pulumi.get(self, "ip_address_range")


@pulumi.output_type
class NetworkPolicyExternalIp(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: True if the service is enabled; false otherwise.
        :param _builtins.str state: (Output)
               State of the service. New values may be added to this enum when appropriate.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        True if the service is enabled; false otherwise.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        State of the service. New values may be added to this enum when appropriate.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkPolicyInternetAccess(dict):
    def __init__(__self__, *,
                 enabled: Optional[_builtins.bool] = None,
                 state: Optional[_builtins.str] = None):
        """
        :param _builtins.bool enabled: True if the service is enabled; false otherwise.
        :param _builtins.str state: (Output)
               State of the service. New values may be added to this enum when appropriate.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[_builtins.bool]:
        """
        True if the service is enabled; false otherwise.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        (Output)
        State of the service. New values may be added to this enum when appropriate.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class NetworkVpcNetwork(dict):
    def __init__(__self__, *,
                 network: Optional[_builtins.str] = None,
                 type: Optional[_builtins.str] = None):
        """
        :param _builtins.str network: (Output)
               The relative resource name of the service VPC network this VMware Engine network is attached to.
               For example: projects/123123/global/networks/my-network
        :param _builtins.str type: VMware Engine network type.
               Possible values are: `LEGACY`, `STANDARD`.
        """
        if network is not None:
            pulumi.set(__self__, "network", network)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def network(self) -> Optional[_builtins.str]:
        """
        (Output)
        The relative resource name of the service VPC network this VMware Engine network is attached to.
        For example: projects/123123/global/networks/my-network
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def type(self) -> Optional[_builtins.str]:
        """
        VMware Engine network type.
        Possible values are: `LEGACY`, `STANDARD`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class PrivateCloudHcx(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateCloudHcx. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateCloudHcx.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateCloudHcx.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: Optional[_builtins.str] = None,
                 internal_ip: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str fqdn: Fully qualified domain name of the appliance.
        :param _builtins.str internal_ip: Internal IP address of the appliance.
        :param _builtins.str state: State of the appliance.
               Possible values are: `ACTIVE`, `CREATING`.
        :param _builtins.str version: Version of the appliance.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        """
        Fully qualified domain name of the appliance.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[_builtins.str]:
        """
        Internal IP address of the appliance.
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        State of the appliance.
        Possible values are: `ACTIVE`, `CREATING`.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Version of the appliance.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class PrivateCloudManagementCluster(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clusterId":
            suggest = "cluster_id"
        elif key == "autoscalingSettings":
            suggest = "autoscaling_settings"
        elif key == "nodeTypeConfigs":
            suggest = "node_type_configs"
        elif key == "stretchedClusterConfig":
            suggest = "stretched_cluster_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateCloudManagementCluster. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateCloudManagementCluster.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateCloudManagementCluster.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 cluster_id: _builtins.str,
                 autoscaling_settings: Optional['outputs.PrivateCloudManagementClusterAutoscalingSettings'] = None,
                 node_type_configs: Optional[Sequence['outputs.PrivateCloudManagementClusterNodeTypeConfig']] = None,
                 stretched_cluster_config: Optional['outputs.PrivateCloudManagementClusterStretchedClusterConfig'] = None):
        """
        :param _builtins.str cluster_id: The user-provided identifier of the new Cluster. The identifier must meet the following requirements:
               * Only contains 1-63 alphanumeric characters and hyphens
               * Begins with an alphabetical character
               * Ends with a non-hyphen character
               * Not formatted as a UUID
               * Complies with RFC 1034 (https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
        :param 'PrivateCloudManagementClusterAutoscalingSettingsArgs' autoscaling_settings: Configuration of the autoscaling applied to this cluster
               Private cloud must have a minimum of 3 nodes to add autoscale settings
               Structure is documented below.
        :param Sequence['PrivateCloudManagementClusterNodeTypeConfigArgs'] node_type_configs: The map of cluster node types in this cluster,
               where the key is canonical identifier of the node type (corresponds to the NodeType).
               Structure is documented below.
        :param 'PrivateCloudManagementClusterStretchedClusterConfigArgs' stretched_cluster_config: The stretched cluster configuration for the private cloud.
               Structure is documented below.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        if autoscaling_settings is not None:
            pulumi.set(__self__, "autoscaling_settings", autoscaling_settings)
        if node_type_configs is not None:
            pulumi.set(__self__, "node_type_configs", node_type_configs)
        if stretched_cluster_config is not None:
            pulumi.set(__self__, "stretched_cluster_config", stretched_cluster_config)

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        The user-provided identifier of the new Cluster. The identifier must meet the following requirements:
        * Only contains 1-63 alphanumeric characters and hyphens
        * Begins with an alphabetical character
        * Ends with a non-hyphen character
        * Not formatted as a UUID
        * Complies with RFC 1034 (https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="autoscalingSettings")
    def autoscaling_settings(self) -> Optional['outputs.PrivateCloudManagementClusterAutoscalingSettings']:
        """
        Configuration of the autoscaling applied to this cluster
        Private cloud must have a minimum of 3 nodes to add autoscale settings
        Structure is documented below.
        """
        return pulumi.get(self, "autoscaling_settings")

    @_builtins.property
    @pulumi.getter(name="nodeTypeConfigs")
    def node_type_configs(self) -> Optional[Sequence['outputs.PrivateCloudManagementClusterNodeTypeConfig']]:
        """
        The map of cluster node types in this cluster,
        where the key is canonical identifier of the node type (corresponds to the NodeType).
        Structure is documented below.
        """
        return pulumi.get(self, "node_type_configs")

    @_builtins.property
    @pulumi.getter(name="stretchedClusterConfig")
    def stretched_cluster_config(self) -> Optional['outputs.PrivateCloudManagementClusterStretchedClusterConfig']:
        """
        The stretched cluster configuration for the private cloud.
        Structure is documented below.
        """
        return pulumi.get(self, "stretched_cluster_config")


@pulumi.output_type
class PrivateCloudManagementClusterAutoscalingSettings(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoscalingPolicies":
            suggest = "autoscaling_policies"
        elif key == "coolDownPeriod":
            suggest = "cool_down_period"
        elif key == "maxClusterNodeCount":
            suggest = "max_cluster_node_count"
        elif key == "minClusterNodeCount":
            suggest = "min_cluster_node_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateCloudManagementClusterAutoscalingSettings. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateCloudManagementClusterAutoscalingSettings.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateCloudManagementClusterAutoscalingSettings.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscaling_policies: Sequence['outputs.PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicy'],
                 cool_down_period: Optional[_builtins.str] = None,
                 max_cluster_node_count: Optional[_builtins.int] = None,
                 min_cluster_node_count: Optional[_builtins.int] = None):
        """
        :param Sequence['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyArgs'] autoscaling_policies: The map with autoscaling policies applied to the cluster.
               The key is the identifier of the policy.
               It must meet the following requirements:
               * Only contains 1-63 alphanumeric characters and hyphens
               * Begins with an alphabetical character
               * Ends with a non-hyphen character
               * Not formatted as a UUID
               * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
               Currently the map must contain only one element
               that describes the autoscaling policy for compute nodes.
               Structure is documented below.
        :param _builtins.str cool_down_period: The minimum duration between consecutive autoscale operations.
               It starts once addition or removal of nodes is fully completed.
               Minimum cool down period is 30m.
               Cool down period must be in whole minutes (for example, 30m, 31m, 50m).
               Mandatory for successful addition of autoscaling settings in cluster.
        :param _builtins.int max_cluster_node_count: Maximum number of nodes of any type in a cluster.
               Mandatory for successful addition of autoscaling settings in cluster.
        :param _builtins.int min_cluster_node_count: Minimum number of nodes of any type in a cluster.
               Mandatory for successful addition of autoscaling settings in cluster.
        """
        pulumi.set(__self__, "autoscaling_policies", autoscaling_policies)
        if cool_down_period is not None:
            pulumi.set(__self__, "cool_down_period", cool_down_period)
        if max_cluster_node_count is not None:
            pulumi.set(__self__, "max_cluster_node_count", max_cluster_node_count)
        if min_cluster_node_count is not None:
            pulumi.set(__self__, "min_cluster_node_count", min_cluster_node_count)

    @_builtins.property
    @pulumi.getter(name="autoscalingPolicies")
    def autoscaling_policies(self) -> Sequence['outputs.PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicy']:
        """
        The map with autoscaling policies applied to the cluster.
        The key is the identifier of the policy.
        It must meet the following requirements:
        * Only contains 1-63 alphanumeric characters and hyphens
        * Begins with an alphabetical character
        * Ends with a non-hyphen character
        * Not formatted as a UUID
        * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
        Currently the map must contain only one element
        that describes the autoscaling policy for compute nodes.
        Structure is documented below.
        """
        return pulumi.get(self, "autoscaling_policies")

    @_builtins.property
    @pulumi.getter(name="coolDownPeriod")
    def cool_down_period(self) -> Optional[_builtins.str]:
        """
        The minimum duration between consecutive autoscale operations.
        It starts once addition or removal of nodes is fully completed.
        Minimum cool down period is 30m.
        Cool down period must be in whole minutes (for example, 30m, 31m, 50m).
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        return pulumi.get(self, "cool_down_period")

    @_builtins.property
    @pulumi.getter(name="maxClusterNodeCount")
    def max_cluster_node_count(self) -> Optional[_builtins.int]:
        """
        Maximum number of nodes of any type in a cluster.
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        return pulumi.get(self, "max_cluster_node_count")

    @_builtins.property
    @pulumi.getter(name="minClusterNodeCount")
    def min_cluster_node_count(self) -> Optional[_builtins.int]:
        """
        Minimum number of nodes of any type in a cluster.
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        return pulumi.get(self, "min_cluster_node_count")


@pulumi.output_type
class PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicy(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "autoscalePolicyId":
            suggest = "autoscale_policy_id"
        elif key == "nodeTypeId":
            suggest = "node_type_id"
        elif key == "scaleOutSize":
            suggest = "scale_out_size"
        elif key == "consumedMemoryThresholds":
            suggest = "consumed_memory_thresholds"
        elif key == "cpuThresholds":
            suggest = "cpu_thresholds"
        elif key == "storageThresholds":
            suggest = "storage_thresholds"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicy. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicy.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicy.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 autoscale_policy_id: _builtins.str,
                 node_type_id: _builtins.str,
                 scale_out_size: _builtins.int,
                 consumed_memory_thresholds: Optional['outputs.PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholds'] = None,
                 cpu_thresholds: Optional['outputs.PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholds'] = None,
                 storage_thresholds: Optional['outputs.PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholds'] = None):
        """
        :param _builtins.str autoscale_policy_id: The identifier for this object. Format specified above.
        :param _builtins.str node_type_id: The canonical identifier of the node type to add or remove.
        :param _builtins.int scale_out_size: Number of nodes to add to a cluster during a scale-out operation.
               Must be divisible by 2 for stretched clusters.
        :param 'PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgs' consumed_memory_thresholds: Utilization thresholds pertaining to amount of consumed memory.
               Structure is documented below.
        :param 'PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgs' cpu_thresholds: Utilization thresholds pertaining to CPU utilization.
               Structure is documented below.
        :param 'PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgs' storage_thresholds: Utilization thresholds pertaining to amount of consumed storage.
               Structure is documented below.
        """
        pulumi.set(__self__, "autoscale_policy_id", autoscale_policy_id)
        pulumi.set(__self__, "node_type_id", node_type_id)
        pulumi.set(__self__, "scale_out_size", scale_out_size)
        if consumed_memory_thresholds is not None:
            pulumi.set(__self__, "consumed_memory_thresholds", consumed_memory_thresholds)
        if cpu_thresholds is not None:
            pulumi.set(__self__, "cpu_thresholds", cpu_thresholds)
        if storage_thresholds is not None:
            pulumi.set(__self__, "storage_thresholds", storage_thresholds)

    @_builtins.property
    @pulumi.getter(name="autoscalePolicyId")
    def autoscale_policy_id(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "autoscale_policy_id")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> _builtins.str:
        """
        The canonical identifier of the node type to add or remove.
        """
        return pulumi.get(self, "node_type_id")

    @_builtins.property
    @pulumi.getter(name="scaleOutSize")
    def scale_out_size(self) -> _builtins.int:
        """
        Number of nodes to add to a cluster during a scale-out operation.
        Must be divisible by 2 for stretched clusters.
        """
        return pulumi.get(self, "scale_out_size")

    @_builtins.property
    @pulumi.getter(name="consumedMemoryThresholds")
    def consumed_memory_thresholds(self) -> Optional['outputs.PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholds']:
        """
        Utilization thresholds pertaining to amount of consumed memory.
        Structure is documented below.
        """
        return pulumi.get(self, "consumed_memory_thresholds")

    @_builtins.property
    @pulumi.getter(name="cpuThresholds")
    def cpu_thresholds(self) -> Optional['outputs.PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholds']:
        """
        Utilization thresholds pertaining to CPU utilization.
        Structure is documented below.
        """
        return pulumi.get(self, "cpu_thresholds")

    @_builtins.property
    @pulumi.getter(name="storageThresholds")
    def storage_thresholds(self) -> Optional['outputs.PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholds']:
        """
        Utilization thresholds pertaining to amount of consumed storage.
        Structure is documented below.
        """
        return pulumi.get(self, "storage_thresholds")


@pulumi.output_type
class PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleIn":
            suggest = "scale_in"
        elif key == "scaleOut":
            suggest = "scale_out"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scale_in: _builtins.int,
                 scale_out: _builtins.int):
        """
        :param _builtins.int scale_in: The utilization triggering the scale-in operation in percent.
        :param _builtins.int scale_out: The utilization triggering the scale-out operation in percent.
        """
        pulumi.set(__self__, "scale_in", scale_in)
        pulumi.set(__self__, "scale_out", scale_out)

    @_builtins.property
    @pulumi.getter(name="scaleIn")
    def scale_in(self) -> _builtins.int:
        """
        The utilization triggering the scale-in operation in percent.
        """
        return pulumi.get(self, "scale_in")

    @_builtins.property
    @pulumi.getter(name="scaleOut")
    def scale_out(self) -> _builtins.int:
        """
        The utilization triggering the scale-out operation in percent.
        """
        return pulumi.get(self, "scale_out")


@pulumi.output_type
class PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleIn":
            suggest = "scale_in"
        elif key == "scaleOut":
            suggest = "scale_out"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scale_in: _builtins.int,
                 scale_out: _builtins.int):
        """
        :param _builtins.int scale_in: The utilization triggering the scale-in operation in percent.
        :param _builtins.int scale_out: The utilization triggering the scale-out operation in percent.
        """
        pulumi.set(__self__, "scale_in", scale_in)
        pulumi.set(__self__, "scale_out", scale_out)

    @_builtins.property
    @pulumi.getter(name="scaleIn")
    def scale_in(self) -> _builtins.int:
        """
        The utilization triggering the scale-in operation in percent.
        """
        return pulumi.get(self, "scale_in")

    @_builtins.property
    @pulumi.getter(name="scaleOut")
    def scale_out(self) -> _builtins.int:
        """
        The utilization triggering the scale-out operation in percent.
        """
        return pulumi.get(self, "scale_out")


@pulumi.output_type
class PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholds(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "scaleIn":
            suggest = "scale_in"
        elif key == "scaleOut":
            suggest = "scale_out"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholds. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholds.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholds.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 scale_in: _builtins.int,
                 scale_out: _builtins.int):
        """
        :param _builtins.int scale_in: The utilization triggering the scale-in operation in percent.
        :param _builtins.int scale_out: The utilization triggering the scale-out operation in percent.
        """
        pulumi.set(__self__, "scale_in", scale_in)
        pulumi.set(__self__, "scale_out", scale_out)

    @_builtins.property
    @pulumi.getter(name="scaleIn")
    def scale_in(self) -> _builtins.int:
        """
        The utilization triggering the scale-in operation in percent.
        """
        return pulumi.get(self, "scale_in")

    @_builtins.property
    @pulumi.getter(name="scaleOut")
    def scale_out(self) -> _builtins.int:
        """
        The utilization triggering the scale-out operation in percent.
        """
        return pulumi.get(self, "scale_out")


@pulumi.output_type
class PrivateCloudManagementClusterNodeTypeConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "nodeCount":
            suggest = "node_count"
        elif key == "nodeTypeId":
            suggest = "node_type_id"
        elif key == "customCoreCount":
            suggest = "custom_core_count"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateCloudManagementClusterNodeTypeConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateCloudManagementClusterNodeTypeConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateCloudManagementClusterNodeTypeConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 node_count: _builtins.int,
                 node_type_id: _builtins.str,
                 custom_core_count: Optional[_builtins.int] = None):
        """
        :param _builtins.int node_count: The number of nodes of this type in the cluster.
        :param _builtins.str node_type_id: The identifier for this object. Format specified above.
        :param _builtins.int custom_core_count: Customized number of cores available to each node of the type.
               This number must always be one of `nodeType.availableCustomCoreCounts`.
               If zero is provided max value from `nodeType.availableCustomCoreCounts` will be used.
               This cannot be changed once the PrivateCloud is created.
        """
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "node_type_id", node_type_id)
        if custom_core_count is not None:
            pulumi.set(__self__, "custom_core_count", custom_core_count)

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        The number of nodes of this type in the cluster.
        """
        return pulumi.get(self, "node_count")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> _builtins.str:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "node_type_id")

    @_builtins.property
    @pulumi.getter(name="customCoreCount")
    def custom_core_count(self) -> Optional[_builtins.int]:
        """
        Customized number of cores available to each node of the type.
        This number must always be one of `nodeType.availableCustomCoreCounts`.
        If zero is provided max value from `nodeType.availableCustomCoreCounts` will be used.
        This cannot be changed once the PrivateCloud is created.
        """
        return pulumi.get(self, "custom_core_count")


@pulumi.output_type
class PrivateCloudManagementClusterStretchedClusterConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "preferredLocation":
            suggest = "preferred_location"
        elif key == "secondaryLocation":
            suggest = "secondary_location"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateCloudManagementClusterStretchedClusterConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateCloudManagementClusterStretchedClusterConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateCloudManagementClusterStretchedClusterConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 preferred_location: Optional[_builtins.str] = None,
                 secondary_location: Optional[_builtins.str] = None):
        """
        :param _builtins.str preferred_location: Zone that will remain operational when connection between the two zones is lost.
               Specify the zone in the following format: projects/{project}/locations/{location}.
        :param _builtins.str secondary_location: Additional zone for a higher level of availability and load balancing.
               Specify the zone in the following format: projects/{project}/locations/{location}.
        """
        if preferred_location is not None:
            pulumi.set(__self__, "preferred_location", preferred_location)
        if secondary_location is not None:
            pulumi.set(__self__, "secondary_location", secondary_location)

    @_builtins.property
    @pulumi.getter(name="preferredLocation")
    def preferred_location(self) -> Optional[_builtins.str]:
        """
        Zone that will remain operational when connection between the two zones is lost.
        Specify the zone in the following format: projects/{project}/locations/{location}.
        """
        return pulumi.get(self, "preferred_location")

    @_builtins.property
    @pulumi.getter(name="secondaryLocation")
    def secondary_location(self) -> Optional[_builtins.str]:
        """
        Additional zone for a higher level of availability and load balancing.
        Specify the zone in the following format: projects/{project}/locations/{location}.
        """
        return pulumi.get(self, "secondary_location")


@pulumi.output_type
class PrivateCloudNetworkConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "managementCidr":
            suggest = "management_cidr"
        elif key == "dnsServerIp":
            suggest = "dns_server_ip"
        elif key == "managementIpAddressLayoutVersion":
            suggest = "management_ip_address_layout_version"
        elif key == "vmwareEngineNetwork":
            suggest = "vmware_engine_network"
        elif key == "vmwareEngineNetworkCanonical":
            suggest = "vmware_engine_network_canonical"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateCloudNetworkConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateCloudNetworkConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateCloudNetworkConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 management_cidr: _builtins.str,
                 dns_server_ip: Optional[_builtins.str] = None,
                 management_ip_address_layout_version: Optional[_builtins.int] = None,
                 vmware_engine_network: Optional[_builtins.str] = None,
                 vmware_engine_network_canonical: Optional[_builtins.str] = None):
        """
        :param _builtins.str management_cidr: Management CIDR used by VMware management appliances.
        :param _builtins.str dns_server_ip: (Output)
               DNS Server IP of the Private Cloud.
        :param _builtins.int management_ip_address_layout_version: (Output)
               The IP address layout version of the management IP address range.
               Possible versions include:
               * managementIpAddressLayoutVersion=1: Indicates the legacy IP address layout used by some existing private clouds. This is no longer supported for new private clouds
               as it does not support all features.
               * managementIpAddressLayoutVersion=2: Indicates the latest IP address layout
               used by all newly created private clouds. This version supports all current features.
        :param _builtins.str vmware_engine_network: The relative resource name of the VMware Engine network attached to the private cloud.
               Specify the name in the following form: projects/{project}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}
               where {project} can either be a project number or a project ID.
        :param _builtins.str vmware_engine_network_canonical: (Output)
               The canonical name of the VMware Engine network in
               the form: projects/{project_number}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}
        """
        pulumi.set(__self__, "management_cidr", management_cidr)
        if dns_server_ip is not None:
            pulumi.set(__self__, "dns_server_ip", dns_server_ip)
        if management_ip_address_layout_version is not None:
            pulumi.set(__self__, "management_ip_address_layout_version", management_ip_address_layout_version)
        if vmware_engine_network is not None:
            pulumi.set(__self__, "vmware_engine_network", vmware_engine_network)
        if vmware_engine_network_canonical is not None:
            pulumi.set(__self__, "vmware_engine_network_canonical", vmware_engine_network_canonical)

    @_builtins.property
    @pulumi.getter(name="managementCidr")
    def management_cidr(self) -> _builtins.str:
        """
        Management CIDR used by VMware management appliances.
        """
        return pulumi.get(self, "management_cidr")

    @_builtins.property
    @pulumi.getter(name="dnsServerIp")
    def dns_server_ip(self) -> Optional[_builtins.str]:
        """
        (Output)
        DNS Server IP of the Private Cloud.
        """
        return pulumi.get(self, "dns_server_ip")

    @_builtins.property
    @pulumi.getter(name="managementIpAddressLayoutVersion")
    def management_ip_address_layout_version(self) -> Optional[_builtins.int]:
        """
        (Output)
        The IP address layout version of the management IP address range.
        Possible versions include:
        * managementIpAddressLayoutVersion=1: Indicates the legacy IP address layout used by some existing private clouds. This is no longer supported for new private clouds
        as it does not support all features.
        * managementIpAddressLayoutVersion=2: Indicates the latest IP address layout
        used by all newly created private clouds. This version supports all current features.
        """
        return pulumi.get(self, "management_ip_address_layout_version")

    @_builtins.property
    @pulumi.getter(name="vmwareEngineNetwork")
    def vmware_engine_network(self) -> Optional[_builtins.str]:
        """
        The relative resource name of the VMware Engine network attached to the private cloud.
        Specify the name in the following form: projects/{project}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}
        where {project} can either be a project number or a project ID.
        """
        return pulumi.get(self, "vmware_engine_network")

    @_builtins.property
    @pulumi.getter(name="vmwareEngineNetworkCanonical")
    def vmware_engine_network_canonical(self) -> Optional[_builtins.str]:
        """
        (Output)
        The canonical name of the VMware Engine network in
        the form: projects/{project_number}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}
        """
        return pulumi.get(self, "vmware_engine_network_canonical")


@pulumi.output_type
class PrivateCloudNsx(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateCloudNsx. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateCloudNsx.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateCloudNsx.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: Optional[_builtins.str] = None,
                 internal_ip: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str fqdn: Fully qualified domain name of the appliance.
        :param _builtins.str internal_ip: Internal IP address of the appliance.
        :param _builtins.str state: State of the appliance.
               Possible values are: `ACTIVE`, `CREATING`.
        :param _builtins.str version: Version of the appliance.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        """
        Fully qualified domain name of the appliance.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[_builtins.str]:
        """
        Internal IP address of the appliance.
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        State of the appliance.
        Possible values are: `ACTIVE`, `CREATING`.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Version of the appliance.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class PrivateCloudVcenter(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "internalIp":
            suggest = "internal_ip"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateCloudVcenter. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateCloudVcenter.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateCloudVcenter.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fqdn: Optional[_builtins.str] = None,
                 internal_ip: Optional[_builtins.str] = None,
                 state: Optional[_builtins.str] = None,
                 version: Optional[_builtins.str] = None):
        """
        :param _builtins.str fqdn: Fully qualified domain name of the appliance.
        :param _builtins.str internal_ip: Internal IP address of the appliance.
        :param _builtins.str state: State of the appliance.
               Possible values are: `ACTIVE`, `CREATING`.
        :param _builtins.str version: Version of the appliance.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> Optional[_builtins.str]:
        """
        Fully qualified domain name of the appliance.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[_builtins.str]:
        """
        Internal IP address of the appliance.
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[_builtins.str]:
        """
        State of the appliance.
        Possible values are: `ACTIVE`, `CREATING`.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[_builtins.str]:
        """
        Version of the appliance.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class SubnetDhcpAddressRange(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "firstAddress":
            suggest = "first_address"
        elif key == "lastAddress":
            suggest = "last_address"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in SubnetDhcpAddressRange. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        SubnetDhcpAddressRange.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        SubnetDhcpAddressRange.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 first_address: Optional[_builtins.str] = None,
                 last_address: Optional[_builtins.str] = None):
        """
        :param _builtins.str first_address: (Output)
               The first IP address of the range.
        :param _builtins.str last_address: (Output)
               The last IP address of the range.
        """
        if first_address is not None:
            pulumi.set(__self__, "first_address", first_address)
        if last_address is not None:
            pulumi.set(__self__, "last_address", last_address)

    @_builtins.property
    @pulumi.getter(name="firstAddress")
    def first_address(self) -> Optional[_builtins.str]:
        """
        (Output)
        The first IP address of the range.
        """
        return pulumi.get(self, "first_address")

    @_builtins.property
    @pulumi.getter(name="lastAddress")
    def last_address(self) -> Optional[_builtins.str]:
        """
        (Output)
        The last IP address of the range.
        """
        return pulumi.get(self, "last_address")


@pulumi.output_type
class GetAnnouncementsAnnouncementResult(dict):
    def __init__(__self__, *,
                 code: _builtins.str,
                 metadata: Mapping[str, _builtins.str],
                 name: _builtins.str,
                 target_resource_type: _builtins.str):
        """
        :param _builtins.str code: Code of the announcement. Possible values include: `MAINTENANCE_SCHEDULE_NOT_AVAILABLE`, `MAINTENANCE_SCHEDULE_READY`, `MAINTENANCE_SCHEDULE_LOCKED`, `MAINTENANCE_SCHEDULE_CANCELED`, `MAINTENANCE_INPROGRESS`, `MAINTENANCE_SUCCESSFUL`, `MAINTENANCE_CANCELED`, `MAINTENANCE_PAUSED`, `MAINTENANCE_FAILED`, `IMMUTABLE_MAINTENANCE_SCHEDULE_READY`, `MAINTENANCE_STARTING_SOON`.
        :param Mapping[str, _builtins.str] metadata: `Additional structured details about this announcement`
        :param _builtins.str name: The resource name of the specific Announcement to retrieve. If provided, the `announcements` list will contain only this announcement.
        :param _builtins.str target_resource_type: Target Resource Type defines the type of the target for the announcement.
        """
        pulumi.set(__self__, "code", code)
        pulumi.set(__self__, "metadata", metadata)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "target_resource_type", target_resource_type)

    @_builtins.property
    @pulumi.getter
    def code(self) -> _builtins.str:
        """
        Code of the announcement. Possible values include: `MAINTENANCE_SCHEDULE_NOT_AVAILABLE`, `MAINTENANCE_SCHEDULE_READY`, `MAINTENANCE_SCHEDULE_LOCKED`, `MAINTENANCE_SCHEDULE_CANCELED`, `MAINTENANCE_INPROGRESS`, `MAINTENANCE_SUCCESSFUL`, `MAINTENANCE_CANCELED`, `MAINTENANCE_PAUSED`, `MAINTENANCE_FAILED`, `IMMUTABLE_MAINTENANCE_SCHEDULE_READY`, `MAINTENANCE_STARTING_SOON`.
        """
        return pulumi.get(self, "code")

    @_builtins.property
    @pulumi.getter
    def metadata(self) -> Mapping[str, _builtins.str]:
        """
        `Additional structured details about this announcement`
        """
        return pulumi.get(self, "metadata")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The resource name of the specific Announcement to retrieve. If provided, the `announcements` list will contain only this announcement.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter(name="targetResourceType")
    def target_resource_type(self) -> _builtins.str:
        """
        Target Resource Type defines the type of the target for the announcement.
        """
        return pulumi.get(self, "target_resource_type")


@pulumi.output_type
class GetClusterAutoscalingSettingResult(dict):
    def __init__(__self__, *,
                 autoscaling_policies: Sequence['outputs.GetClusterAutoscalingSettingAutoscalingPolicyResult'],
                 cool_down_period: _builtins.str,
                 max_cluster_node_count: _builtins.int,
                 min_cluster_node_count: _builtins.int):
        """
        :param Sequence['GetClusterAutoscalingSettingAutoscalingPolicyArgs'] autoscaling_policies: The map with autoscaling policies applied to the cluster.
               The key is the identifier of the policy.
               It must meet the following requirements:
                 * Only contains 1-63 alphanumeric characters and hyphens
                 * Begins with an alphabetical character
                 * Ends with a non-hyphen character
                 * Not formatted as a UUID
                 * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
               
               Currently the map must contain only one element
               that describes the autoscaling policy for compute nodes.
        :param _builtins.str cool_down_period: The minimum duration between consecutive autoscale operations.
               It starts once addition or removal of nodes is fully completed.
               Minimum cool down period is 30m.
               Cool down period must be in whole minutes (for example, 30m, 31m, 50m).
               Mandatory for successful addition of autoscaling settings in cluster.
        :param _builtins.int max_cluster_node_count: Maximum number of nodes of any type in a cluster.
               Mandatory for successful addition of autoscaling settings in cluster.
        :param _builtins.int min_cluster_node_count: Minimum number of nodes of any type in a cluster.
               Mandatory for successful addition of autoscaling settings in cluster.
        """
        pulumi.set(__self__, "autoscaling_policies", autoscaling_policies)
        pulumi.set(__self__, "cool_down_period", cool_down_period)
        pulumi.set(__self__, "max_cluster_node_count", max_cluster_node_count)
        pulumi.set(__self__, "min_cluster_node_count", min_cluster_node_count)

    @_builtins.property
    @pulumi.getter(name="autoscalingPolicies")
    def autoscaling_policies(self) -> Sequence['outputs.GetClusterAutoscalingSettingAutoscalingPolicyResult']:
        """
        The map with autoscaling policies applied to the cluster.
        The key is the identifier of the policy.
        It must meet the following requirements:
          * Only contains 1-63 alphanumeric characters and hyphens
          * Begins with an alphabetical character
          * Ends with a non-hyphen character
          * Not formatted as a UUID
          * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)

        Currently the map must contain only one element
        that describes the autoscaling policy for compute nodes.
        """
        return pulumi.get(self, "autoscaling_policies")

    @_builtins.property
    @pulumi.getter(name="coolDownPeriod")
    def cool_down_period(self) -> _builtins.str:
        """
        The minimum duration between consecutive autoscale operations.
        It starts once addition or removal of nodes is fully completed.
        Minimum cool down period is 30m.
        Cool down period must be in whole minutes (for example, 30m, 31m, 50m).
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        return pulumi.get(self, "cool_down_period")

    @_builtins.property
    @pulumi.getter(name="maxClusterNodeCount")
    def max_cluster_node_count(self) -> _builtins.int:
        """
        Maximum number of nodes of any type in a cluster.
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        return pulumi.get(self, "max_cluster_node_count")

    @_builtins.property
    @pulumi.getter(name="minClusterNodeCount")
    def min_cluster_node_count(self) -> _builtins.int:
        """
        Minimum number of nodes of any type in a cluster.
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        return pulumi.get(self, "min_cluster_node_count")


@pulumi.output_type
class GetClusterAutoscalingSettingAutoscalingPolicyResult(dict):
    def __init__(__self__, *,
                 autoscale_policy_id: _builtins.str,
                 consumed_memory_thresholds: Sequence['outputs.GetClusterAutoscalingSettingAutoscalingPolicyConsumedMemoryThresholdResult'],
                 cpu_thresholds: Sequence['outputs.GetClusterAutoscalingSettingAutoscalingPolicyCpuThresholdResult'],
                 node_type_id: _builtins.str,
                 scale_out_size: _builtins.int,
                 storage_thresholds: Sequence['outputs.GetClusterAutoscalingSettingAutoscalingPolicyStorageThresholdResult']):
        """
        :param Sequence['GetClusterAutoscalingSettingAutoscalingPolicyConsumedMemoryThresholdArgs'] consumed_memory_thresholds: Utilization thresholds pertaining to amount of consumed memory.
        :param Sequence['GetClusterAutoscalingSettingAutoscalingPolicyCpuThresholdArgs'] cpu_thresholds: Utilization thresholds pertaining to CPU utilization.
        :param _builtins.str node_type_id: The canonical identifier of the node type to add or remove.
        :param _builtins.int scale_out_size: Number of nodes to add to a cluster during a scale-out operation.
               Must be divisible by 2 for stretched clusters.
        :param Sequence['GetClusterAutoscalingSettingAutoscalingPolicyStorageThresholdArgs'] storage_thresholds: Utilization thresholds pertaining to amount of consumed storage.
        """
        pulumi.set(__self__, "autoscale_policy_id", autoscale_policy_id)
        pulumi.set(__self__, "consumed_memory_thresholds", consumed_memory_thresholds)
        pulumi.set(__self__, "cpu_thresholds", cpu_thresholds)
        pulumi.set(__self__, "node_type_id", node_type_id)
        pulumi.set(__self__, "scale_out_size", scale_out_size)
        pulumi.set(__self__, "storage_thresholds", storage_thresholds)

    @_builtins.property
    @pulumi.getter(name="autoscalePolicyId")
    def autoscale_policy_id(self) -> _builtins.str:
        return pulumi.get(self, "autoscale_policy_id")

    @_builtins.property
    @pulumi.getter(name="consumedMemoryThresholds")
    def consumed_memory_thresholds(self) -> Sequence['outputs.GetClusterAutoscalingSettingAutoscalingPolicyConsumedMemoryThresholdResult']:
        """
        Utilization thresholds pertaining to amount of consumed memory.
        """
        return pulumi.get(self, "consumed_memory_thresholds")

    @_builtins.property
    @pulumi.getter(name="cpuThresholds")
    def cpu_thresholds(self) -> Sequence['outputs.GetClusterAutoscalingSettingAutoscalingPolicyCpuThresholdResult']:
        """
        Utilization thresholds pertaining to CPU utilization.
        """
        return pulumi.get(self, "cpu_thresholds")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> _builtins.str:
        """
        The canonical identifier of the node type to add or remove.
        """
        return pulumi.get(self, "node_type_id")

    @_builtins.property
    @pulumi.getter(name="scaleOutSize")
    def scale_out_size(self) -> _builtins.int:
        """
        Number of nodes to add to a cluster during a scale-out operation.
        Must be divisible by 2 for stretched clusters.
        """
        return pulumi.get(self, "scale_out_size")

    @_builtins.property
    @pulumi.getter(name="storageThresholds")
    def storage_thresholds(self) -> Sequence['outputs.GetClusterAutoscalingSettingAutoscalingPolicyStorageThresholdResult']:
        """
        Utilization thresholds pertaining to amount of consumed storage.
        """
        return pulumi.get(self, "storage_thresholds")


@pulumi.output_type
class GetClusterAutoscalingSettingAutoscalingPolicyConsumedMemoryThresholdResult(dict):
    def __init__(__self__, *,
                 scale_in: _builtins.int,
                 scale_out: _builtins.int):
        """
        :param _builtins.int scale_in: The utilization triggering the scale-in operation in percent.
        :param _builtins.int scale_out: The utilization triggering the scale-out operation in percent.
        """
        pulumi.set(__self__, "scale_in", scale_in)
        pulumi.set(__self__, "scale_out", scale_out)

    @_builtins.property
    @pulumi.getter(name="scaleIn")
    def scale_in(self) -> _builtins.int:
        """
        The utilization triggering the scale-in operation in percent.
        """
        return pulumi.get(self, "scale_in")

    @_builtins.property
    @pulumi.getter(name="scaleOut")
    def scale_out(self) -> _builtins.int:
        """
        The utilization triggering the scale-out operation in percent.
        """
        return pulumi.get(self, "scale_out")


@pulumi.output_type
class GetClusterAutoscalingSettingAutoscalingPolicyCpuThresholdResult(dict):
    def __init__(__self__, *,
                 scale_in: _builtins.int,
                 scale_out: _builtins.int):
        """
        :param _builtins.int scale_in: The utilization triggering the scale-in operation in percent.
        :param _builtins.int scale_out: The utilization triggering the scale-out operation in percent.
        """
        pulumi.set(__self__, "scale_in", scale_in)
        pulumi.set(__self__, "scale_out", scale_out)

    @_builtins.property
    @pulumi.getter(name="scaleIn")
    def scale_in(self) -> _builtins.int:
        """
        The utilization triggering the scale-in operation in percent.
        """
        return pulumi.get(self, "scale_in")

    @_builtins.property
    @pulumi.getter(name="scaleOut")
    def scale_out(self) -> _builtins.int:
        """
        The utilization triggering the scale-out operation in percent.
        """
        return pulumi.get(self, "scale_out")


@pulumi.output_type
class GetClusterAutoscalingSettingAutoscalingPolicyStorageThresholdResult(dict):
    def __init__(__self__, *,
                 scale_in: _builtins.int,
                 scale_out: _builtins.int):
        """
        :param _builtins.int scale_in: The utilization triggering the scale-in operation in percent.
        :param _builtins.int scale_out: The utilization triggering the scale-out operation in percent.
        """
        pulumi.set(__self__, "scale_in", scale_in)
        pulumi.set(__self__, "scale_out", scale_out)

    @_builtins.property
    @pulumi.getter(name="scaleIn")
    def scale_in(self) -> _builtins.int:
        """
        The utilization triggering the scale-in operation in percent.
        """
        return pulumi.get(self, "scale_in")

    @_builtins.property
    @pulumi.getter(name="scaleOut")
    def scale_out(self) -> _builtins.int:
        """
        The utilization triggering the scale-out operation in percent.
        """
        return pulumi.get(self, "scale_out")


@pulumi.output_type
class GetClusterDatastoreMountConfigResult(dict):
    def __init__(__self__, *,
                 access_mode: _builtins.str,
                 datastore: _builtins.str,
                 datastore_networks: Sequence['outputs.GetClusterDatastoreMountConfigDatastoreNetworkResult'],
                 file_share: _builtins.str,
                 ignore_colocation: _builtins.bool,
                 nfs_version: _builtins.str,
                 servers: Sequence[_builtins.str]):
        """
        :param _builtins.str access_mode: Optional. NFS is accessed by hosts in either read or read_write mode
               Default value used will be READ_WRITE
               Possible values:
               READ_ONLY
               READ_WRITE
        :param _builtins.str datastore: The resource name of the datastore to unmount.
               The datastore requested to be mounted should be in same region/zone as the
               cluster.
               Resource names are schemeless URIs that follow the conventions in
               https://cloud.google.com/apis/design/resource_names.
               For example:
               'projects/my-project/locations/us-central1/datastores/my-datastore'
        :param Sequence['GetClusterDatastoreMountConfigDatastoreNetworkArgs'] datastore_networks: The network configuration for the datastore.
        :param _builtins.str file_share: File share name.
        :param _builtins.bool ignore_colocation: Optional. If set to true, the colocation requirement will be ignored.
               If set to false, the colocation requirement will be enforced.
               Colocation requirement is the requirement that the cluster must be in the
               same region/zone of datastore.
        :param _builtins.str nfs_version: Optional. The NFS protocol supported by the NFS volume.
               Default value used will be NFS_V3
               Possible values:
               NFS_V3
        :param Sequence[_builtins.str] servers: Server IP addresses of the NFS volume.
               For NFS 3, you can only provide a single
               server IP address or DNS names.
        """
        pulumi.set(__self__, "access_mode", access_mode)
        pulumi.set(__self__, "datastore", datastore)
        pulumi.set(__self__, "datastore_networks", datastore_networks)
        pulumi.set(__self__, "file_share", file_share)
        pulumi.set(__self__, "ignore_colocation", ignore_colocation)
        pulumi.set(__self__, "nfs_version", nfs_version)
        pulumi.set(__self__, "servers", servers)

    @_builtins.property
    @pulumi.getter(name="accessMode")
    def access_mode(self) -> _builtins.str:
        """
        Optional. NFS is accessed by hosts in either read or read_write mode
        Default value used will be READ_WRITE
        Possible values:
        READ_ONLY
        READ_WRITE
        """
        return pulumi.get(self, "access_mode")

    @_builtins.property
    @pulumi.getter
    def datastore(self) -> _builtins.str:
        """
        The resource name of the datastore to unmount.
        The datastore requested to be mounted should be in same region/zone as the
        cluster.
        Resource names are schemeless URIs that follow the conventions in
        https://cloud.google.com/apis/design/resource_names.
        For example:
        'projects/my-project/locations/us-central1/datastores/my-datastore'
        """
        return pulumi.get(self, "datastore")

    @_builtins.property
    @pulumi.getter(name="datastoreNetworks")
    def datastore_networks(self) -> Sequence['outputs.GetClusterDatastoreMountConfigDatastoreNetworkResult']:
        """
        The network configuration for the datastore.
        """
        return pulumi.get(self, "datastore_networks")

    @_builtins.property
    @pulumi.getter(name="fileShare")
    def file_share(self) -> _builtins.str:
        """
        File share name.
        """
        return pulumi.get(self, "file_share")

    @_builtins.property
    @pulumi.getter(name="ignoreColocation")
    def ignore_colocation(self) -> _builtins.bool:
        """
        Optional. If set to true, the colocation requirement will be ignored.
        If set to false, the colocation requirement will be enforced.
        Colocation requirement is the requirement that the cluster must be in the
        same region/zone of datastore.
        """
        return pulumi.get(self, "ignore_colocation")

    @_builtins.property
    @pulumi.getter(name="nfsVersion")
    def nfs_version(self) -> _builtins.str:
        """
        Optional. The NFS protocol supported by the NFS volume.
        Default value used will be NFS_V3
        Possible values:
        NFS_V3
        """
        return pulumi.get(self, "nfs_version")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Sequence[_builtins.str]:
        """
        Server IP addresses of the NFS volume.
        For NFS 3, you can only provide a single
        server IP address or DNS names.
        """
        return pulumi.get(self, "servers")


@pulumi.output_type
class GetClusterDatastoreMountConfigDatastoreNetworkResult(dict):
    def __init__(__self__, *,
                 connection_count: _builtins.int,
                 mtu: _builtins.int,
                 network_peering: _builtins.str,
                 subnet: _builtins.str):
        """
        :param _builtins.int connection_count: Optional. The number of connections of the NFS volume.
               Supported from vsphere 8.0u1. Possible values are 1-4.
               Default value is 4.
        :param _builtins.int mtu: Optional. The Maximal Transmission Unit (MTU) of the datastore.
               MTU value can range from 1330-9000. If not set, system sets
               default MTU size to 1500.
        :param _builtins.str network_peering: The resource name of the network peering, used to access the
               file share by clients on private cloud. Resource names are schemeless
               URIs that follow the conventions in
               https://cloud.google.com/apis/design/resource_names.
               e.g.
               projects/my-project/locations/us-central1/networkPeerings/my-network-peering
        :param _builtins.str subnet: The resource name of the subnet
               Resource names are schemeless URIs that follow the conventions in
               https://cloud.google.com/apis/design/resource_names.
               e.g. projects/my-project/locations/us-central1/subnets/my-subnet
        """
        pulumi.set(__self__, "connection_count", connection_count)
        pulumi.set(__self__, "mtu", mtu)
        pulumi.set(__self__, "network_peering", network_peering)
        pulumi.set(__self__, "subnet", subnet)

    @_builtins.property
    @pulumi.getter(name="connectionCount")
    def connection_count(self) -> _builtins.int:
        """
        Optional. The number of connections of the NFS volume.
        Supported from vsphere 8.0u1. Possible values are 1-4.
        Default value is 4.
        """
        return pulumi.get(self, "connection_count")

    @_builtins.property
    @pulumi.getter
    def mtu(self) -> _builtins.int:
        """
        Optional. The Maximal Transmission Unit (MTU) of the datastore.
        MTU value can range from 1330-9000. If not set, system sets
        default MTU size to 1500.
        """
        return pulumi.get(self, "mtu")

    @_builtins.property
    @pulumi.getter(name="networkPeering")
    def network_peering(self) -> _builtins.str:
        """
        The resource name of the network peering, used to access the
        file share by clients on private cloud. Resource names are schemeless
        URIs that follow the conventions in
        https://cloud.google.com/apis/design/resource_names.
        e.g.
        projects/my-project/locations/us-central1/networkPeerings/my-network-peering
        """
        return pulumi.get(self, "network_peering")

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        """
        The resource name of the subnet
        Resource names are schemeless URIs that follow the conventions in
        https://cloud.google.com/apis/design/resource_names.
        e.g. projects/my-project/locations/us-central1/subnets/my-subnet
        """
        return pulumi.get(self, "subnet")


@pulumi.output_type
class GetClusterNodeTypeConfigResult(dict):
    def __init__(__self__, *,
                 custom_core_count: _builtins.int,
                 node_count: _builtins.int,
                 node_type_id: _builtins.str):
        """
        :param _builtins.int custom_core_count: Customized number of cores available to each node of the type.
               This number must always be one of 'nodeType.availableCustomCoreCounts'.
               If zero is provided max value from 'nodeType.availableCustomCoreCounts' will be used.
               Once the customer is created then corecount cannot be changed.
        :param _builtins.int node_count: The number of nodes of this type in the cluster.
        """
        pulumi.set(__self__, "custom_core_count", custom_core_count)
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "node_type_id", node_type_id)

    @_builtins.property
    @pulumi.getter(name="customCoreCount")
    def custom_core_count(self) -> _builtins.int:
        """
        Customized number of cores available to each node of the type.
        This number must always be one of 'nodeType.availableCustomCoreCounts'.
        If zero is provided max value from 'nodeType.availableCustomCoreCounts' will be used.
        Once the customer is created then corecount cannot be changed.
        """
        return pulumi.get(self, "custom_core_count")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        The number of nodes of this type in the cluster.
        """
        return pulumi.get(self, "node_count")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> _builtins.str:
        return pulumi.get(self, "node_type_id")


@pulumi.output_type
class GetDatastoreNfsDatastoreResult(dict):
    def __init__(__self__, *,
                 google_file_services: Sequence['outputs.GetDatastoreNfsDatastoreGoogleFileServiceResult'],
                 third_party_file_services: Sequence['outputs.GetDatastoreNfsDatastoreThirdPartyFileServiceResult']):
        """
        :param Sequence['GetDatastoreNfsDatastoreGoogleFileServiceArgs'] google_file_services: Google service file service configuration
        :param Sequence['GetDatastoreNfsDatastoreThirdPartyFileServiceArgs'] third_party_file_services: Third party file service configuration
        """
        pulumi.set(__self__, "google_file_services", google_file_services)
        pulumi.set(__self__, "third_party_file_services", third_party_file_services)

    @_builtins.property
    @pulumi.getter(name="googleFileServices")
    def google_file_services(self) -> Sequence['outputs.GetDatastoreNfsDatastoreGoogleFileServiceResult']:
        """
        Google service file service configuration
        """
        return pulumi.get(self, "google_file_services")

    @_builtins.property
    @pulumi.getter(name="thirdPartyFileServices")
    def third_party_file_services(self) -> Sequence['outputs.GetDatastoreNfsDatastoreThirdPartyFileServiceResult']:
        """
        Third party file service configuration
        """
        return pulumi.get(self, "third_party_file_services")


@pulumi.output_type
class GetDatastoreNfsDatastoreGoogleFileServiceResult(dict):
    def __init__(__self__, *,
                 filestore_instance: _builtins.str,
                 netapp_volume: _builtins.str):
        """
        :param _builtins.str filestore_instance: Google filestore instance resource name
               e.g. projects/my-project/locations/me-west1-b/instances/my-instance
        :param _builtins.str netapp_volume: Google netapp volume resource name
               e.g. projects/my-project/locations/me-west1-b/volumes/my-volume
        """
        pulumi.set(__self__, "filestore_instance", filestore_instance)
        pulumi.set(__self__, "netapp_volume", netapp_volume)

    @_builtins.property
    @pulumi.getter(name="filestoreInstance")
    def filestore_instance(self) -> _builtins.str:
        """
        Google filestore instance resource name
        e.g. projects/my-project/locations/me-west1-b/instances/my-instance
        """
        return pulumi.get(self, "filestore_instance")

    @_builtins.property
    @pulumi.getter(name="netappVolume")
    def netapp_volume(self) -> _builtins.str:
        """
        Google netapp volume resource name
        e.g. projects/my-project/locations/me-west1-b/volumes/my-volume
        """
        return pulumi.get(self, "netapp_volume")


@pulumi.output_type
class GetDatastoreNfsDatastoreThirdPartyFileServiceResult(dict):
    def __init__(__self__, *,
                 file_share: _builtins.str,
                 network: _builtins.str,
                 servers: Sequence[_builtins.str]):
        """
        :param _builtins.str file_share: Required
               Mount Folder name
        :param _builtins.str network: Required to identify vpc peering used for NFS access
               network name of NFS's vpc
               e.g. projects/project-id/global/networks/my-network_id
        :param Sequence[_builtins.str] servers: Server IP addresses of the NFS file service.
               NFS v3, provide a single IP address or DNS name.
               Multiple servers can be supported in future when NFS 4.1 protocol support
               is enabled.
        """
        pulumi.set(__self__, "file_share", file_share)
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "servers", servers)

    @_builtins.property
    @pulumi.getter(name="fileShare")
    def file_share(self) -> _builtins.str:
        """
        Required
        Mount Folder name
        """
        return pulumi.get(self, "file_share")

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        Required to identify vpc peering used for NFS access
        network name of NFS's vpc
        e.g. projects/project-id/global/networks/my-network_id
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def servers(self) -> Sequence[_builtins.str]:
        """
        Server IP addresses of the NFS file service.
        NFS v3, provide a single IP address or DNS name.
        Multiple servers can be supported in future when NFS 4.1 protocol support
        is enabled.
        """
        return pulumi.get(self, "servers")


@pulumi.output_type
class GetExternalAccessRuleDestinationIpRangeResult(dict):
    def __init__(__self__, *,
                 external_address: _builtins.str,
                 ip_address_range: _builtins.str):
        """
        :param _builtins.str external_address: The name of an 'ExternalAddress' resource.
        :param _builtins.str ip_address_range: An IP address range in the CIDR format.
        """
        pulumi.set(__self__, "external_address", external_address)
        pulumi.set(__self__, "ip_address_range", ip_address_range)

    @_builtins.property
    @pulumi.getter(name="externalAddress")
    def external_address(self) -> _builtins.str:
        """
        The name of an 'ExternalAddress' resource.
        """
        return pulumi.get(self, "external_address")

    @_builtins.property
    @pulumi.getter(name="ipAddressRange")
    def ip_address_range(self) -> _builtins.str:
        """
        An IP address range in the CIDR format.
        """
        return pulumi.get(self, "ip_address_range")


@pulumi.output_type
class GetExternalAccessRuleSourceIpRangeResult(dict):
    def __init__(__self__, *,
                 ip_address: _builtins.str,
                 ip_address_range: _builtins.str):
        """
        :param _builtins.str ip_address: A single IP address.
        :param _builtins.str ip_address_range: An IP address range in the CIDR format.
        """
        pulumi.set(__self__, "ip_address", ip_address)
        pulumi.set(__self__, "ip_address_range", ip_address_range)

    @_builtins.property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> _builtins.str:
        """
        A single IP address.
        """
        return pulumi.get(self, "ip_address")

    @_builtins.property
    @pulumi.getter(name="ipAddressRange")
    def ip_address_range(self) -> _builtins.str:
        """
        An IP address range in the CIDR format.
        """
        return pulumi.get(self, "ip_address_range")


@pulumi.output_type
class GetNetworkPolicyExternalIpResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 state: _builtins.str):
        """
        :param _builtins.bool enabled: True if the service is enabled; false otherwise.
        :param _builtins.str state: State of the service. New values may be added to this enum when appropriate.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        True if the service is enabled; false otherwise.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        State of the service. New values may be added to this enum when appropriate.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetNetworkPolicyInternetAccessResult(dict):
    def __init__(__self__, *,
                 enabled: _builtins.bool,
                 state: _builtins.str):
        """
        :param _builtins.bool enabled: True if the service is enabled; false otherwise.
        :param _builtins.str state: State of the service. New values may be added to this enum when appropriate.
        """
        pulumi.set(__self__, "enabled", enabled)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> _builtins.bool:
        """
        True if the service is enabled; false otherwise.
        """
        return pulumi.get(self, "enabled")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        State of the service. New values may be added to this enum when appropriate.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetNetworkVpcNetworkResult(dict):
    def __init__(__self__, *,
                 network: _builtins.str,
                 type: _builtins.str):
        """
        :param _builtins.str network: The relative resource name of the service VPC network this VMware Engine network is attached to.
               For example: projects/123123/global/networks/my-network
        :param _builtins.str type: Type of VPC network (INTRANET, INTERNET, or GOOGLE_CLOUD)
        """
        pulumi.set(__self__, "network", network)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter
    def network(self) -> _builtins.str:
        """
        The relative resource name of the service VPC network this VMware Engine network is attached to.
        For example: projects/123123/global/networks/my-network
        """
        return pulumi.get(self, "network")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        Type of VPC network (INTRANET, INTERNET, or GOOGLE_CLOUD)
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetPrivateCloudHcxResult(dict):
    def __init__(__self__, *,
                 fqdn: _builtins.str,
                 internal_ip: _builtins.str,
                 state: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str fqdn: Fully qualified domain name of the appliance.
        :param _builtins.str internal_ip: Internal IP address of the appliance.
        :param _builtins.str state: State of the appliance. Possible values: ["ACTIVE", "CREATING"]
        :param _builtins.str version: Version of the appliance.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        Fully qualified domain name of the appliance.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> _builtins.str:
        """
        Internal IP address of the appliance.
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        State of the appliance. Possible values: ["ACTIVE", "CREATING"]
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of the appliance.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetPrivateCloudManagementClusterResult(dict):
    def __init__(__self__, *,
                 autoscaling_settings: Sequence['outputs.GetPrivateCloudManagementClusterAutoscalingSettingResult'],
                 cluster_id: _builtins.str,
                 node_type_configs: Sequence['outputs.GetPrivateCloudManagementClusterNodeTypeConfigResult'],
                 stretched_cluster_configs: Sequence['outputs.GetPrivateCloudManagementClusterStretchedClusterConfigResult']):
        """
        :param Sequence['GetPrivateCloudManagementClusterAutoscalingSettingArgs'] autoscaling_settings: Configuration of the autoscaling applied to this cluster
               Private cloud must have a minimum of 3 nodes to add autoscale settings
        :param _builtins.str cluster_id: The user-provided identifier of the new Cluster. The identifier must meet the following requirements:
                 * Only contains 1-63 alphanumeric characters and hyphens
                 * Begins with an alphabetical character
                 * Ends with a non-hyphen character
                 * Not formatted as a UUID
                 * Complies with RFC 1034 (https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
        :param Sequence['GetPrivateCloudManagementClusterNodeTypeConfigArgs'] node_type_configs: The map of cluster node types in this cluster,
               where the key is canonical identifier of the node type (corresponds to the NodeType).
        :param Sequence['GetPrivateCloudManagementClusterStretchedClusterConfigArgs'] stretched_cluster_configs: The stretched cluster configuration for the private cloud.
        """
        pulumi.set(__self__, "autoscaling_settings", autoscaling_settings)
        pulumi.set(__self__, "cluster_id", cluster_id)
        pulumi.set(__self__, "node_type_configs", node_type_configs)
        pulumi.set(__self__, "stretched_cluster_configs", stretched_cluster_configs)

    @_builtins.property
    @pulumi.getter(name="autoscalingSettings")
    def autoscaling_settings(self) -> Sequence['outputs.GetPrivateCloudManagementClusterAutoscalingSettingResult']:
        """
        Configuration of the autoscaling applied to this cluster
        Private cloud must have a minimum of 3 nodes to add autoscale settings
        """
        return pulumi.get(self, "autoscaling_settings")

    @_builtins.property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> _builtins.str:
        """
        The user-provided identifier of the new Cluster. The identifier must meet the following requirements:
          * Only contains 1-63 alphanumeric characters and hyphens
          * Begins with an alphabetical character
          * Ends with a non-hyphen character
          * Not formatted as a UUID
          * Complies with RFC 1034 (https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
        """
        return pulumi.get(self, "cluster_id")

    @_builtins.property
    @pulumi.getter(name="nodeTypeConfigs")
    def node_type_configs(self) -> Sequence['outputs.GetPrivateCloudManagementClusterNodeTypeConfigResult']:
        """
        The map of cluster node types in this cluster,
        where the key is canonical identifier of the node type (corresponds to the NodeType).
        """
        return pulumi.get(self, "node_type_configs")

    @_builtins.property
    @pulumi.getter(name="stretchedClusterConfigs")
    def stretched_cluster_configs(self) -> Sequence['outputs.GetPrivateCloudManagementClusterStretchedClusterConfigResult']:
        """
        The stretched cluster configuration for the private cloud.
        """
        return pulumi.get(self, "stretched_cluster_configs")


@pulumi.output_type
class GetPrivateCloudManagementClusterAutoscalingSettingResult(dict):
    def __init__(__self__, *,
                 autoscaling_policies: Sequence['outputs.GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyResult'],
                 cool_down_period: _builtins.str,
                 max_cluster_node_count: _builtins.int,
                 min_cluster_node_count: _builtins.int):
        """
        :param Sequence['GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyArgs'] autoscaling_policies: The map with autoscaling policies applied to the cluster.
               The key is the identifier of the policy.
               It must meet the following requirements:
                * Only contains 1-63 alphanumeric characters and hyphens
                * Begins with an alphabetical character
                * Ends with a non-hyphen character
                * Not formatted as a UUID
                * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
               
               Currently the map must contain only one element
               that describes the autoscaling policy for compute nodes.
        :param _builtins.str cool_down_period: The minimum duration between consecutive autoscale operations.
               It starts once addition or removal of nodes is fully completed.
               Minimum cool down period is 30m.
               Cool down period must be in whole minutes (for example, 30m, 31m, 50m).
               Mandatory for successful addition of autoscaling settings in cluster.
        :param _builtins.int max_cluster_node_count: Maximum number of nodes of any type in a cluster.
               Mandatory for successful addition of autoscaling settings in cluster.
        :param _builtins.int min_cluster_node_count: Minimum number of nodes of any type in a cluster.
               Mandatory for successful addition of autoscaling settings in cluster.
        """
        pulumi.set(__self__, "autoscaling_policies", autoscaling_policies)
        pulumi.set(__self__, "cool_down_period", cool_down_period)
        pulumi.set(__self__, "max_cluster_node_count", max_cluster_node_count)
        pulumi.set(__self__, "min_cluster_node_count", min_cluster_node_count)

    @_builtins.property
    @pulumi.getter(name="autoscalingPolicies")
    def autoscaling_policies(self) -> Sequence['outputs.GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyResult']:
        """
        The map with autoscaling policies applied to the cluster.
        The key is the identifier of the policy.
        It must meet the following requirements:
         * Only contains 1-63 alphanumeric characters and hyphens
         * Begins with an alphabetical character
         * Ends with a non-hyphen character
         * Not formatted as a UUID
         * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)

        Currently the map must contain only one element
        that describes the autoscaling policy for compute nodes.
        """
        return pulumi.get(self, "autoscaling_policies")

    @_builtins.property
    @pulumi.getter(name="coolDownPeriod")
    def cool_down_period(self) -> _builtins.str:
        """
        The minimum duration between consecutive autoscale operations.
        It starts once addition or removal of nodes is fully completed.
        Minimum cool down period is 30m.
        Cool down period must be in whole minutes (for example, 30m, 31m, 50m).
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        return pulumi.get(self, "cool_down_period")

    @_builtins.property
    @pulumi.getter(name="maxClusterNodeCount")
    def max_cluster_node_count(self) -> _builtins.int:
        """
        Maximum number of nodes of any type in a cluster.
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        return pulumi.get(self, "max_cluster_node_count")

    @_builtins.property
    @pulumi.getter(name="minClusterNodeCount")
    def min_cluster_node_count(self) -> _builtins.int:
        """
        Minimum number of nodes of any type in a cluster.
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        return pulumi.get(self, "min_cluster_node_count")


@pulumi.output_type
class GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyResult(dict):
    def __init__(__self__, *,
                 autoscale_policy_id: _builtins.str,
                 consumed_memory_thresholds: Sequence['outputs.GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyConsumedMemoryThresholdResult'],
                 cpu_thresholds: Sequence['outputs.GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyCpuThresholdResult'],
                 node_type_id: _builtins.str,
                 scale_out_size: _builtins.int,
                 storage_thresholds: Sequence['outputs.GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyStorageThresholdResult']):
        """
        :param Sequence['GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyConsumedMemoryThresholdArgs'] consumed_memory_thresholds: Utilization thresholds pertaining to amount of consumed memory.
        :param Sequence['GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyCpuThresholdArgs'] cpu_thresholds: Utilization thresholds pertaining to CPU utilization.
        :param _builtins.str node_type_id: The canonical identifier of the node type to add or remove.
        :param _builtins.int scale_out_size: Number of nodes to add to a cluster during a scale-out operation.
               Must be divisible by 2 for stretched clusters.
        :param Sequence['GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyStorageThresholdArgs'] storage_thresholds: Utilization thresholds pertaining to amount of consumed storage.
        """
        pulumi.set(__self__, "autoscale_policy_id", autoscale_policy_id)
        pulumi.set(__self__, "consumed_memory_thresholds", consumed_memory_thresholds)
        pulumi.set(__self__, "cpu_thresholds", cpu_thresholds)
        pulumi.set(__self__, "node_type_id", node_type_id)
        pulumi.set(__self__, "scale_out_size", scale_out_size)
        pulumi.set(__self__, "storage_thresholds", storage_thresholds)

    @_builtins.property
    @pulumi.getter(name="autoscalePolicyId")
    def autoscale_policy_id(self) -> _builtins.str:
        return pulumi.get(self, "autoscale_policy_id")

    @_builtins.property
    @pulumi.getter(name="consumedMemoryThresholds")
    def consumed_memory_thresholds(self) -> Sequence['outputs.GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyConsumedMemoryThresholdResult']:
        """
        Utilization thresholds pertaining to amount of consumed memory.
        """
        return pulumi.get(self, "consumed_memory_thresholds")

    @_builtins.property
    @pulumi.getter(name="cpuThresholds")
    def cpu_thresholds(self) -> Sequence['outputs.GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyCpuThresholdResult']:
        """
        Utilization thresholds pertaining to CPU utilization.
        """
        return pulumi.get(self, "cpu_thresholds")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> _builtins.str:
        """
        The canonical identifier of the node type to add or remove.
        """
        return pulumi.get(self, "node_type_id")

    @_builtins.property
    @pulumi.getter(name="scaleOutSize")
    def scale_out_size(self) -> _builtins.int:
        """
        Number of nodes to add to a cluster during a scale-out operation.
        Must be divisible by 2 for stretched clusters.
        """
        return pulumi.get(self, "scale_out_size")

    @_builtins.property
    @pulumi.getter(name="storageThresholds")
    def storage_thresholds(self) -> Sequence['outputs.GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyStorageThresholdResult']:
        """
        Utilization thresholds pertaining to amount of consumed storage.
        """
        return pulumi.get(self, "storage_thresholds")


@pulumi.output_type
class GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyConsumedMemoryThresholdResult(dict):
    def __init__(__self__, *,
                 scale_in: _builtins.int,
                 scale_out: _builtins.int):
        """
        :param _builtins.int scale_in: The utilization triggering the scale-in operation in percent.
        :param _builtins.int scale_out: The utilization triggering the scale-out operation in percent.
        """
        pulumi.set(__self__, "scale_in", scale_in)
        pulumi.set(__self__, "scale_out", scale_out)

    @_builtins.property
    @pulumi.getter(name="scaleIn")
    def scale_in(self) -> _builtins.int:
        """
        The utilization triggering the scale-in operation in percent.
        """
        return pulumi.get(self, "scale_in")

    @_builtins.property
    @pulumi.getter(name="scaleOut")
    def scale_out(self) -> _builtins.int:
        """
        The utilization triggering the scale-out operation in percent.
        """
        return pulumi.get(self, "scale_out")


@pulumi.output_type
class GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyCpuThresholdResult(dict):
    def __init__(__self__, *,
                 scale_in: _builtins.int,
                 scale_out: _builtins.int):
        """
        :param _builtins.int scale_in: The utilization triggering the scale-in operation in percent.
        :param _builtins.int scale_out: The utilization triggering the scale-out operation in percent.
        """
        pulumi.set(__self__, "scale_in", scale_in)
        pulumi.set(__self__, "scale_out", scale_out)

    @_builtins.property
    @pulumi.getter(name="scaleIn")
    def scale_in(self) -> _builtins.int:
        """
        The utilization triggering the scale-in operation in percent.
        """
        return pulumi.get(self, "scale_in")

    @_builtins.property
    @pulumi.getter(name="scaleOut")
    def scale_out(self) -> _builtins.int:
        """
        The utilization triggering the scale-out operation in percent.
        """
        return pulumi.get(self, "scale_out")


@pulumi.output_type
class GetPrivateCloudManagementClusterAutoscalingSettingAutoscalingPolicyStorageThresholdResult(dict):
    def __init__(__self__, *,
                 scale_in: _builtins.int,
                 scale_out: _builtins.int):
        """
        :param _builtins.int scale_in: The utilization triggering the scale-in operation in percent.
        :param _builtins.int scale_out: The utilization triggering the scale-out operation in percent.
        """
        pulumi.set(__self__, "scale_in", scale_in)
        pulumi.set(__self__, "scale_out", scale_out)

    @_builtins.property
    @pulumi.getter(name="scaleIn")
    def scale_in(self) -> _builtins.int:
        """
        The utilization triggering the scale-in operation in percent.
        """
        return pulumi.get(self, "scale_in")

    @_builtins.property
    @pulumi.getter(name="scaleOut")
    def scale_out(self) -> _builtins.int:
        """
        The utilization triggering the scale-out operation in percent.
        """
        return pulumi.get(self, "scale_out")


@pulumi.output_type
class GetPrivateCloudManagementClusterNodeTypeConfigResult(dict):
    def __init__(__self__, *,
                 custom_core_count: _builtins.int,
                 node_count: _builtins.int,
                 node_type_id: _builtins.str):
        """
        :param _builtins.int custom_core_count: Customized number of cores available to each node of the type.
               This number must always be one of 'nodeType.availableCustomCoreCounts'.
               If zero is provided max value from 'nodeType.availableCustomCoreCounts' will be used.
               This cannot be changed once the PrivateCloud is created.
        :param _builtins.int node_count: The number of nodes of this type in the cluster.
        """
        pulumi.set(__self__, "custom_core_count", custom_core_count)
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "node_type_id", node_type_id)

    @_builtins.property
    @pulumi.getter(name="customCoreCount")
    def custom_core_count(self) -> _builtins.int:
        """
        Customized number of cores available to each node of the type.
        This number must always be one of 'nodeType.availableCustomCoreCounts'.
        If zero is provided max value from 'nodeType.availableCustomCoreCounts' will be used.
        This cannot be changed once the PrivateCloud is created.
        """
        return pulumi.get(self, "custom_core_count")

    @_builtins.property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> _builtins.int:
        """
        The number of nodes of this type in the cluster.
        """
        return pulumi.get(self, "node_count")

    @_builtins.property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> _builtins.str:
        return pulumi.get(self, "node_type_id")


@pulumi.output_type
class GetPrivateCloudManagementClusterStretchedClusterConfigResult(dict):
    def __init__(__self__, *,
                 preferred_location: _builtins.str,
                 secondary_location: _builtins.str):
        """
        :param _builtins.str preferred_location: Zone that will remain operational when connection between the two zones is lost.
               Specify the zone in the following format: projects/{project}/locations/{location}.
        :param _builtins.str secondary_location: Additional zone for a higher level of availability and load balancing.
               Specify the zone in the following format: projects/{project}/locations/{location}.
        """
        pulumi.set(__self__, "preferred_location", preferred_location)
        pulumi.set(__self__, "secondary_location", secondary_location)

    @_builtins.property
    @pulumi.getter(name="preferredLocation")
    def preferred_location(self) -> _builtins.str:
        """
        Zone that will remain operational when connection between the two zones is lost.
        Specify the zone in the following format: projects/{project}/locations/{location}.
        """
        return pulumi.get(self, "preferred_location")

    @_builtins.property
    @pulumi.getter(name="secondaryLocation")
    def secondary_location(self) -> _builtins.str:
        """
        Additional zone for a higher level of availability and load balancing.
        Specify the zone in the following format: projects/{project}/locations/{location}.
        """
        return pulumi.get(self, "secondary_location")


@pulumi.output_type
class GetPrivateCloudNetworkConfigResult(dict):
    def __init__(__self__, *,
                 dns_server_ip: _builtins.str,
                 management_cidr: _builtins.str,
                 management_ip_address_layout_version: _builtins.int,
                 vmware_engine_network: _builtins.str,
                 vmware_engine_network_canonical: _builtins.str):
        """
        :param _builtins.str dns_server_ip: DNS Server IP of the Private Cloud.
        :param _builtins.str management_cidr: Management CIDR used by VMware management appliances.
        :param _builtins.int management_ip_address_layout_version: The IP address layout version of the management IP address range.
               Possible versions include:
               * managementIpAddressLayoutVersion=1: Indicates the legacy IP address layout used by some existing private clouds. This is no longer supported for new private clouds
               as it does not support all features.
               * managementIpAddressLayoutVersion=2: Indicates the latest IP address layout
               used by all newly created private clouds. This version supports all current features.
        :param _builtins.str vmware_engine_network: The relative resource name of the VMware Engine network attached to the private cloud.
               Specify the name in the following form: projects/{project}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}
               where {project} can either be a project number or a project ID.
        :param _builtins.str vmware_engine_network_canonical: The canonical name of the VMware Engine network in
               the form: projects/{project_number}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}
        """
        pulumi.set(__self__, "dns_server_ip", dns_server_ip)
        pulumi.set(__self__, "management_cidr", management_cidr)
        pulumi.set(__self__, "management_ip_address_layout_version", management_ip_address_layout_version)
        pulumi.set(__self__, "vmware_engine_network", vmware_engine_network)
        pulumi.set(__self__, "vmware_engine_network_canonical", vmware_engine_network_canonical)

    @_builtins.property
    @pulumi.getter(name="dnsServerIp")
    def dns_server_ip(self) -> _builtins.str:
        """
        DNS Server IP of the Private Cloud.
        """
        return pulumi.get(self, "dns_server_ip")

    @_builtins.property
    @pulumi.getter(name="managementCidr")
    def management_cidr(self) -> _builtins.str:
        """
        Management CIDR used by VMware management appliances.
        """
        return pulumi.get(self, "management_cidr")

    @_builtins.property
    @pulumi.getter(name="managementIpAddressLayoutVersion")
    def management_ip_address_layout_version(self) -> _builtins.int:
        """
        The IP address layout version of the management IP address range.
        Possible versions include:
        * managementIpAddressLayoutVersion=1: Indicates the legacy IP address layout used by some existing private clouds. This is no longer supported for new private clouds
        as it does not support all features.
        * managementIpAddressLayoutVersion=2: Indicates the latest IP address layout
        used by all newly created private clouds. This version supports all current features.
        """
        return pulumi.get(self, "management_ip_address_layout_version")

    @_builtins.property
    @pulumi.getter(name="vmwareEngineNetwork")
    def vmware_engine_network(self) -> _builtins.str:
        """
        The relative resource name of the VMware Engine network attached to the private cloud.
        Specify the name in the following form: projects/{project}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}
        where {project} can either be a project number or a project ID.
        """
        return pulumi.get(self, "vmware_engine_network")

    @_builtins.property
    @pulumi.getter(name="vmwareEngineNetworkCanonical")
    def vmware_engine_network_canonical(self) -> _builtins.str:
        """
        The canonical name of the VMware Engine network in
        the form: projects/{project_number}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}
        """
        return pulumi.get(self, "vmware_engine_network_canonical")


@pulumi.output_type
class GetPrivateCloudNsxResult(dict):
    def __init__(__self__, *,
                 fqdn: _builtins.str,
                 internal_ip: _builtins.str,
                 state: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str fqdn: Fully qualified domain name of the appliance.
        :param _builtins.str internal_ip: Internal IP address of the appliance.
        :param _builtins.str state: State of the appliance. Possible values: ["ACTIVE", "CREATING"]
        :param _builtins.str version: Version of the appliance.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        Fully qualified domain name of the appliance.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> _builtins.str:
        """
        Internal IP address of the appliance.
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        State of the appliance. Possible values: ["ACTIVE", "CREATING"]
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of the appliance.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetPrivateCloudVcenterResult(dict):
    def __init__(__self__, *,
                 fqdn: _builtins.str,
                 internal_ip: _builtins.str,
                 state: _builtins.str,
                 version: _builtins.str):
        """
        :param _builtins.str fqdn: Fully qualified domain name of the appliance.
        :param _builtins.str internal_ip: Internal IP address of the appliance.
        :param _builtins.str state: State of the appliance. Possible values: ["ACTIVE", "CREATING"]
        :param _builtins.str version: Version of the appliance.
        """
        pulumi.set(__self__, "fqdn", fqdn)
        pulumi.set(__self__, "internal_ip", internal_ip)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def fqdn(self) -> _builtins.str:
        """
        Fully qualified domain name of the appliance.
        """
        return pulumi.get(self, "fqdn")

    @_builtins.property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> _builtins.str:
        """
        Internal IP address of the appliance.
        """
        return pulumi.get(self, "internal_ip")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        State of the appliance. Possible values: ["ACTIVE", "CREATING"]
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter
    def version(self) -> _builtins.str:
        """
        Version of the appliance.
        """
        return pulumi.get(self, "version")


@pulumi.output_type
class GetSubnetDhcpAddressRangeResult(dict):
    def __init__(__self__, *,
                 first_address: _builtins.str,
                 last_address: _builtins.str):
        """
        :param _builtins.str first_address: The first IP address of the range.
        :param _builtins.str last_address: The last IP address of the range.
        """
        pulumi.set(__self__, "first_address", first_address)
        pulumi.set(__self__, "last_address", last_address)

    @_builtins.property
    @pulumi.getter(name="firstAddress")
    def first_address(self) -> _builtins.str:
        """
        The first IP address of the range.
        """
        return pulumi.get(self, "first_address")

    @_builtins.property
    @pulumi.getter(name="lastAddress")
    def last_address(self) -> _builtins.str:
        """
        The last IP address of the range.
        """
        return pulumi.get(self, "last_address")


@pulumi.output_type
class GetUpgradesUpgradeResult(dict):
    def __init__(__self__, *,
                 component_upgrades: Sequence['outputs.GetUpgradesUpgradeComponentUpgradeResult'],
                 description: _builtins.str,
                 end_time: _builtins.str,
                 estimated_duration: _builtins.str,
                 name: _builtins.str,
                 schedules: Sequence['outputs.GetUpgradesUpgradeScheduleResult'],
                 start_version: _builtins.str,
                 state: _builtins.str,
                 target_version: _builtins.str,
                 type: _builtins.str):
        """
        :param Sequence['GetUpgradesUpgradeComponentUpgradeArgs'] component_upgrades: The list of component upgrades.
        :param _builtins.str description: Additional information about the private cloud upgrade.
        :param _builtins.str end_time: End of the edit window (RFC3339).
        :param _builtins.str estimated_duration: The estimated total duration of the upgrade in seconds. This information can be used to plan or schedule upgrades to minimize disruptions. Please note that the estimated duration is only an estimate. The actual upgrade duration may vary. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
        :param _builtins.str name: The resource name of the specific Upgrade to retrieve. If provided, the 'upgrades' list will contain only this upgrade.
        :param Sequence['GetUpgradesUpgradeScheduleArgs'] schedules: Schedule details for the upgrade.
        :param _builtins.str start_version: The start version of the private cloud for this upgrade.
        :param _builtins.str state: Component's upgrade state.
        :param _builtins.str target_version: The targeted version of the private cloud at the end of the upgrade.
        :param _builtins.str type: The type of upgrade. Possible values include: `VSPHERE_UPGRADE`, `VSPHERE_PATCH`, `WORKAROUND`, `FIRMWARE_UPGRADE`, `SWITCH_UPGRADE`, `OTHER`, `INFRASTRUCTURE_UPGRADE`.
        """
        pulumi.set(__self__, "component_upgrades", component_upgrades)
        pulumi.set(__self__, "description", description)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "estimated_duration", estimated_duration)
        pulumi.set(__self__, "name", name)
        pulumi.set(__self__, "schedules", schedules)
        pulumi.set(__self__, "start_version", start_version)
        pulumi.set(__self__, "state", state)
        pulumi.set(__self__, "target_version", target_version)
        pulumi.set(__self__, "type", type)

    @_builtins.property
    @pulumi.getter(name="componentUpgrades")
    def component_upgrades(self) -> Sequence['outputs.GetUpgradesUpgradeComponentUpgradeResult']:
        """
        The list of component upgrades.
        """
        return pulumi.get(self, "component_upgrades")

    @_builtins.property
    @pulumi.getter
    def description(self) -> _builtins.str:
        """
        Additional information about the private cloud upgrade.
        """
        return pulumi.get(self, "description")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        End of the edit window (RFC3339).
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="estimatedDuration")
    def estimated_duration(self) -> _builtins.str:
        """
        The estimated total duration of the upgrade in seconds. This information can be used to plan or schedule upgrades to minimize disruptions. Please note that the estimated duration is only an estimate. The actual upgrade duration may vary. A duration in seconds with up to nine fractional digits, ending with 's'. Example: "3.5s".
        """
        return pulumi.get(self, "estimated_duration")

    @_builtins.property
    @pulumi.getter
    def name(self) -> _builtins.str:
        """
        The resource name of the specific Upgrade to retrieve. If provided, the 'upgrades' list will contain only this upgrade.
        """
        return pulumi.get(self, "name")

    @_builtins.property
    @pulumi.getter
    def schedules(self) -> Sequence['outputs.GetUpgradesUpgradeScheduleResult']:
        """
        Schedule details for the upgrade.
        """
        return pulumi.get(self, "schedules")

    @_builtins.property
    @pulumi.getter(name="startVersion")
    def start_version(self) -> _builtins.str:
        """
        The start version of the private cloud for this upgrade.
        """
        return pulumi.get(self, "start_version")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Component's upgrade state.
        """
        return pulumi.get(self, "state")

    @_builtins.property
    @pulumi.getter(name="targetVersion")
    def target_version(self) -> _builtins.str:
        """
        The targeted version of the private cloud at the end of the upgrade.
        """
        return pulumi.get(self, "target_version")

    @_builtins.property
    @pulumi.getter
    def type(self) -> _builtins.str:
        """
        The type of upgrade. Possible values include: `VSPHERE_UPGRADE`, `VSPHERE_PATCH`, `WORKAROUND`, `FIRMWARE_UPGRADE`, `SWITCH_UPGRADE`, `OTHER`, `INFRASTRUCTURE_UPGRADE`.
        """
        return pulumi.get(self, "type")


@pulumi.output_type
class GetUpgradesUpgradeComponentUpgradeResult(dict):
    def __init__(__self__, *,
                 component_type: _builtins.str,
                 state: _builtins.str):
        """
        :param _builtins.str component_type: The type of vmware component being upgraded.
        :param _builtins.str state: Component's upgrade state.
        """
        pulumi.set(__self__, "component_type", component_type)
        pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="componentType")
    def component_type(self) -> _builtins.str:
        """
        The type of vmware component being upgraded.
        """
        return pulumi.get(self, "component_type")

    @_builtins.property
    @pulumi.getter
    def state(self) -> _builtins.str:
        """
        Component's upgrade state.
        """
        return pulumi.get(self, "state")


@pulumi.output_type
class GetUpgradesUpgradeScheduleResult(dict):
    def __init__(__self__, *,
                 constraints: 'outputs.GetUpgradesUpgradeScheduleConstraintsResult',
                 edit_windows: Sequence['outputs.GetUpgradesUpgradeScheduleEditWindowResult'],
                 last_editor: _builtins.str,
                 start_time: _builtins.str,
                 weekly_windows: Sequence['outputs.GetUpgradesUpgradeScheduleWeeklyWindowResult']):
        """
        :param 'GetUpgradesUpgradeScheduleConstraintsArgs' constraints: Constraints applied to the schedule.
        :param Sequence['GetUpgradesUpgradeScheduleEditWindowArgs'] edit_windows: The schedule is open for edits during this time interval.
        :param _builtins.str last_editor: Indicates who most recently edited the upgrade schedule. Possible values: `SYSTEM`, `USER`.
        :param _builtins.str start_time: Start of the edit window (RFC3339).
        :param Sequence['GetUpgradesUpgradeScheduleWeeklyWindowArgs'] weekly_windows: Weekly time windows for upgrade activities.
        """
        pulumi.set(__self__, "constraints", constraints)
        pulumi.set(__self__, "edit_windows", edit_windows)
        pulumi.set(__self__, "last_editor", last_editor)
        pulumi.set(__self__, "start_time", start_time)
        pulumi.set(__self__, "weekly_windows", weekly_windows)

    @_builtins.property
    @pulumi.getter
    def constraints(self) -> 'outputs.GetUpgradesUpgradeScheduleConstraintsResult':
        """
        Constraints applied to the schedule.
        """
        return pulumi.get(self, "constraints")

    @_builtins.property
    @pulumi.getter(name="editWindows")
    def edit_windows(self) -> Sequence['outputs.GetUpgradesUpgradeScheduleEditWindowResult']:
        """
        The schedule is open for edits during this time interval.
        """
        return pulumi.get(self, "edit_windows")

    @_builtins.property
    @pulumi.getter(name="lastEditor")
    def last_editor(self) -> _builtins.str:
        """
        Indicates who most recently edited the upgrade schedule. Possible values: `SYSTEM`, `USER`.
        """
        return pulumi.get(self, "last_editor")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Start of the edit window (RFC3339).
        """
        return pulumi.get(self, "start_time")

    @_builtins.property
    @pulumi.getter(name="weeklyWindows")
    def weekly_windows(self) -> Sequence['outputs.GetUpgradesUpgradeScheduleWeeklyWindowResult']:
        """
        Weekly time windows for upgrade activities.
        """
        return pulumi.get(self, "weekly_windows")


@pulumi.output_type
class GetUpgradesUpgradeScheduleConstraintsResult(dict):
    def __init__(__self__, *,
                 disallowed_intervals: 'outputs.GetUpgradesUpgradeScheduleConstraintsDisallowedIntervalsResult',
                 min_hours_day: _builtins.int,
                 min_hours_week: _builtins.int,
                 reschedule_date_range: 'outputs.GetUpgradesUpgradeScheduleConstraintsRescheduleDateRangeResult'):
        """
        :param 'GetUpgradesUpgradeScheduleConstraintsDisallowedIntervalsArgs' disallowed_intervals: A list of intervals in which maintenance windows are not allowed.
        :param _builtins.int min_hours_day: Minimum number of hours must be allotted for the upgrade activities for each selected day.
        :param _builtins.int min_hours_week: The minimum number of weekly hours must be allotted for the upgrade activities.
        :param 'GetUpgradesUpgradeScheduleConstraintsRescheduleDateRangeArgs' reschedule_date_range: The user can only reschedule an upgrade that starts within this range.
        """
        pulumi.set(__self__, "disallowed_intervals", disallowed_intervals)
        pulumi.set(__self__, "min_hours_day", min_hours_day)
        pulumi.set(__self__, "min_hours_week", min_hours_week)
        pulumi.set(__self__, "reschedule_date_range", reschedule_date_range)

    @_builtins.property
    @pulumi.getter(name="disallowedIntervals")
    def disallowed_intervals(self) -> 'outputs.GetUpgradesUpgradeScheduleConstraintsDisallowedIntervalsResult':
        """
        A list of intervals in which maintenance windows are not allowed.
        """
        return pulumi.get(self, "disallowed_intervals")

    @_builtins.property
    @pulumi.getter(name="minHoursDay")
    def min_hours_day(self) -> _builtins.int:
        """
        Minimum number of hours must be allotted for the upgrade activities for each selected day.
        """
        return pulumi.get(self, "min_hours_day")

    @_builtins.property
    @pulumi.getter(name="minHoursWeek")
    def min_hours_week(self) -> _builtins.int:
        """
        The minimum number of weekly hours must be allotted for the upgrade activities.
        """
        return pulumi.get(self, "min_hours_week")

    @_builtins.property
    @pulumi.getter(name="rescheduleDateRange")
    def reschedule_date_range(self) -> 'outputs.GetUpgradesUpgradeScheduleConstraintsRescheduleDateRangeResult':
        """
        The user can only reschedule an upgrade that starts within this range.
        """
        return pulumi.get(self, "reschedule_date_range")


@pulumi.output_type
class GetUpgradesUpgradeScheduleConstraintsDisallowedIntervalsResult(dict):
    def __init__(__self__, *,
                 end_day: _builtins.str,
                 end_time: 'outputs.GetUpgradesUpgradeScheduleConstraintsDisallowedIntervalsEndTimeResult',
                 start_day: _builtins.str,
                 start_time: 'outputs.GetUpgradesUpgradeScheduleConstraintsDisallowedIntervalsStartTimeResult'):
        """
        :param 'GetUpgradesUpgradeScheduleConstraintsDisallowedIntervalsEndTimeArgs' end_time: End of the edit window (RFC3339).
        :param 'GetUpgradesUpgradeScheduleConstraintsDisallowedIntervalsStartTimeArgs' start_time: Start of the edit window (RFC3339).
        """
        pulumi.set(__self__, "end_day", end_day)
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_day", start_day)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="endDay")
    def end_day(self) -> _builtins.str:
        return pulumi.get(self, "end_day")

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> 'outputs.GetUpgradesUpgradeScheduleConstraintsDisallowedIntervalsEndTimeResult':
        """
        End of the edit window (RFC3339).
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startDay")
    def start_day(self) -> _builtins.str:
        return pulumi.get(self, "start_day")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> 'outputs.GetUpgradesUpgradeScheduleConstraintsDisallowedIntervalsStartTimeResult':
        """
        Start of the edit window (RFC3339).
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetUpgradesUpgradeScheduleConstraintsDisallowedIntervalsEndTimeResult(dict):
    def __init__(__self__, *,
                 hours: _builtins.int,
                 minutes: _builtins.int):
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> _builtins.int:
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> _builtins.int:
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetUpgradesUpgradeScheduleConstraintsDisallowedIntervalsStartTimeResult(dict):
    def __init__(__self__, *,
                 hours: _builtins.int,
                 minutes: _builtins.int):
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> _builtins.int:
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> _builtins.int:
        return pulumi.get(self, "minutes")


@pulumi.output_type
class GetUpgradesUpgradeScheduleConstraintsRescheduleDateRangeResult(dict):
    def __init__(__self__, *,
                 end_time: _builtins.str,
                 start_time: _builtins.str):
        """
        :param _builtins.str end_time: End of the edit window (RFC3339).
        :param _builtins.str start_time: Start of the edit window (RFC3339).
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        End of the edit window (RFC3339).
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Start of the edit window (RFC3339).
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetUpgradesUpgradeScheduleEditWindowResult(dict):
    def __init__(__self__, *,
                 end_time: _builtins.str,
                 start_time: _builtins.str):
        """
        :param _builtins.str end_time: End of the edit window (RFC3339).
        :param _builtins.str start_time: Start of the edit window (RFC3339).
        """
        pulumi.set(__self__, "end_time", end_time)
        pulumi.set(__self__, "start_time", start_time)

    @_builtins.property
    @pulumi.getter(name="endTime")
    def end_time(self) -> _builtins.str:
        """
        End of the edit window (RFC3339).
        """
        return pulumi.get(self, "end_time")

    @_builtins.property
    @pulumi.getter(name="startTime")
    def start_time(self) -> _builtins.str:
        """
        Start of the edit window (RFC3339).
        """
        return pulumi.get(self, "start_time")


@pulumi.output_type
class GetUpgradesUpgradeScheduleWeeklyWindowResult(dict):
    def __init__(__self__, *,
                 day_of_week: _builtins.str,
                 duration: _builtins.str,
                 start_times: Sequence['outputs.GetUpgradesUpgradeScheduleWeeklyWindowStartTimeResult']):
        """
        :param _builtins.str day_of_week: Day of the week for this window.
        :param _builtins.str duration: The duration of the window in seconds.
        :param Sequence['GetUpgradesUpgradeScheduleWeeklyWindowStartTimeArgs'] start_times: Start of the edit window (RFC3339).
        """
        pulumi.set(__self__, "day_of_week", day_of_week)
        pulumi.set(__self__, "duration", duration)
        pulumi.set(__self__, "start_times", start_times)

    @_builtins.property
    @pulumi.getter(name="dayOfWeek")
    def day_of_week(self) -> _builtins.str:
        """
        Day of the week for this window.
        """
        return pulumi.get(self, "day_of_week")

    @_builtins.property
    @pulumi.getter
    def duration(self) -> _builtins.str:
        """
        The duration of the window in seconds.
        """
        return pulumi.get(self, "duration")

    @_builtins.property
    @pulumi.getter(name="startTimes")
    def start_times(self) -> Sequence['outputs.GetUpgradesUpgradeScheduleWeeklyWindowStartTimeResult']:
        """
        Start of the edit window (RFC3339).
        """
        return pulumi.get(self, "start_times")


@pulumi.output_type
class GetUpgradesUpgradeScheduleWeeklyWindowStartTimeResult(dict):
    def __init__(__self__, *,
                 hours: _builtins.int,
                 minutes: _builtins.int):
        pulumi.set(__self__, "hours", hours)
        pulumi.set(__self__, "minutes", minutes)

    @_builtins.property
    @pulumi.getter
    def hours(self) -> _builtins.int:
        return pulumi.get(self, "hours")

    @_builtins.property
    @pulumi.getter
    def minutes(self) -> _builtins.int:
        return pulumi.get(self, "minutes")


