# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ClusterAutoscalingSettingsArgs',
    'ClusterAutoscalingSettingsArgsDict',
    'ClusterAutoscalingSettingsAutoscalingPolicyArgs',
    'ClusterAutoscalingSettingsAutoscalingPolicyArgsDict',
    'ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgs',
    'ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgsDict',
    'ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgs',
    'ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgsDict',
    'ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgs',
    'ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgsDict',
    'ClusterNodeTypeConfigArgs',
    'ClusterNodeTypeConfigArgsDict',
    'ExternalAccessRuleDestinationIpRangeArgs',
    'ExternalAccessRuleDestinationIpRangeArgsDict',
    'ExternalAccessRuleSourceIpRangeArgs',
    'ExternalAccessRuleSourceIpRangeArgsDict',
    'NetworkPolicyExternalIpArgs',
    'NetworkPolicyExternalIpArgsDict',
    'NetworkPolicyInternetAccessArgs',
    'NetworkPolicyInternetAccessArgsDict',
    'NetworkVpcNetworkArgs',
    'NetworkVpcNetworkArgsDict',
    'PrivateCloudHcxArgs',
    'PrivateCloudHcxArgsDict',
    'PrivateCloudManagementClusterArgs',
    'PrivateCloudManagementClusterArgsDict',
    'PrivateCloudManagementClusterAutoscalingSettingsArgs',
    'PrivateCloudManagementClusterAutoscalingSettingsArgsDict',
    'PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyArgs',
    'PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyArgsDict',
    'PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgs',
    'PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgsDict',
    'PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgs',
    'PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgsDict',
    'PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgs',
    'PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgsDict',
    'PrivateCloudManagementClusterNodeTypeConfigArgs',
    'PrivateCloudManagementClusterNodeTypeConfigArgsDict',
    'PrivateCloudManagementClusterStretchedClusterConfigArgs',
    'PrivateCloudManagementClusterStretchedClusterConfigArgsDict',
    'PrivateCloudNetworkConfigArgs',
    'PrivateCloudNetworkConfigArgsDict',
    'PrivateCloudNsxArgs',
    'PrivateCloudNsxArgsDict',
    'PrivateCloudVcenterArgs',
    'PrivateCloudVcenterArgsDict',
    'SubnetDhcpAddressRangeArgs',
    'SubnetDhcpAddressRangeArgsDict',
]

MYPY = False

if not MYPY:
    class ClusterAutoscalingSettingsArgsDict(TypedDict):
        autoscaling_policies: pulumi.Input[Sequence[pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyArgsDict']]]
        """
        The map with autoscaling policies applied to the cluster.
        The key is the identifier of the policy.
        It must meet the following requirements:
        * Only contains 1-63 alphanumeric characters and hyphens
        * Begins with an alphabetical character
        * Ends with a non-hyphen character
        * Not formatted as a UUID
        * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
        Currently the map must contain only one element
        that describes the autoscaling policy for compute nodes.
        Structure is documented below.
        """
        cool_down_period: NotRequired[pulumi.Input[builtins.str]]
        """
        The minimum duration between consecutive autoscale operations.
        It starts once addition or removal of nodes is fully completed.
        Minimum cool down period is 30m.
        Cool down period must be in whole minutes (for example, 30m, 31m, 50m).
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        max_cluster_node_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of nodes of any type in a cluster.
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        min_cluster_node_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Minimum number of nodes of any type in a cluster.
        Mandatory for successful addition of autoscaling settings in cluster.
        """
elif False:
    ClusterAutoscalingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAutoscalingSettingsArgs:
    def __init__(__self__, *,
                 autoscaling_policies: pulumi.Input[Sequence[pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyArgs']]],
                 cool_down_period: Optional[pulumi.Input[builtins.str]] = None,
                 max_cluster_node_count: Optional[pulumi.Input[builtins.int]] = None,
                 min_cluster_node_count: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyArgs']]] autoscaling_policies: The map with autoscaling policies applied to the cluster.
               The key is the identifier of the policy.
               It must meet the following requirements:
               * Only contains 1-63 alphanumeric characters and hyphens
               * Begins with an alphabetical character
               * Ends with a non-hyphen character
               * Not formatted as a UUID
               * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
               Currently the map must contain only one element
               that describes the autoscaling policy for compute nodes.
               Structure is documented below.
        :param pulumi.Input[builtins.str] cool_down_period: The minimum duration between consecutive autoscale operations.
               It starts once addition or removal of nodes is fully completed.
               Minimum cool down period is 30m.
               Cool down period must be in whole minutes (for example, 30m, 31m, 50m).
               Mandatory for successful addition of autoscaling settings in cluster.
        :param pulumi.Input[builtins.int] max_cluster_node_count: Maximum number of nodes of any type in a cluster.
               Mandatory for successful addition of autoscaling settings in cluster.
        :param pulumi.Input[builtins.int] min_cluster_node_count: Minimum number of nodes of any type in a cluster.
               Mandatory for successful addition of autoscaling settings in cluster.
        """
        pulumi.set(__self__, "autoscaling_policies", autoscaling_policies)
        if cool_down_period is not None:
            pulumi.set(__self__, "cool_down_period", cool_down_period)
        if max_cluster_node_count is not None:
            pulumi.set(__self__, "max_cluster_node_count", max_cluster_node_count)
        if min_cluster_node_count is not None:
            pulumi.set(__self__, "min_cluster_node_count", min_cluster_node_count)

    @property
    @pulumi.getter(name="autoscalingPolicies")
    def autoscaling_policies(self) -> pulumi.Input[Sequence[pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyArgs']]]:
        """
        The map with autoscaling policies applied to the cluster.
        The key is the identifier of the policy.
        It must meet the following requirements:
        * Only contains 1-63 alphanumeric characters and hyphens
        * Begins with an alphabetical character
        * Ends with a non-hyphen character
        * Not formatted as a UUID
        * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
        Currently the map must contain only one element
        that describes the autoscaling policy for compute nodes.
        Structure is documented below.
        """
        return pulumi.get(self, "autoscaling_policies")

    @autoscaling_policies.setter
    def autoscaling_policies(self, value: pulumi.Input[Sequence[pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyArgs']]]):
        pulumi.set(self, "autoscaling_policies", value)

    @property
    @pulumi.getter(name="coolDownPeriod")
    def cool_down_period(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The minimum duration between consecutive autoscale operations.
        It starts once addition or removal of nodes is fully completed.
        Minimum cool down period is 30m.
        Cool down period must be in whole minutes (for example, 30m, 31m, 50m).
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        return pulumi.get(self, "cool_down_period")

    @cool_down_period.setter
    def cool_down_period(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cool_down_period", value)

    @property
    @pulumi.getter(name="maxClusterNodeCount")
    def max_cluster_node_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of nodes of any type in a cluster.
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        return pulumi.get(self, "max_cluster_node_count")

    @max_cluster_node_count.setter
    def max_cluster_node_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_cluster_node_count", value)

    @property
    @pulumi.getter(name="minClusterNodeCount")
    def min_cluster_node_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minimum number of nodes of any type in a cluster.
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        return pulumi.get(self, "min_cluster_node_count")

    @min_cluster_node_count.setter
    def min_cluster_node_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_cluster_node_count", value)


if not MYPY:
    class ClusterAutoscalingSettingsAutoscalingPolicyArgsDict(TypedDict):
        autoscale_policy_id: pulumi.Input[builtins.str]
        """
        The identifier for this object. Format specified above.
        """
        node_type_id: pulumi.Input[builtins.str]
        """
        The canonical identifier of the node type to add or remove.
        """
        scale_out_size: pulumi.Input[builtins.int]
        """
        Number of nodes to add to a cluster during a scale-out operation.
        Must be divisible by 2 for stretched clusters.
        """
        consumed_memory_thresholds: NotRequired[pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgsDict']]
        """
        Utilization thresholds pertaining to amount of consumed memory.
        Structure is documented below.
        """
        cpu_thresholds: NotRequired[pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgsDict']]
        """
        Utilization thresholds pertaining to CPU utilization.
        Structure is documented below.
        """
        storage_thresholds: NotRequired[pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgsDict']]
        """
        Utilization thresholds pertaining to amount of consumed storage.
        Structure is documented below.
        """
elif False:
    ClusterAutoscalingSettingsAutoscalingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAutoscalingSettingsAutoscalingPolicyArgs:
    def __init__(__self__, *,
                 autoscale_policy_id: pulumi.Input[builtins.str],
                 node_type_id: pulumi.Input[builtins.str],
                 scale_out_size: pulumi.Input[builtins.int],
                 consumed_memory_thresholds: Optional[pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgs']] = None,
                 cpu_thresholds: Optional[pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgs']] = None,
                 storage_thresholds: Optional[pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgs']] = None):
        """
        :param pulumi.Input[builtins.str] autoscale_policy_id: The identifier for this object. Format specified above.
        :param pulumi.Input[builtins.str] node_type_id: The canonical identifier of the node type to add or remove.
        :param pulumi.Input[builtins.int] scale_out_size: Number of nodes to add to a cluster during a scale-out operation.
               Must be divisible by 2 for stretched clusters.
        :param pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgs'] consumed_memory_thresholds: Utilization thresholds pertaining to amount of consumed memory.
               Structure is documented below.
        :param pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgs'] cpu_thresholds: Utilization thresholds pertaining to CPU utilization.
               Structure is documented below.
        :param pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgs'] storage_thresholds: Utilization thresholds pertaining to amount of consumed storage.
               Structure is documented below.
        """
        pulumi.set(__self__, "autoscale_policy_id", autoscale_policy_id)
        pulumi.set(__self__, "node_type_id", node_type_id)
        pulumi.set(__self__, "scale_out_size", scale_out_size)
        if consumed_memory_thresholds is not None:
            pulumi.set(__self__, "consumed_memory_thresholds", consumed_memory_thresholds)
        if cpu_thresholds is not None:
            pulumi.set(__self__, "cpu_thresholds", cpu_thresholds)
        if storage_thresholds is not None:
            pulumi.set(__self__, "storage_thresholds", storage_thresholds)

    @property
    @pulumi.getter(name="autoscalePolicyId")
    def autoscale_policy_id(self) -> pulumi.Input[builtins.str]:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "autoscale_policy_id")

    @autoscale_policy_id.setter
    def autoscale_policy_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "autoscale_policy_id", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> pulumi.Input[builtins.str]:
        """
        The canonical identifier of the node type to add or remove.
        """
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="scaleOutSize")
    def scale_out_size(self) -> pulumi.Input[builtins.int]:
        """
        Number of nodes to add to a cluster during a scale-out operation.
        Must be divisible by 2 for stretched clusters.
        """
        return pulumi.get(self, "scale_out_size")

    @scale_out_size.setter
    def scale_out_size(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "scale_out_size", value)

    @property
    @pulumi.getter(name="consumedMemoryThresholds")
    def consumed_memory_thresholds(self) -> Optional[pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgs']]:
        """
        Utilization thresholds pertaining to amount of consumed memory.
        Structure is documented below.
        """
        return pulumi.get(self, "consumed_memory_thresholds")

    @consumed_memory_thresholds.setter
    def consumed_memory_thresholds(self, value: Optional[pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgs']]):
        pulumi.set(self, "consumed_memory_thresholds", value)

    @property
    @pulumi.getter(name="cpuThresholds")
    def cpu_thresholds(self) -> Optional[pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgs']]:
        """
        Utilization thresholds pertaining to CPU utilization.
        Structure is documented below.
        """
        return pulumi.get(self, "cpu_thresholds")

    @cpu_thresholds.setter
    def cpu_thresholds(self, value: Optional[pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgs']]):
        pulumi.set(self, "cpu_thresholds", value)

    @property
    @pulumi.getter(name="storageThresholds")
    def storage_thresholds(self) -> Optional[pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgs']]:
        """
        Utilization thresholds pertaining to amount of consumed storage.
        Structure is documented below.
        """
        return pulumi.get(self, "storage_thresholds")

    @storage_thresholds.setter
    def storage_thresholds(self, value: Optional[pulumi.Input['ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgs']]):
        pulumi.set(self, "storage_thresholds", value)


if not MYPY:
    class ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgsDict(TypedDict):
        scale_in: pulumi.Input[builtins.int]
        """
        The utilization triggering the scale-in operation in percent.
        """
        scale_out: pulumi.Input[builtins.int]
        """
        The utilization triggering the scale-out operation in percent.
        """
elif False:
    ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgs:
    def __init__(__self__, *,
                 scale_in: pulumi.Input[builtins.int],
                 scale_out: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.int] scale_in: The utilization triggering the scale-in operation in percent.
        :param pulumi.Input[builtins.int] scale_out: The utilization triggering the scale-out operation in percent.
        """
        pulumi.set(__self__, "scale_in", scale_in)
        pulumi.set(__self__, "scale_out", scale_out)

    @property
    @pulumi.getter(name="scaleIn")
    def scale_in(self) -> pulumi.Input[builtins.int]:
        """
        The utilization triggering the scale-in operation in percent.
        """
        return pulumi.get(self, "scale_in")

    @scale_in.setter
    def scale_in(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "scale_in", value)

    @property
    @pulumi.getter(name="scaleOut")
    def scale_out(self) -> pulumi.Input[builtins.int]:
        """
        The utilization triggering the scale-out operation in percent.
        """
        return pulumi.get(self, "scale_out")

    @scale_out.setter
    def scale_out(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "scale_out", value)


if not MYPY:
    class ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgsDict(TypedDict):
        scale_in: pulumi.Input[builtins.int]
        """
        The utilization triggering the scale-in operation in percent.
        """
        scale_out: pulumi.Input[builtins.int]
        """
        The utilization triggering the scale-out operation in percent.
        """
elif False:
    ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgs:
    def __init__(__self__, *,
                 scale_in: pulumi.Input[builtins.int],
                 scale_out: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.int] scale_in: The utilization triggering the scale-in operation in percent.
        :param pulumi.Input[builtins.int] scale_out: The utilization triggering the scale-out operation in percent.
        """
        pulumi.set(__self__, "scale_in", scale_in)
        pulumi.set(__self__, "scale_out", scale_out)

    @property
    @pulumi.getter(name="scaleIn")
    def scale_in(self) -> pulumi.Input[builtins.int]:
        """
        The utilization triggering the scale-in operation in percent.
        """
        return pulumi.get(self, "scale_in")

    @scale_in.setter
    def scale_in(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "scale_in", value)

    @property
    @pulumi.getter(name="scaleOut")
    def scale_out(self) -> pulumi.Input[builtins.int]:
        """
        The utilization triggering the scale-out operation in percent.
        """
        return pulumi.get(self, "scale_out")

    @scale_out.setter
    def scale_out(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "scale_out", value)


if not MYPY:
    class ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgsDict(TypedDict):
        scale_in: pulumi.Input[builtins.int]
        """
        The utilization triggering the scale-in operation in percent.
        """
        scale_out: pulumi.Input[builtins.int]
        """
        The utilization triggering the scale-out operation in percent.
        """
elif False:
    ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgs:
    def __init__(__self__, *,
                 scale_in: pulumi.Input[builtins.int],
                 scale_out: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.int] scale_in: The utilization triggering the scale-in operation in percent.
        :param pulumi.Input[builtins.int] scale_out: The utilization triggering the scale-out operation in percent.
        """
        pulumi.set(__self__, "scale_in", scale_in)
        pulumi.set(__self__, "scale_out", scale_out)

    @property
    @pulumi.getter(name="scaleIn")
    def scale_in(self) -> pulumi.Input[builtins.int]:
        """
        The utilization triggering the scale-in operation in percent.
        """
        return pulumi.get(self, "scale_in")

    @scale_in.setter
    def scale_in(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "scale_in", value)

    @property
    @pulumi.getter(name="scaleOut")
    def scale_out(self) -> pulumi.Input[builtins.int]:
        """
        The utilization triggering the scale-out operation in percent.
        """
        return pulumi.get(self, "scale_out")

    @scale_out.setter
    def scale_out(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "scale_out", value)


if not MYPY:
    class ClusterNodeTypeConfigArgsDict(TypedDict):
        node_count: pulumi.Input[builtins.int]
        """
        The number of nodes of this type in the cluster.
        """
        node_type_id: pulumi.Input[builtins.str]
        """
        The identifier for this object. Format specified above.
        """
        custom_core_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Customized number of cores available to each node of the type.
        This number must always be one of `nodeType.availableCustomCoreCounts`.
        If zero is provided max value from `nodeType.availableCustomCoreCounts` will be used.
        Once the customer is created then corecount cannot be changed.
        """
elif False:
    ClusterNodeTypeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ClusterNodeTypeConfigArgs:
    def __init__(__self__, *,
                 node_count: pulumi.Input[builtins.int],
                 node_type_id: pulumi.Input[builtins.str],
                 custom_core_count: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] node_count: The number of nodes of this type in the cluster.
        :param pulumi.Input[builtins.str] node_type_id: The identifier for this object. Format specified above.
        :param pulumi.Input[builtins.int] custom_core_count: Customized number of cores available to each node of the type.
               This number must always be one of `nodeType.availableCustomCoreCounts`.
               If zero is provided max value from `nodeType.availableCustomCoreCounts` will be used.
               Once the customer is created then corecount cannot be changed.
        """
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "node_type_id", node_type_id)
        if custom_core_count is not None:
            pulumi.set(__self__, "custom_core_count", custom_core_count)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> pulumi.Input[builtins.int]:
        """
        The number of nodes of this type in the cluster.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "node_count", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> pulumi.Input[builtins.str]:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="customCoreCount")
    def custom_core_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Customized number of cores available to each node of the type.
        This number must always be one of `nodeType.availableCustomCoreCounts`.
        If zero is provided max value from `nodeType.availableCustomCoreCounts` will be used.
        Once the customer is created then corecount cannot be changed.
        """
        return pulumi.get(self, "custom_core_count")

    @custom_core_count.setter
    def custom_core_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "custom_core_count", value)


if not MYPY:
    class ExternalAccessRuleDestinationIpRangeArgsDict(TypedDict):
        external_address: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of an `ExternalAddress` resource.

        - - -
        """
        ip_address_range: NotRequired[pulumi.Input[builtins.str]]
        """
        An IP address range in the CIDR format.
        """
elif False:
    ExternalAccessRuleDestinationIpRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalAccessRuleDestinationIpRangeArgs:
    def __init__(__self__, *,
                 external_address: Optional[pulumi.Input[builtins.str]] = None,
                 ip_address_range: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] external_address: The name of an `ExternalAddress` resource.
               
               - - -
        :param pulumi.Input[builtins.str] ip_address_range: An IP address range in the CIDR format.
        """
        if external_address is not None:
            pulumi.set(__self__, "external_address", external_address)
        if ip_address_range is not None:
            pulumi.set(__self__, "ip_address_range", ip_address_range)

    @property
    @pulumi.getter(name="externalAddress")
    def external_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of an `ExternalAddress` resource.

        - - -
        """
        return pulumi.get(self, "external_address")

    @external_address.setter
    def external_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "external_address", value)

    @property
    @pulumi.getter(name="ipAddressRange")
    def ip_address_range(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An IP address range in the CIDR format.
        """
        return pulumi.get(self, "ip_address_range")

    @ip_address_range.setter
    def ip_address_range(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address_range", value)


if not MYPY:
    class ExternalAccessRuleSourceIpRangeArgsDict(TypedDict):
        ip_address: NotRequired[pulumi.Input[builtins.str]]
        """
        A single IP address.
        """
        ip_address_range: NotRequired[pulumi.Input[builtins.str]]
        """
        An IP address range in the CIDR format.
        """
elif False:
    ExternalAccessRuleSourceIpRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ExternalAccessRuleSourceIpRangeArgs:
    def __init__(__self__, *,
                 ip_address: Optional[pulumi.Input[builtins.str]] = None,
                 ip_address_range: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] ip_address: A single IP address.
        :param pulumi.Input[builtins.str] ip_address_range: An IP address range in the CIDR format.
        """
        if ip_address is not None:
            pulumi.set(__self__, "ip_address", ip_address)
        if ip_address_range is not None:
            pulumi.set(__self__, "ip_address_range", ip_address_range)

    @property
    @pulumi.getter(name="ipAddress")
    def ip_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A single IP address.
        """
        return pulumi.get(self, "ip_address")

    @ip_address.setter
    def ip_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address", value)

    @property
    @pulumi.getter(name="ipAddressRange")
    def ip_address_range(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        An IP address range in the CIDR format.
        """
        return pulumi.get(self, "ip_address_range")

    @ip_address_range.setter
    def ip_address_range(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "ip_address_range", value)


if not MYPY:
    class NetworkPolicyExternalIpArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        True if the service is enabled; false otherwise.
        """
        state: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        State of the service. New values may be added to this enum when appropriate.
        """
elif False:
    NetworkPolicyExternalIpArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPolicyExternalIpArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: True if the service is enabled; false otherwise.
        :param pulumi.Input[builtins.str] state: (Output)
               State of the service. New values may be added to this enum when appropriate.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        True if the service is enabled; false otherwise.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        State of the service. New values may be added to this enum when appropriate.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class NetworkPolicyInternetAccessArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[builtins.bool]]
        """
        True if the service is enabled; false otherwise.
        """
        state: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        State of the service. New values may be added to this enum when appropriate.
        """
elif False:
    NetworkPolicyInternetAccessArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkPolicyInternetAccessArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[builtins.bool]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] enabled: True if the service is enabled; false otherwise.
        :param pulumi.Input[builtins.str] state: (Output)
               State of the service. New values may be added to this enum when appropriate.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        True if the service is enabled; false otherwise.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        State of the service. New values may be added to this enum when appropriate.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class NetworkVpcNetworkArgsDict(TypedDict):
        network: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        The relative resource name of the service VPC network this VMware Engine network is attached to.
        For example: projects/123123/global/networks/my-network
        """
        type: NotRequired[pulumi.Input[builtins.str]]
        """
        VMware Engine network type.
        Possible values are: `LEGACY`, `STANDARD`.
        """
elif False:
    NetworkVpcNetworkArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class NetworkVpcNetworkArgs:
    def __init__(__self__, *,
                 network: Optional[pulumi.Input[builtins.str]] = None,
                 type: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] network: (Output)
               The relative resource name of the service VPC network this VMware Engine network is attached to.
               For example: projects/123123/global/networks/my-network
        :param pulumi.Input[builtins.str] type: VMware Engine network type.
               Possible values are: `LEGACY`, `STANDARD`.
        """
        if network is not None:
            pulumi.set(__self__, "network", network)
        if type is not None:
            pulumi.set(__self__, "type", type)

    @property
    @pulumi.getter
    def network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        The relative resource name of the service VPC network this VMware Engine network is attached to.
        For example: projects/123123/global/networks/my-network
        """
        return pulumi.get(self, "network")

    @network.setter
    def network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "network", value)

    @property
    @pulumi.getter
    def type(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        VMware Engine network type.
        Possible values are: `LEGACY`, `STANDARD`.
        """
        return pulumi.get(self, "type")

    @type.setter
    def type(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "type", value)


if not MYPY:
    class PrivateCloudHcxArgsDict(TypedDict):
        fqdn: NotRequired[pulumi.Input[builtins.str]]
        """
        Fully qualified domain name of the appliance.
        """
        internal_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        Internal IP address of the appliance.
        """
        state: NotRequired[pulumi.Input[builtins.str]]
        """
        State of the appliance.
        Possible values are: `ACTIVE`, `CREATING`.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        Version of the appliance.
        """
elif False:
    PrivateCloudHcxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateCloudHcxArgs:
    def __init__(__self__, *,
                 fqdn: Optional[pulumi.Input[builtins.str]] = None,
                 internal_ip: Optional[pulumi.Input[builtins.str]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] fqdn: Fully qualified domain name of the appliance.
        :param pulumi.Input[builtins.str] internal_ip: Internal IP address of the appliance.
        :param pulumi.Input[builtins.str] state: State of the appliance.
               Possible values are: `ACTIVE`, `CREATING`.
        :param pulumi.Input[builtins.str] version: Version of the appliance.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Fully qualified domain name of the appliance.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Internal IP address of the appliance.
        """
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        State of the appliance.
        Possible values are: `ACTIVE`, `CREATING`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Version of the appliance.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PrivateCloudManagementClusterArgsDict(TypedDict):
        cluster_id: pulumi.Input[builtins.str]
        """
        The user-provided identifier of the new Cluster. The identifier must meet the following requirements:
        * Only contains 1-63 alphanumeric characters and hyphens
        * Begins with an alphabetical character
        * Ends with a non-hyphen character
        * Not formatted as a UUID
        * Complies with RFC 1034 (https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
        """
        autoscaling_settings: NotRequired[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsArgsDict']]
        """
        Configuration of the autoscaling applied to this cluster
        Private cloud must have a minimum of 3 nodes to add autoscale settings
        Structure is documented below.
        """
        node_type_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['PrivateCloudManagementClusterNodeTypeConfigArgsDict']]]]
        """
        The map of cluster node types in this cluster,
        where the key is canonical identifier of the node type (corresponds to the NodeType).
        Structure is documented below.
        """
        stretched_cluster_config: NotRequired[pulumi.Input['PrivateCloudManagementClusterStretchedClusterConfigArgsDict']]
        """
        The stretched cluster configuration for the private cloud.
        Structure is documented below.
        """
elif False:
    PrivateCloudManagementClusterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateCloudManagementClusterArgs:
    def __init__(__self__, *,
                 cluster_id: pulumi.Input[builtins.str],
                 autoscaling_settings: Optional[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsArgs']] = None,
                 node_type_configs: Optional[pulumi.Input[Sequence[pulumi.Input['PrivateCloudManagementClusterNodeTypeConfigArgs']]]] = None,
                 stretched_cluster_config: Optional[pulumi.Input['PrivateCloudManagementClusterStretchedClusterConfigArgs']] = None):
        """
        :param pulumi.Input[builtins.str] cluster_id: The user-provided identifier of the new Cluster. The identifier must meet the following requirements:
               * Only contains 1-63 alphanumeric characters and hyphens
               * Begins with an alphabetical character
               * Ends with a non-hyphen character
               * Not formatted as a UUID
               * Complies with RFC 1034 (https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
        :param pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsArgs'] autoscaling_settings: Configuration of the autoscaling applied to this cluster
               Private cloud must have a minimum of 3 nodes to add autoscale settings
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['PrivateCloudManagementClusterNodeTypeConfigArgs']]] node_type_configs: The map of cluster node types in this cluster,
               where the key is canonical identifier of the node type (corresponds to the NodeType).
               Structure is documented below.
        :param pulumi.Input['PrivateCloudManagementClusterStretchedClusterConfigArgs'] stretched_cluster_config: The stretched cluster configuration for the private cloud.
               Structure is documented below.
        """
        pulumi.set(__self__, "cluster_id", cluster_id)
        if autoscaling_settings is not None:
            pulumi.set(__self__, "autoscaling_settings", autoscaling_settings)
        if node_type_configs is not None:
            pulumi.set(__self__, "node_type_configs", node_type_configs)
        if stretched_cluster_config is not None:
            pulumi.set(__self__, "stretched_cluster_config", stretched_cluster_config)

    @property
    @pulumi.getter(name="clusterId")
    def cluster_id(self) -> pulumi.Input[builtins.str]:
        """
        The user-provided identifier of the new Cluster. The identifier must meet the following requirements:
        * Only contains 1-63 alphanumeric characters and hyphens
        * Begins with an alphabetical character
        * Ends with a non-hyphen character
        * Not formatted as a UUID
        * Complies with RFC 1034 (https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
        """
        return pulumi.get(self, "cluster_id")

    @cluster_id.setter
    def cluster_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "cluster_id", value)

    @property
    @pulumi.getter(name="autoscalingSettings")
    def autoscaling_settings(self) -> Optional[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsArgs']]:
        """
        Configuration of the autoscaling applied to this cluster
        Private cloud must have a minimum of 3 nodes to add autoscale settings
        Structure is documented below.
        """
        return pulumi.get(self, "autoscaling_settings")

    @autoscaling_settings.setter
    def autoscaling_settings(self, value: Optional[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsArgs']]):
        pulumi.set(self, "autoscaling_settings", value)

    @property
    @pulumi.getter(name="nodeTypeConfigs")
    def node_type_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['PrivateCloudManagementClusterNodeTypeConfigArgs']]]]:
        """
        The map of cluster node types in this cluster,
        where the key is canonical identifier of the node type (corresponds to the NodeType).
        Structure is documented below.
        """
        return pulumi.get(self, "node_type_configs")

    @node_type_configs.setter
    def node_type_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['PrivateCloudManagementClusterNodeTypeConfigArgs']]]]):
        pulumi.set(self, "node_type_configs", value)

    @property
    @pulumi.getter(name="stretchedClusterConfig")
    def stretched_cluster_config(self) -> Optional[pulumi.Input['PrivateCloudManagementClusterStretchedClusterConfigArgs']]:
        """
        The stretched cluster configuration for the private cloud.
        Structure is documented below.
        """
        return pulumi.get(self, "stretched_cluster_config")

    @stretched_cluster_config.setter
    def stretched_cluster_config(self, value: Optional[pulumi.Input['PrivateCloudManagementClusterStretchedClusterConfigArgs']]):
        pulumi.set(self, "stretched_cluster_config", value)


if not MYPY:
    class PrivateCloudManagementClusterAutoscalingSettingsArgsDict(TypedDict):
        autoscaling_policies: pulumi.Input[Sequence[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyArgsDict']]]
        """
        The map with autoscaling policies applied to the cluster.
        The key is the identifier of the policy.
        It must meet the following requirements:
        * Only contains 1-63 alphanumeric characters and hyphens
        * Begins with an alphabetical character
        * Ends with a non-hyphen character
        * Not formatted as a UUID
        * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
        Currently the map must contain only one element
        that describes the autoscaling policy for compute nodes.
        Structure is documented below.
        """
        cool_down_period: NotRequired[pulumi.Input[builtins.str]]
        """
        The minimum duration between consecutive autoscale operations.
        It starts once addition or removal of nodes is fully completed.
        Minimum cool down period is 30m.
        Cool down period must be in whole minutes (for example, 30m, 31m, 50m).
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        max_cluster_node_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Maximum number of nodes of any type in a cluster.
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        min_cluster_node_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Minimum number of nodes of any type in a cluster.
        Mandatory for successful addition of autoscaling settings in cluster.
        """
elif False:
    PrivateCloudManagementClusterAutoscalingSettingsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateCloudManagementClusterAutoscalingSettingsArgs:
    def __init__(__self__, *,
                 autoscaling_policies: pulumi.Input[Sequence[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyArgs']]],
                 cool_down_period: Optional[pulumi.Input[builtins.str]] = None,
                 max_cluster_node_count: Optional[pulumi.Input[builtins.int]] = None,
                 min_cluster_node_count: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyArgs']]] autoscaling_policies: The map with autoscaling policies applied to the cluster.
               The key is the identifier of the policy.
               It must meet the following requirements:
               * Only contains 1-63 alphanumeric characters and hyphens
               * Begins with an alphabetical character
               * Ends with a non-hyphen character
               * Not formatted as a UUID
               * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
               Currently the map must contain only one element
               that describes the autoscaling policy for compute nodes.
               Structure is documented below.
        :param pulumi.Input[builtins.str] cool_down_period: The minimum duration between consecutive autoscale operations.
               It starts once addition or removal of nodes is fully completed.
               Minimum cool down period is 30m.
               Cool down period must be in whole minutes (for example, 30m, 31m, 50m).
               Mandatory for successful addition of autoscaling settings in cluster.
        :param pulumi.Input[builtins.int] max_cluster_node_count: Maximum number of nodes of any type in a cluster.
               Mandatory for successful addition of autoscaling settings in cluster.
        :param pulumi.Input[builtins.int] min_cluster_node_count: Minimum number of nodes of any type in a cluster.
               Mandatory for successful addition of autoscaling settings in cluster.
        """
        pulumi.set(__self__, "autoscaling_policies", autoscaling_policies)
        if cool_down_period is not None:
            pulumi.set(__self__, "cool_down_period", cool_down_period)
        if max_cluster_node_count is not None:
            pulumi.set(__self__, "max_cluster_node_count", max_cluster_node_count)
        if min_cluster_node_count is not None:
            pulumi.set(__self__, "min_cluster_node_count", min_cluster_node_count)

    @property
    @pulumi.getter(name="autoscalingPolicies")
    def autoscaling_policies(self) -> pulumi.Input[Sequence[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyArgs']]]:
        """
        The map with autoscaling policies applied to the cluster.
        The key is the identifier of the policy.
        It must meet the following requirements:
        * Only contains 1-63 alphanumeric characters and hyphens
        * Begins with an alphabetical character
        * Ends with a non-hyphen character
        * Not formatted as a UUID
        * Complies with [RFC 1034](https://datatracker.ietf.org/doc/html/rfc1034) (section 3.5)
        Currently the map must contain only one element
        that describes the autoscaling policy for compute nodes.
        Structure is documented below.
        """
        return pulumi.get(self, "autoscaling_policies")

    @autoscaling_policies.setter
    def autoscaling_policies(self, value: pulumi.Input[Sequence[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyArgs']]]):
        pulumi.set(self, "autoscaling_policies", value)

    @property
    @pulumi.getter(name="coolDownPeriod")
    def cool_down_period(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The minimum duration between consecutive autoscale operations.
        It starts once addition or removal of nodes is fully completed.
        Minimum cool down period is 30m.
        Cool down period must be in whole minutes (for example, 30m, 31m, 50m).
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        return pulumi.get(self, "cool_down_period")

    @cool_down_period.setter
    def cool_down_period(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "cool_down_period", value)

    @property
    @pulumi.getter(name="maxClusterNodeCount")
    def max_cluster_node_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Maximum number of nodes of any type in a cluster.
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        return pulumi.get(self, "max_cluster_node_count")

    @max_cluster_node_count.setter
    def max_cluster_node_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "max_cluster_node_count", value)

    @property
    @pulumi.getter(name="minClusterNodeCount")
    def min_cluster_node_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Minimum number of nodes of any type in a cluster.
        Mandatory for successful addition of autoscaling settings in cluster.
        """
        return pulumi.get(self, "min_cluster_node_count")

    @min_cluster_node_count.setter
    def min_cluster_node_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "min_cluster_node_count", value)


if not MYPY:
    class PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyArgsDict(TypedDict):
        autoscale_policy_id: pulumi.Input[builtins.str]
        """
        The identifier for this object. Format specified above.
        """
        node_type_id: pulumi.Input[builtins.str]
        """
        The canonical identifier of the node type to add or remove.
        """
        scale_out_size: pulumi.Input[builtins.int]
        """
        Number of nodes to add to a cluster during a scale-out operation.
        Must be divisible by 2 for stretched clusters.
        """
        consumed_memory_thresholds: NotRequired[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgsDict']]
        """
        Utilization thresholds pertaining to amount of consumed memory.
        Structure is documented below.
        """
        cpu_thresholds: NotRequired[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgsDict']]
        """
        Utilization thresholds pertaining to CPU utilization.
        Structure is documented below.
        """
        storage_thresholds: NotRequired[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgsDict']]
        """
        Utilization thresholds pertaining to amount of consumed storage.
        Structure is documented below.
        """
elif False:
    PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyArgs:
    def __init__(__self__, *,
                 autoscale_policy_id: pulumi.Input[builtins.str],
                 node_type_id: pulumi.Input[builtins.str],
                 scale_out_size: pulumi.Input[builtins.int],
                 consumed_memory_thresholds: Optional[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgs']] = None,
                 cpu_thresholds: Optional[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgs']] = None,
                 storage_thresholds: Optional[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgs']] = None):
        """
        :param pulumi.Input[builtins.str] autoscale_policy_id: The identifier for this object. Format specified above.
        :param pulumi.Input[builtins.str] node_type_id: The canonical identifier of the node type to add or remove.
        :param pulumi.Input[builtins.int] scale_out_size: Number of nodes to add to a cluster during a scale-out operation.
               Must be divisible by 2 for stretched clusters.
        :param pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgs'] consumed_memory_thresholds: Utilization thresholds pertaining to amount of consumed memory.
               Structure is documented below.
        :param pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgs'] cpu_thresholds: Utilization thresholds pertaining to CPU utilization.
               Structure is documented below.
        :param pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgs'] storage_thresholds: Utilization thresholds pertaining to amount of consumed storage.
               Structure is documented below.
        """
        pulumi.set(__self__, "autoscale_policy_id", autoscale_policy_id)
        pulumi.set(__self__, "node_type_id", node_type_id)
        pulumi.set(__self__, "scale_out_size", scale_out_size)
        if consumed_memory_thresholds is not None:
            pulumi.set(__self__, "consumed_memory_thresholds", consumed_memory_thresholds)
        if cpu_thresholds is not None:
            pulumi.set(__self__, "cpu_thresholds", cpu_thresholds)
        if storage_thresholds is not None:
            pulumi.set(__self__, "storage_thresholds", storage_thresholds)

    @property
    @pulumi.getter(name="autoscalePolicyId")
    def autoscale_policy_id(self) -> pulumi.Input[builtins.str]:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "autoscale_policy_id")

    @autoscale_policy_id.setter
    def autoscale_policy_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "autoscale_policy_id", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> pulumi.Input[builtins.str]:
        """
        The canonical identifier of the node type to add or remove.
        """
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="scaleOutSize")
    def scale_out_size(self) -> pulumi.Input[builtins.int]:
        """
        Number of nodes to add to a cluster during a scale-out operation.
        Must be divisible by 2 for stretched clusters.
        """
        return pulumi.get(self, "scale_out_size")

    @scale_out_size.setter
    def scale_out_size(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "scale_out_size", value)

    @property
    @pulumi.getter(name="consumedMemoryThresholds")
    def consumed_memory_thresholds(self) -> Optional[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgs']]:
        """
        Utilization thresholds pertaining to amount of consumed memory.
        Structure is documented below.
        """
        return pulumi.get(self, "consumed_memory_thresholds")

    @consumed_memory_thresholds.setter
    def consumed_memory_thresholds(self, value: Optional[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgs']]):
        pulumi.set(self, "consumed_memory_thresholds", value)

    @property
    @pulumi.getter(name="cpuThresholds")
    def cpu_thresholds(self) -> Optional[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgs']]:
        """
        Utilization thresholds pertaining to CPU utilization.
        Structure is documented below.
        """
        return pulumi.get(self, "cpu_thresholds")

    @cpu_thresholds.setter
    def cpu_thresholds(self, value: Optional[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgs']]):
        pulumi.set(self, "cpu_thresholds", value)

    @property
    @pulumi.getter(name="storageThresholds")
    def storage_thresholds(self) -> Optional[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgs']]:
        """
        Utilization thresholds pertaining to amount of consumed storage.
        Structure is documented below.
        """
        return pulumi.get(self, "storage_thresholds")

    @storage_thresholds.setter
    def storage_thresholds(self, value: Optional[pulumi.Input['PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgs']]):
        pulumi.set(self, "storage_thresholds", value)


if not MYPY:
    class PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgsDict(TypedDict):
        scale_in: pulumi.Input[builtins.int]
        """
        The utilization triggering the scale-in operation in percent.
        """
        scale_out: pulumi.Input[builtins.int]
        """
        The utilization triggering the scale-out operation in percent.
        """
elif False:
    PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyConsumedMemoryThresholdsArgs:
    def __init__(__self__, *,
                 scale_in: pulumi.Input[builtins.int],
                 scale_out: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.int] scale_in: The utilization triggering the scale-in operation in percent.
        :param pulumi.Input[builtins.int] scale_out: The utilization triggering the scale-out operation in percent.
        """
        pulumi.set(__self__, "scale_in", scale_in)
        pulumi.set(__self__, "scale_out", scale_out)

    @property
    @pulumi.getter(name="scaleIn")
    def scale_in(self) -> pulumi.Input[builtins.int]:
        """
        The utilization triggering the scale-in operation in percent.
        """
        return pulumi.get(self, "scale_in")

    @scale_in.setter
    def scale_in(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "scale_in", value)

    @property
    @pulumi.getter(name="scaleOut")
    def scale_out(self) -> pulumi.Input[builtins.int]:
        """
        The utilization triggering the scale-out operation in percent.
        """
        return pulumi.get(self, "scale_out")

    @scale_out.setter
    def scale_out(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "scale_out", value)


if not MYPY:
    class PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgsDict(TypedDict):
        scale_in: pulumi.Input[builtins.int]
        """
        The utilization triggering the scale-in operation in percent.
        """
        scale_out: pulumi.Input[builtins.int]
        """
        The utilization triggering the scale-out operation in percent.
        """
elif False:
    PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyCpuThresholdsArgs:
    def __init__(__self__, *,
                 scale_in: pulumi.Input[builtins.int],
                 scale_out: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.int] scale_in: The utilization triggering the scale-in operation in percent.
        :param pulumi.Input[builtins.int] scale_out: The utilization triggering the scale-out operation in percent.
        """
        pulumi.set(__self__, "scale_in", scale_in)
        pulumi.set(__self__, "scale_out", scale_out)

    @property
    @pulumi.getter(name="scaleIn")
    def scale_in(self) -> pulumi.Input[builtins.int]:
        """
        The utilization triggering the scale-in operation in percent.
        """
        return pulumi.get(self, "scale_in")

    @scale_in.setter
    def scale_in(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "scale_in", value)

    @property
    @pulumi.getter(name="scaleOut")
    def scale_out(self) -> pulumi.Input[builtins.int]:
        """
        The utilization triggering the scale-out operation in percent.
        """
        return pulumi.get(self, "scale_out")

    @scale_out.setter
    def scale_out(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "scale_out", value)


if not MYPY:
    class PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgsDict(TypedDict):
        scale_in: pulumi.Input[builtins.int]
        """
        The utilization triggering the scale-in operation in percent.

        - - -
        """
        scale_out: pulumi.Input[builtins.int]
        """
        The utilization triggering the scale-out operation in percent.
        """
elif False:
    PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateCloudManagementClusterAutoscalingSettingsAutoscalingPolicyStorageThresholdsArgs:
    def __init__(__self__, *,
                 scale_in: pulumi.Input[builtins.int],
                 scale_out: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.int] scale_in: The utilization triggering the scale-in operation in percent.
               
               - - -
        :param pulumi.Input[builtins.int] scale_out: The utilization triggering the scale-out operation in percent.
        """
        pulumi.set(__self__, "scale_in", scale_in)
        pulumi.set(__self__, "scale_out", scale_out)

    @property
    @pulumi.getter(name="scaleIn")
    def scale_in(self) -> pulumi.Input[builtins.int]:
        """
        The utilization triggering the scale-in operation in percent.

        - - -
        """
        return pulumi.get(self, "scale_in")

    @scale_in.setter
    def scale_in(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "scale_in", value)

    @property
    @pulumi.getter(name="scaleOut")
    def scale_out(self) -> pulumi.Input[builtins.int]:
        """
        The utilization triggering the scale-out operation in percent.
        """
        return pulumi.get(self, "scale_out")

    @scale_out.setter
    def scale_out(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "scale_out", value)


if not MYPY:
    class PrivateCloudManagementClusterNodeTypeConfigArgsDict(TypedDict):
        node_count: pulumi.Input[builtins.int]
        """
        The number of nodes of this type in the cluster.
        """
        node_type_id: pulumi.Input[builtins.str]
        """
        The identifier for this object. Format specified above.
        """
        custom_core_count: NotRequired[pulumi.Input[builtins.int]]
        """
        Customized number of cores available to each node of the type.
        This number must always be one of `nodeType.availableCustomCoreCounts`.
        If zero is provided max value from `nodeType.availableCustomCoreCounts` will be used.
        This cannot be changed once the PrivateCloud is created.
        """
elif False:
    PrivateCloudManagementClusterNodeTypeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateCloudManagementClusterNodeTypeConfigArgs:
    def __init__(__self__, *,
                 node_count: pulumi.Input[builtins.int],
                 node_type_id: pulumi.Input[builtins.str],
                 custom_core_count: Optional[pulumi.Input[builtins.int]] = None):
        """
        :param pulumi.Input[builtins.int] node_count: The number of nodes of this type in the cluster.
        :param pulumi.Input[builtins.str] node_type_id: The identifier for this object. Format specified above.
        :param pulumi.Input[builtins.int] custom_core_count: Customized number of cores available to each node of the type.
               This number must always be one of `nodeType.availableCustomCoreCounts`.
               If zero is provided max value from `nodeType.availableCustomCoreCounts` will be used.
               This cannot be changed once the PrivateCloud is created.
        """
        pulumi.set(__self__, "node_count", node_count)
        pulumi.set(__self__, "node_type_id", node_type_id)
        if custom_core_count is not None:
            pulumi.set(__self__, "custom_core_count", custom_core_count)

    @property
    @pulumi.getter(name="nodeCount")
    def node_count(self) -> pulumi.Input[builtins.int]:
        """
        The number of nodes of this type in the cluster.
        """
        return pulumi.get(self, "node_count")

    @node_count.setter
    def node_count(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "node_count", value)

    @property
    @pulumi.getter(name="nodeTypeId")
    def node_type_id(self) -> pulumi.Input[builtins.str]:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "node_type_id")

    @node_type_id.setter
    def node_type_id(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "node_type_id", value)

    @property
    @pulumi.getter(name="customCoreCount")
    def custom_core_count(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Customized number of cores available to each node of the type.
        This number must always be one of `nodeType.availableCustomCoreCounts`.
        If zero is provided max value from `nodeType.availableCustomCoreCounts` will be used.
        This cannot be changed once the PrivateCloud is created.
        """
        return pulumi.get(self, "custom_core_count")

    @custom_core_count.setter
    def custom_core_count(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "custom_core_count", value)


if not MYPY:
    class PrivateCloudManagementClusterStretchedClusterConfigArgsDict(TypedDict):
        preferred_location: NotRequired[pulumi.Input[builtins.str]]
        """
        Zone that will remain operational when connection between the two zones is lost.
        Specify the zone in the following format: projects/{project}/locations/{location}.
        """
        secondary_location: NotRequired[pulumi.Input[builtins.str]]
        """
        Additional zone for a higher level of availability and load balancing.
        Specify the zone in the following format: projects/{project}/locations/{location}.
        """
elif False:
    PrivateCloudManagementClusterStretchedClusterConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateCloudManagementClusterStretchedClusterConfigArgs:
    def __init__(__self__, *,
                 preferred_location: Optional[pulumi.Input[builtins.str]] = None,
                 secondary_location: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] preferred_location: Zone that will remain operational when connection between the two zones is lost.
               Specify the zone in the following format: projects/{project}/locations/{location}.
        :param pulumi.Input[builtins.str] secondary_location: Additional zone for a higher level of availability and load balancing.
               Specify the zone in the following format: projects/{project}/locations/{location}.
        """
        if preferred_location is not None:
            pulumi.set(__self__, "preferred_location", preferred_location)
        if secondary_location is not None:
            pulumi.set(__self__, "secondary_location", secondary_location)

    @property
    @pulumi.getter(name="preferredLocation")
    def preferred_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Zone that will remain operational when connection between the two zones is lost.
        Specify the zone in the following format: projects/{project}/locations/{location}.
        """
        return pulumi.get(self, "preferred_location")

    @preferred_location.setter
    def preferred_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "preferred_location", value)

    @property
    @pulumi.getter(name="secondaryLocation")
    def secondary_location(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Additional zone for a higher level of availability and load balancing.
        Specify the zone in the following format: projects/{project}/locations/{location}.
        """
        return pulumi.get(self, "secondary_location")

    @secondary_location.setter
    def secondary_location(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "secondary_location", value)


if not MYPY:
    class PrivateCloudNetworkConfigArgsDict(TypedDict):
        management_cidr: pulumi.Input[builtins.str]
        """
        Management CIDR used by VMware management appliances.
        """
        dns_server_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        DNS Server IP of the Private Cloud.
        """
        management_ip_address_layout_version: NotRequired[pulumi.Input[builtins.int]]
        """
        (Output)
        The IP address layout version of the management IP address range.
        Possible versions include:
        * managementIpAddressLayoutVersion=1: Indicates the legacy IP address layout used by some existing private clouds. This is no longer supported for new private clouds
        as it does not support all features.
        * managementIpAddressLayoutVersion=2: Indicates the latest IP address layout
        used by all newly created private clouds. This version supports all current features.
        """
        vmware_engine_network: NotRequired[pulumi.Input[builtins.str]]
        """
        The relative resource name of the VMware Engine network attached to the private cloud.
        Specify the name in the following form: projects/{project}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}
        where {project} can either be a project number or a project ID.
        """
        vmware_engine_network_canonical: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        The canonical name of the VMware Engine network in
        the form: projects/{project_number}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}
        """
elif False:
    PrivateCloudNetworkConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateCloudNetworkConfigArgs:
    def __init__(__self__, *,
                 management_cidr: pulumi.Input[builtins.str],
                 dns_server_ip: Optional[pulumi.Input[builtins.str]] = None,
                 management_ip_address_layout_version: Optional[pulumi.Input[builtins.int]] = None,
                 vmware_engine_network: Optional[pulumi.Input[builtins.str]] = None,
                 vmware_engine_network_canonical: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] management_cidr: Management CIDR used by VMware management appliances.
        :param pulumi.Input[builtins.str] dns_server_ip: (Output)
               DNS Server IP of the Private Cloud.
        :param pulumi.Input[builtins.int] management_ip_address_layout_version: (Output)
               The IP address layout version of the management IP address range.
               Possible versions include:
               * managementIpAddressLayoutVersion=1: Indicates the legacy IP address layout used by some existing private clouds. This is no longer supported for new private clouds
               as it does not support all features.
               * managementIpAddressLayoutVersion=2: Indicates the latest IP address layout
               used by all newly created private clouds. This version supports all current features.
        :param pulumi.Input[builtins.str] vmware_engine_network: The relative resource name of the VMware Engine network attached to the private cloud.
               Specify the name in the following form: projects/{project}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}
               where {project} can either be a project number or a project ID.
        :param pulumi.Input[builtins.str] vmware_engine_network_canonical: (Output)
               The canonical name of the VMware Engine network in
               the form: projects/{project_number}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}
        """
        pulumi.set(__self__, "management_cidr", management_cidr)
        if dns_server_ip is not None:
            pulumi.set(__self__, "dns_server_ip", dns_server_ip)
        if management_ip_address_layout_version is not None:
            pulumi.set(__self__, "management_ip_address_layout_version", management_ip_address_layout_version)
        if vmware_engine_network is not None:
            pulumi.set(__self__, "vmware_engine_network", vmware_engine_network)
        if vmware_engine_network_canonical is not None:
            pulumi.set(__self__, "vmware_engine_network_canonical", vmware_engine_network_canonical)

    @property
    @pulumi.getter(name="managementCidr")
    def management_cidr(self) -> pulumi.Input[builtins.str]:
        """
        Management CIDR used by VMware management appliances.
        """
        return pulumi.get(self, "management_cidr")

    @management_cidr.setter
    def management_cidr(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "management_cidr", value)

    @property
    @pulumi.getter(name="dnsServerIp")
    def dns_server_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        DNS Server IP of the Private Cloud.
        """
        return pulumi.get(self, "dns_server_ip")

    @dns_server_ip.setter
    def dns_server_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "dns_server_ip", value)

    @property
    @pulumi.getter(name="managementIpAddressLayoutVersion")
    def management_ip_address_layout_version(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        (Output)
        The IP address layout version of the management IP address range.
        Possible versions include:
        * managementIpAddressLayoutVersion=1: Indicates the legacy IP address layout used by some existing private clouds. This is no longer supported for new private clouds
        as it does not support all features.
        * managementIpAddressLayoutVersion=2: Indicates the latest IP address layout
        used by all newly created private clouds. This version supports all current features.
        """
        return pulumi.get(self, "management_ip_address_layout_version")

    @management_ip_address_layout_version.setter
    def management_ip_address_layout_version(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "management_ip_address_layout_version", value)

    @property
    @pulumi.getter(name="vmwareEngineNetwork")
    def vmware_engine_network(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The relative resource name of the VMware Engine network attached to the private cloud.
        Specify the name in the following form: projects/{project}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}
        where {project} can either be a project number or a project ID.
        """
        return pulumi.get(self, "vmware_engine_network")

    @vmware_engine_network.setter
    def vmware_engine_network(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vmware_engine_network", value)

    @property
    @pulumi.getter(name="vmwareEngineNetworkCanonical")
    def vmware_engine_network_canonical(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        The canonical name of the VMware Engine network in
        the form: projects/{project_number}/locations/{location}/vmwareEngineNetworks/{vmwareEngineNetworkId}
        """
        return pulumi.get(self, "vmware_engine_network_canonical")

    @vmware_engine_network_canonical.setter
    def vmware_engine_network_canonical(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "vmware_engine_network_canonical", value)


if not MYPY:
    class PrivateCloudNsxArgsDict(TypedDict):
        fqdn: NotRequired[pulumi.Input[builtins.str]]
        """
        Fully qualified domain name of the appliance.
        """
        internal_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        Internal IP address of the appliance.
        """
        state: NotRequired[pulumi.Input[builtins.str]]
        """
        State of the appliance.
        Possible values are: `ACTIVE`, `CREATING`.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        Version of the appliance.
        """
elif False:
    PrivateCloudNsxArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateCloudNsxArgs:
    def __init__(__self__, *,
                 fqdn: Optional[pulumi.Input[builtins.str]] = None,
                 internal_ip: Optional[pulumi.Input[builtins.str]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] fqdn: Fully qualified domain name of the appliance.
        :param pulumi.Input[builtins.str] internal_ip: Internal IP address of the appliance.
        :param pulumi.Input[builtins.str] state: State of the appliance.
               Possible values are: `ACTIVE`, `CREATING`.
        :param pulumi.Input[builtins.str] version: Version of the appliance.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Fully qualified domain name of the appliance.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Internal IP address of the appliance.
        """
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        State of the appliance.
        Possible values are: `ACTIVE`, `CREATING`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Version of the appliance.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class PrivateCloudVcenterArgsDict(TypedDict):
        fqdn: NotRequired[pulumi.Input[builtins.str]]
        """
        Fully qualified domain name of the appliance.
        """
        internal_ip: NotRequired[pulumi.Input[builtins.str]]
        """
        Internal IP address of the appliance.
        """
        state: NotRequired[pulumi.Input[builtins.str]]
        """
        State of the appliance.
        Possible values are: `ACTIVE`, `CREATING`.
        """
        version: NotRequired[pulumi.Input[builtins.str]]
        """
        Version of the appliance.
        """
elif False:
    PrivateCloudVcenterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateCloudVcenterArgs:
    def __init__(__self__, *,
                 fqdn: Optional[pulumi.Input[builtins.str]] = None,
                 internal_ip: Optional[pulumi.Input[builtins.str]] = None,
                 state: Optional[pulumi.Input[builtins.str]] = None,
                 version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] fqdn: Fully qualified domain name of the appliance.
        :param pulumi.Input[builtins.str] internal_ip: Internal IP address of the appliance.
        :param pulumi.Input[builtins.str] state: State of the appliance.
               Possible values are: `ACTIVE`, `CREATING`.
        :param pulumi.Input[builtins.str] version: Version of the appliance.
        """
        if fqdn is not None:
            pulumi.set(__self__, "fqdn", fqdn)
        if internal_ip is not None:
            pulumi.set(__self__, "internal_ip", internal_ip)
        if state is not None:
            pulumi.set(__self__, "state", state)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @property
    @pulumi.getter
    def fqdn(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Fully qualified domain name of the appliance.
        """
        return pulumi.get(self, "fqdn")

    @fqdn.setter
    def fqdn(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "fqdn", value)

    @property
    @pulumi.getter(name="internalIp")
    def internal_ip(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Internal IP address of the appliance.
        """
        return pulumi.get(self, "internal_ip")

    @internal_ip.setter
    def internal_ip(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "internal_ip", value)

    @property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        State of the appliance.
        Possible values are: `ACTIVE`, `CREATING`.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "state", value)

    @property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Version of the appliance.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class SubnetDhcpAddressRangeArgsDict(TypedDict):
        first_address: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        The first IP address of the range.
        """
        last_address: NotRequired[pulumi.Input[builtins.str]]
        """
        (Output)
        The last IP address of the range.
        """
elif False:
    SubnetDhcpAddressRangeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SubnetDhcpAddressRangeArgs:
    def __init__(__self__, *,
                 first_address: Optional[pulumi.Input[builtins.str]] = None,
                 last_address: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] first_address: (Output)
               The first IP address of the range.
        :param pulumi.Input[builtins.str] last_address: (Output)
               The last IP address of the range.
        """
        if first_address is not None:
            pulumi.set(__self__, "first_address", first_address)
        if last_address is not None:
            pulumi.set(__self__, "last_address", last_address)

    @property
    @pulumi.getter(name="firstAddress")
    def first_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        The first IP address of the range.
        """
        return pulumi.get(self, "first_address")

    @first_address.setter
    def first_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "first_address", value)

    @property
    @pulumi.getter(name="lastAddress")
    def last_address(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        (Output)
        The last IP address of the range.
        """
        return pulumi.get(self, "last_address")

    @last_address.setter
    def last_address(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "last_address", value)


