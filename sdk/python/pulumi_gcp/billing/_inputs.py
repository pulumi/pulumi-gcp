# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins
import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AccountIamBindingConditionArgs',
    'AccountIamBindingConditionArgsDict',
    'AccountIamMemberConditionArgs',
    'AccountIamMemberConditionArgsDict',
    'BudgetAllUpdatesRuleArgs',
    'BudgetAllUpdatesRuleArgsDict',
    'BudgetAmountArgs',
    'BudgetAmountArgsDict',
    'BudgetAmountSpecifiedAmountArgs',
    'BudgetAmountSpecifiedAmountArgsDict',
    'BudgetBudgetFilterArgs',
    'BudgetBudgetFilterArgsDict',
    'BudgetBudgetFilterCustomPeriodArgs',
    'BudgetBudgetFilterCustomPeriodArgsDict',
    'BudgetBudgetFilterCustomPeriodEndDateArgs',
    'BudgetBudgetFilterCustomPeriodEndDateArgsDict',
    'BudgetBudgetFilterCustomPeriodStartDateArgs',
    'BudgetBudgetFilterCustomPeriodStartDateArgsDict',
    'BudgetThresholdRuleArgs',
    'BudgetThresholdRuleArgsDict',
]

MYPY = False

if not MYPY:
    class AccountIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    AccountIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class AccountIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[builtins.str]
        title: pulumi.Input[builtins.str]
        description: NotRequired[pulumi.Input[builtins.str]]
elif False:
    AccountIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AccountIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[builtins.str],
                 title: pulumi.Input[builtins.str],
                 description: Optional[pulumi.Input[builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @property
    @pulumi.getter
    def expression(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "expression", value)

    @property
    @pulumi.getter
    def title(self) -> pulumi.Input[builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[builtins.str]):
        pulumi.set(self, "title", value)

    @property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class BudgetAllUpdatesRuleArgsDict(TypedDict):
        disable_default_iam_recipients: NotRequired[pulumi.Input[builtins.bool]]
        """
        Boolean. When set to true, disables default notifications sent
        when a threshold is exceeded. Default recipients are
        those with Billing Account Administrators and Billing
        Account Users IAM roles for the target account.
        """
        enable_project_level_recipients: NotRequired[pulumi.Input[builtins.bool]]
        """
        When set to true, and when the budget has a single project configured,
        notifications will be sent to project level recipients of that project.
        This field will be ignored if the budget has multiple or no project configured.
        Currently, project level recipients are the users with Owner role on a cloud project.
        """
        monitoring_notification_channels: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        The full resource name of a monitoring notification
        channel in the form
        projects/{project_id}/notificationChannels/{channel_id}.
        A maximum of 5 channels are allowed.
        """
        pubsub_topic: NotRequired[pulumi.Input[builtins.str]]
        """
        The name of the Cloud Pub/Sub topic where budget related
        messages will be published, in the form
        projects/{project_id}/topics/{topic_id}. Updates are sent
        at regular intervals to the topic.
        """
        schema_version: NotRequired[pulumi.Input[builtins.str]]
        """
        The schema version of the notification. Only "1.0" is
        accepted. It represents the JSON schema as defined in
        https://cloud.google.com/billing/docs/how-to/budgets#notification_format.
        """
elif False:
    BudgetAllUpdatesRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetAllUpdatesRuleArgs:
    def __init__(__self__, *,
                 disable_default_iam_recipients: Optional[pulumi.Input[builtins.bool]] = None,
                 enable_project_level_recipients: Optional[pulumi.Input[builtins.bool]] = None,
                 monitoring_notification_channels: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 pubsub_topic: Optional[pulumi.Input[builtins.str]] = None,
                 schema_version: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.bool] disable_default_iam_recipients: Boolean. When set to true, disables default notifications sent
               when a threshold is exceeded. Default recipients are
               those with Billing Account Administrators and Billing
               Account Users IAM roles for the target account.
        :param pulumi.Input[builtins.bool] enable_project_level_recipients: When set to true, and when the budget has a single project configured,
               notifications will be sent to project level recipients of that project.
               This field will be ignored if the budget has multiple or no project configured.
               Currently, project level recipients are the users with Owner role on a cloud project.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] monitoring_notification_channels: The full resource name of a monitoring notification
               channel in the form
               projects/{project_id}/notificationChannels/{channel_id}.
               A maximum of 5 channels are allowed.
        :param pulumi.Input[builtins.str] pubsub_topic: The name of the Cloud Pub/Sub topic where budget related
               messages will be published, in the form
               projects/{project_id}/topics/{topic_id}. Updates are sent
               at regular intervals to the topic.
        :param pulumi.Input[builtins.str] schema_version: The schema version of the notification. Only "1.0" is
               accepted. It represents the JSON schema as defined in
               https://cloud.google.com/billing/docs/how-to/budgets#notification_format.
        """
        if disable_default_iam_recipients is not None:
            pulumi.set(__self__, "disable_default_iam_recipients", disable_default_iam_recipients)
        if enable_project_level_recipients is not None:
            pulumi.set(__self__, "enable_project_level_recipients", enable_project_level_recipients)
        if monitoring_notification_channels is not None:
            pulumi.set(__self__, "monitoring_notification_channels", monitoring_notification_channels)
        if pubsub_topic is not None:
            pulumi.set(__self__, "pubsub_topic", pubsub_topic)
        if schema_version is not None:
            pulumi.set(__self__, "schema_version", schema_version)

    @property
    @pulumi.getter(name="disableDefaultIamRecipients")
    def disable_default_iam_recipients(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Boolean. When set to true, disables default notifications sent
        when a threshold is exceeded. Default recipients are
        those with Billing Account Administrators and Billing
        Account Users IAM roles for the target account.
        """
        return pulumi.get(self, "disable_default_iam_recipients")

    @disable_default_iam_recipients.setter
    def disable_default_iam_recipients(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "disable_default_iam_recipients", value)

    @property
    @pulumi.getter(name="enableProjectLevelRecipients")
    def enable_project_level_recipients(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        When set to true, and when the budget has a single project configured,
        notifications will be sent to project level recipients of that project.
        This field will be ignored if the budget has multiple or no project configured.
        Currently, project level recipients are the users with Owner role on a cloud project.
        """
        return pulumi.get(self, "enable_project_level_recipients")

    @enable_project_level_recipients.setter
    def enable_project_level_recipients(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "enable_project_level_recipients", value)

    @property
    @pulumi.getter(name="monitoringNotificationChannels")
    def monitoring_notification_channels(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        The full resource name of a monitoring notification
        channel in the form
        projects/{project_id}/notificationChannels/{channel_id}.
        A maximum of 5 channels are allowed.
        """
        return pulumi.get(self, "monitoring_notification_channels")

    @monitoring_notification_channels.setter
    def monitoring_notification_channels(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "monitoring_notification_channels", value)

    @property
    @pulumi.getter(name="pubsubTopic")
    def pubsub_topic(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The name of the Cloud Pub/Sub topic where budget related
        messages will be published, in the form
        projects/{project_id}/topics/{topic_id}. Updates are sent
        at regular intervals to the topic.
        """
        return pulumi.get(self, "pubsub_topic")

    @pubsub_topic.setter
    def pubsub_topic(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "pubsub_topic", value)

    @property
    @pulumi.getter(name="schemaVersion")
    def schema_version(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The schema version of the notification. Only "1.0" is
        accepted. It represents the JSON schema as defined in
        https://cloud.google.com/billing/docs/how-to/budgets#notification_format.
        """
        return pulumi.get(self, "schema_version")

    @schema_version.setter
    def schema_version(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "schema_version", value)


if not MYPY:
    class BudgetAmountArgsDict(TypedDict):
        last_period_amount: NotRequired[pulumi.Input[builtins.bool]]
        """
        Configures a budget amount that is automatically set to 100% of
        last period's spend.
        Boolean. Set value to true to use. Do not set to false, instead
        use the `specified_amount` block.
        """
        specified_amount: NotRequired[pulumi.Input['BudgetAmountSpecifiedAmountArgsDict']]
        """
        A specified amount to use as the budget. currencyCode is
        optional. If specified, it must match the currency of the
        billing account. The currencyCode is provided on output.
        Structure is documented below.
        """
elif False:
    BudgetAmountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetAmountArgs:
    def __init__(__self__, *,
                 last_period_amount: Optional[pulumi.Input[builtins.bool]] = None,
                 specified_amount: Optional[pulumi.Input['BudgetAmountSpecifiedAmountArgs']] = None):
        """
        :param pulumi.Input[builtins.bool] last_period_amount: Configures a budget amount that is automatically set to 100% of
               last period's spend.
               Boolean. Set value to true to use. Do not set to false, instead
               use the `specified_amount` block.
        :param pulumi.Input['BudgetAmountSpecifiedAmountArgs'] specified_amount: A specified amount to use as the budget. currencyCode is
               optional. If specified, it must match the currency of the
               billing account. The currencyCode is provided on output.
               Structure is documented below.
        """
        if last_period_amount is not None:
            pulumi.set(__self__, "last_period_amount", last_period_amount)
        if specified_amount is not None:
            pulumi.set(__self__, "specified_amount", specified_amount)

    @property
    @pulumi.getter(name="lastPeriodAmount")
    def last_period_amount(self) -> Optional[pulumi.Input[builtins.bool]]:
        """
        Configures a budget amount that is automatically set to 100% of
        last period's spend.
        Boolean. Set value to true to use. Do not set to false, instead
        use the `specified_amount` block.
        """
        return pulumi.get(self, "last_period_amount")

    @last_period_amount.setter
    def last_period_amount(self, value: Optional[pulumi.Input[builtins.bool]]):
        pulumi.set(self, "last_period_amount", value)

    @property
    @pulumi.getter(name="specifiedAmount")
    def specified_amount(self) -> Optional[pulumi.Input['BudgetAmountSpecifiedAmountArgs']]:
        """
        A specified amount to use as the budget. currencyCode is
        optional. If specified, it must match the currency of the
        billing account. The currencyCode is provided on output.
        Structure is documented below.
        """
        return pulumi.get(self, "specified_amount")

    @specified_amount.setter
    def specified_amount(self, value: Optional[pulumi.Input['BudgetAmountSpecifiedAmountArgs']]):
        pulumi.set(self, "specified_amount", value)


if not MYPY:
    class BudgetAmountSpecifiedAmountArgsDict(TypedDict):
        currency_code: NotRequired[pulumi.Input[builtins.str]]
        """
        The 3-letter currency code defined in ISO 4217.
        """
        nanos: NotRequired[pulumi.Input[builtins.int]]
        """
        Number of nano (10^-9) units of the amount.
        The value must be between -999,999,999 and +999,999,999
        inclusive. If units is positive, nanos must be positive or
        zero. If units is zero, nanos can be positive, zero, or
        negative. If units is negative, nanos must be negative or
        zero. For example $-1.75 is represented as units=-1 and
        nanos=-750,000,000.

        - - -
        """
        units: NotRequired[pulumi.Input[builtins.str]]
        """
        The whole units of the amount. For example if currencyCode
        is "USD", then 1 unit is one US dollar.
        """
elif False:
    BudgetAmountSpecifiedAmountArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetAmountSpecifiedAmountArgs:
    def __init__(__self__, *,
                 currency_code: Optional[pulumi.Input[builtins.str]] = None,
                 nanos: Optional[pulumi.Input[builtins.int]] = None,
                 units: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.str] currency_code: The 3-letter currency code defined in ISO 4217.
        :param pulumi.Input[builtins.int] nanos: Number of nano (10^-9) units of the amount.
               The value must be between -999,999,999 and +999,999,999
               inclusive. If units is positive, nanos must be positive or
               zero. If units is zero, nanos can be positive, zero, or
               negative. If units is negative, nanos must be negative or
               zero. For example $-1.75 is represented as units=-1 and
               nanos=-750,000,000.
               
               - - -
        :param pulumi.Input[builtins.str] units: The whole units of the amount. For example if currencyCode
               is "USD", then 1 unit is one US dollar.
        """
        if currency_code is not None:
            pulumi.set(__self__, "currency_code", currency_code)
        if nanos is not None:
            pulumi.set(__self__, "nanos", nanos)
        if units is not None:
            pulumi.set(__self__, "units", units)

    @property
    @pulumi.getter(name="currencyCode")
    def currency_code(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The 3-letter currency code defined in ISO 4217.
        """
        return pulumi.get(self, "currency_code")

    @currency_code.setter
    def currency_code(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "currency_code", value)

    @property
    @pulumi.getter
    def nanos(self) -> Optional[pulumi.Input[builtins.int]]:
        """
        Number of nano (10^-9) units of the amount.
        The value must be between -999,999,999 and +999,999,999
        inclusive. If units is positive, nanos must be positive or
        zero. If units is zero, nanos can be positive, zero, or
        negative. If units is negative, nanos must be negative or
        zero. For example $-1.75 is represented as units=-1 and
        nanos=-750,000,000.

        - - -
        """
        return pulumi.get(self, "nanos")

    @nanos.setter
    def nanos(self, value: Optional[pulumi.Input[builtins.int]]):
        pulumi.set(self, "nanos", value)

    @property
    @pulumi.getter
    def units(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The whole units of the amount. For example if currencyCode
        is "USD", then 1 unit is one US dollar.
        """
        return pulumi.get(self, "units")

    @units.setter
    def units(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "units", value)


if not MYPY:
    class BudgetBudgetFilterArgsDict(TypedDict):
        calendar_period: NotRequired[pulumi.Input[builtins.str]]
        """
        A CalendarPeriod represents the abstract concept of a recurring time period that has a
        canonical start. Grammatically, "the start of the current CalendarPeriod".
        All calendar times begin at 12 AM US and Canadian Pacific Time (UTC-8).
        Exactly one of `calendar_period`, `custom_period` must be provided.
        Possible values are: `MONTH`, `QUARTER`, `YEAR`, `CALENDAR_PERIOD_UNSPECIFIED`.
        """
        credit_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        Optional. If creditTypesTreatment is INCLUDE_SPECIFIED_CREDITS,
        this is a list of credit types to be subtracted from gross cost to determine the spend for threshold calculations. See a list of acceptable credit type values.
        If creditTypesTreatment is not INCLUDE_SPECIFIED_CREDITS, this field must be empty.
        **Note:** If the field has a value in the config and needs to be removed, the field has to be an empty array in the config.
        """
        credit_types_treatment: NotRequired[pulumi.Input[builtins.str]]
        """
        Specifies how credits should be treated when determining spend
        for threshold calculations.
        Default value is `INCLUDE_ALL_CREDITS`.
        Possible values are: `INCLUDE_ALL_CREDITS`, `EXCLUDE_ALL_CREDITS`, `INCLUDE_SPECIFIED_CREDITS`.
        """
        custom_period: NotRequired[pulumi.Input['BudgetBudgetFilterCustomPeriodArgsDict']]
        """
        Specifies to track usage from any start date (required) to any end date (optional).
        This time period is static, it does not recur.
        Exactly one of `calendar_period`, `custom_period` must be provided.
        Structure is documented below.
        """
        labels: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]
        """
        A single label and value pair specifying that usage from only
        this set of labeled resources should be included in the budget.
        """
        projects: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A set of projects of the form projects/{project_number},
        specifying that usage from only this set of projects should be
        included in the budget. If omitted, the report will include
        all usage for the billing account, regardless of which project
        the usage occurred on.
        """
        resource_ancestors: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A set of folder and organization names of the form folders/{folderId} or organizations/{organizationId},
        specifying that usage from only this set of folders and organizations should be included in the budget.
        If omitted, the budget includes all usage that the billing account pays for. If the folder or organization
        contains projects that are paid for by a different Cloud Billing account, the budget doesn't apply to those projects.
        """
        services: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A set of services of the form services/{service_id},
        specifying that usage from only this set of services should be
        included in the budget. If omitted, the report will include
        usage for all the services. The service names are available
        through the Catalog API:
        https://cloud.google.com/billing/v1/how-tos/catalog-api.
        """
        subaccounts: NotRequired[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]
        """
        A set of subaccounts of the form billingAccounts/{account_id},
        specifying that usage from only this set of subaccounts should
        be included in the budget. If a subaccount is set to the name of
        the parent account, usage from the parent account will be included.
        If the field is omitted, the report will include usage from the parent
        account and all subaccounts, if they exist.
        **Note:** If the field has a value in the config and needs to be removed, the field has to be an empty array in the config.
        """
elif False:
    BudgetBudgetFilterArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetBudgetFilterArgs:
    def __init__(__self__, *,
                 calendar_period: Optional[pulumi.Input[builtins.str]] = None,
                 credit_types: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 credit_types_treatment: Optional[pulumi.Input[builtins.str]] = None,
                 custom_period: Optional[pulumi.Input['BudgetBudgetFilterCustomPeriodArgs']] = None,
                 labels: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]] = None,
                 projects: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 resource_ancestors: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 services: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None,
                 subaccounts: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]] = None):
        """
        :param pulumi.Input[builtins.str] calendar_period: A CalendarPeriod represents the abstract concept of a recurring time period that has a
               canonical start. Grammatically, "the start of the current CalendarPeriod".
               All calendar times begin at 12 AM US and Canadian Pacific Time (UTC-8).
               Exactly one of `calendar_period`, `custom_period` must be provided.
               Possible values are: `MONTH`, `QUARTER`, `YEAR`, `CALENDAR_PERIOD_UNSPECIFIED`.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] credit_types: Optional. If creditTypesTreatment is INCLUDE_SPECIFIED_CREDITS,
               this is a list of credit types to be subtracted from gross cost to determine the spend for threshold calculations. See a list of acceptable credit type values.
               If creditTypesTreatment is not INCLUDE_SPECIFIED_CREDITS, this field must be empty.
               **Note:** If the field has a value in the config and needs to be removed, the field has to be an empty array in the config.
        :param pulumi.Input[builtins.str] credit_types_treatment: Specifies how credits should be treated when determining spend
               for threshold calculations.
               Default value is `INCLUDE_ALL_CREDITS`.
               Possible values are: `INCLUDE_ALL_CREDITS`, `EXCLUDE_ALL_CREDITS`, `INCLUDE_SPECIFIED_CREDITS`.
        :param pulumi.Input['BudgetBudgetFilterCustomPeriodArgs'] custom_period: Specifies to track usage from any start date (required) to any end date (optional).
               This time period is static, it does not recur.
               Exactly one of `calendar_period`, `custom_period` must be provided.
               Structure is documented below.
        :param pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]] labels: A single label and value pair specifying that usage from only
               this set of labeled resources should be included in the budget.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] projects: A set of projects of the form projects/{project_number},
               specifying that usage from only this set of projects should be
               included in the budget. If omitted, the report will include
               all usage for the billing account, regardless of which project
               the usage occurred on.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] resource_ancestors: A set of folder and organization names of the form folders/{folderId} or organizations/{organizationId},
               specifying that usage from only this set of folders and organizations should be included in the budget.
               If omitted, the budget includes all usage that the billing account pays for. If the folder or organization
               contains projects that are paid for by a different Cloud Billing account, the budget doesn't apply to those projects.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] services: A set of services of the form services/{service_id},
               specifying that usage from only this set of services should be
               included in the budget. If omitted, the report will include
               usage for all the services. The service names are available
               through the Catalog API:
               https://cloud.google.com/billing/v1/how-tos/catalog-api.
        :param pulumi.Input[Sequence[pulumi.Input[builtins.str]]] subaccounts: A set of subaccounts of the form billingAccounts/{account_id},
               specifying that usage from only this set of subaccounts should
               be included in the budget. If a subaccount is set to the name of
               the parent account, usage from the parent account will be included.
               If the field is omitted, the report will include usage from the parent
               account and all subaccounts, if they exist.
               **Note:** If the field has a value in the config and needs to be removed, the field has to be an empty array in the config.
        """
        if calendar_period is not None:
            pulumi.set(__self__, "calendar_period", calendar_period)
        if credit_types is not None:
            pulumi.set(__self__, "credit_types", credit_types)
        if credit_types_treatment is not None:
            pulumi.set(__self__, "credit_types_treatment", credit_types_treatment)
        if custom_period is not None:
            pulumi.set(__self__, "custom_period", custom_period)
        if labels is not None:
            pulumi.set(__self__, "labels", labels)
        if projects is not None:
            pulumi.set(__self__, "projects", projects)
        if resource_ancestors is not None:
            pulumi.set(__self__, "resource_ancestors", resource_ancestors)
        if services is not None:
            pulumi.set(__self__, "services", services)
        if subaccounts is not None:
            pulumi.set(__self__, "subaccounts", subaccounts)

    @property
    @pulumi.getter(name="calendarPeriod")
    def calendar_period(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        A CalendarPeriod represents the abstract concept of a recurring time period that has a
        canonical start. Grammatically, "the start of the current CalendarPeriod".
        All calendar times begin at 12 AM US and Canadian Pacific Time (UTC-8).
        Exactly one of `calendar_period`, `custom_period` must be provided.
        Possible values are: `MONTH`, `QUARTER`, `YEAR`, `CALENDAR_PERIOD_UNSPECIFIED`.
        """
        return pulumi.get(self, "calendar_period")

    @calendar_period.setter
    def calendar_period(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "calendar_period", value)

    @property
    @pulumi.getter(name="creditTypes")
    def credit_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        Optional. If creditTypesTreatment is INCLUDE_SPECIFIED_CREDITS,
        this is a list of credit types to be subtracted from gross cost to determine the spend for threshold calculations. See a list of acceptable credit type values.
        If creditTypesTreatment is not INCLUDE_SPECIFIED_CREDITS, this field must be empty.
        **Note:** If the field has a value in the config and needs to be removed, the field has to be an empty array in the config.
        """
        return pulumi.get(self, "credit_types")

    @credit_types.setter
    def credit_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "credit_types", value)

    @property
    @pulumi.getter(name="creditTypesTreatment")
    def credit_types_treatment(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        Specifies how credits should be treated when determining spend
        for threshold calculations.
        Default value is `INCLUDE_ALL_CREDITS`.
        Possible values are: `INCLUDE_ALL_CREDITS`, `EXCLUDE_ALL_CREDITS`, `INCLUDE_SPECIFIED_CREDITS`.
        """
        return pulumi.get(self, "credit_types_treatment")

    @credit_types_treatment.setter
    def credit_types_treatment(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "credit_types_treatment", value)

    @property
    @pulumi.getter(name="customPeriod")
    def custom_period(self) -> Optional[pulumi.Input['BudgetBudgetFilterCustomPeriodArgs']]:
        """
        Specifies to track usage from any start date (required) to any end date (optional).
        This time period is static, it does not recur.
        Exactly one of `calendar_period`, `custom_period` must be provided.
        Structure is documented below.
        """
        return pulumi.get(self, "custom_period")

    @custom_period.setter
    def custom_period(self, value: Optional[pulumi.Input['BudgetBudgetFilterCustomPeriodArgs']]):
        pulumi.set(self, "custom_period", value)

    @property
    @pulumi.getter
    def labels(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]:
        """
        A single label and value pair specifying that usage from only
        this set of labeled resources should be included in the budget.
        """
        return pulumi.get(self, "labels")

    @labels.setter
    def labels(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "labels", value)

    @property
    @pulumi.getter
    def projects(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A set of projects of the form projects/{project_number},
        specifying that usage from only this set of projects should be
        included in the budget. If omitted, the report will include
        all usage for the billing account, regardless of which project
        the usage occurred on.
        """
        return pulumi.get(self, "projects")

    @projects.setter
    def projects(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "projects", value)

    @property
    @pulumi.getter(name="resourceAncestors")
    def resource_ancestors(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A set of folder and organization names of the form folders/{folderId} or organizations/{organizationId},
        specifying that usage from only this set of folders and organizations should be included in the budget.
        If omitted, the budget includes all usage that the billing account pays for. If the folder or organization
        contains projects that are paid for by a different Cloud Billing account, the budget doesn't apply to those projects.
        """
        return pulumi.get(self, "resource_ancestors")

    @resource_ancestors.setter
    def resource_ancestors(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "resource_ancestors", value)

    @property
    @pulumi.getter
    def services(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A set of services of the form services/{service_id},
        specifying that usage from only this set of services should be
        included in the budget. If omitted, the report will include
        usage for all the services. The service names are available
        through the Catalog API:
        https://cloud.google.com/billing/v1/how-tos/catalog-api.
        """
        return pulumi.get(self, "services")

    @services.setter
    def services(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "services", value)

    @property
    @pulumi.getter
    def subaccounts(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]:
        """
        A set of subaccounts of the form billingAccounts/{account_id},
        specifying that usage from only this set of subaccounts should
        be included in the budget. If a subaccount is set to the name of
        the parent account, usage from the parent account will be included.
        If the field is omitted, the report will include usage from the parent
        account and all subaccounts, if they exist.
        **Note:** If the field has a value in the config and needs to be removed, the field has to be an empty array in the config.
        """
        return pulumi.get(self, "subaccounts")

    @subaccounts.setter
    def subaccounts(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[builtins.str]]]]):
        pulumi.set(self, "subaccounts", value)


if not MYPY:
    class BudgetBudgetFilterCustomPeriodArgsDict(TypedDict):
        start_date: pulumi.Input['BudgetBudgetFilterCustomPeriodStartDateArgsDict']
        """
        A start date is required. The start date must be after January 1, 2017.
        Structure is documented below.
        """
        end_date: NotRequired[pulumi.Input['BudgetBudgetFilterCustomPeriodEndDateArgsDict']]
        """
        Optional. The end date of the time period. Budgets with elapsed end date won't be processed.
        If unset, specifies to track all usage incurred since the startDate.
        Structure is documented below.
        """
elif False:
    BudgetBudgetFilterCustomPeriodArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetBudgetFilterCustomPeriodArgs:
    def __init__(__self__, *,
                 start_date: pulumi.Input['BudgetBudgetFilterCustomPeriodStartDateArgs'],
                 end_date: Optional[pulumi.Input['BudgetBudgetFilterCustomPeriodEndDateArgs']] = None):
        """
        :param pulumi.Input['BudgetBudgetFilterCustomPeriodStartDateArgs'] start_date: A start date is required. The start date must be after January 1, 2017.
               Structure is documented below.
        :param pulumi.Input['BudgetBudgetFilterCustomPeriodEndDateArgs'] end_date: Optional. The end date of the time period. Budgets with elapsed end date won't be processed.
               If unset, specifies to track all usage incurred since the startDate.
               Structure is documented below.
        """
        pulumi.set(__self__, "start_date", start_date)
        if end_date is not None:
            pulumi.set(__self__, "end_date", end_date)

    @property
    @pulumi.getter(name="startDate")
    def start_date(self) -> pulumi.Input['BudgetBudgetFilterCustomPeriodStartDateArgs']:
        """
        A start date is required. The start date must be after January 1, 2017.
        Structure is documented below.
        """
        return pulumi.get(self, "start_date")

    @start_date.setter
    def start_date(self, value: pulumi.Input['BudgetBudgetFilterCustomPeriodStartDateArgs']):
        pulumi.set(self, "start_date", value)

    @property
    @pulumi.getter(name="endDate")
    def end_date(self) -> Optional[pulumi.Input['BudgetBudgetFilterCustomPeriodEndDateArgs']]:
        """
        Optional. The end date of the time period. Budgets with elapsed end date won't be processed.
        If unset, specifies to track all usage incurred since the startDate.
        Structure is documented below.
        """
        return pulumi.get(self, "end_date")

    @end_date.setter
    def end_date(self, value: Optional[pulumi.Input['BudgetBudgetFilterCustomPeriodEndDateArgs']]):
        pulumi.set(self, "end_date", value)


if not MYPY:
    class BudgetBudgetFilterCustomPeriodEndDateArgsDict(TypedDict):
        day: pulumi.Input[builtins.int]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month.
        """
        month: pulumi.Input[builtins.int]
        """
        Month of a year. Must be from 1 to 12.
        """
        year: pulumi.Input[builtins.int]
        """
        Year of the date. Must be from 1 to 9999.
        """
elif False:
    BudgetBudgetFilterCustomPeriodEndDateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetBudgetFilterCustomPeriodEndDateArgs:
    def __init__(__self__, *,
                 day: pulumi.Input[builtins.int],
                 month: pulumi.Input[builtins.int],
                 year: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.int] day: Day of a month. Must be from 1 to 31 and valid for the year and month.
        :param pulumi.Input[builtins.int] month: Month of a year. Must be from 1 to 12.
        :param pulumi.Input[builtins.int] year: Year of the date. Must be from 1 to 9999.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "month", month)
        pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> pulumi.Input[builtins.int]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> pulumi.Input[builtins.int]:
        """
        Month of a year. Must be from 1 to 12.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> pulumi.Input[builtins.int]:
        """
        Year of the date. Must be from 1 to 9999.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "year", value)


if not MYPY:
    class BudgetBudgetFilterCustomPeriodStartDateArgsDict(TypedDict):
        day: pulumi.Input[builtins.int]
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month.
        """
        month: pulumi.Input[builtins.int]
        """
        Month of a year. Must be from 1 to 12.
        """
        year: pulumi.Input[builtins.int]
        """
        Year of the date. Must be from 1 to 9999.
        """
elif False:
    BudgetBudgetFilterCustomPeriodStartDateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetBudgetFilterCustomPeriodStartDateArgs:
    def __init__(__self__, *,
                 day: pulumi.Input[builtins.int],
                 month: pulumi.Input[builtins.int],
                 year: pulumi.Input[builtins.int]):
        """
        :param pulumi.Input[builtins.int] day: Day of a month. Must be from 1 to 31 and valid for the year and month.
        :param pulumi.Input[builtins.int] month: Month of a year. Must be from 1 to 12.
        :param pulumi.Input[builtins.int] year: Year of the date. Must be from 1 to 9999.
        """
        pulumi.set(__self__, "day", day)
        pulumi.set(__self__, "month", month)
        pulumi.set(__self__, "year", year)

    @property
    @pulumi.getter
    def day(self) -> pulumi.Input[builtins.int]:
        """
        Day of a month. Must be from 1 to 31 and valid for the year and month.
        """
        return pulumi.get(self, "day")

    @day.setter
    def day(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "day", value)

    @property
    @pulumi.getter
    def month(self) -> pulumi.Input[builtins.int]:
        """
        Month of a year. Must be from 1 to 12.
        """
        return pulumi.get(self, "month")

    @month.setter
    def month(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "month", value)

    @property
    @pulumi.getter
    def year(self) -> pulumi.Input[builtins.int]:
        """
        Year of the date. Must be from 1 to 9999.
        """
        return pulumi.get(self, "year")

    @year.setter
    def year(self, value: pulumi.Input[builtins.int]):
        pulumi.set(self, "year", value)


if not MYPY:
    class BudgetThresholdRuleArgsDict(TypedDict):
        threshold_percent: pulumi.Input[builtins.float]
        """
        Send an alert when this threshold is exceeded. This is a
        1.0-based percentage, so 0.5 = 50%. Must be >= 0.
        """
        spend_basis: NotRequired[pulumi.Input[builtins.str]]
        """
        The type of basis used to determine if spend has passed
        the threshold.
        Default value is `CURRENT_SPEND`.
        Possible values are: `CURRENT_SPEND`, `FORECASTED_SPEND`.
        """
elif False:
    BudgetThresholdRuleArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class BudgetThresholdRuleArgs:
    def __init__(__self__, *,
                 threshold_percent: pulumi.Input[builtins.float],
                 spend_basis: Optional[pulumi.Input[builtins.str]] = None):
        """
        :param pulumi.Input[builtins.float] threshold_percent: Send an alert when this threshold is exceeded. This is a
               1.0-based percentage, so 0.5 = 50%. Must be >= 0.
        :param pulumi.Input[builtins.str] spend_basis: The type of basis used to determine if spend has passed
               the threshold.
               Default value is `CURRENT_SPEND`.
               Possible values are: `CURRENT_SPEND`, `FORECASTED_SPEND`.
        """
        pulumi.set(__self__, "threshold_percent", threshold_percent)
        if spend_basis is not None:
            pulumi.set(__self__, "spend_basis", spend_basis)

    @property
    @pulumi.getter(name="thresholdPercent")
    def threshold_percent(self) -> pulumi.Input[builtins.float]:
        """
        Send an alert when this threshold is exceeded. This is a
        1.0-based percentage, so 0.5 = 50%. Must be >= 0.
        """
        return pulumi.get(self, "threshold_percent")

    @threshold_percent.setter
    def threshold_percent(self, value: pulumi.Input[builtins.float]):
        pulumi.set(self, "threshold_percent", value)

    @property
    @pulumi.getter(name="spendBasis")
    def spend_basis(self) -> Optional[pulumi.Input[builtins.str]]:
        """
        The type of basis used to determine if spend has passed
        the threshold.
        Default value is `CURRENT_SPEND`.
        Possible values are: `CURRENT_SPEND`, `FORECASTED_SPEND`.
        """
        return pulumi.get(self, "spend_basis")

    @spend_basis.setter
    def spend_basis(self, value: Optional[pulumi.Input[builtins.str]]):
        pulumi.set(self, "spend_basis", value)


