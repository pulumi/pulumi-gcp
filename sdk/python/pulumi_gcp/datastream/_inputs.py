# coding=utf-8
# *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import copy
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'ConnectionProfileBigqueryProfileArgs',
    'ConnectionProfileBigqueryProfileArgsDict',
    'ConnectionProfileForwardSshConnectivityArgs',
    'ConnectionProfileForwardSshConnectivityArgsDict',
    'ConnectionProfileGcsProfileArgs',
    'ConnectionProfileGcsProfileArgsDict',
    'ConnectionProfileMysqlProfileArgs',
    'ConnectionProfileMysqlProfileArgsDict',
    'ConnectionProfileMysqlProfileSslConfigArgs',
    'ConnectionProfileMysqlProfileSslConfigArgsDict',
    'ConnectionProfileOracleProfileArgs',
    'ConnectionProfileOracleProfileArgsDict',
    'ConnectionProfilePostgresqlProfileArgs',
    'ConnectionProfilePostgresqlProfileArgsDict',
    'ConnectionProfilePrivateConnectivityArgs',
    'ConnectionProfilePrivateConnectivityArgsDict',
    'ConnectionProfileSqlServerProfileArgs',
    'ConnectionProfileSqlServerProfileArgsDict',
    'PrivateConnectionErrorArgs',
    'PrivateConnectionErrorArgsDict',
    'PrivateConnectionVpcPeeringConfigArgs',
    'PrivateConnectionVpcPeeringConfigArgsDict',
    'StreamBackfillAllArgs',
    'StreamBackfillAllArgsDict',
    'StreamBackfillAllMysqlExcludedObjectsArgs',
    'StreamBackfillAllMysqlExcludedObjectsArgsDict',
    'StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseArgs',
    'StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseArgsDict',
    'StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableArgs',
    'StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableArgsDict',
    'StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumnArgs',
    'StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumnArgsDict',
    'StreamBackfillAllOracleExcludedObjectsArgs',
    'StreamBackfillAllOracleExcludedObjectsArgsDict',
    'StreamBackfillAllOracleExcludedObjectsOracleSchemaArgs',
    'StreamBackfillAllOracleExcludedObjectsOracleSchemaArgsDict',
    'StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableArgs',
    'StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableArgsDict',
    'StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumnArgs',
    'StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumnArgsDict',
    'StreamBackfillAllPostgresqlExcludedObjectsArgs',
    'StreamBackfillAllPostgresqlExcludedObjectsArgsDict',
    'StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaArgs',
    'StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaArgsDict',
    'StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTableArgs',
    'StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTableArgsDict',
    'StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs',
    'StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgsDict',
    'StreamBackfillAllSqlServerExcludedObjectsArgs',
    'StreamBackfillAllSqlServerExcludedObjectsArgsDict',
    'StreamBackfillAllSqlServerExcludedObjectsSchemaArgs',
    'StreamBackfillAllSqlServerExcludedObjectsSchemaArgsDict',
    'StreamBackfillAllSqlServerExcludedObjectsSchemaTableArgs',
    'StreamBackfillAllSqlServerExcludedObjectsSchemaTableArgsDict',
    'StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumnArgs',
    'StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumnArgsDict',
    'StreamBackfillNoneArgs',
    'StreamBackfillNoneArgsDict',
    'StreamDestinationConfigArgs',
    'StreamDestinationConfigArgsDict',
    'StreamDestinationConfigBigqueryDestinationConfigArgs',
    'StreamDestinationConfigBigqueryDestinationConfigArgsDict',
    'StreamDestinationConfigBigqueryDestinationConfigSingleTargetDatasetArgs',
    'StreamDestinationConfigBigqueryDestinationConfigSingleTargetDatasetArgsDict',
    'StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsArgs',
    'StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsArgsDict',
    'StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplateArgs',
    'StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplateArgsDict',
    'StreamDestinationConfigGcsDestinationConfigArgs',
    'StreamDestinationConfigGcsDestinationConfigArgsDict',
    'StreamDestinationConfigGcsDestinationConfigAvroFileFormatArgs',
    'StreamDestinationConfigGcsDestinationConfigAvroFileFormatArgsDict',
    'StreamDestinationConfigGcsDestinationConfigJsonFileFormatArgs',
    'StreamDestinationConfigGcsDestinationConfigJsonFileFormatArgsDict',
    'StreamSourceConfigArgs',
    'StreamSourceConfigArgsDict',
    'StreamSourceConfigMysqlSourceConfigArgs',
    'StreamSourceConfigMysqlSourceConfigArgsDict',
    'StreamSourceConfigMysqlSourceConfigExcludeObjectsArgs',
    'StreamSourceConfigMysqlSourceConfigExcludeObjectsArgsDict',
    'StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseArgs',
    'StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseArgsDict',
    'StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableArgs',
    'StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableArgsDict',
    'StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgs',
    'StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgsDict',
    'StreamSourceConfigMysqlSourceConfigIncludeObjectsArgs',
    'StreamSourceConfigMysqlSourceConfigIncludeObjectsArgsDict',
    'StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseArgs',
    'StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseArgsDict',
    'StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableArgs',
    'StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableArgsDict',
    'StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgs',
    'StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgsDict',
    'StreamSourceConfigOracleSourceConfigArgs',
    'StreamSourceConfigOracleSourceConfigArgsDict',
    'StreamSourceConfigOracleSourceConfigDropLargeObjectsArgs',
    'StreamSourceConfigOracleSourceConfigDropLargeObjectsArgsDict',
    'StreamSourceConfigOracleSourceConfigExcludeObjectsArgs',
    'StreamSourceConfigOracleSourceConfigExcludeObjectsArgsDict',
    'StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaArgs',
    'StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaArgsDict',
    'StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableArgs',
    'StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableArgsDict',
    'StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumnArgs',
    'StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumnArgsDict',
    'StreamSourceConfigOracleSourceConfigIncludeObjectsArgs',
    'StreamSourceConfigOracleSourceConfigIncludeObjectsArgsDict',
    'StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaArgs',
    'StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaArgsDict',
    'StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableArgs',
    'StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableArgsDict',
    'StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumnArgs',
    'StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumnArgsDict',
    'StreamSourceConfigOracleSourceConfigStreamLargeObjectsArgs',
    'StreamSourceConfigOracleSourceConfigStreamLargeObjectsArgsDict',
    'StreamSourceConfigPostgresqlSourceConfigArgs',
    'StreamSourceConfigPostgresqlSourceConfigArgsDict',
    'StreamSourceConfigPostgresqlSourceConfigExcludeObjectsArgs',
    'StreamSourceConfigPostgresqlSourceConfigExcludeObjectsArgsDict',
    'StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaArgs',
    'StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaArgsDict',
    'StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTableArgs',
    'StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTableArgsDict',
    'StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs',
    'StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgsDict',
    'StreamSourceConfigPostgresqlSourceConfigIncludeObjectsArgs',
    'StreamSourceConfigPostgresqlSourceConfigIncludeObjectsArgsDict',
    'StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaArgs',
    'StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaArgsDict',
    'StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTableArgs',
    'StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTableArgsDict',
    'StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs',
    'StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgsDict',
    'StreamSourceConfigSqlServerSourceConfigArgs',
    'StreamSourceConfigSqlServerSourceConfigArgsDict',
    'StreamSourceConfigSqlServerSourceConfigExcludeObjectsArgs',
    'StreamSourceConfigSqlServerSourceConfigExcludeObjectsArgsDict',
    'StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaArgs',
    'StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaArgsDict',
    'StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableArgs',
    'StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableArgsDict',
    'StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumnArgs',
    'StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumnArgsDict',
    'StreamSourceConfigSqlServerSourceConfigIncludeObjectsArgs',
    'StreamSourceConfigSqlServerSourceConfigIncludeObjectsArgsDict',
    'StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaArgs',
    'StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaArgsDict',
    'StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableArgs',
    'StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableArgsDict',
    'StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumnArgs',
    'StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumnArgsDict',
]

MYPY = False

if not MYPY:
    class ConnectionProfileBigqueryProfileArgsDict(TypedDict):
        pass
elif False:
    ConnectionProfileBigqueryProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionProfileBigqueryProfileArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class ConnectionProfileForwardSshConnectivityArgsDict(TypedDict):
        hostname: pulumi.Input[str]
        """
        Hostname for the SSH tunnel.
        """
        username: pulumi.Input[str]
        """
        Username for the SSH tunnel.
        """
        password: NotRequired[pulumi.Input[str]]
        """
        SSH password.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port for the SSH tunnel.
        """
        private_key: NotRequired[pulumi.Input[str]]
        """
        SSH private key.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
elif False:
    ConnectionProfileForwardSshConnectivityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionProfileForwardSshConnectivityArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 username: pulumi.Input[str],
                 password: Optional[pulumi.Input[str]] = None,
                 port: Optional[pulumi.Input[int]] = None,
                 private_key: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] hostname: Hostname for the SSH tunnel.
        :param pulumi.Input[str] username: Username for the SSH tunnel.
        :param pulumi.Input[str] password: SSH password.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[int] port: Port for the SSH tunnel.
        :param pulumi.Input[str] private_key: SSH private key.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "username", username)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        Hostname for the SSH tunnel.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username for the SSH tunnel.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def password(self) -> Optional[pulumi.Input[str]]:
        """
        SSH password.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port for the SSH tunnel.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[pulumi.Input[str]]:
        """
        SSH private key.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "private_key")

    @private_key.setter
    def private_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "private_key", value)


if not MYPY:
    class ConnectionProfileGcsProfileArgsDict(TypedDict):
        bucket: pulumi.Input[str]
        """
        The Cloud Storage bucket name.
        """
        root_path: NotRequired[pulumi.Input[str]]
        """
        The root path inside the Cloud Storage bucket.
        """
elif False:
    ConnectionProfileGcsProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionProfileGcsProfileArgs:
    def __init__(__self__, *,
                 bucket: pulumi.Input[str],
                 root_path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] bucket: The Cloud Storage bucket name.
        :param pulumi.Input[str] root_path: The root path inside the Cloud Storage bucket.
        """
        pulumi.set(__self__, "bucket", bucket)
        if root_path is not None:
            pulumi.set(__self__, "root_path", root_path)

    @property
    @pulumi.getter
    def bucket(self) -> pulumi.Input[str]:
        """
        The Cloud Storage bucket name.
        """
        return pulumi.get(self, "bucket")

    @bucket.setter
    def bucket(self, value: pulumi.Input[str]):
        pulumi.set(self, "bucket", value)

    @property
    @pulumi.getter(name="rootPath")
    def root_path(self) -> Optional[pulumi.Input[str]]:
        """
        The root path inside the Cloud Storage bucket.
        """
        return pulumi.get(self, "root_path")

    @root_path.setter
    def root_path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "root_path", value)


if not MYPY:
    class ConnectionProfileMysqlProfileArgsDict(TypedDict):
        hostname: pulumi.Input[str]
        """
        Hostname for the MySQL connection.
        """
        password: pulumi.Input[str]
        """
        Password for the MySQL connection.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        username: pulumi.Input[str]
        """
        Username for the MySQL connection.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port for the MySQL connection.
        """
        ssl_config: NotRequired[pulumi.Input['ConnectionProfileMysqlProfileSslConfigArgsDict']]
        """
        SSL configuration for the MySQL connection.
        Structure is documented below.
        """
elif False:
    ConnectionProfileMysqlProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionProfileMysqlProfileArgs:
    def __init__(__self__, *,
                 hostname: pulumi.Input[str],
                 password: pulumi.Input[str],
                 username: pulumi.Input[str],
                 port: Optional[pulumi.Input[int]] = None,
                 ssl_config: Optional[pulumi.Input['ConnectionProfileMysqlProfileSslConfigArgs']] = None):
        """
        :param pulumi.Input[str] hostname: Hostname for the MySQL connection.
        :param pulumi.Input[str] password: Password for the MySQL connection.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[str] username: Username for the MySQL connection.
        :param pulumi.Input[int] port: Port for the MySQL connection.
        :param pulumi.Input['ConnectionProfileMysqlProfileSslConfigArgs'] ssl_config: SSL configuration for the MySQL connection.
               Structure is documented below.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if ssl_config is not None:
            pulumi.set(__self__, "ssl_config", ssl_config)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        Hostname for the MySQL connection.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Password for the MySQL connection.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username for the MySQL connection.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port for the MySQL connection.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)

    @property
    @pulumi.getter(name="sslConfig")
    def ssl_config(self) -> Optional[pulumi.Input['ConnectionProfileMysqlProfileSslConfigArgs']]:
        """
        SSL configuration for the MySQL connection.
        Structure is documented below.
        """
        return pulumi.get(self, "ssl_config")

    @ssl_config.setter
    def ssl_config(self, value: Optional[pulumi.Input['ConnectionProfileMysqlProfileSslConfigArgs']]):
        pulumi.set(self, "ssl_config", value)


if not MYPY:
    class ConnectionProfileMysqlProfileSslConfigArgsDict(TypedDict):
        ca_certificate: NotRequired[pulumi.Input[str]]
        """
        PEM-encoded certificate of the CA that signed the source database
        server's certificate.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        ca_certificate_set: NotRequired[pulumi.Input[bool]]
        """
        (Output)
        Indicates whether the clientKey field is set.
        """
        client_certificate: NotRequired[pulumi.Input[str]]
        """
        PEM-encoded certificate that will be used by the replica to
        authenticate against the source database server. If this field
        is used then the 'clientKey' and the 'caCertificate' fields are
        mandatory.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        client_certificate_set: NotRequired[pulumi.Input[bool]]
        """
        (Output)
        Indicates whether the clientCertificate field is set.
        """
        client_key: NotRequired[pulumi.Input[str]]
        """
        PEM-encoded private key associated with the Client Certificate.
        If this field is used then the 'client_certificate' and the
        'ca_certificate' fields are mandatory.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        client_key_set: NotRequired[pulumi.Input[bool]]
        """
        (Output)
        Indicates whether the clientKey field is set.
        """
elif False:
    ConnectionProfileMysqlProfileSslConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionProfileMysqlProfileSslConfigArgs:
    def __init__(__self__, *,
                 ca_certificate: Optional[pulumi.Input[str]] = None,
                 ca_certificate_set: Optional[pulumi.Input[bool]] = None,
                 client_certificate: Optional[pulumi.Input[str]] = None,
                 client_certificate_set: Optional[pulumi.Input[bool]] = None,
                 client_key: Optional[pulumi.Input[str]] = None,
                 client_key_set: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] ca_certificate: PEM-encoded certificate of the CA that signed the source database
               server's certificate.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[bool] ca_certificate_set: (Output)
               Indicates whether the clientKey field is set.
        :param pulumi.Input[str] client_certificate: PEM-encoded certificate that will be used by the replica to
               authenticate against the source database server. If this field
               is used then the 'clientKey' and the 'caCertificate' fields are
               mandatory.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[bool] client_certificate_set: (Output)
               Indicates whether the clientCertificate field is set.
        :param pulumi.Input[str] client_key: PEM-encoded private key associated with the Client Certificate.
               If this field is used then the 'client_certificate' and the
               'ca_certificate' fields are mandatory.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[bool] client_key_set: (Output)
               Indicates whether the clientKey field is set.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if ca_certificate_set is not None:
            pulumi.set(__self__, "ca_certificate_set", ca_certificate_set)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_certificate_set is not None:
            pulumi.set(__self__, "client_certificate_set", client_certificate_set)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_key_set is not None:
            pulumi.set(__self__, "client_key_set", client_key_set)

    @property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        PEM-encoded certificate of the CA that signed the source database
        server's certificate.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "ca_certificate")

    @ca_certificate.setter
    def ca_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "ca_certificate", value)

    @property
    @pulumi.getter(name="caCertificateSet")
    def ca_certificate_set(self) -> Optional[pulumi.Input[bool]]:
        """
        (Output)
        Indicates whether the clientKey field is set.
        """
        return pulumi.get(self, "ca_certificate_set")

    @ca_certificate_set.setter
    def ca_certificate_set(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "ca_certificate_set", value)

    @property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[pulumi.Input[str]]:
        """
        PEM-encoded certificate that will be used by the replica to
        authenticate against the source database server. If this field
        is used then the 'clientKey' and the 'caCertificate' fields are
        mandatory.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "client_certificate")

    @client_certificate.setter
    def client_certificate(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_certificate", value)

    @property
    @pulumi.getter(name="clientCertificateSet")
    def client_certificate_set(self) -> Optional[pulumi.Input[bool]]:
        """
        (Output)
        Indicates whether the clientCertificate field is set.
        """
        return pulumi.get(self, "client_certificate_set")

    @client_certificate_set.setter
    def client_certificate_set(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "client_certificate_set", value)

    @property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[pulumi.Input[str]]:
        """
        PEM-encoded private key associated with the Client Certificate.
        If this field is used then the 'client_certificate' and the
        'ca_certificate' fields are mandatory.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "client_key")

    @client_key.setter
    def client_key(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "client_key", value)

    @property
    @pulumi.getter(name="clientKeySet")
    def client_key_set(self) -> Optional[pulumi.Input[bool]]:
        """
        (Output)
        Indicates whether the clientKey field is set.
        """
        return pulumi.get(self, "client_key_set")

    @client_key_set.setter
    def client_key_set(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "client_key_set", value)


if not MYPY:
    class ConnectionProfileOracleProfileArgsDict(TypedDict):
        database_service: pulumi.Input[str]
        """
        Database for the Oracle connection.
        """
        hostname: pulumi.Input[str]
        """
        Hostname for the Oracle connection.
        """
        password: pulumi.Input[str]
        """
        Password for the Oracle connection.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        username: pulumi.Input[str]
        """
        Username for the Oracle connection.
        """
        connection_attributes: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        Connection string attributes
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port for the Oracle connection.
        """
elif False:
    ConnectionProfileOracleProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionProfileOracleProfileArgs:
    def __init__(__self__, *,
                 database_service: pulumi.Input[str],
                 hostname: pulumi.Input[str],
                 password: pulumi.Input[str],
                 username: pulumi.Input[str],
                 connection_attributes: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] database_service: Database for the Oracle connection.
        :param pulumi.Input[str] hostname: Hostname for the Oracle connection.
        :param pulumi.Input[str] password: Password for the Oracle connection.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[str] username: Username for the Oracle connection.
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] connection_attributes: Connection string attributes
        :param pulumi.Input[int] port: Port for the Oracle connection.
        """
        pulumi.set(__self__, "database_service", database_service)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if connection_attributes is not None:
            pulumi.set(__self__, "connection_attributes", connection_attributes)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter(name="databaseService")
    def database_service(self) -> pulumi.Input[str]:
        """
        Database for the Oracle connection.
        """
        return pulumi.get(self, "database_service")

    @database_service.setter
    def database_service(self, value: pulumi.Input[str]):
        pulumi.set(self, "database_service", value)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        Hostname for the Oracle connection.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Password for the Oracle connection.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username for the Oracle connection.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter(name="connectionAttributes")
    def connection_attributes(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        Connection string attributes
        """
        return pulumi.get(self, "connection_attributes")

    @connection_attributes.setter
    def connection_attributes(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "connection_attributes", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port for the Oracle connection.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ConnectionProfilePostgresqlProfileArgsDict(TypedDict):
        database: pulumi.Input[str]
        """
        Database for the PostgreSQL connection.
        """
        hostname: pulumi.Input[str]
        """
        Hostname for the PostgreSQL connection.
        """
        password: pulumi.Input[str]
        """
        Password for the PostgreSQL connection.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        username: pulumi.Input[str]
        """
        Username for the PostgreSQL connection.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port for the PostgreSQL connection.
        """
elif False:
    ConnectionProfilePostgresqlProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionProfilePostgresqlProfileArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 hostname: pulumi.Input[str],
                 password: pulumi.Input[str],
                 username: pulumi.Input[str],
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] database: Database for the PostgreSQL connection.
        :param pulumi.Input[str] hostname: Hostname for the PostgreSQL connection.
        :param pulumi.Input[str] password: Password for the PostgreSQL connection.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[str] username: Username for the PostgreSQL connection.
        :param pulumi.Input[int] port: Port for the PostgreSQL connection.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Database for the PostgreSQL connection.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        Hostname for the PostgreSQL connection.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Password for the PostgreSQL connection.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username for the PostgreSQL connection.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port for the PostgreSQL connection.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class ConnectionProfilePrivateConnectivityArgsDict(TypedDict):
        private_connection: pulumi.Input[str]
        """
        A reference to a private connection resource. Format: `projects/{project}/locations/{location}/privateConnections/{name}`
        """
elif False:
    ConnectionProfilePrivateConnectivityArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionProfilePrivateConnectivityArgs:
    def __init__(__self__, *,
                 private_connection: pulumi.Input[str]):
        """
        :param pulumi.Input[str] private_connection: A reference to a private connection resource. Format: `projects/{project}/locations/{location}/privateConnections/{name}`
        """
        pulumi.set(__self__, "private_connection", private_connection)

    @property
    @pulumi.getter(name="privateConnection")
    def private_connection(self) -> pulumi.Input[str]:
        """
        A reference to a private connection resource. Format: `projects/{project}/locations/{location}/privateConnections/{name}`
        """
        return pulumi.get(self, "private_connection")

    @private_connection.setter
    def private_connection(self, value: pulumi.Input[str]):
        pulumi.set(self, "private_connection", value)


if not MYPY:
    class ConnectionProfileSqlServerProfileArgsDict(TypedDict):
        database: pulumi.Input[str]
        """
        Database for the SQL Server connection.
        """
        hostname: pulumi.Input[str]
        """
        Hostname for the SQL Server connection.
        """
        password: pulumi.Input[str]
        """
        Password for the SQL Server connection.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        username: pulumi.Input[str]
        """
        Username for the SQL Server connection.
        """
        port: NotRequired[pulumi.Input[int]]
        """
        Port for the SQL Server connection.
        """
elif False:
    ConnectionProfileSqlServerProfileArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ConnectionProfileSqlServerProfileArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 hostname: pulumi.Input[str],
                 password: pulumi.Input[str],
                 username: pulumi.Input[str],
                 port: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] database: Database for the SQL Server connection.
        :param pulumi.Input[str] hostname: Hostname for the SQL Server connection.
        :param pulumi.Input[str] password: Password for the SQL Server connection.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[str] username: Username for the SQL Server connection.
        :param pulumi.Input[int] port: Port for the SQL Server connection.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "password", password)
        pulumi.set(__self__, "username", username)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Database for the SQL Server connection.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter
    def hostname(self) -> pulumi.Input[str]:
        """
        Hostname for the SQL Server connection.
        """
        return pulumi.get(self, "hostname")

    @hostname.setter
    def hostname(self, value: pulumi.Input[str]):
        pulumi.set(self, "hostname", value)

    @property
    @pulumi.getter
    def password(self) -> pulumi.Input[str]:
        """
        Password for the SQL Server connection.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "password")

    @password.setter
    def password(self, value: pulumi.Input[str]):
        pulumi.set(self, "password", value)

    @property
    @pulumi.getter
    def username(self) -> pulumi.Input[str]:
        """
        Username for the SQL Server connection.
        """
        return pulumi.get(self, "username")

    @username.setter
    def username(self, value: pulumi.Input[str]):
        pulumi.set(self, "username", value)

    @property
    @pulumi.getter
    def port(self) -> Optional[pulumi.Input[int]]:
        """
        Port for the SQL Server connection.
        """
        return pulumi.get(self, "port")

    @port.setter
    def port(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "port", value)


if not MYPY:
    class PrivateConnectionErrorArgsDict(TypedDict):
        details: NotRequired[pulumi.Input[Mapping[str, pulumi.Input[str]]]]
        """
        A list of messages that carry the error details.
        """
        message: NotRequired[pulumi.Input[str]]
        """
        A message containing more information about the error that occurred.
        """
elif False:
    PrivateConnectionErrorArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateConnectionErrorArgs:
    def __init__(__self__, *,
                 details: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]] = None,
                 message: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[Mapping[str, pulumi.Input[str]]] details: A list of messages that carry the error details.
        :param pulumi.Input[str] message: A message containing more information about the error that occurred.
        """
        if details is not None:
            pulumi.set(__self__, "details", details)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @property
    @pulumi.getter
    def details(self) -> Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]:
        """
        A list of messages that carry the error details.
        """
        return pulumi.get(self, "details")

    @details.setter
    def details(self, value: Optional[pulumi.Input[Mapping[str, pulumi.Input[str]]]]):
        pulumi.set(self, "details", value)

    @property
    @pulumi.getter
    def message(self) -> Optional[pulumi.Input[str]]:
        """
        A message containing more information about the error that occurred.
        """
        return pulumi.get(self, "message")

    @message.setter
    def message(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "message", value)


if not MYPY:
    class PrivateConnectionVpcPeeringConfigArgsDict(TypedDict):
        subnet: pulumi.Input[str]
        """
        A free subnet for peering. (CIDR of /29)

        - - -
        """
        vpc: pulumi.Input[str]
        """
        Fully qualified name of the VPC that Datastream will peer to.
        Format: projects/{project}/global/{networks}/{name}
        """
elif False:
    PrivateConnectionVpcPeeringConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class PrivateConnectionVpcPeeringConfigArgs:
    def __init__(__self__, *,
                 subnet: pulumi.Input[str],
                 vpc: pulumi.Input[str]):
        """
        :param pulumi.Input[str] subnet: A free subnet for peering. (CIDR of /29)
               
               - - -
        :param pulumi.Input[str] vpc: Fully qualified name of the VPC that Datastream will peer to.
               Format: projects/{project}/global/{networks}/{name}
        """
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "vpc", vpc)

    @property
    @pulumi.getter
    def subnet(self) -> pulumi.Input[str]:
        """
        A free subnet for peering. (CIDR of /29)

        - - -
        """
        return pulumi.get(self, "subnet")

    @subnet.setter
    def subnet(self, value: pulumi.Input[str]):
        pulumi.set(self, "subnet", value)

    @property
    @pulumi.getter
    def vpc(self) -> pulumi.Input[str]:
        """
        Fully qualified name of the VPC that Datastream will peer to.
        Format: projects/{project}/global/{networks}/{name}
        """
        return pulumi.get(self, "vpc")

    @vpc.setter
    def vpc(self, value: pulumi.Input[str]):
        pulumi.set(self, "vpc", value)


if not MYPY:
    class StreamBackfillAllArgsDict(TypedDict):
        mysql_excluded_objects: NotRequired[pulumi.Input['StreamBackfillAllMysqlExcludedObjectsArgsDict']]
        """
        MySQL data source objects to avoid backfilling.
        Structure is documented below.
        """
        oracle_excluded_objects: NotRequired[pulumi.Input['StreamBackfillAllOracleExcludedObjectsArgsDict']]
        """
        PostgreSQL data source objects to avoid backfilling.
        Structure is documented below.
        """
        postgresql_excluded_objects: NotRequired[pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsArgsDict']]
        """
        PostgreSQL data source objects to avoid backfilling.
        Structure is documented below.
        """
        sql_server_excluded_objects: NotRequired[pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsArgsDict']]
        """
        SQL Server data source objects to avoid backfilling.
        Structure is documented below.
        """
elif False:
    StreamBackfillAllArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamBackfillAllArgs:
    def __init__(__self__, *,
                 mysql_excluded_objects: Optional[pulumi.Input['StreamBackfillAllMysqlExcludedObjectsArgs']] = None,
                 oracle_excluded_objects: Optional[pulumi.Input['StreamBackfillAllOracleExcludedObjectsArgs']] = None,
                 postgresql_excluded_objects: Optional[pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsArgs']] = None,
                 sql_server_excluded_objects: Optional[pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsArgs']] = None):
        """
        :param pulumi.Input['StreamBackfillAllMysqlExcludedObjectsArgs'] mysql_excluded_objects: MySQL data source objects to avoid backfilling.
               Structure is documented below.
        :param pulumi.Input['StreamBackfillAllOracleExcludedObjectsArgs'] oracle_excluded_objects: PostgreSQL data source objects to avoid backfilling.
               Structure is documented below.
        :param pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsArgs'] postgresql_excluded_objects: PostgreSQL data source objects to avoid backfilling.
               Structure is documented below.
        :param pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsArgs'] sql_server_excluded_objects: SQL Server data source objects to avoid backfilling.
               Structure is documented below.
        """
        if mysql_excluded_objects is not None:
            pulumi.set(__self__, "mysql_excluded_objects", mysql_excluded_objects)
        if oracle_excluded_objects is not None:
            pulumi.set(__self__, "oracle_excluded_objects", oracle_excluded_objects)
        if postgresql_excluded_objects is not None:
            pulumi.set(__self__, "postgresql_excluded_objects", postgresql_excluded_objects)
        if sql_server_excluded_objects is not None:
            pulumi.set(__self__, "sql_server_excluded_objects", sql_server_excluded_objects)

    @property
    @pulumi.getter(name="mysqlExcludedObjects")
    def mysql_excluded_objects(self) -> Optional[pulumi.Input['StreamBackfillAllMysqlExcludedObjectsArgs']]:
        """
        MySQL data source objects to avoid backfilling.
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_excluded_objects")

    @mysql_excluded_objects.setter
    def mysql_excluded_objects(self, value: Optional[pulumi.Input['StreamBackfillAllMysqlExcludedObjectsArgs']]):
        pulumi.set(self, "mysql_excluded_objects", value)

    @property
    @pulumi.getter(name="oracleExcludedObjects")
    def oracle_excluded_objects(self) -> Optional[pulumi.Input['StreamBackfillAllOracleExcludedObjectsArgs']]:
        """
        PostgreSQL data source objects to avoid backfilling.
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_excluded_objects")

    @oracle_excluded_objects.setter
    def oracle_excluded_objects(self, value: Optional[pulumi.Input['StreamBackfillAllOracleExcludedObjectsArgs']]):
        pulumi.set(self, "oracle_excluded_objects", value)

    @property
    @pulumi.getter(name="postgresqlExcludedObjects")
    def postgresql_excluded_objects(self) -> Optional[pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsArgs']]:
        """
        PostgreSQL data source objects to avoid backfilling.
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_excluded_objects")

    @postgresql_excluded_objects.setter
    def postgresql_excluded_objects(self, value: Optional[pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsArgs']]):
        pulumi.set(self, "postgresql_excluded_objects", value)

    @property
    @pulumi.getter(name="sqlServerExcludedObjects")
    def sql_server_excluded_objects(self) -> Optional[pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsArgs']]:
        """
        SQL Server data source objects to avoid backfilling.
        Structure is documented below.
        """
        return pulumi.get(self, "sql_server_excluded_objects")

    @sql_server_excluded_objects.setter
    def sql_server_excluded_objects(self, value: Optional[pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsArgs']]):
        pulumi.set(self, "sql_server_excluded_objects", value)


if not MYPY:
    class StreamBackfillAllMysqlExcludedObjectsArgsDict(TypedDict):
        mysql_databases: pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseArgsDict']]]
        """
        MySQL databases on the server
        Structure is documented below.
        """
elif False:
    StreamBackfillAllMysqlExcludedObjectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamBackfillAllMysqlExcludedObjectsArgs:
    def __init__(__self__, *,
                 mysql_databases: pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseArgs']]] mysql_databases: MySQL databases on the server
               Structure is documented below.
        """
        pulumi.set(__self__, "mysql_databases", mysql_databases)

    @property
    @pulumi.getter(name="mysqlDatabases")
    def mysql_databases(self) -> pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseArgs']]]:
        """
        MySQL databases on the server
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_databases")

    @mysql_databases.setter
    def mysql_databases(self, value: pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseArgs']]]):
        pulumi.set(self, "mysql_databases", value)


if not MYPY:
    class StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseArgsDict(TypedDict):
        database: pulumi.Input[str]
        """
        Database name.
        """
        mysql_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableArgsDict']]]]
        """
        Tables in the database.
        Structure is documented below.
        """
elif False:
    StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 mysql_tables: Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableArgs']]]] = None):
        """
        :param pulumi.Input[str] database: Database name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableArgs']]] mysql_tables: Tables in the database.
               Structure is documented below.
        """
        pulumi.set(__self__, "database", database)
        if mysql_tables is not None:
            pulumi.set(__self__, "mysql_tables", mysql_tables)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Database name.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="mysqlTables")
    def mysql_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableArgs']]]]:
        """
        Tables in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_tables")

    @mysql_tables.setter
    def mysql_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableArgs']]]]):
        pulumi.set(self, "mysql_tables", value)


if not MYPY:
    class StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableArgsDict(TypedDict):
        table: pulumi.Input[str]
        """
        Table name.
        """
        mysql_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumnArgsDict']]]]
        """
        MySQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
elif False:
    StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableArgs:
    def __init__(__self__, *,
                 table: pulumi.Input[str],
                 mysql_columns: Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumnArgs']]]] = None):
        """
        :param pulumi.Input[str] table: Table name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumnArgs']]] mysql_columns: MySQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if mysql_columns is not None:
            pulumi.set(__self__, "mysql_columns", mysql_columns)

    @property
    @pulumi.getter
    def table(self) -> pulumi.Input[str]:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: pulumi.Input[str]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="mysqlColumns")
    def mysql_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumnArgs']]]]:
        """
        MySQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_columns")

    @mysql_columns.setter
    def mysql_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumnArgs']]]]):
        pulumi.set(self, "mysql_columns", value)


if not MYPY:
    class StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumnArgsDict(TypedDict):
        collation: NotRequired[pulumi.Input[str]]
        """
        Column collation.
        """
        column: NotRequired[pulumi.Input[str]]
        """
        Column name.
        """
        data_type: NotRequired[pulumi.Input[str]]
        """
        The MySQL data type. Full data types list can be found here:
        https://dev.mysql.com/doc/refman/8.0/en/data-types.html
        """
        length: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column length.
        """
        nullable: NotRequired[pulumi.Input[bool]]
        """
        Whether or not the column can accept a null value.
        """
        ordinal_position: NotRequired[pulumi.Input[int]]
        """
        The ordinal position of the column in the table.
        """
        primary_key: NotRequired[pulumi.Input[bool]]
        """
        Whether or not the column represents a primary key.
        """
elif False:
    StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumnArgs:
    def __init__(__self__, *,
                 collation: Optional[pulumi.Input[str]] = None,
                 column: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 length: Optional[pulumi.Input[int]] = None,
                 nullable: Optional[pulumi.Input[bool]] = None,
                 ordinal_position: Optional[pulumi.Input[int]] = None,
                 primary_key: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] collation: Column collation.
        :param pulumi.Input[str] column: Column name.
        :param pulumi.Input[str] data_type: The MySQL data type. Full data types list can be found here:
               https://dev.mysql.com/doc/refman/8.0/en/data-types.html
        :param pulumi.Input[int] length: (Output)
               Column length.
        :param pulumi.Input[bool] nullable: Whether or not the column can accept a null value.
        :param pulumi.Input[int] ordinal_position: The ordinal position of the column in the table.
        :param pulumi.Input[bool] primary_key: Whether or not the column represents a primary key.
        """
        if collation is not None:
            pulumi.set(__self__, "collation", collation)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)

    @property
    @pulumi.getter
    def collation(self) -> Optional[pulumi.Input[str]]:
        """
        Column collation.
        """
        return pulumi.get(self, "collation")

    @collation.setter
    def collation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collation", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[str]]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        The MySQL data type. Full data types list can be found here:
        https://dev.mysql.com/doc/refman/8.0/en/data-types.html
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nullable", value)

    @property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[pulumi.Input[int]]:
        """
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @ordinal_position.setter
    def ordinal_position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ordinal_position", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary_key", value)


if not MYPY:
    class StreamBackfillAllOracleExcludedObjectsArgsDict(TypedDict):
        oracle_schemas: pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllOracleExcludedObjectsOracleSchemaArgsDict']]]
        """
        Oracle schemas/databases in the database server
        Structure is documented below.
        """
elif False:
    StreamBackfillAllOracleExcludedObjectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamBackfillAllOracleExcludedObjectsArgs:
    def __init__(__self__, *,
                 oracle_schemas: pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllOracleExcludedObjectsOracleSchemaArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllOracleExcludedObjectsOracleSchemaArgs']]] oracle_schemas: Oracle schemas/databases in the database server
               Structure is documented below.
        """
        pulumi.set(__self__, "oracle_schemas", oracle_schemas)

    @property
    @pulumi.getter(name="oracleSchemas")
    def oracle_schemas(self) -> pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllOracleExcludedObjectsOracleSchemaArgs']]]:
        """
        Oracle schemas/databases in the database server
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_schemas")

    @oracle_schemas.setter
    def oracle_schemas(self, value: pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllOracleExcludedObjectsOracleSchemaArgs']]]):
        pulumi.set(self, "oracle_schemas", value)


if not MYPY:
    class StreamBackfillAllOracleExcludedObjectsOracleSchemaArgsDict(TypedDict):
        schema: pulumi.Input[str]
        """
        Schema name.
        """
        oracle_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableArgsDict']]]]
        """
        Tables in the database.
        Structure is documented below.
        """
elif False:
    StreamBackfillAllOracleExcludedObjectsOracleSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamBackfillAllOracleExcludedObjectsOracleSchemaArgs:
    def __init__(__self__, *,
                 schema: pulumi.Input[str],
                 oracle_tables: Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableArgs']]]] = None):
        """
        :param pulumi.Input[str] schema: Schema name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableArgs']]] oracle_tables: Tables in the database.
               Structure is documented below.
        """
        pulumi.set(__self__, "schema", schema)
        if oracle_tables is not None:
            pulumi.set(__self__, "oracle_tables", oracle_tables)

    @property
    @pulumi.getter
    def schema(self) -> pulumi.Input[str]:
        """
        Schema name.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input[str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="oracleTables")
    def oracle_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableArgs']]]]:
        """
        Tables in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_tables")

    @oracle_tables.setter
    def oracle_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableArgs']]]]):
        pulumi.set(self, "oracle_tables", value)


if not MYPY:
    class StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableArgsDict(TypedDict):
        table: pulumi.Input[str]
        """
        Table name.
        """
        oracle_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumnArgsDict']]]]
        """
        Oracle columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
elif False:
    StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableArgs:
    def __init__(__self__, *,
                 table: pulumi.Input[str],
                 oracle_columns: Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumnArgs']]]] = None):
        """
        :param pulumi.Input[str] table: Table name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumnArgs']]] oracle_columns: Oracle columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if oracle_columns is not None:
            pulumi.set(__self__, "oracle_columns", oracle_columns)

    @property
    @pulumi.getter
    def table(self) -> pulumi.Input[str]:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: pulumi.Input[str]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="oracleColumns")
    def oracle_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumnArgs']]]]:
        """
        Oracle columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_columns")

    @oracle_columns.setter
    def oracle_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumnArgs']]]]):
        pulumi.set(self, "oracle_columns", value)


if not MYPY:
    class StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumnArgsDict(TypedDict):
        column: NotRequired[pulumi.Input[str]]
        """
        Column name.
        """
        data_type: NotRequired[pulumi.Input[str]]
        """
        The Oracle data type. Full data types list can be found here:
        https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html
        """
        encoding: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Column encoding.
        """
        length: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column length.
        """
        nullable: NotRequired[pulumi.Input[bool]]
        """
        (Output)
        Whether or not the column can accept a null value.
        """
        ordinal_position: NotRequired[pulumi.Input[int]]
        """
        (Output)
        The ordinal position of the column in the table.
        """
        precision: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column precision.
        """
        primary_key: NotRequired[pulumi.Input[bool]]
        """
        (Output)
        Whether or not the column represents a primary key.
        """
        scale: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column scale.
        """
elif False:
    StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumnArgs:
    def __init__(__self__, *,
                 column: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 length: Optional[pulumi.Input[int]] = None,
                 nullable: Optional[pulumi.Input[bool]] = None,
                 ordinal_position: Optional[pulumi.Input[int]] = None,
                 precision: Optional[pulumi.Input[int]] = None,
                 primary_key: Optional[pulumi.Input[bool]] = None,
                 scale: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] column: Column name.
        :param pulumi.Input[str] data_type: The Oracle data type. Full data types list can be found here:
               https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html
        :param pulumi.Input[str] encoding: (Output)
               Column encoding.
        :param pulumi.Input[int] length: (Output)
               Column length.
        :param pulumi.Input[bool] nullable: (Output)
               Whether or not the column can accept a null value.
        :param pulumi.Input[int] ordinal_position: (Output)
               The ordinal position of the column in the table.
        :param pulumi.Input[int] precision: (Output)
               Column precision.
        :param pulumi.Input[bool] primary_key: (Output)
               Whether or not the column represents a primary key.
        :param pulumi.Input[int] scale: (Output)
               Column scale.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[str]]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle data type. Full data types list can be found here:
        https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Column encoding.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[bool]]:
        """
        (Output)
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nullable", value)

    @property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @ordinal_position.setter
    def ordinal_position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ordinal_position", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column precision.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[bool]]:
        """
        (Output)
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary_key", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column scale.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scale", value)


if not MYPY:
    class StreamBackfillAllPostgresqlExcludedObjectsArgsDict(TypedDict):
        postgresql_schemas: pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaArgsDict']]]
        """
        PostgreSQL schemas on the server
        Structure is documented below.
        """
elif False:
    StreamBackfillAllPostgresqlExcludedObjectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamBackfillAllPostgresqlExcludedObjectsArgs:
    def __init__(__self__, *,
                 postgresql_schemas: pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaArgs']]] postgresql_schemas: PostgreSQL schemas on the server
               Structure is documented below.
        """
        pulumi.set(__self__, "postgresql_schemas", postgresql_schemas)

    @property
    @pulumi.getter(name="postgresqlSchemas")
    def postgresql_schemas(self) -> pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaArgs']]]:
        """
        PostgreSQL schemas on the server
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_schemas")

    @postgresql_schemas.setter
    def postgresql_schemas(self, value: pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaArgs']]]):
        pulumi.set(self, "postgresql_schemas", value)


if not MYPY:
    class StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaArgsDict(TypedDict):
        schema: pulumi.Input[str]
        """
        Database name.
        """
        postgresql_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTableArgsDict']]]]
        """
        Tables in the schema.
        Structure is documented below.
        """
elif False:
    StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaArgs:
    def __init__(__self__, *,
                 schema: pulumi.Input[str],
                 postgresql_tables: Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTableArgs']]]] = None):
        """
        :param pulumi.Input[str] schema: Database name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTableArgs']]] postgresql_tables: Tables in the schema.
               Structure is documented below.
        """
        pulumi.set(__self__, "schema", schema)
        if postgresql_tables is not None:
            pulumi.set(__self__, "postgresql_tables", postgresql_tables)

    @property
    @pulumi.getter
    def schema(self) -> pulumi.Input[str]:
        """
        Database name.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input[str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="postgresqlTables")
    def postgresql_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTableArgs']]]]:
        """
        Tables in the schema.
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_tables")

    @postgresql_tables.setter
    def postgresql_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTableArgs']]]]):
        pulumi.set(self, "postgresql_tables", value)


if not MYPY:
    class StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTableArgsDict(TypedDict):
        table: pulumi.Input[str]
        """
        Table name.
        """
        postgresql_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgsDict']]]]
        """
        PostgreSQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
elif False:
    StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTableArgs:
    def __init__(__self__, *,
                 table: pulumi.Input[str],
                 postgresql_columns: Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs']]]] = None):
        """
        :param pulumi.Input[str] table: Table name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs']]] postgresql_columns: PostgreSQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if postgresql_columns is not None:
            pulumi.set(__self__, "postgresql_columns", postgresql_columns)

    @property
    @pulumi.getter
    def table(self) -> pulumi.Input[str]:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: pulumi.Input[str]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="postgresqlColumns")
    def postgresql_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs']]]]:
        """
        PostgreSQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_columns")

    @postgresql_columns.setter
    def postgresql_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs']]]]):
        pulumi.set(self, "postgresql_columns", value)


if not MYPY:
    class StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgsDict(TypedDict):
        column: NotRequired[pulumi.Input[str]]
        """
        Column name.
        """
        data_type: NotRequired[pulumi.Input[str]]
        """
        The PostgreSQL data type. Full data types list can be found here:
        https://www.postgresql.org/docs/current/datatype.html
        """
        length: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column length.
        """
        nullable: NotRequired[pulumi.Input[bool]]
        """
        Whether or not the column can accept a null value.
        """
        ordinal_position: NotRequired[pulumi.Input[int]]
        """
        The ordinal position of the column in the table.
        """
        precision: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column precision.
        """
        primary_key: NotRequired[pulumi.Input[bool]]
        """
        Whether or not the column represents a primary key.
        """
        scale: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column scale.
        """
elif False:
    StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs:
    def __init__(__self__, *,
                 column: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 length: Optional[pulumi.Input[int]] = None,
                 nullable: Optional[pulumi.Input[bool]] = None,
                 ordinal_position: Optional[pulumi.Input[int]] = None,
                 precision: Optional[pulumi.Input[int]] = None,
                 primary_key: Optional[pulumi.Input[bool]] = None,
                 scale: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] column: Column name.
        :param pulumi.Input[str] data_type: The PostgreSQL data type. Full data types list can be found here:
               https://www.postgresql.org/docs/current/datatype.html
        :param pulumi.Input[int] length: (Output)
               Column length.
        :param pulumi.Input[bool] nullable: Whether or not the column can accept a null value.
        :param pulumi.Input[int] ordinal_position: The ordinal position of the column in the table.
        :param pulumi.Input[int] precision: (Output)
               Column precision.
        :param pulumi.Input[bool] primary_key: Whether or not the column represents a primary key.
        :param pulumi.Input[int] scale: (Output)
               Column scale.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[str]]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        The PostgreSQL data type. Full data types list can be found here:
        https://www.postgresql.org/docs/current/datatype.html
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nullable", value)

    @property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[pulumi.Input[int]]:
        """
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @ordinal_position.setter
    def ordinal_position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ordinal_position", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column precision.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary_key", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column scale.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scale", value)


if not MYPY:
    class StreamBackfillAllSqlServerExcludedObjectsArgsDict(TypedDict):
        schemas: pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsSchemaArgsDict']]]
        """
        SQL Server schemas/databases in the database server
        Structure is documented below.
        """
elif False:
    StreamBackfillAllSqlServerExcludedObjectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamBackfillAllSqlServerExcludedObjectsArgs:
    def __init__(__self__, *,
                 schemas: pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsSchemaArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsSchemaArgs']]] schemas: SQL Server schemas/databases in the database server
               Structure is documented below.
        """
        pulumi.set(__self__, "schemas", schemas)

    @property
    @pulumi.getter
    def schemas(self) -> pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsSchemaArgs']]]:
        """
        SQL Server schemas/databases in the database server
        Structure is documented below.
        """
        return pulumi.get(self, "schemas")

    @schemas.setter
    def schemas(self, value: pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsSchemaArgs']]]):
        pulumi.set(self, "schemas", value)


if not MYPY:
    class StreamBackfillAllSqlServerExcludedObjectsSchemaArgsDict(TypedDict):
        schema: pulumi.Input[str]
        """
        Schema name.
        """
        tables: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsSchemaTableArgsDict']]]]
        """
        Tables in the database.
        Structure is documented below.
        """
elif False:
    StreamBackfillAllSqlServerExcludedObjectsSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamBackfillAllSqlServerExcludedObjectsSchemaArgs:
    def __init__(__self__, *,
                 schema: pulumi.Input[str],
                 tables: Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsSchemaTableArgs']]]] = None):
        """
        :param pulumi.Input[str] schema: Schema name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsSchemaTableArgs']]] tables: Tables in the database.
               Structure is documented below.
        """
        pulumi.set(__self__, "schema", schema)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @property
    @pulumi.getter
    def schema(self) -> pulumi.Input[str]:
        """
        Schema name.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input[str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsSchemaTableArgs']]]]:
        """
        Tables in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsSchemaTableArgs']]]]):
        pulumi.set(self, "tables", value)


if not MYPY:
    class StreamBackfillAllSqlServerExcludedObjectsSchemaTableArgsDict(TypedDict):
        table: pulumi.Input[str]
        """
        Table name.
        """
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumnArgsDict']]]]
        """
        SQL Server columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
elif False:
    StreamBackfillAllSqlServerExcludedObjectsSchemaTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamBackfillAllSqlServerExcludedObjectsSchemaTableArgs:
    def __init__(__self__, *,
                 table: pulumi.Input[str],
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumnArgs']]]] = None):
        """
        :param pulumi.Input[str] table: Table name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumnArgs']]] columns: SQL Server columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)

    @property
    @pulumi.getter
    def table(self) -> pulumi.Input[str]:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: pulumi.Input[str]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumnArgs']]]]:
        """
        SQL Server columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumnArgs']]]]):
        pulumi.set(self, "columns", value)


if not MYPY:
    class StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumnArgsDict(TypedDict):
        column: NotRequired[pulumi.Input[str]]
        """
        Column name.
        """
        data_type: NotRequired[pulumi.Input[str]]
        """
        The SQL Server data type. Full data types list can be found here:
        https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver16
        """
        length: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column length.
        """
        nullable: NotRequired[pulumi.Input[bool]]
        """
        (Output)
        Whether or not the column can accept a null value.
        """
        ordinal_position: NotRequired[pulumi.Input[int]]
        """
        (Output)
        The ordinal position of the column in the table.
        """
        precision: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column precision.
        """
        primary_key: NotRequired[pulumi.Input[bool]]
        """
        (Output)
        Whether or not the column represents a primary key.
        """
        scale: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column scale.
        """
elif False:
    StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumnArgs:
    def __init__(__self__, *,
                 column: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 length: Optional[pulumi.Input[int]] = None,
                 nullable: Optional[pulumi.Input[bool]] = None,
                 ordinal_position: Optional[pulumi.Input[int]] = None,
                 precision: Optional[pulumi.Input[int]] = None,
                 primary_key: Optional[pulumi.Input[bool]] = None,
                 scale: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] column: Column name.
        :param pulumi.Input[str] data_type: The SQL Server data type. Full data types list can be found here:
               https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver16
        :param pulumi.Input[int] length: (Output)
               Column length.
        :param pulumi.Input[bool] nullable: (Output)
               Whether or not the column can accept a null value.
        :param pulumi.Input[int] ordinal_position: (Output)
               The ordinal position of the column in the table.
        :param pulumi.Input[int] precision: (Output)
               Column precision.
        :param pulumi.Input[bool] primary_key: (Output)
               Whether or not the column represents a primary key.
        :param pulumi.Input[int] scale: (Output)
               Column scale.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[str]]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        The SQL Server data type. Full data types list can be found here:
        https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver16
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[bool]]:
        """
        (Output)
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nullable", value)

    @property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @ordinal_position.setter
    def ordinal_position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ordinal_position", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column precision.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[bool]]:
        """
        (Output)
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary_key", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column scale.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scale", value)


if not MYPY:
    class StreamBackfillNoneArgsDict(TypedDict):
        pass
elif False:
    StreamBackfillNoneArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamBackfillNoneArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class StreamDestinationConfigArgsDict(TypedDict):
        destination_connection_profile: pulumi.Input[str]
        """
        Destination connection profile resource. Format: projects/{project}/locations/{location}/connectionProfiles/{name}
        """
        bigquery_destination_config: NotRequired[pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigArgsDict']]
        """
        A configuration for how data should be loaded to Cloud Storage.
        Structure is documented below.
        """
        gcs_destination_config: NotRequired[pulumi.Input['StreamDestinationConfigGcsDestinationConfigArgsDict']]
        """
        A configuration for how data should be loaded to Cloud Storage.
        Structure is documented below.
        """
elif False:
    StreamDestinationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamDestinationConfigArgs:
    def __init__(__self__, *,
                 destination_connection_profile: pulumi.Input[str],
                 bigquery_destination_config: Optional[pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigArgs']] = None,
                 gcs_destination_config: Optional[pulumi.Input['StreamDestinationConfigGcsDestinationConfigArgs']] = None):
        """
        :param pulumi.Input[str] destination_connection_profile: Destination connection profile resource. Format: projects/{project}/locations/{location}/connectionProfiles/{name}
        :param pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigArgs'] bigquery_destination_config: A configuration for how data should be loaded to Cloud Storage.
               Structure is documented below.
        :param pulumi.Input['StreamDestinationConfigGcsDestinationConfigArgs'] gcs_destination_config: A configuration for how data should be loaded to Cloud Storage.
               Structure is documented below.
        """
        pulumi.set(__self__, "destination_connection_profile", destination_connection_profile)
        if bigquery_destination_config is not None:
            pulumi.set(__self__, "bigquery_destination_config", bigquery_destination_config)
        if gcs_destination_config is not None:
            pulumi.set(__self__, "gcs_destination_config", gcs_destination_config)

    @property
    @pulumi.getter(name="destinationConnectionProfile")
    def destination_connection_profile(self) -> pulumi.Input[str]:
        """
        Destination connection profile resource. Format: projects/{project}/locations/{location}/connectionProfiles/{name}
        """
        return pulumi.get(self, "destination_connection_profile")

    @destination_connection_profile.setter
    def destination_connection_profile(self, value: pulumi.Input[str]):
        pulumi.set(self, "destination_connection_profile", value)

    @property
    @pulumi.getter(name="bigqueryDestinationConfig")
    def bigquery_destination_config(self) -> Optional[pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigArgs']]:
        """
        A configuration for how data should be loaded to Cloud Storage.
        Structure is documented below.
        """
        return pulumi.get(self, "bigquery_destination_config")

    @bigquery_destination_config.setter
    def bigquery_destination_config(self, value: Optional[pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigArgs']]):
        pulumi.set(self, "bigquery_destination_config", value)

    @property
    @pulumi.getter(name="gcsDestinationConfig")
    def gcs_destination_config(self) -> Optional[pulumi.Input['StreamDestinationConfigGcsDestinationConfigArgs']]:
        """
        A configuration for how data should be loaded to Cloud Storage.
        Structure is documented below.
        """
        return pulumi.get(self, "gcs_destination_config")

    @gcs_destination_config.setter
    def gcs_destination_config(self, value: Optional[pulumi.Input['StreamDestinationConfigGcsDestinationConfigArgs']]):
        pulumi.set(self, "gcs_destination_config", value)


if not MYPY:
    class StreamDestinationConfigBigqueryDestinationConfigArgsDict(TypedDict):
        data_freshness: NotRequired[pulumi.Input[str]]
        """
        The guaranteed data freshness (in seconds) when querying tables created by the stream.
        Editing this field will only affect new tables created in the future, but existing tables
        will not be impacted. Lower values mean that queries will return fresher data, but may result in higher cost.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s". Defaults to 900s.
        """
        single_target_dataset: NotRequired[pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigSingleTargetDatasetArgsDict']]
        """
        A single target dataset to which all data will be streamed.
        Structure is documented below.
        """
        source_hierarchy_datasets: NotRequired[pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsArgsDict']]
        """
        Destination datasets are created so that hierarchy of the destination data objects matches the source hierarchy.
        Structure is documented below.
        """
elif False:
    StreamDestinationConfigBigqueryDestinationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamDestinationConfigBigqueryDestinationConfigArgs:
    def __init__(__self__, *,
                 data_freshness: Optional[pulumi.Input[str]] = None,
                 single_target_dataset: Optional[pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigSingleTargetDatasetArgs']] = None,
                 source_hierarchy_datasets: Optional[pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsArgs']] = None):
        """
        :param pulumi.Input[str] data_freshness: The guaranteed data freshness (in seconds) when querying tables created by the stream.
               Editing this field will only affect new tables created in the future, but existing tables
               will not be impacted. Lower values mean that queries will return fresher data, but may result in higher cost.
               A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s". Defaults to 900s.
        :param pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigSingleTargetDatasetArgs'] single_target_dataset: A single target dataset to which all data will be streamed.
               Structure is documented below.
        :param pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsArgs'] source_hierarchy_datasets: Destination datasets are created so that hierarchy of the destination data objects matches the source hierarchy.
               Structure is documented below.
        """
        if data_freshness is not None:
            pulumi.set(__self__, "data_freshness", data_freshness)
        if single_target_dataset is not None:
            pulumi.set(__self__, "single_target_dataset", single_target_dataset)
        if source_hierarchy_datasets is not None:
            pulumi.set(__self__, "source_hierarchy_datasets", source_hierarchy_datasets)

    @property
    @pulumi.getter(name="dataFreshness")
    def data_freshness(self) -> Optional[pulumi.Input[str]]:
        """
        The guaranteed data freshness (in seconds) when querying tables created by the stream.
        Editing this field will only affect new tables created in the future, but existing tables
        will not be impacted. Lower values mean that queries will return fresher data, but may result in higher cost.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s". Defaults to 900s.
        """
        return pulumi.get(self, "data_freshness")

    @data_freshness.setter
    def data_freshness(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_freshness", value)

    @property
    @pulumi.getter(name="singleTargetDataset")
    def single_target_dataset(self) -> Optional[pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigSingleTargetDatasetArgs']]:
        """
        A single target dataset to which all data will be streamed.
        Structure is documented below.
        """
        return pulumi.get(self, "single_target_dataset")

    @single_target_dataset.setter
    def single_target_dataset(self, value: Optional[pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigSingleTargetDatasetArgs']]):
        pulumi.set(self, "single_target_dataset", value)

    @property
    @pulumi.getter(name="sourceHierarchyDatasets")
    def source_hierarchy_datasets(self) -> Optional[pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsArgs']]:
        """
        Destination datasets are created so that hierarchy of the destination data objects matches the source hierarchy.
        Structure is documented below.
        """
        return pulumi.get(self, "source_hierarchy_datasets")

    @source_hierarchy_datasets.setter
    def source_hierarchy_datasets(self, value: Optional[pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsArgs']]):
        pulumi.set(self, "source_hierarchy_datasets", value)


if not MYPY:
    class StreamDestinationConfigBigqueryDestinationConfigSingleTargetDatasetArgsDict(TypedDict):
        dataset_id: pulumi.Input[str]
        """
        Dataset ID in the format projects/{project}/datasets/{dataset_id} or
        {project}:{dataset_id}
        """
elif False:
    StreamDestinationConfigBigqueryDestinationConfigSingleTargetDatasetArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamDestinationConfigBigqueryDestinationConfigSingleTargetDatasetArgs:
    def __init__(__self__, *,
                 dataset_id: pulumi.Input[str]):
        """
        :param pulumi.Input[str] dataset_id: Dataset ID in the format projects/{project}/datasets/{dataset_id} or
               {project}:{dataset_id}
        """
        pulumi.set(__self__, "dataset_id", dataset_id)

    @property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> pulumi.Input[str]:
        """
        Dataset ID in the format projects/{project}/datasets/{dataset_id} or
        {project}:{dataset_id}
        """
        return pulumi.get(self, "dataset_id")

    @dataset_id.setter
    def dataset_id(self, value: pulumi.Input[str]):
        pulumi.set(self, "dataset_id", value)


if not MYPY:
    class StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsArgsDict(TypedDict):
        dataset_template: pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplateArgsDict']
        """
        Dataset template used for dynamic dataset creation.
        Structure is documented below.
        """
elif False:
    StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsArgs:
    def __init__(__self__, *,
                 dataset_template: pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplateArgs']):
        """
        :param pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplateArgs'] dataset_template: Dataset template used for dynamic dataset creation.
               Structure is documented below.
        """
        pulumi.set(__self__, "dataset_template", dataset_template)

    @property
    @pulumi.getter(name="datasetTemplate")
    def dataset_template(self) -> pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplateArgs']:
        """
        Dataset template used for dynamic dataset creation.
        Structure is documented below.
        """
        return pulumi.get(self, "dataset_template")

    @dataset_template.setter
    def dataset_template(self, value: pulumi.Input['StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplateArgs']):
        pulumi.set(self, "dataset_template", value)


if not MYPY:
    class StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplateArgsDict(TypedDict):
        location: pulumi.Input[str]
        """
        The geographic location where the dataset should reside.
        See https://cloud.google.com/bigquery/docs/locations for supported locations.
        """
        dataset_id_prefix: NotRequired[pulumi.Input[str]]
        """
        If supplied, every created dataset will have its name prefixed by the provided value.
        The prefix and name will be separated by an underscore. i.e. _.
        """
        kms_key_name: NotRequired[pulumi.Input[str]]
        """
        Describes the Cloud KMS encryption key that will be used to protect destination BigQuery
        table. The BigQuery Service Account associated with your project requires access to this
        encryption key. i.e. projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{cryptoKey}.
        See https://cloud.google.com/bigquery/docs/customer-managed-encryption for more information.

        - - -
        """
elif False:
    StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplateArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplateArgs:
    def __init__(__self__, *,
                 location: pulumi.Input[str],
                 dataset_id_prefix: Optional[pulumi.Input[str]] = None,
                 kms_key_name: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] location: The geographic location where the dataset should reside.
               See https://cloud.google.com/bigquery/docs/locations for supported locations.
        :param pulumi.Input[str] dataset_id_prefix: If supplied, every created dataset will have its name prefixed by the provided value.
               The prefix and name will be separated by an underscore. i.e. _.
        :param pulumi.Input[str] kms_key_name: Describes the Cloud KMS encryption key that will be used to protect destination BigQuery
               table. The BigQuery Service Account associated with your project requires access to this
               encryption key. i.e. projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{cryptoKey}.
               See https://cloud.google.com/bigquery/docs/customer-managed-encryption for more information.
               
               - - -
        """
        pulumi.set(__self__, "location", location)
        if dataset_id_prefix is not None:
            pulumi.set(__self__, "dataset_id_prefix", dataset_id_prefix)
        if kms_key_name is not None:
            pulumi.set(__self__, "kms_key_name", kms_key_name)

    @property
    @pulumi.getter
    def location(self) -> pulumi.Input[str]:
        """
        The geographic location where the dataset should reside.
        See https://cloud.google.com/bigquery/docs/locations for supported locations.
        """
        return pulumi.get(self, "location")

    @location.setter
    def location(self, value: pulumi.Input[str]):
        pulumi.set(self, "location", value)

    @property
    @pulumi.getter(name="datasetIdPrefix")
    def dataset_id_prefix(self) -> Optional[pulumi.Input[str]]:
        """
        If supplied, every created dataset will have its name prefixed by the provided value.
        The prefix and name will be separated by an underscore. i.e. _.
        """
        return pulumi.get(self, "dataset_id_prefix")

    @dataset_id_prefix.setter
    def dataset_id_prefix(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "dataset_id_prefix", value)

    @property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[pulumi.Input[str]]:
        """
        Describes the Cloud KMS encryption key that will be used to protect destination BigQuery
        table. The BigQuery Service Account associated with your project requires access to this
        encryption key. i.e. projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{cryptoKey}.
        See https://cloud.google.com/bigquery/docs/customer-managed-encryption for more information.

        - - -
        """
        return pulumi.get(self, "kms_key_name")

    @kms_key_name.setter
    def kms_key_name(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "kms_key_name", value)


if not MYPY:
    class StreamDestinationConfigGcsDestinationConfigArgsDict(TypedDict):
        avro_file_format: NotRequired[pulumi.Input['StreamDestinationConfigGcsDestinationConfigAvroFileFormatArgsDict']]
        """
        AVRO file format configuration.
        """
        file_rotation_interval: NotRequired[pulumi.Input[str]]
        """
        The maximum duration for which new events are added before a file is closed and a new file is created.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s". Defaults to 900s.
        """
        file_rotation_mb: NotRequired[pulumi.Input[int]]
        """
        The maximum file size to be saved in the bucket.
        """
        json_file_format: NotRequired[pulumi.Input['StreamDestinationConfigGcsDestinationConfigJsonFileFormatArgsDict']]
        """
        JSON file format configuration.
        Structure is documented below.
        """
        path: NotRequired[pulumi.Input[str]]
        """
        Path inside the Cloud Storage bucket to write data to.
        """
elif False:
    StreamDestinationConfigGcsDestinationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamDestinationConfigGcsDestinationConfigArgs:
    def __init__(__self__, *,
                 avro_file_format: Optional[pulumi.Input['StreamDestinationConfigGcsDestinationConfigAvroFileFormatArgs']] = None,
                 file_rotation_interval: Optional[pulumi.Input[str]] = None,
                 file_rotation_mb: Optional[pulumi.Input[int]] = None,
                 json_file_format: Optional[pulumi.Input['StreamDestinationConfigGcsDestinationConfigJsonFileFormatArgs']] = None,
                 path: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input['StreamDestinationConfigGcsDestinationConfigAvroFileFormatArgs'] avro_file_format: AVRO file format configuration.
        :param pulumi.Input[str] file_rotation_interval: The maximum duration for which new events are added before a file is closed and a new file is created.
               A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s". Defaults to 900s.
        :param pulumi.Input[int] file_rotation_mb: The maximum file size to be saved in the bucket.
        :param pulumi.Input['StreamDestinationConfigGcsDestinationConfigJsonFileFormatArgs'] json_file_format: JSON file format configuration.
               Structure is documented below.
        :param pulumi.Input[str] path: Path inside the Cloud Storage bucket to write data to.
        """
        if avro_file_format is not None:
            pulumi.set(__self__, "avro_file_format", avro_file_format)
        if file_rotation_interval is not None:
            pulumi.set(__self__, "file_rotation_interval", file_rotation_interval)
        if file_rotation_mb is not None:
            pulumi.set(__self__, "file_rotation_mb", file_rotation_mb)
        if json_file_format is not None:
            pulumi.set(__self__, "json_file_format", json_file_format)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @property
    @pulumi.getter(name="avroFileFormat")
    def avro_file_format(self) -> Optional[pulumi.Input['StreamDestinationConfigGcsDestinationConfigAvroFileFormatArgs']]:
        """
        AVRO file format configuration.
        """
        return pulumi.get(self, "avro_file_format")

    @avro_file_format.setter
    def avro_file_format(self, value: Optional[pulumi.Input['StreamDestinationConfigGcsDestinationConfigAvroFileFormatArgs']]):
        pulumi.set(self, "avro_file_format", value)

    @property
    @pulumi.getter(name="fileRotationInterval")
    def file_rotation_interval(self) -> Optional[pulumi.Input[str]]:
        """
        The maximum duration for which new events are added before a file is closed and a new file is created.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s". Defaults to 900s.
        """
        return pulumi.get(self, "file_rotation_interval")

    @file_rotation_interval.setter
    def file_rotation_interval(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "file_rotation_interval", value)

    @property
    @pulumi.getter(name="fileRotationMb")
    def file_rotation_mb(self) -> Optional[pulumi.Input[int]]:
        """
        The maximum file size to be saved in the bucket.
        """
        return pulumi.get(self, "file_rotation_mb")

    @file_rotation_mb.setter
    def file_rotation_mb(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "file_rotation_mb", value)

    @property
    @pulumi.getter(name="jsonFileFormat")
    def json_file_format(self) -> Optional[pulumi.Input['StreamDestinationConfigGcsDestinationConfigJsonFileFormatArgs']]:
        """
        JSON file format configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "json_file_format")

    @json_file_format.setter
    def json_file_format(self, value: Optional[pulumi.Input['StreamDestinationConfigGcsDestinationConfigJsonFileFormatArgs']]):
        pulumi.set(self, "json_file_format", value)

    @property
    @pulumi.getter
    def path(self) -> Optional[pulumi.Input[str]]:
        """
        Path inside the Cloud Storage bucket to write data to.
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "path", value)


if not MYPY:
    class StreamDestinationConfigGcsDestinationConfigAvroFileFormatArgsDict(TypedDict):
        pass
elif False:
    StreamDestinationConfigGcsDestinationConfigAvroFileFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamDestinationConfigGcsDestinationConfigAvroFileFormatArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class StreamDestinationConfigGcsDestinationConfigJsonFileFormatArgsDict(TypedDict):
        compression: NotRequired[pulumi.Input[str]]
        """
        Compression of the loaded JSON file.
        Possible values are: `NO_COMPRESSION`, `GZIP`.
        """
        schema_file_format: NotRequired[pulumi.Input[str]]
        """
        The schema file format along JSON data files.
        Possible values are: `NO_SCHEMA_FILE`, `AVRO_SCHEMA_FILE`.
        """
elif False:
    StreamDestinationConfigGcsDestinationConfigJsonFileFormatArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamDestinationConfigGcsDestinationConfigJsonFileFormatArgs:
    def __init__(__self__, *,
                 compression: Optional[pulumi.Input[str]] = None,
                 schema_file_format: Optional[pulumi.Input[str]] = None):
        """
        :param pulumi.Input[str] compression: Compression of the loaded JSON file.
               Possible values are: `NO_COMPRESSION`, `GZIP`.
        :param pulumi.Input[str] schema_file_format: The schema file format along JSON data files.
               Possible values are: `NO_SCHEMA_FILE`, `AVRO_SCHEMA_FILE`.
        """
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if schema_file_format is not None:
            pulumi.set(__self__, "schema_file_format", schema_file_format)

    @property
    @pulumi.getter
    def compression(self) -> Optional[pulumi.Input[str]]:
        """
        Compression of the loaded JSON file.
        Possible values are: `NO_COMPRESSION`, `GZIP`.
        """
        return pulumi.get(self, "compression")

    @compression.setter
    def compression(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "compression", value)

    @property
    @pulumi.getter(name="schemaFileFormat")
    def schema_file_format(self) -> Optional[pulumi.Input[str]]:
        """
        The schema file format along JSON data files.
        Possible values are: `NO_SCHEMA_FILE`, `AVRO_SCHEMA_FILE`.
        """
        return pulumi.get(self, "schema_file_format")

    @schema_file_format.setter
    def schema_file_format(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "schema_file_format", value)


if not MYPY:
    class StreamSourceConfigArgsDict(TypedDict):
        source_connection_profile: pulumi.Input[str]
        """
        Source connection profile resource. Format: projects/{project}/locations/{location}/connectionProfiles/{name}
        """
        mysql_source_config: NotRequired[pulumi.Input['StreamSourceConfigMysqlSourceConfigArgsDict']]
        """
        MySQL data source configuration.
        Structure is documented below.
        """
        oracle_source_config: NotRequired[pulumi.Input['StreamSourceConfigOracleSourceConfigArgsDict']]
        """
        MySQL data source configuration.
        Structure is documented below.
        """
        postgresql_source_config: NotRequired[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigArgsDict']]
        """
        PostgreSQL data source configuration.
        Structure is documented below.
        """
        sql_server_source_config: NotRequired[pulumi.Input['StreamSourceConfigSqlServerSourceConfigArgsDict']]
        """
        SQL Server data source configuration.
        Structure is documented below.
        """
elif False:
    StreamSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigArgs:
    def __init__(__self__, *,
                 source_connection_profile: pulumi.Input[str],
                 mysql_source_config: Optional[pulumi.Input['StreamSourceConfigMysqlSourceConfigArgs']] = None,
                 oracle_source_config: Optional[pulumi.Input['StreamSourceConfigOracleSourceConfigArgs']] = None,
                 postgresql_source_config: Optional[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigArgs']] = None,
                 sql_server_source_config: Optional[pulumi.Input['StreamSourceConfigSqlServerSourceConfigArgs']] = None):
        """
        :param pulumi.Input[str] source_connection_profile: Source connection profile resource. Format: projects/{project}/locations/{location}/connectionProfiles/{name}
        :param pulumi.Input['StreamSourceConfigMysqlSourceConfigArgs'] mysql_source_config: MySQL data source configuration.
               Structure is documented below.
        :param pulumi.Input['StreamSourceConfigOracleSourceConfigArgs'] oracle_source_config: MySQL data source configuration.
               Structure is documented below.
        :param pulumi.Input['StreamSourceConfigPostgresqlSourceConfigArgs'] postgresql_source_config: PostgreSQL data source configuration.
               Structure is documented below.
        :param pulumi.Input['StreamSourceConfigSqlServerSourceConfigArgs'] sql_server_source_config: SQL Server data source configuration.
               Structure is documented below.
        """
        pulumi.set(__self__, "source_connection_profile", source_connection_profile)
        if mysql_source_config is not None:
            pulumi.set(__self__, "mysql_source_config", mysql_source_config)
        if oracle_source_config is not None:
            pulumi.set(__self__, "oracle_source_config", oracle_source_config)
        if postgresql_source_config is not None:
            pulumi.set(__self__, "postgresql_source_config", postgresql_source_config)
        if sql_server_source_config is not None:
            pulumi.set(__self__, "sql_server_source_config", sql_server_source_config)

    @property
    @pulumi.getter(name="sourceConnectionProfile")
    def source_connection_profile(self) -> pulumi.Input[str]:
        """
        Source connection profile resource. Format: projects/{project}/locations/{location}/connectionProfiles/{name}
        """
        return pulumi.get(self, "source_connection_profile")

    @source_connection_profile.setter
    def source_connection_profile(self, value: pulumi.Input[str]):
        pulumi.set(self, "source_connection_profile", value)

    @property
    @pulumi.getter(name="mysqlSourceConfig")
    def mysql_source_config(self) -> Optional[pulumi.Input['StreamSourceConfigMysqlSourceConfigArgs']]:
        """
        MySQL data source configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_source_config")

    @mysql_source_config.setter
    def mysql_source_config(self, value: Optional[pulumi.Input['StreamSourceConfigMysqlSourceConfigArgs']]):
        pulumi.set(self, "mysql_source_config", value)

    @property
    @pulumi.getter(name="oracleSourceConfig")
    def oracle_source_config(self) -> Optional[pulumi.Input['StreamSourceConfigOracleSourceConfigArgs']]:
        """
        MySQL data source configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_source_config")

    @oracle_source_config.setter
    def oracle_source_config(self, value: Optional[pulumi.Input['StreamSourceConfigOracleSourceConfigArgs']]):
        pulumi.set(self, "oracle_source_config", value)

    @property
    @pulumi.getter(name="postgresqlSourceConfig")
    def postgresql_source_config(self) -> Optional[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigArgs']]:
        """
        PostgreSQL data source configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_source_config")

    @postgresql_source_config.setter
    def postgresql_source_config(self, value: Optional[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigArgs']]):
        pulumi.set(self, "postgresql_source_config", value)

    @property
    @pulumi.getter(name="sqlServerSourceConfig")
    def sql_server_source_config(self) -> Optional[pulumi.Input['StreamSourceConfigSqlServerSourceConfigArgs']]:
        """
        SQL Server data source configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "sql_server_source_config")

    @sql_server_source_config.setter
    def sql_server_source_config(self, value: Optional[pulumi.Input['StreamSourceConfigSqlServerSourceConfigArgs']]):
        pulumi.set(self, "sql_server_source_config", value)


if not MYPY:
    class StreamSourceConfigMysqlSourceConfigArgsDict(TypedDict):
        exclude_objects: NotRequired[pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsArgsDict']]
        """
        MySQL objects to exclude from the stream.
        Structure is documented below.
        """
        include_objects: NotRequired[pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsArgsDict']]
        """
        MySQL objects to retrieve from the source.
        Structure is documented below.
        """
        max_concurrent_backfill_tasks: NotRequired[pulumi.Input[int]]
        """
        Maximum number of concurrent backfill tasks. The number should be non negative.
        If not set (or set to 0), the system's default value will be used.
        """
        max_concurrent_cdc_tasks: NotRequired[pulumi.Input[int]]
        """
        Maximum number of concurrent CDC tasks. The number should be non negative.
        If not set (or set to 0), the system's default value will be used.
        """
elif False:
    StreamSourceConfigMysqlSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigMysqlSourceConfigArgs:
    def __init__(__self__, *,
                 exclude_objects: Optional[pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsArgs']] = None,
                 include_objects: Optional[pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsArgs']] = None,
                 max_concurrent_backfill_tasks: Optional[pulumi.Input[int]] = None,
                 max_concurrent_cdc_tasks: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsArgs'] exclude_objects: MySQL objects to exclude from the stream.
               Structure is documented below.
        :param pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsArgs'] include_objects: MySQL objects to retrieve from the source.
               Structure is documented below.
        :param pulumi.Input[int] max_concurrent_backfill_tasks: Maximum number of concurrent backfill tasks. The number should be non negative.
               If not set (or set to 0), the system's default value will be used.
        :param pulumi.Input[int] max_concurrent_cdc_tasks: Maximum number of concurrent CDC tasks. The number should be non negative.
               If not set (or set to 0), the system's default value will be used.
        """
        if exclude_objects is not None:
            pulumi.set(__self__, "exclude_objects", exclude_objects)
        if include_objects is not None:
            pulumi.set(__self__, "include_objects", include_objects)
        if max_concurrent_backfill_tasks is not None:
            pulumi.set(__self__, "max_concurrent_backfill_tasks", max_concurrent_backfill_tasks)
        if max_concurrent_cdc_tasks is not None:
            pulumi.set(__self__, "max_concurrent_cdc_tasks", max_concurrent_cdc_tasks)

    @property
    @pulumi.getter(name="excludeObjects")
    def exclude_objects(self) -> Optional[pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsArgs']]:
        """
        MySQL objects to exclude from the stream.
        Structure is documented below.
        """
        return pulumi.get(self, "exclude_objects")

    @exclude_objects.setter
    def exclude_objects(self, value: Optional[pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsArgs']]):
        pulumi.set(self, "exclude_objects", value)

    @property
    @pulumi.getter(name="includeObjects")
    def include_objects(self) -> Optional[pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsArgs']]:
        """
        MySQL objects to retrieve from the source.
        Structure is documented below.
        """
        return pulumi.get(self, "include_objects")

    @include_objects.setter
    def include_objects(self, value: Optional[pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsArgs']]):
        pulumi.set(self, "include_objects", value)

    @property
    @pulumi.getter(name="maxConcurrentBackfillTasks")
    def max_concurrent_backfill_tasks(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of concurrent backfill tasks. The number should be non negative.
        If not set (or set to 0), the system's default value will be used.
        """
        return pulumi.get(self, "max_concurrent_backfill_tasks")

    @max_concurrent_backfill_tasks.setter
    def max_concurrent_backfill_tasks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_concurrent_backfill_tasks", value)

    @property
    @pulumi.getter(name="maxConcurrentCdcTasks")
    def max_concurrent_cdc_tasks(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of concurrent CDC tasks. The number should be non negative.
        If not set (or set to 0), the system's default value will be used.
        """
        return pulumi.get(self, "max_concurrent_cdc_tasks")

    @max_concurrent_cdc_tasks.setter
    def max_concurrent_cdc_tasks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_concurrent_cdc_tasks", value)


if not MYPY:
    class StreamSourceConfigMysqlSourceConfigExcludeObjectsArgsDict(TypedDict):
        mysql_databases: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseArgsDict']]]
        """
        MySQL databases on the server
        Structure is documented below.
        """
elif False:
    StreamSourceConfigMysqlSourceConfigExcludeObjectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigMysqlSourceConfigExcludeObjectsArgs:
    def __init__(__self__, *,
                 mysql_databases: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseArgs']]] mysql_databases: MySQL databases on the server
               Structure is documented below.
        """
        pulumi.set(__self__, "mysql_databases", mysql_databases)

    @property
    @pulumi.getter(name="mysqlDatabases")
    def mysql_databases(self) -> pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseArgs']]]:
        """
        MySQL databases on the server
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_databases")

    @mysql_databases.setter
    def mysql_databases(self, value: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseArgs']]]):
        pulumi.set(self, "mysql_databases", value)


if not MYPY:
    class StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseArgsDict(TypedDict):
        database: pulumi.Input[str]
        """
        Database name.
        """
        mysql_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableArgsDict']]]]
        """
        Tables in the database.
        Structure is documented below.
        """
elif False:
    StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 mysql_tables: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableArgs']]]] = None):
        """
        :param pulumi.Input[str] database: Database name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableArgs']]] mysql_tables: Tables in the database.
               Structure is documented below.
        """
        pulumi.set(__self__, "database", database)
        if mysql_tables is not None:
            pulumi.set(__self__, "mysql_tables", mysql_tables)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Database name.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="mysqlTables")
    def mysql_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableArgs']]]]:
        """
        Tables in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_tables")

    @mysql_tables.setter
    def mysql_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableArgs']]]]):
        pulumi.set(self, "mysql_tables", value)


if not MYPY:
    class StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableArgsDict(TypedDict):
        table: pulumi.Input[str]
        """
        Table name.
        """
        mysql_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgsDict']]]]
        """
        MySQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
elif False:
    StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableArgs:
    def __init__(__self__, *,
                 table: pulumi.Input[str],
                 mysql_columns: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgs']]]] = None):
        """
        :param pulumi.Input[str] table: Table name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgs']]] mysql_columns: MySQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if mysql_columns is not None:
            pulumi.set(__self__, "mysql_columns", mysql_columns)

    @property
    @pulumi.getter
    def table(self) -> pulumi.Input[str]:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: pulumi.Input[str]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="mysqlColumns")
    def mysql_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgs']]]]:
        """
        MySQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_columns")

    @mysql_columns.setter
    def mysql_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgs']]]]):
        pulumi.set(self, "mysql_columns", value)


if not MYPY:
    class StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgsDict(TypedDict):
        collation: NotRequired[pulumi.Input[str]]
        """
        Column collation.
        """
        column: NotRequired[pulumi.Input[str]]
        """
        Column name.
        """
        data_type: NotRequired[pulumi.Input[str]]
        """
        The MySQL data type. Full data types list can be found here:
        https://dev.mysql.com/doc/refman/8.0/en/data-types.html
        """
        length: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column length.
        """
        nullable: NotRequired[pulumi.Input[bool]]
        """
        Whether or not the column can accept a null value.
        """
        ordinal_position: NotRequired[pulumi.Input[int]]
        """
        The ordinal position of the column in the table.
        """
        primary_key: NotRequired[pulumi.Input[bool]]
        """
        Whether or not the column represents a primary key.
        """
elif False:
    StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgs:
    def __init__(__self__, *,
                 collation: Optional[pulumi.Input[str]] = None,
                 column: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 length: Optional[pulumi.Input[int]] = None,
                 nullable: Optional[pulumi.Input[bool]] = None,
                 ordinal_position: Optional[pulumi.Input[int]] = None,
                 primary_key: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] collation: Column collation.
        :param pulumi.Input[str] column: Column name.
        :param pulumi.Input[str] data_type: The MySQL data type. Full data types list can be found here:
               https://dev.mysql.com/doc/refman/8.0/en/data-types.html
        :param pulumi.Input[int] length: (Output)
               Column length.
        :param pulumi.Input[bool] nullable: Whether or not the column can accept a null value.
        :param pulumi.Input[int] ordinal_position: The ordinal position of the column in the table.
        :param pulumi.Input[bool] primary_key: Whether or not the column represents a primary key.
        """
        if collation is not None:
            pulumi.set(__self__, "collation", collation)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)

    @property
    @pulumi.getter
    def collation(self) -> Optional[pulumi.Input[str]]:
        """
        Column collation.
        """
        return pulumi.get(self, "collation")

    @collation.setter
    def collation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collation", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[str]]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        The MySQL data type. Full data types list can be found here:
        https://dev.mysql.com/doc/refman/8.0/en/data-types.html
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nullable", value)

    @property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[pulumi.Input[int]]:
        """
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @ordinal_position.setter
    def ordinal_position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ordinal_position", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary_key", value)


if not MYPY:
    class StreamSourceConfigMysqlSourceConfigIncludeObjectsArgsDict(TypedDict):
        mysql_databases: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseArgsDict']]]
        """
        MySQL databases on the server
        Structure is documented below.
        """
elif False:
    StreamSourceConfigMysqlSourceConfigIncludeObjectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigMysqlSourceConfigIncludeObjectsArgs:
    def __init__(__self__, *,
                 mysql_databases: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseArgs']]] mysql_databases: MySQL databases on the server
               Structure is documented below.
        """
        pulumi.set(__self__, "mysql_databases", mysql_databases)

    @property
    @pulumi.getter(name="mysqlDatabases")
    def mysql_databases(self) -> pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseArgs']]]:
        """
        MySQL databases on the server
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_databases")

    @mysql_databases.setter
    def mysql_databases(self, value: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseArgs']]]):
        pulumi.set(self, "mysql_databases", value)


if not MYPY:
    class StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseArgsDict(TypedDict):
        database: pulumi.Input[str]
        """
        Database name.
        """
        mysql_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableArgsDict']]]]
        """
        Tables in the database.
        Structure is documented below.
        """
elif False:
    StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseArgs:
    def __init__(__self__, *,
                 database: pulumi.Input[str],
                 mysql_tables: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableArgs']]]] = None):
        """
        :param pulumi.Input[str] database: Database name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableArgs']]] mysql_tables: Tables in the database.
               Structure is documented below.
        """
        pulumi.set(__self__, "database", database)
        if mysql_tables is not None:
            pulumi.set(__self__, "mysql_tables", mysql_tables)

    @property
    @pulumi.getter
    def database(self) -> pulumi.Input[str]:
        """
        Database name.
        """
        return pulumi.get(self, "database")

    @database.setter
    def database(self, value: pulumi.Input[str]):
        pulumi.set(self, "database", value)

    @property
    @pulumi.getter(name="mysqlTables")
    def mysql_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableArgs']]]]:
        """
        Tables in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_tables")

    @mysql_tables.setter
    def mysql_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableArgs']]]]):
        pulumi.set(self, "mysql_tables", value)


if not MYPY:
    class StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableArgsDict(TypedDict):
        table: pulumi.Input[str]
        """
        Table name.
        """
        mysql_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgsDict']]]]
        """
        MySQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
elif False:
    StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableArgs:
    def __init__(__self__, *,
                 table: pulumi.Input[str],
                 mysql_columns: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgs']]]] = None):
        """
        :param pulumi.Input[str] table: Table name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgs']]] mysql_columns: MySQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if mysql_columns is not None:
            pulumi.set(__self__, "mysql_columns", mysql_columns)

    @property
    @pulumi.getter
    def table(self) -> pulumi.Input[str]:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: pulumi.Input[str]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="mysqlColumns")
    def mysql_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgs']]]]:
        """
        MySQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_columns")

    @mysql_columns.setter
    def mysql_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgs']]]]):
        pulumi.set(self, "mysql_columns", value)


if not MYPY:
    class StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgsDict(TypedDict):
        collation: NotRequired[pulumi.Input[str]]
        """
        Column collation.
        """
        column: NotRequired[pulumi.Input[str]]
        """
        Column name.
        """
        data_type: NotRequired[pulumi.Input[str]]
        """
        The MySQL data type. Full data types list can be found here:
        https://dev.mysql.com/doc/refman/8.0/en/data-types.html
        """
        length: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column length.
        """
        nullable: NotRequired[pulumi.Input[bool]]
        """
        Whether or not the column can accept a null value.
        """
        ordinal_position: NotRequired[pulumi.Input[int]]
        """
        The ordinal position of the column in the table.
        """
        primary_key: NotRequired[pulumi.Input[bool]]
        """
        Whether or not the column represents a primary key.
        """
elif False:
    StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgs:
    def __init__(__self__, *,
                 collation: Optional[pulumi.Input[str]] = None,
                 column: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 length: Optional[pulumi.Input[int]] = None,
                 nullable: Optional[pulumi.Input[bool]] = None,
                 ordinal_position: Optional[pulumi.Input[int]] = None,
                 primary_key: Optional[pulumi.Input[bool]] = None):
        """
        :param pulumi.Input[str] collation: Column collation.
        :param pulumi.Input[str] column: Column name.
        :param pulumi.Input[str] data_type: The MySQL data type. Full data types list can be found here:
               https://dev.mysql.com/doc/refman/8.0/en/data-types.html
        :param pulumi.Input[int] length: (Output)
               Column length.
        :param pulumi.Input[bool] nullable: Whether or not the column can accept a null value.
        :param pulumi.Input[int] ordinal_position: The ordinal position of the column in the table.
        :param pulumi.Input[bool] primary_key: Whether or not the column represents a primary key.
        """
        if collation is not None:
            pulumi.set(__self__, "collation", collation)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)

    @property
    @pulumi.getter
    def collation(self) -> Optional[pulumi.Input[str]]:
        """
        Column collation.
        """
        return pulumi.get(self, "collation")

    @collation.setter
    def collation(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "collation", value)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[str]]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        The MySQL data type. Full data types list can be found here:
        https://dev.mysql.com/doc/refman/8.0/en/data-types.html
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nullable", value)

    @property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[pulumi.Input[int]]:
        """
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @ordinal_position.setter
    def ordinal_position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ordinal_position", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary_key", value)


if not MYPY:
    class StreamSourceConfigOracleSourceConfigArgsDict(TypedDict):
        drop_large_objects: NotRequired[pulumi.Input['StreamSourceConfigOracleSourceConfigDropLargeObjectsArgsDict']]
        """
        Configuration to drop large object values.
        """
        exclude_objects: NotRequired[pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsArgsDict']]
        """
        Oracle objects to exclude from the stream.
        Structure is documented below.
        """
        include_objects: NotRequired[pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsArgsDict']]
        """
        Oracle objects to retrieve from the source.
        Structure is documented below.
        """
        max_concurrent_backfill_tasks: NotRequired[pulumi.Input[int]]
        """
        Maximum number of concurrent backfill tasks. The number should be non negative.
        If not set (or set to 0), the system's default value will be used.
        """
        max_concurrent_cdc_tasks: NotRequired[pulumi.Input[int]]
        """
        Maximum number of concurrent CDC tasks. The number should be non negative.
        If not set (or set to 0), the system's default value will be used.
        """
        stream_large_objects: NotRequired[pulumi.Input['StreamSourceConfigOracleSourceConfigStreamLargeObjectsArgsDict']]
        """
        Configuration to drop large object values.
        """
elif False:
    StreamSourceConfigOracleSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigOracleSourceConfigArgs:
    def __init__(__self__, *,
                 drop_large_objects: Optional[pulumi.Input['StreamSourceConfigOracleSourceConfigDropLargeObjectsArgs']] = None,
                 exclude_objects: Optional[pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsArgs']] = None,
                 include_objects: Optional[pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsArgs']] = None,
                 max_concurrent_backfill_tasks: Optional[pulumi.Input[int]] = None,
                 max_concurrent_cdc_tasks: Optional[pulumi.Input[int]] = None,
                 stream_large_objects: Optional[pulumi.Input['StreamSourceConfigOracleSourceConfigStreamLargeObjectsArgs']] = None):
        """
        :param pulumi.Input['StreamSourceConfigOracleSourceConfigDropLargeObjectsArgs'] drop_large_objects: Configuration to drop large object values.
        :param pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsArgs'] exclude_objects: Oracle objects to exclude from the stream.
               Structure is documented below.
        :param pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsArgs'] include_objects: Oracle objects to retrieve from the source.
               Structure is documented below.
        :param pulumi.Input[int] max_concurrent_backfill_tasks: Maximum number of concurrent backfill tasks. The number should be non negative.
               If not set (or set to 0), the system's default value will be used.
        :param pulumi.Input[int] max_concurrent_cdc_tasks: Maximum number of concurrent CDC tasks. The number should be non negative.
               If not set (or set to 0), the system's default value will be used.
        :param pulumi.Input['StreamSourceConfigOracleSourceConfigStreamLargeObjectsArgs'] stream_large_objects: Configuration to drop large object values.
        """
        if drop_large_objects is not None:
            pulumi.set(__self__, "drop_large_objects", drop_large_objects)
        if exclude_objects is not None:
            pulumi.set(__self__, "exclude_objects", exclude_objects)
        if include_objects is not None:
            pulumi.set(__self__, "include_objects", include_objects)
        if max_concurrent_backfill_tasks is not None:
            pulumi.set(__self__, "max_concurrent_backfill_tasks", max_concurrent_backfill_tasks)
        if max_concurrent_cdc_tasks is not None:
            pulumi.set(__self__, "max_concurrent_cdc_tasks", max_concurrent_cdc_tasks)
        if stream_large_objects is not None:
            pulumi.set(__self__, "stream_large_objects", stream_large_objects)

    @property
    @pulumi.getter(name="dropLargeObjects")
    def drop_large_objects(self) -> Optional[pulumi.Input['StreamSourceConfigOracleSourceConfigDropLargeObjectsArgs']]:
        """
        Configuration to drop large object values.
        """
        return pulumi.get(self, "drop_large_objects")

    @drop_large_objects.setter
    def drop_large_objects(self, value: Optional[pulumi.Input['StreamSourceConfigOracleSourceConfigDropLargeObjectsArgs']]):
        pulumi.set(self, "drop_large_objects", value)

    @property
    @pulumi.getter(name="excludeObjects")
    def exclude_objects(self) -> Optional[pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsArgs']]:
        """
        Oracle objects to exclude from the stream.
        Structure is documented below.
        """
        return pulumi.get(self, "exclude_objects")

    @exclude_objects.setter
    def exclude_objects(self, value: Optional[pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsArgs']]):
        pulumi.set(self, "exclude_objects", value)

    @property
    @pulumi.getter(name="includeObjects")
    def include_objects(self) -> Optional[pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsArgs']]:
        """
        Oracle objects to retrieve from the source.
        Structure is documented below.
        """
        return pulumi.get(self, "include_objects")

    @include_objects.setter
    def include_objects(self, value: Optional[pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsArgs']]):
        pulumi.set(self, "include_objects", value)

    @property
    @pulumi.getter(name="maxConcurrentBackfillTasks")
    def max_concurrent_backfill_tasks(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of concurrent backfill tasks. The number should be non negative.
        If not set (or set to 0), the system's default value will be used.
        """
        return pulumi.get(self, "max_concurrent_backfill_tasks")

    @max_concurrent_backfill_tasks.setter
    def max_concurrent_backfill_tasks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_concurrent_backfill_tasks", value)

    @property
    @pulumi.getter(name="maxConcurrentCdcTasks")
    def max_concurrent_cdc_tasks(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of concurrent CDC tasks. The number should be non negative.
        If not set (or set to 0), the system's default value will be used.
        """
        return pulumi.get(self, "max_concurrent_cdc_tasks")

    @max_concurrent_cdc_tasks.setter
    def max_concurrent_cdc_tasks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_concurrent_cdc_tasks", value)

    @property
    @pulumi.getter(name="streamLargeObjects")
    def stream_large_objects(self) -> Optional[pulumi.Input['StreamSourceConfigOracleSourceConfigStreamLargeObjectsArgs']]:
        """
        Configuration to drop large object values.
        """
        return pulumi.get(self, "stream_large_objects")

    @stream_large_objects.setter
    def stream_large_objects(self, value: Optional[pulumi.Input['StreamSourceConfigOracleSourceConfigStreamLargeObjectsArgs']]):
        pulumi.set(self, "stream_large_objects", value)


if not MYPY:
    class StreamSourceConfigOracleSourceConfigDropLargeObjectsArgsDict(TypedDict):
        pass
elif False:
    StreamSourceConfigOracleSourceConfigDropLargeObjectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigOracleSourceConfigDropLargeObjectsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class StreamSourceConfigOracleSourceConfigExcludeObjectsArgsDict(TypedDict):
        oracle_schemas: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaArgsDict']]]
        """
        Oracle schemas/databases in the database server
        Structure is documented below.
        """
elif False:
    StreamSourceConfigOracleSourceConfigExcludeObjectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigOracleSourceConfigExcludeObjectsArgs:
    def __init__(__self__, *,
                 oracle_schemas: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaArgs']]] oracle_schemas: Oracle schemas/databases in the database server
               Structure is documented below.
        """
        pulumi.set(__self__, "oracle_schemas", oracle_schemas)

    @property
    @pulumi.getter(name="oracleSchemas")
    def oracle_schemas(self) -> pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaArgs']]]:
        """
        Oracle schemas/databases in the database server
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_schemas")

    @oracle_schemas.setter
    def oracle_schemas(self, value: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaArgs']]]):
        pulumi.set(self, "oracle_schemas", value)


if not MYPY:
    class StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaArgsDict(TypedDict):
        schema: pulumi.Input[str]
        """
        Schema name.
        """
        oracle_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableArgsDict']]]]
        """
        Tables in the database.
        Structure is documented below.
        """
elif False:
    StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaArgs:
    def __init__(__self__, *,
                 schema: pulumi.Input[str],
                 oracle_tables: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableArgs']]]] = None):
        """
        :param pulumi.Input[str] schema: Schema name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableArgs']]] oracle_tables: Tables in the database.
               Structure is documented below.
        """
        pulumi.set(__self__, "schema", schema)
        if oracle_tables is not None:
            pulumi.set(__self__, "oracle_tables", oracle_tables)

    @property
    @pulumi.getter
    def schema(self) -> pulumi.Input[str]:
        """
        Schema name.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input[str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="oracleTables")
    def oracle_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableArgs']]]]:
        """
        Tables in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_tables")

    @oracle_tables.setter
    def oracle_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableArgs']]]]):
        pulumi.set(self, "oracle_tables", value)


if not MYPY:
    class StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableArgsDict(TypedDict):
        table: pulumi.Input[str]
        """
        Table name.
        """
        oracle_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumnArgsDict']]]]
        """
        Oracle columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
elif False:
    StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableArgs:
    def __init__(__self__, *,
                 table: pulumi.Input[str],
                 oracle_columns: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumnArgs']]]] = None):
        """
        :param pulumi.Input[str] table: Table name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumnArgs']]] oracle_columns: Oracle columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if oracle_columns is not None:
            pulumi.set(__self__, "oracle_columns", oracle_columns)

    @property
    @pulumi.getter
    def table(self) -> pulumi.Input[str]:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: pulumi.Input[str]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="oracleColumns")
    def oracle_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumnArgs']]]]:
        """
        Oracle columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_columns")

    @oracle_columns.setter
    def oracle_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumnArgs']]]]):
        pulumi.set(self, "oracle_columns", value)


if not MYPY:
    class StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumnArgsDict(TypedDict):
        column: NotRequired[pulumi.Input[str]]
        """
        Column name.
        """
        data_type: NotRequired[pulumi.Input[str]]
        """
        The Oracle data type. Full data types list can be found here:
        https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html
        """
        encoding: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Column encoding.
        """
        length: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column length.
        """
        nullable: NotRequired[pulumi.Input[bool]]
        """
        (Output)
        Whether or not the column can accept a null value.
        """
        ordinal_position: NotRequired[pulumi.Input[int]]
        """
        (Output)
        The ordinal position of the column in the table.
        """
        precision: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column precision.
        """
        primary_key: NotRequired[pulumi.Input[bool]]
        """
        (Output)
        Whether or not the column represents a primary key.
        """
        scale: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column scale.
        """
elif False:
    StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumnArgs:
    def __init__(__self__, *,
                 column: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 length: Optional[pulumi.Input[int]] = None,
                 nullable: Optional[pulumi.Input[bool]] = None,
                 ordinal_position: Optional[pulumi.Input[int]] = None,
                 precision: Optional[pulumi.Input[int]] = None,
                 primary_key: Optional[pulumi.Input[bool]] = None,
                 scale: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] column: Column name.
        :param pulumi.Input[str] data_type: The Oracle data type. Full data types list can be found here:
               https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html
        :param pulumi.Input[str] encoding: (Output)
               Column encoding.
        :param pulumi.Input[int] length: (Output)
               Column length.
        :param pulumi.Input[bool] nullable: (Output)
               Whether or not the column can accept a null value.
        :param pulumi.Input[int] ordinal_position: (Output)
               The ordinal position of the column in the table.
        :param pulumi.Input[int] precision: (Output)
               Column precision.
        :param pulumi.Input[bool] primary_key: (Output)
               Whether or not the column represents a primary key.
        :param pulumi.Input[int] scale: (Output)
               Column scale.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[str]]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle data type. Full data types list can be found here:
        https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Column encoding.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[bool]]:
        """
        (Output)
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nullable", value)

    @property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @ordinal_position.setter
    def ordinal_position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ordinal_position", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column precision.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[bool]]:
        """
        (Output)
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary_key", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column scale.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scale", value)


if not MYPY:
    class StreamSourceConfigOracleSourceConfigIncludeObjectsArgsDict(TypedDict):
        oracle_schemas: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaArgsDict']]]
        """
        Oracle schemas/databases in the database server
        Structure is documented below.
        """
elif False:
    StreamSourceConfigOracleSourceConfigIncludeObjectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigOracleSourceConfigIncludeObjectsArgs:
    def __init__(__self__, *,
                 oracle_schemas: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaArgs']]] oracle_schemas: Oracle schemas/databases in the database server
               Structure is documented below.
        """
        pulumi.set(__self__, "oracle_schemas", oracle_schemas)

    @property
    @pulumi.getter(name="oracleSchemas")
    def oracle_schemas(self) -> pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaArgs']]]:
        """
        Oracle schemas/databases in the database server
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_schemas")

    @oracle_schemas.setter
    def oracle_schemas(self, value: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaArgs']]]):
        pulumi.set(self, "oracle_schemas", value)


if not MYPY:
    class StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaArgsDict(TypedDict):
        schema: pulumi.Input[str]
        """
        Schema name.
        """
        oracle_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableArgsDict']]]]
        """
        Tables in the database.
        Structure is documented below.
        """
elif False:
    StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaArgs:
    def __init__(__self__, *,
                 schema: pulumi.Input[str],
                 oracle_tables: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableArgs']]]] = None):
        """
        :param pulumi.Input[str] schema: Schema name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableArgs']]] oracle_tables: Tables in the database.
               Structure is documented below.
        """
        pulumi.set(__self__, "schema", schema)
        if oracle_tables is not None:
            pulumi.set(__self__, "oracle_tables", oracle_tables)

    @property
    @pulumi.getter
    def schema(self) -> pulumi.Input[str]:
        """
        Schema name.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input[str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="oracleTables")
    def oracle_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableArgs']]]]:
        """
        Tables in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_tables")

    @oracle_tables.setter
    def oracle_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableArgs']]]]):
        pulumi.set(self, "oracle_tables", value)


if not MYPY:
    class StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableArgsDict(TypedDict):
        table: pulumi.Input[str]
        """
        Table name.
        """
        oracle_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumnArgsDict']]]]
        """
        Oracle columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
elif False:
    StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableArgs:
    def __init__(__self__, *,
                 table: pulumi.Input[str],
                 oracle_columns: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumnArgs']]]] = None):
        """
        :param pulumi.Input[str] table: Table name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumnArgs']]] oracle_columns: Oracle columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if oracle_columns is not None:
            pulumi.set(__self__, "oracle_columns", oracle_columns)

    @property
    @pulumi.getter
    def table(self) -> pulumi.Input[str]:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: pulumi.Input[str]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="oracleColumns")
    def oracle_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumnArgs']]]]:
        """
        Oracle columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_columns")

    @oracle_columns.setter
    def oracle_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumnArgs']]]]):
        pulumi.set(self, "oracle_columns", value)


if not MYPY:
    class StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumnArgsDict(TypedDict):
        column: NotRequired[pulumi.Input[str]]
        """
        Column name.
        """
        data_type: NotRequired[pulumi.Input[str]]
        """
        The Oracle data type. Full data types list can be found here:
        https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html
        """
        encoding: NotRequired[pulumi.Input[str]]
        """
        (Output)
        Column encoding.
        """
        length: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column length.
        """
        nullable: NotRequired[pulumi.Input[bool]]
        """
        (Output)
        Whether or not the column can accept a null value.
        """
        ordinal_position: NotRequired[pulumi.Input[int]]
        """
        (Output)
        The ordinal position of the column in the table.
        """
        precision: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column precision.
        """
        primary_key: NotRequired[pulumi.Input[bool]]
        """
        (Output)
        Whether or not the column represents a primary key.
        """
        scale: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column scale.
        """
elif False:
    StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumnArgs:
    def __init__(__self__, *,
                 column: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 encoding: Optional[pulumi.Input[str]] = None,
                 length: Optional[pulumi.Input[int]] = None,
                 nullable: Optional[pulumi.Input[bool]] = None,
                 ordinal_position: Optional[pulumi.Input[int]] = None,
                 precision: Optional[pulumi.Input[int]] = None,
                 primary_key: Optional[pulumi.Input[bool]] = None,
                 scale: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] column: Column name.
        :param pulumi.Input[str] data_type: The Oracle data type. Full data types list can be found here:
               https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html
        :param pulumi.Input[str] encoding: (Output)
               Column encoding.
        :param pulumi.Input[int] length: (Output)
               Column length.
        :param pulumi.Input[bool] nullable: (Output)
               Whether or not the column can accept a null value.
        :param pulumi.Input[int] ordinal_position: (Output)
               The ordinal position of the column in the table.
        :param pulumi.Input[int] precision: (Output)
               Column precision.
        :param pulumi.Input[bool] primary_key: (Output)
               Whether or not the column represents a primary key.
        :param pulumi.Input[int] scale: (Output)
               Column scale.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[str]]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        The Oracle data type. Full data types list can be found here:
        https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def encoding(self) -> Optional[pulumi.Input[str]]:
        """
        (Output)
        Column encoding.
        """
        return pulumi.get(self, "encoding")

    @encoding.setter
    def encoding(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "encoding", value)

    @property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[bool]]:
        """
        (Output)
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nullable", value)

    @property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @ordinal_position.setter
    def ordinal_position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ordinal_position", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column precision.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[bool]]:
        """
        (Output)
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary_key", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column scale.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scale", value)


if not MYPY:
    class StreamSourceConfigOracleSourceConfigStreamLargeObjectsArgsDict(TypedDict):
        pass
elif False:
    StreamSourceConfigOracleSourceConfigStreamLargeObjectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigOracleSourceConfigStreamLargeObjectsArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class StreamSourceConfigPostgresqlSourceConfigArgsDict(TypedDict):
        publication: pulumi.Input[str]
        """
        The name of the publication that includes the set of all tables
        that are defined in the stream's include_objects.
        """
        replication_slot: pulumi.Input[str]
        """
        The name of the logical replication slot that's configured with
        the pgoutput plugin.
        """
        exclude_objects: NotRequired[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsArgsDict']]
        """
        PostgreSQL objects to exclude from the stream.
        Structure is documented below.
        """
        include_objects: NotRequired[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsArgsDict']]
        """
        PostgreSQL objects to retrieve from the source.
        Structure is documented below.
        """
        max_concurrent_backfill_tasks: NotRequired[pulumi.Input[int]]
        """
        Maximum number of concurrent backfill tasks. The number should be non
        negative. If not set (or set to 0), the system's default value will be used.
        """
elif False:
    StreamSourceConfigPostgresqlSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigPostgresqlSourceConfigArgs:
    def __init__(__self__, *,
                 publication: pulumi.Input[str],
                 replication_slot: pulumi.Input[str],
                 exclude_objects: Optional[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsArgs']] = None,
                 include_objects: Optional[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsArgs']] = None,
                 max_concurrent_backfill_tasks: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] publication: The name of the publication that includes the set of all tables
               that are defined in the stream's include_objects.
        :param pulumi.Input[str] replication_slot: The name of the logical replication slot that's configured with
               the pgoutput plugin.
        :param pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsArgs'] exclude_objects: PostgreSQL objects to exclude from the stream.
               Structure is documented below.
        :param pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsArgs'] include_objects: PostgreSQL objects to retrieve from the source.
               Structure is documented below.
        :param pulumi.Input[int] max_concurrent_backfill_tasks: Maximum number of concurrent backfill tasks. The number should be non
               negative. If not set (or set to 0), the system's default value will be used.
        """
        pulumi.set(__self__, "publication", publication)
        pulumi.set(__self__, "replication_slot", replication_slot)
        if exclude_objects is not None:
            pulumi.set(__self__, "exclude_objects", exclude_objects)
        if include_objects is not None:
            pulumi.set(__self__, "include_objects", include_objects)
        if max_concurrent_backfill_tasks is not None:
            pulumi.set(__self__, "max_concurrent_backfill_tasks", max_concurrent_backfill_tasks)

    @property
    @pulumi.getter
    def publication(self) -> pulumi.Input[str]:
        """
        The name of the publication that includes the set of all tables
        that are defined in the stream's include_objects.
        """
        return pulumi.get(self, "publication")

    @publication.setter
    def publication(self, value: pulumi.Input[str]):
        pulumi.set(self, "publication", value)

    @property
    @pulumi.getter(name="replicationSlot")
    def replication_slot(self) -> pulumi.Input[str]:
        """
        The name of the logical replication slot that's configured with
        the pgoutput plugin.
        """
        return pulumi.get(self, "replication_slot")

    @replication_slot.setter
    def replication_slot(self, value: pulumi.Input[str]):
        pulumi.set(self, "replication_slot", value)

    @property
    @pulumi.getter(name="excludeObjects")
    def exclude_objects(self) -> Optional[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsArgs']]:
        """
        PostgreSQL objects to exclude from the stream.
        Structure is documented below.
        """
        return pulumi.get(self, "exclude_objects")

    @exclude_objects.setter
    def exclude_objects(self, value: Optional[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsArgs']]):
        pulumi.set(self, "exclude_objects", value)

    @property
    @pulumi.getter(name="includeObjects")
    def include_objects(self) -> Optional[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsArgs']]:
        """
        PostgreSQL objects to retrieve from the source.
        Structure is documented below.
        """
        return pulumi.get(self, "include_objects")

    @include_objects.setter
    def include_objects(self, value: Optional[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsArgs']]):
        pulumi.set(self, "include_objects", value)

    @property
    @pulumi.getter(name="maxConcurrentBackfillTasks")
    def max_concurrent_backfill_tasks(self) -> Optional[pulumi.Input[int]]:
        """
        Maximum number of concurrent backfill tasks. The number should be non
        negative. If not set (or set to 0), the system's default value will be used.
        """
        return pulumi.get(self, "max_concurrent_backfill_tasks")

    @max_concurrent_backfill_tasks.setter
    def max_concurrent_backfill_tasks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_concurrent_backfill_tasks", value)


if not MYPY:
    class StreamSourceConfigPostgresqlSourceConfigExcludeObjectsArgsDict(TypedDict):
        postgresql_schemas: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaArgsDict']]]
        """
        PostgreSQL schemas on the server
        Structure is documented below.
        """
elif False:
    StreamSourceConfigPostgresqlSourceConfigExcludeObjectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigPostgresqlSourceConfigExcludeObjectsArgs:
    def __init__(__self__, *,
                 postgresql_schemas: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaArgs']]] postgresql_schemas: PostgreSQL schemas on the server
               Structure is documented below.
        """
        pulumi.set(__self__, "postgresql_schemas", postgresql_schemas)

    @property
    @pulumi.getter(name="postgresqlSchemas")
    def postgresql_schemas(self) -> pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaArgs']]]:
        """
        PostgreSQL schemas on the server
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_schemas")

    @postgresql_schemas.setter
    def postgresql_schemas(self, value: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaArgs']]]):
        pulumi.set(self, "postgresql_schemas", value)


if not MYPY:
    class StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaArgsDict(TypedDict):
        schema: pulumi.Input[str]
        """
        Database name.
        """
        postgresql_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTableArgsDict']]]]
        """
        Tables in the schema.
        Structure is documented below.
        """
elif False:
    StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaArgs:
    def __init__(__self__, *,
                 schema: pulumi.Input[str],
                 postgresql_tables: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTableArgs']]]] = None):
        """
        :param pulumi.Input[str] schema: Database name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTableArgs']]] postgresql_tables: Tables in the schema.
               Structure is documented below.
        """
        pulumi.set(__self__, "schema", schema)
        if postgresql_tables is not None:
            pulumi.set(__self__, "postgresql_tables", postgresql_tables)

    @property
    @pulumi.getter
    def schema(self) -> pulumi.Input[str]:
        """
        Database name.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input[str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="postgresqlTables")
    def postgresql_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTableArgs']]]]:
        """
        Tables in the schema.
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_tables")

    @postgresql_tables.setter
    def postgresql_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTableArgs']]]]):
        pulumi.set(self, "postgresql_tables", value)


if not MYPY:
    class StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTableArgsDict(TypedDict):
        table: pulumi.Input[str]
        """
        Table name.
        """
        postgresql_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgsDict']]]]
        """
        PostgreSQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
elif False:
    StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTableArgs:
    def __init__(__self__, *,
                 table: pulumi.Input[str],
                 postgresql_columns: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs']]]] = None):
        """
        :param pulumi.Input[str] table: Table name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs']]] postgresql_columns: PostgreSQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if postgresql_columns is not None:
            pulumi.set(__self__, "postgresql_columns", postgresql_columns)

    @property
    @pulumi.getter
    def table(self) -> pulumi.Input[str]:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: pulumi.Input[str]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="postgresqlColumns")
    def postgresql_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs']]]]:
        """
        PostgreSQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_columns")

    @postgresql_columns.setter
    def postgresql_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs']]]]):
        pulumi.set(self, "postgresql_columns", value)


if not MYPY:
    class StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgsDict(TypedDict):
        column: NotRequired[pulumi.Input[str]]
        """
        Column name.
        """
        data_type: NotRequired[pulumi.Input[str]]
        """
        The PostgreSQL data type. Full data types list can be found here:
        https://www.postgresql.org/docs/current/datatype.html
        """
        length: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column length.
        """
        nullable: NotRequired[pulumi.Input[bool]]
        """
        Whether or not the column can accept a null value.
        """
        ordinal_position: NotRequired[pulumi.Input[int]]
        """
        The ordinal position of the column in the table.
        """
        precision: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column precision.
        """
        primary_key: NotRequired[pulumi.Input[bool]]
        """
        Whether or not the column represents a primary key.
        """
        scale: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column scale.
        """
elif False:
    StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs:
    def __init__(__self__, *,
                 column: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 length: Optional[pulumi.Input[int]] = None,
                 nullable: Optional[pulumi.Input[bool]] = None,
                 ordinal_position: Optional[pulumi.Input[int]] = None,
                 precision: Optional[pulumi.Input[int]] = None,
                 primary_key: Optional[pulumi.Input[bool]] = None,
                 scale: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] column: Column name.
        :param pulumi.Input[str] data_type: The PostgreSQL data type. Full data types list can be found here:
               https://www.postgresql.org/docs/current/datatype.html
        :param pulumi.Input[int] length: (Output)
               Column length.
        :param pulumi.Input[bool] nullable: Whether or not the column can accept a null value.
        :param pulumi.Input[int] ordinal_position: The ordinal position of the column in the table.
        :param pulumi.Input[int] precision: (Output)
               Column precision.
        :param pulumi.Input[bool] primary_key: Whether or not the column represents a primary key.
        :param pulumi.Input[int] scale: (Output)
               Column scale.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[str]]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        The PostgreSQL data type. Full data types list can be found here:
        https://www.postgresql.org/docs/current/datatype.html
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nullable", value)

    @property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[pulumi.Input[int]]:
        """
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @ordinal_position.setter
    def ordinal_position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ordinal_position", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column precision.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary_key", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column scale.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scale", value)


if not MYPY:
    class StreamSourceConfigPostgresqlSourceConfigIncludeObjectsArgsDict(TypedDict):
        postgresql_schemas: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaArgsDict']]]
        """
        PostgreSQL schemas on the server
        Structure is documented below.
        """
elif False:
    StreamSourceConfigPostgresqlSourceConfigIncludeObjectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigPostgresqlSourceConfigIncludeObjectsArgs:
    def __init__(__self__, *,
                 postgresql_schemas: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaArgs']]] postgresql_schemas: PostgreSQL schemas on the server
               Structure is documented below.
        """
        pulumi.set(__self__, "postgresql_schemas", postgresql_schemas)

    @property
    @pulumi.getter(name="postgresqlSchemas")
    def postgresql_schemas(self) -> pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaArgs']]]:
        """
        PostgreSQL schemas on the server
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_schemas")

    @postgresql_schemas.setter
    def postgresql_schemas(self, value: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaArgs']]]):
        pulumi.set(self, "postgresql_schemas", value)


if not MYPY:
    class StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaArgsDict(TypedDict):
        schema: pulumi.Input[str]
        """
        Database name.
        """
        postgresql_tables: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTableArgsDict']]]]
        """
        Tables in the schema.
        Structure is documented below.
        """
elif False:
    StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaArgs:
    def __init__(__self__, *,
                 schema: pulumi.Input[str],
                 postgresql_tables: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTableArgs']]]] = None):
        """
        :param pulumi.Input[str] schema: Database name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTableArgs']]] postgresql_tables: Tables in the schema.
               Structure is documented below.
        """
        pulumi.set(__self__, "schema", schema)
        if postgresql_tables is not None:
            pulumi.set(__self__, "postgresql_tables", postgresql_tables)

    @property
    @pulumi.getter
    def schema(self) -> pulumi.Input[str]:
        """
        Database name.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input[str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter(name="postgresqlTables")
    def postgresql_tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTableArgs']]]]:
        """
        Tables in the schema.
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_tables")

    @postgresql_tables.setter
    def postgresql_tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTableArgs']]]]):
        pulumi.set(self, "postgresql_tables", value)


if not MYPY:
    class StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTableArgsDict(TypedDict):
        table: pulumi.Input[str]
        """
        Table name.
        """
        postgresql_columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgsDict']]]]
        """
        PostgreSQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
elif False:
    StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTableArgs:
    def __init__(__self__, *,
                 table: pulumi.Input[str],
                 postgresql_columns: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs']]]] = None):
        """
        :param pulumi.Input[str] table: Table name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs']]] postgresql_columns: PostgreSQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if postgresql_columns is not None:
            pulumi.set(__self__, "postgresql_columns", postgresql_columns)

    @property
    @pulumi.getter
    def table(self) -> pulumi.Input[str]:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: pulumi.Input[str]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter(name="postgresqlColumns")
    def postgresql_columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs']]]]:
        """
        PostgreSQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_columns")

    @postgresql_columns.setter
    def postgresql_columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs']]]]):
        pulumi.set(self, "postgresql_columns", value)


if not MYPY:
    class StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgsDict(TypedDict):
        column: NotRequired[pulumi.Input[str]]
        """
        Column name.
        """
        data_type: NotRequired[pulumi.Input[str]]
        """
        The PostgreSQL data type. Full data types list can be found here:
        https://www.postgresql.org/docs/current/datatype.html
        """
        length: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column length.
        """
        nullable: NotRequired[pulumi.Input[bool]]
        """
        Whether or not the column can accept a null value.
        """
        ordinal_position: NotRequired[pulumi.Input[int]]
        """
        The ordinal position of the column in the table.
        """
        precision: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column precision.
        """
        primary_key: NotRequired[pulumi.Input[bool]]
        """
        Whether or not the column represents a primary key.
        """
        scale: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column scale.
        """
elif False:
    StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs:
    def __init__(__self__, *,
                 column: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 length: Optional[pulumi.Input[int]] = None,
                 nullable: Optional[pulumi.Input[bool]] = None,
                 ordinal_position: Optional[pulumi.Input[int]] = None,
                 precision: Optional[pulumi.Input[int]] = None,
                 primary_key: Optional[pulumi.Input[bool]] = None,
                 scale: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] column: Column name.
        :param pulumi.Input[str] data_type: The PostgreSQL data type. Full data types list can be found here:
               https://www.postgresql.org/docs/current/datatype.html
        :param pulumi.Input[int] length: (Output)
               Column length.
        :param pulumi.Input[bool] nullable: Whether or not the column can accept a null value.
        :param pulumi.Input[int] ordinal_position: The ordinal position of the column in the table.
        :param pulumi.Input[int] precision: (Output)
               Column precision.
        :param pulumi.Input[bool] primary_key: Whether or not the column represents a primary key.
        :param pulumi.Input[int] scale: (Output)
               Column scale.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[str]]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        The PostgreSQL data type. Full data types list can be found here:
        https://www.postgresql.org/docs/current/datatype.html
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nullable", value)

    @property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[pulumi.Input[int]]:
        """
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @ordinal_position.setter
    def ordinal_position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ordinal_position", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column precision.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[bool]]:
        """
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary_key", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column scale.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scale", value)


if not MYPY:
    class StreamSourceConfigSqlServerSourceConfigArgsDict(TypedDict):
        exclude_objects: NotRequired[pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsArgsDict']]
        """
        SQL Server objects to exclude from the stream.
        Structure is documented below.
        """
        include_objects: NotRequired[pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsArgsDict']]
        """
        SQL Server objects to retrieve from the source.
        Structure is documented below.
        """
        max_concurrent_backfill_tasks: NotRequired[pulumi.Input[int]]
        """
        Max concurrent backfill tasks.
        """
        max_concurrent_cdc_tasks: NotRequired[pulumi.Input[int]]
        """
        Max concurrent CDC tasks.
        """
elif False:
    StreamSourceConfigSqlServerSourceConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigSqlServerSourceConfigArgs:
    def __init__(__self__, *,
                 exclude_objects: Optional[pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsArgs']] = None,
                 include_objects: Optional[pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsArgs']] = None,
                 max_concurrent_backfill_tasks: Optional[pulumi.Input[int]] = None,
                 max_concurrent_cdc_tasks: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsArgs'] exclude_objects: SQL Server objects to exclude from the stream.
               Structure is documented below.
        :param pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsArgs'] include_objects: SQL Server objects to retrieve from the source.
               Structure is documented below.
        :param pulumi.Input[int] max_concurrent_backfill_tasks: Max concurrent backfill tasks.
        :param pulumi.Input[int] max_concurrent_cdc_tasks: Max concurrent CDC tasks.
        """
        if exclude_objects is not None:
            pulumi.set(__self__, "exclude_objects", exclude_objects)
        if include_objects is not None:
            pulumi.set(__self__, "include_objects", include_objects)
        if max_concurrent_backfill_tasks is not None:
            pulumi.set(__self__, "max_concurrent_backfill_tasks", max_concurrent_backfill_tasks)
        if max_concurrent_cdc_tasks is not None:
            pulumi.set(__self__, "max_concurrent_cdc_tasks", max_concurrent_cdc_tasks)

    @property
    @pulumi.getter(name="excludeObjects")
    def exclude_objects(self) -> Optional[pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsArgs']]:
        """
        SQL Server objects to exclude from the stream.
        Structure is documented below.
        """
        return pulumi.get(self, "exclude_objects")

    @exclude_objects.setter
    def exclude_objects(self, value: Optional[pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsArgs']]):
        pulumi.set(self, "exclude_objects", value)

    @property
    @pulumi.getter(name="includeObjects")
    def include_objects(self) -> Optional[pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsArgs']]:
        """
        SQL Server objects to retrieve from the source.
        Structure is documented below.
        """
        return pulumi.get(self, "include_objects")

    @include_objects.setter
    def include_objects(self, value: Optional[pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsArgs']]):
        pulumi.set(self, "include_objects", value)

    @property
    @pulumi.getter(name="maxConcurrentBackfillTasks")
    def max_concurrent_backfill_tasks(self) -> Optional[pulumi.Input[int]]:
        """
        Max concurrent backfill tasks.
        """
        return pulumi.get(self, "max_concurrent_backfill_tasks")

    @max_concurrent_backfill_tasks.setter
    def max_concurrent_backfill_tasks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_concurrent_backfill_tasks", value)

    @property
    @pulumi.getter(name="maxConcurrentCdcTasks")
    def max_concurrent_cdc_tasks(self) -> Optional[pulumi.Input[int]]:
        """
        Max concurrent CDC tasks.
        """
        return pulumi.get(self, "max_concurrent_cdc_tasks")

    @max_concurrent_cdc_tasks.setter
    def max_concurrent_cdc_tasks(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "max_concurrent_cdc_tasks", value)


if not MYPY:
    class StreamSourceConfigSqlServerSourceConfigExcludeObjectsArgsDict(TypedDict):
        schemas: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaArgsDict']]]
        """
        SQL Server schemas/databases in the database server
        Structure is documented below.
        """
elif False:
    StreamSourceConfigSqlServerSourceConfigExcludeObjectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigSqlServerSourceConfigExcludeObjectsArgs:
    def __init__(__self__, *,
                 schemas: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaArgs']]] schemas: SQL Server schemas/databases in the database server
               Structure is documented below.
        """
        pulumi.set(__self__, "schemas", schemas)

    @property
    @pulumi.getter
    def schemas(self) -> pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaArgs']]]:
        """
        SQL Server schemas/databases in the database server
        Structure is documented below.
        """
        return pulumi.get(self, "schemas")

    @schemas.setter
    def schemas(self, value: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaArgs']]]):
        pulumi.set(self, "schemas", value)


if not MYPY:
    class StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaArgsDict(TypedDict):
        schema: pulumi.Input[str]
        """
        Schema name.
        """
        tables: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableArgsDict']]]]
        """
        Tables in the database.
        Structure is documented below.
        """
elif False:
    StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaArgs:
    def __init__(__self__, *,
                 schema: pulumi.Input[str],
                 tables: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableArgs']]]] = None):
        """
        :param pulumi.Input[str] schema: Schema name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableArgs']]] tables: Tables in the database.
               Structure is documented below.
        """
        pulumi.set(__self__, "schema", schema)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @property
    @pulumi.getter
    def schema(self) -> pulumi.Input[str]:
        """
        Schema name.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input[str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableArgs']]]]:
        """
        Tables in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableArgs']]]]):
        pulumi.set(self, "tables", value)


if not MYPY:
    class StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableArgsDict(TypedDict):
        table: pulumi.Input[str]
        """
        Table name.
        """
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumnArgsDict']]]]
        """
        SQL Server columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
elif False:
    StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableArgs:
    def __init__(__self__, *,
                 table: pulumi.Input[str],
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumnArgs']]]] = None):
        """
        :param pulumi.Input[str] table: Table name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumnArgs']]] columns: SQL Server columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)

    @property
    @pulumi.getter
    def table(self) -> pulumi.Input[str]:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: pulumi.Input[str]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumnArgs']]]]:
        """
        SQL Server columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumnArgs']]]]):
        pulumi.set(self, "columns", value)


if not MYPY:
    class StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumnArgsDict(TypedDict):
        column: NotRequired[pulumi.Input[str]]
        """
        Column name.
        """
        data_type: NotRequired[pulumi.Input[str]]
        """
        The SQL Server data type. Full data types list can be found here:
        https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver16
        """
        length: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column length.
        """
        nullable: NotRequired[pulumi.Input[bool]]
        """
        (Output)
        Whether or not the column can accept a null value.
        """
        ordinal_position: NotRequired[pulumi.Input[int]]
        """
        (Output)
        The ordinal position of the column in the table.
        """
        precision: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column precision.
        """
        primary_key: NotRequired[pulumi.Input[bool]]
        """
        (Output)
        Whether or not the column represents a primary key.
        """
        scale: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column scale.
        """
elif False:
    StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumnArgs:
    def __init__(__self__, *,
                 column: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 length: Optional[pulumi.Input[int]] = None,
                 nullable: Optional[pulumi.Input[bool]] = None,
                 ordinal_position: Optional[pulumi.Input[int]] = None,
                 precision: Optional[pulumi.Input[int]] = None,
                 primary_key: Optional[pulumi.Input[bool]] = None,
                 scale: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] column: Column name.
        :param pulumi.Input[str] data_type: The SQL Server data type. Full data types list can be found here:
               https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver16
        :param pulumi.Input[int] length: (Output)
               Column length.
        :param pulumi.Input[bool] nullable: (Output)
               Whether or not the column can accept a null value.
        :param pulumi.Input[int] ordinal_position: (Output)
               The ordinal position of the column in the table.
        :param pulumi.Input[int] precision: (Output)
               Column precision.
        :param pulumi.Input[bool] primary_key: (Output)
               Whether or not the column represents a primary key.
        :param pulumi.Input[int] scale: (Output)
               Column scale.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[str]]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        The SQL Server data type. Full data types list can be found here:
        https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver16
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[bool]]:
        """
        (Output)
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nullable", value)

    @property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @ordinal_position.setter
    def ordinal_position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ordinal_position", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column precision.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[bool]]:
        """
        (Output)
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary_key", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column scale.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scale", value)


if not MYPY:
    class StreamSourceConfigSqlServerSourceConfigIncludeObjectsArgsDict(TypedDict):
        schemas: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaArgsDict']]]
        """
        SQL Server schemas/databases in the database server
        Structure is documented below.
        """
elif False:
    StreamSourceConfigSqlServerSourceConfigIncludeObjectsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigSqlServerSourceConfigIncludeObjectsArgs:
    def __init__(__self__, *,
                 schemas: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaArgs']]]):
        """
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaArgs']]] schemas: SQL Server schemas/databases in the database server
               Structure is documented below.
        """
        pulumi.set(__self__, "schemas", schemas)

    @property
    @pulumi.getter
    def schemas(self) -> pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaArgs']]]:
        """
        SQL Server schemas/databases in the database server
        Structure is documented below.
        """
        return pulumi.get(self, "schemas")

    @schemas.setter
    def schemas(self, value: pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaArgs']]]):
        pulumi.set(self, "schemas", value)


if not MYPY:
    class StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaArgsDict(TypedDict):
        schema: pulumi.Input[str]
        """
        Schema name.
        """
        tables: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableArgsDict']]]]
        """
        Tables in the database.
        Structure is documented below.
        """
elif False:
    StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaArgs:
    def __init__(__self__, *,
                 schema: pulumi.Input[str],
                 tables: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableArgs']]]] = None):
        """
        :param pulumi.Input[str] schema: Schema name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableArgs']]] tables: Tables in the database.
               Structure is documented below.
        """
        pulumi.set(__self__, "schema", schema)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @property
    @pulumi.getter
    def schema(self) -> pulumi.Input[str]:
        """
        Schema name.
        """
        return pulumi.get(self, "schema")

    @schema.setter
    def schema(self, value: pulumi.Input[str]):
        pulumi.set(self, "schema", value)

    @property
    @pulumi.getter
    def tables(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableArgs']]]]:
        """
        Tables in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "tables")

    @tables.setter
    def tables(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableArgs']]]]):
        pulumi.set(self, "tables", value)


if not MYPY:
    class StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableArgsDict(TypedDict):
        table: pulumi.Input[str]
        """
        Table name.
        """
        columns: NotRequired[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumnArgsDict']]]]
        """
        SQL Server columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
elif False:
    StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableArgs:
    def __init__(__self__, *,
                 table: pulumi.Input[str],
                 columns: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumnArgs']]]] = None):
        """
        :param pulumi.Input[str] table: Table name.
        :param pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumnArgs']]] columns: SQL Server columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)

    @property
    @pulumi.getter
    def table(self) -> pulumi.Input[str]:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @table.setter
    def table(self, value: pulumi.Input[str]):
        pulumi.set(self, "table", value)

    @property
    @pulumi.getter
    def columns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumnArgs']]]]:
        """
        SQL Server columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "columns")

    @columns.setter
    def columns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumnArgs']]]]):
        pulumi.set(self, "columns", value)


if not MYPY:
    class StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumnArgsDict(TypedDict):
        column: NotRequired[pulumi.Input[str]]
        """
        Column name.
        """
        data_type: NotRequired[pulumi.Input[str]]
        """
        The SQL Server data type. Full data types list can be found here:
        https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver16
        """
        length: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column length.
        """
        nullable: NotRequired[pulumi.Input[bool]]
        """
        (Output)
        Whether or not the column can accept a null value.
        """
        ordinal_position: NotRequired[pulumi.Input[int]]
        """
        (Output)
        The ordinal position of the column in the table.
        """
        precision: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column precision.
        """
        primary_key: NotRequired[pulumi.Input[bool]]
        """
        (Output)
        Whether or not the column represents a primary key.
        """
        scale: NotRequired[pulumi.Input[int]]
        """
        (Output)
        Column scale.
        """
elif False:
    StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumnArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumnArgs:
    def __init__(__self__, *,
                 column: Optional[pulumi.Input[str]] = None,
                 data_type: Optional[pulumi.Input[str]] = None,
                 length: Optional[pulumi.Input[int]] = None,
                 nullable: Optional[pulumi.Input[bool]] = None,
                 ordinal_position: Optional[pulumi.Input[int]] = None,
                 precision: Optional[pulumi.Input[int]] = None,
                 primary_key: Optional[pulumi.Input[bool]] = None,
                 scale: Optional[pulumi.Input[int]] = None):
        """
        :param pulumi.Input[str] column: Column name.
        :param pulumi.Input[str] data_type: The SQL Server data type. Full data types list can be found here:
               https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver16
        :param pulumi.Input[int] length: (Output)
               Column length.
        :param pulumi.Input[bool] nullable: (Output)
               Whether or not the column can accept a null value.
        :param pulumi.Input[int] ordinal_position: (Output)
               The ordinal position of the column in the table.
        :param pulumi.Input[int] precision: (Output)
               Column precision.
        :param pulumi.Input[bool] primary_key: (Output)
               Whether or not the column represents a primary key.
        :param pulumi.Input[int] scale: (Output)
               Column scale.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @property
    @pulumi.getter
    def column(self) -> Optional[pulumi.Input[str]]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @column.setter
    def column(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "column", value)

    @property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[pulumi.Input[str]]:
        """
        The SQL Server data type. Full data types list can be found here:
        https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver16
        """
        return pulumi.get(self, "data_type")

    @data_type.setter
    def data_type(self, value: Optional[pulumi.Input[str]]):
        pulumi.set(self, "data_type", value)

    @property
    @pulumi.getter
    def length(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @length.setter
    def length(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "length", value)

    @property
    @pulumi.getter
    def nullable(self) -> Optional[pulumi.Input[bool]]:
        """
        (Output)
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @nullable.setter
    def nullable(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "nullable", value)

    @property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @ordinal_position.setter
    def ordinal_position(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "ordinal_position", value)

    @property
    @pulumi.getter
    def precision(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column precision.
        """
        return pulumi.get(self, "precision")

    @precision.setter
    def precision(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "precision", value)

    @property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[pulumi.Input[bool]]:
        """
        (Output)
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @primary_key.setter
    def primary_key(self, value: Optional[pulumi.Input[bool]]):
        pulumi.set(self, "primary_key", value)

    @property
    @pulumi.getter
    def scale(self) -> Optional[pulumi.Input[int]]:
        """
        (Output)
        Column scale.
        """
        return pulumi.get(self, "scale")

    @scale.setter
    def scale(self, value: Optional[pulumi.Input[int]]):
        pulumi.set(self, "scale", value)


