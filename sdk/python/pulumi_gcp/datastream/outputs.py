# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities
from . import outputs

__all__ = [
    'ConnectionProfileBigqueryProfile',
    'ConnectionProfileForwardSshConnectivity',
    'ConnectionProfileGcsProfile',
    'ConnectionProfileMongodbProfile',
    'ConnectionProfileMongodbProfileHostAddress',
    'ConnectionProfileMongodbProfileSrvConnectionFormat',
    'ConnectionProfileMongodbProfileSslConfig',
    'ConnectionProfileMongodbProfileStandardConnectionFormat',
    'ConnectionProfileMysqlProfile',
    'ConnectionProfileMysqlProfileSslConfig',
    'ConnectionProfileOracleProfile',
    'ConnectionProfilePostgresqlProfile',
    'ConnectionProfilePrivateConnectivity',
    'ConnectionProfileSalesforceProfile',
    'ConnectionProfileSalesforceProfileOauth2ClientCredentials',
    'ConnectionProfileSalesforceProfileUserCredentials',
    'ConnectionProfileSqlServerProfile',
    'PrivateConnectionError',
    'PrivateConnectionPscInterfaceConfig',
    'PrivateConnectionVpcPeeringConfig',
    'StreamBackfillAll',
    'StreamBackfillAllMongodbExcludedObjects',
    'StreamBackfillAllMongodbExcludedObjectsDatabase',
    'StreamBackfillAllMongodbExcludedObjectsDatabaseCollection',
    'StreamBackfillAllMongodbExcludedObjectsDatabaseCollectionField',
    'StreamBackfillAllMysqlExcludedObjects',
    'StreamBackfillAllMysqlExcludedObjectsMysqlDatabase',
    'StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTable',
    'StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumn',
    'StreamBackfillAllOracleExcludedObjects',
    'StreamBackfillAllOracleExcludedObjectsOracleSchema',
    'StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTable',
    'StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumn',
    'StreamBackfillAllPostgresqlExcludedObjects',
    'StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchema',
    'StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTable',
    'StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn',
    'StreamBackfillAllSalesforceExcludedObjects',
    'StreamBackfillAllSalesforceExcludedObjectsObject',
    'StreamBackfillAllSalesforceExcludedObjectsObjectField',
    'StreamBackfillAllSqlServerExcludedObjects',
    'StreamBackfillAllSqlServerExcludedObjectsSchema',
    'StreamBackfillAllSqlServerExcludedObjectsSchemaTable',
    'StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumn',
    'StreamBackfillNone',
    'StreamDestinationConfig',
    'StreamDestinationConfigBigqueryDestinationConfig',
    'StreamDestinationConfigBigqueryDestinationConfigAppendOnly',
    'StreamDestinationConfigBigqueryDestinationConfigBlmtConfig',
    'StreamDestinationConfigBigqueryDestinationConfigMerge',
    'StreamDestinationConfigBigqueryDestinationConfigSingleTargetDataset',
    'StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasets',
    'StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplate',
    'StreamDestinationConfigGcsDestinationConfig',
    'StreamDestinationConfigGcsDestinationConfigAvroFileFormat',
    'StreamDestinationConfigGcsDestinationConfigJsonFileFormat',
    'StreamSourceConfig',
    'StreamSourceConfigMongodbSourceConfig',
    'StreamSourceConfigMongodbSourceConfigExcludeObjects',
    'StreamSourceConfigMongodbSourceConfigExcludeObjectsDatabase',
    'StreamSourceConfigMongodbSourceConfigExcludeObjectsDatabaseCollection',
    'StreamSourceConfigMongodbSourceConfigExcludeObjectsDatabaseCollectionField',
    'StreamSourceConfigMongodbSourceConfigIncludeObjects',
    'StreamSourceConfigMongodbSourceConfigIncludeObjectsDatabase',
    'StreamSourceConfigMongodbSourceConfigIncludeObjectsDatabaseCollection',
    'StreamSourceConfigMongodbSourceConfigIncludeObjectsDatabaseCollectionField',
    'StreamSourceConfigMysqlSourceConfig',
    'StreamSourceConfigMysqlSourceConfigBinaryLogPosition',
    'StreamSourceConfigMysqlSourceConfigExcludeObjects',
    'StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabase',
    'StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTable',
    'StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumn',
    'StreamSourceConfigMysqlSourceConfigGtid',
    'StreamSourceConfigMysqlSourceConfigIncludeObjects',
    'StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabase',
    'StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTable',
    'StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumn',
    'StreamSourceConfigOracleSourceConfig',
    'StreamSourceConfigOracleSourceConfigDropLargeObjects',
    'StreamSourceConfigOracleSourceConfigExcludeObjects',
    'StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchema',
    'StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTable',
    'StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumn',
    'StreamSourceConfigOracleSourceConfigIncludeObjects',
    'StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchema',
    'StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTable',
    'StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumn',
    'StreamSourceConfigOracleSourceConfigStreamLargeObjects',
    'StreamSourceConfigPostgresqlSourceConfig',
    'StreamSourceConfigPostgresqlSourceConfigExcludeObjects',
    'StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchema',
    'StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTable',
    'StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn',
    'StreamSourceConfigPostgresqlSourceConfigIncludeObjects',
    'StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchema',
    'StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTable',
    'StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn',
    'StreamSourceConfigSalesforceSourceConfig',
    'StreamSourceConfigSalesforceSourceConfigExcludeObjects',
    'StreamSourceConfigSalesforceSourceConfigExcludeObjectsObject',
    'StreamSourceConfigSalesforceSourceConfigExcludeObjectsObjectField',
    'StreamSourceConfigSalesforceSourceConfigIncludeObjects',
    'StreamSourceConfigSalesforceSourceConfigIncludeObjectsObject',
    'StreamSourceConfigSalesforceSourceConfigIncludeObjectsObjectField',
    'StreamSourceConfigSqlServerSourceConfig',
    'StreamSourceConfigSqlServerSourceConfigChangeTables',
    'StreamSourceConfigSqlServerSourceConfigExcludeObjects',
    'StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchema',
    'StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTable',
    'StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumn',
    'StreamSourceConfigSqlServerSourceConfigIncludeObjects',
    'StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchema',
    'StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTable',
    'StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumn',
    'StreamSourceConfigSqlServerSourceConfigTransactionLogs',
]

@pulumi.output_type
class ConnectionProfileBigqueryProfile(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ConnectionProfileForwardSshConnectivity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateKey":
            suggest = "private_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionProfileForwardSshConnectivity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionProfileForwardSshConnectivity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionProfileForwardSshConnectivity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 username: _builtins.str,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 private_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str hostname: Hostname for the SSH tunnel.
        :param _builtins.str username: Username for the SSH tunnel.
        :param _builtins.str password: SSH password.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.int port: Port for the SSH tunnel.
        :param _builtins.str private_key: SSH private key.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "username", username)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if private_key is not None:
            pulumi.set(__self__, "private_key", private_key)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Hostname for the SSH tunnel.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username for the SSH tunnel.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        SSH password.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port for the SSH tunnel.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="privateKey")
    def private_key(self) -> Optional[_builtins.str]:
        """
        SSH private key.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "private_key")


@pulumi.output_type
class ConnectionProfileGcsProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "rootPath":
            suggest = "root_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionProfileGcsProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionProfileGcsProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionProfileGcsProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: _builtins.str,
                 root_path: Optional[_builtins.str] = None):
        """
        :param _builtins.str bucket: The Cloud Storage bucket name.
        :param _builtins.str root_path: The root path inside the Cloud Storage bucket.
        """
        pulumi.set(__self__, "bucket", bucket)
        if root_path is not None:
            pulumi.set(__self__, "root_path", root_path)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        The Cloud Storage bucket name.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="rootPath")
    def root_path(self) -> Optional[_builtins.str]:
        """
        The root path inside the Cloud Storage bucket.
        """
        return pulumi.get(self, "root_path")


@pulumi.output_type
class ConnectionProfileMongodbProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "hostAddresses":
            suggest = "host_addresses"
        elif key == "replicaSet":
            suggest = "replica_set"
        elif key == "secretManagerStoredPassword":
            suggest = "secret_manager_stored_password"
        elif key == "srvConnectionFormat":
            suggest = "srv_connection_format"
        elif key == "sslConfig":
            suggest = "ssl_config"
        elif key == "standardConnectionFormat":
            suggest = "standard_connection_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionProfileMongodbProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionProfileMongodbProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionProfileMongodbProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 host_addresses: Sequence['outputs.ConnectionProfileMongodbProfileHostAddress'],
                 username: _builtins.str,
                 password: Optional[_builtins.str] = None,
                 replica_set: Optional[_builtins.str] = None,
                 secret_manager_stored_password: Optional[_builtins.str] = None,
                 srv_connection_format: Optional['outputs.ConnectionProfileMongodbProfileSrvConnectionFormat'] = None,
                 ssl_config: Optional['outputs.ConnectionProfileMongodbProfileSslConfig'] = None,
                 standard_connection_format: Optional['outputs.ConnectionProfileMongodbProfileStandardConnectionFormat'] = None):
        """
        :param Sequence['ConnectionProfileMongodbProfileHostAddressArgs'] host_addresses: List of host addresses for a MongoDB cluster.
               Structure is documented below.
        :param _builtins.str username: Username for the MongoDB connection.
        :param _builtins.str password: Password for the MongoDB connection. Mutually exclusive with
               secretManagerStoredPassword.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.str replica_set: Name of the replica set.
        :param _builtins.str secret_manager_stored_password: A reference to a Secret Manager resource name storing the MongoDB
               connection password. Mutually exclusive with password.
        :param 'ConnectionProfileMongodbProfileSrvConnectionFormatArgs' srv_connection_format: Srv connection format. Mutually exclusive with
               standard_connection_Format.
        :param 'ConnectionProfileMongodbProfileSslConfigArgs' ssl_config: SSL configuration for the MongoDB connection.
               Structure is documented below.
        :param 'ConnectionProfileMongodbProfileStandardConnectionFormatArgs' standard_connection_format: Standard connection format. Mutually exclusive with
               srv_connection_format.
               Structure is documented below.
        """
        pulumi.set(__self__, "host_addresses", host_addresses)
        pulumi.set(__self__, "username", username)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if replica_set is not None:
            pulumi.set(__self__, "replica_set", replica_set)
        if secret_manager_stored_password is not None:
            pulumi.set(__self__, "secret_manager_stored_password", secret_manager_stored_password)
        if srv_connection_format is not None:
            pulumi.set(__self__, "srv_connection_format", srv_connection_format)
        if ssl_config is not None:
            pulumi.set(__self__, "ssl_config", ssl_config)
        if standard_connection_format is not None:
            pulumi.set(__self__, "standard_connection_format", standard_connection_format)

    @_builtins.property
    @pulumi.getter(name="hostAddresses")
    def host_addresses(self) -> Sequence['outputs.ConnectionProfileMongodbProfileHostAddress']:
        """
        List of host addresses for a MongoDB cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "host_addresses")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username for the MongoDB connection.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password for the MongoDB connection. Mutually exclusive with
        secretManagerStoredPassword.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="replicaSet")
    def replica_set(self) -> Optional[_builtins.str]:
        """
        Name of the replica set.
        """
        return pulumi.get(self, "replica_set")

    @_builtins.property
    @pulumi.getter(name="secretManagerStoredPassword")
    def secret_manager_stored_password(self) -> Optional[_builtins.str]:
        """
        A reference to a Secret Manager resource name storing the MongoDB
        connection password. Mutually exclusive with password.
        """
        return pulumi.get(self, "secret_manager_stored_password")

    @_builtins.property
    @pulumi.getter(name="srvConnectionFormat")
    def srv_connection_format(self) -> Optional['outputs.ConnectionProfileMongodbProfileSrvConnectionFormat']:
        """
        Srv connection format. Mutually exclusive with
        standard_connection_Format.
        """
        return pulumi.get(self, "srv_connection_format")

    @_builtins.property
    @pulumi.getter(name="sslConfig")
    def ssl_config(self) -> Optional['outputs.ConnectionProfileMongodbProfileSslConfig']:
        """
        SSL configuration for the MongoDB connection.
        Structure is documented below.
        """
        return pulumi.get(self, "ssl_config")

    @_builtins.property
    @pulumi.getter(name="standardConnectionFormat")
    def standard_connection_format(self) -> Optional['outputs.ConnectionProfileMongodbProfileStandardConnectionFormat']:
        """
        Standard connection format. Mutually exclusive with
        srv_connection_format.
        Structure is documented below.
        """
        return pulumi.get(self, "standard_connection_format")


@pulumi.output_type
class ConnectionProfileMongodbProfileHostAddress(dict):
    def __init__(__self__, *,
                 hostname: _builtins.str,
                 port: Optional[_builtins.int] = None):
        """
        :param _builtins.str hostname: Hostname for the connection.
        :param _builtins.int port: Port for the connection.
        """
        pulumi.set(__self__, "hostname", hostname)
        if port is not None:
            pulumi.set(__self__, "port", port)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Hostname for the connection.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port for the connection.
        """
        return pulumi.get(self, "port")


@pulumi.output_type
class ConnectionProfileMongodbProfileSrvConnectionFormat(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class ConnectionProfileMongodbProfileSslConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "caCertificateSet":
            suggest = "ca_certificate_set"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientCertificateSet":
            suggest = "client_certificate_set"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clientKeySet":
            suggest = "client_key_set"
        elif key == "secretManagerStoredClientKey":
            suggest = "secret_manager_stored_client_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionProfileMongodbProfileSslConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionProfileMongodbProfileSslConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionProfileMongodbProfileSslConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[_builtins.str] = None,
                 ca_certificate_set: Optional[_builtins.bool] = None,
                 client_certificate: Optional[_builtins.str] = None,
                 client_certificate_set: Optional[_builtins.bool] = None,
                 client_key: Optional[_builtins.str] = None,
                 client_key_set: Optional[_builtins.bool] = None,
                 secret_manager_stored_client_key: Optional[_builtins.str] = None):
        """
        :param _builtins.str ca_certificate: PEM-encoded certificate of the CA that signed the source database
               server's certificate.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.bool ca_certificate_set: (Output)
               Indicates whether the clientKey field is set.
        :param _builtins.str client_certificate: PEM-encoded certificate that will be used by the replica to
               authenticate against the source database server. If this field
               is used then the 'clientKey' and the 'caCertificate' fields are
               mandatory.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.bool client_certificate_set: (Output)
               Indicates whether the clientCertificate field is set.
        :param _builtins.str client_key: PEM-encoded private key associated with the Client Certificate.
               If this field is used then the 'client_certificate' and the
               'ca_certificate' fields are mandatory.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.bool client_key_set: (Output)
               Indicates whether the clientKey field is set.
        :param _builtins.str secret_manager_stored_client_key: A reference to a Secret Manager resource name storing the
               PEM-encoded private key. Mutually exclusive with clientKey.
               **Note**: This property is sensitive and will not be displayed in the plan.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if ca_certificate_set is not None:
            pulumi.set(__self__, "ca_certificate_set", ca_certificate_set)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_certificate_set is not None:
            pulumi.set(__self__, "client_certificate_set", client_certificate_set)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_key_set is not None:
            pulumi.set(__self__, "client_key_set", client_key_set)
        if secret_manager_stored_client_key is not None:
            pulumi.set(__self__, "secret_manager_stored_client_key", secret_manager_stored_client_key)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[_builtins.str]:
        """
        PEM-encoded certificate of the CA that signed the source database
        server's certificate.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "ca_certificate")

    @_builtins.property
    @pulumi.getter(name="caCertificateSet")
    def ca_certificate_set(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Indicates whether the clientKey field is set.
        """
        return pulumi.get(self, "ca_certificate_set")

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        PEM-encoded certificate that will be used by the replica to
        authenticate against the source database server. If this field
        is used then the 'clientKey' and the 'caCertificate' fields are
        mandatory.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientCertificateSet")
    def client_certificate_set(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Indicates whether the clientCertificate field is set.
        """
        return pulumi.get(self, "client_certificate_set")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        PEM-encoded private key associated with the Client Certificate.
        If this field is used then the 'client_certificate' and the
        'ca_certificate' fields are mandatory.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="clientKeySet")
    def client_key_set(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Indicates whether the clientKey field is set.
        """
        return pulumi.get(self, "client_key_set")

    @_builtins.property
    @pulumi.getter(name="secretManagerStoredClientKey")
    def secret_manager_stored_client_key(self) -> Optional[_builtins.str]:
        """
        A reference to a Secret Manager resource name storing the
        PEM-encoded private key. Mutually exclusive with clientKey.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "secret_manager_stored_client_key")


@pulumi.output_type
class ConnectionProfileMongodbProfileStandardConnectionFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "directConnection":
            suggest = "direct_connection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionProfileMongodbProfileStandardConnectionFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionProfileMongodbProfileStandardConnectionFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionProfileMongodbProfileStandardConnectionFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 direct_connection: Optional[_builtins.bool] = None):
        """
        :param _builtins.bool direct_connection: Specifies whether the client connects directly to the
               host[:port] in the connection URI.
        """
        if direct_connection is not None:
            pulumi.set(__self__, "direct_connection", direct_connection)

    @_builtins.property
    @pulumi.getter(name="directConnection")
    def direct_connection(self) -> Optional[_builtins.bool]:
        """
        Specifies whether the client connects directly to the
        host[:port] in the connection URI.
        """
        return pulumi.get(self, "direct_connection")


@pulumi.output_type
class ConnectionProfileMysqlProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretManagerStoredPassword":
            suggest = "secret_manager_stored_password"
        elif key == "sslConfig":
            suggest = "ssl_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionProfileMysqlProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionProfileMysqlProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionProfileMysqlProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 hostname: _builtins.str,
                 username: _builtins.str,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 secret_manager_stored_password: Optional[_builtins.str] = None,
                 ssl_config: Optional['outputs.ConnectionProfileMysqlProfileSslConfig'] = None):
        """
        :param _builtins.str hostname: Hostname for the MySQL connection.
        :param _builtins.str username: Username for the MySQL connection.
        :param _builtins.str password: Password for the MySQL connection.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.int port: Port for the MySQL connection.
        :param _builtins.str secret_manager_stored_password: A reference to a Secret Manager resource name storing the user's password.
        :param 'ConnectionProfileMysqlProfileSslConfigArgs' ssl_config: SSL configuration for the MySQL connection.
               Structure is documented below.
        """
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "username", username)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret_manager_stored_password is not None:
            pulumi.set(__self__, "secret_manager_stored_password", secret_manager_stored_password)
        if ssl_config is not None:
            pulumi.set(__self__, "ssl_config", ssl_config)

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Hostname for the MySQL connection.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username for the MySQL connection.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password for the MySQL connection.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port for the MySQL connection.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="secretManagerStoredPassword")
    def secret_manager_stored_password(self) -> Optional[_builtins.str]:
        """
        A reference to a Secret Manager resource name storing the user's password.
        """
        return pulumi.get(self, "secret_manager_stored_password")

    @_builtins.property
    @pulumi.getter(name="sslConfig")
    def ssl_config(self) -> Optional['outputs.ConnectionProfileMysqlProfileSslConfig']:
        """
        SSL configuration for the MySQL connection.
        Structure is documented below.
        """
        return pulumi.get(self, "ssl_config")


@pulumi.output_type
class ConnectionProfileMysqlProfileSslConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "caCertificate":
            suggest = "ca_certificate"
        elif key == "caCertificateSet":
            suggest = "ca_certificate_set"
        elif key == "clientCertificate":
            suggest = "client_certificate"
        elif key == "clientCertificateSet":
            suggest = "client_certificate_set"
        elif key == "clientKey":
            suggest = "client_key"
        elif key == "clientKeySet":
            suggest = "client_key_set"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionProfileMysqlProfileSslConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionProfileMysqlProfileSslConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionProfileMysqlProfileSslConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 ca_certificate: Optional[_builtins.str] = None,
                 ca_certificate_set: Optional[_builtins.bool] = None,
                 client_certificate: Optional[_builtins.str] = None,
                 client_certificate_set: Optional[_builtins.bool] = None,
                 client_key: Optional[_builtins.str] = None,
                 client_key_set: Optional[_builtins.bool] = None):
        """
        :param _builtins.str ca_certificate: PEM-encoded certificate of the CA that signed the source database
               server's certificate.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.bool ca_certificate_set: (Output)
               Indicates whether the clientKey field is set.
        :param _builtins.str client_certificate: PEM-encoded certificate that will be used by the replica to
               authenticate against the source database server. If this field
               is used then the 'clientKey' and the 'caCertificate' fields are
               mandatory.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.bool client_certificate_set: (Output)
               Indicates whether the clientCertificate field is set.
        :param _builtins.str client_key: PEM-encoded private key associated with the Client Certificate.
               If this field is used then the 'client_certificate' and the
               'ca_certificate' fields are mandatory.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.bool client_key_set: (Output)
               Indicates whether the clientKey field is set.
        """
        if ca_certificate is not None:
            pulumi.set(__self__, "ca_certificate", ca_certificate)
        if ca_certificate_set is not None:
            pulumi.set(__self__, "ca_certificate_set", ca_certificate_set)
        if client_certificate is not None:
            pulumi.set(__self__, "client_certificate", client_certificate)
        if client_certificate_set is not None:
            pulumi.set(__self__, "client_certificate_set", client_certificate_set)
        if client_key is not None:
            pulumi.set(__self__, "client_key", client_key)
        if client_key_set is not None:
            pulumi.set(__self__, "client_key_set", client_key_set)

    @_builtins.property
    @pulumi.getter(name="caCertificate")
    def ca_certificate(self) -> Optional[_builtins.str]:
        """
        PEM-encoded certificate of the CA that signed the source database
        server's certificate.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "ca_certificate")

    @_builtins.property
    @pulumi.getter(name="caCertificateSet")
    def ca_certificate_set(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Indicates whether the clientKey field is set.
        """
        return pulumi.get(self, "ca_certificate_set")

    @_builtins.property
    @pulumi.getter(name="clientCertificate")
    def client_certificate(self) -> Optional[_builtins.str]:
        """
        PEM-encoded certificate that will be used by the replica to
        authenticate against the source database server. If this field
        is used then the 'clientKey' and the 'caCertificate' fields are
        mandatory.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "client_certificate")

    @_builtins.property
    @pulumi.getter(name="clientCertificateSet")
    def client_certificate_set(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Indicates whether the clientCertificate field is set.
        """
        return pulumi.get(self, "client_certificate_set")

    @_builtins.property
    @pulumi.getter(name="clientKey")
    def client_key(self) -> Optional[_builtins.str]:
        """
        PEM-encoded private key associated with the Client Certificate.
        If this field is used then the 'client_certificate' and the
        'ca_certificate' fields are mandatory.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "client_key")

    @_builtins.property
    @pulumi.getter(name="clientKeySet")
    def client_key_set(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Indicates whether the clientKey field is set.
        """
        return pulumi.get(self, "client_key_set")


@pulumi.output_type
class ConnectionProfileOracleProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "databaseService":
            suggest = "database_service"
        elif key == "connectionAttributes":
            suggest = "connection_attributes"
        elif key == "secretManagerStoredPassword":
            suggest = "secret_manager_stored_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionProfileOracleProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionProfileOracleProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionProfileOracleProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database_service: _builtins.str,
                 hostname: _builtins.str,
                 username: _builtins.str,
                 connection_attributes: Optional[Mapping[str, _builtins.str]] = None,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 secret_manager_stored_password: Optional[_builtins.str] = None):
        """
        :param _builtins.str database_service: Database for the Oracle connection.
        :param _builtins.str hostname: Hostname for the Oracle connection.
        :param _builtins.str username: Username for the Oracle connection.
        :param Mapping[str, _builtins.str] connection_attributes: Connection string attributes
        :param _builtins.str password: Password for the Oracle connection.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.int port: Port for the Oracle connection.
        :param _builtins.str secret_manager_stored_password: A reference to a Secret Manager resource name storing the user's password.
        """
        pulumi.set(__self__, "database_service", database_service)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "username", username)
        if connection_attributes is not None:
            pulumi.set(__self__, "connection_attributes", connection_attributes)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret_manager_stored_password is not None:
            pulumi.set(__self__, "secret_manager_stored_password", secret_manager_stored_password)

    @_builtins.property
    @pulumi.getter(name="databaseService")
    def database_service(self) -> _builtins.str:
        """
        Database for the Oracle connection.
        """
        return pulumi.get(self, "database_service")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Hostname for the Oracle connection.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username for the Oracle connection.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter(name="connectionAttributes")
    def connection_attributes(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        Connection string attributes
        """
        return pulumi.get(self, "connection_attributes")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password for the Oracle connection.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port for the Oracle connection.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="secretManagerStoredPassword")
    def secret_manager_stored_password(self) -> Optional[_builtins.str]:
        """
        A reference to a Secret Manager resource name storing the user's password.
        """
        return pulumi.get(self, "secret_manager_stored_password")


@pulumi.output_type
class ConnectionProfilePostgresqlProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretManagerStoredPassword":
            suggest = "secret_manager_stored_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionProfilePostgresqlProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionProfilePostgresqlProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionProfilePostgresqlProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 username: _builtins.str,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 secret_manager_stored_password: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: Database for the PostgreSQL connection.
        :param _builtins.str hostname: Hostname for the PostgreSQL connection.
        :param _builtins.str username: Username for the PostgreSQL connection.
        :param _builtins.str password: Password for the PostgreSQL connection.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.int port: Port for the PostgreSQL connection.
        :param _builtins.str secret_manager_stored_password: A reference to a Secret Manager resource name storing the user's password.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "username", username)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret_manager_stored_password is not None:
            pulumi.set(__self__, "secret_manager_stored_password", secret_manager_stored_password)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        Database for the PostgreSQL connection.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Hostname for the PostgreSQL connection.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username for the PostgreSQL connection.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password for the PostgreSQL connection.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port for the PostgreSQL connection.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="secretManagerStoredPassword")
    def secret_manager_stored_password(self) -> Optional[_builtins.str]:
        """
        A reference to a Secret Manager resource name storing the user's password.
        """
        return pulumi.get(self, "secret_manager_stored_password")


@pulumi.output_type
class ConnectionProfilePrivateConnectivity(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "privateConnection":
            suggest = "private_connection"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionProfilePrivateConnectivity. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionProfilePrivateConnectivity.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionProfilePrivateConnectivity.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 private_connection: _builtins.str):
        """
        :param _builtins.str private_connection: A reference to a private connection resource. Format: `projects/{project}/locations/{location}/privateConnections/{name}`
        """
        pulumi.set(__self__, "private_connection", private_connection)

    @_builtins.property
    @pulumi.getter(name="privateConnection")
    def private_connection(self) -> _builtins.str:
        """
        A reference to a private connection resource. Format: `projects/{project}/locations/{location}/privateConnections/{name}`
        """
        return pulumi.get(self, "private_connection")


@pulumi.output_type
class ConnectionProfileSalesforceProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oauth2ClientCredentials":
            suggest = "oauth2_client_credentials"
        elif key == "userCredentials":
            suggest = "user_credentials"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionProfileSalesforceProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionProfileSalesforceProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionProfileSalesforceProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 domain: _builtins.str,
                 oauth2_client_credentials: Optional['outputs.ConnectionProfileSalesforceProfileOauth2ClientCredentials'] = None,
                 user_credentials: Optional['outputs.ConnectionProfileSalesforceProfileUserCredentials'] = None):
        """
        :param _builtins.str domain: Domain for the Salesforce Org.
        :param 'ConnectionProfileSalesforceProfileOauth2ClientCredentialsArgs' oauth2_client_credentials: OAuth credentials to use for Salesforce authentication.
               Structure is documented below.
        :param 'ConnectionProfileSalesforceProfileUserCredentialsArgs' user_credentials: User credentials to use for Salesforce authentication.
               Structure is documented below.
        """
        pulumi.set(__self__, "domain", domain)
        if oauth2_client_credentials is not None:
            pulumi.set(__self__, "oauth2_client_credentials", oauth2_client_credentials)
        if user_credentials is not None:
            pulumi.set(__self__, "user_credentials", user_credentials)

    @_builtins.property
    @pulumi.getter
    def domain(self) -> _builtins.str:
        """
        Domain for the Salesforce Org.
        """
        return pulumi.get(self, "domain")

    @_builtins.property
    @pulumi.getter(name="oauth2ClientCredentials")
    def oauth2_client_credentials(self) -> Optional['outputs.ConnectionProfileSalesforceProfileOauth2ClientCredentials']:
        """
        OAuth credentials to use for Salesforce authentication.
        Structure is documented below.
        """
        return pulumi.get(self, "oauth2_client_credentials")

    @_builtins.property
    @pulumi.getter(name="userCredentials")
    def user_credentials(self) -> Optional['outputs.ConnectionProfileSalesforceProfileUserCredentials']:
        """
        User credentials to use for Salesforce authentication.
        Structure is documented below.
        """
        return pulumi.get(self, "user_credentials")


@pulumi.output_type
class ConnectionProfileSalesforceProfileOauth2ClientCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "clientId":
            suggest = "client_id"
        elif key == "clientSecret":
            suggest = "client_secret"
        elif key == "secretManagerStoredClientSecret":
            suggest = "secret_manager_stored_client_secret"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionProfileSalesforceProfileOauth2ClientCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionProfileSalesforceProfileOauth2ClientCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionProfileSalesforceProfileOauth2ClientCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 client_id: Optional[_builtins.str] = None,
                 client_secret: Optional[_builtins.str] = None,
                 secret_manager_stored_client_secret: Optional[_builtins.str] = None):
        """
        :param _builtins.str client_id: Client ID to use for authentication.
        :param _builtins.str client_secret: Client secret to use for authentication.
        :param _builtins.str secret_manager_stored_client_secret: A reference to a Secret Manager resource name storing the client secret.
        """
        if client_id is not None:
            pulumi.set(__self__, "client_id", client_id)
        if client_secret is not None:
            pulumi.set(__self__, "client_secret", client_secret)
        if secret_manager_stored_client_secret is not None:
            pulumi.set(__self__, "secret_manager_stored_client_secret", secret_manager_stored_client_secret)

    @_builtins.property
    @pulumi.getter(name="clientId")
    def client_id(self) -> Optional[_builtins.str]:
        """
        Client ID to use for authentication.
        """
        return pulumi.get(self, "client_id")

    @_builtins.property
    @pulumi.getter(name="clientSecret")
    def client_secret(self) -> Optional[_builtins.str]:
        """
        Client secret to use for authentication.
        """
        return pulumi.get(self, "client_secret")

    @_builtins.property
    @pulumi.getter(name="secretManagerStoredClientSecret")
    def secret_manager_stored_client_secret(self) -> Optional[_builtins.str]:
        """
        A reference to a Secret Manager resource name storing the client secret.
        """
        return pulumi.get(self, "secret_manager_stored_client_secret")


@pulumi.output_type
class ConnectionProfileSalesforceProfileUserCredentials(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretManagerStoredPassword":
            suggest = "secret_manager_stored_password"
        elif key == "secretManagerStoredSecurityToken":
            suggest = "secret_manager_stored_security_token"
        elif key == "securityToken":
            suggest = "security_token"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionProfileSalesforceProfileUserCredentials. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionProfileSalesforceProfileUserCredentials.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionProfileSalesforceProfileUserCredentials.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 password: Optional[_builtins.str] = None,
                 secret_manager_stored_password: Optional[_builtins.str] = None,
                 secret_manager_stored_security_token: Optional[_builtins.str] = None,
                 security_token: Optional[_builtins.str] = None,
                 username: Optional[_builtins.str] = None):
        """
        :param _builtins.str password: Password of the user.
        :param _builtins.str secret_manager_stored_password: A reference to a Secret Manager resource name storing the user's password.
        :param _builtins.str secret_manager_stored_security_token: A reference to a Secret Manager resource name storing the user's security token.
               
               <a name="nested_salesforce_profile_oauth2_client_credentials"></a>The `oauth2_client_credentials` block supports:
        :param _builtins.str security_token: Security token of the user.
        :param _builtins.str username: Username to use for authentication.
        """
        if password is not None:
            pulumi.set(__self__, "password", password)
        if secret_manager_stored_password is not None:
            pulumi.set(__self__, "secret_manager_stored_password", secret_manager_stored_password)
        if secret_manager_stored_security_token is not None:
            pulumi.set(__self__, "secret_manager_stored_security_token", secret_manager_stored_security_token)
        if security_token is not None:
            pulumi.set(__self__, "security_token", security_token)
        if username is not None:
            pulumi.set(__self__, "username", username)

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password of the user.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter(name="secretManagerStoredPassword")
    def secret_manager_stored_password(self) -> Optional[_builtins.str]:
        """
        A reference to a Secret Manager resource name storing the user's password.
        """
        return pulumi.get(self, "secret_manager_stored_password")

    @_builtins.property
    @pulumi.getter(name="secretManagerStoredSecurityToken")
    def secret_manager_stored_security_token(self) -> Optional[_builtins.str]:
        """
        A reference to a Secret Manager resource name storing the user's security token.

        <a name="nested_salesforce_profile_oauth2_client_credentials"></a>The `oauth2_client_credentials` block supports:
        """
        return pulumi.get(self, "secret_manager_stored_security_token")

    @_builtins.property
    @pulumi.getter(name="securityToken")
    def security_token(self) -> Optional[_builtins.str]:
        """
        Security token of the user.
        """
        return pulumi.get(self, "security_token")

    @_builtins.property
    @pulumi.getter
    def username(self) -> Optional[_builtins.str]:
        """
        Username to use for authentication.
        """
        return pulumi.get(self, "username")


@pulumi.output_type
class ConnectionProfileSqlServerProfile(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "secretManagerStoredPassword":
            suggest = "secret_manager_stored_password"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in ConnectionProfileSqlServerProfile. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        ConnectionProfileSqlServerProfile.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        ConnectionProfileSqlServerProfile.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 hostname: _builtins.str,
                 username: _builtins.str,
                 password: Optional[_builtins.str] = None,
                 port: Optional[_builtins.int] = None,
                 secret_manager_stored_password: Optional[_builtins.str] = None):
        """
        :param _builtins.str database: Database for the SQL Server connection.
        :param _builtins.str hostname: Hostname for the SQL Server connection.
        :param _builtins.str username: Username for the SQL Server connection.
        :param _builtins.str password: Password for the SQL Server connection.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param _builtins.int port: Port for the SQL Server connection.
        :param _builtins.str secret_manager_stored_password: A reference to a Secret Manager resource name storing the user's password.
        """
        pulumi.set(__self__, "database", database)
        pulumi.set(__self__, "hostname", hostname)
        pulumi.set(__self__, "username", username)
        if password is not None:
            pulumi.set(__self__, "password", password)
        if port is not None:
            pulumi.set(__self__, "port", port)
        if secret_manager_stored_password is not None:
            pulumi.set(__self__, "secret_manager_stored_password", secret_manager_stored_password)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        Database for the SQL Server connection.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def hostname(self) -> _builtins.str:
        """
        Hostname for the SQL Server connection.
        """
        return pulumi.get(self, "hostname")

    @_builtins.property
    @pulumi.getter
    def username(self) -> _builtins.str:
        """
        Username for the SQL Server connection.
        """
        return pulumi.get(self, "username")

    @_builtins.property
    @pulumi.getter
    def password(self) -> Optional[_builtins.str]:
        """
        Password for the SQL Server connection.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "password")

    @_builtins.property
    @pulumi.getter
    def port(self) -> Optional[_builtins.int]:
        """
        Port for the SQL Server connection.
        """
        return pulumi.get(self, "port")

    @_builtins.property
    @pulumi.getter(name="secretManagerStoredPassword")
    def secret_manager_stored_password(self) -> Optional[_builtins.str]:
        """
        A reference to a Secret Manager resource name storing the user's password.
        """
        return pulumi.get(self, "secret_manager_stored_password")


@pulumi.output_type
class PrivateConnectionError(dict):
    def __init__(__self__, *,
                 details: Optional[Mapping[str, _builtins.str]] = None,
                 message: Optional[_builtins.str] = None):
        """
        :param Mapping[str, _builtins.str] details: A list of messages that carry the error details.
        :param _builtins.str message: A message containing more information about the error that occurred.
        """
        if details is not None:
            pulumi.set(__self__, "details", details)
        if message is not None:
            pulumi.set(__self__, "message", message)

    @_builtins.property
    @pulumi.getter
    def details(self) -> Optional[Mapping[str, _builtins.str]]:
        """
        A list of messages that carry the error details.
        """
        return pulumi.get(self, "details")

    @_builtins.property
    @pulumi.getter
    def message(self) -> Optional[_builtins.str]:
        """
        A message containing more information about the error that occurred.
        """
        return pulumi.get(self, "message")


@pulumi.output_type
class PrivateConnectionPscInterfaceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "networkAttachment":
            suggest = "network_attachment"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in PrivateConnectionPscInterfaceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        PrivateConnectionPscInterfaceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        PrivateConnectionPscInterfaceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 network_attachment: _builtins.str):
        """
        :param _builtins.str network_attachment: Fully qualified name of the network attachment that Datastream will connect to.
               Format: projects/{project}/regions/{region}/networkAttachments/{name}
               To get Datastream project for the accepted list:
               `gcloud datastream private-connections create [PC ID] --location=[LOCATION] --network-attachment=[NA URI] --validate-only --display-name=[ANY STRING]`
               Add Datastream project to the attachment accepted list:
               `gcloud compute network-attachments update [NA URI] --region=[NA region] --producer-accept-list=[TP from prev command]`
        """
        pulumi.set(__self__, "network_attachment", network_attachment)

    @_builtins.property
    @pulumi.getter(name="networkAttachment")
    def network_attachment(self) -> _builtins.str:
        """
        Fully qualified name of the network attachment that Datastream will connect to.
        Format: projects/{project}/regions/{region}/networkAttachments/{name}
        To get Datastream project for the accepted list:
        `gcloud datastream private-connections create [PC ID] --location=[LOCATION] --network-attachment=[NA URI] --validate-only --display-name=[ANY STRING]`
        Add Datastream project to the attachment accepted list:
        `gcloud compute network-attachments update [NA URI] --region=[NA region] --producer-accept-list=[TP from prev command]`
        """
        return pulumi.get(self, "network_attachment")


@pulumi.output_type
class PrivateConnectionVpcPeeringConfig(dict):
    def __init__(__self__, *,
                 subnet: _builtins.str,
                 vpc: _builtins.str):
        """
        :param _builtins.str subnet: A free subnet for peering. (CIDR of /29)
        :param _builtins.str vpc: Fully qualified name of the VPC that Datastream will peer to.
               Format: projects/{project}/global/{networks}/{name}
        """
        pulumi.set(__self__, "subnet", subnet)
        pulumi.set(__self__, "vpc", vpc)

    @_builtins.property
    @pulumi.getter
    def subnet(self) -> _builtins.str:
        """
        A free subnet for peering. (CIDR of /29)
        """
        return pulumi.get(self, "subnet")

    @_builtins.property
    @pulumi.getter
    def vpc(self) -> _builtins.str:
        """
        Fully qualified name of the VPC that Datastream will peer to.
        Format: projects/{project}/global/{networks}/{name}
        """
        return pulumi.get(self, "vpc")


@pulumi.output_type
class StreamBackfillAll(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mongodbExcludedObjects":
            suggest = "mongodb_excluded_objects"
        elif key == "mysqlExcludedObjects":
            suggest = "mysql_excluded_objects"
        elif key == "oracleExcludedObjects":
            suggest = "oracle_excluded_objects"
        elif key == "postgresqlExcludedObjects":
            suggest = "postgresql_excluded_objects"
        elif key == "salesforceExcludedObjects":
            suggest = "salesforce_excluded_objects"
        elif key == "sqlServerExcludedObjects":
            suggest = "sql_server_excluded_objects"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamBackfillAll. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamBackfillAll.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamBackfillAll.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mongodb_excluded_objects: Optional['outputs.StreamBackfillAllMongodbExcludedObjects'] = None,
                 mysql_excluded_objects: Optional['outputs.StreamBackfillAllMysqlExcludedObjects'] = None,
                 oracle_excluded_objects: Optional['outputs.StreamBackfillAllOracleExcludedObjects'] = None,
                 postgresql_excluded_objects: Optional['outputs.StreamBackfillAllPostgresqlExcludedObjects'] = None,
                 salesforce_excluded_objects: Optional['outputs.StreamBackfillAllSalesforceExcludedObjects'] = None,
                 sql_server_excluded_objects: Optional['outputs.StreamBackfillAllSqlServerExcludedObjects'] = None):
        """
        :param 'StreamBackfillAllMongodbExcludedObjectsArgs' mongodb_excluded_objects: MongoDB data source objects to avoid backfilling.
               Structure is documented below.
        :param 'StreamBackfillAllMysqlExcludedObjectsArgs' mysql_excluded_objects: MySQL data source objects to avoid backfilling.
               Structure is documented below.
        :param 'StreamBackfillAllOracleExcludedObjectsArgs' oracle_excluded_objects: PostgreSQL data source objects to avoid backfilling.
               Structure is documented below.
        :param 'StreamBackfillAllPostgresqlExcludedObjectsArgs' postgresql_excluded_objects: PostgreSQL data source objects to avoid backfilling.
               Structure is documented below.
        :param 'StreamBackfillAllSalesforceExcludedObjectsArgs' salesforce_excluded_objects: Salesforce objects to avoid backfilling.
               Structure is documented below.
        :param 'StreamBackfillAllSqlServerExcludedObjectsArgs' sql_server_excluded_objects: SQL Server data source objects to avoid backfilling.
               Structure is documented below.
        """
        if mongodb_excluded_objects is not None:
            pulumi.set(__self__, "mongodb_excluded_objects", mongodb_excluded_objects)
        if mysql_excluded_objects is not None:
            pulumi.set(__self__, "mysql_excluded_objects", mysql_excluded_objects)
        if oracle_excluded_objects is not None:
            pulumi.set(__self__, "oracle_excluded_objects", oracle_excluded_objects)
        if postgresql_excluded_objects is not None:
            pulumi.set(__self__, "postgresql_excluded_objects", postgresql_excluded_objects)
        if salesforce_excluded_objects is not None:
            pulumi.set(__self__, "salesforce_excluded_objects", salesforce_excluded_objects)
        if sql_server_excluded_objects is not None:
            pulumi.set(__self__, "sql_server_excluded_objects", sql_server_excluded_objects)

    @_builtins.property
    @pulumi.getter(name="mongodbExcludedObjects")
    def mongodb_excluded_objects(self) -> Optional['outputs.StreamBackfillAllMongodbExcludedObjects']:
        """
        MongoDB data source objects to avoid backfilling.
        Structure is documented below.
        """
        return pulumi.get(self, "mongodb_excluded_objects")

    @_builtins.property
    @pulumi.getter(name="mysqlExcludedObjects")
    def mysql_excluded_objects(self) -> Optional['outputs.StreamBackfillAllMysqlExcludedObjects']:
        """
        MySQL data source objects to avoid backfilling.
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_excluded_objects")

    @_builtins.property
    @pulumi.getter(name="oracleExcludedObjects")
    def oracle_excluded_objects(self) -> Optional['outputs.StreamBackfillAllOracleExcludedObjects']:
        """
        PostgreSQL data source objects to avoid backfilling.
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_excluded_objects")

    @_builtins.property
    @pulumi.getter(name="postgresqlExcludedObjects")
    def postgresql_excluded_objects(self) -> Optional['outputs.StreamBackfillAllPostgresqlExcludedObjects']:
        """
        PostgreSQL data source objects to avoid backfilling.
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_excluded_objects")

    @_builtins.property
    @pulumi.getter(name="salesforceExcludedObjects")
    def salesforce_excluded_objects(self) -> Optional['outputs.StreamBackfillAllSalesforceExcludedObjects']:
        """
        Salesforce objects to avoid backfilling.
        Structure is documented below.
        """
        return pulumi.get(self, "salesforce_excluded_objects")

    @_builtins.property
    @pulumi.getter(name="sqlServerExcludedObjects")
    def sql_server_excluded_objects(self) -> Optional['outputs.StreamBackfillAllSqlServerExcludedObjects']:
        """
        SQL Server data source objects to avoid backfilling.
        Structure is documented below.
        """
        return pulumi.get(self, "sql_server_excluded_objects")


@pulumi.output_type
class StreamBackfillAllMongodbExcludedObjects(dict):
    def __init__(__self__, *,
                 databases: Sequence['outputs.StreamBackfillAllMongodbExcludedObjectsDatabase']):
        """
        :param Sequence['StreamBackfillAllMongodbExcludedObjectsDatabaseArgs'] databases: MongoDB databases in the cluster.
               Structure is documented below.
        """
        pulumi.set(__self__, "databases", databases)

    @_builtins.property
    @pulumi.getter
    def databases(self) -> Sequence['outputs.StreamBackfillAllMongodbExcludedObjectsDatabase']:
        """
        MongoDB databases in the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "databases")


@pulumi.output_type
class StreamBackfillAllMongodbExcludedObjectsDatabase(dict):
    def __init__(__self__, *,
                 database: _builtins.str,
                 collections: Optional[Sequence['outputs.StreamBackfillAllMongodbExcludedObjectsDatabaseCollection']] = None):
        """
        :param _builtins.str database: Database name.
        :param Sequence['StreamBackfillAllMongodbExcludedObjectsDatabaseCollectionArgs'] collections: Collections in the database.
               Structure is documented below.
        """
        pulumi.set(__self__, "database", database)
        if collections is not None:
            pulumi.set(__self__, "collections", collections)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        Database name.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter
    def collections(self) -> Optional[Sequence['outputs.StreamBackfillAllMongodbExcludedObjectsDatabaseCollection']]:
        """
        Collections in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "collections")


@pulumi.output_type
class StreamBackfillAllMongodbExcludedObjectsDatabaseCollection(dict):
    def __init__(__self__, *,
                 collection: _builtins.str,
                 fields: Optional[Sequence['outputs.StreamBackfillAllMongodbExcludedObjectsDatabaseCollectionField']] = None):
        """
        :param _builtins.str collection: Collection name.
        :param Sequence['StreamBackfillAllMongodbExcludedObjectsDatabaseCollectionFieldArgs'] fields: Fields in the collection.
               Structure is documented below.
        """
        pulumi.set(__self__, "collection", collection)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @_builtins.property
    @pulumi.getter
    def collection(self) -> _builtins.str:
        """
        Collection name.
        """
        return pulumi.get(self, "collection")

    @_builtins.property
    @pulumi.getter
    def fields(self) -> Optional[Sequence['outputs.StreamBackfillAllMongodbExcludedObjectsDatabaseCollectionField']]:
        """
        Fields in the collection.
        Structure is documented below.
        """
        return pulumi.get(self, "fields")


@pulumi.output_type
class StreamBackfillAllMongodbExcludedObjectsDatabaseCollectionField(dict):
    def __init__(__self__, *,
                 field: Optional[_builtins.str] = None):
        """
        :param _builtins.str field: Field name.
        """
        if field is not None:
            pulumi.set(__self__, "field", field)

    @_builtins.property
    @pulumi.getter
    def field(self) -> Optional[_builtins.str]:
        """
        Field name.
        """
        return pulumi.get(self, "field")


@pulumi.output_type
class StreamBackfillAllMysqlExcludedObjects(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mysqlDatabases":
            suggest = "mysql_databases"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamBackfillAllMysqlExcludedObjects. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamBackfillAllMysqlExcludedObjects.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamBackfillAllMysqlExcludedObjects.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mysql_databases: Sequence['outputs.StreamBackfillAllMysqlExcludedObjectsMysqlDatabase']):
        """
        :param Sequence['StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseArgs'] mysql_databases: MySQL databases on the server
               Structure is documented below.
        """
        pulumi.set(__self__, "mysql_databases", mysql_databases)

    @_builtins.property
    @pulumi.getter(name="mysqlDatabases")
    def mysql_databases(self) -> Sequence['outputs.StreamBackfillAllMysqlExcludedObjectsMysqlDatabase']:
        """
        MySQL databases on the server
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_databases")


@pulumi.output_type
class StreamBackfillAllMysqlExcludedObjectsMysqlDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mysqlTables":
            suggest = "mysql_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamBackfillAllMysqlExcludedObjectsMysqlDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamBackfillAllMysqlExcludedObjectsMysqlDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamBackfillAllMysqlExcludedObjectsMysqlDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 mysql_tables: Optional[Sequence['outputs.StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTable']] = None):
        """
        :param _builtins.str database: Database name.
        :param Sequence['StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableArgs'] mysql_tables: Tables in the database.
               Structure is documented below.
        """
        pulumi.set(__self__, "database", database)
        if mysql_tables is not None:
            pulumi.set(__self__, "mysql_tables", mysql_tables)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        Database name.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="mysqlTables")
    def mysql_tables(self) -> Optional[Sequence['outputs.StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTable']]:
        """
        Tables in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_tables")


@pulumi.output_type
class StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mysqlColumns":
            suggest = "mysql_columns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table: _builtins.str,
                 mysql_columns: Optional[Sequence['outputs.StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumn']] = None):
        """
        :param _builtins.str table: Table name.
        :param Sequence['StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumnArgs'] mysql_columns: MySQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if mysql_columns is not None:
            pulumi.set(__self__, "mysql_columns", mysql_columns)

    @_builtins.property
    @pulumi.getter
    def table(self) -> _builtins.str:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @_builtins.property
    @pulumi.getter(name="mysqlColumns")
    def mysql_columns(self) -> Optional[Sequence['outputs.StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumn']]:
        """
        MySQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_columns")


@pulumi.output_type
class StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "ordinalPosition":
            suggest = "ordinal_position"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamBackfillAllMysqlExcludedObjectsMysqlDatabaseMysqlTableMysqlColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collation: Optional[_builtins.str] = None,
                 column: Optional[_builtins.str] = None,
                 data_type: Optional[_builtins.str] = None,
                 length: Optional[_builtins.int] = None,
                 nullable: Optional[_builtins.bool] = None,
                 ordinal_position: Optional[_builtins.int] = None,
                 primary_key: Optional[_builtins.bool] = None):
        """
        :param _builtins.str collation: Column collation.
        :param _builtins.str column: Column name.
        :param _builtins.str data_type: The MySQL data type. Full data types list can be found here:
               https://dev.mysql.com/doc/refman/8.0/en/data-types.html
        :param _builtins.int length: (Output)
               Column length.
        :param _builtins.bool nullable: Whether or not the column can accept a null value.
        :param _builtins.int ordinal_position: The ordinal position of the column in the table.
        :param _builtins.bool primary_key: Whether or not the column represents a primary key.
        """
        if collation is not None:
            pulumi.set(__self__, "collation", collation)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)

    @_builtins.property
    @pulumi.getter
    def collation(self) -> Optional[_builtins.str]:
        """
        Column collation.
        """
        return pulumi.get(self, "collation")

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[_builtins.str]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        The MySQL data type. Full data types list can be found here:
        https://dev.mysql.com/doc/refman/8.0/en/data-types.html
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[_builtins.int]:
        """
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @_builtins.property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[_builtins.bool]:
        """
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")


@pulumi.output_type
class StreamBackfillAllOracleExcludedObjects(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oracleSchemas":
            suggest = "oracle_schemas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamBackfillAllOracleExcludedObjects. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamBackfillAllOracleExcludedObjects.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamBackfillAllOracleExcludedObjects.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oracle_schemas: Sequence['outputs.StreamBackfillAllOracleExcludedObjectsOracleSchema']):
        """
        :param Sequence['StreamBackfillAllOracleExcludedObjectsOracleSchemaArgs'] oracle_schemas: Oracle schemas/databases in the database server
               Structure is documented below.
        """
        pulumi.set(__self__, "oracle_schemas", oracle_schemas)

    @_builtins.property
    @pulumi.getter(name="oracleSchemas")
    def oracle_schemas(self) -> Sequence['outputs.StreamBackfillAllOracleExcludedObjectsOracleSchema']:
        """
        Oracle schemas/databases in the database server
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_schemas")


@pulumi.output_type
class StreamBackfillAllOracleExcludedObjectsOracleSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oracleTables":
            suggest = "oracle_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamBackfillAllOracleExcludedObjectsOracleSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamBackfillAllOracleExcludedObjectsOracleSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamBackfillAllOracleExcludedObjectsOracleSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema: _builtins.str,
                 oracle_tables: Optional[Sequence['outputs.StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTable']] = None):
        """
        :param _builtins.str schema: Schema name.
        :param Sequence['StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableArgs'] oracle_tables: Tables in the database.
               Structure is documented below.
        """
        pulumi.set(__self__, "schema", schema)
        if oracle_tables is not None:
            pulumi.set(__self__, "oracle_tables", oracle_tables)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> _builtins.str:
        """
        Schema name.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="oracleTables")
    def oracle_tables(self) -> Optional[Sequence['outputs.StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTable']]:
        """
        Tables in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_tables")


@pulumi.output_type
class StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oracleColumns":
            suggest = "oracle_columns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table: _builtins.str,
                 oracle_columns: Optional[Sequence['outputs.StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumn']] = None):
        """
        :param _builtins.str table: Table name.
        :param Sequence['StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumnArgs'] oracle_columns: Oracle columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if oracle_columns is not None:
            pulumi.set(__self__, "oracle_columns", oracle_columns)

    @_builtins.property
    @pulumi.getter
    def table(self) -> _builtins.str:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @_builtins.property
    @pulumi.getter(name="oracleColumns")
    def oracle_columns(self) -> Optional[Sequence['outputs.StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumn']]:
        """
        Oracle columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_columns")


@pulumi.output_type
class StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "ordinalPosition":
            suggest = "ordinal_position"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamBackfillAllOracleExcludedObjectsOracleSchemaOracleTableOracleColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: Optional[_builtins.str] = None,
                 data_type: Optional[_builtins.str] = None,
                 encoding: Optional[_builtins.str] = None,
                 length: Optional[_builtins.int] = None,
                 nullable: Optional[_builtins.bool] = None,
                 ordinal_position: Optional[_builtins.int] = None,
                 precision: Optional[_builtins.int] = None,
                 primary_key: Optional[_builtins.bool] = None,
                 scale: Optional[_builtins.int] = None):
        """
        :param _builtins.str column: Column name.
        :param _builtins.str data_type: The Oracle data type. Full data types list can be found here:
               https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html
        :param _builtins.str encoding: (Output)
               Column encoding.
        :param _builtins.int length: (Output)
               Column length.
        :param _builtins.bool nullable: (Output)
               Whether or not the column can accept a null value.
        :param _builtins.int ordinal_position: (Output)
               The ordinal position of the column in the table.
        :param _builtins.int precision: (Output)
               Column precision.
        :param _builtins.bool primary_key: (Output)
               Whether or not the column represents a primary key.
        :param _builtins.int scale: (Output)
               Column scale.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[_builtins.str]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        The Oracle data type. Full data types list can be found here:
        https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def encoding(self) -> Optional[_builtins.str]:
        """
        (Output)
        Column encoding.
        """
        return pulumi.get(self, "encoding")

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[_builtins.int]:
        """
        (Output)
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column precision.
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column scale.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class StreamBackfillAllPostgresqlExcludedObjects(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postgresqlSchemas":
            suggest = "postgresql_schemas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamBackfillAllPostgresqlExcludedObjects. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamBackfillAllPostgresqlExcludedObjects.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamBackfillAllPostgresqlExcludedObjects.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 postgresql_schemas: Sequence['outputs.StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchema']):
        """
        :param Sequence['StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaArgs'] postgresql_schemas: PostgreSQL schemas on the server
               Structure is documented below.
        """
        pulumi.set(__self__, "postgresql_schemas", postgresql_schemas)

    @_builtins.property
    @pulumi.getter(name="postgresqlSchemas")
    def postgresql_schemas(self) -> Sequence['outputs.StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchema']:
        """
        PostgreSQL schemas on the server
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_schemas")


@pulumi.output_type
class StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postgresqlTables":
            suggest = "postgresql_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema: _builtins.str,
                 postgresql_tables: Optional[Sequence['outputs.StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTable']] = None):
        """
        :param _builtins.str schema: Database name.
        :param Sequence['StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTableArgs'] postgresql_tables: Tables in the schema.
               Structure is documented below.
        """
        pulumi.set(__self__, "schema", schema)
        if postgresql_tables is not None:
            pulumi.set(__self__, "postgresql_tables", postgresql_tables)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> _builtins.str:
        """
        Database name.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="postgresqlTables")
    def postgresql_tables(self) -> Optional[Sequence['outputs.StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTable']]:
        """
        Tables in the schema.
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_tables")


@pulumi.output_type
class StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postgresqlColumns":
            suggest = "postgresql_columns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table: _builtins.str,
                 postgresql_columns: Optional[Sequence['outputs.StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn']] = None):
        """
        :param _builtins.str table: Table name.
        :param Sequence['StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs'] postgresql_columns: PostgreSQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if postgresql_columns is not None:
            pulumi.set(__self__, "postgresql_columns", postgresql_columns)

    @_builtins.property
    @pulumi.getter
    def table(self) -> _builtins.str:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @_builtins.property
    @pulumi.getter(name="postgresqlColumns")
    def postgresql_columns(self) -> Optional[Sequence['outputs.StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn']]:
        """
        PostgreSQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_columns")


@pulumi.output_type
class StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "ordinalPosition":
            suggest = "ordinal_position"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamBackfillAllPostgresqlExcludedObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: Optional[_builtins.str] = None,
                 data_type: Optional[_builtins.str] = None,
                 length: Optional[_builtins.int] = None,
                 nullable: Optional[_builtins.bool] = None,
                 ordinal_position: Optional[_builtins.int] = None,
                 precision: Optional[_builtins.int] = None,
                 primary_key: Optional[_builtins.bool] = None,
                 scale: Optional[_builtins.int] = None):
        """
        :param _builtins.str column: Column name.
        :param _builtins.str data_type: The PostgreSQL data type. Full data types list can be found here:
               https://www.postgresql.org/docs/current/datatype.html
        :param _builtins.int length: (Output)
               Column length.
        :param _builtins.bool nullable: Whether or not the column can accept a null value.
        :param _builtins.int ordinal_position: The ordinal position of the column in the table.
        :param _builtins.int precision: (Output)
               Column precision.
        :param _builtins.bool primary_key: Whether or not the column represents a primary key.
        :param _builtins.int scale: (Output)
               Column scale.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[_builtins.str]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        The PostgreSQL data type. Full data types list can be found here:
        https://www.postgresql.org/docs/current/datatype.html
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[_builtins.int]:
        """
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column precision.
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[_builtins.bool]:
        """
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column scale.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class StreamBackfillAllSalesforceExcludedObjects(dict):
    def __init__(__self__, *,
                 objects: Sequence['outputs.StreamBackfillAllSalesforceExcludedObjectsObject']):
        """
        :param Sequence['StreamBackfillAllSalesforceExcludedObjectsObjectArgs'] objects: Salesforce objects in Salesforce Org.
               Structure is documented below.
        """
        pulumi.set(__self__, "objects", objects)

    @_builtins.property
    @pulumi.getter
    def objects(self) -> Sequence['outputs.StreamBackfillAllSalesforceExcludedObjectsObject']:
        """
        Salesforce objects in Salesforce Org.
        Structure is documented below.
        """
        return pulumi.get(self, "objects")


@pulumi.output_type
class StreamBackfillAllSalesforceExcludedObjectsObject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectName":
            suggest = "object_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamBackfillAllSalesforceExcludedObjectsObject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamBackfillAllSalesforceExcludedObjectsObject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamBackfillAllSalesforceExcludedObjectsObject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fields: Optional[Sequence['outputs.StreamBackfillAllSalesforceExcludedObjectsObjectField']] = None,
                 object_name: Optional[_builtins.str] = None):
        """
        :param Sequence['StreamBackfillAllSalesforceExcludedObjectsObjectFieldArgs'] fields: Fields in the Salesforce object. When unspecified as part of include/exclude objects, includes/excludes everything/nothing.
               Structure is documented below.
        :param _builtins.str object_name: Name of object in Salesforce Org.
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if object_name is not None:
            pulumi.set(__self__, "object_name", object_name)

    @_builtins.property
    @pulumi.getter
    def fields(self) -> Optional[Sequence['outputs.StreamBackfillAllSalesforceExcludedObjectsObjectField']]:
        """
        Fields in the Salesforce object. When unspecified as part of include/exclude objects, includes/excludes everything/nothing.
        Structure is documented below.
        """
        return pulumi.get(self, "fields")

    @_builtins.property
    @pulumi.getter(name="objectName")
    def object_name(self) -> Optional[_builtins.str]:
        """
        Name of object in Salesforce Org.
        """
        return pulumi.get(self, "object_name")


@pulumi.output_type
class StreamBackfillAllSalesforceExcludedObjectsObjectField(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Field name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Field name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class StreamBackfillAllSqlServerExcludedObjects(dict):
    def __init__(__self__, *,
                 schemas: Sequence['outputs.StreamBackfillAllSqlServerExcludedObjectsSchema']):
        """
        :param Sequence['StreamBackfillAllSqlServerExcludedObjectsSchemaArgs'] schemas: SQL Server schemas/databases in the database server
               Structure is documented below.
        """
        pulumi.set(__self__, "schemas", schemas)

    @_builtins.property
    @pulumi.getter
    def schemas(self) -> Sequence['outputs.StreamBackfillAllSqlServerExcludedObjectsSchema']:
        """
        SQL Server schemas/databases in the database server
        Structure is documented below.
        """
        return pulumi.get(self, "schemas")


@pulumi.output_type
class StreamBackfillAllSqlServerExcludedObjectsSchema(dict):
    def __init__(__self__, *,
                 schema: _builtins.str,
                 tables: Optional[Sequence['outputs.StreamBackfillAllSqlServerExcludedObjectsSchemaTable']] = None):
        """
        :param _builtins.str schema: Schema name.
        :param Sequence['StreamBackfillAllSqlServerExcludedObjectsSchemaTableArgs'] tables: Tables in the database.
               Structure is documented below.
        """
        pulumi.set(__self__, "schema", schema)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> _builtins.str:
        """
        Schema name.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional[Sequence['outputs.StreamBackfillAllSqlServerExcludedObjectsSchemaTable']]:
        """
        Tables in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "tables")


@pulumi.output_type
class StreamBackfillAllSqlServerExcludedObjectsSchemaTable(dict):
    def __init__(__self__, *,
                 table: _builtins.str,
                 columns: Optional[Sequence['outputs.StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumn']] = None):
        """
        :param _builtins.str table: Table name.
        :param Sequence['StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumnArgs'] columns: SQL Server columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)

    @_builtins.property
    @pulumi.getter
    def table(self) -> _builtins.str:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumn']]:
        """
        SQL Server columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "columns")


@pulumi.output_type
class StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "ordinalPosition":
            suggest = "ordinal_position"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamBackfillAllSqlServerExcludedObjectsSchemaTableColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: Optional[_builtins.str] = None,
                 data_type: Optional[_builtins.str] = None,
                 length: Optional[_builtins.int] = None,
                 nullable: Optional[_builtins.bool] = None,
                 ordinal_position: Optional[_builtins.int] = None,
                 precision: Optional[_builtins.int] = None,
                 primary_key: Optional[_builtins.bool] = None,
                 scale: Optional[_builtins.int] = None):
        """
        :param _builtins.str column: Column name.
        :param _builtins.str data_type: The SQL Server data type. Full data types list can be found here:
               https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver16
        :param _builtins.int length: (Output)
               Column length.
        :param _builtins.bool nullable: (Output)
               Whether or not the column can accept a null value.
        :param _builtins.int ordinal_position: (Output)
               The ordinal position of the column in the table.
        :param _builtins.int precision: (Output)
               Column precision.
        :param _builtins.bool primary_key: (Output)
               Whether or not the column represents a primary key.
        :param _builtins.int scale: (Output)
               Column scale.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[_builtins.str]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        The SQL Server data type. Full data types list can be found here:
        https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver16
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[_builtins.int]:
        """
        (Output)
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column precision.
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column scale.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class StreamBackfillNone(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class StreamDestinationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "destinationConnectionProfile":
            suggest = "destination_connection_profile"
        elif key == "bigqueryDestinationConfig":
            suggest = "bigquery_destination_config"
        elif key == "gcsDestinationConfig":
            suggest = "gcs_destination_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamDestinationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamDestinationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamDestinationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 destination_connection_profile: _builtins.str,
                 bigquery_destination_config: Optional['outputs.StreamDestinationConfigBigqueryDestinationConfig'] = None,
                 gcs_destination_config: Optional['outputs.StreamDestinationConfigGcsDestinationConfig'] = None):
        """
        :param _builtins.str destination_connection_profile: Destination connection profile resource. Format: projects/{project}/locations/{location}/connectionProfiles/{name}
        :param 'StreamDestinationConfigBigqueryDestinationConfigArgs' bigquery_destination_config: A configuration for how data should be loaded to Google BigQuery.
               Structure is documented below.
        :param 'StreamDestinationConfigGcsDestinationConfigArgs' gcs_destination_config: A configuration for how data should be loaded to Cloud Storage.
               Structure is documented below.
        """
        pulumi.set(__self__, "destination_connection_profile", destination_connection_profile)
        if bigquery_destination_config is not None:
            pulumi.set(__self__, "bigquery_destination_config", bigquery_destination_config)
        if gcs_destination_config is not None:
            pulumi.set(__self__, "gcs_destination_config", gcs_destination_config)

    @_builtins.property
    @pulumi.getter(name="destinationConnectionProfile")
    def destination_connection_profile(self) -> _builtins.str:
        """
        Destination connection profile resource. Format: projects/{project}/locations/{location}/connectionProfiles/{name}
        """
        return pulumi.get(self, "destination_connection_profile")

    @_builtins.property
    @pulumi.getter(name="bigqueryDestinationConfig")
    def bigquery_destination_config(self) -> Optional['outputs.StreamDestinationConfigBigqueryDestinationConfig']:
        """
        A configuration for how data should be loaded to Google BigQuery.
        Structure is documented below.
        """
        return pulumi.get(self, "bigquery_destination_config")

    @_builtins.property
    @pulumi.getter(name="gcsDestinationConfig")
    def gcs_destination_config(self) -> Optional['outputs.StreamDestinationConfigGcsDestinationConfig']:
        """
        A configuration for how data should be loaded to Cloud Storage.
        Structure is documented below.
        """
        return pulumi.get(self, "gcs_destination_config")


@pulumi.output_type
class StreamDestinationConfigBigqueryDestinationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "appendOnly":
            suggest = "append_only"
        elif key == "blmtConfig":
            suggest = "blmt_config"
        elif key == "dataFreshness":
            suggest = "data_freshness"
        elif key == "singleTargetDataset":
            suggest = "single_target_dataset"
        elif key == "sourceHierarchyDatasets":
            suggest = "source_hierarchy_datasets"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamDestinationConfigBigqueryDestinationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamDestinationConfigBigqueryDestinationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamDestinationConfigBigqueryDestinationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 append_only: Optional['outputs.StreamDestinationConfigBigqueryDestinationConfigAppendOnly'] = None,
                 blmt_config: Optional['outputs.StreamDestinationConfigBigqueryDestinationConfigBlmtConfig'] = None,
                 data_freshness: Optional[_builtins.str] = None,
                 merge: Optional['outputs.StreamDestinationConfigBigqueryDestinationConfigMerge'] = None,
                 single_target_dataset: Optional['outputs.StreamDestinationConfigBigqueryDestinationConfigSingleTargetDataset'] = None,
                 source_hierarchy_datasets: Optional['outputs.StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasets'] = None):
        """
        :param 'StreamDestinationConfigBigqueryDestinationConfigAppendOnlyArgs' append_only: AppendOnly mode defines that the stream of changes (INSERT, UPDATE-INSERT, UPDATE-DELETE and DELETE
               events) to a source table will be written to the destination Google BigQuery table, retaining the
               historical state of the data.
        :param 'StreamDestinationConfigBigqueryDestinationConfigBlmtConfigArgs' blmt_config: BigLake Managed Tables configuration for BigQuery streams.
               Structure is documented below.
        :param _builtins.str data_freshness: The guaranteed data freshness (in seconds) when querying tables created by the stream.
               Editing this field will only affect new tables created in the future, but existing tables
               will not be impacted. Lower values mean that queries will return fresher data, but may result in higher cost.
               A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s". Defaults to 900s.
        :param 'StreamDestinationConfigBigqueryDestinationConfigMergeArgs' merge: Merge mode defines that all changes to a table will be merged at the destination Google BigQuery
               table. This is the default write mode. When selected, BigQuery reflects the way the data is stored
               in the source database. With Merge mode, no historical record of the change events is kept.
        :param 'StreamDestinationConfigBigqueryDestinationConfigSingleTargetDatasetArgs' single_target_dataset: A single target dataset to which all data will be streamed.
               Structure is documented below.
        :param 'StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsArgs' source_hierarchy_datasets: Destination datasets are created so that hierarchy of the destination data objects matches the source hierarchy.
               Structure is documented below.
        """
        if append_only is not None:
            pulumi.set(__self__, "append_only", append_only)
        if blmt_config is not None:
            pulumi.set(__self__, "blmt_config", blmt_config)
        if data_freshness is not None:
            pulumi.set(__self__, "data_freshness", data_freshness)
        if merge is not None:
            pulumi.set(__self__, "merge", merge)
        if single_target_dataset is not None:
            pulumi.set(__self__, "single_target_dataset", single_target_dataset)
        if source_hierarchy_datasets is not None:
            pulumi.set(__self__, "source_hierarchy_datasets", source_hierarchy_datasets)

    @_builtins.property
    @pulumi.getter(name="appendOnly")
    def append_only(self) -> Optional['outputs.StreamDestinationConfigBigqueryDestinationConfigAppendOnly']:
        """
        AppendOnly mode defines that the stream of changes (INSERT, UPDATE-INSERT, UPDATE-DELETE and DELETE
        events) to a source table will be written to the destination Google BigQuery table, retaining the
        historical state of the data.
        """
        return pulumi.get(self, "append_only")

    @_builtins.property
    @pulumi.getter(name="blmtConfig")
    def blmt_config(self) -> Optional['outputs.StreamDestinationConfigBigqueryDestinationConfigBlmtConfig']:
        """
        BigLake Managed Tables configuration for BigQuery streams.
        Structure is documented below.
        """
        return pulumi.get(self, "blmt_config")

    @_builtins.property
    @pulumi.getter(name="dataFreshness")
    def data_freshness(self) -> Optional[_builtins.str]:
        """
        The guaranteed data freshness (in seconds) when querying tables created by the stream.
        Editing this field will only affect new tables created in the future, but existing tables
        will not be impacted. Lower values mean that queries will return fresher data, but may result in higher cost.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s". Defaults to 900s.
        """
        return pulumi.get(self, "data_freshness")

    @_builtins.property
    @pulumi.getter
    def merge(self) -> Optional['outputs.StreamDestinationConfigBigqueryDestinationConfigMerge']:
        """
        Merge mode defines that all changes to a table will be merged at the destination Google BigQuery
        table. This is the default write mode. When selected, BigQuery reflects the way the data is stored
        in the source database. With Merge mode, no historical record of the change events is kept.
        """
        return pulumi.get(self, "merge")

    @_builtins.property
    @pulumi.getter(name="singleTargetDataset")
    def single_target_dataset(self) -> Optional['outputs.StreamDestinationConfigBigqueryDestinationConfigSingleTargetDataset']:
        """
        A single target dataset to which all data will be streamed.
        Structure is documented below.
        """
        return pulumi.get(self, "single_target_dataset")

    @_builtins.property
    @pulumi.getter(name="sourceHierarchyDatasets")
    def source_hierarchy_datasets(self) -> Optional['outputs.StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasets']:
        """
        Destination datasets are created so that hierarchy of the destination data objects matches the source hierarchy.
        Structure is documented below.
        """
        return pulumi.get(self, "source_hierarchy_datasets")


@pulumi.output_type
class StreamDestinationConfigBigqueryDestinationConfigAppendOnly(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class StreamDestinationConfigBigqueryDestinationConfigBlmtConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "connectionName":
            suggest = "connection_name"
        elif key == "fileFormat":
            suggest = "file_format"
        elif key == "tableFormat":
            suggest = "table_format"
        elif key == "rootPath":
            suggest = "root_path"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamDestinationConfigBigqueryDestinationConfigBlmtConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamDestinationConfigBigqueryDestinationConfigBlmtConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamDestinationConfigBigqueryDestinationConfigBlmtConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 bucket: _builtins.str,
                 connection_name: _builtins.str,
                 file_format: _builtins.str,
                 table_format: _builtins.str,
                 root_path: Optional[_builtins.str] = None):
        """
        :param _builtins.str bucket: The Cloud Storage bucket name.
        :param _builtins.str connection_name: The bigquery connection. Format: `{project}.{location}.{name}`
        :param _builtins.str file_format: The file format.
        :param _builtins.str table_format: The table format.
        :param _builtins.str root_path: The root path inside the Cloud Storage bucket.
        """
        pulumi.set(__self__, "bucket", bucket)
        pulumi.set(__self__, "connection_name", connection_name)
        pulumi.set(__self__, "file_format", file_format)
        pulumi.set(__self__, "table_format", table_format)
        if root_path is not None:
            pulumi.set(__self__, "root_path", root_path)

    @_builtins.property
    @pulumi.getter
    def bucket(self) -> _builtins.str:
        """
        The Cloud Storage bucket name.
        """
        return pulumi.get(self, "bucket")

    @_builtins.property
    @pulumi.getter(name="connectionName")
    def connection_name(self) -> _builtins.str:
        """
        The bigquery connection. Format: `{project}.{location}.{name}`
        """
        return pulumi.get(self, "connection_name")

    @_builtins.property
    @pulumi.getter(name="fileFormat")
    def file_format(self) -> _builtins.str:
        """
        The file format.
        """
        return pulumi.get(self, "file_format")

    @_builtins.property
    @pulumi.getter(name="tableFormat")
    def table_format(self) -> _builtins.str:
        """
        The table format.
        """
        return pulumi.get(self, "table_format")

    @_builtins.property
    @pulumi.getter(name="rootPath")
    def root_path(self) -> Optional[_builtins.str]:
        """
        The root path inside the Cloud Storage bucket.
        """
        return pulumi.get(self, "root_path")


@pulumi.output_type
class StreamDestinationConfigBigqueryDestinationConfigMerge(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class StreamDestinationConfigBigqueryDestinationConfigSingleTargetDataset(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetId":
            suggest = "dataset_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamDestinationConfigBigqueryDestinationConfigSingleTargetDataset. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamDestinationConfigBigqueryDestinationConfigSingleTargetDataset.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamDestinationConfigBigqueryDestinationConfigSingleTargetDataset.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_id: _builtins.str):
        """
        :param _builtins.str dataset_id: Dataset ID in the format projects/{project}/datasets/{dataset_id} or
               {project}:{dataset_id}
        """
        pulumi.set(__self__, "dataset_id", dataset_id)

    @_builtins.property
    @pulumi.getter(name="datasetId")
    def dataset_id(self) -> _builtins.str:
        """
        Dataset ID in the format projects/{project}/datasets/{dataset_id} or
        {project}:{dataset_id}
        """
        return pulumi.get(self, "dataset_id")


@pulumi.output_type
class StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasets(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetTemplate":
            suggest = "dataset_template"
        elif key == "projectId":
            suggest = "project_id"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasets. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasets.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasets.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 dataset_template: 'outputs.StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplate',
                 project_id: Optional[_builtins.str] = None):
        """
        :param 'StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplateArgs' dataset_template: Dataset template used for dynamic dataset creation.
               Structure is documented below.
        :param _builtins.str project_id: Optional. The project id of the BigQuery dataset. If not specified, the project will be inferred from the stream resource.
        """
        pulumi.set(__self__, "dataset_template", dataset_template)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter(name="datasetTemplate")
    def dataset_template(self) -> 'outputs.StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplate':
        """
        Dataset template used for dynamic dataset creation.
        Structure is documented below.
        """
        return pulumi.get(self, "dataset_template")

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[_builtins.str]:
        """
        Optional. The project id of the BigQuery dataset. If not specified, the project will be inferred from the stream resource.
        """
        return pulumi.get(self, "project_id")


@pulumi.output_type
class StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplate(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "datasetIdPrefix":
            suggest = "dataset_id_prefix"
        elif key == "kmsKeyName":
            suggest = "kms_key_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplate. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplate.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamDestinationConfigBigqueryDestinationConfigSourceHierarchyDatasetsDatasetTemplate.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 location: _builtins.str,
                 dataset_id_prefix: Optional[_builtins.str] = None,
                 kms_key_name: Optional[_builtins.str] = None):
        """
        :param _builtins.str location: The geographic location where the dataset should reside.
               See https://cloud.google.com/bigquery/docs/locations for supported locations.
        :param _builtins.str dataset_id_prefix: If supplied, every created dataset will have its name prefixed by the provided value.
               The prefix and name will be separated by an underscore. i.e. _.
        :param _builtins.str kms_key_name: Describes the Cloud KMS encryption key that will be used to protect destination BigQuery
               table. The BigQuery Service Account associated with your project requires access to this
               encryption key. i.e. projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{cryptoKey}.
               See https://cloud.google.com/bigquery/docs/customer-managed-encryption for more information.
        """
        pulumi.set(__self__, "location", location)
        if dataset_id_prefix is not None:
            pulumi.set(__self__, "dataset_id_prefix", dataset_id_prefix)
        if kms_key_name is not None:
            pulumi.set(__self__, "kms_key_name", kms_key_name)

    @_builtins.property
    @pulumi.getter
    def location(self) -> _builtins.str:
        """
        The geographic location where the dataset should reside.
        See https://cloud.google.com/bigquery/docs/locations for supported locations.
        """
        return pulumi.get(self, "location")

    @_builtins.property
    @pulumi.getter(name="datasetIdPrefix")
    def dataset_id_prefix(self) -> Optional[_builtins.str]:
        """
        If supplied, every created dataset will have its name prefixed by the provided value.
        The prefix and name will be separated by an underscore. i.e. _.
        """
        return pulumi.get(self, "dataset_id_prefix")

    @_builtins.property
    @pulumi.getter(name="kmsKeyName")
    def kms_key_name(self) -> Optional[_builtins.str]:
        """
        Describes the Cloud KMS encryption key that will be used to protect destination BigQuery
        table. The BigQuery Service Account associated with your project requires access to this
        encryption key. i.e. projects/{project}/locations/{location}/keyRings/{key_ring}/cryptoKeys/{cryptoKey}.
        See https://cloud.google.com/bigquery/docs/customer-managed-encryption for more information.
        """
        return pulumi.get(self, "kms_key_name")


@pulumi.output_type
class StreamDestinationConfigGcsDestinationConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "avroFileFormat":
            suggest = "avro_file_format"
        elif key == "fileRotationInterval":
            suggest = "file_rotation_interval"
        elif key == "fileRotationMb":
            suggest = "file_rotation_mb"
        elif key == "jsonFileFormat":
            suggest = "json_file_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamDestinationConfigGcsDestinationConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamDestinationConfigGcsDestinationConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamDestinationConfigGcsDestinationConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 avro_file_format: Optional['outputs.StreamDestinationConfigGcsDestinationConfigAvroFileFormat'] = None,
                 file_rotation_interval: Optional[_builtins.str] = None,
                 file_rotation_mb: Optional[_builtins.int] = None,
                 json_file_format: Optional['outputs.StreamDestinationConfigGcsDestinationConfigJsonFileFormat'] = None,
                 path: Optional[_builtins.str] = None):
        """
        :param 'StreamDestinationConfigGcsDestinationConfigAvroFileFormatArgs' avro_file_format: AVRO file format configuration.
        :param _builtins.str file_rotation_interval: The maximum duration for which new events are added before a file is closed and a new file is created.
               A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s". Defaults to 900s.
        :param _builtins.int file_rotation_mb: The maximum file size to be saved in the bucket.
        :param 'StreamDestinationConfigGcsDestinationConfigJsonFileFormatArgs' json_file_format: JSON file format configuration.
               Structure is documented below.
        :param _builtins.str path: Path inside the Cloud Storage bucket to write data to.
        """
        if avro_file_format is not None:
            pulumi.set(__self__, "avro_file_format", avro_file_format)
        if file_rotation_interval is not None:
            pulumi.set(__self__, "file_rotation_interval", file_rotation_interval)
        if file_rotation_mb is not None:
            pulumi.set(__self__, "file_rotation_mb", file_rotation_mb)
        if json_file_format is not None:
            pulumi.set(__self__, "json_file_format", json_file_format)
        if path is not None:
            pulumi.set(__self__, "path", path)

    @_builtins.property
    @pulumi.getter(name="avroFileFormat")
    def avro_file_format(self) -> Optional['outputs.StreamDestinationConfigGcsDestinationConfigAvroFileFormat']:
        """
        AVRO file format configuration.
        """
        return pulumi.get(self, "avro_file_format")

    @_builtins.property
    @pulumi.getter(name="fileRotationInterval")
    def file_rotation_interval(self) -> Optional[_builtins.str]:
        """
        The maximum duration for which new events are added before a file is closed and a new file is created.
        A duration in seconds with up to nine fractional digits, terminated by 's'. Example: "3.5s". Defaults to 900s.
        """
        return pulumi.get(self, "file_rotation_interval")

    @_builtins.property
    @pulumi.getter(name="fileRotationMb")
    def file_rotation_mb(self) -> Optional[_builtins.int]:
        """
        The maximum file size to be saved in the bucket.
        """
        return pulumi.get(self, "file_rotation_mb")

    @_builtins.property
    @pulumi.getter(name="jsonFileFormat")
    def json_file_format(self) -> Optional['outputs.StreamDestinationConfigGcsDestinationConfigJsonFileFormat']:
        """
        JSON file format configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "json_file_format")

    @_builtins.property
    @pulumi.getter
    def path(self) -> Optional[_builtins.str]:
        """
        Path inside the Cloud Storage bucket to write data to.
        """
        return pulumi.get(self, "path")


@pulumi.output_type
class StreamDestinationConfigGcsDestinationConfigAvroFileFormat(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class StreamDestinationConfigGcsDestinationConfigJsonFileFormat(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "schemaFileFormat":
            suggest = "schema_file_format"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamDestinationConfigGcsDestinationConfigJsonFileFormat. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamDestinationConfigGcsDestinationConfigJsonFileFormat.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamDestinationConfigGcsDestinationConfigJsonFileFormat.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 compression: Optional[_builtins.str] = None,
                 schema_file_format: Optional[_builtins.str] = None):
        """
        :param _builtins.str compression: Compression of the loaded JSON file.
               Possible values are: `NO_COMPRESSION`, `GZIP`.
        :param _builtins.str schema_file_format: The schema file format along JSON data files.
               Possible values are: `NO_SCHEMA_FILE`, `AVRO_SCHEMA_FILE`.
        """
        if compression is not None:
            pulumi.set(__self__, "compression", compression)
        if schema_file_format is not None:
            pulumi.set(__self__, "schema_file_format", schema_file_format)

    @_builtins.property
    @pulumi.getter
    def compression(self) -> Optional[_builtins.str]:
        """
        Compression of the loaded JSON file.
        Possible values are: `NO_COMPRESSION`, `GZIP`.
        """
        return pulumi.get(self, "compression")

    @_builtins.property
    @pulumi.getter(name="schemaFileFormat")
    def schema_file_format(self) -> Optional[_builtins.str]:
        """
        The schema file format along JSON data files.
        Possible values are: `NO_SCHEMA_FILE`, `AVRO_SCHEMA_FILE`.
        """
        return pulumi.get(self, "schema_file_format")


@pulumi.output_type
class StreamSourceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "sourceConnectionProfile":
            suggest = "source_connection_profile"
        elif key == "mongodbSourceConfig":
            suggest = "mongodb_source_config"
        elif key == "mysqlSourceConfig":
            suggest = "mysql_source_config"
        elif key == "oracleSourceConfig":
            suggest = "oracle_source_config"
        elif key == "postgresqlSourceConfig":
            suggest = "postgresql_source_config"
        elif key == "salesforceSourceConfig":
            suggest = "salesforce_source_config"
        elif key == "sqlServerSourceConfig":
            suggest = "sql_server_source_config"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 source_connection_profile: _builtins.str,
                 mongodb_source_config: Optional['outputs.StreamSourceConfigMongodbSourceConfig'] = None,
                 mysql_source_config: Optional['outputs.StreamSourceConfigMysqlSourceConfig'] = None,
                 oracle_source_config: Optional['outputs.StreamSourceConfigOracleSourceConfig'] = None,
                 postgresql_source_config: Optional['outputs.StreamSourceConfigPostgresqlSourceConfig'] = None,
                 salesforce_source_config: Optional['outputs.StreamSourceConfigSalesforceSourceConfig'] = None,
                 sql_server_source_config: Optional['outputs.StreamSourceConfigSqlServerSourceConfig'] = None):
        """
        :param _builtins.str source_connection_profile: Source connection profile resource. Format: projects/{project}/locations/{location}/connectionProfiles/{name}
        :param 'StreamSourceConfigMongodbSourceConfigArgs' mongodb_source_config: MongoDB source configuration.
               Structure is documented below.
        :param 'StreamSourceConfigMysqlSourceConfigArgs' mysql_source_config: MySQL data source configuration.
               Structure is documented below.
        :param 'StreamSourceConfigOracleSourceConfigArgs' oracle_source_config: MySQL data source configuration.
               Structure is documented below.
        :param 'StreamSourceConfigPostgresqlSourceConfigArgs' postgresql_source_config: PostgreSQL data source configuration.
               Structure is documented below.
        :param 'StreamSourceConfigSalesforceSourceConfigArgs' salesforce_source_config: Salesforce data source configuration.
               Structure is documented below.
        :param 'StreamSourceConfigSqlServerSourceConfigArgs' sql_server_source_config: SQL Server data source configuration.
               Structure is documented below.
        """
        pulumi.set(__self__, "source_connection_profile", source_connection_profile)
        if mongodb_source_config is not None:
            pulumi.set(__self__, "mongodb_source_config", mongodb_source_config)
        if mysql_source_config is not None:
            pulumi.set(__self__, "mysql_source_config", mysql_source_config)
        if oracle_source_config is not None:
            pulumi.set(__self__, "oracle_source_config", oracle_source_config)
        if postgresql_source_config is not None:
            pulumi.set(__self__, "postgresql_source_config", postgresql_source_config)
        if salesforce_source_config is not None:
            pulumi.set(__self__, "salesforce_source_config", salesforce_source_config)
        if sql_server_source_config is not None:
            pulumi.set(__self__, "sql_server_source_config", sql_server_source_config)

    @_builtins.property
    @pulumi.getter(name="sourceConnectionProfile")
    def source_connection_profile(self) -> _builtins.str:
        """
        Source connection profile resource. Format: projects/{project}/locations/{location}/connectionProfiles/{name}
        """
        return pulumi.get(self, "source_connection_profile")

    @_builtins.property
    @pulumi.getter(name="mongodbSourceConfig")
    def mongodb_source_config(self) -> Optional['outputs.StreamSourceConfigMongodbSourceConfig']:
        """
        MongoDB source configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "mongodb_source_config")

    @_builtins.property
    @pulumi.getter(name="mysqlSourceConfig")
    def mysql_source_config(self) -> Optional['outputs.StreamSourceConfigMysqlSourceConfig']:
        """
        MySQL data source configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_source_config")

    @_builtins.property
    @pulumi.getter(name="oracleSourceConfig")
    def oracle_source_config(self) -> Optional['outputs.StreamSourceConfigOracleSourceConfig']:
        """
        MySQL data source configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_source_config")

    @_builtins.property
    @pulumi.getter(name="postgresqlSourceConfig")
    def postgresql_source_config(self) -> Optional['outputs.StreamSourceConfigPostgresqlSourceConfig']:
        """
        PostgreSQL data source configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_source_config")

    @_builtins.property
    @pulumi.getter(name="salesforceSourceConfig")
    def salesforce_source_config(self) -> Optional['outputs.StreamSourceConfigSalesforceSourceConfig']:
        """
        Salesforce data source configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "salesforce_source_config")

    @_builtins.property
    @pulumi.getter(name="sqlServerSourceConfig")
    def sql_server_source_config(self) -> Optional['outputs.StreamSourceConfigSqlServerSourceConfig']:
        """
        SQL Server data source configuration.
        Structure is documented below.
        """
        return pulumi.get(self, "sql_server_source_config")


@pulumi.output_type
class StreamSourceConfigMongodbSourceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "excludeObjects":
            suggest = "exclude_objects"
        elif key == "includeObjects":
            suggest = "include_objects"
        elif key == "maxConcurrentBackfillTasks":
            suggest = "max_concurrent_backfill_tasks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigMongodbSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigMongodbSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigMongodbSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 exclude_objects: Optional['outputs.StreamSourceConfigMongodbSourceConfigExcludeObjects'] = None,
                 include_objects: Optional['outputs.StreamSourceConfigMongodbSourceConfigIncludeObjects'] = None,
                 max_concurrent_backfill_tasks: Optional[_builtins.int] = None):
        """
        :param 'StreamSourceConfigMongodbSourceConfigExcludeObjectsArgs' exclude_objects: MongoDB collections to include in the stream.
               Structure is documented below.
        :param 'StreamSourceConfigMongodbSourceConfigIncludeObjectsArgs' include_objects: MongoDB collections to include in the stream.
               Structure is documented below.
        :param _builtins.int max_concurrent_backfill_tasks: Optional. Maximum number of concurrent backfill tasks. The number
               should be non-negative and less than or equal to 50. If not set
               (or set to 0), the system''s default value is used
        """
        if exclude_objects is not None:
            pulumi.set(__self__, "exclude_objects", exclude_objects)
        if include_objects is not None:
            pulumi.set(__self__, "include_objects", include_objects)
        if max_concurrent_backfill_tasks is not None:
            pulumi.set(__self__, "max_concurrent_backfill_tasks", max_concurrent_backfill_tasks)

    @_builtins.property
    @pulumi.getter(name="excludeObjects")
    def exclude_objects(self) -> Optional['outputs.StreamSourceConfigMongodbSourceConfigExcludeObjects']:
        """
        MongoDB collections to include in the stream.
        Structure is documented below.
        """
        return pulumi.get(self, "exclude_objects")

    @_builtins.property
    @pulumi.getter(name="includeObjects")
    def include_objects(self) -> Optional['outputs.StreamSourceConfigMongodbSourceConfigIncludeObjects']:
        """
        MongoDB collections to include in the stream.
        Structure is documented below.
        """
        return pulumi.get(self, "include_objects")

    @_builtins.property
    @pulumi.getter(name="maxConcurrentBackfillTasks")
    def max_concurrent_backfill_tasks(self) -> Optional[_builtins.int]:
        """
        Optional. Maximum number of concurrent backfill tasks. The number
        should be non-negative and less than or equal to 50. If not set
        (or set to 0), the system''s default value is used
        """
        return pulumi.get(self, "max_concurrent_backfill_tasks")


@pulumi.output_type
class StreamSourceConfigMongodbSourceConfigExcludeObjects(dict):
    def __init__(__self__, *,
                 databases: Optional[Sequence['outputs.StreamSourceConfigMongodbSourceConfigExcludeObjectsDatabase']] = None):
        """
        :param Sequence['StreamSourceConfigMongodbSourceConfigExcludeObjectsDatabaseArgs'] databases: MongoDB databases in the cluster.
               Structure is documented below.
        """
        if databases is not None:
            pulumi.set(__self__, "databases", databases)

    @_builtins.property
    @pulumi.getter
    def databases(self) -> Optional[Sequence['outputs.StreamSourceConfigMongodbSourceConfigExcludeObjectsDatabase']]:
        """
        MongoDB databases in the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "databases")


@pulumi.output_type
class StreamSourceConfigMongodbSourceConfigExcludeObjectsDatabase(dict):
    def __init__(__self__, *,
                 collections: Optional[Sequence['outputs.StreamSourceConfigMongodbSourceConfigExcludeObjectsDatabaseCollection']] = None,
                 database: Optional[_builtins.str] = None):
        """
        :param Sequence['StreamSourceConfigMongodbSourceConfigExcludeObjectsDatabaseCollectionArgs'] collections: Collections in the database.
               Structure is documented below.
        :param _builtins.str database: Database name.
        """
        if collections is not None:
            pulumi.set(__self__, "collections", collections)
        if database is not None:
            pulumi.set(__self__, "database", database)

    @_builtins.property
    @pulumi.getter
    def collections(self) -> Optional[Sequence['outputs.StreamSourceConfigMongodbSourceConfigExcludeObjectsDatabaseCollection']]:
        """
        Collections in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "collections")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        Database name.
        """
        return pulumi.get(self, "database")


@pulumi.output_type
class StreamSourceConfigMongodbSourceConfigExcludeObjectsDatabaseCollection(dict):
    def __init__(__self__, *,
                 collection: Optional[_builtins.str] = None,
                 fields: Optional[Sequence['outputs.StreamSourceConfigMongodbSourceConfigExcludeObjectsDatabaseCollectionField']] = None):
        """
        :param _builtins.str collection: Collection name.
        :param Sequence['StreamSourceConfigMongodbSourceConfigExcludeObjectsDatabaseCollectionFieldArgs'] fields: Fields in the collection.
               Structure is documented below.
        """
        if collection is not None:
            pulumi.set(__self__, "collection", collection)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @_builtins.property
    @pulumi.getter
    def collection(self) -> Optional[_builtins.str]:
        """
        Collection name.
        """
        return pulumi.get(self, "collection")

    @_builtins.property
    @pulumi.getter
    def fields(self) -> Optional[Sequence['outputs.StreamSourceConfigMongodbSourceConfigExcludeObjectsDatabaseCollectionField']]:
        """
        Fields in the collection.
        Structure is documented below.
        """
        return pulumi.get(self, "fields")


@pulumi.output_type
class StreamSourceConfigMongodbSourceConfigExcludeObjectsDatabaseCollectionField(dict):
    def __init__(__self__, *,
                 field: Optional[_builtins.str] = None):
        """
        :param _builtins.str field: Field name.
        """
        if field is not None:
            pulumi.set(__self__, "field", field)

    @_builtins.property
    @pulumi.getter
    def field(self) -> Optional[_builtins.str]:
        """
        Field name.
        """
        return pulumi.get(self, "field")


@pulumi.output_type
class StreamSourceConfigMongodbSourceConfigIncludeObjects(dict):
    def __init__(__self__, *,
                 databases: Optional[Sequence['outputs.StreamSourceConfigMongodbSourceConfigIncludeObjectsDatabase']] = None):
        """
        :param Sequence['StreamSourceConfigMongodbSourceConfigIncludeObjectsDatabaseArgs'] databases: MongoDB databases in the cluster.
               Structure is documented below.
        """
        if databases is not None:
            pulumi.set(__self__, "databases", databases)

    @_builtins.property
    @pulumi.getter
    def databases(self) -> Optional[Sequence['outputs.StreamSourceConfigMongodbSourceConfigIncludeObjectsDatabase']]:
        """
        MongoDB databases in the cluster.
        Structure is documented below.
        """
        return pulumi.get(self, "databases")


@pulumi.output_type
class StreamSourceConfigMongodbSourceConfigIncludeObjectsDatabase(dict):
    def __init__(__self__, *,
                 collections: Optional[Sequence['outputs.StreamSourceConfigMongodbSourceConfigIncludeObjectsDatabaseCollection']] = None,
                 database: Optional[_builtins.str] = None):
        """
        :param Sequence['StreamSourceConfigMongodbSourceConfigIncludeObjectsDatabaseCollectionArgs'] collections: Collections in the database.
               Structure is documented below.
        :param _builtins.str database: Database name.
        """
        if collections is not None:
            pulumi.set(__self__, "collections", collections)
        if database is not None:
            pulumi.set(__self__, "database", database)

    @_builtins.property
    @pulumi.getter
    def collections(self) -> Optional[Sequence['outputs.StreamSourceConfigMongodbSourceConfigIncludeObjectsDatabaseCollection']]:
        """
        Collections in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "collections")

    @_builtins.property
    @pulumi.getter
    def database(self) -> Optional[_builtins.str]:
        """
        Database name.
        """
        return pulumi.get(self, "database")


@pulumi.output_type
class StreamSourceConfigMongodbSourceConfigIncludeObjectsDatabaseCollection(dict):
    def __init__(__self__, *,
                 collection: Optional[_builtins.str] = None,
                 fields: Optional[Sequence['outputs.StreamSourceConfigMongodbSourceConfigIncludeObjectsDatabaseCollectionField']] = None):
        """
        :param _builtins.str collection: Collection name.
        :param Sequence['StreamSourceConfigMongodbSourceConfigIncludeObjectsDatabaseCollectionFieldArgs'] fields: Fields in the collection.
               Structure is documented below.
        """
        if collection is not None:
            pulumi.set(__self__, "collection", collection)
        if fields is not None:
            pulumi.set(__self__, "fields", fields)

    @_builtins.property
    @pulumi.getter
    def collection(self) -> Optional[_builtins.str]:
        """
        Collection name.
        """
        return pulumi.get(self, "collection")

    @_builtins.property
    @pulumi.getter
    def fields(self) -> Optional[Sequence['outputs.StreamSourceConfigMongodbSourceConfigIncludeObjectsDatabaseCollectionField']]:
        """
        Fields in the collection.
        Structure is documented below.
        """
        return pulumi.get(self, "fields")


@pulumi.output_type
class StreamSourceConfigMongodbSourceConfigIncludeObjectsDatabaseCollectionField(dict):
    def __init__(__self__, *,
                 field: Optional[_builtins.str] = None):
        """
        :param _builtins.str field: Field name.
        """
        if field is not None:
            pulumi.set(__self__, "field", field)

    @_builtins.property
    @pulumi.getter
    def field(self) -> Optional[_builtins.str]:
        """
        Field name.
        """
        return pulumi.get(self, "field")


@pulumi.output_type
class StreamSourceConfigMysqlSourceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "binaryLogPosition":
            suggest = "binary_log_position"
        elif key == "excludeObjects":
            suggest = "exclude_objects"
        elif key == "includeObjects":
            suggest = "include_objects"
        elif key == "maxConcurrentBackfillTasks":
            suggest = "max_concurrent_backfill_tasks"
        elif key == "maxConcurrentCdcTasks":
            suggest = "max_concurrent_cdc_tasks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigMysqlSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigMysqlSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigMysqlSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 binary_log_position: Optional['outputs.StreamSourceConfigMysqlSourceConfigBinaryLogPosition'] = None,
                 exclude_objects: Optional['outputs.StreamSourceConfigMysqlSourceConfigExcludeObjects'] = None,
                 gtid: Optional['outputs.StreamSourceConfigMysqlSourceConfigGtid'] = None,
                 include_objects: Optional['outputs.StreamSourceConfigMysqlSourceConfigIncludeObjects'] = None,
                 max_concurrent_backfill_tasks: Optional[_builtins.int] = None,
                 max_concurrent_cdc_tasks: Optional[_builtins.int] = None):
        """
        :param 'StreamSourceConfigMysqlSourceConfigBinaryLogPositionArgs' binary_log_position: CDC reader reads from binary logs replication cdc method.
        :param 'StreamSourceConfigMysqlSourceConfigExcludeObjectsArgs' exclude_objects: MySQL objects to exclude from the stream.
               Structure is documented below.
        :param 'StreamSourceConfigMysqlSourceConfigGtidArgs' gtid: CDC reader reads from gtid based replication.
        :param 'StreamSourceConfigMysqlSourceConfigIncludeObjectsArgs' include_objects: MySQL objects to retrieve from the source.
               Structure is documented below.
        :param _builtins.int max_concurrent_backfill_tasks: Maximum number of concurrent backfill tasks. The number should be non negative.
               If not set (or set to 0), the system's default value will be used.
        :param _builtins.int max_concurrent_cdc_tasks: Maximum number of concurrent CDC tasks. The number should be non negative.
               If not set (or set to 0), the system's default value will be used.
        """
        if binary_log_position is not None:
            pulumi.set(__self__, "binary_log_position", binary_log_position)
        if exclude_objects is not None:
            pulumi.set(__self__, "exclude_objects", exclude_objects)
        if gtid is not None:
            pulumi.set(__self__, "gtid", gtid)
        if include_objects is not None:
            pulumi.set(__self__, "include_objects", include_objects)
        if max_concurrent_backfill_tasks is not None:
            pulumi.set(__self__, "max_concurrent_backfill_tasks", max_concurrent_backfill_tasks)
        if max_concurrent_cdc_tasks is not None:
            pulumi.set(__self__, "max_concurrent_cdc_tasks", max_concurrent_cdc_tasks)

    @_builtins.property
    @pulumi.getter(name="binaryLogPosition")
    def binary_log_position(self) -> Optional['outputs.StreamSourceConfigMysqlSourceConfigBinaryLogPosition']:
        """
        CDC reader reads from binary logs replication cdc method.
        """
        return pulumi.get(self, "binary_log_position")

    @_builtins.property
    @pulumi.getter(name="excludeObjects")
    def exclude_objects(self) -> Optional['outputs.StreamSourceConfigMysqlSourceConfigExcludeObjects']:
        """
        MySQL objects to exclude from the stream.
        Structure is documented below.
        """
        return pulumi.get(self, "exclude_objects")

    @_builtins.property
    @pulumi.getter
    def gtid(self) -> Optional['outputs.StreamSourceConfigMysqlSourceConfigGtid']:
        """
        CDC reader reads from gtid based replication.
        """
        return pulumi.get(self, "gtid")

    @_builtins.property
    @pulumi.getter(name="includeObjects")
    def include_objects(self) -> Optional['outputs.StreamSourceConfigMysqlSourceConfigIncludeObjects']:
        """
        MySQL objects to retrieve from the source.
        Structure is documented below.
        """
        return pulumi.get(self, "include_objects")

    @_builtins.property
    @pulumi.getter(name="maxConcurrentBackfillTasks")
    def max_concurrent_backfill_tasks(self) -> Optional[_builtins.int]:
        """
        Maximum number of concurrent backfill tasks. The number should be non negative.
        If not set (or set to 0), the system's default value will be used.
        """
        return pulumi.get(self, "max_concurrent_backfill_tasks")

    @_builtins.property
    @pulumi.getter(name="maxConcurrentCdcTasks")
    def max_concurrent_cdc_tasks(self) -> Optional[_builtins.int]:
        """
        Maximum number of concurrent CDC tasks. The number should be non negative.
        If not set (or set to 0), the system's default value will be used.
        """
        return pulumi.get(self, "max_concurrent_cdc_tasks")


@pulumi.output_type
class StreamSourceConfigMysqlSourceConfigBinaryLogPosition(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class StreamSourceConfigMysqlSourceConfigExcludeObjects(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mysqlDatabases":
            suggest = "mysql_databases"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigMysqlSourceConfigExcludeObjects. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigMysqlSourceConfigExcludeObjects.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigMysqlSourceConfigExcludeObjects.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mysql_databases: Sequence['outputs.StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabase']):
        """
        :param Sequence['StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseArgs'] mysql_databases: MySQL databases on the server
               Structure is documented below.
        """
        pulumi.set(__self__, "mysql_databases", mysql_databases)

    @_builtins.property
    @pulumi.getter(name="mysqlDatabases")
    def mysql_databases(self) -> Sequence['outputs.StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabase']:
        """
        MySQL databases on the server
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_databases")


@pulumi.output_type
class StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mysqlTables":
            suggest = "mysql_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 mysql_tables: Optional[Sequence['outputs.StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTable']] = None):
        """
        :param _builtins.str database: Database name.
        :param Sequence['StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableArgs'] mysql_tables: Tables in the database.
               Structure is documented below.
        """
        pulumi.set(__self__, "database", database)
        if mysql_tables is not None:
            pulumi.set(__self__, "mysql_tables", mysql_tables)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        Database name.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="mysqlTables")
    def mysql_tables(self) -> Optional[Sequence['outputs.StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTable']]:
        """
        Tables in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_tables")


@pulumi.output_type
class StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mysqlColumns":
            suggest = "mysql_columns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table: _builtins.str,
                 mysql_columns: Optional[Sequence['outputs.StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumn']] = None):
        """
        :param _builtins.str table: Table name.
        :param Sequence['StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgs'] mysql_columns: MySQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if mysql_columns is not None:
            pulumi.set(__self__, "mysql_columns", mysql_columns)

    @_builtins.property
    @pulumi.getter
    def table(self) -> _builtins.str:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @_builtins.property
    @pulumi.getter(name="mysqlColumns")
    def mysql_columns(self) -> Optional[Sequence['outputs.StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumn']]:
        """
        MySQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_columns")


@pulumi.output_type
class StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "ordinalPosition":
            suggest = "ordinal_position"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigMysqlSourceConfigExcludeObjectsMysqlDatabaseMysqlTableMysqlColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collation: Optional[_builtins.str] = None,
                 column: Optional[_builtins.str] = None,
                 data_type: Optional[_builtins.str] = None,
                 length: Optional[_builtins.int] = None,
                 nullable: Optional[_builtins.bool] = None,
                 ordinal_position: Optional[_builtins.int] = None,
                 primary_key: Optional[_builtins.bool] = None):
        """
        :param _builtins.str collation: Column collation.
        :param _builtins.str column: Column name.
        :param _builtins.str data_type: The MySQL data type. Full data types list can be found here:
               https://dev.mysql.com/doc/refman/8.0/en/data-types.html
        :param _builtins.int length: (Output)
               Column length.
        :param _builtins.bool nullable: Whether or not the column can accept a null value.
        :param _builtins.int ordinal_position: The ordinal position of the column in the table.
        :param _builtins.bool primary_key: Whether or not the column represents a primary key.
        """
        if collation is not None:
            pulumi.set(__self__, "collation", collation)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)

    @_builtins.property
    @pulumi.getter
    def collation(self) -> Optional[_builtins.str]:
        """
        Column collation.
        """
        return pulumi.get(self, "collation")

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[_builtins.str]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        The MySQL data type. Full data types list can be found here:
        https://dev.mysql.com/doc/refman/8.0/en/data-types.html
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[_builtins.int]:
        """
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @_builtins.property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[_builtins.bool]:
        """
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")


@pulumi.output_type
class StreamSourceConfigMysqlSourceConfigGtid(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class StreamSourceConfigMysqlSourceConfigIncludeObjects(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mysqlDatabases":
            suggest = "mysql_databases"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigMysqlSourceConfigIncludeObjects. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigMysqlSourceConfigIncludeObjects.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigMysqlSourceConfigIncludeObjects.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 mysql_databases: Sequence['outputs.StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabase']):
        """
        :param Sequence['StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseArgs'] mysql_databases: MySQL databases on the server
               Structure is documented below.
        """
        pulumi.set(__self__, "mysql_databases", mysql_databases)

    @_builtins.property
    @pulumi.getter(name="mysqlDatabases")
    def mysql_databases(self) -> Sequence['outputs.StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabase']:
        """
        MySQL databases on the server
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_databases")


@pulumi.output_type
class StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabase(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mysqlTables":
            suggest = "mysql_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabase. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabase.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabase.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 database: _builtins.str,
                 mysql_tables: Optional[Sequence['outputs.StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTable']] = None):
        """
        :param _builtins.str database: Database name.
        :param Sequence['StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableArgs'] mysql_tables: Tables in the database.
               Structure is documented below.
        """
        pulumi.set(__self__, "database", database)
        if mysql_tables is not None:
            pulumi.set(__self__, "mysql_tables", mysql_tables)

    @_builtins.property
    @pulumi.getter
    def database(self) -> _builtins.str:
        """
        Database name.
        """
        return pulumi.get(self, "database")

    @_builtins.property
    @pulumi.getter(name="mysqlTables")
    def mysql_tables(self) -> Optional[Sequence['outputs.StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTable']]:
        """
        Tables in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_tables")


@pulumi.output_type
class StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "mysqlColumns":
            suggest = "mysql_columns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table: _builtins.str,
                 mysql_columns: Optional[Sequence['outputs.StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumn']] = None):
        """
        :param _builtins.str table: Table name.
        :param Sequence['StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumnArgs'] mysql_columns: MySQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if mysql_columns is not None:
            pulumi.set(__self__, "mysql_columns", mysql_columns)

    @_builtins.property
    @pulumi.getter
    def table(self) -> _builtins.str:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @_builtins.property
    @pulumi.getter(name="mysqlColumns")
    def mysql_columns(self) -> Optional[Sequence['outputs.StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumn']]:
        """
        MySQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "mysql_columns")


@pulumi.output_type
class StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "ordinalPosition":
            suggest = "ordinal_position"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigMysqlSourceConfigIncludeObjectsMysqlDatabaseMysqlTableMysqlColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 collation: Optional[_builtins.str] = None,
                 column: Optional[_builtins.str] = None,
                 data_type: Optional[_builtins.str] = None,
                 length: Optional[_builtins.int] = None,
                 nullable: Optional[_builtins.bool] = None,
                 ordinal_position: Optional[_builtins.int] = None,
                 primary_key: Optional[_builtins.bool] = None):
        """
        :param _builtins.str collation: Column collation.
        :param _builtins.str column: Column name.
        :param _builtins.str data_type: The MySQL data type. Full data types list can be found here:
               https://dev.mysql.com/doc/refman/8.0/en/data-types.html
        :param _builtins.int length: (Output)
               Column length.
        :param _builtins.bool nullable: Whether or not the column can accept a null value.
        :param _builtins.int ordinal_position: The ordinal position of the column in the table.
        :param _builtins.bool primary_key: Whether or not the column represents a primary key.
        """
        if collation is not None:
            pulumi.set(__self__, "collation", collation)
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)

    @_builtins.property
    @pulumi.getter
    def collation(self) -> Optional[_builtins.str]:
        """
        Column collation.
        """
        return pulumi.get(self, "collation")

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[_builtins.str]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        The MySQL data type. Full data types list can be found here:
        https://dev.mysql.com/doc/refman/8.0/en/data-types.html
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[_builtins.int]:
        """
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @_builtins.property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[_builtins.bool]:
        """
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")


@pulumi.output_type
class StreamSourceConfigOracleSourceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dropLargeObjects":
            suggest = "drop_large_objects"
        elif key == "excludeObjects":
            suggest = "exclude_objects"
        elif key == "includeObjects":
            suggest = "include_objects"
        elif key == "maxConcurrentBackfillTasks":
            suggest = "max_concurrent_backfill_tasks"
        elif key == "maxConcurrentCdcTasks":
            suggest = "max_concurrent_cdc_tasks"
        elif key == "streamLargeObjects":
            suggest = "stream_large_objects"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigOracleSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigOracleSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigOracleSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 drop_large_objects: Optional['outputs.StreamSourceConfigOracleSourceConfigDropLargeObjects'] = None,
                 exclude_objects: Optional['outputs.StreamSourceConfigOracleSourceConfigExcludeObjects'] = None,
                 include_objects: Optional['outputs.StreamSourceConfigOracleSourceConfigIncludeObjects'] = None,
                 max_concurrent_backfill_tasks: Optional[_builtins.int] = None,
                 max_concurrent_cdc_tasks: Optional[_builtins.int] = None,
                 stream_large_objects: Optional['outputs.StreamSourceConfigOracleSourceConfigStreamLargeObjects'] = None):
        """
        :param 'StreamSourceConfigOracleSourceConfigDropLargeObjectsArgs' drop_large_objects: Configuration to drop large object values.
        :param 'StreamSourceConfigOracleSourceConfigExcludeObjectsArgs' exclude_objects: Oracle objects to exclude from the stream.
               Structure is documented below.
        :param 'StreamSourceConfigOracleSourceConfigIncludeObjectsArgs' include_objects: Oracle objects to retrieve from the source.
               Structure is documented below.
        :param _builtins.int max_concurrent_backfill_tasks: Maximum number of concurrent backfill tasks. The number should be non negative.
               If not set (or set to 0), the system's default value will be used.
        :param _builtins.int max_concurrent_cdc_tasks: Maximum number of concurrent CDC tasks. The number should be non negative.
               If not set (or set to 0), the system's default value will be used.
        :param 'StreamSourceConfigOracleSourceConfigStreamLargeObjectsArgs' stream_large_objects: Configuration to drop large object values.
        """
        if drop_large_objects is not None:
            pulumi.set(__self__, "drop_large_objects", drop_large_objects)
        if exclude_objects is not None:
            pulumi.set(__self__, "exclude_objects", exclude_objects)
        if include_objects is not None:
            pulumi.set(__self__, "include_objects", include_objects)
        if max_concurrent_backfill_tasks is not None:
            pulumi.set(__self__, "max_concurrent_backfill_tasks", max_concurrent_backfill_tasks)
        if max_concurrent_cdc_tasks is not None:
            pulumi.set(__self__, "max_concurrent_cdc_tasks", max_concurrent_cdc_tasks)
        if stream_large_objects is not None:
            pulumi.set(__self__, "stream_large_objects", stream_large_objects)

    @_builtins.property
    @pulumi.getter(name="dropLargeObjects")
    def drop_large_objects(self) -> Optional['outputs.StreamSourceConfigOracleSourceConfigDropLargeObjects']:
        """
        Configuration to drop large object values.
        """
        return pulumi.get(self, "drop_large_objects")

    @_builtins.property
    @pulumi.getter(name="excludeObjects")
    def exclude_objects(self) -> Optional['outputs.StreamSourceConfigOracleSourceConfigExcludeObjects']:
        """
        Oracle objects to exclude from the stream.
        Structure is documented below.
        """
        return pulumi.get(self, "exclude_objects")

    @_builtins.property
    @pulumi.getter(name="includeObjects")
    def include_objects(self) -> Optional['outputs.StreamSourceConfigOracleSourceConfigIncludeObjects']:
        """
        Oracle objects to retrieve from the source.
        Structure is documented below.
        """
        return pulumi.get(self, "include_objects")

    @_builtins.property
    @pulumi.getter(name="maxConcurrentBackfillTasks")
    def max_concurrent_backfill_tasks(self) -> Optional[_builtins.int]:
        """
        Maximum number of concurrent backfill tasks. The number should be non negative.
        If not set (or set to 0), the system's default value will be used.
        """
        return pulumi.get(self, "max_concurrent_backfill_tasks")

    @_builtins.property
    @pulumi.getter(name="maxConcurrentCdcTasks")
    def max_concurrent_cdc_tasks(self) -> Optional[_builtins.int]:
        """
        Maximum number of concurrent CDC tasks. The number should be non negative.
        If not set (or set to 0), the system's default value will be used.
        """
        return pulumi.get(self, "max_concurrent_cdc_tasks")

    @_builtins.property
    @pulumi.getter(name="streamLargeObjects")
    def stream_large_objects(self) -> Optional['outputs.StreamSourceConfigOracleSourceConfigStreamLargeObjects']:
        """
        Configuration to drop large object values.
        """
        return pulumi.get(self, "stream_large_objects")


@pulumi.output_type
class StreamSourceConfigOracleSourceConfigDropLargeObjects(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class StreamSourceConfigOracleSourceConfigExcludeObjects(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oracleSchemas":
            suggest = "oracle_schemas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigOracleSourceConfigExcludeObjects. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigOracleSourceConfigExcludeObjects.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigOracleSourceConfigExcludeObjects.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oracle_schemas: Sequence['outputs.StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchema']):
        """
        :param Sequence['StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaArgs'] oracle_schemas: Oracle schemas/databases in the database server
               Structure is documented below.
        """
        pulumi.set(__self__, "oracle_schemas", oracle_schemas)

    @_builtins.property
    @pulumi.getter(name="oracleSchemas")
    def oracle_schemas(self) -> Sequence['outputs.StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchema']:
        """
        Oracle schemas/databases in the database server
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_schemas")


@pulumi.output_type
class StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oracleTables":
            suggest = "oracle_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema: _builtins.str,
                 oracle_tables: Optional[Sequence['outputs.StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTable']] = None):
        """
        :param _builtins.str schema: Schema name.
        :param Sequence['StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableArgs'] oracle_tables: Tables in the database.
               Structure is documented below.
        """
        pulumi.set(__self__, "schema", schema)
        if oracle_tables is not None:
            pulumi.set(__self__, "oracle_tables", oracle_tables)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> _builtins.str:
        """
        Schema name.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="oracleTables")
    def oracle_tables(self) -> Optional[Sequence['outputs.StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTable']]:
        """
        Tables in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_tables")


@pulumi.output_type
class StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oracleColumns":
            suggest = "oracle_columns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table: _builtins.str,
                 oracle_columns: Optional[Sequence['outputs.StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumn']] = None):
        """
        :param _builtins.str table: Table name.
        :param Sequence['StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumnArgs'] oracle_columns: Oracle columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if oracle_columns is not None:
            pulumi.set(__self__, "oracle_columns", oracle_columns)

    @_builtins.property
    @pulumi.getter
    def table(self) -> _builtins.str:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @_builtins.property
    @pulumi.getter(name="oracleColumns")
    def oracle_columns(self) -> Optional[Sequence['outputs.StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumn']]:
        """
        Oracle columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_columns")


@pulumi.output_type
class StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "ordinalPosition":
            suggest = "ordinal_position"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigOracleSourceConfigExcludeObjectsOracleSchemaOracleTableOracleColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: Optional[_builtins.str] = None,
                 data_type: Optional[_builtins.str] = None,
                 encoding: Optional[_builtins.str] = None,
                 length: Optional[_builtins.int] = None,
                 nullable: Optional[_builtins.bool] = None,
                 ordinal_position: Optional[_builtins.int] = None,
                 precision: Optional[_builtins.int] = None,
                 primary_key: Optional[_builtins.bool] = None,
                 scale: Optional[_builtins.int] = None):
        """
        :param _builtins.str column: Column name.
        :param _builtins.str data_type: The Oracle data type. Full data types list can be found here:
               https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html
        :param _builtins.str encoding: (Output)
               Column encoding.
        :param _builtins.int length: (Output)
               Column length.
        :param _builtins.bool nullable: (Output)
               Whether or not the column can accept a null value.
        :param _builtins.int ordinal_position: (Output)
               The ordinal position of the column in the table.
        :param _builtins.int precision: (Output)
               Column precision.
        :param _builtins.bool primary_key: (Output)
               Whether or not the column represents a primary key.
        :param _builtins.int scale: (Output)
               Column scale.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[_builtins.str]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        The Oracle data type. Full data types list can be found here:
        https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def encoding(self) -> Optional[_builtins.str]:
        """
        (Output)
        Column encoding.
        """
        return pulumi.get(self, "encoding")

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[_builtins.int]:
        """
        (Output)
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column precision.
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column scale.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class StreamSourceConfigOracleSourceConfigIncludeObjects(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oracleSchemas":
            suggest = "oracle_schemas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigOracleSourceConfigIncludeObjects. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigOracleSourceConfigIncludeObjects.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigOracleSourceConfigIncludeObjects.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 oracle_schemas: Sequence['outputs.StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchema']):
        """
        :param Sequence['StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaArgs'] oracle_schemas: Oracle schemas/databases in the database server
               Structure is documented below.
        """
        pulumi.set(__self__, "oracle_schemas", oracle_schemas)

    @_builtins.property
    @pulumi.getter(name="oracleSchemas")
    def oracle_schemas(self) -> Sequence['outputs.StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchema']:
        """
        Oracle schemas/databases in the database server
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_schemas")


@pulumi.output_type
class StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oracleTables":
            suggest = "oracle_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema: _builtins.str,
                 oracle_tables: Optional[Sequence['outputs.StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTable']] = None):
        """
        :param _builtins.str schema: Schema name.
        :param Sequence['StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableArgs'] oracle_tables: Tables in the database.
               Structure is documented below.
        """
        pulumi.set(__self__, "schema", schema)
        if oracle_tables is not None:
            pulumi.set(__self__, "oracle_tables", oracle_tables)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> _builtins.str:
        """
        Schema name.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="oracleTables")
    def oracle_tables(self) -> Optional[Sequence['outputs.StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTable']]:
        """
        Tables in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_tables")


@pulumi.output_type
class StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "oracleColumns":
            suggest = "oracle_columns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table: _builtins.str,
                 oracle_columns: Optional[Sequence['outputs.StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumn']] = None):
        """
        :param _builtins.str table: Table name.
        :param Sequence['StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumnArgs'] oracle_columns: Oracle columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if oracle_columns is not None:
            pulumi.set(__self__, "oracle_columns", oracle_columns)

    @_builtins.property
    @pulumi.getter
    def table(self) -> _builtins.str:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @_builtins.property
    @pulumi.getter(name="oracleColumns")
    def oracle_columns(self) -> Optional[Sequence['outputs.StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumn']]:
        """
        Oracle columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "oracle_columns")


@pulumi.output_type
class StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "ordinalPosition":
            suggest = "ordinal_position"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigOracleSourceConfigIncludeObjectsOracleSchemaOracleTableOracleColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: Optional[_builtins.str] = None,
                 data_type: Optional[_builtins.str] = None,
                 encoding: Optional[_builtins.str] = None,
                 length: Optional[_builtins.int] = None,
                 nullable: Optional[_builtins.bool] = None,
                 ordinal_position: Optional[_builtins.int] = None,
                 precision: Optional[_builtins.int] = None,
                 primary_key: Optional[_builtins.bool] = None,
                 scale: Optional[_builtins.int] = None):
        """
        :param _builtins.str column: Column name.
        :param _builtins.str data_type: The Oracle data type. Full data types list can be found here:
               https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html
        :param _builtins.str encoding: (Output)
               Column encoding.
        :param _builtins.int length: (Output)
               Column length.
        :param _builtins.bool nullable: (Output)
               Whether or not the column can accept a null value.
        :param _builtins.int ordinal_position: (Output)
               The ordinal position of the column in the table.
        :param _builtins.int precision: (Output)
               Column precision.
        :param _builtins.bool primary_key: (Output)
               Whether or not the column represents a primary key.
        :param _builtins.int scale: (Output)
               Column scale.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if encoding is not None:
            pulumi.set(__self__, "encoding", encoding)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[_builtins.str]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        The Oracle data type. Full data types list can be found here:
        https://docs.oracle.com/en/database/oracle/oracle-database/21/sqlrf/Data-Types.html
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def encoding(self) -> Optional[_builtins.str]:
        """
        (Output)
        Column encoding.
        """
        return pulumi.get(self, "encoding")

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[_builtins.int]:
        """
        (Output)
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column precision.
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column scale.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class StreamSourceConfigOracleSourceConfigStreamLargeObjects(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class StreamSourceConfigPostgresqlSourceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "replicationSlot":
            suggest = "replication_slot"
        elif key == "excludeObjects":
            suggest = "exclude_objects"
        elif key == "includeObjects":
            suggest = "include_objects"
        elif key == "maxConcurrentBackfillTasks":
            suggest = "max_concurrent_backfill_tasks"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigPostgresqlSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigPostgresqlSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigPostgresqlSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 publication: _builtins.str,
                 replication_slot: _builtins.str,
                 exclude_objects: Optional['outputs.StreamSourceConfigPostgresqlSourceConfigExcludeObjects'] = None,
                 include_objects: Optional['outputs.StreamSourceConfigPostgresqlSourceConfigIncludeObjects'] = None,
                 max_concurrent_backfill_tasks: Optional[_builtins.int] = None):
        """
        :param _builtins.str publication: The name of the publication that includes the set of all tables
               that are defined in the stream's include_objects.
        :param _builtins.str replication_slot: The name of the logical replication slot that's configured with
               the pgoutput plugin.
        :param 'StreamSourceConfigPostgresqlSourceConfigExcludeObjectsArgs' exclude_objects: PostgreSQL objects to exclude from the stream.
               Structure is documented below.
        :param 'StreamSourceConfigPostgresqlSourceConfigIncludeObjectsArgs' include_objects: PostgreSQL objects to retrieve from the source.
               Structure is documented below.
        :param _builtins.int max_concurrent_backfill_tasks: Maximum number of concurrent backfill tasks. The number should be non
               negative. If not set (or set to 0), the system's default value will be used.
        """
        pulumi.set(__self__, "publication", publication)
        pulumi.set(__self__, "replication_slot", replication_slot)
        if exclude_objects is not None:
            pulumi.set(__self__, "exclude_objects", exclude_objects)
        if include_objects is not None:
            pulumi.set(__self__, "include_objects", include_objects)
        if max_concurrent_backfill_tasks is not None:
            pulumi.set(__self__, "max_concurrent_backfill_tasks", max_concurrent_backfill_tasks)

    @_builtins.property
    @pulumi.getter
    def publication(self) -> _builtins.str:
        """
        The name of the publication that includes the set of all tables
        that are defined in the stream's include_objects.
        """
        return pulumi.get(self, "publication")

    @_builtins.property
    @pulumi.getter(name="replicationSlot")
    def replication_slot(self) -> _builtins.str:
        """
        The name of the logical replication slot that's configured with
        the pgoutput plugin.
        """
        return pulumi.get(self, "replication_slot")

    @_builtins.property
    @pulumi.getter(name="excludeObjects")
    def exclude_objects(self) -> Optional['outputs.StreamSourceConfigPostgresqlSourceConfigExcludeObjects']:
        """
        PostgreSQL objects to exclude from the stream.
        Structure is documented below.
        """
        return pulumi.get(self, "exclude_objects")

    @_builtins.property
    @pulumi.getter(name="includeObjects")
    def include_objects(self) -> Optional['outputs.StreamSourceConfigPostgresqlSourceConfigIncludeObjects']:
        """
        PostgreSQL objects to retrieve from the source.
        Structure is documented below.
        """
        return pulumi.get(self, "include_objects")

    @_builtins.property
    @pulumi.getter(name="maxConcurrentBackfillTasks")
    def max_concurrent_backfill_tasks(self) -> Optional[_builtins.int]:
        """
        Maximum number of concurrent backfill tasks. The number should be non
        negative. If not set (or set to 0), the system's default value will be used.
        """
        return pulumi.get(self, "max_concurrent_backfill_tasks")


@pulumi.output_type
class StreamSourceConfigPostgresqlSourceConfigExcludeObjects(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postgresqlSchemas":
            suggest = "postgresql_schemas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigPostgresqlSourceConfigExcludeObjects. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigPostgresqlSourceConfigExcludeObjects.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigPostgresqlSourceConfigExcludeObjects.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 postgresql_schemas: Sequence['outputs.StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchema']):
        """
        :param Sequence['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaArgs'] postgresql_schemas: PostgreSQL schemas on the server
               Structure is documented below.
        """
        pulumi.set(__self__, "postgresql_schemas", postgresql_schemas)

    @_builtins.property
    @pulumi.getter(name="postgresqlSchemas")
    def postgresql_schemas(self) -> Sequence['outputs.StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchema']:
        """
        PostgreSQL schemas on the server
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_schemas")


@pulumi.output_type
class StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postgresqlTables":
            suggest = "postgresql_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema: _builtins.str,
                 postgresql_tables: Optional[Sequence['outputs.StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTable']] = None):
        """
        :param _builtins.str schema: Database name.
        :param Sequence['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTableArgs'] postgresql_tables: Tables in the schema.
               Structure is documented below.
        """
        pulumi.set(__self__, "schema", schema)
        if postgresql_tables is not None:
            pulumi.set(__self__, "postgresql_tables", postgresql_tables)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> _builtins.str:
        """
        Database name.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="postgresqlTables")
    def postgresql_tables(self) -> Optional[Sequence['outputs.StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTable']]:
        """
        Tables in the schema.
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_tables")


@pulumi.output_type
class StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postgresqlColumns":
            suggest = "postgresql_columns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table: _builtins.str,
                 postgresql_columns: Optional[Sequence['outputs.StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn']] = None):
        """
        :param _builtins.str table: Table name.
        :param Sequence['StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs'] postgresql_columns: PostgreSQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if postgresql_columns is not None:
            pulumi.set(__self__, "postgresql_columns", postgresql_columns)

    @_builtins.property
    @pulumi.getter
    def table(self) -> _builtins.str:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @_builtins.property
    @pulumi.getter(name="postgresqlColumns")
    def postgresql_columns(self) -> Optional[Sequence['outputs.StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn']]:
        """
        PostgreSQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_columns")


@pulumi.output_type
class StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "ordinalPosition":
            suggest = "ordinal_position"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigPostgresqlSourceConfigExcludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: Optional[_builtins.str] = None,
                 data_type: Optional[_builtins.str] = None,
                 length: Optional[_builtins.int] = None,
                 nullable: Optional[_builtins.bool] = None,
                 ordinal_position: Optional[_builtins.int] = None,
                 precision: Optional[_builtins.int] = None,
                 primary_key: Optional[_builtins.bool] = None,
                 scale: Optional[_builtins.int] = None):
        """
        :param _builtins.str column: Column name.
        :param _builtins.str data_type: The PostgreSQL data type. Full data types list can be found here:
               https://www.postgresql.org/docs/current/datatype.html
        :param _builtins.int length: (Output)
               Column length.
        :param _builtins.bool nullable: Whether or not the column can accept a null value.
        :param _builtins.int ordinal_position: The ordinal position of the column in the table.
        :param _builtins.int precision: (Output)
               Column precision.
        :param _builtins.bool primary_key: Whether or not the column represents a primary key.
        :param _builtins.int scale: (Output)
               Column scale.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[_builtins.str]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        The PostgreSQL data type. Full data types list can be found here:
        https://www.postgresql.org/docs/current/datatype.html
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[_builtins.int]:
        """
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column precision.
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[_builtins.bool]:
        """
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column scale.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class StreamSourceConfigPostgresqlSourceConfigIncludeObjects(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postgresqlSchemas":
            suggest = "postgresql_schemas"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigPostgresqlSourceConfigIncludeObjects. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigPostgresqlSourceConfigIncludeObjects.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigPostgresqlSourceConfigIncludeObjects.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 postgresql_schemas: Sequence['outputs.StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchema']):
        """
        :param Sequence['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaArgs'] postgresql_schemas: PostgreSQL schemas on the server
               Structure is documented below.
        """
        pulumi.set(__self__, "postgresql_schemas", postgresql_schemas)

    @_builtins.property
    @pulumi.getter(name="postgresqlSchemas")
    def postgresql_schemas(self) -> Sequence['outputs.StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchema']:
        """
        PostgreSQL schemas on the server
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_schemas")


@pulumi.output_type
class StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchema(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postgresqlTables":
            suggest = "postgresql_tables"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchema. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchema.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchema.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 schema: _builtins.str,
                 postgresql_tables: Optional[Sequence['outputs.StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTable']] = None):
        """
        :param _builtins.str schema: Database name.
        :param Sequence['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTableArgs'] postgresql_tables: Tables in the schema.
               Structure is documented below.
        """
        pulumi.set(__self__, "schema", schema)
        if postgresql_tables is not None:
            pulumi.set(__self__, "postgresql_tables", postgresql_tables)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> _builtins.str:
        """
        Database name.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter(name="postgresqlTables")
    def postgresql_tables(self) -> Optional[Sequence['outputs.StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTable']]:
        """
        Tables in the schema.
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_tables")


@pulumi.output_type
class StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTable(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "postgresqlColumns":
            suggest = "postgresql_columns"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTable. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTable.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTable.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 table: _builtins.str,
                 postgresql_columns: Optional[Sequence['outputs.StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn']] = None):
        """
        :param _builtins.str table: Table name.
        :param Sequence['StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumnArgs'] postgresql_columns: PostgreSQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if postgresql_columns is not None:
            pulumi.set(__self__, "postgresql_columns", postgresql_columns)

    @_builtins.property
    @pulumi.getter
    def table(self) -> _builtins.str:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @_builtins.property
    @pulumi.getter(name="postgresqlColumns")
    def postgresql_columns(self) -> Optional[Sequence['outputs.StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn']]:
        """
        PostgreSQL columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "postgresql_columns")


@pulumi.output_type
class StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "ordinalPosition":
            suggest = "ordinal_position"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigPostgresqlSourceConfigIncludeObjectsPostgresqlSchemaPostgresqlTablePostgresqlColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: Optional[_builtins.str] = None,
                 data_type: Optional[_builtins.str] = None,
                 length: Optional[_builtins.int] = None,
                 nullable: Optional[_builtins.bool] = None,
                 ordinal_position: Optional[_builtins.int] = None,
                 precision: Optional[_builtins.int] = None,
                 primary_key: Optional[_builtins.bool] = None,
                 scale: Optional[_builtins.int] = None):
        """
        :param _builtins.str column: Column name.
        :param _builtins.str data_type: The PostgreSQL data type. Full data types list can be found here:
               https://www.postgresql.org/docs/current/datatype.html
        :param _builtins.int length: (Output)
               Column length.
        :param _builtins.bool nullable: Whether or not the column can accept a null value.
        :param _builtins.int ordinal_position: The ordinal position of the column in the table.
        :param _builtins.int precision: (Output)
               Column precision.
        :param _builtins.bool primary_key: Whether or not the column represents a primary key.
        :param _builtins.int scale: (Output)
               Column scale.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[_builtins.str]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        The PostgreSQL data type. Full data types list can be found here:
        https://www.postgresql.org/docs/current/datatype.html
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[_builtins.int]:
        """
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column precision.
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[_builtins.bool]:
        """
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column scale.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class StreamSourceConfigSalesforceSourceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "pollingInterval":
            suggest = "polling_interval"
        elif key == "excludeObjects":
            suggest = "exclude_objects"
        elif key == "includeObjects":
            suggest = "include_objects"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigSalesforceSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigSalesforceSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigSalesforceSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 polling_interval: _builtins.str,
                 exclude_objects: Optional['outputs.StreamSourceConfigSalesforceSourceConfigExcludeObjects'] = None,
                 include_objects: Optional['outputs.StreamSourceConfigSalesforceSourceConfigIncludeObjects'] = None):
        """
        :param _builtins.str polling_interval: Salesforce objects polling interval. The interval at which new changes will be polled for each object. The duration must be between 5 minutes and 24 hours.
        :param 'StreamSourceConfigSalesforceSourceConfigExcludeObjectsArgs' exclude_objects: Salesforce objects to exclude from the stream.
               Structure is documented below.
        :param 'StreamSourceConfigSalesforceSourceConfigIncludeObjectsArgs' include_objects: Salesforce objects to retrieve from the source.
               Structure is documented below.
        """
        pulumi.set(__self__, "polling_interval", polling_interval)
        if exclude_objects is not None:
            pulumi.set(__self__, "exclude_objects", exclude_objects)
        if include_objects is not None:
            pulumi.set(__self__, "include_objects", include_objects)

    @_builtins.property
    @pulumi.getter(name="pollingInterval")
    def polling_interval(self) -> _builtins.str:
        """
        Salesforce objects polling interval. The interval at which new changes will be polled for each object. The duration must be between 5 minutes and 24 hours.
        """
        return pulumi.get(self, "polling_interval")

    @_builtins.property
    @pulumi.getter(name="excludeObjects")
    def exclude_objects(self) -> Optional['outputs.StreamSourceConfigSalesforceSourceConfigExcludeObjects']:
        """
        Salesforce objects to exclude from the stream.
        Structure is documented below.
        """
        return pulumi.get(self, "exclude_objects")

    @_builtins.property
    @pulumi.getter(name="includeObjects")
    def include_objects(self) -> Optional['outputs.StreamSourceConfigSalesforceSourceConfigIncludeObjects']:
        """
        Salesforce objects to retrieve from the source.
        Structure is documented below.
        """
        return pulumi.get(self, "include_objects")


@pulumi.output_type
class StreamSourceConfigSalesforceSourceConfigExcludeObjects(dict):
    def __init__(__self__, *,
                 objects: Sequence['outputs.StreamSourceConfigSalesforceSourceConfigExcludeObjectsObject']):
        """
        :param Sequence['StreamSourceConfigSalesforceSourceConfigExcludeObjectsObjectArgs'] objects: Salesforce objects in data source.
               Structure is documented below.
        """
        pulumi.set(__self__, "objects", objects)

    @_builtins.property
    @pulumi.getter
    def objects(self) -> Sequence['outputs.StreamSourceConfigSalesforceSourceConfigExcludeObjectsObject']:
        """
        Salesforce objects in data source.
        Structure is documented below.
        """
        return pulumi.get(self, "objects")


@pulumi.output_type
class StreamSourceConfigSalesforceSourceConfigExcludeObjectsObject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectName":
            suggest = "object_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigSalesforceSourceConfigExcludeObjectsObject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigSalesforceSourceConfigExcludeObjectsObject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigSalesforceSourceConfigExcludeObjectsObject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fields: Optional[Sequence['outputs.StreamSourceConfigSalesforceSourceConfigExcludeObjectsObjectField']] = None,
                 object_name: Optional[_builtins.str] = None):
        """
        :param Sequence['StreamSourceConfigSalesforceSourceConfigExcludeObjectsObjectFieldArgs'] fields: Fields in the Salesforce object. When unspecified as part of include/exclude objects, includes/excludes everything/nothing.
               Structure is documented below.
        :param _builtins.str object_name: Name of object in Salesforce Org.
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if object_name is not None:
            pulumi.set(__self__, "object_name", object_name)

    @_builtins.property
    @pulumi.getter
    def fields(self) -> Optional[Sequence['outputs.StreamSourceConfigSalesforceSourceConfigExcludeObjectsObjectField']]:
        """
        Fields in the Salesforce object. When unspecified as part of include/exclude objects, includes/excludes everything/nothing.
        Structure is documented below.
        """
        return pulumi.get(self, "fields")

    @_builtins.property
    @pulumi.getter(name="objectName")
    def object_name(self) -> Optional[_builtins.str]:
        """
        Name of object in Salesforce Org.
        """
        return pulumi.get(self, "object_name")


@pulumi.output_type
class StreamSourceConfigSalesforceSourceConfigExcludeObjectsObjectField(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Field name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Field name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class StreamSourceConfigSalesforceSourceConfigIncludeObjects(dict):
    def __init__(__self__, *,
                 objects: Sequence['outputs.StreamSourceConfigSalesforceSourceConfigIncludeObjectsObject']):
        """
        :param Sequence['StreamSourceConfigSalesforceSourceConfigIncludeObjectsObjectArgs'] objects: Salesforce objects in Salesforce Org.
               Structure is documented below.
        """
        pulumi.set(__self__, "objects", objects)

    @_builtins.property
    @pulumi.getter
    def objects(self) -> Sequence['outputs.StreamSourceConfigSalesforceSourceConfigIncludeObjectsObject']:
        """
        Salesforce objects in Salesforce Org.
        Structure is documented below.
        """
        return pulumi.get(self, "objects")


@pulumi.output_type
class StreamSourceConfigSalesforceSourceConfigIncludeObjectsObject(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "objectName":
            suggest = "object_name"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigSalesforceSourceConfigIncludeObjectsObject. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigSalesforceSourceConfigIncludeObjectsObject.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigSalesforceSourceConfigIncludeObjectsObject.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 fields: Optional[Sequence['outputs.StreamSourceConfigSalesforceSourceConfigIncludeObjectsObjectField']] = None,
                 object_name: Optional[_builtins.str] = None):
        """
        :param Sequence['StreamSourceConfigSalesforceSourceConfigIncludeObjectsObjectFieldArgs'] fields: Fields in the Salesforce object. When unspecified as part of include/exclude objects, includes/excludes everything/nothing.
               Structure is documented below.
        :param _builtins.str object_name: Name of object in Salesforce Org.
        """
        if fields is not None:
            pulumi.set(__self__, "fields", fields)
        if object_name is not None:
            pulumi.set(__self__, "object_name", object_name)

    @_builtins.property
    @pulumi.getter
    def fields(self) -> Optional[Sequence['outputs.StreamSourceConfigSalesforceSourceConfigIncludeObjectsObjectField']]:
        """
        Fields in the Salesforce object. When unspecified as part of include/exclude objects, includes/excludes everything/nothing.
        Structure is documented below.
        """
        return pulumi.get(self, "fields")

    @_builtins.property
    @pulumi.getter(name="objectName")
    def object_name(self) -> Optional[_builtins.str]:
        """
        Name of object in Salesforce Org.
        """
        return pulumi.get(self, "object_name")


@pulumi.output_type
class StreamSourceConfigSalesforceSourceConfigIncludeObjectsObjectField(dict):
    def __init__(__self__, *,
                 name: Optional[_builtins.str] = None):
        """
        :param _builtins.str name: Field name.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[_builtins.str]:
        """
        Field name.
        """
        return pulumi.get(self, "name")


@pulumi.output_type
class StreamSourceConfigSqlServerSourceConfig(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "changeTables":
            suggest = "change_tables"
        elif key == "excludeObjects":
            suggest = "exclude_objects"
        elif key == "includeObjects":
            suggest = "include_objects"
        elif key == "maxConcurrentBackfillTasks":
            suggest = "max_concurrent_backfill_tasks"
        elif key == "maxConcurrentCdcTasks":
            suggest = "max_concurrent_cdc_tasks"
        elif key == "transactionLogs":
            suggest = "transaction_logs"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigSqlServerSourceConfig. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigSqlServerSourceConfig.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigSqlServerSourceConfig.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 change_tables: Optional['outputs.StreamSourceConfigSqlServerSourceConfigChangeTables'] = None,
                 exclude_objects: Optional['outputs.StreamSourceConfigSqlServerSourceConfigExcludeObjects'] = None,
                 include_objects: Optional['outputs.StreamSourceConfigSqlServerSourceConfigIncludeObjects'] = None,
                 max_concurrent_backfill_tasks: Optional[_builtins.int] = None,
                 max_concurrent_cdc_tasks: Optional[_builtins.int] = None,
                 transaction_logs: Optional['outputs.StreamSourceConfigSqlServerSourceConfigTransactionLogs'] = None):
        """
        :param 'StreamSourceConfigSqlServerSourceConfigChangeTablesArgs' change_tables: CDC reader reads from change tables.
        :param 'StreamSourceConfigSqlServerSourceConfigExcludeObjectsArgs' exclude_objects: SQL Server objects to exclude from the stream.
               Structure is documented below.
        :param 'StreamSourceConfigSqlServerSourceConfigIncludeObjectsArgs' include_objects: SQL Server objects to retrieve from the source.
               Structure is documented below.
        :param _builtins.int max_concurrent_backfill_tasks: Max concurrent backfill tasks.
        :param _builtins.int max_concurrent_cdc_tasks: Max concurrent CDC tasks.
        :param 'StreamSourceConfigSqlServerSourceConfigTransactionLogsArgs' transaction_logs: CDC reader reads from transaction logs.
        """
        if change_tables is not None:
            pulumi.set(__self__, "change_tables", change_tables)
        if exclude_objects is not None:
            pulumi.set(__self__, "exclude_objects", exclude_objects)
        if include_objects is not None:
            pulumi.set(__self__, "include_objects", include_objects)
        if max_concurrent_backfill_tasks is not None:
            pulumi.set(__self__, "max_concurrent_backfill_tasks", max_concurrent_backfill_tasks)
        if max_concurrent_cdc_tasks is not None:
            pulumi.set(__self__, "max_concurrent_cdc_tasks", max_concurrent_cdc_tasks)
        if transaction_logs is not None:
            pulumi.set(__self__, "transaction_logs", transaction_logs)

    @_builtins.property
    @pulumi.getter(name="changeTables")
    def change_tables(self) -> Optional['outputs.StreamSourceConfigSqlServerSourceConfigChangeTables']:
        """
        CDC reader reads from change tables.
        """
        return pulumi.get(self, "change_tables")

    @_builtins.property
    @pulumi.getter(name="excludeObjects")
    def exclude_objects(self) -> Optional['outputs.StreamSourceConfigSqlServerSourceConfigExcludeObjects']:
        """
        SQL Server objects to exclude from the stream.
        Structure is documented below.
        """
        return pulumi.get(self, "exclude_objects")

    @_builtins.property
    @pulumi.getter(name="includeObjects")
    def include_objects(self) -> Optional['outputs.StreamSourceConfigSqlServerSourceConfigIncludeObjects']:
        """
        SQL Server objects to retrieve from the source.
        Structure is documented below.
        """
        return pulumi.get(self, "include_objects")

    @_builtins.property
    @pulumi.getter(name="maxConcurrentBackfillTasks")
    def max_concurrent_backfill_tasks(self) -> Optional[_builtins.int]:
        """
        Max concurrent backfill tasks.
        """
        return pulumi.get(self, "max_concurrent_backfill_tasks")

    @_builtins.property
    @pulumi.getter(name="maxConcurrentCdcTasks")
    def max_concurrent_cdc_tasks(self) -> Optional[_builtins.int]:
        """
        Max concurrent CDC tasks.
        """
        return pulumi.get(self, "max_concurrent_cdc_tasks")

    @_builtins.property
    @pulumi.getter(name="transactionLogs")
    def transaction_logs(self) -> Optional['outputs.StreamSourceConfigSqlServerSourceConfigTransactionLogs']:
        """
        CDC reader reads from transaction logs.
        """
        return pulumi.get(self, "transaction_logs")


@pulumi.output_type
class StreamSourceConfigSqlServerSourceConfigChangeTables(dict):
    def __init__(__self__):
        pass


@pulumi.output_type
class StreamSourceConfigSqlServerSourceConfigExcludeObjects(dict):
    def __init__(__self__, *,
                 schemas: Sequence['outputs.StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchema']):
        """
        :param Sequence['StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaArgs'] schemas: SQL Server schemas/databases in the database server
               Structure is documented below.
        """
        pulumi.set(__self__, "schemas", schemas)

    @_builtins.property
    @pulumi.getter
    def schemas(self) -> Sequence['outputs.StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchema']:
        """
        SQL Server schemas/databases in the database server
        Structure is documented below.
        """
        return pulumi.get(self, "schemas")


@pulumi.output_type
class StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchema(dict):
    def __init__(__self__, *,
                 schema: _builtins.str,
                 tables: Optional[Sequence['outputs.StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTable']] = None):
        """
        :param _builtins.str schema: Schema name.
        :param Sequence['StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableArgs'] tables: Tables in the database.
               Structure is documented below.
        """
        pulumi.set(__self__, "schema", schema)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> _builtins.str:
        """
        Schema name.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional[Sequence['outputs.StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTable']]:
        """
        Tables in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "tables")


@pulumi.output_type
class StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTable(dict):
    def __init__(__self__, *,
                 table: _builtins.str,
                 columns: Optional[Sequence['outputs.StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumn']] = None):
        """
        :param _builtins.str table: Table name.
        :param Sequence['StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumnArgs'] columns: SQL Server columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)

    @_builtins.property
    @pulumi.getter
    def table(self) -> _builtins.str:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumn']]:
        """
        SQL Server columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "columns")


@pulumi.output_type
class StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "ordinalPosition":
            suggest = "ordinal_position"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigSqlServerSourceConfigExcludeObjectsSchemaTableColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: Optional[_builtins.str] = None,
                 data_type: Optional[_builtins.str] = None,
                 length: Optional[_builtins.int] = None,
                 nullable: Optional[_builtins.bool] = None,
                 ordinal_position: Optional[_builtins.int] = None,
                 precision: Optional[_builtins.int] = None,
                 primary_key: Optional[_builtins.bool] = None,
                 scale: Optional[_builtins.int] = None):
        """
        :param _builtins.str column: Column name.
        :param _builtins.str data_type: The SQL Server data type. Full data types list can be found here:
               https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver16
        :param _builtins.int length: (Output)
               Column length.
        :param _builtins.bool nullable: (Output)
               Whether or not the column can accept a null value.
        :param _builtins.int ordinal_position: (Output)
               The ordinal position of the column in the table.
        :param _builtins.int precision: (Output)
               Column precision.
        :param _builtins.bool primary_key: (Output)
               Whether or not the column represents a primary key.
        :param _builtins.int scale: (Output)
               Column scale.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[_builtins.str]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        The SQL Server data type. Full data types list can be found here:
        https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver16
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[_builtins.int]:
        """
        (Output)
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column precision.
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column scale.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class StreamSourceConfigSqlServerSourceConfigIncludeObjects(dict):
    def __init__(__self__, *,
                 schemas: Sequence['outputs.StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchema']):
        """
        :param Sequence['StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaArgs'] schemas: SQL Server schemas/databases in the database server
               Structure is documented below.
        """
        pulumi.set(__self__, "schemas", schemas)

    @_builtins.property
    @pulumi.getter
    def schemas(self) -> Sequence['outputs.StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchema']:
        """
        SQL Server schemas/databases in the database server
        Structure is documented below.
        """
        return pulumi.get(self, "schemas")


@pulumi.output_type
class StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchema(dict):
    def __init__(__self__, *,
                 schema: _builtins.str,
                 tables: Optional[Sequence['outputs.StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTable']] = None):
        """
        :param _builtins.str schema: Schema name.
        :param Sequence['StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableArgs'] tables: Tables in the database.
               Structure is documented below.
        """
        pulumi.set(__self__, "schema", schema)
        if tables is not None:
            pulumi.set(__self__, "tables", tables)

    @_builtins.property
    @pulumi.getter
    def schema(self) -> _builtins.str:
        """
        Schema name.
        """
        return pulumi.get(self, "schema")

    @_builtins.property
    @pulumi.getter
    def tables(self) -> Optional[Sequence['outputs.StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTable']]:
        """
        Tables in the database.
        Structure is documented below.
        """
        return pulumi.get(self, "tables")


@pulumi.output_type
class StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTable(dict):
    def __init__(__self__, *,
                 table: _builtins.str,
                 columns: Optional[Sequence['outputs.StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumn']] = None):
        """
        :param _builtins.str table: Table name.
        :param Sequence['StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumnArgs'] columns: SQL Server columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
               Structure is documented below.
        """
        pulumi.set(__self__, "table", table)
        if columns is not None:
            pulumi.set(__self__, "columns", columns)

    @_builtins.property
    @pulumi.getter
    def table(self) -> _builtins.str:
        """
        Table name.
        """
        return pulumi.get(self, "table")

    @_builtins.property
    @pulumi.getter
    def columns(self) -> Optional[Sequence['outputs.StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumn']]:
        """
        SQL Server columns in the schema. When unspecified as part of include/exclude objects, includes/excludes everything.
        Structure is documented below.
        """
        return pulumi.get(self, "columns")


@pulumi.output_type
class StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumn(dict):
    @staticmethod
    def __key_warning(key: str):
        suggest = None
        if key == "dataType":
            suggest = "data_type"
        elif key == "ordinalPosition":
            suggest = "ordinal_position"
        elif key == "primaryKey":
            suggest = "primary_key"

        if suggest:
            pulumi.log.warn(f"Key '{key}' not found in StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumn. Access the value via the '{suggest}' property getter instead.")

    def __getitem__(self, key: str) -> Any:
        StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumn.__key_warning(key)
        return super().__getitem__(key)

    def get(self, key: str, default = None) -> Any:
        StreamSourceConfigSqlServerSourceConfigIncludeObjectsSchemaTableColumn.__key_warning(key)
        return super().get(key, default)

    def __init__(__self__, *,
                 column: Optional[_builtins.str] = None,
                 data_type: Optional[_builtins.str] = None,
                 length: Optional[_builtins.int] = None,
                 nullable: Optional[_builtins.bool] = None,
                 ordinal_position: Optional[_builtins.int] = None,
                 precision: Optional[_builtins.int] = None,
                 primary_key: Optional[_builtins.bool] = None,
                 scale: Optional[_builtins.int] = None):
        """
        :param _builtins.str column: Column name.
        :param _builtins.str data_type: The SQL Server data type. Full data types list can be found here:
               https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver16
        :param _builtins.int length: (Output)
               Column length.
        :param _builtins.bool nullable: (Output)
               Whether or not the column can accept a null value.
        :param _builtins.int ordinal_position: (Output)
               The ordinal position of the column in the table.
        :param _builtins.int precision: (Output)
               Column precision.
        :param _builtins.bool primary_key: (Output)
               Whether or not the column represents a primary key.
        :param _builtins.int scale: (Output)
               Column scale.
        """
        if column is not None:
            pulumi.set(__self__, "column", column)
        if data_type is not None:
            pulumi.set(__self__, "data_type", data_type)
        if length is not None:
            pulumi.set(__self__, "length", length)
        if nullable is not None:
            pulumi.set(__self__, "nullable", nullable)
        if ordinal_position is not None:
            pulumi.set(__self__, "ordinal_position", ordinal_position)
        if precision is not None:
            pulumi.set(__self__, "precision", precision)
        if primary_key is not None:
            pulumi.set(__self__, "primary_key", primary_key)
        if scale is not None:
            pulumi.set(__self__, "scale", scale)

    @_builtins.property
    @pulumi.getter
    def column(self) -> Optional[_builtins.str]:
        """
        Column name.
        """
        return pulumi.get(self, "column")

    @_builtins.property
    @pulumi.getter(name="dataType")
    def data_type(self) -> Optional[_builtins.str]:
        """
        The SQL Server data type. Full data types list can be found here:
        https://learn.microsoft.com/en-us/sql/t-sql/data-types/data-types-transact-sql?view=sql-server-ver16
        """
        return pulumi.get(self, "data_type")

    @_builtins.property
    @pulumi.getter
    def length(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column length.
        """
        return pulumi.get(self, "length")

    @_builtins.property
    @pulumi.getter
    def nullable(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether or not the column can accept a null value.
        """
        return pulumi.get(self, "nullable")

    @_builtins.property
    @pulumi.getter(name="ordinalPosition")
    def ordinal_position(self) -> Optional[_builtins.int]:
        """
        (Output)
        The ordinal position of the column in the table.
        """
        return pulumi.get(self, "ordinal_position")

    @_builtins.property
    @pulumi.getter
    def precision(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column precision.
        """
        return pulumi.get(self, "precision")

    @_builtins.property
    @pulumi.getter(name="primaryKey")
    def primary_key(self) -> Optional[_builtins.bool]:
        """
        (Output)
        Whether or not the column represents a primary key.
        """
        return pulumi.get(self, "primary_key")

    @_builtins.property
    @pulumi.getter
    def scale(self) -> Optional[_builtins.int]:
        """
        (Output)
        Column scale.
        """
        return pulumi.get(self, "scale")


@pulumi.output_type
class StreamSourceConfigSqlServerSourceConfigTransactionLogs(dict):
    def __init__(__self__):
        pass


