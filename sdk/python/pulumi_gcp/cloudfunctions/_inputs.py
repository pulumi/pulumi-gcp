# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'FunctionAutomaticUpdatePolicyArgs',
    'FunctionAutomaticUpdatePolicyArgsDict',
    'FunctionEventTriggerArgs',
    'FunctionEventTriggerArgsDict',
    'FunctionEventTriggerFailurePolicyArgs',
    'FunctionEventTriggerFailurePolicyArgsDict',
    'FunctionIamBindingConditionArgs',
    'FunctionIamBindingConditionArgsDict',
    'FunctionIamMemberConditionArgs',
    'FunctionIamMemberConditionArgsDict',
    'FunctionOnDeployUpdatePolicyArgs',
    'FunctionOnDeployUpdatePolicyArgsDict',
    'FunctionSecretEnvironmentVariableArgs',
    'FunctionSecretEnvironmentVariableArgsDict',
    'FunctionSecretVolumeArgs',
    'FunctionSecretVolumeArgsDict',
    'FunctionSecretVolumeVersionArgs',
    'FunctionSecretVolumeVersionArgsDict',
    'FunctionSourceRepositoryArgs',
    'FunctionSourceRepositoryArgsDict',
]

MYPY = False

if not MYPY:
    class FunctionAutomaticUpdatePolicyArgsDict(TypedDict):
        pass
elif False:
    FunctionAutomaticUpdatePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionAutomaticUpdatePolicyArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class FunctionEventTriggerArgsDict(TypedDict):
        event_type: pulumi.Input[_builtins.str]
        """
        The type of event to observe. For example: `"google.storage.object.finalize"`.
        See the documentation on [calling Cloud Functions](https://cloud.google.com/functions/docs/calling/) for a
        full reference of accepted triggers.
        """
        resource: pulumi.Input[_builtins.str]
        """
        Required. The name or partial URI of the resource from
        which to observe events. For example, `"myBucket"` or `"projects/my-project/topics/my-topic"`
        """
        failure_policy: NotRequired[pulumi.Input['FunctionEventTriggerFailurePolicyArgsDict']]
        """
        Specifies policy for failed executions. Structure is documented below.
        """
elif False:
    FunctionEventTriggerArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEventTriggerArgs:
    def __init__(__self__, *,
                 event_type: pulumi.Input[_builtins.str],
                 resource: pulumi.Input[_builtins.str],
                 failure_policy: Optional[pulumi.Input['FunctionEventTriggerFailurePolicyArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] event_type: The type of event to observe. For example: `"google.storage.object.finalize"`.
               See the documentation on [calling Cloud Functions](https://cloud.google.com/functions/docs/calling/) for a
               full reference of accepted triggers.
        :param pulumi.Input[_builtins.str] resource: Required. The name or partial URI of the resource from
               which to observe events. For example, `"myBucket"` or `"projects/my-project/topics/my-topic"`
        :param pulumi.Input['FunctionEventTriggerFailurePolicyArgs'] failure_policy: Specifies policy for failed executions. Structure is documented below.
        """
        pulumi.set(__self__, "event_type", event_type)
        pulumi.set(__self__, "resource", resource)
        if failure_policy is not None:
            pulumi.set(__self__, "failure_policy", failure_policy)

    @_builtins.property
    @pulumi.getter(name="eventType")
    def event_type(self) -> pulumi.Input[_builtins.str]:
        """
        The type of event to observe. For example: `"google.storage.object.finalize"`.
        See the documentation on [calling Cloud Functions](https://cloud.google.com/functions/docs/calling/) for a
        full reference of accepted triggers.
        """
        return pulumi.get(self, "event_type")

    @event_type.setter
    def event_type(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "event_type", value)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> pulumi.Input[_builtins.str]:
        """
        Required. The name or partial URI of the resource from
        which to observe events. For example, `"myBucket"` or `"projects/my-project/topics/my-topic"`
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "resource", value)

    @_builtins.property
    @pulumi.getter(name="failurePolicy")
    def failure_policy(self) -> Optional[pulumi.Input['FunctionEventTriggerFailurePolicyArgs']]:
        """
        Specifies policy for failed executions. Structure is documented below.
        """
        return pulumi.get(self, "failure_policy")

    @failure_policy.setter
    def failure_policy(self, value: Optional[pulumi.Input['FunctionEventTriggerFailurePolicyArgs']]):
        pulumi.set(self, "failure_policy", value)


if not MYPY:
    class FunctionEventTriggerFailurePolicyArgsDict(TypedDict):
        retry: pulumi.Input[_builtins.bool]
        """
        Whether the function should be retried on failure. Defaults to `false`.
        """
elif False:
    FunctionEventTriggerFailurePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionEventTriggerFailurePolicyArgs:
    def __init__(__self__, *,
                 retry: pulumi.Input[_builtins.bool]):
        """
        :param pulumi.Input[_builtins.bool] retry: Whether the function should be retried on failure. Defaults to `false`.
        """
        pulumi.set(__self__, "retry", retry)

    @_builtins.property
    @pulumi.getter
    def retry(self) -> pulumi.Input[_builtins.bool]:
        """
        Whether the function should be retried on failure. Defaults to `false`.
        """
        return pulumi.get(self, "retry")

    @retry.setter
    def retry(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "retry", value)


if not MYPY:
    class FunctionIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[_builtins.str]
        title: pulumi.Input[_builtins.str]
        description: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FunctionIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 title: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class FunctionIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[_builtins.str]
        title: pulumi.Input[_builtins.str]
        description: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    FunctionIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 title: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class FunctionOnDeployUpdatePolicyArgsDict(TypedDict):
        runtime_version: NotRequired[pulumi.Input[_builtins.str]]
        """
        The runtime version which was used during latest function deployment.
        """
elif False:
    FunctionOnDeployUpdatePolicyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionOnDeployUpdatePolicyArgs:
    def __init__(__self__, *,
                 runtime_version: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] runtime_version: The runtime version which was used during latest function deployment.
        """
        if runtime_version is not None:
            pulumi.set(__self__, "runtime_version", runtime_version)

    @_builtins.property
    @pulumi.getter(name="runtimeVersion")
    def runtime_version(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The runtime version which was used during latest function deployment.
        """
        return pulumi.get(self, "runtime_version")

    @runtime_version.setter
    def runtime_version(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "runtime_version", value)


if not MYPY:
    class FunctionSecretEnvironmentVariableArgsDict(TypedDict):
        key: pulumi.Input[_builtins.str]
        """
        Name of the environment variable.
        """
        secret: pulumi.Input[_builtins.str]
        """
        ID of the secret in secret manager (not the full resource name).
        """
        version: pulumi.Input[_builtins.str]
        """
        Version of the secret (version number or the string "latest"). It is recommended to use a numeric version for secret environment variables as any updates to the secret value is not reflected until new clones start.
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Project identifier (due to a known limitation, only project number is supported by this field) of the project that contains the secret. If not set, it will be populated with the function's project, assuming that the secret exists in the same project as of the function.
        """
elif False:
    FunctionSecretEnvironmentVariableArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionSecretEnvironmentVariableArgs:
    def __init__(__self__, *,
                 key: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str],
                 version: pulumi.Input[_builtins.str],
                 project_id: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] key: Name of the environment variable.
        :param pulumi.Input[_builtins.str] secret: ID of the secret in secret manager (not the full resource name).
        :param pulumi.Input[_builtins.str] version: Version of the secret (version number or the string "latest"). It is recommended to use a numeric version for secret environment variables as any updates to the secret value is not reflected until new clones start.
        :param pulumi.Input[_builtins.str] project_id: Project identifier (due to a known limitation, only project number is supported by this field) of the project that contains the secret. If not set, it will be populated with the function's project, assuming that the secret exists in the same project as of the function.
        """
        pulumi.set(__self__, "key", key)
        pulumi.set(__self__, "secret", secret)
        pulumi.set(__self__, "version", version)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)

    @_builtins.property
    @pulumi.getter
    def key(self) -> pulumi.Input[_builtins.str]:
        """
        Name of the environment variable.
        """
        return pulumi.get(self, "key")

    @key.setter
    def key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "key", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the secret in secret manager (not the full resource name).
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.str]:
        """
        Version of the secret (version number or the string "latest"). It is recommended to use a numeric version for secret environment variables as any updates to the secret value is not reflected until new clones start.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Project identifier (due to a known limitation, only project number is supported by this field) of the project that contains the secret. If not set, it will be populated with the function's project, assuming that the secret exists in the same project as of the function.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)


if not MYPY:
    class FunctionSecretVolumeArgsDict(TypedDict):
        mount_path: pulumi.Input[_builtins.str]
        """
        The path within the container to mount the secret volume. For example, setting the mount_path as "/etc/secrets" would mount the secret value files under the "/etc/secrets" directory. This directory will also be completely shadowed and unavailable to mount any other secrets. Recommended mount paths: "/etc/secrets" Restricted mount paths: "/cloudsql", "/dev/log", "/pod", "/proc", "/var/log".
        """
        secret: pulumi.Input[_builtins.str]
        """
        ID of the secret in secret manager (not the full resource name).
        """
        project_id: NotRequired[pulumi.Input[_builtins.str]]
        """
        Project identifier (due to a known limitation, only project number is supported by this field) of the project that contains the secret. If not set, it will be populated with the function's project, assuming that the secret exists in the same project as of the function.
        """
        versions: NotRequired[pulumi.Input[Sequence[pulumi.Input['FunctionSecretVolumeVersionArgsDict']]]]
        """
        List of secret versions to mount for this secret. If empty, the "latest" version of the secret will be made available in a file named after the secret under the mount point. Structure is documented below.
        """
elif False:
    FunctionSecretVolumeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionSecretVolumeArgs:
    def __init__(__self__, *,
                 mount_path: pulumi.Input[_builtins.str],
                 secret: pulumi.Input[_builtins.str],
                 project_id: Optional[pulumi.Input[_builtins.str]] = None,
                 versions: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionSecretVolumeVersionArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] mount_path: The path within the container to mount the secret volume. For example, setting the mount_path as "/etc/secrets" would mount the secret value files under the "/etc/secrets" directory. This directory will also be completely shadowed and unavailable to mount any other secrets. Recommended mount paths: "/etc/secrets" Restricted mount paths: "/cloudsql", "/dev/log", "/pod", "/proc", "/var/log".
        :param pulumi.Input[_builtins.str] secret: ID of the secret in secret manager (not the full resource name).
        :param pulumi.Input[_builtins.str] project_id: Project identifier (due to a known limitation, only project number is supported by this field) of the project that contains the secret. If not set, it will be populated with the function's project, assuming that the secret exists in the same project as of the function.
        :param pulumi.Input[Sequence[pulumi.Input['FunctionSecretVolumeVersionArgs']]] versions: List of secret versions to mount for this secret. If empty, the "latest" version of the secret will be made available in a file named after the secret under the mount point. Structure is documented below.
        """
        pulumi.set(__self__, "mount_path", mount_path)
        pulumi.set(__self__, "secret", secret)
        if project_id is not None:
            pulumi.set(__self__, "project_id", project_id)
        if versions is not None:
            pulumi.set(__self__, "versions", versions)

    @_builtins.property
    @pulumi.getter(name="mountPath")
    def mount_path(self) -> pulumi.Input[_builtins.str]:
        """
        The path within the container to mount the secret volume. For example, setting the mount_path as "/etc/secrets" would mount the secret value files under the "/etc/secrets" directory. This directory will also be completely shadowed and unavailable to mount any other secrets. Recommended mount paths: "/etc/secrets" Restricted mount paths: "/cloudsql", "/dev/log", "/pod", "/proc", "/var/log".
        """
        return pulumi.get(self, "mount_path")

    @mount_path.setter
    def mount_path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "mount_path", value)

    @_builtins.property
    @pulumi.getter
    def secret(self) -> pulumi.Input[_builtins.str]:
        """
        ID of the secret in secret manager (not the full resource name).
        """
        return pulumi.get(self, "secret")

    @secret.setter
    def secret(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "secret", value)

    @_builtins.property
    @pulumi.getter(name="projectId")
    def project_id(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Project identifier (due to a known limitation, only project number is supported by this field) of the project that contains the secret. If not set, it will be populated with the function's project, assuming that the secret exists in the same project as of the function.
        """
        return pulumi.get(self, "project_id")

    @project_id.setter
    def project_id(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "project_id", value)

    @_builtins.property
    @pulumi.getter
    def versions(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['FunctionSecretVolumeVersionArgs']]]]:
        """
        List of secret versions to mount for this secret. If empty, the "latest" version of the secret will be made available in a file named after the secret under the mount point. Structure is documented below.
        """
        return pulumi.get(self, "versions")

    @versions.setter
    def versions(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['FunctionSecretVolumeVersionArgs']]]]):
        pulumi.set(self, "versions", value)


if not MYPY:
    class FunctionSecretVolumeVersionArgsDict(TypedDict):
        path: pulumi.Input[_builtins.str]
        """
        Relative path of the file under the mount path where the secret value for this version will be fetched and made available. For example, setting the mount_path as "/etc/secrets" and path as "/secret_foo" would mount the secret value file at "/etc/secrets/secret_foo".
        """
        version: pulumi.Input[_builtins.str]
        """
        Version of the secret (version number or the string "latest"). It is preferable to use "latest" version with secret volumes as secret value changes are reflected immediately.
        """
elif False:
    FunctionSecretVolumeVersionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionSecretVolumeVersionArgs:
    def __init__(__self__, *,
                 path: pulumi.Input[_builtins.str],
                 version: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] path: Relative path of the file under the mount path where the secret value for this version will be fetched and made available. For example, setting the mount_path as "/etc/secrets" and path as "/secret_foo" would mount the secret value file at "/etc/secrets/secret_foo".
        :param pulumi.Input[_builtins.str] version: Version of the secret (version number or the string "latest"). It is preferable to use "latest" version with secret volumes as secret value changes are reflected immediately.
        """
        pulumi.set(__self__, "path", path)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter
    def path(self) -> pulumi.Input[_builtins.str]:
        """
        Relative path of the file under the mount path where the secret value for this version will be fetched and made available. For example, setting the mount_path as "/etc/secrets" and path as "/secret_foo" would mount the secret value file at "/etc/secrets/secret_foo".
        """
        return pulumi.get(self, "path")

    @path.setter
    def path(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "path", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.str]:
        """
        Version of the secret (version number or the string "latest"). It is preferable to use "latest" version with secret volumes as secret value changes are reflected immediately.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "version", value)


if not MYPY:
    class FunctionSourceRepositoryArgsDict(TypedDict):
        url: pulumi.Input[_builtins.str]
        """
        The URL pointing to the hosted repository where the function is defined. There are supported Cloud Source Repository URLs in the following formats:

        * To refer to a specific commit: `https://source.developers.google.com/projects/*/repos/*/revisions/*/paths/*`
        * To refer to a moveable alias (branch): `https://source.developers.google.com/projects/*/repos/*/moveable-aliases/*/paths/*`. To refer to HEAD, use the `master` moveable alias.
        * To refer to a specific fixed alias (tag): `https://source.developers.google.com/projects/*/repos/*/fixed-aliases/*/paths/*`
        """
        deployed_url: NotRequired[pulumi.Input[_builtins.str]]
        """
        The URL pointing to the hosted repository where the function was defined at the time of deployment.
        """
elif False:
    FunctionSourceRepositoryArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class FunctionSourceRepositoryArgs:
    def __init__(__self__, *,
                 url: pulumi.Input[_builtins.str],
                 deployed_url: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] url: The URL pointing to the hosted repository where the function is defined. There are supported Cloud Source Repository URLs in the following formats:
               
               * To refer to a specific commit: `https://source.developers.google.com/projects/*/repos/*/revisions/*/paths/*`
               * To refer to a moveable alias (branch): `https://source.developers.google.com/projects/*/repos/*/moveable-aliases/*/paths/*`. To refer to HEAD, use the `master` moveable alias.
               * To refer to a specific fixed alias (tag): `https://source.developers.google.com/projects/*/repos/*/fixed-aliases/*/paths/*`
        :param pulumi.Input[_builtins.str] deployed_url: The URL pointing to the hosted repository where the function was defined at the time of deployment.
        """
        pulumi.set(__self__, "url", url)
        if deployed_url is not None:
            pulumi.set(__self__, "deployed_url", deployed_url)

    @_builtins.property
    @pulumi.getter
    def url(self) -> pulumi.Input[_builtins.str]:
        """
        The URL pointing to the hosted repository where the function is defined. There are supported Cloud Source Repository URLs in the following formats:

        * To refer to a specific commit: `https://source.developers.google.com/projects/*/repos/*/revisions/*/paths/*`
        * To refer to a moveable alias (branch): `https://source.developers.google.com/projects/*/repos/*/moveable-aliases/*/paths/*`. To refer to HEAD, use the `master` moveable alias.
        * To refer to a specific fixed alias (tag): `https://source.developers.google.com/projects/*/repos/*/fixed-aliases/*/paths/*`
        """
        return pulumi.get(self, "url")

    @url.setter
    def url(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "url", value)

    @_builtins.property
    @pulumi.getter(name="deployedUrl")
    def deployed_url(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The URL pointing to the hosted repository where the function was defined at the time of deployment.
        """
        return pulumi.get(self, "deployed_url")

    @deployed_url.setter
    def deployed_url(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "deployed_url", value)


