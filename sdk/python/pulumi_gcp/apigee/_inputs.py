# coding=utf-8
# *** WARNING: this file was generated by pulumi-language-python. ***
# *** Do not edit by hand unless you're certain you know what you are doing! ***

import builtins as _builtins
import warnings
import sys
import pulumi
import pulumi.runtime
from typing import Any, Mapping, Optional, Sequence, Union, overload
if sys.version_info >= (3, 11):
    from typing import NotRequired, TypedDict, TypeAlias
else:
    from typing_extensions import NotRequired, TypedDict, TypeAlias
from .. import _utilities

__all__ = [
    'AddonsConfigAddonsConfigArgs',
    'AddonsConfigAddonsConfigArgsDict',
    'AddonsConfigAddonsConfigAdvancedApiOpsConfigArgs',
    'AddonsConfigAddonsConfigAdvancedApiOpsConfigArgsDict',
    'AddonsConfigAddonsConfigApiSecurityConfigArgs',
    'AddonsConfigAddonsConfigApiSecurityConfigArgsDict',
    'AddonsConfigAddonsConfigConnectorsPlatformConfigArgs',
    'AddonsConfigAddonsConfigConnectorsPlatformConfigArgsDict',
    'AddonsConfigAddonsConfigIntegrationConfigArgs',
    'AddonsConfigAddonsConfigIntegrationConfigArgsDict',
    'AddonsConfigAddonsConfigMonetizationConfigArgs',
    'AddonsConfigAddonsConfigMonetizationConfigArgsDict',
    'ApiMetaDataArgs',
    'ApiMetaDataArgsDict',
    'ApiProductAttributeArgs',
    'ApiProductAttributeArgsDict',
    'ApiProductGraphqlOperationGroupArgs',
    'ApiProductGraphqlOperationGroupArgsDict',
    'ApiProductGraphqlOperationGroupOperationConfigArgs',
    'ApiProductGraphqlOperationGroupOperationConfigArgsDict',
    'ApiProductGraphqlOperationGroupOperationConfigAttributeArgs',
    'ApiProductGraphqlOperationGroupOperationConfigAttributeArgsDict',
    'ApiProductGraphqlOperationGroupOperationConfigOperationArgs',
    'ApiProductGraphqlOperationGroupOperationConfigOperationArgsDict',
    'ApiProductGraphqlOperationGroupOperationConfigQuotaArgs',
    'ApiProductGraphqlOperationGroupOperationConfigQuotaArgsDict',
    'ApiProductGrpcOperationGroupArgs',
    'ApiProductGrpcOperationGroupArgsDict',
    'ApiProductGrpcOperationGroupOperationConfigArgs',
    'ApiProductGrpcOperationGroupOperationConfigArgsDict',
    'ApiProductGrpcOperationGroupOperationConfigAttributeArgs',
    'ApiProductGrpcOperationGroupOperationConfigAttributeArgsDict',
    'ApiProductGrpcOperationGroupOperationConfigQuotaArgs',
    'ApiProductGrpcOperationGroupOperationConfigQuotaArgsDict',
    'ApiProductOperationGroupArgs',
    'ApiProductOperationGroupArgsDict',
    'ApiProductOperationGroupOperationConfigArgs',
    'ApiProductOperationGroupOperationConfigArgsDict',
    'ApiProductOperationGroupOperationConfigAttributeArgs',
    'ApiProductOperationGroupOperationConfigAttributeArgsDict',
    'ApiProductOperationGroupOperationConfigOperationArgs',
    'ApiProductOperationGroupOperationConfigOperationArgsDict',
    'ApiProductOperationGroupOperationConfigQuotaArgs',
    'ApiProductOperationGroupOperationConfigQuotaArgsDict',
    'AppGroupAttributeArgs',
    'AppGroupAttributeArgsDict',
    'DeveloperAppAttributeArgs',
    'DeveloperAppAttributeArgsDict',
    'DeveloperAppCredentialArgs',
    'DeveloperAppCredentialArgsDict',
    'DeveloperAppCredentialApiProductArgs',
    'DeveloperAppCredentialApiProductArgsDict',
    'DeveloperAppCredentialAttributeArgs',
    'DeveloperAppCredentialAttributeArgsDict',
    'DeveloperAttributeArgs',
    'DeveloperAttributeArgsDict',
    'DnsZonePeeringConfigArgs',
    'DnsZonePeeringConfigArgsDict',
    'EnvironmentClientIpResolutionConfigArgs',
    'EnvironmentClientIpResolutionConfigArgsDict',
    'EnvironmentClientIpResolutionConfigHeaderIndexAlgorithmArgs',
    'EnvironmentClientIpResolutionConfigHeaderIndexAlgorithmArgsDict',
    'EnvironmentIamBindingConditionArgs',
    'EnvironmentIamBindingConditionArgsDict',
    'EnvironmentIamMemberConditionArgs',
    'EnvironmentIamMemberConditionArgsDict',
    'EnvironmentNodeConfigArgs',
    'EnvironmentNodeConfigArgsDict',
    'EnvironmentPropertiesArgs',
    'EnvironmentPropertiesArgsDict',
    'EnvironmentPropertiesPropertyArgs',
    'EnvironmentPropertiesPropertyArgsDict',
    'InstanceAccessLoggingConfigArgs',
    'InstanceAccessLoggingConfigArgsDict',
    'KeystoresAliasesKeyCertFileCertsInfoArgs',
    'KeystoresAliasesKeyCertFileCertsInfoArgsDict',
    'KeystoresAliasesKeyCertFileTimeoutsArgs',
    'KeystoresAliasesKeyCertFileTimeoutsArgsDict',
    'KeystoresAliasesPkcs12CertsInfoArgs',
    'KeystoresAliasesPkcs12CertsInfoArgsDict',
    'KeystoresAliasesPkcs12CertsInfoCertInfoArgs',
    'KeystoresAliasesPkcs12CertsInfoCertInfoArgsDict',
    'KeystoresAliasesSelfSignedCertCertsInfoArgs',
    'KeystoresAliasesSelfSignedCertCertsInfoArgsDict',
    'KeystoresAliasesSelfSignedCertCertsInfoCertInfoArgs',
    'KeystoresAliasesSelfSignedCertCertsInfoCertInfoArgsDict',
    'KeystoresAliasesSelfSignedCertSubjectArgs',
    'KeystoresAliasesSelfSignedCertSubjectArgsDict',
    'KeystoresAliasesSelfSignedCertSubjectAlternativeDnsNamesArgs',
    'KeystoresAliasesSelfSignedCertSubjectAlternativeDnsNamesArgsDict',
    'OrganizationPropertiesArgs',
    'OrganizationPropertiesArgsDict',
    'OrganizationPropertiesPropertyArgs',
    'OrganizationPropertiesPropertyArgsDict',
    'SecurityActionAllowArgs',
    'SecurityActionAllowArgsDict',
    'SecurityActionConditionConfigArgs',
    'SecurityActionConditionConfigArgsDict',
    'SecurityActionDenyArgs',
    'SecurityActionDenyArgsDict',
    'SecurityActionFlagArgs',
    'SecurityActionFlagArgsDict',
    'SecurityActionFlagHeaderArgs',
    'SecurityActionFlagHeaderArgsDict',
    'SecurityMonitoringConditionIncludeAllResourcesArgs',
    'SecurityMonitoringConditionIncludeAllResourcesArgsDict',
    'SecurityProfileV2ProfileAssessmentConfigArgs',
    'SecurityProfileV2ProfileAssessmentConfigArgsDict',
    'SharedflowMetaDataArgs',
    'SharedflowMetaDataArgsDict',
    'TargetServerSSlInfoArgs',
    'TargetServerSSlInfoArgsDict',
    'TargetServerSSlInfoCommonNameArgs',
    'TargetServerSSlInfoCommonNameArgsDict',
]

MYPY = False

if not MYPY:
    class AddonsConfigAddonsConfigArgsDict(TypedDict):
        advanced_api_ops_config: NotRequired[pulumi.Input['AddonsConfigAddonsConfigAdvancedApiOpsConfigArgsDict']]
        """
        Configuration for the Advanced API Ops add-on.
        Structure is documented below.
        """
        api_security_config: NotRequired[pulumi.Input['AddonsConfigAddonsConfigApiSecurityConfigArgsDict']]
        """
        Configuration for the API Security add-on.
        Structure is documented below.
        """
        connectors_platform_config: NotRequired[pulumi.Input['AddonsConfigAddonsConfigConnectorsPlatformConfigArgsDict']]
        """
        Configuration for the Monetization add-on.
        Structure is documented below.
        """
        integration_config: NotRequired[pulumi.Input['AddonsConfigAddonsConfigIntegrationConfigArgsDict']]
        """
        Configuration for the Integration add-on.
        Structure is documented below.
        """
        monetization_config: NotRequired[pulumi.Input['AddonsConfigAddonsConfigMonetizationConfigArgsDict']]
        """
        Configuration for the Monetization add-on.
        Structure is documented below.
        """
elif False:
    AddonsConfigAddonsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddonsConfigAddonsConfigArgs:
    def __init__(__self__, *,
                 advanced_api_ops_config: Optional[pulumi.Input['AddonsConfigAddonsConfigAdvancedApiOpsConfigArgs']] = None,
                 api_security_config: Optional[pulumi.Input['AddonsConfigAddonsConfigApiSecurityConfigArgs']] = None,
                 connectors_platform_config: Optional[pulumi.Input['AddonsConfigAddonsConfigConnectorsPlatformConfigArgs']] = None,
                 integration_config: Optional[pulumi.Input['AddonsConfigAddonsConfigIntegrationConfigArgs']] = None,
                 monetization_config: Optional[pulumi.Input['AddonsConfigAddonsConfigMonetizationConfigArgs']] = None):
        """
        :param pulumi.Input['AddonsConfigAddonsConfigAdvancedApiOpsConfigArgs'] advanced_api_ops_config: Configuration for the Advanced API Ops add-on.
               Structure is documented below.
        :param pulumi.Input['AddonsConfigAddonsConfigApiSecurityConfigArgs'] api_security_config: Configuration for the API Security add-on.
               Structure is documented below.
        :param pulumi.Input['AddonsConfigAddonsConfigConnectorsPlatformConfigArgs'] connectors_platform_config: Configuration for the Monetization add-on.
               Structure is documented below.
        :param pulumi.Input['AddonsConfigAddonsConfigIntegrationConfigArgs'] integration_config: Configuration for the Integration add-on.
               Structure is documented below.
        :param pulumi.Input['AddonsConfigAddonsConfigMonetizationConfigArgs'] monetization_config: Configuration for the Monetization add-on.
               Structure is documented below.
        """
        if advanced_api_ops_config is not None:
            pulumi.set(__self__, "advanced_api_ops_config", advanced_api_ops_config)
        if api_security_config is not None:
            pulumi.set(__self__, "api_security_config", api_security_config)
        if connectors_platform_config is not None:
            pulumi.set(__self__, "connectors_platform_config", connectors_platform_config)
        if integration_config is not None:
            pulumi.set(__self__, "integration_config", integration_config)
        if monetization_config is not None:
            pulumi.set(__self__, "monetization_config", monetization_config)

    @_builtins.property
    @pulumi.getter(name="advancedApiOpsConfig")
    def advanced_api_ops_config(self) -> Optional[pulumi.Input['AddonsConfigAddonsConfigAdvancedApiOpsConfigArgs']]:
        """
        Configuration for the Advanced API Ops add-on.
        Structure is documented below.
        """
        return pulumi.get(self, "advanced_api_ops_config")

    @advanced_api_ops_config.setter
    def advanced_api_ops_config(self, value: Optional[pulumi.Input['AddonsConfigAddonsConfigAdvancedApiOpsConfigArgs']]):
        pulumi.set(self, "advanced_api_ops_config", value)

    @_builtins.property
    @pulumi.getter(name="apiSecurityConfig")
    def api_security_config(self) -> Optional[pulumi.Input['AddonsConfigAddonsConfigApiSecurityConfigArgs']]:
        """
        Configuration for the API Security add-on.
        Structure is documented below.
        """
        return pulumi.get(self, "api_security_config")

    @api_security_config.setter
    def api_security_config(self, value: Optional[pulumi.Input['AddonsConfigAddonsConfigApiSecurityConfigArgs']]):
        pulumi.set(self, "api_security_config", value)

    @_builtins.property
    @pulumi.getter(name="connectorsPlatformConfig")
    def connectors_platform_config(self) -> Optional[pulumi.Input['AddonsConfigAddonsConfigConnectorsPlatformConfigArgs']]:
        """
        Configuration for the Monetization add-on.
        Structure is documented below.
        """
        return pulumi.get(self, "connectors_platform_config")

    @connectors_platform_config.setter
    def connectors_platform_config(self, value: Optional[pulumi.Input['AddonsConfigAddonsConfigConnectorsPlatformConfigArgs']]):
        pulumi.set(self, "connectors_platform_config", value)

    @_builtins.property
    @pulumi.getter(name="integrationConfig")
    def integration_config(self) -> Optional[pulumi.Input['AddonsConfigAddonsConfigIntegrationConfigArgs']]:
        """
        Configuration for the Integration add-on.
        Structure is documented below.
        """
        return pulumi.get(self, "integration_config")

    @integration_config.setter
    def integration_config(self, value: Optional[pulumi.Input['AddonsConfigAddonsConfigIntegrationConfigArgs']]):
        pulumi.set(self, "integration_config", value)

    @_builtins.property
    @pulumi.getter(name="monetizationConfig")
    def monetization_config(self) -> Optional[pulumi.Input['AddonsConfigAddonsConfigMonetizationConfigArgs']]:
        """
        Configuration for the Monetization add-on.
        Structure is documented below.
        """
        return pulumi.get(self, "monetization_config")

    @monetization_config.setter
    def monetization_config(self, value: Optional[pulumi.Input['AddonsConfigAddonsConfigMonetizationConfigArgs']]):
        pulumi.set(self, "monetization_config", value)


if not MYPY:
    class AddonsConfigAddonsConfigAdvancedApiOpsConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Flag that specifies whether the Advanced API Ops add-on is enabled.
        """
elif False:
    AddonsConfigAddonsConfigAdvancedApiOpsConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddonsConfigAddonsConfigAdvancedApiOpsConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Flag that specifies whether the Advanced API Ops add-on is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Flag that specifies whether the Advanced API Ops add-on is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class AddonsConfigAddonsConfigApiSecurityConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Flag that specifies whether the API security add-on is enabled.
        """
        expires_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Time at which the API Security add-on expires in in milliseconds since epoch. If unspecified, the add-on will never expire.
        """
elif False:
    AddonsConfigAddonsConfigApiSecurityConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddonsConfigAddonsConfigApiSecurityConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 expires_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Flag that specifies whether the API security add-on is enabled.
        :param pulumi.Input[_builtins.str] expires_at: (Output)
               Time at which the API Security add-on expires in in milliseconds since epoch. If unspecified, the add-on will never expire.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Flag that specifies whether the API security add-on is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Time at which the API Security add-on expires in in milliseconds since epoch. If unspecified, the add-on will never expire.
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expires_at", value)


if not MYPY:
    class AddonsConfigAddonsConfigConnectorsPlatformConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Flag that specifies whether the Connectors Platform add-on is enabled.
        """
        expires_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Time at which the Connectors Platform add-on expires in milliseconds since epoch. If unspecified, the add-on will never expire.
        """
elif False:
    AddonsConfigAddonsConfigConnectorsPlatformConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddonsConfigAddonsConfigConnectorsPlatformConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 expires_at: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Flag that specifies whether the Connectors Platform add-on is enabled.
        :param pulumi.Input[_builtins.str] expires_at: (Output)
               Time at which the Connectors Platform add-on expires in milliseconds since epoch. If unspecified, the add-on will never expire.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Flag that specifies whether the Connectors Platform add-on is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Time at which the Connectors Platform add-on expires in milliseconds since epoch. If unspecified, the add-on will never expire.
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expires_at", value)


if not MYPY:
    class AddonsConfigAddonsConfigIntegrationConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Flag that specifies whether the Integration add-on is enabled.
        """
elif False:
    AddonsConfigAddonsConfigIntegrationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddonsConfigAddonsConfigIntegrationConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Flag that specifies whether the Integration add-on is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Flag that specifies whether the Integration add-on is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class AddonsConfigAddonsConfigMonetizationConfigArgsDict(TypedDict):
        enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Flag that specifies whether the Monetization add-on is enabled.
        """
elif False:
    AddonsConfigAddonsConfigMonetizationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AddonsConfigAddonsConfigMonetizationConfigArgs:
    def __init__(__self__, *,
                 enabled: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Flag that specifies whether the Monetization add-on is enabled.
        """
        if enabled is not None:
            pulumi.set(__self__, "enabled", enabled)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Flag that specifies whether the Monetization add-on is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enabled", value)


if not MYPY:
    class ApiMetaDataArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time at which the API proxy was created, in milliseconds since epoch.
        """
        last_modified_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time at which the API proxy was most recently modified, in milliseconds since epoch.
        """
        sub_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of entity described
        """
elif False:
    ApiMetaDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiMetaDataArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 last_modified_at: Optional[pulumi.Input[_builtins.str]] = None,
                 sub_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: Time at which the API proxy was created, in milliseconds since epoch.
        :param pulumi.Input[_builtins.str] last_modified_at: Time at which the API proxy was most recently modified, in milliseconds since epoch.
        :param pulumi.Input[_builtins.str] sub_type: The type of entity described
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if sub_type is not None:
            pulumi.set(__self__, "sub_type", sub_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time at which the API proxy was created, in milliseconds since epoch.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time at which the API proxy was most recently modified, in milliseconds since epoch.
        """
        return pulumi.get(self, "last_modified_at")

    @last_modified_at.setter
    def last_modified_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_modified_at", value)

    @_builtins.property
    @pulumi.getter(name="subType")
    def sub_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of entity described
        """
        return pulumi.get(self, "sub_type")

    @sub_type.setter
    def sub_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sub_type", value)


if not MYPY:
    class ApiProductAttributeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key of the attribute.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the attribute.
        """
elif False:
    ApiProductAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiProductAttributeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Key of the attribute.
        :param pulumi.Input[_builtins.str] value: Value of the attribute.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key of the attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the attribute.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ApiProductGraphqlOperationGroupArgsDict(TypedDict):
        operation_config_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Flag that specifes whether the configuration is for Apigee API proxy or a remote service. Valid values include proxy or remoteservice. Defaults to proxy. Set to proxy when Apigee API proxies are associated with the API product. Set to remoteservice when non-Apigee proxies like Istio-Envoy are associated with the API product.
        Possible values are: `proxy`, `remoteservice`.
        """
        operation_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigArgsDict']]]]
        """
        List of graphQL operation configuration details associated with Apigee API proxies or remote services. Remote services are non-Apigee proxies, such as Istio-Envoy.
        Structure is documented below.
        """
elif False:
    ApiProductGraphqlOperationGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiProductGraphqlOperationGroupArgs:
    def __init__(__self__, *,
                 operation_config_type: Optional[pulumi.Input[_builtins.str]] = None,
                 operation_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] operation_config_type: Flag that specifes whether the configuration is for Apigee API proxy or a remote service. Valid values include proxy or remoteservice. Defaults to proxy. Set to proxy when Apigee API proxies are associated with the API product. Set to remoteservice when non-Apigee proxies like Istio-Envoy are associated with the API product.
               Possible values are: `proxy`, `remoteservice`.
        :param pulumi.Input[Sequence[pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigArgs']]] operation_configs: List of graphQL operation configuration details associated with Apigee API proxies or remote services. Remote services are non-Apigee proxies, such as Istio-Envoy.
               Structure is documented below.
        """
        if operation_config_type is not None:
            pulumi.set(__self__, "operation_config_type", operation_config_type)
        if operation_configs is not None:
            pulumi.set(__self__, "operation_configs", operation_configs)

    @_builtins.property
    @pulumi.getter(name="operationConfigType")
    def operation_config_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Flag that specifes whether the configuration is for Apigee API proxy or a remote service. Valid values include proxy or remoteservice. Defaults to proxy. Set to proxy when Apigee API proxies are associated with the API product. Set to remoteservice when non-Apigee proxies like Istio-Envoy are associated with the API product.
        Possible values are: `proxy`, `remoteservice`.
        """
        return pulumi.get(self, "operation_config_type")

    @operation_config_type.setter
    def operation_config_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operation_config_type", value)

    @_builtins.property
    @pulumi.getter(name="operationConfigs")
    def operation_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigArgs']]]]:
        """
        List of graphQL operation configuration details associated with Apigee API proxies or remote services. Remote services are non-Apigee proxies, such as Istio-Envoy.
        Structure is documented below.
        """
        return pulumi.get(self, "operation_configs")

    @operation_configs.setter
    def operation_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigArgs']]]]):
        pulumi.set(self, "operation_configs", value)


if not MYPY:
    class ApiProductGraphqlOperationGroupOperationConfigArgsDict(TypedDict):
        api_source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Required. Name of the API proxy with which the gRPC operation and quota are associated.
        """
        attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigAttributeArgsDict']]]]
        """
        Custom attributes associated with the operation.
        Structure is documented below.
        """
        operations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigOperationArgsDict']]]]
        """
        Required. List of GraphQL name/operation type pairs for the proxy or remote service to which quota will be applied. If only operation types are specified, the quota will be applied to all GraphQL requests irrespective of the GraphQL name.
        Note: Currently, you can specify only a single GraphQLOperation. Specifying more than one will cause the operation to fail.
        Structure is documented below.
        """
        quota: NotRequired[pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigQuotaArgsDict']]
        """
        Quota parameters to be enforced for the resources, methods, and API source combination. If none are specified, quota enforcement will not be done.
        Structure is documented below.
        """
elif False:
    ApiProductGraphqlOperationGroupOperationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiProductGraphqlOperationGroupOperationConfigArgs:
    def __init__(__self__, *,
                 api_source: Optional[pulumi.Input[_builtins.str]] = None,
                 attributes: Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigAttributeArgs']]]] = None,
                 operations: Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigOperationArgs']]]] = None,
                 quota: Optional[pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigQuotaArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] api_source: Required. Name of the API proxy with which the gRPC operation and quota are associated.
        :param pulumi.Input[Sequence[pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigAttributeArgs']]] attributes: Custom attributes associated with the operation.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigOperationArgs']]] operations: Required. List of GraphQL name/operation type pairs for the proxy or remote service to which quota will be applied. If only operation types are specified, the quota will be applied to all GraphQL requests irrespective of the GraphQL name.
               Note: Currently, you can specify only a single GraphQLOperation. Specifying more than one will cause the operation to fail.
               Structure is documented below.
        :param pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigQuotaArgs'] quota: Quota parameters to be enforced for the resources, methods, and API source combination. If none are specified, quota enforcement will not be done.
               Structure is documented below.
        """
        if api_source is not None:
            pulumi.set(__self__, "api_source", api_source)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if operations is not None:
            pulumi.set(__self__, "operations", operations)
        if quota is not None:
            pulumi.set(__self__, "quota", quota)

    @_builtins.property
    @pulumi.getter(name="apiSource")
    def api_source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Required. Name of the API proxy with which the gRPC operation and quota are associated.
        """
        return pulumi.get(self, "api_source")

    @api_source.setter
    def api_source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_source", value)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigAttributeArgs']]]]:
        """
        Custom attributes associated with the operation.
        Structure is documented below.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigAttributeArgs']]]]):
        pulumi.set(self, "attributes", value)

    @_builtins.property
    @pulumi.getter
    def operations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigOperationArgs']]]]:
        """
        Required. List of GraphQL name/operation type pairs for the proxy or remote service to which quota will be applied. If only operation types are specified, the quota will be applied to all GraphQL requests irrespective of the GraphQL name.
        Note: Currently, you can specify only a single GraphQLOperation. Specifying more than one will cause the operation to fail.
        Structure is documented below.
        """
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigOperationArgs']]]]):
        pulumi.set(self, "operations", value)

    @_builtins.property
    @pulumi.getter
    def quota(self) -> Optional[pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigQuotaArgs']]:
        """
        Quota parameters to be enforced for the resources, methods, and API source combination. If none are specified, quota enforcement will not be done.
        Structure is documented below.
        """
        return pulumi.get(self, "quota")

    @quota.setter
    def quota(self, value: Optional[pulumi.Input['ApiProductGraphqlOperationGroupOperationConfigQuotaArgs']]):
        pulumi.set(self, "quota", value)


if not MYPY:
    class ApiProductGraphqlOperationGroupOperationConfigAttributeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key of the attribute.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the attribute.
        """
elif False:
    ApiProductGraphqlOperationGroupOperationConfigAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiProductGraphqlOperationGroupOperationConfigAttributeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Key of the attribute.
        :param pulumi.Input[_builtins.str] value: Value of the attribute.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key of the attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the attribute.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ApiProductGraphqlOperationGroupOperationConfigOperationArgsDict(TypedDict):
        operation: NotRequired[pulumi.Input[_builtins.str]]
        """
        GraphQL operation name. The name and operation type will be used to apply quotas. If no name is specified, the quota will be applied to all GraphQL operations irrespective of their operation names in the payload.
        """
        operation_types: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Required. GraphQL operation types. Valid values include query or mutation.
        Note: Apigee does not currently support subscription types.
        """
elif False:
    ApiProductGraphqlOperationGroupOperationConfigOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiProductGraphqlOperationGroupOperationConfigOperationArgs:
    def __init__(__self__, *,
                 operation: Optional[pulumi.Input[_builtins.str]] = None,
                 operation_types: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[_builtins.str] operation: GraphQL operation name. The name and operation type will be used to apply quotas. If no name is specified, the quota will be applied to all GraphQL operations irrespective of their operation names in the payload.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] operation_types: Required. GraphQL operation types. Valid values include query or mutation.
               Note: Apigee does not currently support subscription types.
        """
        if operation is not None:
            pulumi.set(__self__, "operation", operation)
        if operation_types is not None:
            pulumi.set(__self__, "operation_types", operation_types)

    @_builtins.property
    @pulumi.getter
    def operation(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        GraphQL operation name. The name and operation type will be used to apply quotas. If no name is specified, the quota will be applied to all GraphQL operations irrespective of their operation names in the payload.
        """
        return pulumi.get(self, "operation")

    @operation.setter
    def operation(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operation", value)

    @_builtins.property
    @pulumi.getter(name="operationTypes")
    def operation_types(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Required. GraphQL operation types. Valid values include query or mutation.
        Note: Apigee does not currently support subscription types.
        """
        return pulumi.get(self, "operation_types")

    @operation_types.setter
    def operation_types(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "operation_types", value)


if not MYPY:
    class ApiProductGraphqlOperationGroupOperationConfigQuotaArgsDict(TypedDict):
        interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Required. Time interval over which the number of request messages is calculated.
        """
        limit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Required. Upper limit allowed for the time interval and time unit specified. Requests exceeding this limit will be rejected.
        """
        time_unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time unit defined for the interval. Valid values include second, minute, hour, day, month or year. If limit and interval are valid, the default value is hour; otherwise, the default is null.
        """
elif False:
    ApiProductGraphqlOperationGroupOperationConfigQuotaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiProductGraphqlOperationGroupOperationConfigQuotaArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[_builtins.str]] = None,
                 limit: Optional[pulumi.Input[_builtins.str]] = None,
                 time_unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] interval: Required. Time interval over which the number of request messages is calculated.
        :param pulumi.Input[_builtins.str] limit: Required. Upper limit allowed for the time interval and time unit specified. Requests exceeding this limit will be rejected.
        :param pulumi.Input[_builtins.str] time_unit: Time unit defined for the interval. Valid values include second, minute, hour, day, month or year. If limit and interval are valid, the default value is hour; otherwise, the default is null.
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if time_unit is not None:
            pulumi.set(__self__, "time_unit", time_unit)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Required. Time interval over which the number of request messages is calculated.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Required. Upper limit allowed for the time interval and time unit specified. Requests exceeding this limit will be rejected.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time unit defined for the interval. Valid values include second, minute, hour, day, month or year. If limit and interval are valid, the default value is hour; otherwise, the default is null.
        """
        return pulumi.get(self, "time_unit")

    @time_unit.setter
    def time_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_unit", value)


if not MYPY:
    class ApiProductGrpcOperationGroupArgsDict(TypedDict):
        operation_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApiProductGrpcOperationGroupOperationConfigArgsDict']]]]
        """
        Required. List of operation configurations for either Apigee API proxies that are associated with this API product.
        Structure is documented below.
        """
elif False:
    ApiProductGrpcOperationGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiProductGrpcOperationGroupArgs:
    def __init__(__self__, *,
                 operation_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductGrpcOperationGroupOperationConfigArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['ApiProductGrpcOperationGroupOperationConfigArgs']]] operation_configs: Required. List of operation configurations for either Apigee API proxies that are associated with this API product.
               Structure is documented below.
        """
        if operation_configs is not None:
            pulumi.set(__self__, "operation_configs", operation_configs)

    @_builtins.property
    @pulumi.getter(name="operationConfigs")
    def operation_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductGrpcOperationGroupOperationConfigArgs']]]]:
        """
        Required. List of operation configurations for either Apigee API proxies that are associated with this API product.
        Structure is documented below.
        """
        return pulumi.get(self, "operation_configs")

    @operation_configs.setter
    def operation_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductGrpcOperationGroupOperationConfigArgs']]]]):
        pulumi.set(self, "operation_configs", value)


if not MYPY:
    class ApiProductGrpcOperationGroupOperationConfigArgsDict(TypedDict):
        api_source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Required. Name of the API proxy with which the gRPC operation and quota are associated.
        """
        attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApiProductGrpcOperationGroupOperationConfigAttributeArgsDict']]]]
        """
        Custom attributes associated with the operation.
        Structure is documented below.
        """
        methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        List of unqualified gRPC method names for the proxy to which quota will be applied. If this field is empty, the Quota will apply to all operations on the gRPC service defined on the proxy.
        Example: Given a proxy that is configured to serve com.petstore.PetService, the methods com.petstore.PetService.ListPets and com.petstore.PetService.GetPet would be specified here as simply ["ListPets", "GetPet"].
        Note: Currently, you can specify only a single GraphQLOperation. Specifying more than one will cause the operation to fail.
        """
        quota: NotRequired[pulumi.Input['ApiProductGrpcOperationGroupOperationConfigQuotaArgsDict']]
        """
        Quota parameters to be enforced for the resources, methods, and API source combination. If none are specified, quota enforcement will not be done.
        Structure is documented below.
        """
        service: NotRequired[pulumi.Input[_builtins.str]]
        """
        Required. gRPC Service name associated to be associated with the API proxy, on which quota rules can be applied upon.
        """
elif False:
    ApiProductGrpcOperationGroupOperationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiProductGrpcOperationGroupOperationConfigArgs:
    def __init__(__self__, *,
                 api_source: Optional[pulumi.Input[_builtins.str]] = None,
                 attributes: Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductGrpcOperationGroupOperationConfigAttributeArgs']]]] = None,
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 quota: Optional[pulumi.Input['ApiProductGrpcOperationGroupOperationConfigQuotaArgs']] = None,
                 service: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] api_source: Required. Name of the API proxy with which the gRPC operation and quota are associated.
        :param pulumi.Input[Sequence[pulumi.Input['ApiProductGrpcOperationGroupOperationConfigAttributeArgs']]] attributes: Custom attributes associated with the operation.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] methods: List of unqualified gRPC method names for the proxy to which quota will be applied. If this field is empty, the Quota will apply to all operations on the gRPC service defined on the proxy.
               Example: Given a proxy that is configured to serve com.petstore.PetService, the methods com.petstore.PetService.ListPets and com.petstore.PetService.GetPet would be specified here as simply ["ListPets", "GetPet"].
               Note: Currently, you can specify only a single GraphQLOperation. Specifying more than one will cause the operation to fail.
        :param pulumi.Input['ApiProductGrpcOperationGroupOperationConfigQuotaArgs'] quota: Quota parameters to be enforced for the resources, methods, and API source combination. If none are specified, quota enforcement will not be done.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] service: Required. gRPC Service name associated to be associated with the API proxy, on which quota rules can be applied upon.
        """
        if api_source is not None:
            pulumi.set(__self__, "api_source", api_source)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if quota is not None:
            pulumi.set(__self__, "quota", quota)
        if service is not None:
            pulumi.set(__self__, "service", service)

    @_builtins.property
    @pulumi.getter(name="apiSource")
    def api_source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Required. Name of the API proxy with which the gRPC operation and quota are associated.
        """
        return pulumi.get(self, "api_source")

    @api_source.setter
    def api_source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_source", value)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductGrpcOperationGroupOperationConfigAttributeArgs']]]]:
        """
        Custom attributes associated with the operation.
        Structure is documented below.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductGrpcOperationGroupOperationConfigAttributeArgs']]]]):
        pulumi.set(self, "attributes", value)

    @_builtins.property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        List of unqualified gRPC method names for the proxy to which quota will be applied. If this field is empty, the Quota will apply to all operations on the gRPC service defined on the proxy.
        Example: Given a proxy that is configured to serve com.petstore.PetService, the methods com.petstore.PetService.ListPets and com.petstore.PetService.GetPet would be specified here as simply ["ListPets", "GetPet"].
        Note: Currently, you can specify only a single GraphQLOperation. Specifying more than one will cause the operation to fail.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "methods", value)

    @_builtins.property
    @pulumi.getter
    def quota(self) -> Optional[pulumi.Input['ApiProductGrpcOperationGroupOperationConfigQuotaArgs']]:
        """
        Quota parameters to be enforced for the resources, methods, and API source combination. If none are specified, quota enforcement will not be done.
        Structure is documented below.
        """
        return pulumi.get(self, "quota")

    @quota.setter
    def quota(self, value: Optional[pulumi.Input['ApiProductGrpcOperationGroupOperationConfigQuotaArgs']]):
        pulumi.set(self, "quota", value)

    @_builtins.property
    @pulumi.getter
    def service(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Required. gRPC Service name associated to be associated with the API proxy, on which quota rules can be applied upon.
        """
        return pulumi.get(self, "service")

    @service.setter
    def service(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "service", value)


if not MYPY:
    class ApiProductGrpcOperationGroupOperationConfigAttributeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key of the attribute.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the attribute.
        """
elif False:
    ApiProductGrpcOperationGroupOperationConfigAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiProductGrpcOperationGroupOperationConfigAttributeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Key of the attribute.
        :param pulumi.Input[_builtins.str] value: Value of the attribute.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key of the attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the attribute.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ApiProductGrpcOperationGroupOperationConfigQuotaArgsDict(TypedDict):
        interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Required. Time interval over which the number of request messages is calculated.
        """
        limit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Required. Upper limit allowed for the time interval and time unit specified. Requests exceeding this limit will be rejected.
        """
        time_unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time unit defined for the interval. Valid values include second, minute, hour, day, month or year. If limit and interval are valid, the default value is hour; otherwise, the default is null.
        """
elif False:
    ApiProductGrpcOperationGroupOperationConfigQuotaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiProductGrpcOperationGroupOperationConfigQuotaArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[_builtins.str]] = None,
                 limit: Optional[pulumi.Input[_builtins.str]] = None,
                 time_unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] interval: Required. Time interval over which the number of request messages is calculated.
        :param pulumi.Input[_builtins.str] limit: Required. Upper limit allowed for the time interval and time unit specified. Requests exceeding this limit will be rejected.
        :param pulumi.Input[_builtins.str] time_unit: Time unit defined for the interval. Valid values include second, minute, hour, day, month or year. If limit and interval are valid, the default value is hour; otherwise, the default is null.
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if time_unit is not None:
            pulumi.set(__self__, "time_unit", time_unit)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Required. Time interval over which the number of request messages is calculated.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Required. Upper limit allowed for the time interval and time unit specified. Requests exceeding this limit will be rejected.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time unit defined for the interval. Valid values include second, minute, hour, day, month or year. If limit and interval are valid, the default value is hour; otherwise, the default is null.
        """
        return pulumi.get(self, "time_unit")

    @time_unit.setter
    def time_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_unit", value)


if not MYPY:
    class ApiProductOperationGroupArgsDict(TypedDict):
        operation_config_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        Flag that specifes whether the configuration is for Apigee API proxy or a remote service. Valid values include proxy or remoteservice. Defaults to proxy. Set to proxy when Apigee API proxies are associated with the API product. Set to remoteservice when non-Apigee proxies like Istio-Envoy are associated with the API product.
        Possible values are: `proxy`, `remoteservice`.
        """
        operation_configs: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApiProductOperationGroupOperationConfigArgsDict']]]]
        """
        Required. List of operation configurations for either Apigee API proxies or other remote services that are associated with this API product.
        Structure is documented below.
        """
elif False:
    ApiProductOperationGroupArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiProductOperationGroupArgs:
    def __init__(__self__, *,
                 operation_config_type: Optional[pulumi.Input[_builtins.str]] = None,
                 operation_configs: Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductOperationGroupOperationConfigArgs']]]] = None):
        """
        :param pulumi.Input[_builtins.str] operation_config_type: Flag that specifes whether the configuration is for Apigee API proxy or a remote service. Valid values include proxy or remoteservice. Defaults to proxy. Set to proxy when Apigee API proxies are associated with the API product. Set to remoteservice when non-Apigee proxies like Istio-Envoy are associated with the API product.
               Possible values are: `proxy`, `remoteservice`.
        :param pulumi.Input[Sequence[pulumi.Input['ApiProductOperationGroupOperationConfigArgs']]] operation_configs: Required. List of operation configurations for either Apigee API proxies or other remote services that are associated with this API product.
               Structure is documented below.
        """
        if operation_config_type is not None:
            pulumi.set(__self__, "operation_config_type", operation_config_type)
        if operation_configs is not None:
            pulumi.set(__self__, "operation_configs", operation_configs)

    @_builtins.property
    @pulumi.getter(name="operationConfigType")
    def operation_config_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Flag that specifes whether the configuration is for Apigee API proxy or a remote service. Valid values include proxy or remoteservice. Defaults to proxy. Set to proxy when Apigee API proxies are associated with the API product. Set to remoteservice when non-Apigee proxies like Istio-Envoy are associated with the API product.
        Possible values are: `proxy`, `remoteservice`.
        """
        return pulumi.get(self, "operation_config_type")

    @operation_config_type.setter
    def operation_config_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "operation_config_type", value)

    @_builtins.property
    @pulumi.getter(name="operationConfigs")
    def operation_configs(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductOperationGroupOperationConfigArgs']]]]:
        """
        Required. List of operation configurations for either Apigee API proxies or other remote services that are associated with this API product.
        Structure is documented below.
        """
        return pulumi.get(self, "operation_configs")

    @operation_configs.setter
    def operation_configs(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductOperationGroupOperationConfigArgs']]]]):
        pulumi.set(self, "operation_configs", value)


if not MYPY:
    class ApiProductOperationGroupOperationConfigArgsDict(TypedDict):
        api_source: NotRequired[pulumi.Input[_builtins.str]]
        """
        Required. Name of the API proxy with which the gRPC operation and quota are associated.
        """
        attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApiProductOperationGroupOperationConfigAttributeArgsDict']]]]
        """
        Custom attributes associated with the operation.
        Structure is documented below.
        """
        operations: NotRequired[pulumi.Input[Sequence[pulumi.Input['ApiProductOperationGroupOperationConfigOperationArgsDict']]]]
        """
        Required. List of GraphQL name/operation type pairs for the proxy or remote service to which quota will be applied. If only operation types are specified, the quota will be applied to all GraphQL requests irrespective of the GraphQL name.
        Note: Currently, you can specify only a single GraphQLOperation. Specifying more than one will cause the operation to fail.
        Structure is documented below.
        """
        quota: NotRequired[pulumi.Input['ApiProductOperationGroupOperationConfigQuotaArgsDict']]
        """
        Quota parameters to be enforced for the resources, methods, and API source combination. If none are specified, quota enforcement will not be done.
        Structure is documented below.
        """
elif False:
    ApiProductOperationGroupOperationConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiProductOperationGroupOperationConfigArgs:
    def __init__(__self__, *,
                 api_source: Optional[pulumi.Input[_builtins.str]] = None,
                 attributes: Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductOperationGroupOperationConfigAttributeArgs']]]] = None,
                 operations: Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductOperationGroupOperationConfigOperationArgs']]]] = None,
                 quota: Optional[pulumi.Input['ApiProductOperationGroupOperationConfigQuotaArgs']] = None):
        """
        :param pulumi.Input[_builtins.str] api_source: Required. Name of the API proxy with which the gRPC operation and quota are associated.
        :param pulumi.Input[Sequence[pulumi.Input['ApiProductOperationGroupOperationConfigAttributeArgs']]] attributes: Custom attributes associated with the operation.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input['ApiProductOperationGroupOperationConfigOperationArgs']]] operations: Required. List of GraphQL name/operation type pairs for the proxy or remote service to which quota will be applied. If only operation types are specified, the quota will be applied to all GraphQL requests irrespective of the GraphQL name.
               Note: Currently, you can specify only a single GraphQLOperation. Specifying more than one will cause the operation to fail.
               Structure is documented below.
        :param pulumi.Input['ApiProductOperationGroupOperationConfigQuotaArgs'] quota: Quota parameters to be enforced for the resources, methods, and API source combination. If none are specified, quota enforcement will not be done.
               Structure is documented below.
        """
        if api_source is not None:
            pulumi.set(__self__, "api_source", api_source)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if operations is not None:
            pulumi.set(__self__, "operations", operations)
        if quota is not None:
            pulumi.set(__self__, "quota", quota)

    @_builtins.property
    @pulumi.getter(name="apiSource")
    def api_source(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Required. Name of the API proxy with which the gRPC operation and quota are associated.
        """
        return pulumi.get(self, "api_source")

    @api_source.setter
    def api_source(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "api_source", value)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductOperationGroupOperationConfigAttributeArgs']]]]:
        """
        Custom attributes associated with the operation.
        Structure is documented below.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductOperationGroupOperationConfigAttributeArgs']]]]):
        pulumi.set(self, "attributes", value)

    @_builtins.property
    @pulumi.getter
    def operations(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductOperationGroupOperationConfigOperationArgs']]]]:
        """
        Required. List of GraphQL name/operation type pairs for the proxy or remote service to which quota will be applied. If only operation types are specified, the quota will be applied to all GraphQL requests irrespective of the GraphQL name.
        Note: Currently, you can specify only a single GraphQLOperation. Specifying more than one will cause the operation to fail.
        Structure is documented below.
        """
        return pulumi.get(self, "operations")

    @operations.setter
    def operations(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['ApiProductOperationGroupOperationConfigOperationArgs']]]]):
        pulumi.set(self, "operations", value)

    @_builtins.property
    @pulumi.getter
    def quota(self) -> Optional[pulumi.Input['ApiProductOperationGroupOperationConfigQuotaArgs']]:
        """
        Quota parameters to be enforced for the resources, methods, and API source combination. If none are specified, quota enforcement will not be done.
        Structure is documented below.
        """
        return pulumi.get(self, "quota")

    @quota.setter
    def quota(self, value: Optional[pulumi.Input['ApiProductOperationGroupOperationConfigQuotaArgs']]):
        pulumi.set(self, "quota", value)


if not MYPY:
    class ApiProductOperationGroupOperationConfigAttributeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key of the attribute.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the attribute.
        """
elif False:
    ApiProductOperationGroupOperationConfigAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiProductOperationGroupOperationConfigAttributeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Key of the attribute.
        :param pulumi.Input[_builtins.str] value: Value of the attribute.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key of the attribute.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the attribute.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class ApiProductOperationGroupOperationConfigOperationArgsDict(TypedDict):
        methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Methods refers to the REST verbs, when none specified, all verb types are allowed.
        """
        resource: NotRequired[pulumi.Input[_builtins.str]]
        """
        Required. REST resource path associated with the API proxy or remote service.
        """
elif False:
    ApiProductOperationGroupOperationConfigOperationArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiProductOperationGroupOperationConfigOperationArgs:
    def __init__(__self__, *,
                 methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 resource: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] methods: Methods refers to the REST verbs, when none specified, all verb types are allowed.
        :param pulumi.Input[_builtins.str] resource: Required. REST resource path associated with the API proxy or remote service.
        """
        if methods is not None:
            pulumi.set(__self__, "methods", methods)
        if resource is not None:
            pulumi.set(__self__, "resource", resource)

    @_builtins.property
    @pulumi.getter
    def methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Methods refers to the REST verbs, when none specified, all verb types are allowed.
        """
        return pulumi.get(self, "methods")

    @methods.setter
    def methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "methods", value)

    @_builtins.property
    @pulumi.getter
    def resource(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Required. REST resource path associated with the API proxy or remote service.
        """
        return pulumi.get(self, "resource")

    @resource.setter
    def resource(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "resource", value)


if not MYPY:
    class ApiProductOperationGroupOperationConfigQuotaArgsDict(TypedDict):
        interval: NotRequired[pulumi.Input[_builtins.str]]
        """
        Required. Time interval over which the number of request messages is calculated.
        """
        limit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Required. Upper limit allowed for the time interval and time unit specified. Requests exceeding this limit will be rejected.
        """
        time_unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time unit defined for the interval. Valid values include second, minute, hour, day, month or year. If limit and interval are valid, the default value is hour; otherwise, the default is null.
        """
elif False:
    ApiProductOperationGroupOperationConfigQuotaArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class ApiProductOperationGroupOperationConfigQuotaArgs:
    def __init__(__self__, *,
                 interval: Optional[pulumi.Input[_builtins.str]] = None,
                 limit: Optional[pulumi.Input[_builtins.str]] = None,
                 time_unit: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] interval: Required. Time interval over which the number of request messages is calculated.
        :param pulumi.Input[_builtins.str] limit: Required. Upper limit allowed for the time interval and time unit specified. Requests exceeding this limit will be rejected.
        :param pulumi.Input[_builtins.str] time_unit: Time unit defined for the interval. Valid values include second, minute, hour, day, month or year. If limit and interval are valid, the default value is hour; otherwise, the default is null.
        """
        if interval is not None:
            pulumi.set(__self__, "interval", interval)
        if limit is not None:
            pulumi.set(__self__, "limit", limit)
        if time_unit is not None:
            pulumi.set(__self__, "time_unit", time_unit)

    @_builtins.property
    @pulumi.getter
    def interval(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Required. Time interval over which the number of request messages is calculated.
        """
        return pulumi.get(self, "interval")

    @interval.setter
    def interval(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "interval", value)

    @_builtins.property
    @pulumi.getter
    def limit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Required. Upper limit allowed for the time interval and time unit specified. Requests exceeding this limit will be rejected.
        """
        return pulumi.get(self, "limit")

    @limit.setter
    def limit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "limit", value)

    @_builtins.property
    @pulumi.getter(name="timeUnit")
    def time_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time unit defined for the interval. Valid values include second, minute, hour, day, month or year. If limit and interval are valid, the default value is hour; otherwise, the default is null.
        """
        return pulumi.get(self, "time_unit")

    @time_unit.setter
    def time_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "time_unit", value)


if not MYPY:
    class AppGroupAttributeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key of the attribute
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the attribute
        """
elif False:
    AppGroupAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class AppGroupAttributeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Key of the attribute
        :param pulumi.Input[_builtins.str] value: Value of the attribute
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key of the attribute
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the attribute
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeveloperAppAttributeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key of the attribute
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the attribute
        """
elif False:
    DeveloperAppAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeveloperAppAttributeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Key of the attribute
        :param pulumi.Input[_builtins.str] value: Value of the attribute
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key of the attribute
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the attribute
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeveloperAppCredentialArgsDict(TypedDict):
        api_products: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeveloperAppCredentialApiProductArgsDict']]]]
        """
        List of API products associated with the developer app.
        """
        attributes: NotRequired[pulumi.Input[Sequence[pulumi.Input['DeveloperAppCredentialAttributeArgsDict']]]]
        """
        Developer attributes (name/value pairs). The custom attribute limit is 18.
        Structure is documented below.
        """
        consumer_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Consumer key.
        """
        consumer_secret: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Secret key.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        expires_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Time the credential will expire in milliseconds since epoch.
        """
        issued_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Time the credential was issued in milliseconds since epoch.
        """
        scopes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Scopes to apply to the developer app.
        The specified scopes must already exist for the API product that
        you associate with the developer app.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of the credential. Valid values include approved or revoked.
        """
elif False:
    DeveloperAppCredentialArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeveloperAppCredentialArgs:
    def __init__(__self__, *,
                 api_products: Optional[pulumi.Input[Sequence[pulumi.Input['DeveloperAppCredentialApiProductArgs']]]] = None,
                 attributes: Optional[pulumi.Input[Sequence[pulumi.Input['DeveloperAppCredentialAttributeArgs']]]] = None,
                 consumer_key: Optional[pulumi.Input[_builtins.str]] = None,
                 consumer_secret: Optional[pulumi.Input[_builtins.str]] = None,
                 expires_at: Optional[pulumi.Input[_builtins.str]] = None,
                 issued_at: Optional[pulumi.Input[_builtins.str]] = None,
                 scopes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['DeveloperAppCredentialApiProductArgs']]] api_products: List of API products associated with the developer app.
        :param pulumi.Input[Sequence[pulumi.Input['DeveloperAppCredentialAttributeArgs']]] attributes: Developer attributes (name/value pairs). The custom attribute limit is 18.
               Structure is documented below.
        :param pulumi.Input[_builtins.str] consumer_key: (Output)
               Consumer key.
        :param pulumi.Input[_builtins.str] consumer_secret: (Output)
               Secret key.
               **Note**: This property is sensitive and will not be displayed in the plan.
        :param pulumi.Input[_builtins.str] expires_at: (Output)
               Time the credential will expire in milliseconds since epoch.
        :param pulumi.Input[_builtins.str] issued_at: (Output)
               Time the credential was issued in milliseconds since epoch.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] scopes: Scopes to apply to the developer app.
               The specified scopes must already exist for the API product that
               you associate with the developer app.
        :param pulumi.Input[_builtins.str] status: Status of the credential. Valid values include approved or revoked.
        """
        if api_products is not None:
            pulumi.set(__self__, "api_products", api_products)
        if attributes is not None:
            pulumi.set(__self__, "attributes", attributes)
        if consumer_key is not None:
            pulumi.set(__self__, "consumer_key", consumer_key)
        if consumer_secret is not None:
            pulumi.set(__self__, "consumer_secret", consumer_secret)
        if expires_at is not None:
            pulumi.set(__self__, "expires_at", expires_at)
        if issued_at is not None:
            pulumi.set(__self__, "issued_at", issued_at)
        if scopes is not None:
            pulumi.set(__self__, "scopes", scopes)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter(name="apiProducts")
    def api_products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeveloperAppCredentialApiProductArgs']]]]:
        """
        List of API products associated with the developer app.
        """
        return pulumi.get(self, "api_products")

    @api_products.setter
    def api_products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeveloperAppCredentialApiProductArgs']]]]):
        pulumi.set(self, "api_products", value)

    @_builtins.property
    @pulumi.getter
    def attributes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['DeveloperAppCredentialAttributeArgs']]]]:
        """
        Developer attributes (name/value pairs). The custom attribute limit is 18.
        Structure is documented below.
        """
        return pulumi.get(self, "attributes")

    @attributes.setter
    def attributes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['DeveloperAppCredentialAttributeArgs']]]]):
        pulumi.set(self, "attributes", value)

    @_builtins.property
    @pulumi.getter(name="consumerKey")
    def consumer_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Consumer key.
        """
        return pulumi.get(self, "consumer_key")

    @consumer_key.setter
    def consumer_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_key", value)

    @_builtins.property
    @pulumi.getter(name="consumerSecret")
    def consumer_secret(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Secret key.
        **Note**: This property is sensitive and will not be displayed in the plan.
        """
        return pulumi.get(self, "consumer_secret")

    @consumer_secret.setter
    def consumer_secret(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "consumer_secret", value)

    @_builtins.property
    @pulumi.getter(name="expiresAt")
    def expires_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Time the credential will expire in milliseconds since epoch.
        """
        return pulumi.get(self, "expires_at")

    @expires_at.setter
    def expires_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expires_at", value)

    @_builtins.property
    @pulumi.getter(name="issuedAt")
    def issued_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Time the credential was issued in milliseconds since epoch.
        """
        return pulumi.get(self, "issued_at")

    @issued_at.setter
    def issued_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issued_at", value)

    @_builtins.property
    @pulumi.getter
    def scopes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Scopes to apply to the developer app.
        The specified scopes must already exist for the API product that
        you associate with the developer app.
        """
        return pulumi.get(self, "scopes")

    @scopes.setter
    def scopes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "scopes", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of the credential. Valid values include approved or revoked.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DeveloperAppCredentialApiProductArgsDict(TypedDict):
        apiproduct: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Name of the API product.
        """
        status: NotRequired[pulumi.Input[_builtins.str]]
        """
        Status of the credential. Valid values include approved or revoked.
        """
elif False:
    DeveloperAppCredentialApiProductArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeveloperAppCredentialApiProductArgs:
    def __init__(__self__, *,
                 apiproduct: Optional[pulumi.Input[_builtins.str]] = None,
                 status: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] apiproduct: (Output)
               Name of the API product.
        :param pulumi.Input[_builtins.str] status: Status of the credential. Valid values include approved or revoked.
        """
        if apiproduct is not None:
            pulumi.set(__self__, "apiproduct", apiproduct)
        if status is not None:
            pulumi.set(__self__, "status", status)

    @_builtins.property
    @pulumi.getter
    def apiproduct(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Name of the API product.
        """
        return pulumi.get(self, "apiproduct")

    @apiproduct.setter
    def apiproduct(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "apiproduct", value)

    @_builtins.property
    @pulumi.getter
    def status(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Status of the credential. Valid values include approved or revoked.
        """
        return pulumi.get(self, "status")

    @status.setter
    def status(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "status", value)


if not MYPY:
    class DeveloperAppCredentialAttributeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key of the attribute
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the attribute
        """
elif False:
    DeveloperAppCredentialAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeveloperAppCredentialAttributeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Key of the attribute
        :param pulumi.Input[_builtins.str] value: Value of the attribute
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key of the attribute
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the attribute
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DeveloperAttributeArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Key of the attribute
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the attribute
        """
elif False:
    DeveloperAttributeArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DeveloperAttributeArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Key of the attribute
        :param pulumi.Input[_builtins.str] value: Value of the attribute
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Key of the attribute
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the attribute
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class DnsZonePeeringConfigArgsDict(TypedDict):
        target_network_id: pulumi.Input[_builtins.str]
        """
        The name of the producer VPC network.
        """
        target_project_id: pulumi.Input[_builtins.str]
        """
        The ID of the project that contains the producer VPC network.
        """
elif False:
    DnsZonePeeringConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class DnsZonePeeringConfigArgs:
    def __init__(__self__, *,
                 target_network_id: pulumi.Input[_builtins.str],
                 target_project_id: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] target_network_id: The name of the producer VPC network.
        :param pulumi.Input[_builtins.str] target_project_id: The ID of the project that contains the producer VPC network.
        """
        pulumi.set(__self__, "target_network_id", target_network_id)
        pulumi.set(__self__, "target_project_id", target_project_id)

    @_builtins.property
    @pulumi.getter(name="targetNetworkId")
    def target_network_id(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the producer VPC network.
        """
        return pulumi.get(self, "target_network_id")

    @target_network_id.setter
    def target_network_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_network_id", value)

    @_builtins.property
    @pulumi.getter(name="targetProjectId")
    def target_project_id(self) -> pulumi.Input[_builtins.str]:
        """
        The ID of the project that contains the producer VPC network.
        """
        return pulumi.get(self, "target_project_id")

    @target_project_id.setter
    def target_project_id(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "target_project_id", value)


if not MYPY:
    class EnvironmentClientIpResolutionConfigArgsDict(TypedDict):
        header_index_algorithm: NotRequired[pulumi.Input['EnvironmentClientIpResolutionConfigHeaderIndexAlgorithmArgsDict']]
        """
        Resolves the client ip based on a custom header.
        Structure is documented below.
        """
elif False:
    EnvironmentClientIpResolutionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentClientIpResolutionConfigArgs:
    def __init__(__self__, *,
                 header_index_algorithm: Optional[pulumi.Input['EnvironmentClientIpResolutionConfigHeaderIndexAlgorithmArgs']] = None):
        """
        :param pulumi.Input['EnvironmentClientIpResolutionConfigHeaderIndexAlgorithmArgs'] header_index_algorithm: Resolves the client ip based on a custom header.
               Structure is documented below.
        """
        if header_index_algorithm is not None:
            pulumi.set(__self__, "header_index_algorithm", header_index_algorithm)

    @_builtins.property
    @pulumi.getter(name="headerIndexAlgorithm")
    def header_index_algorithm(self) -> Optional[pulumi.Input['EnvironmentClientIpResolutionConfigHeaderIndexAlgorithmArgs']]:
        """
        Resolves the client ip based on a custom header.
        Structure is documented below.
        """
        return pulumi.get(self, "header_index_algorithm")

    @header_index_algorithm.setter
    def header_index_algorithm(self, value: Optional[pulumi.Input['EnvironmentClientIpResolutionConfigHeaderIndexAlgorithmArgs']]):
        pulumi.set(self, "header_index_algorithm", value)


if not MYPY:
    class EnvironmentClientIpResolutionConfigHeaderIndexAlgorithmArgsDict(TypedDict):
        ip_header_index: pulumi.Input[_builtins.int]
        """
        The index of the ip in the header. Positive indices 0, 1, 2, 3 chooses indices from the left (first ips). Negative indices -1, -2, -3 chooses indices from the right (last ips).
        """
        ip_header_name: pulumi.Input[_builtins.str]
        """
        The name of the header to extract the client ip from. We are currently only supporting the X-Forwarded-For header.
        """
elif False:
    EnvironmentClientIpResolutionConfigHeaderIndexAlgorithmArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentClientIpResolutionConfigHeaderIndexAlgorithmArgs:
    def __init__(__self__, *,
                 ip_header_index: pulumi.Input[_builtins.int],
                 ip_header_name: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.int] ip_header_index: The index of the ip in the header. Positive indices 0, 1, 2, 3 chooses indices from the left (first ips). Negative indices -1, -2, -3 chooses indices from the right (last ips).
        :param pulumi.Input[_builtins.str] ip_header_name: The name of the header to extract the client ip from. We are currently only supporting the X-Forwarded-For header.
        """
        pulumi.set(__self__, "ip_header_index", ip_header_index)
        pulumi.set(__self__, "ip_header_name", ip_header_name)

    @_builtins.property
    @pulumi.getter(name="ipHeaderIndex")
    def ip_header_index(self) -> pulumi.Input[_builtins.int]:
        """
        The index of the ip in the header. Positive indices 0, 1, 2, 3 chooses indices from the left (first ips). Negative indices -1, -2, -3 chooses indices from the right (last ips).
        """
        return pulumi.get(self, "ip_header_index")

    @ip_header_index.setter
    def ip_header_index(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "ip_header_index", value)

    @_builtins.property
    @pulumi.getter(name="ipHeaderName")
    def ip_header_name(self) -> pulumi.Input[_builtins.str]:
        """
        The name of the header to extract the client ip from. We are currently only supporting the X-Forwarded-For header.
        """
        return pulumi.get(self, "ip_header_name")

    @ip_header_name.setter
    def ip_header_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "ip_header_name", value)


if not MYPY:
    class EnvironmentIamBindingConditionArgsDict(TypedDict):
        expression: pulumi.Input[_builtins.str]
        title: pulumi.Input[_builtins.str]
        description: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EnvironmentIamBindingConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentIamBindingConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 title: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class EnvironmentIamMemberConditionArgsDict(TypedDict):
        expression: pulumi.Input[_builtins.str]
        title: pulumi.Input[_builtins.str]
        description: NotRequired[pulumi.Input[_builtins.str]]
elif False:
    EnvironmentIamMemberConditionArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentIamMemberConditionArgs:
    def __init__(__self__, *,
                 expression: pulumi.Input[_builtins.str],
                 title: pulumi.Input[_builtins.str],
                 description: Optional[pulumi.Input[_builtins.str]] = None):
        pulumi.set(__self__, "expression", expression)
        pulumi.set(__self__, "title", title)
        if description is not None:
            pulumi.set(__self__, "description", description)

    @_builtins.property
    @pulumi.getter
    def expression(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "expression")

    @expression.setter
    def expression(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expression", value)

    @_builtins.property
    @pulumi.getter
    def title(self) -> pulumi.Input[_builtins.str]:
        return pulumi.get(self, "title")

    @title.setter
    def title(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "title", value)

    @_builtins.property
    @pulumi.getter
    def description(self) -> Optional[pulumi.Input[_builtins.str]]:
        return pulumi.get(self, "description")

    @description.setter
    def description(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "description", value)


if not MYPY:
    class EnvironmentNodeConfigArgsDict(TypedDict):
        current_aggregate_node_count: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        The current total number of gateway nodes that each environment currently has across
        all instances.
        """
        max_node_count: NotRequired[pulumi.Input[_builtins.str]]
        """
        The maximum total number of gateway nodes that the is reserved for all instances that
        has the specified environment. If not specified, the default is determined by the
        recommended maximum number of nodes for that gateway.
        """
        min_node_count: NotRequired[pulumi.Input[_builtins.str]]
        """
        The minimum total number of gateway nodes that the is reserved for all instances that
        has the specified environment. If not specified, the default is determined by the
        recommended minimum number of nodes for that gateway.
        """
elif False:
    EnvironmentNodeConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentNodeConfigArgs:
    def __init__(__self__, *,
                 current_aggregate_node_count: Optional[pulumi.Input[_builtins.str]] = None,
                 max_node_count: Optional[pulumi.Input[_builtins.str]] = None,
                 min_node_count: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] current_aggregate_node_count: (Output)
               The current total number of gateway nodes that each environment currently has across
               all instances.
        :param pulumi.Input[_builtins.str] max_node_count: The maximum total number of gateway nodes that the is reserved for all instances that
               has the specified environment. If not specified, the default is determined by the
               recommended maximum number of nodes for that gateway.
        :param pulumi.Input[_builtins.str] min_node_count: The minimum total number of gateway nodes that the is reserved for all instances that
               has the specified environment. If not specified, the default is determined by the
               recommended minimum number of nodes for that gateway.
        """
        if current_aggregate_node_count is not None:
            pulumi.set(__self__, "current_aggregate_node_count", current_aggregate_node_count)
        if max_node_count is not None:
            pulumi.set(__self__, "max_node_count", max_node_count)
        if min_node_count is not None:
            pulumi.set(__self__, "min_node_count", min_node_count)

    @_builtins.property
    @pulumi.getter(name="currentAggregateNodeCount")
    def current_aggregate_node_count(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        The current total number of gateway nodes that each environment currently has across
        all instances.
        """
        return pulumi.get(self, "current_aggregate_node_count")

    @current_aggregate_node_count.setter
    def current_aggregate_node_count(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "current_aggregate_node_count", value)

    @_builtins.property
    @pulumi.getter(name="maxNodeCount")
    def max_node_count(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The maximum total number of gateway nodes that the is reserved for all instances that
        has the specified environment. If not specified, the default is determined by the
        recommended maximum number of nodes for that gateway.
        """
        return pulumi.get(self, "max_node_count")

    @max_node_count.setter
    def max_node_count(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "max_node_count", value)

    @_builtins.property
    @pulumi.getter(name="minNodeCount")
    def min_node_count(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The minimum total number of gateway nodes that the is reserved for all instances that
        has the specified environment. If not specified, the default is determined by the
        recommended minimum number of nodes for that gateway.
        """
        return pulumi.get(self, "min_node_count")

    @min_node_count.setter
    def min_node_count(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "min_node_count", value)


if not MYPY:
    class EnvironmentPropertiesArgsDict(TypedDict):
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['EnvironmentPropertiesPropertyArgsDict']]]]
        """
        List of all properties in the object.
        Structure is documented below.
        """
elif False:
    EnvironmentPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentPropertiesArgs:
    def __init__(__self__, *,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentPropertiesPropertyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['EnvironmentPropertiesPropertyArgs']]] properties: List of all properties in the object.
               Structure is documented below.
        """
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentPropertiesPropertyArgs']]]]:
        """
        List of all properties in the object.
        Structure is documented below.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['EnvironmentPropertiesPropertyArgs']]]]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class EnvironmentPropertiesPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The property key.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The property value.
        """
elif False:
    EnvironmentPropertiesPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class EnvironmentPropertiesPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The property key.
        :param pulumi.Input[_builtins.str] value: The property value.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The property key.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The property value.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class InstanceAccessLoggingConfigArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Boolean flag that specifies whether the customer access log feature is enabled.
        """
        filter: NotRequired[pulumi.Input[_builtins.str]]
        """
        Ship the access log entries that match the statusCode defined in the filter.
        The statusCode is the only expected/supported filter field. (Ex: statusCode)
        The filter will parse it to the Common Expression Language semantics for expression
        evaluation to build the filter condition. (Ex: "filter": statusCode >= 200 && statusCode < 300 )
        """
elif False:
    InstanceAccessLoggingConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class InstanceAccessLoggingConfigArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 filter: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Boolean flag that specifies whether the customer access log feature is enabled.
        :param pulumi.Input[_builtins.str] filter: Ship the access log entries that match the statusCode defined in the filter.
               The statusCode is the only expected/supported filter field. (Ex: statusCode)
               The filter will parse it to the Common Expression Language semantics for expression
               evaluation to build the filter condition. (Ex: "filter": statusCode >= 200 && statusCode < 300 )
        """
        pulumi.set(__self__, "enabled", enabled)
        if filter is not None:
            pulumi.set(__self__, "filter", filter)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Boolean flag that specifies whether the customer access log feature is enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def filter(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Ship the access log entries that match the statusCode defined in the filter.
        The statusCode is the only expected/supported filter field. (Ex: statusCode)
        The filter will parse it to the Common Expression Language semantics for expression
        evaluation to build the filter condition. (Ex: "filter": statusCode >= 200 && statusCode < 300 )
        """
        return pulumi.get(self, "filter")

    @filter.setter
    def filter(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "filter", value)


if not MYPY:
    class KeystoresAliasesKeyCertFileCertsInfoArgsDict(TypedDict):
        basic_constraints: pulumi.Input[_builtins.str]
        """
        (Output)
        X.509 basic constraints extension.
        """
        expiry_date: pulumi.Input[_builtins.str]
        """
        (Output)
        X.509 notAfter validity period in milliseconds since epoch.
        """
        is_valid: pulumi.Input[_builtins.str]
        """
        (Output)
        Flag that specifies whether the certificate is valid.
        Flag is set to Yes if the certificate is valid, No if expired, or Not yet if not yet valid.
        """
        issuer: pulumi.Input[_builtins.str]
        """
        (Output)
        X.509 issuer.
        """
        public_key: pulumi.Input[_builtins.str]
        """
        (Output)
        Public key component of the X.509 subject public key info.
        """
        serial_number: pulumi.Input[_builtins.str]
        """
        (Output)
        X.509 serial number.
        """
        sig_alg_name: pulumi.Input[_builtins.str]
        """
        (Output)
        X.509 signatureAlgorithm.
        """
        subject: pulumi.Input[_builtins.str]
        """
        (Output)
        X.509 subject.
        """
        subject_alternative_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]
        """
        (Output)
        X.509 subject alternative names (SANs) extension.
        """
        valid_from: pulumi.Input[_builtins.str]
        """
        (Output)
        X.509 notBefore validity period in milliseconds since epoch.
        """
        version: pulumi.Input[_builtins.int]
        """
        (Output)
        X.509 version.
        """
elif False:
    KeystoresAliasesKeyCertFileCertsInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeystoresAliasesKeyCertFileCertsInfoArgs:
    def __init__(__self__, *,
                 basic_constraints: pulumi.Input[_builtins.str],
                 expiry_date: pulumi.Input[_builtins.str],
                 is_valid: pulumi.Input[_builtins.str],
                 issuer: pulumi.Input[_builtins.str],
                 public_key: pulumi.Input[_builtins.str],
                 serial_number: pulumi.Input[_builtins.str],
                 sig_alg_name: pulumi.Input[_builtins.str],
                 subject: pulumi.Input[_builtins.str],
                 subject_alternative_names: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]],
                 valid_from: pulumi.Input[_builtins.str],
                 version: pulumi.Input[_builtins.int]):
        """
        :param pulumi.Input[_builtins.str] basic_constraints: (Output)
               X.509 basic constraints extension.
        :param pulumi.Input[_builtins.str] expiry_date: (Output)
               X.509 notAfter validity period in milliseconds since epoch.
        :param pulumi.Input[_builtins.str] is_valid: (Output)
               Flag that specifies whether the certificate is valid.
               Flag is set to Yes if the certificate is valid, No if expired, or Not yet if not yet valid.
        :param pulumi.Input[_builtins.str] issuer: (Output)
               X.509 issuer.
        :param pulumi.Input[_builtins.str] public_key: (Output)
               Public key component of the X.509 subject public key info.
        :param pulumi.Input[_builtins.str] serial_number: (Output)
               X.509 serial number.
        :param pulumi.Input[_builtins.str] sig_alg_name: (Output)
               X.509 signatureAlgorithm.
        :param pulumi.Input[_builtins.str] subject: (Output)
               X.509 subject.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subject_alternative_names: (Output)
               X.509 subject alternative names (SANs) extension.
        :param pulumi.Input[_builtins.str] valid_from: (Output)
               X.509 notBefore validity period in milliseconds since epoch.
        :param pulumi.Input[_builtins.int] version: (Output)
               X.509 version.
        """
        pulumi.set(__self__, "basic_constraints", basic_constraints)
        pulumi.set(__self__, "expiry_date", expiry_date)
        pulumi.set(__self__, "is_valid", is_valid)
        pulumi.set(__self__, "issuer", issuer)
        pulumi.set(__self__, "public_key", public_key)
        pulumi.set(__self__, "serial_number", serial_number)
        pulumi.set(__self__, "sig_alg_name", sig_alg_name)
        pulumi.set(__self__, "subject", subject)
        pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)
        pulumi.set(__self__, "valid_from", valid_from)
        pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="basicConstraints")
    def basic_constraints(self) -> pulumi.Input[_builtins.str]:
        """
        (Output)
        X.509 basic constraints extension.
        """
        return pulumi.get(self, "basic_constraints")

    @basic_constraints.setter
    def basic_constraints(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "basic_constraints", value)

    @_builtins.property
    @pulumi.getter(name="expiryDate")
    def expiry_date(self) -> pulumi.Input[_builtins.str]:
        """
        (Output)
        X.509 notAfter validity period in milliseconds since epoch.
        """
        return pulumi.get(self, "expiry_date")

    @expiry_date.setter
    def expiry_date(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "expiry_date", value)

    @_builtins.property
    @pulumi.getter(name="isValid")
    def is_valid(self) -> pulumi.Input[_builtins.str]:
        """
        (Output)
        Flag that specifies whether the certificate is valid.
        Flag is set to Yes if the certificate is valid, No if expired, or Not yet if not yet valid.
        """
        return pulumi.get(self, "is_valid")

    @is_valid.setter
    def is_valid(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "is_valid", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> pulumi.Input[_builtins.str]:
        """
        (Output)
        X.509 issuer.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> pulumi.Input[_builtins.str]:
        """
        (Output)
        Public key component of the X.509 subject public key info.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> pulumi.Input[_builtins.str]:
        """
        (Output)
        X.509 serial number.
        """
        return pulumi.get(self, "serial_number")

    @serial_number.setter
    def serial_number(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "serial_number", value)

    @_builtins.property
    @pulumi.getter(name="sigAlgName")
    def sig_alg_name(self) -> pulumi.Input[_builtins.str]:
        """
        (Output)
        X.509 signatureAlgorithm.
        """
        return pulumi.get(self, "sig_alg_name")

    @sig_alg_name.setter
    def sig_alg_name(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "sig_alg_name", value)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> pulumi.Input[_builtins.str]:
        """
        (Output)
        X.509 subject.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "subject", value)

    @_builtins.property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]:
        """
        (Output)
        X.509 subject alternative names (SANs) extension.
        """
        return pulumi.get(self, "subject_alternative_names")

    @subject_alternative_names.setter
    def subject_alternative_names(self, value: pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]):
        pulumi.set(self, "subject_alternative_names", value)

    @_builtins.property
    @pulumi.getter(name="validFrom")
    def valid_from(self) -> pulumi.Input[_builtins.str]:
        """
        (Output)
        X.509 notBefore validity period in milliseconds since epoch.
        """
        return pulumi.get(self, "valid_from")

    @valid_from.setter
    def valid_from(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "valid_from", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> pulumi.Input[_builtins.int]:
        """
        (Output)
        X.509 version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: pulumi.Input[_builtins.int]):
        pulumi.set(self, "version", value)


if not MYPY:
    class KeystoresAliasesKeyCertFileTimeoutsArgsDict(TypedDict):
        create: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        delete: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        read: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        update: NotRequired[pulumi.Input[_builtins.str]]
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
elif False:
    KeystoresAliasesKeyCertFileTimeoutsArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeystoresAliasesKeyCertFileTimeoutsArgs:
    def __init__(__self__, *,
                 create: Optional[pulumi.Input[_builtins.str]] = None,
                 delete: Optional[pulumi.Input[_builtins.str]] = None,
                 read: Optional[pulumi.Input[_builtins.str]] = None,
                 update: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] create: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        :param pulumi.Input[_builtins.str] delete: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        :param pulumi.Input[_builtins.str] read: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        :param pulumi.Input[_builtins.str] update: A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        if create is not None:
            pulumi.set(__self__, "create", create)
        if delete is not None:
            pulumi.set(__self__, "delete", delete)
        if read is not None:
            pulumi.set(__self__, "read", read)
        if update is not None:
            pulumi.set(__self__, "update", update)

    @_builtins.property
    @pulumi.getter
    def create(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "create")

    @create.setter
    def create(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "create", value)

    @_builtins.property
    @pulumi.getter
    def delete(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Setting a timeout for a Delete operation is only applicable if changes are saved into state before the destroy operation occurs.
        """
        return pulumi.get(self, "delete")

    @delete.setter
    def delete(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "delete", value)

    @_builtins.property
    @pulumi.getter
    def read(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours). Read operations occur during any refresh or planning operation when refresh is enabled.
        """
        return pulumi.get(self, "read")

    @read.setter
    def read(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "read", value)

    @_builtins.property
    @pulumi.getter
    def update(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        A string that can be [parsed as a duration](https://pkg.go.dev/time#ParseDuration) consisting of numbers and unit suffixes, such as "30s" or "2h45m". Valid time units are "s" (seconds), "m" (minutes), "h" (hours).
        """
        return pulumi.get(self, "update")

    @update.setter
    def update(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "update", value)


if not MYPY:
    class KeystoresAliasesPkcs12CertsInfoArgsDict(TypedDict):
        cert_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['KeystoresAliasesPkcs12CertsInfoCertInfoArgsDict']]]]
        """
        (Output)
        List of all properties in the object.
        Structure is documented below.
        """
elif False:
    KeystoresAliasesPkcs12CertsInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeystoresAliasesPkcs12CertsInfoArgs:
    def __init__(__self__, *,
                 cert_infos: Optional[pulumi.Input[Sequence[pulumi.Input['KeystoresAliasesPkcs12CertsInfoCertInfoArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['KeystoresAliasesPkcs12CertsInfoCertInfoArgs']]] cert_infos: (Output)
               List of all properties in the object.
               Structure is documented below.
        """
        if cert_infos is not None:
            pulumi.set(__self__, "cert_infos", cert_infos)

    @_builtins.property
    @pulumi.getter(name="certInfos")
    def cert_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KeystoresAliasesPkcs12CertsInfoCertInfoArgs']]]]:
        """
        (Output)
        List of all properties in the object.
        Structure is documented below.
        """
        return pulumi.get(self, "cert_infos")

    @cert_infos.setter
    def cert_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KeystoresAliasesPkcs12CertsInfoCertInfoArgs']]]]):
        pulumi.set(self, "cert_infos", value)


if not MYPY:
    class KeystoresAliasesPkcs12CertsInfoCertInfoArgsDict(TypedDict):
        basic_constraints: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        X.509 basic constraints extension.
        """
        expiry_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        X.509 notAfter validity period in milliseconds since epoch.
        """
        is_valid: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Flag that specifies whether the certificate is valid.
        Flag is set to Yes if the certificate is valid, No if expired, or Not yet if not yet valid.
        """
        issuer: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        X.509 issuer.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Public key component of the X.509 subject public key info.
        """
        serial_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        X.509 serial number.
        """
        sig_alg_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        X.509 signatureAlgorithm.
        """
        subject: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        X.509 subject.
        """
        subject_alternative_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        X.509 subject alternative names (SANs) extension.
        """
        valid_from: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        X.509 notBefore validity period in milliseconds since epoch.
        """
        version: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Output)
        X.509 version.
        """
elif False:
    KeystoresAliasesPkcs12CertsInfoCertInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeystoresAliasesPkcs12CertsInfoCertInfoArgs:
    def __init__(__self__, *,
                 basic_constraints: Optional[pulumi.Input[_builtins.str]] = None,
                 expiry_date: Optional[pulumi.Input[_builtins.str]] = None,
                 is_valid: Optional[pulumi.Input[_builtins.str]] = None,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 serial_number: Optional[pulumi.Input[_builtins.str]] = None,
                 sig_alg_name: Optional[pulumi.Input[_builtins.str]] = None,
                 subject: Optional[pulumi.Input[_builtins.str]] = None,
                 subject_alternative_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 valid_from: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] basic_constraints: (Output)
               X.509 basic constraints extension.
        :param pulumi.Input[_builtins.str] expiry_date: (Output)
               X.509 notAfter validity period in milliseconds since epoch.
        :param pulumi.Input[_builtins.str] is_valid: (Output)
               Flag that specifies whether the certificate is valid.
               Flag is set to Yes if the certificate is valid, No if expired, or Not yet if not yet valid.
        :param pulumi.Input[_builtins.str] issuer: (Output)
               X.509 issuer.
        :param pulumi.Input[_builtins.str] public_key: (Output)
               Public key component of the X.509 subject public key info.
        :param pulumi.Input[_builtins.str] serial_number: (Output)
               X.509 serial number.
        :param pulumi.Input[_builtins.str] sig_alg_name: (Output)
               X.509 signatureAlgorithm.
        :param pulumi.Input[_builtins.str] subject: (Output)
               X.509 subject.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subject_alternative_names: (Output)
               X.509 subject alternative names (SANs) extension.
        :param pulumi.Input[_builtins.str] valid_from: (Output)
               X.509 notBefore validity period in milliseconds since epoch.
        :param pulumi.Input[_builtins.int] version: (Output)
               X.509 version.
        """
        if basic_constraints is not None:
            pulumi.set(__self__, "basic_constraints", basic_constraints)
        if expiry_date is not None:
            pulumi.set(__self__, "expiry_date", expiry_date)
        if is_valid is not None:
            pulumi.set(__self__, "is_valid", is_valid)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if sig_alg_name is not None:
            pulumi.set(__self__, "sig_alg_name", sig_alg_name)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if subject_alternative_names is not None:
            pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)
        if valid_from is not None:
            pulumi.set(__self__, "valid_from", valid_from)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="basicConstraints")
    def basic_constraints(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        X.509 basic constraints extension.
        """
        return pulumi.get(self, "basic_constraints")

    @basic_constraints.setter
    def basic_constraints(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "basic_constraints", value)

    @_builtins.property
    @pulumi.getter(name="expiryDate")
    def expiry_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        X.509 notAfter validity period in milliseconds since epoch.
        """
        return pulumi.get(self, "expiry_date")

    @expiry_date.setter
    def expiry_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expiry_date", value)

    @_builtins.property
    @pulumi.getter(name="isValid")
    def is_valid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Flag that specifies whether the certificate is valid.
        Flag is set to Yes if the certificate is valid, No if expired, or Not yet if not yet valid.
        """
        return pulumi.get(self, "is_valid")

    @is_valid.setter
    def is_valid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_valid", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        X.509 issuer.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Public key component of the X.509 subject public key info.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        X.509 serial number.
        """
        return pulumi.get(self, "serial_number")

    @serial_number.setter
    def serial_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial_number", value)

    @_builtins.property
    @pulumi.getter(name="sigAlgName")
    def sig_alg_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        X.509 signatureAlgorithm.
        """
        return pulumi.get(self, "sig_alg_name")

    @sig_alg_name.setter
    def sig_alg_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sig_alg_name", value)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        X.509 subject.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subject", value)

    @_builtins.property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        X.509 subject alternative names (SANs) extension.
        """
        return pulumi.get(self, "subject_alternative_names")

    @subject_alternative_names.setter
    def subject_alternative_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "subject_alternative_names", value)

    @_builtins.property
    @pulumi.getter(name="validFrom")
    def valid_from(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        X.509 notBefore validity period in milliseconds since epoch.
        """
        return pulumi.get(self, "valid_from")

    @valid_from.setter
    def valid_from(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "valid_from", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Output)
        X.509 version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class KeystoresAliasesSelfSignedCertCertsInfoArgsDict(TypedDict):
        cert_infos: NotRequired[pulumi.Input[Sequence[pulumi.Input['KeystoresAliasesSelfSignedCertCertsInfoCertInfoArgsDict']]]]
        """
        (Output)
        List of all properties in the object.
        Structure is documented below.
        """
elif False:
    KeystoresAliasesSelfSignedCertCertsInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeystoresAliasesSelfSignedCertCertsInfoArgs:
    def __init__(__self__, *,
                 cert_infos: Optional[pulumi.Input[Sequence[pulumi.Input['KeystoresAliasesSelfSignedCertCertsInfoCertInfoArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['KeystoresAliasesSelfSignedCertCertsInfoCertInfoArgs']]] cert_infos: (Output)
               List of all properties in the object.
               Structure is documented below.
        """
        if cert_infos is not None:
            pulumi.set(__self__, "cert_infos", cert_infos)

    @_builtins.property
    @pulumi.getter(name="certInfos")
    def cert_infos(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['KeystoresAliasesSelfSignedCertCertsInfoCertInfoArgs']]]]:
        """
        (Output)
        List of all properties in the object.
        Structure is documented below.
        """
        return pulumi.get(self, "cert_infos")

    @cert_infos.setter
    def cert_infos(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['KeystoresAliasesSelfSignedCertCertsInfoCertInfoArgs']]]]):
        pulumi.set(self, "cert_infos", value)


if not MYPY:
    class KeystoresAliasesSelfSignedCertCertsInfoCertInfoArgsDict(TypedDict):
        basic_constraints: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        X.509 basic constraints extension.
        """
        expiry_date: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        X.509 notAfter validity period in milliseconds since epoch.
        """
        is_valid: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Flag that specifies whether the certificate is valid.
        Flag is set to Yes if the certificate is valid, No if expired, or Not yet if not yet valid.
        """
        issuer: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        X.509 issuer.
        """
        public_key: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        Public key component of the X.509 subject public key info.
        """
        serial_number: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        X.509 serial number.
        """
        sig_alg_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        X.509 signatureAlgorithm.
        """
        subject: NotRequired[pulumi.Input[_builtins.str]]
        """
        Subject details.
        Structure is documented below.
        """
        subject_alternative_names: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        (Output)
        X.509 subject alternative names (SANs) extension.
        """
        valid_from: NotRequired[pulumi.Input[_builtins.str]]
        """
        (Output)
        X.509 notBefore validity period in milliseconds since epoch.
        """
        version: NotRequired[pulumi.Input[_builtins.int]]
        """
        (Output)
        X.509 version.
        """
elif False:
    KeystoresAliasesSelfSignedCertCertsInfoCertInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeystoresAliasesSelfSignedCertCertsInfoCertInfoArgs:
    def __init__(__self__, *,
                 basic_constraints: Optional[pulumi.Input[_builtins.str]] = None,
                 expiry_date: Optional[pulumi.Input[_builtins.str]] = None,
                 is_valid: Optional[pulumi.Input[_builtins.str]] = None,
                 issuer: Optional[pulumi.Input[_builtins.str]] = None,
                 public_key: Optional[pulumi.Input[_builtins.str]] = None,
                 serial_number: Optional[pulumi.Input[_builtins.str]] = None,
                 sig_alg_name: Optional[pulumi.Input[_builtins.str]] = None,
                 subject: Optional[pulumi.Input[_builtins.str]] = None,
                 subject_alternative_names: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 valid_from: Optional[pulumi.Input[_builtins.str]] = None,
                 version: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.str] basic_constraints: (Output)
               X.509 basic constraints extension.
        :param pulumi.Input[_builtins.str] expiry_date: (Output)
               X.509 notAfter validity period in milliseconds since epoch.
        :param pulumi.Input[_builtins.str] is_valid: (Output)
               Flag that specifies whether the certificate is valid.
               Flag is set to Yes if the certificate is valid, No if expired, or Not yet if not yet valid.
        :param pulumi.Input[_builtins.str] issuer: (Output)
               X.509 issuer.
        :param pulumi.Input[_builtins.str] public_key: (Output)
               Public key component of the X.509 subject public key info.
        :param pulumi.Input[_builtins.str] serial_number: (Output)
               X.509 serial number.
        :param pulumi.Input[_builtins.str] sig_alg_name: (Output)
               X.509 signatureAlgorithm.
        :param pulumi.Input[_builtins.str] subject: Subject details.
               Structure is documented below.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] subject_alternative_names: (Output)
               X.509 subject alternative names (SANs) extension.
        :param pulumi.Input[_builtins.str] valid_from: (Output)
               X.509 notBefore validity period in milliseconds since epoch.
        :param pulumi.Input[_builtins.int] version: (Output)
               X.509 version.
        """
        if basic_constraints is not None:
            pulumi.set(__self__, "basic_constraints", basic_constraints)
        if expiry_date is not None:
            pulumi.set(__self__, "expiry_date", expiry_date)
        if is_valid is not None:
            pulumi.set(__self__, "is_valid", is_valid)
        if issuer is not None:
            pulumi.set(__self__, "issuer", issuer)
        if public_key is not None:
            pulumi.set(__self__, "public_key", public_key)
        if serial_number is not None:
            pulumi.set(__self__, "serial_number", serial_number)
        if sig_alg_name is not None:
            pulumi.set(__self__, "sig_alg_name", sig_alg_name)
        if subject is not None:
            pulumi.set(__self__, "subject", subject)
        if subject_alternative_names is not None:
            pulumi.set(__self__, "subject_alternative_names", subject_alternative_names)
        if valid_from is not None:
            pulumi.set(__self__, "valid_from", valid_from)
        if version is not None:
            pulumi.set(__self__, "version", version)

    @_builtins.property
    @pulumi.getter(name="basicConstraints")
    def basic_constraints(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        X.509 basic constraints extension.
        """
        return pulumi.get(self, "basic_constraints")

    @basic_constraints.setter
    def basic_constraints(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "basic_constraints", value)

    @_builtins.property
    @pulumi.getter(name="expiryDate")
    def expiry_date(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        X.509 notAfter validity period in milliseconds since epoch.
        """
        return pulumi.get(self, "expiry_date")

    @expiry_date.setter
    def expiry_date(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "expiry_date", value)

    @_builtins.property
    @pulumi.getter(name="isValid")
    def is_valid(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Flag that specifies whether the certificate is valid.
        Flag is set to Yes if the certificate is valid, No if expired, or Not yet if not yet valid.
        """
        return pulumi.get(self, "is_valid")

    @is_valid.setter
    def is_valid(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "is_valid", value)

    @_builtins.property
    @pulumi.getter
    def issuer(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        X.509 issuer.
        """
        return pulumi.get(self, "issuer")

    @issuer.setter
    def issuer(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "issuer", value)

    @_builtins.property
    @pulumi.getter(name="publicKey")
    def public_key(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        Public key component of the X.509 subject public key info.
        """
        return pulumi.get(self, "public_key")

    @public_key.setter
    def public_key(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "public_key", value)

    @_builtins.property
    @pulumi.getter(name="serialNumber")
    def serial_number(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        X.509 serial number.
        """
        return pulumi.get(self, "serial_number")

    @serial_number.setter
    def serial_number(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "serial_number", value)

    @_builtins.property
    @pulumi.getter(name="sigAlgName")
    def sig_alg_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        X.509 signatureAlgorithm.
        """
        return pulumi.get(self, "sig_alg_name")

    @sig_alg_name.setter
    def sig_alg_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sig_alg_name", value)

    @_builtins.property
    @pulumi.getter
    def subject(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Subject details.
        Structure is documented below.
        """
        return pulumi.get(self, "subject")

    @subject.setter
    def subject(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subject", value)

    @_builtins.property
    @pulumi.getter(name="subjectAlternativeNames")
    def subject_alternative_names(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        (Output)
        X.509 subject alternative names (SANs) extension.
        """
        return pulumi.get(self, "subject_alternative_names")

    @subject_alternative_names.setter
    def subject_alternative_names(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "subject_alternative_names", value)

    @_builtins.property
    @pulumi.getter(name="validFrom")
    def valid_from(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        (Output)
        X.509 notBefore validity period in milliseconds since epoch.
        """
        return pulumi.get(self, "valid_from")

    @valid_from.setter
    def valid_from(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "valid_from", value)

    @_builtins.property
    @pulumi.getter
    def version(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        (Output)
        X.509 version.
        """
        return pulumi.get(self, "version")

    @version.setter
    def version(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "version", value)


if not MYPY:
    class KeystoresAliasesSelfSignedCertSubjectArgsDict(TypedDict):
        common_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Common name of the organization. Maximum length is 64 characters.
        """
        country_code: NotRequired[pulumi.Input[_builtins.str]]
        """
        Two-letter country code. Example, IN for India, US for United States of America.
        """
        email: NotRequired[pulumi.Input[_builtins.str]]
        """
        Email address. Max 255 characters.
        """
        locality: NotRequired[pulumi.Input[_builtins.str]]
        """
        City or town name. Maximum length is 128 characters.
        """
        org: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organization name. Maximum length is 64 characters.
        """
        org_unit: NotRequired[pulumi.Input[_builtins.str]]
        """
        Organization team name. Maximum length is 64 characters.
        """
        state: NotRequired[pulumi.Input[_builtins.str]]
        """
        State or district name. Maximum length is 128 characters.
        """
elif False:
    KeystoresAliasesSelfSignedCertSubjectArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeystoresAliasesSelfSignedCertSubjectArgs:
    def __init__(__self__, *,
                 common_name: Optional[pulumi.Input[_builtins.str]] = None,
                 country_code: Optional[pulumi.Input[_builtins.str]] = None,
                 email: Optional[pulumi.Input[_builtins.str]] = None,
                 locality: Optional[pulumi.Input[_builtins.str]] = None,
                 org: Optional[pulumi.Input[_builtins.str]] = None,
                 org_unit: Optional[pulumi.Input[_builtins.str]] = None,
                 state: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] common_name: Common name of the organization. Maximum length is 64 characters.
        :param pulumi.Input[_builtins.str] country_code: Two-letter country code. Example, IN for India, US for United States of America.
        :param pulumi.Input[_builtins.str] email: Email address. Max 255 characters.
        :param pulumi.Input[_builtins.str] locality: City or town name. Maximum length is 128 characters.
        :param pulumi.Input[_builtins.str] org: Organization name. Maximum length is 64 characters.
        :param pulumi.Input[_builtins.str] org_unit: Organization team name. Maximum length is 64 characters.
        :param pulumi.Input[_builtins.str] state: State or district name. Maximum length is 128 characters.
        """
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if country_code is not None:
            pulumi.set(__self__, "country_code", country_code)
        if email is not None:
            pulumi.set(__self__, "email", email)
        if locality is not None:
            pulumi.set(__self__, "locality", locality)
        if org is not None:
            pulumi.set(__self__, "org", org)
        if org_unit is not None:
            pulumi.set(__self__, "org_unit", org_unit)
        if state is not None:
            pulumi.set(__self__, "state", state)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Common name of the organization. Maximum length is 64 characters.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter(name="countryCode")
    def country_code(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Two-letter country code. Example, IN for India, US for United States of America.
        """
        return pulumi.get(self, "country_code")

    @country_code.setter
    def country_code(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "country_code", value)

    @_builtins.property
    @pulumi.getter
    def email(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Email address. Max 255 characters.
        """
        return pulumi.get(self, "email")

    @email.setter
    def email(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "email", value)

    @_builtins.property
    @pulumi.getter
    def locality(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        City or town name. Maximum length is 128 characters.
        """
        return pulumi.get(self, "locality")

    @locality.setter
    def locality(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "locality", value)

    @_builtins.property
    @pulumi.getter
    def org(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organization name. Maximum length is 64 characters.
        """
        return pulumi.get(self, "org")

    @org.setter
    def org(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "org", value)

    @_builtins.property
    @pulumi.getter(name="orgUnit")
    def org_unit(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Organization team name. Maximum length is 64 characters.
        """
        return pulumi.get(self, "org_unit")

    @org_unit.setter
    def org_unit(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "org_unit", value)

    @_builtins.property
    @pulumi.getter
    def state(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        State or district name. Maximum length is 128 characters.
        """
        return pulumi.get(self, "state")

    @state.setter
    def state(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "state", value)


if not MYPY:
    class KeystoresAliasesSelfSignedCertSubjectAlternativeDnsNamesArgsDict(TypedDict):
        subject_alternative_name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Subject Alternative Name
        """
elif False:
    KeystoresAliasesSelfSignedCertSubjectAlternativeDnsNamesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class KeystoresAliasesSelfSignedCertSubjectAlternativeDnsNamesArgs:
    def __init__(__self__, *,
                 subject_alternative_name: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] subject_alternative_name: Subject Alternative Name
        """
        if subject_alternative_name is not None:
            pulumi.set(__self__, "subject_alternative_name", subject_alternative_name)

    @_builtins.property
    @pulumi.getter(name="subjectAlternativeName")
    def subject_alternative_name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Subject Alternative Name
        """
        return pulumi.get(self, "subject_alternative_name")

    @subject_alternative_name.setter
    def subject_alternative_name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "subject_alternative_name", value)


if not MYPY:
    class OrganizationPropertiesArgsDict(TypedDict):
        properties: NotRequired[pulumi.Input[Sequence[pulumi.Input['OrganizationPropertiesPropertyArgsDict']]]]
        """
        List of all properties in the object.
        Structure is documented below.
        """
elif False:
    OrganizationPropertiesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationPropertiesArgs:
    def __init__(__self__, *,
                 properties: Optional[pulumi.Input[Sequence[pulumi.Input['OrganizationPropertiesPropertyArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['OrganizationPropertiesPropertyArgs']]] properties: List of all properties in the object.
               Structure is documented below.
        """
        if properties is not None:
            pulumi.set(__self__, "properties", properties)

    @_builtins.property
    @pulumi.getter
    def properties(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['OrganizationPropertiesPropertyArgs']]]]:
        """
        List of all properties in the object.
        Structure is documented below.
        """
        return pulumi.get(self, "properties")

    @properties.setter
    def properties(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['OrganizationPropertiesPropertyArgs']]]]):
        pulumi.set(self, "properties", value)


if not MYPY:
    class OrganizationPropertiesPropertyArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        Name of the property.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        Value of the property.
        """
elif False:
    OrganizationPropertiesPropertyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class OrganizationPropertiesPropertyArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: Name of the property.
        :param pulumi.Input[_builtins.str] value: Value of the property.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Name of the property.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Value of the property.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SecurityActionAllowArgsDict(TypedDict):
        pass
elif False:
    SecurityActionAllowArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityActionAllowArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class SecurityActionConditionConfigArgsDict(TypedDict):
        access_tokens: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of accessTokens. Limit 1000 per action.
        """
        api_keys: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of API keys. Limit 1000 per action.
        """
        api_products: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of API Products. Limit 1000 per action.
        """
        asns: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of ASN numbers to act on, e.g. 23. https://en.wikipedia.org/wiki/Autonomous_system_(Internet)
        This uses int64 instead of uint32 because of https://linter.aip.dev/141/forbidden-types.
        """
        bot_reasons: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of Bot Reasons. Current options: Flooder, Brute Guessor, Static Content Scraper,
        OAuth Abuser, Robot Abuser, TorListRule, Advanced Anomaly Detection, Advanced API Scraper,
        Search Engine Crawlers, Public Clouds, Public Cloud AWS, Public Cloud Azure, and Public Cloud Google.
        """
        developer_apps: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of developer apps. Limit 1000 per action.
        """
        developers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of developers. Limit 1000 per action.
        """
        http_methods: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        Act only on particular HTTP methods. E.g. A read-only API can block POST/PUT/DELETE methods.
        Accepted values are: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE and PATCH.
        """
        ip_address_ranges: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of IP addresses. This could be either IPv4 or IPv6. Limited to 100 per action.
        """
        region_codes: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of countries/region codes to act on, e.g. US. This follows https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2.
        """
        user_agents: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        A list of user agents to deny. We look for exact matches. Limit 50 per action.
        """
elif False:
    SecurityActionConditionConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityActionConditionConfigArgs:
    def __init__(__self__, *,
                 access_tokens: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 api_keys: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 api_products: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 asns: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 bot_reasons: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 developer_apps: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 developers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 http_methods: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 ip_address_ranges: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 region_codes: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 user_agents: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] access_tokens: A list of accessTokens. Limit 1000 per action.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] api_keys: A list of API keys. Limit 1000 per action.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] api_products: A list of API Products. Limit 1000 per action.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] asns: A list of ASN numbers to act on, e.g. 23. https://en.wikipedia.org/wiki/Autonomous_system_(Internet)
               This uses int64 instead of uint32 because of https://linter.aip.dev/141/forbidden-types.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] bot_reasons: A list of Bot Reasons. Current options: Flooder, Brute Guessor, Static Content Scraper,
               OAuth Abuser, Robot Abuser, TorListRule, Advanced Anomaly Detection, Advanced API Scraper,
               Search Engine Crawlers, Public Clouds, Public Cloud AWS, Public Cloud Azure, and Public Cloud Google.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] developer_apps: A list of developer apps. Limit 1000 per action.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] developers: A list of developers. Limit 1000 per action.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] http_methods: Act only on particular HTTP methods. E.g. A read-only API can block POST/PUT/DELETE methods.
               Accepted values are: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE and PATCH.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ip_address_ranges: A list of IP addresses. This could be either IPv4 or IPv6. Limited to 100 per action.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] region_codes: A list of countries/region codes to act on, e.g. US. This follows https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] user_agents: A list of user agents to deny. We look for exact matches. Limit 50 per action.
        """
        if access_tokens is not None:
            pulumi.set(__self__, "access_tokens", access_tokens)
        if api_keys is not None:
            pulumi.set(__self__, "api_keys", api_keys)
        if api_products is not None:
            pulumi.set(__self__, "api_products", api_products)
        if asns is not None:
            pulumi.set(__self__, "asns", asns)
        if bot_reasons is not None:
            pulumi.set(__self__, "bot_reasons", bot_reasons)
        if developer_apps is not None:
            pulumi.set(__self__, "developer_apps", developer_apps)
        if developers is not None:
            pulumi.set(__self__, "developers", developers)
        if http_methods is not None:
            pulumi.set(__self__, "http_methods", http_methods)
        if ip_address_ranges is not None:
            pulumi.set(__self__, "ip_address_ranges", ip_address_ranges)
        if region_codes is not None:
            pulumi.set(__self__, "region_codes", region_codes)
        if user_agents is not None:
            pulumi.set(__self__, "user_agents", user_agents)

    @_builtins.property
    @pulumi.getter(name="accessTokens")
    def access_tokens(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of accessTokens. Limit 1000 per action.
        """
        return pulumi.get(self, "access_tokens")

    @access_tokens.setter
    def access_tokens(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "access_tokens", value)

    @_builtins.property
    @pulumi.getter(name="apiKeys")
    def api_keys(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of API keys. Limit 1000 per action.
        """
        return pulumi.get(self, "api_keys")

    @api_keys.setter
    def api_keys(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "api_keys", value)

    @_builtins.property
    @pulumi.getter(name="apiProducts")
    def api_products(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of API Products. Limit 1000 per action.
        """
        return pulumi.get(self, "api_products")

    @api_products.setter
    def api_products(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "api_products", value)

    @_builtins.property
    @pulumi.getter
    def asns(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of ASN numbers to act on, e.g. 23. https://en.wikipedia.org/wiki/Autonomous_system_(Internet)
        This uses int64 instead of uint32 because of https://linter.aip.dev/141/forbidden-types.
        """
        return pulumi.get(self, "asns")

    @asns.setter
    def asns(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "asns", value)

    @_builtins.property
    @pulumi.getter(name="botReasons")
    def bot_reasons(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of Bot Reasons. Current options: Flooder, Brute Guessor, Static Content Scraper,
        OAuth Abuser, Robot Abuser, TorListRule, Advanced Anomaly Detection, Advanced API Scraper,
        Search Engine Crawlers, Public Clouds, Public Cloud AWS, Public Cloud Azure, and Public Cloud Google.
        """
        return pulumi.get(self, "bot_reasons")

    @bot_reasons.setter
    def bot_reasons(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "bot_reasons", value)

    @_builtins.property
    @pulumi.getter(name="developerApps")
    def developer_apps(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of developer apps. Limit 1000 per action.
        """
        return pulumi.get(self, "developer_apps")

    @developer_apps.setter
    def developer_apps(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "developer_apps", value)

    @_builtins.property
    @pulumi.getter
    def developers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of developers. Limit 1000 per action.
        """
        return pulumi.get(self, "developers")

    @developers.setter
    def developers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "developers", value)

    @_builtins.property
    @pulumi.getter(name="httpMethods")
    def http_methods(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        Act only on particular HTTP methods. E.g. A read-only API can block POST/PUT/DELETE methods.
        Accepted values are: GET, HEAD, POST, PUT, DELETE, CONNECT, OPTIONS, TRACE and PATCH.
        """
        return pulumi.get(self, "http_methods")

    @http_methods.setter
    def http_methods(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "http_methods", value)

    @_builtins.property
    @pulumi.getter(name="ipAddressRanges")
    def ip_address_ranges(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of IP addresses. This could be either IPv4 or IPv6. Limited to 100 per action.
        """
        return pulumi.get(self, "ip_address_ranges")

    @ip_address_ranges.setter
    def ip_address_ranges(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ip_address_ranges", value)

    @_builtins.property
    @pulumi.getter(name="regionCodes")
    def region_codes(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of countries/region codes to act on, e.g. US. This follows https://en.wikipedia.org/wiki/ISO_3166-1_alpha-2.
        """
        return pulumi.get(self, "region_codes")

    @region_codes.setter
    def region_codes(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "region_codes", value)

    @_builtins.property
    @pulumi.getter(name="userAgents")
    def user_agents(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        A list of user agents to deny. We look for exact matches. Limit 50 per action.
        """
        return pulumi.get(self, "user_agents")

    @user_agents.setter
    def user_agents(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "user_agents", value)


if not MYPY:
    class SecurityActionDenyArgsDict(TypedDict):
        response_code: NotRequired[pulumi.Input[_builtins.int]]
        """
        The HTTP response code if the Action = DENY.
        """
elif False:
    SecurityActionDenyArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityActionDenyArgs:
    def __init__(__self__, *,
                 response_code: Optional[pulumi.Input[_builtins.int]] = None):
        """
        :param pulumi.Input[_builtins.int] response_code: The HTTP response code if the Action = DENY.
        """
        if response_code is not None:
            pulumi.set(__self__, "response_code", response_code)

    @_builtins.property
    @pulumi.getter(name="responseCode")
    def response_code(self) -> Optional[pulumi.Input[_builtins.int]]:
        """
        The HTTP response code if the Action = DENY.
        """
        return pulumi.get(self, "response_code")

    @response_code.setter
    def response_code(self, value: Optional[pulumi.Input[_builtins.int]]):
        pulumi.set(self, "response_code", value)


if not MYPY:
    class SecurityActionFlagArgsDict(TypedDict):
        headers: NotRequired[pulumi.Input[Sequence[pulumi.Input['SecurityActionFlagHeaderArgsDict']]]]
        """
        A list of HTTP headers to be sent to the target in case of a FLAG SecurityAction.
        Limit 5 headers per SecurityAction.
        At least one is mandatory.
        Structure is documented below.
        """
elif False:
    SecurityActionFlagArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityActionFlagArgs:
    def __init__(__self__, *,
                 headers: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityActionFlagHeaderArgs']]]] = None):
        """
        :param pulumi.Input[Sequence[pulumi.Input['SecurityActionFlagHeaderArgs']]] headers: A list of HTTP headers to be sent to the target in case of a FLAG SecurityAction.
               Limit 5 headers per SecurityAction.
               At least one is mandatory.
               Structure is documented below.
        """
        if headers is not None:
            pulumi.set(__self__, "headers", headers)

    @_builtins.property
    @pulumi.getter
    def headers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input['SecurityActionFlagHeaderArgs']]]]:
        """
        A list of HTTP headers to be sent to the target in case of a FLAG SecurityAction.
        Limit 5 headers per SecurityAction.
        At least one is mandatory.
        Structure is documented below.
        """
        return pulumi.get(self, "headers")

    @headers.setter
    def headers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input['SecurityActionFlagHeaderArgs']]]]):
        pulumi.set(self, "headers", value)


if not MYPY:
    class SecurityActionFlagHeaderArgsDict(TypedDict):
        name: NotRequired[pulumi.Input[_builtins.str]]
        """
        The header name to be sent to the target.
        """
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The header value to be sent to the target.
        """
elif False:
    SecurityActionFlagHeaderArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityActionFlagHeaderArgs:
    def __init__(__self__, *,
                 name: Optional[pulumi.Input[_builtins.str]] = None,
                 value: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] name: The header name to be sent to the target.
        :param pulumi.Input[_builtins.str] value: The header value to be sent to the target.
        """
        if name is not None:
            pulumi.set(__self__, "name", name)
        if value is not None:
            pulumi.set(__self__, "value", value)

    @_builtins.property
    @pulumi.getter
    def name(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The header name to be sent to the target.
        """
        return pulumi.get(self, "name")

    @name.setter
    def name(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "name", value)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The header value to be sent to the target.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)


if not MYPY:
    class SecurityMonitoringConditionIncludeAllResourcesArgsDict(TypedDict):
        pass
elif False:
    SecurityMonitoringConditionIncludeAllResourcesArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityMonitoringConditionIncludeAllResourcesArgs:
    def __init__(__self__):
        pass


if not MYPY:
    class SecurityProfileV2ProfileAssessmentConfigArgsDict(TypedDict):
        assessment: pulumi.Input[_builtins.str]
        """
        The identifier for this object. Format specified above.
        """
        weight: pulumi.Input[_builtins.str]
        """
        The weight of the assessment.
        Possible values are: `MINOR`, `MODERATE`, `MAJOR`.
        """
elif False:
    SecurityProfileV2ProfileAssessmentConfigArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SecurityProfileV2ProfileAssessmentConfigArgs:
    def __init__(__self__, *,
                 assessment: pulumi.Input[_builtins.str],
                 weight: pulumi.Input[_builtins.str]):
        """
        :param pulumi.Input[_builtins.str] assessment: The identifier for this object. Format specified above.
        :param pulumi.Input[_builtins.str] weight: The weight of the assessment.
               Possible values are: `MINOR`, `MODERATE`, `MAJOR`.
        """
        pulumi.set(__self__, "assessment", assessment)
        pulumi.set(__self__, "weight", weight)

    @_builtins.property
    @pulumi.getter
    def assessment(self) -> pulumi.Input[_builtins.str]:
        """
        The identifier for this object. Format specified above.
        """
        return pulumi.get(self, "assessment")

    @assessment.setter
    def assessment(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "assessment", value)

    @_builtins.property
    @pulumi.getter
    def weight(self) -> pulumi.Input[_builtins.str]:
        """
        The weight of the assessment.
        Possible values are: `MINOR`, `MODERATE`, `MAJOR`.
        """
        return pulumi.get(self, "weight")

    @weight.setter
    def weight(self, value: pulumi.Input[_builtins.str]):
        pulumi.set(self, "weight", value)


if not MYPY:
    class SharedflowMetaDataArgsDict(TypedDict):
        created_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time at which the API proxy was created, in milliseconds since epoch.
        """
        last_modified_at: NotRequired[pulumi.Input[_builtins.str]]
        """
        Time at which the API proxy was most recently modified, in milliseconds since epoch.
        """
        sub_type: NotRequired[pulumi.Input[_builtins.str]]
        """
        The type of entity described
        """
elif False:
    SharedflowMetaDataArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class SharedflowMetaDataArgs:
    def __init__(__self__, *,
                 created_at: Optional[pulumi.Input[_builtins.str]] = None,
                 last_modified_at: Optional[pulumi.Input[_builtins.str]] = None,
                 sub_type: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.str] created_at: Time at which the API proxy was created, in milliseconds since epoch.
        :param pulumi.Input[_builtins.str] last_modified_at: Time at which the API proxy was most recently modified, in milliseconds since epoch.
        :param pulumi.Input[_builtins.str] sub_type: The type of entity described
        """
        if created_at is not None:
            pulumi.set(__self__, "created_at", created_at)
        if last_modified_at is not None:
            pulumi.set(__self__, "last_modified_at", last_modified_at)
        if sub_type is not None:
            pulumi.set(__self__, "sub_type", sub_type)

    @_builtins.property
    @pulumi.getter(name="createdAt")
    def created_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time at which the API proxy was created, in milliseconds since epoch.
        """
        return pulumi.get(self, "created_at")

    @created_at.setter
    def created_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "created_at", value)

    @_builtins.property
    @pulumi.getter(name="lastModifiedAt")
    def last_modified_at(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Time at which the API proxy was most recently modified, in milliseconds since epoch.
        """
        return pulumi.get(self, "last_modified_at")

    @last_modified_at.setter
    def last_modified_at(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "last_modified_at", value)

    @_builtins.property
    @pulumi.getter(name="subType")
    def sub_type(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The type of entity described
        """
        return pulumi.get(self, "sub_type")

    @sub_type.setter
    def sub_type(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "sub_type", value)


if not MYPY:
    class TargetServerSSlInfoArgsDict(TypedDict):
        enabled: pulumi.Input[_builtins.bool]
        """
        Enables TLS. If false, neither one-way nor two-way TLS will be enabled.
        """
        ciphers: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The SSL/TLS cipher suites to be used. For programmable proxies, it must be one of the cipher suite names listed in: http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#ciphersuites. For configurable proxies, it must follow the configuration specified in: https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration. This setting has no effect for configurable proxies when negotiating TLS 1.3.
        """
        client_auth_enabled: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Enables two-way TLS.
        """
        common_name: NotRequired[pulumi.Input['TargetServerSSlInfoCommonNameArgsDict']]
        """
        The TLS Common Name of the certificate.
        Structure is documented below.
        """
        enforce: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, TLS is strictly enforced.
        """
        ignore_validation_errors: NotRequired[pulumi.Input[_builtins.bool]]
        """
        If true, Edge ignores TLS certificate errors. Valid when configuring TLS for target servers and target endpoints, and when configuring virtual hosts that use 2-way TLS. When used with a target endpoint/target server, if the backend system uses SNI and returns a cert with a subject Distinguished Name (DN) that does not match the hostname, there is no way to ignore the error and the connection fails.
        """
        key_alias: NotRequired[pulumi.Input[_builtins.str]]
        """
        Required if clientAuthEnabled is true. The resource ID for the alias containing the private key and cert.
        """
        key_store: NotRequired[pulumi.Input[_builtins.str]]
        """
        Required if clientAuthEnabled is true. The resource ID of the keystore.
        """
        protocols: NotRequired[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]
        """
        The TLS versioins to be used.
        """
        trust_store: NotRequired[pulumi.Input[_builtins.str]]
        """
        The resource ID of the truststore.
        """
elif False:
    TargetServerSSlInfoArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetServerSSlInfoArgs:
    def __init__(__self__, *,
                 enabled: pulumi.Input[_builtins.bool],
                 ciphers: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 client_auth_enabled: Optional[pulumi.Input[_builtins.bool]] = None,
                 common_name: Optional[pulumi.Input['TargetServerSSlInfoCommonNameArgs']] = None,
                 enforce: Optional[pulumi.Input[_builtins.bool]] = None,
                 ignore_validation_errors: Optional[pulumi.Input[_builtins.bool]] = None,
                 key_alias: Optional[pulumi.Input[_builtins.str]] = None,
                 key_store: Optional[pulumi.Input[_builtins.str]] = None,
                 protocols: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]] = None,
                 trust_store: Optional[pulumi.Input[_builtins.str]] = None):
        """
        :param pulumi.Input[_builtins.bool] enabled: Enables TLS. If false, neither one-way nor two-way TLS will be enabled.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] ciphers: The SSL/TLS cipher suites to be used. For programmable proxies, it must be one of the cipher suite names listed in: http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#ciphersuites. For configurable proxies, it must follow the configuration specified in: https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration. This setting has no effect for configurable proxies when negotiating TLS 1.3.
        :param pulumi.Input[_builtins.bool] client_auth_enabled: Enables two-way TLS.
        :param pulumi.Input['TargetServerSSlInfoCommonNameArgs'] common_name: The TLS Common Name of the certificate.
               Structure is documented below.
        :param pulumi.Input[_builtins.bool] enforce: If true, TLS is strictly enforced.
        :param pulumi.Input[_builtins.bool] ignore_validation_errors: If true, Edge ignores TLS certificate errors. Valid when configuring TLS for target servers and target endpoints, and when configuring virtual hosts that use 2-way TLS. When used with a target endpoint/target server, if the backend system uses SNI and returns a cert with a subject Distinguished Name (DN) that does not match the hostname, there is no way to ignore the error and the connection fails.
        :param pulumi.Input[_builtins.str] key_alias: Required if clientAuthEnabled is true. The resource ID for the alias containing the private key and cert.
        :param pulumi.Input[_builtins.str] key_store: Required if clientAuthEnabled is true. The resource ID of the keystore.
        :param pulumi.Input[Sequence[pulumi.Input[_builtins.str]]] protocols: The TLS versioins to be used.
        :param pulumi.Input[_builtins.str] trust_store: The resource ID of the truststore.
        """
        pulumi.set(__self__, "enabled", enabled)
        if ciphers is not None:
            pulumi.set(__self__, "ciphers", ciphers)
        if client_auth_enabled is not None:
            pulumi.set(__self__, "client_auth_enabled", client_auth_enabled)
        if common_name is not None:
            pulumi.set(__self__, "common_name", common_name)
        if enforce is not None:
            pulumi.set(__self__, "enforce", enforce)
        if ignore_validation_errors is not None:
            pulumi.set(__self__, "ignore_validation_errors", ignore_validation_errors)
        if key_alias is not None:
            pulumi.set(__self__, "key_alias", key_alias)
        if key_store is not None:
            pulumi.set(__self__, "key_store", key_store)
        if protocols is not None:
            pulumi.set(__self__, "protocols", protocols)
        if trust_store is not None:
            pulumi.set(__self__, "trust_store", trust_store)

    @_builtins.property
    @pulumi.getter
    def enabled(self) -> pulumi.Input[_builtins.bool]:
        """
        Enables TLS. If false, neither one-way nor two-way TLS will be enabled.
        """
        return pulumi.get(self, "enabled")

    @enabled.setter
    def enabled(self, value: pulumi.Input[_builtins.bool]):
        pulumi.set(self, "enabled", value)

    @_builtins.property
    @pulumi.getter
    def ciphers(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The SSL/TLS cipher suites to be used. For programmable proxies, it must be one of the cipher suite names listed in: http://docs.oracle.com/javase/8/docs/technotes/guides/security/StandardNames.html#ciphersuites. For configurable proxies, it must follow the configuration specified in: https://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#Cipher-suite-configuration. This setting has no effect for configurable proxies when negotiating TLS 1.3.
        """
        return pulumi.get(self, "ciphers")

    @ciphers.setter
    def ciphers(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "ciphers", value)

    @_builtins.property
    @pulumi.getter(name="clientAuthEnabled")
    def client_auth_enabled(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Enables two-way TLS.
        """
        return pulumi.get(self, "client_auth_enabled")

    @client_auth_enabled.setter
    def client_auth_enabled(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "client_auth_enabled", value)

    @_builtins.property
    @pulumi.getter(name="commonName")
    def common_name(self) -> Optional[pulumi.Input['TargetServerSSlInfoCommonNameArgs']]:
        """
        The TLS Common Name of the certificate.
        Structure is documented below.
        """
        return pulumi.get(self, "common_name")

    @common_name.setter
    def common_name(self, value: Optional[pulumi.Input['TargetServerSSlInfoCommonNameArgs']]):
        pulumi.set(self, "common_name", value)

    @_builtins.property
    @pulumi.getter
    def enforce(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, TLS is strictly enforced.
        """
        return pulumi.get(self, "enforce")

    @enforce.setter
    def enforce(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "enforce", value)

    @_builtins.property
    @pulumi.getter(name="ignoreValidationErrors")
    def ignore_validation_errors(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        If true, Edge ignores TLS certificate errors. Valid when configuring TLS for target servers and target endpoints, and when configuring virtual hosts that use 2-way TLS. When used with a target endpoint/target server, if the backend system uses SNI and returns a cert with a subject Distinguished Name (DN) that does not match the hostname, there is no way to ignore the error and the connection fails.
        """
        return pulumi.get(self, "ignore_validation_errors")

    @ignore_validation_errors.setter
    def ignore_validation_errors(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "ignore_validation_errors", value)

    @_builtins.property
    @pulumi.getter(name="keyAlias")
    def key_alias(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Required if clientAuthEnabled is true. The resource ID for the alias containing the private key and cert.
        """
        return pulumi.get(self, "key_alias")

    @key_alias.setter
    def key_alias(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_alias", value)

    @_builtins.property
    @pulumi.getter(name="keyStore")
    def key_store(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        Required if clientAuthEnabled is true. The resource ID of the keystore.
        """
        return pulumi.get(self, "key_store")

    @key_store.setter
    def key_store(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "key_store", value)

    @_builtins.property
    @pulumi.getter
    def protocols(self) -> Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]:
        """
        The TLS versioins to be used.
        """
        return pulumi.get(self, "protocols")

    @protocols.setter
    def protocols(self, value: Optional[pulumi.Input[Sequence[pulumi.Input[_builtins.str]]]]):
        pulumi.set(self, "protocols", value)

    @_builtins.property
    @pulumi.getter(name="trustStore")
    def trust_store(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The resource ID of the truststore.
        """
        return pulumi.get(self, "trust_store")

    @trust_store.setter
    def trust_store(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "trust_store", value)


if not MYPY:
    class TargetServerSSlInfoCommonNameArgsDict(TypedDict):
        value: NotRequired[pulumi.Input[_builtins.str]]
        """
        The TLS Common Name string of the certificate.
        """
        wildcard_match: NotRequired[pulumi.Input[_builtins.bool]]
        """
        Indicates whether the cert should be matched against as a wildcard cert.
        """
elif False:
    TargetServerSSlInfoCommonNameArgsDict: TypeAlias = Mapping[str, Any]

@pulumi.input_type
class TargetServerSSlInfoCommonNameArgs:
    def __init__(__self__, *,
                 value: Optional[pulumi.Input[_builtins.str]] = None,
                 wildcard_match: Optional[pulumi.Input[_builtins.bool]] = None):
        """
        :param pulumi.Input[_builtins.str] value: The TLS Common Name string of the certificate.
        :param pulumi.Input[_builtins.bool] wildcard_match: Indicates whether the cert should be matched against as a wildcard cert.
        """
        if value is not None:
            pulumi.set(__self__, "value", value)
        if wildcard_match is not None:
            pulumi.set(__self__, "wildcard_match", wildcard_match)

    @_builtins.property
    @pulumi.getter
    def value(self) -> Optional[pulumi.Input[_builtins.str]]:
        """
        The TLS Common Name string of the certificate.
        """
        return pulumi.get(self, "value")

    @value.setter
    def value(self, value: Optional[pulumi.Input[_builtins.str]]):
        pulumi.set(self, "value", value)

    @_builtins.property
    @pulumi.getter(name="wildcardMatch")
    def wildcard_match(self) -> Optional[pulumi.Input[_builtins.bool]]:
        """
        Indicates whether the cert should be matched against as a wildcard cert.
        """
        return pulumi.get(self, "wildcard_match")

    @wildcard_match.setter
    def wildcard_match(self, value: Optional[pulumi.Input[_builtins.bool]]):
        pulumi.set(self, "wildcard_match", value)


